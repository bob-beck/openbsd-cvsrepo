head	1.147;
access;
symbols;
locks; strict;
comment	@# @;


1.147
date	2014.04.01.17.03.08;	author nick;	state dead;
branches;
next	1.146;

1.146
date	2013.12.06.20.52.46;	author ajacoutot;	state Exp;
branches;
next	1.145;

1.145
date	2013.11.13.07.09.30;	author ajacoutot;	state Exp;
branches;
next	1.144;

1.144
date	2013.11.01.18.04.04;	author ajacoutot;	state Exp;
branches;
next	1.143;

1.143
date	2013.09.10.20.41.21;	author ajacoutot;	state Exp;
branches;
next	1.142;

1.142
date	2013.06.03.22.52.52;	author ajacoutot;	state Exp;
branches;
next	1.141;

1.141
date	2013.05.12.16.04.55;	author ajacoutot;	state Exp;
branches;
next	1.140;

1.140
date	2013.05.01.17.39.06;	author ajacoutot;	state Exp;
branches;
next	1.139;

1.139
date	2013.02.17.08.05.41;	author ajacoutot;	state Exp;
branches;
next	1.138;

1.138
date	2012.11.04.08.15.48;	author ajacoutot;	state Exp;
branches;
next	1.137;

1.137
date	2012.11.02.07.24.04;	author ajacoutot;	state Exp;
branches;
next	1.136;

1.136
date	2012.10.16.16.57.25;	author ajacoutot;	state Exp;
branches;
next	1.135;

1.135
date	2012.08.17.06.29.34;	author ajacoutot;	state Exp;
branches;
next	1.134;

1.134
date	2012.08.14.07.19.41;	author ajacoutot;	state Exp;
branches;
next	1.133;

1.133
date	2012.05.01.19.11.27;	author ajacoutot;	state Exp;
branches;
next	1.132;

1.132
date	2012.04.24.10.44.03;	author ajacoutot;	state Exp;
branches;
next	1.131;

1.131
date	2012.04.16.00.11.30;	author ajacoutot;	state Exp;
branches;
next	1.130;

1.130
date	2012.03.21.19.25.18;	author ajacoutot;	state Exp;
branches;
next	1.129;

1.129
date	2012.01.31.23.04.08;	author ajacoutot;	state Exp;
branches;
next	1.128;

1.128
date	2012.01.21.19.34.37;	author ajacoutot;	state Exp;
branches;
next	1.127;

1.127
date	2011.12.17.21.32.33;	author ajacoutot;	state Exp;
branches;
next	1.126;

1.126
date	2011.12.12.16.22.49;	author ajacoutot;	state Exp;
branches;
next	1.125;

1.125
date	2008.11.01.11.02.21;	author tobias;	state Exp;
branches;
next	1.124;

1.124
date	2008.06.22.21.06.12;	author tobias;	state Exp;
branches;
next	1.123;

1.123
date	2008.05.12.07.23.52;	author tobias;	state Exp;
branches;
next	1.122;

1.122
date	2008.05.01.10.01.51;	author tobias;	state Exp;
branches;
next	1.121;

1.121
date	2008.04.28.08.25.41;	author tobias;	state Exp;
branches;
next	1.120;

1.120
date	2008.03.09.13.37.12;	author tobias;	state Exp;
branches;
next	1.119;

1.119
date	2008.03.02.12.12.59;	author tobias;	state Exp;
branches;
next	1.118;

1.118
date	2008.02.22.10.12.26;	author tobias;	state Exp;
branches;
next	1.117;

1.117
date	2008.01.06.13.57.19;	author tobias;	state Exp;
branches;
next	1.116;

1.116
date	2007.12.30.14.59.17;	author tobias;	state Exp;
branches;
next	1.115;

1.115
date	2007.12.09.14.56.37;	author tobias;	state Exp;
branches;
next	1.114;

1.114
date	2007.11.12.20.29.59;	author saad;	state Exp;
branches;
next	1.113;

1.113
date	2007.06.18.13.02.50;	author jufi;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.10.12.43.45;	author saad;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.01.19.09.08;	author jufi;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.29.22.23.18;	author saad;	state Exp;
branches;
next	1.109;

1.109
date	2007.04.26.03.08.04;	author jufi;	state Exp;
branches;
next	1.108;

1.108
date	2007.03.22.13.09.53;	author jufi;	state Exp;
branches;
next	1.107;

1.107
date	2007.03.22.07.49.17;	author jufi;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.19.17.39.09;	author jufi;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.10.05.22.17;	author saad;	state Exp;
branches;
next	1.104;

1.104
date	2006.11.01.11.30.45;	author jufi;	state Exp;
branches;
next	1.103;

1.103
date	2006.10.29.10.58.52;	author jufi;	state Exp;
branches;
next	1.102;

1.102
date	2006.09.07.22.06.56;	author saad;	state Exp;
branches;
next	1.101;

1.101
date	2006.08.23.14.47.08;	author jufi;	state Exp;
branches;
next	1.100;

1.100
date	2006.08.08.07.14.20;	author saad;	state Exp;
branches;
next	1.99;

1.99
date	2006.06.01.06.33.43;	author jufi;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.24.06.48.44;	author jufi;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.15.09.15.50;	author jufi;	state Exp;
branches;
next	1.96;

1.96
date	2006.05.01.12.19.17;	author jufi;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.25.08.25.48;	author saad;	state Exp;
branches;
next	1.94;

1.94
date	2006.03.26.19.07.21;	author jufi;	state Exp;
branches;
next	1.93;

1.93
date	2006.03.10.16.35.07;	author saad;	state Exp;
branches;
next	1.92;

1.92
date	2006.01.14.11.35.59;	author jufi;	state Exp;
branches;
next	1.91;

1.91
date	2005.12.07.15.31.45;	author saad;	state Exp;
branches;
next	1.90;

1.90
date	2005.11.25.00.26.22;	author saad;	state Exp;
branches;
next	1.89;

1.89
date	2005.11.04.20.24.23;	author jufi;	state Exp;
branches;
next	1.88;

1.88
date	2005.10.31.12.06.18;	author saad;	state Exp;
branches;
next	1.87;

1.87
date	2005.10.30.08.23.46;	author saad;	state Exp;
branches;
next	1.86;

1.86
date	2005.10.16.10.14.28;	author saad;	state Exp;
branches;
next	1.85;

1.85
date	2005.09.03.16.41.44;	author saad;	state Exp;
branches;
next	1.84;

1.84
date	2005.08.13.07.55.55;	author saad;	state Exp;
branches;
next	1.83;

1.83
date	2005.06.10.14.25.28;	author saad;	state Exp;
branches;
next	1.82;

1.82
date	2005.06.08.17.38.20;	author saad;	state Exp;
branches;
next	1.81;

1.81
date	2005.05.30.13.52.07;	author saad;	state Exp;
branches;
next	1.80;

1.80
date	2005.05.25.04.52.29;	author saad;	state Exp;
branches;
next	1.79;

1.79
date	2005.05.20.14.55.34;	author jufi;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.15.21.17.52;	author saad;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.23.07.03.29;	author jufi;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.25.06.45.42;	author saad;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.18.11.06.46;	author saad;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.04.20.39.14;	author jufi;	state Exp;
branches;
next	1.73;

1.73
date	2005.01.24.09.26.41;	author saad;	state Exp;
branches;
next	1.72;

1.72
date	2005.01.18.17.17.47;	author jufi;	state Exp;
branches;
next	1.71;

1.71
date	2005.01.15.16.33.39;	author jufi;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.06.19.14.20;	author jufi;	state Exp;
branches;
next	1.69;

1.69
date	2004.12.27.19.32.46;	author jufi;	state Exp;
branches;
next	1.68;

1.68
date	2004.12.22.20.00.27;	author jufi;	state Exp;
branches;
next	1.67;

1.67
date	2004.12.10.20.11.01;	author saad;	state Exp;
branches;
next	1.66;

1.66
date	2004.12.03.19.44.11;	author jufi;	state Exp;
branches;
next	1.65;

1.65
date	2004.11.21.17.13.20;	author jufi;	state Exp;
branches;
next	1.64;

1.64
date	2004.11.18.08.03.01;	author jufi;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.12.19.21.37;	author jufi;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.12.13.03.07;	author jufi;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.04.17.17.59;	author jufi;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.02.18.40.59;	author jufi;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.29.21.31.34;	author jufi;	state Exp;
branches;
next	1.58;

1.58
date	2003.07.27.17.39.32;	author jufi;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.13.14.04.21;	author jufi;	state Exp;
branches;
next	1.56;

1.56
date	2003.07.06.10.50.01;	author jufi;	state Exp;
branches;
next	1.55;

1.55
date	2003.07.05.20.30.32;	author jufi;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.27.11.40.31;	author jufi;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.09.18.36.29;	author jufi;	state Exp;
branches;
next	1.52;

1.52
date	2003.02.16.12.01.45;	author jufi;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.17.18.47.48;	author jufi;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.15.22.51.40;	author jufi;	state Exp;
branches;
next	1.49;

1.49
date	2002.11.11.20.52.45;	author jufi;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.05.21.49.35;	author jufi;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.06.21.10.04;	author jufi;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.14.15.50.18;	author jufi;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.03.20.45.30;	author jufi;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.28.21.16.06;	author jufi;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.25.23.46.33;	author jufi;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.25.23.34.18;	author jufi;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.12.20.43.27;	author jufi;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.04.06.33.29;	author jufi;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.03.21.10.53;	author jufi;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.21.12.38.46;	author jufi;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.20.18.27.23;	author jufi;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.20.13.42.05;	author jufi;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.23.10.11.09;	author jufi;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.22.23.38.00;	author jufi;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.18.20.15.21;	author jufi;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.19.19.21.10;	author jufi;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.10.19.00.50;	author jufi;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.25.10.50.58;	author jufi;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.19.06.36.31;	author jufi;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.14.21.06.40;	author jufi;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.26.18.18.25;	author jufi;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.22.20.14.15;	author jufi;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.08.15.51.41;	author jufi;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.15.20.29.23;	author jufi;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.14.22.57.05;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.18.21.28.23;	author jufi;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.06.16.52.58;	author jufi;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.19.18.37.59;	author jufi;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.03.19.25.07;	author jufi;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.27.18.16.19;	author jufi;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.22.21.12.45;	author jufi;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.20.13.35.03;	author jufi;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.05.14.52.18;	author reinhard;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.28.21.53.33;	author jufi;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.26.19.55.26;	author jufi;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.12.22.02.33;	author jufi;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.30.15.46.57;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.24.19.22.38;	author jufi;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.17.09.13.27;	author jufi;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.10.19.03.20;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.19.19.32.55;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.16.13.29.27;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.17.02;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.02.41;	author jufi;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.21.17.44.31;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.17.11.18;	author jufi;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.18.18.20.00;	author reinhard;	state Exp;
branches;
next	;


desc
@@


1.147
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
Thanks to all those that did the translation work, and my appologies to
those who had to translate my writing!
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Vernetzung</title>
<link rev= "made" href= "mailto:www@@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 6 - Networking">
<meta name= "keywords"      content= "openbsd,faq6">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2013 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirmkontrollen]</a>
</font>

<h1><font color="#e00000">6 - Vernetzung</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Intro"    >6.1 - Bevor wir weitermachen</a>
<li><a href="#Setup"    >6.2 - Netzwerkkonfiguration</a>
<ul>
  <li><a href="#Setup.if"      >6.2.1 - Netzwerkinterfaces finden und
    einrichten</a>
  <li><a href="#Setup.gateway" >6.2.2 - Standardgateway</a>
  <li><a href="#Setup.resolver">6.2.3 - DNS-Auflösung</a>
  <li><a href="#Setup.myname"  >6.2.4 - Hostname</a>
  <li><a href="#Setup.activate">6.2.5 - Änderungen übernehmen</a>
  <li><a href="#Setup.chkroute">6.2.6 - Routen überprüfen</a>
  <li><a href="#Setup.forward" >6.2.7 - Dein OpenBSD-System als Gateway
    konfigurieren</a>
  <li><a href="#Setup.aliases" >6.2.8 - Interface-Aliases einrichten</a>
</ul>
<li><a href="#PF"       >6.3 -
    Wie kann ich mit OpenBSD filtern und eine Firewall aufsetzen?</a>
<li><a href="#DHCP"     >6.4 - Dynamic-Host-Configuration-Protokoll (DHCP)</a>
<ul>
  <li><a href="#DHCPclient">6.4.1 - DHCP-Client</a>
  <li><a href="#DHCPserver">6.4.2 - DHCP-Server</a>
</ul>
<li><a href="#PPP"      >6.5 - Point-to-Point-Protokoll (PPP)</a>
<li><a href="#Tuning"   >6.6 - Tunen von Netzwerkparametern</a>
<li><a href="#NFS"      >6.7 - NFS benutzen</a>
<li><a href="#Bridge"   >6.9 - Aufsetzen einer Bridge mit OpenBSD</a>
<li><a href="#PXE"      >6.10 - Wie boote ich mit PXE?</a>
<li><a href="#CARP"     >6.11 -
    Das Common-Address-Redundancy-Protokoll (CARP)</a>
<li><a href="#OpenNTPD" >6.12 - OpenNTPD verwenden</a>
<li><a href="#Wireless" >6.13 -
    Welche Möglichkeiten stehen mir für Drahtlosnetzwerk zur Verfügung?</a>
<li><a href="#Multipath">6.14 -
    Wie kann ich »equal-cost multipath routing« durchführen?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Bevor wir weitermachen</h2>

<p>
Für den Rest dieses Dokumentes sei gesagt, dass es hilfreich
ist, das Kapitel <a href="faq5.html">Kernelkonfiguration und
Einstellungen</a> der FAQ gelesen und zumindest teilweise verstanden zu
haben. Weiterhin helfen die
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>- und
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1"
>netstat(1)</a>-Handbuchseiten.

<p>
Wenn du ein Netzwerkadministrator bist, Routingprotokolle aufsetzt
und dein OpenBSD-Rechner dein Router wird, dann solltest du dein Wissen
über IP-Netzwerke mit
»<a href="http://www.scribd.com/doc/52483921/3Com-Understanding-IP-Addressing"
>Understanding IP Addressing</a>« vertiefen.
Dies ist wirklich ein exzellentes Dokument. »Understanding IP
addressing« beinhaltet grundlegendes Wissen, auf dem man bei der Arbeit
mit IP-Netzwerken aufbauen kann; insbesondere wenn man es mit mehreren
Netzwerken zu tun hat oder für sie verantwortlich ist.

<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailservern arbeitest, dann
könntest du viel <a href="http://www.rfc-editor.org/rfc.html">vom
Lesen der entsprechenden RFCs</a> profitieren.
Selbstverständlich kannst du nicht alle lesen. Aber dennoch: Lies jene,
die dich interessieren oder die du bei deiner Arbeit brauchen könntest.
Lies nach, wie alles funktionieren sollte. Die RFCs definieren mehrere
(tausend) Standards für Protokolle im Internet und wie sie arbeiten
sollten.

<p>
<a name="Setup"></a>
<h2>6.2 - Netzwerkkonfiguration</h2>

Normalerweise wird OpenBSD während der
<a href="faq4.html">Installation</a> das erste Mal konfiguriert. Es ist
jedoch von Vorteil, wenn man genau versteht, was während des Vorgangs
passiert und wie genau das alles funktioniert. Die gesamte
Netzwerkkonfiguration wird mit einfachen Textdateien im
<i>/etc</i>-Verzeichnis abgehandelt.

<p>
<a name="Setup.if"></a>
<h3>6.2.1 - Identifizieren und Einstellen deiner Netzwerkkarten</h3>

<p>
Unter OpenBSD werden Netzwerkkarten nach ihrem Typ, nicht nach
Verbindungsart benannt. Du kannst entweder schon beim Booten oder auch
später mit Hilfe des Befehls <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8"
>dmesg(8)</a> sehen, ob deine Netzwerkkarte initialisiert wurde.
Weiterhin kannst du mit dem Befehl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> deine Karte überprüfen. Als Beispiel hier die Ausgabe
von dmesg für eine Intel-Fast-Ethernet-Netzwerkkarte, die als
Gerätenamen fxp hat.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Wenn du deinen Gerätenamen nicht kennst, sieh bitte in der
<a href="../../de/plat.html">Liste der unterstützten Hardware</a>
für deine Plattform nach. Du wirst eine Liste vieler bekannter Karten
mit ihren OpenBSD-Gerätenamen finden (wie etwa fxp). Kombiniere den
alphabetischen Gerätenamen (zum Beispiel fxp) mit einer vom Kernel
zugewiesenen Nummer und du hast den sogenannten Interfacenamen (wie
z.&nbsp;B. fxp0).
Die Nummer wird nach bestimmten Kriterien zugewiesen: Diese
unterscheiden sich je nach Karte und weiteren Details deines Systems.
Einige Karten werden in der Reihenfolge nummeriert, in der sie während
des Bus-Probings gefunden werden. Bei anderen entscheidet die
Einstellung der Hardwareressourcen oder die MAC-Adresse.

<p>
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem
du das Kommando <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> benutzt. Das folgende Kommando zeigt uns alle
Netzwerkinterfaces im System an. Diese Beispielausgabe zeigt ein
physikalisches Netzwerkinterface an (ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"
>fxp(4)</a>).

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33200
        priority: 0
        groups: lo
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x3
        inet 127.0.0.1 netmask 0xff000000
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:04:ac:dd:39:6a
        priority: 0
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
enc0: flags=0&lt;&gt;
        priority: 0
        groups: enc
        status: active
pflog0: flags=141&lt;UP,RUNNING,PROMISC&gt; mtu 33200
        priority: 0
        groups: pflog
</pre></blockquote>

<p>
Wie du hier sehen kannst, gibt <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> mehr Informationen aus, als wir zu diesem Zeitpunkt
benötigen. Selbstverständlich sehen wir trotzdem unser Interface. Im
obigen Beispiel ist die Netzwerkkarte bereits konfiguriert. Das ist
offensichtlich, da auf fxp0 bereits ein IP-Netzwerk konfiguriert wurde,
sprich die Werte »inet 10.0.0.38 netmask 0xffffff00 broadcast
10.0.0.255«. Außerdem sind die Flags <b>UP</b> und
<b>RUNNING</b> gesetzt.

<p>
Schlussendlich fällt auf, dass standardmäßig noch viele weitere
Interfaces aktiviert sind. Dies sind virtuelle Interfaces, die
verschiedene Funktionen haben. Informationen dazu findest du in den
folgenden Handbuchseiten:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4"
>lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4"
>pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Verkapselungs-Schnittstelle
</ul>

Andere virtuelle Schnittstellen werden bei Bedarf erzeugt, einschließlich:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4"
>sl</a> - SLIP-Netzwerkinterface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4"
>ppp</a> - Point-to-Point-Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4"
>tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4"
>vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=svlan&amp;sektion=4"
>svlan</a> - IEEE 802.1AD Provider Bridges (QinQ)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4"
>gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4"
>gif</a> - Generic IPv4/IPv6 Tunnel Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4"
>carp</a> - Common Address Redundancy Protocol Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mpe&amp;sektion=4"
>mpe</a> - MPLS Provider Edge
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vether&amp;sektion=4"
>vether</a> - Virtuelle Ethernet-Schnittstelle
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=trunk&amp;sektion=4"
>trunk</a> - Schnittstelle zur Gruppierung und Ausfallsicherung von
Verbindungen.
</ul>

<p>
Schnittstelle werden während des Startvorgangs mit Hilfe von
/etc/hostname.<i>if</i>-Dateien konfiguriert,
wobei hier <i>if</i> durch den vollen Namen der Schnittstelle zu ersetzen ist;
jede Schnittstelle besitzt somit eine eigene Datei.
Das obige Beispiel würde eine Datei namens <i>/etc/hostname.fxp0</i> nutzen.

<p>
Der Aufbau dieser Datei ist simpel:

<blockquote><pre>
address_family address netmask broadcast [weitere Optionen]
</pre></blockquote>

Weitere Details über dieser Datei findest du in der Handbuchseite für <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>. In ihr finden sich vor allem Informationen für
nicht ganz so einfache Konfigurationen.

<p>
Eine typische Interface-Konfigurationsdatei für eine IPv4-Adresse
würde so aussehen:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
In diesem Fall haben wir eine IPv4-Adresse (inet) mit der IP-Adresse
10.0.0.38, einer Subnetmask von 255.255.255.0 und ohne bestimmter
Broadcastadresse definiert (die in diesem Fall standardmäßig 10.0.0.255
ist).

<p>
Du solltest auch den Medientypen für Ethernet angeben, wenn du
z.&nbsp;B. den 100baseTX-Fullduplex-Modus erzwingen willst.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der
Verbindungen auf Vollduplex gestellt sind! Wenn du keine besonderen
Anforderungen hast, kannst du diese Medieneinstellungen einfach
ignorieren. Ein viel wahrscheinlicheres Beispiel wäre eine Einstellung
auf 10base-T oder Halbduplex, wenn das Netzwerk dies erfordert.)

<p>
Oder vielleicht willst du auch spezielle Flags für ein einzelnes
Interface benutzen. Das Format der Datei ändert sich dabei nicht
besonders!

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>


<a name="Setup.gateway"></a>
<h3>6.2.2 - Standardgateway</h3>
Schreib die IP-Adresse deines Standardgateways in die Datei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>/etc/mygate</a></i>. Damit wird dein Gateway während des Bootvorgangs
eingestellt. Die Datei besteht nur aus einer einzigen Zeile, in der die
Adresse deines Gateways steht:

<blockquote><pre>
10.0.0.1
</pre></blockquote>

Es ist möglich, hier einen symbolischen Namen zu benutzen, doch sei vorsichtig:
du kannst während des Bootvorgangs nicht davon ausgehen, dass die
Namensauflösung bereits funktioniert oder der Nameserver überhaupt
erreichbar ist BIS das Standardgateway definiert wurde. Mit anderen
Worten: Es ist besser eine IP-Adresse oder etwas in
<i>/etc/hosts</i> fest definiertes in diese Datei zu schreiben.

<p>
<a name="Setup.resolver"></a>
<h3>6.2.3 - DNS-Auflösung</h3>
Die DNS-Auflösung wird über die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"
><i>/etc/resolv.conf</i></a> verwaltet. Hier ist ein Beispiel einer
<i>/etc/resolv.conf</i>-Datei:

<blockquote><pre>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

In diesem Fall wird der Standarddomainname auf <tt>example.com</tt>
gesetzt, zwei DNS-Resolver (<tt>125.2.3.4</tt> und <tt>125.2.3.5</tt>)
definiert und vorgegeben, dass die Datei <i>/etc/hosts</i> durchsucht
werden soll bevor eine Anfrage an die DNS-Resolver gesendet wird.

<p>
Wie in fast jedem anderen Unix-System (und vielen Nicht-Unix-Systemen)
gibt es eine <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5"
><i>/etc/hosts</i></a>-Datei, in die alle Systeme eingetragen werden
können, die sich nicht in einem formalen DNS-System befinden (falls sie
dort anders angegeben sind als gewünscht, kann man die
»lookup«-Reihenfolge wie im vorherigen Beispiel anpassen).

<p>
Wenn du DHCP einsetzt, lies <a href="#DHCP">6.4 - DHCP</a> und
achte auf den Einsatz von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"
>resolv.conf.tail(5)</a>.

<p>
<a name="Setup.myname"></a>
<h3>6.2.4 - Hostname</h3>
Jede Unix-Maschine hat einen Namen. Unter OpenBSD wird der Name als
»Fully Qualified Domain Name« (FQDN) in einer einzelnen Zeile in der
Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=myname&amp;sektion=5"
><i>/etc/myname</i></a> angegeben. Falls die Maschine »puffy« heißt und
sich in der Domain »example.com« befindet, würde folgende Zeile in der
Datei stehen:

<blockquote><pre>
puffy.example.com
</pre></blockquote>

<a name="Setup.activate"></a>
<h3>6.2.5 - Änderungen übernehmen</h3>
Jetzt kannst du entweder neustarten oder das Skript
<b>/etc/netstart</b> ausführen, indem du (als root) Folgendes
eingibst:

<blockquote><pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript
ausführst, versuchst du ein paar Sachen zu konfigurieren, die bereits
konfiguriert sind. Daher existieren bereits einige der Routen in der
Routingtabelle des Kernels. Von hier an sollte dein System laufen und
online sein. Du kannst hier erneut mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> prüfen, ob deine Interfaces richtig konfiguriert
wurden.

<p>
Obwohl du dein Netzwerk unter OpenBSD ohne Neustart vollständig
neukonfigurieren kannst, wird dir DRINGEND dazu geraten, wenn
grundlegende Einstellungen geändert wurden. Der Grund hierfür ist, dass
die Umgebung während des Bootvorgangs etwas anders ist als wenn das
System bereits vollständig hochgefahren wurde. Wenn du zum Beispiel
einen über DNS auflösbaren Namen in eine der Dateien geschrieben hast,
wirst du diesen im laufenden Betrieb sicherlich auflösen können. Während
des Bootvorgangs aber kann es sein, dass der externe Resolver noch nicht
verfügbar ist und die Konfiguration somit fehlschlägt.

<p>
<a name="Setup.chkroute"></a>
<h3>6.2.6 - Routen überprüfen</h3>
Deine Routen kannst du mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1"
>netstat(1)</a> oder <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8"
>route(8)</a> überprüfen. Wenn du Probleme mit dem Routing hast,
möchtest du vielleicht die Option -n mit route(8) benutzen, das die
IP-Adressen ausgibt, statt eine DNS-Auflösung durchzuführen, und um den
Hostnamen anzuzeigen. Hier ist ein Beispiel mit beiden Kommandos, um die
Routingtabelle anzeigen zu lassen:

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.forward"></a>
<h3>6.2.2 - Deinen OpenBSD-Rechner als Gateway einrichten</h3>

<p>
Dies sind nur die grundlegenden Informationen, um deinen OpenBSD-Rechner
als Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als
Router im Internet verwenden willst, solltest du auch die unten
folgenden Packet-Filter-Instruktionen beachten, um potenziell schädliche
IP-Daten zu blockieren. Auch solltest du wegen der Knappheit an <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a>-Adressen die Informationen bezüglich Network Address
Translation beachten, um deinen IP-Adressbereich zu schonen.

<p>
Der GENERIC-Kernel kann bereits IP-Forwarding, muss aber erst
eingeschaltet werden. Du solltest dies mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a> tun. Um diese Änderung permanent einzutragen, musst du
die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>/etc/sysctl.conf</a> editieren. Füge einfach folgende Zeile in diese
Konfigurationsdatei ein.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Ohne Neustart kannst du dies auch direkt mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a> durchführen. Beachte aber, dass diese Änderung nach einem
Neustart weg ist und dass der folgende Befehl als root ausgeführt werden
muss.

<blockquote><pre>
# <b>sysctl net.inet.ip.forwarding=1</b>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Nun modifiziere die Routen der anderen Hosts auf beiden Seiten.
Dies wird oft mit statischen Routeneinträgen gemacht, doch fortgeschrittenere
Netzwerke können von der reichen Sammlung an Routing-Dämonen Gebrauch machen,
die Teil von OpenBSD sind, um Routen zu anderen Systemen zu legen.
Wir reden über
<a href="http://www.openbgpd.org/">OpenBGPD</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ospfd&amp;sektion=8"
>ospfd(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ospf6d&amp;sektion=8"
>ospf6d(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldpd&amp;sektion=8"
>ldpd(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ripd&amp;sektion=8"
>ripd(8)</a>.
Zusätzlich beinhaltet die Portierungs-Kollektion Software wie
<a href="http://bird.network.cz/">bird</a>,
<a href="http://igmpproxy.sourceforge.net/">igmpproxy</a> und
<a href="http://www.quagga.net">quagga</a>.
OpenBSD unterstützt verschiedene T1-, HSSI-, ATM-, FDDI- und serielle
(PPP/SLIP)-Schnittstellen, und natürlich viele Etherne-Geräte
(einscließlich 10 Gb).

<p>
<a name="Setup.aliases"></a>
<h3>6.2.8 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>

<p>
OpenBSD hat einen einfachen Mechanismus, um IP-Aliase für deine
Netzwerkkarten zu setzen. Dazu musst du einfach die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
><i>/etc/hostname.&lt;if&gt;</i></a> editieren. Sie wird beim Booten vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8"
>/etc/netstart(8)</a>-Skript gelesen, das ein Teil der
<a href="faq10.html#rc">rc-Starthierarchie</a> ist. Für dieses Beispiel
nehmen wir an, dass der Benutzer ein Interface <b>dc0</b> hat und sich
im Netzwerk 192.168.0.0 befindet. Weitere wichtige Informationen:

<ul>
<li>IP für dc0 ist 192.168.0.2
<li>NETMASK ist 255.255.255.0
</ul>

<p>
Ein paar Bemerkungen zu Aliasen: In OpenBSD verwendet man nur den
Adapternamen. Es gibt keine Unterschiede zwischen dem ersten und dem
zweiten Alias. Daher muss man sie nicht - wie in einigen anderen
Betriebssystemen - als dc0:0, dc0:1 bezeichnen. Wenn du dich auf einen
speziellen IP-Alias beziehst oder einen hinzufügst, dann nimm
»<tt>ifconfig int alias</tt>« statt nur »<tt>ifconfig int</tt>«
auf der Befehlszeile. Du kannst Aliase mit »<tt>ifconfig int
delete</tt>« löschen.

<p>
Angenommen du verwendest mehrere IP-Adressen im selben IP-Subnetz mit
Aliases, dann ist die Netzmaskeneinstellung für jeden Alias
255.255.255.255. Sie müssen nicht der Netzmaske der ersten IP der
Netzwerkkarte folgen. In dieser <i>/etc/hostname.dc0</i>-Beispieldatei
werden zwei Aliase zur Netzwerkkarte dc0 hinzugefügt, die als
192.168.0.2 mit Netzmaske 255.255.255.0 konfiguriert wurde.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Wenn du einmal diese Datei erstellt hast, benötigst du einen Neustart,
um die Änderung automatisch durchzuführen. Du kannst aber auch
die Aliase manuell mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> hochbringen. Für den ersten Alias geht das so:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(Und wieder ist ein Neustart empfehlenswert um sicherzustellen, dass
alles wie erwartet konfiguriert wird!)

<p>
Um die Aliases zu sehen:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="PF"></a>
<h2>6.3 - Wie kann ich mit OpenBSD filtern und eine Firewall aufsetzen?</h2>
Packet Filter (ab hier nur noch als PF bezeichnet) ist OpenBSDs System
zum Filtern von IP-Verkehr und zum Ausführen von Network Address
Translation. PF ist außerdem in der Lage, IP-Verkehr zu normalisieren
und zu konditionieren, eine Priorisierung von Paketen durchzuführen und
eine mächtige und flexible Firewall zu erzeugen. Er wird im <a
href="../pf/de/index.html"><b>PF-Benutzerhandbuch</b></a> beschrieben.

<p>
<a name= "DHCP"></a>
<h2>6.4 - Dynamic-Host-Configuration-Protokoll (DHCP)</h2>

Das Dynamic-Host-Configuration-Protokoll ist ein Weg, um die
Netzwerkkarten »automatisch« zu konfigurieren. OpenBSD kann als
DHCP-Server (der andere Maschine konfiguriert), als ein DHCP-Client (der
von einer anderen Maschine konfiguriert wird) und in einigen Fällen auch
als beides eingesetzt werden.

<p>
<a name="DHCPclient"></a>
<h3>6.4.1 - DHCP-Client</h3>

<p>
Um den im OpenBSD integrierten DHCP-Client <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8"
>dhclient(8)</a> zu benutzen, editiere <tt>/etc/hostname.xl0</tt> (wenn
deine Hauptnetzwerkkarte xl0 ist. Deine könnte auch ep0 oder fxp0 oder
irgendeine andere sein). Alles was du in diese Datei zu schreiben hast ist
»<tt>dhcp</tt>«.

<blockquote><pre>
# <b>echo dhcp &gt; /etc/hostname.xl0</b>
</pre></blockquote>

<p>
Dies wird OpenBSD veranlassen, den DHCP-Client automatisch beim Booten
zu starten. OpenBSD wird sich seine IP-Adresse, sein Standardgateway und
seine DNS-Server vom DHCP-Server besorgen.

<p>
Wenn du den DHCP-Client von der Befehlszeile aus starten willst, stelle
sicher, dass <tt>/etc/dhclient.conf</tt> existiert, dann versuche:

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
Wobei <tt>fxp0</tt> die Netzwerkkarte ist, auf der du dhcp empfangen
willst.

<p>
Wie auch immer du den DHCP-Client startest, kannst du die
<tt>/etc/dhclient.conf</tt>-Datei so editieren, dass dein DNS
<b>nicht</b> mit den neuen DNS-Informationen aktualisiert wird:
kommentiere zuerst die »request«-Zeilen aus (Es gibt Beispiele in den
Standardeinstellungen, aber du musst die Standardeinstellungen vom
dhclient überschreiben).

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
und dann <tt>domain-name-servers</tt>. Natürlich möchtest du vermutlich
auch Einstellungen wie <tt>host-name</tt> entfernen.

<p>
Durch das Ändern der Optionen in deiner <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5"
>dhclient.conf(5)</a>-Datei teilst du dem DHCP-Client mit, wie deine <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"
>resolv.conf(5)</a>-Datei erzeugt werden soll. Der DHCP-Client
überschreibt jegliche Informationen, die du bereits in der
resolv.conf(5) hast, mit jenen, die er vom DHCP-Server erhält. Daher
wirst du alle Änderungen verlieren, die du manuell an der resolv.conf
vorgenommen hast.

<p>
Zwei Mechanismen stehen zur Verfügung, um das zu verhindern:

<ul>
<li>
<tt><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS"
>OPTION MODIFIERS</a></tt> (<b>default</b>, <b>supersede</b>,
<b>prepend</b> und <b>append</b>) erlauben dir, jegliche Optionen in
dhclient.conf(5) zu überschreiben.

<li>
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"
><tt>resolv.conf.tail(5)</tt></a> ermöglicht dir alle Informationen, die
du haben möchtest, an die resolv.conf(5)-Datei anzuhängen, die durch
dhclient(8) erstellt wurde.
</ul>

<p>
Ein Beispielfall wäre, wenn du DHCP verwendest, aber <tt>lookup file
bind</tt> an die von dhclient(8) erstellte resolv.conf(5) hängen möchtest.
Hierfür gibt es keine Option in <tt>dhclient.conf</tt>, daher musst du
<tt>resolv.conf.tail</tt> benutzen, um dieses Ziel zu erreichen.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

Nun sollte deine resolv.conf(5) »lookup file bind« am Ende stehen haben.
<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<p>
<a name="DHCPserver"></a>
<h3>6.4.2 - DHCP-Server</h3>

<p>
Wenn du OpenBSD als DHCP-Server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>
einsetzen willst, editiere <tt>/etc/rc.conf.local</tt> so,
dass sie die Zeile <tt>dhcpd_flags=""</tt> enthält.
Zum Beispiel:
<pre>
     # <b>echo 'dhcpd_flags=""' &gt;&gt;/etc/rc.conf.local</b>
</pre>

Dies führt zum Start des dhcpd, der sich im Folgenden auf alle NICs aufschalten
wird, die gültige Konfigurationseinträge in <tt>/etc/dhcpd.conf</tt> besitzen.
Du kannst stattdessen auch einzelne Schnittstellen spezifizieren, indem du sie
explizit anführst, wie zum Beispiel <tt>dhcpd_flags="xl1 xl2 xl3"</tt>.

<p>
Dann editiere <tt>/etc/dhcpd.conf</tt>. Die Optionen sind
selbsterklärend.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Dies teilt deinen DHCP-Clients mit, dass die an DNS-Anfragen
anzuhängende Domäne example.com ist (d.&nbsp;h. wenn der Benutzer
»telnet joe« schreibt, dann wird an joe.example.com gesendet). Es wird
auf die DNS-Server 192.168.1.3 und 192.168.1.5 verwiesen. Für Hosts, die
sich im selben Netzwerk wie die Netzwerkkarte des OpenBSD-Rechners
befinden, welche im 192.168.1.0/24 Adressbereich liegt, wird der
DHCP-Server ihnen eine IP-Adresse zwischen 192.168.1.32 und
192.168.1.127 und als Standardgateway 192.168.1.1 zuweisen.

<p>
Willst du den dhcpd(8) von der Befehlszeile aus starten, nachdem du
<tt>/etc/dhcpd.conf</tt> editiert hast, so versuche:

<pre>
    # <b>/etc/rc.d/dhcpd start</b>
    dhcpd(ok)
</pre>

Wurden während des Starts fatale Konfigurationsfehler gefunden, so wird er sich
beenden und dich wissen lassen, dass sein Start fehlgeschlagen ist
("<tt>dhcpd(failed)</tt>") und in <tt>/var/log/messages</tt> den genauen
Grund dafür aufzeigen.

<p>
Wenn du DHCP-Dienste für einen Windows-Rechner bereitstellst, dann
willst du vielleicht auch eine WINS-Serveradresse liefern. Dafür füge
einfach die folgenden Zeilen zu deiner <tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(wobei <tt>192.168.92.55</tt> die IP deines Windows- oder Samba-Servers
ist.) Siehe auch <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5"
>dhcp-options(5)</a> für weitere Optionen, die deine DHCP-Clients
wünschen.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP</h2>

<p>
Das Point-to-Point-Protokoll wird verwendet, um eine Verbindung zu
deinem ISP mit deinem Einwahlmodem herzustellen. OpenBSD bietet dafür
zwei Möglichkeiten:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
- der Kernel-PPP-Daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
- der Userland-PPP-Daemon.
</ul>

<p>
Sowohl ppp als auch pppd führen zwar die gleichen Funktionen aus, dieses
jedoch auf unterschiedliche Wege. pppd arbeitet mit dem <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4"
>ppp(4)</a>-Treiber des Kernels, während ppp mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4"
>tun(4)</a> im Userland arbeitet. Dieses Dokument wird sich nur mit dem
PPP-Daemon des Userlands beschäftigen, da es mit ihm einfacher ist,
Fehlfunktionen zu korrigieren sowie mit ihm zu interagieren. Um zu
beginnen, benötigen wir einige einfache Informationen über deinen ISP.
Hier eine Liste hilfreicher Informationen, die du brauchen wirst.

<ul>
<li>Die Einwahlnummer deines ISPs
<li>Deinen Nameserver
<li>Deinen Benutzernamen und dein Passwort
<li>Dein Gateway
</ul>

<p>
Einige von diesen benötigst du nicht unbedingt, aber sie wären
beim Aufsetzen des ppp hilfreich. Der Userland-PPP-Daemon benutzt die
Datei <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample"
>/etc/ppp/ppp.conf</a> als seine Konfigurationsdatei. Es gibt viele
hilfreiche Dateien in <i>/etc/ppp</i>, die verschiedene Einstellungen
für verschiedene Situationen zeigen. Du solltest dir dieses Verzeichnis
ansehen und es durchforsten.

<p>
<h3>Erste Einstellungen - für PPP(8)</h3>

<p>
Die ersten Einstellungen für den Userland-PPP-Daemon bestehen im
Erstellen deiner <i>/etc/ppp/ppp.conf</i>-Datei. Diese Datei existiert
nicht standardmäßig, aber du kannst einfach
<i>/etc/ppp/ppp.conf.sample</i> editieren, um deine eigene
 <i>ppp.conf</i>-Datei zu erstellen. Hier werde ich mit den einfachsten
und gebräuchlichsten Einstellungen beginnen. Hier eine kurze
<i>ppp.conf</i>-Datei, die einfach einige Standardwerte setzt:

<blockquote><pre>
default:
  set log Phase Chat LCP IPCP CCP tun command     
  set device /dev/cua01                           
  set speed 115200     
  set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
Der Absatz unter der <tt>default:</tt>-Bezeichnung wird jedes Mal
ausgeführt. Hier stehen alle wichtigen Informationen. Mit »set
log« stellen wir unsere Loglevel ein. Um dies zu ändern, lies <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8"
>ppp(8)</a> für weitere Informationen. Unsere Schnittstelle wird mit
»set device« eingestellt. Dies ist die Schnittstelle, mit der das
Modem verbunden ist. In diesem Beispiel hängt das Modem auf COM-Port 2.
Daher wird COM-Port 1 auf <i>/dev/cua00</i> gesetzt. Mit »set speed«
setzen wir die Geschwindigkeit unserer Einwahlverbindung und mit »set
dail« setzen wir unsere Dialup-Parameter, mit denen wir den Timeout
usw. setzen können. Diese Zeile sollte eigentlich ziemlich genau so
bleiben, wie sie jetzt ist.

<p>
Nun können wir die spezifischen Informationen von unserem ISP eintragen.
Wir tun dies, indem wir unter <tt>default:</tt> einen weiteren Absatz
hinzufügen. Dieser kann benannt werden, wie du willst - am einfachsten
nimmst du den Namen deines ISPs. Hier werde ich <tt>myisp:</tt> als
Verweis auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, das
alles beinhaltet, um uns zu verbinden:

<blockquote><pre>
myisp:
  set phone 1234567   
  set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
  set timeout 120   
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
  add default HISADDR 
  enable dns
</pre></blockquote>

<p>
Hier stehen alle wichtigen Informationen für unseren spezifischen ISP.
Die erste Option »set phone« setzt die Einwahlnummer deines ISPs.
»set login« setzt unsere login-Optionen. Hier haben wir den Timeout
auf 5 gesetzt, was bedeutet, dass wir unseren Loginversuch nach 5
Sekunden abbrechen, wenn wir kein Trägersignal bekommen. Ansonsten wird
er auf »login:« warten und dann deinen Benutzernamen und dein Passwort
senden.

<p>
In diesem Beispiel ist unser Benutzername ppp und das Passwort ppp.
Diese Werte müssen geändert werden. Die Zeile »set timeout« setzt den
Idle Timeout für die gesamte Verbindungsdauer auf 120 Sekunden. Die
»set ifaddr«-Zeile ist ein bisschen schwieriger. Hier ist eine genauere
Erklärung.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
Die obige Zeile folgt dem Format »<b>set ifaddr [meineAdr[/nn]
[seineAdr[/nn] [netzmaske [startAdr]]]]</b>«. Daher ist die erste
spezifizierte IP diejenige, die wir als unsere IP wollen. Wenn du eine
statische IP-Adresse hast, dann kannst du sie hier einsetzen. In unserem
Beispiel benutzen wir /0, was besagt, dass keine Bits von dieser
IP-Adresse übereinstimmen müssen und der gesamte Ausdruck ersetzt werden
kann. Die zweite IP behandelt die von uns erwartete IP unserer
Gegenstelle. Wenn du sie weißt, dann kannst du sie hier angeben.
Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also
lassen wir sie uns wieder mitteilen. Die dritte Option ist unsere
Netzmaske, hier auf 255.255.255.0 gesetzt. Wenn startAdr angegeben ist,
dann wird diese anstelle von meineAdr während der initialen
IPCP-Verhandlung; aber es wird nur eine Adresse aus dem
meineAdr-Adressbereich akzeptiert. Dies ist nützlich, wenn Verhandlungen
mit einigen PPP-Implementationen durchgeführt werden, die keine
IP-Nummer vergeben, es sei denn, ihr Peer fordert »0.0.0.0« an.

<p>
Die nächste Option »add default HISADDR« setzt unsere Standardroute zu
deren IP. Dies ist »klebrig«, d.&nbsp;h. falls deren IP sich ändern
sollte, dann wird unsere Route auch automatisch aktualisiert. Mit
»enable dns« teilen wir unserem ISP mit, unsere Nameserveradresse zu
authentifizieren. Tu dies NICHT, wenn du deinen eigenen lokalen DNS
laufen hast, da PPP dies umgehen wird, indem es einige Zeilen in
<i>/etc/resolv.conf</i> schreibt.

<p>
Gegenüber den herkömmlichen Loginmethoden verwenden viele IPS nun
entweder CHAP- oder PAP-Authentifizierung. Wenn das der Fall ist, wird
unsere Konfiguration etwas anders aussehen:

<blockquote><pre>
myisp:
  set phone 1234567   
  set authname ppp
  set authkey ppp
  set login
  set timeout 120   
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
  add default HISADDR 
  enable dns
</pre></blockquote>

<p>
In dem oben genannten Beispiel geben wir unseren Benutzernamen (ppp) und
das Passwort (ppp) unter jeweiliger Verwendung von authname und authkey
an.  Es ist nicht notwendig anzugeben, ob CHAP- oder
PAP-Authentifizierung genutzt wird: Es wird automatisch ermittelt. »set
login« gibt lediglich an, dass versucht wird, sich mit dem zuvor
genannten Benutzernamen und dem Passwort anzumelden.

<p>
<h3>PPP(8) verwenden</h3>

<p>
Nun, da wir unsere <i>ppp.conf</i>-Datei fertig eingerichtet haben,
können wir beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier
einige Details über häufig verwendete Parameter mit ppp:

<ul>
<li><tt>ppp -auto myisp</tt> - Startet PPP, konfiguriert deine
Schnittstellen und wird dich mit deinem ISP verbinden und dann in den
Hintergrund verschwinden.
<li><tt>ppp -ddial myisp</tt> - Ähnlich wie -auto, aber wenn deine
Verbindung abbricht, wird PPP versuchen, sich erneut zu verbinden.
</ul>

<p>
Wenn die gerade genannten Aufrufe fehlschlagen, kannst du versuchen,
<i>/usr/sbin/ppp</i> ohne Optionen zu starten - somit wird ppp im
interaktiven Modus ausgeführt. Die Optionen können nach und nach
angegeben werden, um so nach Fehlern oder anderen Problemen zu suchen.
Unter Verwendung der zuvor beschriebenen Einrichtung wird ppp in
/var/log/ppp.log aufzeichnen. Diese Aufzeichnung, sowie die Handbuchseite,
enthalten hilfreiche Informationen.

<p>
<h3>ppp(8)-Extras</h3>

<p>
In einigen Situationen möchtest du Befehle ausführen, wenn die
Verbindung gerade errichtet oder beendet wurde. Für diese Fälle
gibt es zwei Dateien, die du erstellen kannst:
<i>/etc/ppp/ppp.linkup</i> und <i>/etc/ppp/ppp.linkdown</i>.
Beispielkonfigurationen kannst du hier finden:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample"
>ppp.linkup</a>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample"
>ppp.linkdown</a>
</ul>

<p>
<h3>ppp(8)-Varianten</h3>

<p>
Viele ISPs bieten nun xDSL-Dienste an, welche schneller als die
herkömmlichen Einwählmethoden sind. Dies beinhaltet Varianten wie
zum Beispiel ADSL und SDSL. Obwohl kein physikalisches Einwählen
stattfindet, basiert die Verbindung weiterhin auf dem
Point-to-Point-Protokoll. Beispiele beinhalten:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Das »Point to Point Protocol over Ethernet« (PPPoE) ist eine Methode,
um PPP-Pakete in Ethernetframes zu versenden.
Das »Point to Point Protocol over ATM« (PPPoA) läuft typischerweise
in ATM-Netzwerken, wie sie in Großbritannien oder Belgien gefunden
werden können.

<p>
Typischerweise bedeutet das, dass du eine Verbindung mit deinem ISP
über eine normale Ethernetkarte und ethernetbasiertes DSL-Modem
herstellen kannst (im Gegensatz zu einem Nur-USB-Modem).

<p>
Wenn du ein Modem hast, das PPPoE/PPPoA versteht, ist es möglich,
das Modem so zu konfigurieren, dass es selbst die Verbindung aufbaut.
Wenn das Modem einen Bridgemodus hat, ist es alternativ möglich,
diesen zu aktivieren und so das Modem die Pakete einfach zu einer
Maschine durchleiten zu lassen, welche PPPoE-Software einsetzt (siehe
unten).

<p>
Das Haupt-Softwareinterface für PPPoE/PPPoA unter OpenBSD ist <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8"
>pppoe(8)</a>, welches die Userland-Implementation ist (auf fast die
gleiche Art und Weise, wie wir <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8"
>ppp(8)</a> weiter oben beschrieben haben).
Eine Kernel-PPPoE-Implementation namens <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4"
>pppoe(4)</a> wurde in OpenBSD eingebunden.

<p>
<h3>PPTP</h3>

<p>
Das Point-to-Point-Tunneling-Protokoll (PPTP) ist ein proprietäres
Microsoft-Protokoll.  Ein pptp-Client ist verfügbar, der mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8"
>pppd(8)</a> kommuniziert. Er ist in der Lage, sich zu PPTP-basierten
virtuellen privaten Netzwerken (VPN) zu verbinden, die von einigen
Kabel- und xDSL-Anbietern verwendet werden. pptp selbst muss als
<a href="faq15.html#PkgMgmt">Pakete</a> oder
<a href="faq15.html#Ports">Portierungen</a> installiert werden.
Weitere
Anleitungen, wie man pptp einrichtet und verwendet, befinden
sich in der Handbuchseite, die mit dem pptp-Paket installiert wird.

<p>
<a name="Tuning"></a>
<h2>6.6 - Netzwerkparameter tunen</h2>

Eines der Ziele von OpenBSD ist, dass das System für einen Großteil
unserer Nutzer <i>einfach läuft</i>. An Einstellungen rumspielen, deren
Funktion du nicht verstehst, wird das System eher beeinträchtigen und
nicht dessen Geschwindigkeit erhöhen. Fang immer mit den Standardwerten
an und ändere <i>nur</i> Einstellungen, die tatsächlich ein Problem
darstellen.

<p>
<i>SEHR WENIGE Personen werden ihre Netzwerk-Parameter anpassen müssen!</i>

<p>
<h3>6.6.1 - Der Kernel soll bestimmte Ports nicht dynamisch allozieren</h3>

<p>
Von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8#EXAMPLES">sysctl(8)</a>:

<blockquote><pre>
Um die Liste der reservierten TCP-Ports zu setzen, die vom Kernel nicht
automatisch alloziert werden sollen:

      # <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>

Dies kann benutzt werden, um Dämonen vom stehlen eines speziellen Ports
abzuhalten, den ein anderes Programm benötigt, um funktionieren zu können.
Listeneinträge können durch Kommata or Leerzeichen separiert werden.

Es ist ebenfalls möglich, Ports zu der aktuellen hinzuzufügen, oder aus ihr zu
entfernen:

      # <b>sysctl net.inet.tcp.baddynamic=+748</b>
      # <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre></blockquote>

<p>
<a name="NFS"></a>
<h2>6.7 - Einfache NFS-Anleitung</h2>

<p>NFS, oder Network File System (Netzwerkdateisystem), wird verwendet,
um ein Dateisystem über das Netzwerk zu verwenden. Du solltest vorher
noch folgende Handbuchseiten lesen, bevor du versuchst, einen eigenen
NFS-Server aufzusetzen:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
>nfsd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8"
>mountd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>
</ul>

<p>
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS-System
aufzusetzen: Einen Server im LAN und Clients im LAN, die NFS verwenden.
Es behandelt nicht, wie man NFS sicher macht. Wir nehmen an, dass du
bereits Paketfilterung oder irgendeinen anderen Firewallschutz
eingerichtet hast, damit von außerhalb nicht auf NFS zugegriffen werden
kann.  Wenn du Zugriff via NFS von außerhalb erlauben willst und
sensible Daten dort gespeichert hast, dann empfehlen wir dir wärmstens
den Gebrauch von IPsec. Ansonsten können andere Leute möglicherweise
deinen NFS-Datenverkehr sehen. Jemand könnte auch vortäuschen, die
IP-Adresse zu haben, der du Zugriff auf den NFS-Server zulässt. Es gibt
mehrere Angriffe, die möglich sind. Wenn IPsec richtig konfiguriert
wurde, dann schützt es gegen die Art von Angriffen.

<h3>Einen NFS-Server einrichten</h3>

<p>
Folgende Dienste müssen auf dem Server aktiviert sein und laufen:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8"
>portmap(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8"
>mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
>nfsd(8)</a>
</ul>

<p>
Unter OpenBSD sind diese standardmäßig deaktiviert.
Füge die folgenden Zeilen deiner <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>rc.conf.local(8)</a> hinzu, um sie zu aktivieren:

<blockquote><pre>
portmap_flags=""
mountd_flags=""
nfsd_flags="-tun 4"
</pre></blockquote>

<p>
Im nächsten Schritt wird die Liste der Dateisysteme konfiguriert, die
den Clients für Mountoperationen bereitgestellt werden sollen.

<p>
In diesem Beispiel haben wir einen Server mit der IP-Adresse 10.0.0.1.
Der Server wird NFS nur den Clients anbieten, die sich im gleichen
Subnet befinden. Dies wird alles in der /etc/exports-Datei konfiguriert.
In dieser Datei werden für alle Dateisysteme, auf die über
NFS zugegriffen werden kann, auch die jeweiligen Zugriffsrechte aufgeführt.
Es gibt sehr viele Optionen, die du in /etc/exports verwenden kannst;
es wäre daher am besten, wenn du die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>-Handbuchseite lesen würdest. Für dieses Beispiel haben wir
eine exports-Datei angelegt, die wie folgt aussieht:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

<p>
Das heißt, dass das lokale Dateisystem <tt>/work</tt> via NFS zugänglich
gemacht wird. Die <tt>-alldirs</tt>-Option bedeutet, dass Clients jedes
Verzeichnis unter dem <tt>/work</tt>-Mountpunkt (und auch <tt>/work</tt>
selbst) mounten können. Wenn beispielsweise ein Verzeichnis namens
<tt>/work/monday</tt> vorhanden ist, können Clients <tt>/work</tt>
mounten (und damit auf alle folgenden Dateien/Verzeichnisse zugreifen
können) oder <tt>/work/monday</tt> mounten und nur auf
Dateien/Verzeichnisse zugreifen können, die sich dort befinden.
Die <tt>-ro</tt>-Option gibt an, dass nur Leseberechtigung gestattet
wird. Die letzten zwei Argumente bedeuten, dass nur Clients innerhalb
des 10.0.0.0-Netzwerkes mit einer Netzmaske von 255.255.255.0 dieses
Dateisystem mounten dürfen. Dies ist wichtig für einige Server, die von
verschiedenen Netzwerken aus zugänglich sind.

<p>
Ein weiterer wichtiger Sicherheitshinweis: Füge nicht einfach ein
Dateisystem in /etc/exports ein, ohne eine Liste zulässiger Hosts (oder
einen einzelnen Host) anzugeben. Ohne Angabe einer Liste für
erlaubte Zugriffe kann jeder, der den Server ansprechen kann, deine
über NFS bereitgestellten Verzeichnisse mounten.

<p>
Nun kannst du die Serverdienste starten.
Entweder startest du neu (nachdem du sie mit den oben angegebenen
Schritten aktiviert hast) oder du startest sie manuell.

<blockquote><pre>
# <b>/etc/rc.d/portmap start</b>
# <b>/etc/rc.d/mountd start</b>
# <b>/etc/rc.d/nfsd start</b>
</pre></blockquote>

<p>
Die <tt>nfsd_flags</tt> aktivieren Verbindungen über TCP (-t) und UDP (-u) und
ermöglichen vier gleichzeitige Instanzen (-n) des nfsd.
Du solltest durch Anpassung der <tt>nfsd_flags</tt> Zeile in rc.conf.local eine
Anpassung der Anzahl der NFS-Server-Instanzen vornehmen, entsprechend der
maximalen Anzahl der gleichzeitig zu bedienenden Clients.

<p>
Nun kannst du die exportierten Dateisysteme von den Clients (oder dem
Client) aus mounten.

<p>
Bedenke: Wenn du Änderungen an /etc/exports gemacht hast während NFS
bereits lief, musst du mountd über diese Änderungen informieren!
Sende einfach ein HUP an mountd und die Änderungen werden übernommen.

<blockquote><pre>
# <b>/etc/rc.d/mountd reload</b>
</pre></blockquote>

<h3>NFS-Dateisysteme mounten</h3>

<p>
NFS-Dateisysteme können vom Client gemountet werden, ohne dass
zusätzliche Dienste oder Daemons gestartet werden müssen; sie können
wie jedes andere Dateisystem gemountet werden.

<p>
NFS-Dateisysteme sollten mit mount(8) gemountet werden - genauer
gesagt mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8"
>mount_nfs(8)</a>.
Um ein Dateisystem namens <tt>/work</tt> des Hosts 10.0.0.1 auf das
lokale Dateisystem <tt>/mnt</tt> zu mounten, führe Folgendes aus
(beachte, dass du nicht auf eine IP-Adresse angewiesen bist; mount
löst auch Hostnamen auf):

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

<p>
Damit das Dateisystem während des Bootvorgangs gemountet wird, füge
eine Zeile wie diese in /etc/fstab ein:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Es ist wichtig, dass du <tt>0 0</tt> am Ende der Zeile angibst, damit
dein Computer während des Bootvorgangs nicht versucht, fsck für das
NFS-Dateisystem aufzurufen. Die anderen Standardsicherheitsoptionen
wie <tt>noexec</tt>, <tt>nodev</tt> und <tt>nosuid</tt> sollten je nach
Anwendungszweck ebenfalls gesetzt werden. Ein Beispiel:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
Auf diese Weise können keine Devices oder setuid-Programme auf dem
NFS-Server die Sicherheitsmaßnahmen des NFS-Clients unterwandern. Wenn
du keine auf dem gemounteten Dateisystem befindlichen Programme auf
dem NFS-Client starten willst, füge dieser Liste noexec hinzu.

<p>
Wenn mit Rootrechten auf einen NFS-Mount zugegriffen wird, setzt der
Server automatisch die Berechtigung auf Benutzername »nobody« und Gruppe
»nobody«. Es ist sehr wichtig, diese Eigenschaft zu berücksichtigen,
wenn Dateiberechtigungen gesetzt werden. Die Berechtigungen dieser Datei
soll als Beispiel dienen:

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

<p>
Wenn diese Datei sich auf einem NFS-Share befindet und der Benutzer
root versucht, über einen NFS-Client auf sie zuzugreifen, wird ihm
der Zugriff verwehrt bleiben. Dies liegt daran, dass der Server die
Kennung des Benutzers »nobody« verwendet, wenn root auf die Datei
zugreifen möchte. Da der Benutzer nobody aber keine Zugriffsberechtigung
auf diese Datei hat, bleibt sie ihm verwehrt.

<p>
Der Benutzer und die Gruppe, die bei Rootzugriffen genutzt werden,
können über die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>-Datei auf dem NFS-Server eingestellt werden.

<h3>NFS-Status überprüfen</h3>

<p>
Um sicherzustellen, dass der NFS-Betrieb reibungslos verlaufen kann,
überprüfe, ob alle Daemons über RPC erfolgreich registriert wurden.
Verwende hier für rpcinfo(8).

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Für den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen
du den Status von NFS überprüfen kannst. Eines ist <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8"
>showmount(8)</a> das dir anzeigt, wer was gerade mountet. Dann gibt es
auch noch <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsstat&amp;sektion=1"
>nfsstat(1)</a>, das genauere Statistiken anzeigt. Für
showmount(8) versuche
<tt>/usr/bin/showmount -a host</tt>. Zum Beispiel:

<blockquote><pre>
$ <b>/usr/bin/showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
Diese Ausgabe zeigt, dass der Client 10.0.0.37 den vom Server
10.0.0.1 bereitgestellten Export <tt>/work</tt> gemountet hat.


<p>
<a name="Bridge"></a>
<h2>6.9 - Aufsetzen einer Bridge mit OpenBSD</h2>

<p>
Eine <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>Bridge</a> ist ein Link zwischen zwei oder noch mehr separaten
Netzwerken. Anders als ein Router reisen Pakete durch die Bridge
»unsichtbar« - logisch erscheinen die beiden Netzwerksegmente wie eines
für Rechner auf beiden Seiten der Bridge. Die Bridge wird nur Pakete
weiterleiten, die auch von einem Segment in das andere müssen, sie
bieten also auch einen einfachen Weg den Verkehr in einem komplexen
Netzwerk zu reduzieren und erlauben trotzdem den Zugriff jedes Rechners
zu jedem anderen, falls nötig.

<p>
Denk daran, dass aufgrund dieser »unsichtbaren« Natur ein Interface in
einer Bridge eine IP-Adresse haben kann, aber nicht muss. Wenn sie eine
hat, hat die Karte effektiv zwei Betriebsmodi: eine als Teil der Bridge,
die andere als normale eigenständige Netzwerkkarte. Wenn keine der Karten
eine IP-Adresse hat, wird die Bridge einfach Netzdaten verschieben, aber
nicht extern administrierbar oder wartbar sein (was auch ein Feature sein
kann).

<p>
<h3>Ein einfaches Beispiel einer Bridgeanwendung</h3>

<p>
Eines meiner Computerracks hat eine Anzahl alter Systeme, von denen
keines eine eingebaute 10BASE-TX-Netzwerkkarte hat. Während sie alle
einen AUI- oder AAUI-Stecker haben, sind die Empfänger auf Koax
beschränkt. Eine der Maschinen in diesem Rack ist ein OpenBSD-basierter
Terminalserver, der dauerhaft eingeschaltet und immer mit einem
Highspeed-Netzwerk verbunden ist. Das Hinzufügen einer zweiten
Netzwerkkarte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge
zum Koax-Netzwerk zu benutzen.

<p>
Dieses System hat jetzt zwei Netzwerkkarten (NICs), eine Intel
EtherExpress/100 (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"
><tt>fxp0</tt></a>) und eine 3c590-Combokarte (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"
><tt>ep0</tt></a>) für den Koax-Port. <tt>fxp0</tt> ist der Link zu
meinem restliches Netzwerk und wird daher eine IP-Adresse haben,
<tt>ep0</tt> macht nur Bridging und hat daher keine. Maschinen, die an
das Koax-Segment angeschlossen sind, sollen genau so kommunizieren, als
wenn sie im Rest meines Netzwerkes wären. Wie also bewerkstelligen wir
das?

<p>
Die Datei <tt>hostname.fxp0</tt> enthält die Konfigurationsdaten
für die <tt>fxp0</tt>-Karte.  Diese Maschine soll DHCP machen,
also sieht die Datei etwa so aus:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE
</pre></blockquote>

<p>
Noch keinerlei Überraschungen.

<p>
Die <tt>ep0</tt>-Karte ist ein wenig anders, wie du dir denken kannst:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

<p>
Hier sagen wir dem System, es möge das Interface mittels <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> aktivieren und auf 10BASE-2 (Koax) setzen. Keine
IP-Adresse oder ähnliche Information muss für dieses Interface
spezifiziert werden. Die Optionen, die von der <tt>ep</tt>-Karte
akzeptiert werden, sind detailliert in der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"
>Handbuchseite</a> aufgeführt.

<p>
Jetzt müssen wir die Bridge aufsetzen. Bridges werden durch die Existenz
einer Datei, die so ähnlich heißt wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
><tt>hostname.bridge0</tt></a>,
initialisiert. 
Hier ist ein Beispiel für meine Situation hier:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

<p>
Das sagt aus, es soll eine Bridge aus zwei NICs aufgesetzt und aktiviert
werden: fxp0 und ep0. Es ist egal, in welcher Reihenfolge die Karten
aufgeführt werden. Denke daran, dass die Bridge symmetrisch ist - Pakete
fließen ja in beide Richtungen.

<p>
Das war es! Starte neu und du wirst eine funktionierende Bridge haben.

<p>
<h3>Eine als DHCP-Server fungierende Brücke</h3>

<p>
Angenommen, wir verfügen über ein kleines System, das vier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vr&amp;sektion=4"
>vr(4)</a> Schnittstellen besitzt, vr0 bis vr3.
Wir möchten vr1, vr2 und vr3 mit einer Brücke verbinden, und vr0 als
Netzanbindung (z.&nbsp;B. für ein Kabelmodem) auslassen.
Ebenso möchten wir IP-Adressen durch DHCP über die verbrückten Schnittstellen
anbieten.
Als DHCP-Server und Router für die Netzanbindung muss die Maschine über eine
IP-Adresse in dem verbrückten Netzwerk verfügen (im Gegensatz zum vorigen
Beispiel, in welchem die überbrückende Maschine im Netzwerk nicht sichtbar
war).

<p>
Es ist nicht möglich, einer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>-Schnittstelle eine IP-Adresse direkt zuzuweisen.
Die IP-Adresse sollte einem der teilnehmenden Schnittstellen hinzugefügt
werden, jedoch können wir keine physische Schnittstelle benutzen, da keine
aktive Anbindung an das Netz vorhanden sein könnte, in welchem Falle die
Adresse nicht erreichbar wäre.
Glücklicherweise, beginnend mit OpenBSD 4.7, gibt es einen Treiber für eine
virtuelle Ethernet-Schnittstelle, nämlich
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vether&amp;sektion=4"
>vether(4)</a>, der für diese Zweck genutzt werden kann.
Wir fügen ihn der Brücke hinzu, weisen ihm die IP-Adresse zu, und lassen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8"
>dhcpd(8)</a> dort auf Anfragen warten.

<p>
Bemerkungen:

<ul>
<li>Die <a href="#DHCPserver">DHCP-Server-Konfiguration</a> wird hier nicht
noch einmal beschrieben, da das Adressschemata das gleiche ist.
<li>Dies wird ebenfalls der Router für die Netzanbindung unseres überbrückten
Netzwerks, sodass wir die IP-Adresse 192.168.1.1 nutzen, um der
DHCP-Serverkonfiguration zu entsprechen.
<li>Wir besprechen hier weder die Konfiguration der Netzanbindung, des Routings
noch der Firewall.</li>
</ul>

<p>Als erstes kennzeichne vr1, vr2 and vr3 als aktiv:

<blockquote><pre>
$ <b>cat /etc/hostname.vr1</b>
up
$ <b>cat /etc/hostname.vr2</b>
up
$ <b>cat /etc/hostname.vr3</b>
up
</pre></blockquote>

<p>
Erzeuge dann die Konfiguration für vether0:

<blockquote><pre>
$ <b>cat /etc/hostname.vether0</b>
inet 192.168.1.1 255.255.255.0 192.168.1.255
up
</pre></blockquote>

<p>
Wir konfigurieren die Brückenschnittstelle, sodass sie alle oben aufgeführten
Schnittstellen enthält:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add vether0
add vr1
add vr2
add vr3
up
</pre></blockquote>

<p>
Und schlussendlich lassen wir dhcpd(8) auf der vether0-Schnittstelle lauschen:

<blockquote><pre>
$ <b>grep ^dhcpd_flags= /etc/rc.conf.local</b>
dhcpd_flags="vether0"
</pre></blockquote>

<p>
Starte den Computer neu -- und voil&agrave;!

<p>
<h3>Filtern auf der Bridge</h3>

Während es sicher auch eine Menge Anwendungen für eine solch einfache
Bridge gibt, ist es doch wahrscheinlich, dass du etwas mit den ganzen
Paketen TUN willst, während sie durch deine Bridge laufen. Wie zu
erwarten, kann man <a href="#PF">Packet Filter</a> dazu benutzen, den
Traffic einzuschränken, der durch deine Bridge fließt.

<p>
Denke daran, dass wegen der Natur der Bridge die gleichen Daten
über beide Interfaces fließen, aber du nur auf einem Interface
filtern brauchst. Deine »pass all«-Statements würden dann
wie folgt aussehen:

<blockquote><pre>
pass in  on ep0  any
pass out on ep0  any
pass in  on fxp0 any
pass out on fxp0 any
</pre></blockquote>

<p>
Sagen wir nun, ich wolle den Traffic filtern, der auf diese alten
Maschinen trifft. Ich möchte, dass nur Web- und SSH-Verkehr zu ihnen
durchkommt. In diesem Fall lassen wir jeglichen Verkehr durch das
<tt>ep0</tt>-Interface zu (sowohl rein als auch raus) aber filtern auf
dem <tt>fxp0</tt>-Interface, indem wir <tt>keep state</tt> für die
Antwortdaten benutzen:

<blockquote><pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre></blockquote>

<p>
Denke daran, dass dieses Regelwerk jeglichen Netzwerkverkehr
mit Ausnahme von hereinkommendem HTTP- und SSH-Verkehr zur Bridge selbst
und den Maschinen »dahinter« verhindert. Andere Resultate werden erzielt,
wenn man auf dem anderen Interface filtert.

<p>
Um die Bridge zu überwachen und zu kontrollieren, benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>-Kommando, mit dem man eine Bridge auch nach dem Booten
erzeugen kann.

<p>
<h3>Tipps zum Bridging</h3>

<ul>
<li>Es wird WÄRMSTENS empfohlen, nur auf einem Interface zu filtern.
Wenn es auch möglich ist, auf beiden zu filtern, muss man das vorher
jedoch sehr gut verstanden haben.

<li>Durch die Benutzung der <i>blocknonip</i>-Option von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> oder in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.bridge0</a>,
kannst du jeglichen Datenverkehr, der nicht
zum IP-Traffic gehört (wie etwa IPX oder NETBEUI), davon abhalten, sich
um deine Filter herumzustehlen. Das kann in einigen Situationen sehr
wichtig sein, aber du solltest wissen, dass Bridges für jeglichen
Datenverkehr funktionieren, nicht nur für IP.

<li>Für Bridging müssen die NICs im »promiscuous mode« sein - sie
lauschen einfach am GESAMTEN Netzwerkverkehr, nicht nur an dem, der
an das Interface gerichtet ist. Das hat einen höheren Load für
CPU und Bus zur Folge, als man denkt. Einige NICs funktionieren leider
nicht sauber in diesem Modus, der TI-ThunderLAN-Chip (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4"
>tl(4)</a>) ist leider so ein Beispiel, der nicht als Teil einer Bridge
funktioniert.
</ul>

<a name="PXE"></a>
<h2>6.10 - Wie boote ich mit PXE? (i386, amd64)</h2>
Das »Preboot Execution Environment« (oder kurz PXE) ist ein Weg, um
einen Computer statt von Festplatte, Diskette oder CD-ROM vom Netzwerk
zu booten. Diese Technologie wurde zuerst von Intel entwickelt, doch
wird nun von den meisten führenden Netzwerkkarten- und
Computerherstellern unterstützt. Bedenke, dass es viele verschiedene
Netzwerkbootprotokolle gibt: PXE ist relativ neu. Traditionellerweise
wird das PXE-Booting unter Verwendung von ROMs auf dem NIC oder dem
Mainboard ausgeführt, doch sind ebenfalls Bootdisketten von etlichen
Quellen verfügbar, die ebenfalls das PXE-Booting zulassen. Viele ROMs
auf älteren NICs unterstützen zwar das Booten vom Netzwerk, allerdings
NICHT PXE; OpenBSD/i386 oder am64 können mit diesen zurzeit nicht über
das Netzwerk gebootet werden.



<p>
<h3>Wie funktioniert das PXE-Booting?</h3>
Zuerst sollte die Funktionsweise des
<a href="faq14.html#Boot386">OpenBSD-Bootprozesses</a> auf i386- und
am64-Plattformen verstanden werden. Auf den Bootprozess folgend sendet
die PXE-fähige NIC eine DHCP-Anfrage über das Netzwerk. Der DHCP-Server
wird dem Adapter eine IP zuweisen und gibt ihm den Namen einer Datei,
die von einem <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>-Server bezogen und ausgeführt werden muss. Diese Datei
leitet dann den Rest des Bootprozesses ein. Für OpenBSD ist es die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>-Datei, die den Platz der standardmäßigen <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot(8)</a>-Datei einnimmt. pxeboot(8) ist dann in der Lage, einen
Kernel wie zum Beispiel <tt>bsd</tt> oder <a
href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a> vom gleichen tftp(1)-Server
zu laden und auszuführen.

<h3>Wie mache ich das?</h3>
Der erste und offensichtlichste Schritt ist, dass du einen
PXE-bootfähigen Computer oder Netzwerkadapter haben musst. Einige
Dokumente weisen darauf hin, dass alle modernen NICs und Computer
PXE-Unterstützung hätten, aber das ist einfach nicht wahr -
viele Niedrigpreissysteme liefern keine PXE-ROMs mit oder verwenden
ein älteres Netzwerkbootprotokoll. Du brauchst außerdem einen
ordentlich konfigurierten <a href="#DHCP">DHCP</a>- und TFTP-Server.

<p>
Davon ausgehend, dass eine OpenBSD-Maschine die Quelle der Bootdateien
ist, muss die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5"
>dhcpd.conf</a>-Datei des DHCP-Servers folgende Zeile beinhalten:
<pre>
    filename "pxeboot";
</pre>
damit der DHCP-Server diese Datei dem bootenden Arbeitsplatz anbietet.
Zum Beispiel:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Du musst außerdem den <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8"
>tftpd(8)</a>-Daemon aktivieren.
Normalerweise geschieht dies durch das Hinzufügen der Zeile
"<tt>tftpd_flags=/tftpboot</tt>" zu deiner <tt>/etc/rc.conf.local</tt>-Datei.
tftpd(8) bietet die Dateien von einem bestimmten
Verzeichnis an, in dem Fall von dieser Zeile ist es das
<tt>/tftpboot</tt>-Verzeichnis, welches wir für dieses Beispiel
verwenden werden. Offensichtlich ist, dass dieses Verzeichnis angelegt
und eingerichtet werden muss. Typischerweise wirst du hier nur ein paar
Dateien für das PXE-Booting haben:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, der PXE-Bootloader (der die gleichen Funktionen
bereitstellt wie <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> auf einem plattenbasierten System).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, der Installationskernel, oder
<tt>bsd</tt>, ein angepasster Kernel.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, eine Bootkonfigurationsdatei.
</ul>

Denke daran, dass <tt>/etc/boot.conf</tt> nur gebraucht wird, wenn der
Kernel, den du booten möchtest, nicht <tt>bsd</tt> heißt oder andere
pxeboot-Standardwerte nicht so sind, wie du sie haben möchtest
(zum Beispiel, wenn du eine serielle Konsole wünschst).
Du kannst deinen tftpd(8)-Server mit einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>-Client testen, indem du sicherstellst, dass du die
benötigten Dateien herunterladen kannst.

<p>
Wenn deine DHCP- und TFTP-Server laufen, bist du bereit, es auszuprobieren.
Du wirst PXE-Boot auf deinem System oder auf der Netzwerkkarte aktivieren
müssen; konsultiere deine Systemdokumentation. Wenn du es gesetzt hast,
solltest du etwas sehen, das diesem ähnlich ist:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 3.19
    boot>
</pre>

Zu diesem Zeitpunkt hast du den normalen OpenBSD-Bootprompt.
Wenn du hier einfach »<tt>bsd.rd</tt>« eintippst, wirst du die Datei
<tt>bsd.rd</tt> von dem TFTP-Server laden.

<pre>
    >> OpenBSD/i386 PXEBOOT 3.19
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2013 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 5.4 (RAMDISK_CD) #34: Tue Jul 30 12:20:01 MDT 2013
      ...
</pre>

Der <a href="faq4.html#bsd.rd">bsd.rd-Installationskernel</a> wird nun
booten.

<p>

<h3>Kann ich außer <tt>bsd.rd</tt> auch andere OpenBSD Kernel via PXE
booten?</h3>

Ja, obwohl mit den Programmen, die zurzeit in OpenBSD enthalten sind,
PXE-Booting primär für die Installation des OS gedacht ist.

<p>
<a name="CARP"></a>
<h2>6.11 - Das Common-Address-Redundancy-Protokoll (CARP)</h2>
<h3>6.11.1 - Was ist CARP und wie funktioniert es?</h3>
<!-- This article written by Sunny Raspet, slr@@mordac.info, and
released under the BSD license -->

<p>
CARP ist ein Werkzeug um beim Erreichen von Systemredundanz zu helfen,
indem mehrere Computer ein einzelnes, virtuelles Netzwerkinterface
zwischen sich errichten, sodass beim Ausfall eines Systems ein
anderes antworten kann. Des Weiteren wird somit ein gewisser Grad an
Lastverteilung zwischen Systemen ermöglicht. CARP ist eine Verbesserung
vom Standard Virtual-Router-Redundancy-Protokoll (VRRP). Es wurde
entwickelt, nachdem VRRP als nicht frei genug wegen einem
möglicherweise überlappendem Cisco-Patent angesehen wurde. Für weitere
Informationen über CARPs Ursprünge und den rechtlichen Problemen mit
VRRP, besuche bitte <a href="../../lyrics.html#35">diese Seite</a>.

<p>
Um gesetzliche Konflikte zu umgehen, entwarf Ryan McBride (mit Hilfe von
Michael Shalayeff, Marco Pfatschbacher und Markus Friedl) CARP so, dass
es fundamental anders war. Die Einbindung von Kryptographie ist eine der
prominentesten Änderungen - aber weiterhin nur eine von vielen.

<p>
Wie es funktioniert: CARP ist ein Multicast-Protokoll. Es gruppiert
mehrere physikalische Computer unter einer oder mehreren virtuellen
Adressen zusammen. Von diesen ist ein System der Master und antwortet
auf alle Pakete, die für diese Gruppe bestimmt sind, während die anderen
Systeme als Hotspares agieren. Unbedeutend wie die IP- und MAC-Adressen
des lokalen Interfaces sind, werden Pakete, die zum CARP-Interface
gesendet worden sind, mit CARP-Informationen zurückgesendet.

<p>
Zu konfigurierbaren Intervallen bekundet der Master seine Operation auf
der IP-Protokollnummer 112. Wenn der Master offline geht, beginnen die
anderen Systeme in der CARP-Gruppe mit dem bekunden. Der Host, der in
der Lage ist am häufigsten zu bekunden, wird der neue Master. Wenn das
Hauptsystem wieder online kommt, wird es standardmäßig ein Backuphost,
obwohl wenn es wünschenswerter ist, dass ein Host immer Master wird wenn
das möglich ist (z.&nbsp;B. wenn ein Host eine schnelle Sun Fire V120
ist und die anderen vergleichbar langsame SPARCstation IPCs sind),
kannst du sie so konfigurieren.

<p>
Während hoch redundante und fehlertolerante Hardware die Notwendigkeit
von CARP verringert, vernichtet sie sie nicht. Es gibt keine
Hardwarefehlertoleranz die in der Lage ist zu helfen, wenn jemand das
Stromkabel herauszieht oder wenn dein Systemadministrator
<tt>reboot</tt> im falschen Fenster eintippt. CARP macht es außerdem
einfacher, den Patch- und Rebootzyklus transparent den Anwendern
gegenüber zu gestalten, und einfacher ein Software- oder Hardwareupgrade
zu testen - wenn es nicht funktioniert, kannst du auf deine Spares
zurückgreifen, bis es behoben ist.

<p>Es gibt jedoch Situationen, in denen CARP nicht helfen wird.
CARPs Design setzt voraus, dass die Mitglieder einer Gruppe sich im
selben physikalischen Subnetz mit einer statischen IP-Adresse befinden,
obwohl mit der Einführung der carpdev-Direktive es keine Notwendigkeit
mehr gibt, den physischen Interfaces IP-Adressen zuzuweisen. Ähnlich
werden Dienste, die eine durchgehende Verbindung zum Server benötigen
(so wie SSH oder IRC), nicht transparent auf andere Systeme
weitergeleitet - obwohl in diesem Fall CARP helfen kann, die Ausfallzeit
zu minimieren. CARP wird von sich aus Daten zwischen Applikationen nicht
synchronisieren, dies muss über »alternative Kanäle« wie zum Beispiel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4"
>pfsync(4)</a> (für redundantes Filtern), manuelles Duplizieren von
Daten zwischen Systemen mit <a href="http://rsync.samba.org/">rsync</a>
oder was auch immer für deine Anwendungen geeignet ist, durchgeführt
werden.

<h3>6.11.2 - Konfiguration</h3>

<p>
CARPs Kontrollen befinden sich an zwei Orten: <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a> und <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Lass uns nun zuerst die sysctls betrachten.

<p>Die erste sysctl namens <tt>net.inet.carp.allow</tt> definiert, ob
der Host überhaupt CARP-Pakete handhabt. Klarerweise ist dies notwendig,
um CARP nutzen zu können. Diese sysctl ist standardmäßig aktiviert.

<p>Die zweite, <tt>net.inet.carp.log</tt>, logged CARP Zustandsänderungen,
schlechte Pakete und andere Fehler.  Setze diese Variable, um die genannten
Meldungen standardmäßig zu loggen.

<p>Die dritte namens <tt>net.inet.carp.preempt</tt> aktiviert natürliche
Auswahl zwischen CARP-Hosts. Der passendste für den Job (das heißt, wer
in der Lage ist am schnellsten zu bekunden) wird zum Master.
Standardmäßig deaktiviert: Das bedeutet, dass ein System, das nicht
zum Master auserwählt wurde, nicht versuchen wird den Masterstatus
(wieder) zu erhalten.

<p>
Alle diese sysctl-Variablen sind in <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3"
>sysctl(3)</a> dokumentiert.

<p>Für den Rest von CARPs Konfiguration verlassen wir uns auf <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>. Die CARP-spezifischen Kommandos <tt>advbase</tt> und
 <tt>advskew</tt> behandeln das Intervall zwischen CARP-Advertisements.
Die Formel (in Sekunden) ist <tt>advskew</tt> dividiert durch 256 und
dann zu <tt>advbase</tt> addiert.
<tt>advbase</tt> kann verwendet werden, um Netzwerkverkehr zu verringern
oder eine längere Latenz zuzulassen, bevor ein Backuphost übernimmt;
<tt>advskew</tt> lässt dir die Möglichkeit zu verwalten, welcher
Host Master sein wird, ohne große Failoververzögerungen
(sollte das notwendig sein).

<p>Als nächstes setzt <tt>pass</tt> ein Passwort und <tt>vhid</tt> die
virtuelle Hostidentifizierungsnummer der CARP-Gruppe. Du musst jeder
CARP-Gruppe eine einzigartige Nummer verteilen, selbst wenn (für
Lastverteilung) sie sich die gleiche IP-Adresse teilen.  CARP ist auf
255 Gruppen begrenzt.

<p>
Zum Schluss gibt <tt>carpdev</tt> an, welches physische Interface zu
dieser bestimmten CARP-Gruppe gehört.
Standardmäßig gilt, dass jedes Interface, das eine IP-Adresse im
gleichen Subnetz von CARP zugewiesen bekam, genutzt wird.

<p>Lass uns alle diese Einstellungen zusammen in eine Grundkonfiguration
packen. Angenommen du setzt zwei identische Webserver auf,
<i>rachael</i> (192.168.0.5) und <i>pris</i> (192.168.0.6), um ein
älteres System zu ersetzen, das unter 192.168.0.7 verfügbar war. Die
Befehle:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>erstellen das carp0-Interface und geben es eine vhid von 1, ein
Passwort, das <i>tyrell</i> lautet, und die IP-Adresse 192.168.0.7 mit
der Maske 255.255.255.0. Weise fxp0 als Mitgliedsinterface zu. Um es
über die nächsten Reboots hinaus permanent zu machen, kannst
du eine <tt>/etc/hostnamecarp0</tt>-Datei anlegen, die wie folgt
aussieht:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev fxp0
</pre></blockquote>

Achte darauf, dass die Broadcastadresse in der Zeile neben der vhid
und dem Passwort mit angegeben wurde. Das Vergessen der Angabe dieser
Adresse ist ein häufiger Grund für Fehler, da sie als Platzhalter
benötigt wird.

<p>
Mache das Gleiche auf <i>pris</i>. Welches System von beiden das
CARP-Interface zu erst aufsetzt wird Master (unter der Annahme, dass
»preempt« deaktiviert ist; das Gegenteil ist der Fall, wenn »preempt«
aktiviert wurde).

<p>

Aber lass uns sagen, dass du nicht von Anfang an aufsetzt.
<i>rachael</i> war bereits unter der Adresse 192.168.0.7 vorhanden.
Wie umgehst du das? Glücklicherweise kann CARP mit dieser Situation
umgehen. Du kannst die Adresse einfach dem CARP-Interface zuweisen und
das physikalische Gerät bei der Angabe des »carpdev«-Schlüsselwortes
belassen, ohne eine IP-Adresse zuzuweisen. Trotz allem tendiert es dazu
sauberer zu sein jeweils eine IP für jedes System zu haben - es macht
individuelle Überwachungen und Zugriffe viel einfacher.

<p>Lass uns nun einen weiteren Schwierigkeitsgrad hinzufügen; wir
möchten, dass <i>rachael</i> so lange wie möglich Master bleibt.
Es gibt einige Gründe, warum wir das benötigen könnten:
Hardwareunterschiede, einfache Vorurteile, »wenn das System nicht Master
ist, wird es Probleme geben« oder zu wissen, wer der standardmäßige
Master ist ohne mit Skripten die Ausgabe von ifconfig zu verarbeiten und
per E-Mail zu versenden.

<p>Auf <i>rachael</i> werden wir die sysctl verwenden, die wir weiter
oben erstellt haben und editieren dann <tt>/etc/sysctl.conf</tt>, um sie
permanent zu machen.

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Wir werden ebenfalls die Konfiguration auf <i>pris</i> durchführen:

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>Dies verzögert die Bekundungen von <i>pris</i> ein wenig, was
bedeutet, dass <i>rachael</i> Master sein wird, wenn der Host
angeschlossen wurde.

<p>
Bedenke, dass du »proto carp« mit folgender Zeile an alle beteiligten
Interfaces übergeben musst, wenn du PF auf einem geCARPten Computer
verwendest:
<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Lastverteilung</h3>

<p>Siehe nun einige Monate nach vorne. Unsere Firma des vorherigen
Beispiels ist so gewachsen, dass sie an dem Punkt angekommen ist, an dem
ein einzelner Webserver die Last gerade so verarbeiten kann. Was nun?
CARP ist die Rettung. Es ist Zeit, Lastverteilung zu versuchen. Erstelle
ein neues CARP-Interface und eine neue CARP-Gruppe auf <i>rachael</i>:

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>Auf <i>pris</i> werden wir ebenfalls eine neue Gruppe und Interface
anlegen und dann das »preempt«-sysctl setzen:

<blockquote><pre>
pris# <b>ifconfig carp1 carp1</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Nun haben wir zwei CARP-Gruppen mit der gleichen IP-Adresse.
Jede Gruppe zeigt auf einen anderen Host. Das bedeutet, dass
<i>rachael</i> Master der originalen Gruppe bleibt, aber <i>pris</i> die
neue übernehmen wird.

<p>Während diese Beispiele für einen Cluster bestehend aus zwei
Maschinen sind, gelten die gleichen Prinzipien auch für mehrere Systeme.
Bitte bedenke, dass es trotzdem nicht erwartet wird, dass du perfekte
50/50-Distribution zwischen den beiden Maschinen erreichst - CARP
verwendet einen Hash der ankommenden IP-Adresse um zu ermitteln, welches
System die Anfrage verarbeitet, statt durch Auslastung zu entscheiden.

<h3>6.11.4 - Weitere Informationen zu CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall
Failover with pfsync and CARP</a> von Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - OpenNTPD verwenden</h2>
Genaue Zeit ist wichtig für viele Computerapplikationen.
Trotzdem mussten viele Leute feststellen, dass ihre $5-Uhr eine genauere
Uhrzeit halten kann als ihr $2000-Computer. Zusätzlich zum Wissen,
welche Uhrzeit gerade ist, ist es ebenfalls häufig wichtig, Computer zu
synchronisieren, sodass sie alle mit der gleichen Uhrzeit
übereinstimmen. Für eine gewisse Zeit hat <a
href="http://www.ntp.org">ntp.org</a> ein Applikation für das
 Network-Time-Protokoll (<a
href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>, <a
href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>) entwickelt,
verfügbar als <a href="faq15.html#Ports">Portierung</a>, die verwendet werden
kann, um die Uhren auf den Computern über das Internet zu
synchronisieren.  Trotzdem ist dies ein nicht triviales Programm zum
Einrichten, schwerer Code zum Überprüfen und hat eine große
Speicheranforderung. Kurz gesagt spielt es eine wichtige Rolle für
einige Leute, aber es ist weit entfernt von einer Lösung für jedermann.

<p>
<a href="http://www.openntpd.org/de">OpenNTPD</a> ist ein Versuch,
einige dieser Probleme zu lösen, es einfacher zu administrieren zu
machen und ein sicherer und simpler NTP-kompatibler Weg zu sein, um eine
genaue Uhrzeit auf deinem Computer zu haben. OpenBSDs <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8"
>ntpd(8)</a> wird von einer einfach zu verstehenden Konfigurationsdatei
gesteuert: <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"
><tt>/etc/ntpd.conf</tt></a>.

<p>
Aktiviere ntpd(8) einfach in <a href="faq10.html#rc">rc.conf.local</a>
und das Resultat wird sein, dass deine Computeruhr nach und nach
weiter nach vorne gestellt wird, bis sie sich selbst mit den <a
href="http://www.pool.ntp.org/">pool.ntp.org</a>-Servern synchronisiert
halten kann - einer Sammlung von öffentlich verfügbaren Zeitservern.
Wenn deine Uhr erst einmal genau eingestellt ist, wird ntpd sie auf einem
sehr hohen Genauigkeitsgrad halten. Sollte deine Uhr jedoch um einige
Minuten falsch gehen, so wird <i>dringend</i> dazu geraten, sie zuerst
genau einzustellen, da es Tage oder sogar Wochen dauern kann, eine sehr
ungenau eingestellte Uhr zu synchronisieren. Du kannst dies tun, indem
du entweder die Option »<tt>-s</tt>« an ntpd(8) übergibst oder aber
einen anderen Weg findest, wie du deine Systemzeit richtig einstellen
kannst.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - »Aber OpenNTPD ist nicht so genau wie der ntp.org-Daemon!«</h3>
Das mag wahr sein. Es ist nicht OpenNTPDs
<a href="http://www.openntpd.org/de/goals.html">Entwurfssziel</a>. Es
ist vorgesehen, dass es frei, simpel, zuverlässig und sicher ist.
Wenn du wirklich Mikrosekundenpräzision mehr als die Vorteile von
OpenNTPD brauchst, tu dir keinen Zwang an und verwende ntp.orgs ntpd, da
er weiterhin als Portierung und Paket verfügbar sein wird.
Es existieren
weder ein Plan noch das Verlangen, OpenNTPD mit allen vorstellbaren
Funktionen vollzustopfen.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - »Jemand hat behauptet, dass OpenNTPD schädlich ist!«</h3>
Einige Leute haben die Ziele von OpenNTPD nicht verstanden: ein
einfacher, sicherer und einfach zu verwaltender Weg, um die Uhr deines
Computers genau zu halten. Wenn genaue Zeit wichtig ist, haben einige
Benutzer berichtet, dass die Ergebnisse von OpenNTPD besser sind als
die von ntp.orgs ntpd. Wenn Sicherheit wichtig ist, ist OpenNTPDs Code
sehr viel besser lesbar (und daher kontrollierbar) und wurde unter
Verwendung von OpenBSD-Funktionsaufrufen wie <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3"
>strlcpy</a> statt portableren Funktionen wie <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3"
>strcpy</a> entwickelt und wurde von Anfang an sicher geschrieben und
nicht »später sicher gemacht«. Wenn es wertvoll ist, dass so viele Leute
wie möglich Zeitsynchronisierung verwenden, macht es OpenNTPD einer
großen Anzahl Leute einfacher, diese zu nutzen. Wenn das
»schädlich« ist, stimmen wir dem voll und ganz zu.

<p>
Es gibt Anwendungsgebiete, bei denen ntp.orgs ntpd genauer ist, trotzdem
geht man davon aus, dass für einen Großteil der restlichen Anwender
OpenNTPD mehr als ausreichend sein wird.

<p>
Eine ausführlichere Antwort hierauf von den OpenNTPD-Entwicklern kannst
du <a
href="http://www.advogato.org/person/dtucker/diary.html?start=52"
>hier</a> lesen.

<a name="OpenNTPDNoServe"></a>
<h3>6.12.3 - Warum können meine anderen Systeme nicht ihre
Uhrzeit mit OpenNTPD abgleichen?</h3>

Standardmäßig hört ntpd(8) auf keiner Adresse. Damit du OpenNTPD also
als Server verwenden kannst, musst du die Zeile
»<tt>#listen&nbsp;on&nbsp;*</tt>« in <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"
>/etc/ntpd.conf</a> auskommentieren und den ntpd(8)-Daemon neustarten.
Selbstverständlich kannst du auch eine bestimmte IP-Adresse angeben, so
dass er nicht auf allen verfügbaren Adressen und Interfaces hört:
ersetze »*« mit der gewünschten Adresse.

<p>
Obwohl nun ntpd(8) erreichbar ist, kann es durchaus passieren, dass sich
andere Maschinen noch immer nicht synchronisieren können. Ein erst
kürzlich gestarteter ntpd(8)-Daemon (wenn du zum Beispiel jetzt gerade
nach der Anpassung der ntpd.conf neugestartet hast) verweigert die
Angabe von Zeitinformationen an andere Clients, bis er seine eigene
Uhrzeit auf ein hinnehmbar stabiles Maß angepasst hat. Wenn ntpd(8)
seine eigene Zeitinformation als stabil betrachtet, wird der Eintrag
»clock now synced« in <tt>/var/log/daemon</tt> geschrieben. Selbst wenn
die Systemzeit bereits von Anfang an sehr genau war, kann es bis zu 10
Minuten dauern, bis alles synchronisiert ist - wenn die Uhrzeit nicht
genau eingestellt ist sogar Stunden oder Tage.


<p>
<a name="Wireless"></a>
<h2>6.13 - Welche Möglichkeiten stehen mir für Drahtlosnetzwerke zur
Verfügung?</h2>
OpenBSD hat Unterstützung für eine Vielzahl an Wireless-Chipsätzen:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4">acx(4)</a>
TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
driver for Atheros 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=athn&amp;sektion=4">athn(4)</a>
driver for Atheros 802.11/a/g/n devices.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB 802.11b
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bwi&amp;sektion=4">bwi(4)</a>
Broadcom AirForce 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cnw&amp;sektion=4">cnwi(4)</a>
Xircom CreditCard Netwave
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 802.11b. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG 802.11a/b/g. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwn&amp;sektion=4">iwn(4)</a>
Intel WiFi Link 4965/5100/5300 802.11a/b/g/Draft-N wireless.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=malo&amp;sektion=4">malo(4)</a>
Marvell Libertas 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ray&amp;sektion=4">ray(4)</a>
Raytheon Raylink/WebGear Aviator 802.11FH
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 802.11b. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4">rum(4)</a>
Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=run&amp;sektion=4">run(4)</a>
Ralink Technology USB 802.11a/b/g/Draft-N
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4">uath(4)</a>
Atheros USB 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=upgt&amp;sektion=4">upgt(4)</a>
Conexant/Intersil PrismGT SoftMAC USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=urtw&amp;sektion=4">urtw(4)</a>
Realtek RTL8187L USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4">wpi(4)</a>
Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=zyd&amp;sektion=4">zyd(4)</a>
ZyDAS ZD1211/ZD1211B USB 802.11b/g
</ul>

<sup>(AP)</sup> weist darauf hin, dass diese Karte als Accesspoint
eingesetzt werden kann.<br>
<sup>(NFF)</sup> weist darauf hin, dass der Chip eine nicht freie
Firmware benötigt, die nicht in OpenBSD eingebunden werden kann.

<p>
Karten, die auf diesen Chips basieren, können fast genauso wie andere
Netzwerkkarten genutzt werden, um ein OpenBSD-System mit Hilfe von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> an ein existierendes Drahtlosnetzwerk anzubinden (bitte
lies die Handbuchseiten für präzise Details). Einige dieser Karten können
jedoch auch im hostbasierten Accesspointmodus genutzt werden, das ihnen
erlaubt, in deinen Wireless-Accesspoint für dein Netzwerk als Teil
deiner Firewall gesetzt zu werden.

<p>
Beachte bitte, dass du für einige Karten erst die Firmwaredateien
beziehen musst, bevor du sie einsetzen kannst. Dies gilt für alle
Firmwaredateien, für die die Hersteller keine <a
href="faq1.html#ReallyFree">freie</a> Weiterverbreitung erlauben,
sodass sie nicht in OpenBSD eingebunden werden können. Wenn möglich,
dann lies die zuvor aufgelisteten Handbuchseiten. Sie beinhalten
Kontaktadressen für die zuständigen Mitarbeiter der Firma, sodass du
sie anschreiben und ihnen mitteilen kannst, wie du darüber denkst.
Oder teile ihnen mit, welches Produkt du stattdessen erworben hast.

<p>
Eine andere Möglichkeit, mit deiner OpenBSD-basierten Firewall einen
Wireless Access anzubieten, ist die Verwendung einer konventionellen NIC
und einem externen Bridging-Accesspoint.
Dies hat den zusätzlichen Vorteil, dass du die Position der Antenne
mit Leichtigkeit an die Stelle ändern kannst, an der sie am
effektivsten ist, was nicht häufig direkt auf der Rückseite
deiner Firewall ist.

<p>
<h3>Konfiguration deines Drahtlos-Adapters</h3>

Deine Drahtlos-Adapter können mit Hilfe einer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>-Datei konfiguriert werden, wie andere Netzwerkadapter auch,
jedoch sind sie, da sie mehr Optionen haben, oft ein wenig komplizierter.

<p>
Beispiele einer »hostname«-Datei für Drahtlos wären, z.&nbsp;.:
<blockquote><pre>
nwid puffyuberalles
wpakey puffyguffy
dhcp
</pre></blockquote>
oder
<blockquote><pre>
inet 10.0.0.157 255.255.255.0
nwid puffyuberalles
wpakey puffyguffy
</pre></blockquote>

Beachte, dass das <tt>dhcp</tt> NACH den anderen Konfigurationszeilen kommen
sollte, da der Netzwerkadapter keine Anfrage via DHCP stellen kann, solange er
nicht konfiguriert ist.

<h3>Bringe deine Drahtlos-Adapter unter einen Schirm - via trunk(4)</h3>
Viele Laptops haben sowohl einen Drahtlos- als auch eine fest-verdrahteten
Adapter.
Manchmal wirst du direkt mit deinem Hochgeschwindigkeitsnetzwerk verbunden
sein, und dessen volle Geschwindigkeit in Anspruch nehmen wollen, zu anderen
Zeiten jedoch Drahtlos funken wollen
Vielleicht willst du nicht mit jedem Ortswechsel deine Maschine neu
konfigurieren wollen.

<p>
Du KÖNNTEST beide Schnittstellen via DHCP einrichten, aber dann müsstest du
darauf warten, das während des Startvorgangs das Konfigurations-Zeitlimit der
gerade unbenutzten Schnittstellen abläuft, und außerdem wären die Umstände ein
wenig verwirrend wenn beide Ressourcen verfügbar wären, und das hin- und
herschalten zwischen den Ressourcen wäre ein wenig lästig.

<p>
Die Nutzung eines
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=trunk&amp;sektion=4"
>trunk(4)</a>-Geräts mag dein Leben erleichtern.
trunk(4)s sind virtuelle Schnittstellen, die aus einem oder mehreren
Netzwerkschnittstellen bestehen. 
In diesem Fall nutzen wir einen Laptop mit einer verdrahteten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bge&amp;sektion=4"
>bge0</a> und einer drahtlosen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwn&amp;sektion=4"
>iwn0</a> Schnittstelle.
Mit Hilfe dieser zwei Schnittstellen werden wir uns eine Schnittstelle bauen,
trunk0 genannt, und dann mittels DHCP eine IP-Adresse für diese virtuelle
Schnittstelle anfordern.
Wir wollen die verdrahtete Schnittstelle nutzen, falls sie verfügbar ist,
anderenfalls die drahtlose Schnittstelle.

<p>
Um dies zu erreichen konfigurieren wir zuerst zwei physische Ports.
Da wir sie einzig einer kombinierten Schnittstelle trunk0 zuweisen, machen
wir nicht viel mehr mit der verdrahteten Schnittstelle, als sie zu aktivieren:
<blockquote><pre>
# <b>cat /etc/hostname.bge0</b>
up
</pre></blockquote>

Die drahtlose Schnittstelle braucht jedoch ein wenig mehr Konfiguration.
Es muss sich in unser drahtloses, WPA-gesichertes Netzwerk einhängen:
<pre><blockquote>
# <b>cat /etc/hostname.iwn0</b>
nwid puffynet
wpakey mysecretkey
up
</pre></blockquote>

Nun wird unsere trunk-Schnittstelle wie folgt definiert:
<pre><blockquote>
# <b>cat /etc/hostname.trunk0</b>
trunkproto failover trunkport bge0
trunkport iwn0 
dhcp
</pre></blockquote>

Der trunk wurde im »failover«-Modus konfiguriert, sodass jede Schnittstelle
genutzt werden kann, jedoch bge0 präferiert wird, sollten beide verfügbar sein,
das es als Erstes zu der trunk Schnittstelle hinzugefügt wurde.

<p>
<a name="Multipath"></a>
<h2>6.14 - Wie kann ich »equal-cost multipath routing« durchführen?</h2>

<p>
»Equal-cost multipath routing« bedeutet, dass sich mehrere Routen
in der Routingtabelle für das gleiche Netzwerk befinden - zum
Beispiel die Standardroute 0.0.0.0/0. Wenn der Kernel nach einer Route
sucht, um Pakete an ein bestimmtes Netzwerk senden zu können, kann er
eine von den »equal-cost routes« auswählen. In den meisten Fällen wird
Multipathrouting eingesetzt, um redundante Uplinkverbindungen aufzubauen,
z. B. redundante Internetverbindungen.

<p>
Das Kommando <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8"
>route(8)</a> wird verwendet, um Routen zur Routingtabelle hinzuzufügen,
dort zu ändern oder sie aus der Routingtabelle zu löschen. Das Argument
<tt>-mpath</tt> wird verwendet, um Multipath-Routen hinzuzufügen.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

<p>
Überprüfe die Routen wie folgt:

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

<p>
In diesem Beispiel können wir sehen, dass eine Standardroute auf
10.130.128.1 zeigt, die über das fxp1-Interface erreichbar ist. Die
andere zeigt auf 10.132.0.1 und ist über fxp2 erreichbar.

<p>
Da die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>mygate(5)</a> bisher noch keine Multipath-Standardrouten unterstützt,
sollte der vorherige Befehl an das Ende der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>-Dateien für die Interfaces fxp1 und fxp2 angehängt
werden. Die <tt>/etc/mygate</tt>-Datei sollte danach gelöscht werden.

<dl>
<dt><b>/etc/hostname.fxp1</b></dt>
<dd><tt>!route add -mpath default 10.130.128.1</tt></dd>
<dt><b>/etc/hostname.fxp2</b></dt>
<dd><tt>!route add -mpath default 10.132.0.1</tt></dd>
</dl>

<p>
Vergiss zum Schluss nicht, dass du den Einsatz von Multipathrouten
mit der dafür vorgesehenen sysctl(3)-Variablen aktivieren musst.

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

<p>
Ändere ebenfalls die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>sysctl.conf(5)</a>, um die Änderungen permanent zu machen.

<p>
Versuch nun traceroute mit verschiedenen Zielen aufzurufen. Der
Kernel wird die Datenlast auf die einzelnen Multipathrouten ausgleichen.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre></blockquote>

<p>
Lies im <a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>
das Kapitel »Analysis of an Equal-Cost Multi-Path Algorithm« wenn du
Genaueres über die Routenauswahl erfahren möchtest.

<p>
Des Weiteren ist es erwähnenswert, dass beim Ausfall eines Interfaces
(z. B. beim Verlust des Carriers) für eine Multipathroute der Kernel
weiterhin versucht, Pakete über die Route zu senden, die an dieses
Interface gebunden wurde. Der Datenverkehr wird natürlich ins Nichts
führen und somit verloren gehen. Es wird daher dringend empfohlen,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8"
>ifstated(8)</a> auf nicht verfügbare Interfaces zu überprüfen und die
Routingtabelle dementsprechend anzupassen.


<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirmkontrollen]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.313 ]<br>
$Translation: faq6.html,v 1.178 2013/12/02 10:06:50 steffen Exp $<br>
-->
$OpenBSD: faq6.html,v 1.146 2013/12/06 20:52:46 ajacoutot Exp $
</small>

</body>
</html>
@


1.146
log
@Sync with Steelix CVS
@
text
@d2452 1
a2452 1
$OpenBSD$
@


1.145
log
@Sync with Steelix CVS
@
text
@d1779 2
a1780 2
<h3>Kann ich andere Kerneltypen mit PXE booten, außer
<tt>bsd.rd</tt>?</h3>
d2449 2
a2450 2
Originally [OpenBSD: faq6.html,v 1.311 ]<br>
$Translation: faq6.html,v 1.177 2013/11/12 11:46:23 steffen Exp $<br>
@


1.144
log
@Sync with Steelix CVS
@
text
@d757 1
a757 1
("<tt>dhcpd(failed)</tt>") und in <tt>/var/log/message</tt> den genauen
d2449 2
a2450 2
Originally [OpenBSD: faq6.html,v 1.310 ]<br>
$Translation: faq6.html,v 1.176 2013/11/01 17:42:27 steffen Exp $<br>
@


1.143
log
@Sync with Steelix CVS
@
text
@d1770 1
a1770 1
		OpenBSD 5.3 (RAMDISK_CD) #49: Tue Mar 12 18:50:37 MDT 2013
d2449 2
a2450 2
Originally [OpenBSD: faq6.html,v 1.309 ]<br>
$Translation: faq6.html,v 1.175 2013/09/08 13:34:04 steffen Exp $<br>
@


1.142
log
@Sync with Steelix CVS
@
text
@d238 2
a239 1
>trunk</a> - link aggregation and link failover interface
d243 1
a243 1
Interfaces werden während des Startvorgangs mit Hilfe von
d2312 1
a2312 1
# <b>cat /etc/hostname.wpi0</b>
d2322 1
a2322 1
trunkport wpi0 
d2449 2
a2450 2
Originally [OpenBSD: faq6.html,v 1.308 ]<br>
$Translation: faq6.html,v 1.174 2013/06/03 12:25:26 steffen Exp $<br>
@


1.141
log
@Sync with Steelix CVS
@
text
@d237 2
d2241 89
d2448 2
a2449 2
Originally [OpenBSD: faq6.html,v 1.307 ]<br>
$Translation: faq6.html,v 1.173 2013/05/11 11:41:56 steffen Exp $<br>
@


1.140
log
@Sync with Steelix CVS
@
text
@d1468 1
a1468 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4"
d1476 1
a1476 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vether&sektion=4"
d1479 1
a1479 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8"
d2358 1
a2358 1
$Translation: faq6.html,v 1.172 2013/05/01 16:30:38 steffen Exp $<br>
@


1.139
log
@Sync with Steelix CVS
@
text
@d11 1
a11 1
<meta name= "copyright"     content= "This document copyright 1998-2012 by OpenBSD.">
d1748 1
a1748 1
    >> OpenBSD/i386 PXEBOOT 3.17
d1757 1
a1757 1
    >> OpenBSD/i386 PXEBOOT 3.17
d1765 1
a1765 1
    Copyright (c) 1995-2012 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1767 1
a1767 1
    OpenBSD 5.2 (RAMDISK_CD) #278: Wed Aug  1 10:04:16 MDT 2012
d2357 2
a2358 2
Originally [OpenBSD: faq6.html,v 1.306 ]<br>
$Translation: faq6.html,v 1.171 2013/02/16 12:22:52 steffen Exp $<br>
@


1.138
log
@Sync with Steelix CVS
@
text
@d1370 1
a1370 1
<h3>Ein Beispiel einer Bridgeanwendung</h3>
d1451 89
d2159 1
a2159 1
driver for Atheros 80211/a/g/n devices.
a2163 2
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile.
d2357 2
a2358 2
Originally [OpenBSD: faq6.html,v 1.304 ]<br>
$Translation: faq6.html,v 1.169 2012/11/02 23:41:47 steffen Exp $<br>
@


1.137
log
@Sync with Steelix CVS
@
text
@d1678 1
a1678 1
    OpenBSD 5.2 (GENERIC) #278: Wed Aug  1 10:04:16 MDT 2012
d2270 2
a2271 2
Originally [OpenBSD: faq6.html,v 1.303 ]<br>
$Translation: faq6.html,v 1.168 2012/11/01 20:33:45 steffen Exp $<br>
@


1.136
log
@Sync with Steelix CVS
@
text
@d1608 4
a1611 12
>tftpd(8)</a>-Daemon aktivieren. Dies wird normalerweise durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> realisiert.
Die standardmäßige OpenBSD-Installation hat eine Beispielzeile in
<tt>inetd.conf</tt>, die wunderbar für dich funktionieren wird:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

von der lediglich das »#«-Zeichen entfernt werden muss. Sende inetd(8)
ein -HUP Signal, um mitzuteilen, dass <tt>/etc/inetd.conf</tt> neu
geladen werden soll. tftpd(8) bietet die Dateien von einem bestimmten
d1659 1
a1659 1
    >> OpenBSD/i386 PXEBOOT 3.16
d1668 1
a1668 1
    >> OpenBSD/i386 PXEBOOT 3.16
d1678 1
a1678 1
    OpenBSD 5.1 (RAMDISK_CD) #95: Sun Feb 12 10:02:21 MST 2012
d2270 2
a2271 2
Originally [OpenBSD: faq6.html,v 1.302 ]<br>
$Translation: faq6.html,v 1.167 2012/10/16 10:32:34 steffen Exp $<br>
@


1.135
log
@Sync with Steelix CVS
@
text
@d174 1
a174 1
        inet 192.168.1.34 netmask 0xffffff00 broadcast 192.168.1.255
d2278 2
a2279 2
Originally [OpenBSD: faq6.html,v 1.300 ]<br>
$Translation: faq6.html,v 1.166 2012/08/16 21:08:04 steffen Exp $<br>
@


1.134
log
@Sync with Steelix CVS
@
text
@d1148 2
a1149 1
nfsd_flags=""
d1210 5
a1214 8
Die Standardargumente, die an nfsd durch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8"
>rc.conf(8)</a> übergeben wurden, ermöglichen Verbindungen via TCP (-t) und
UDP (-u) und erlauben das Ausführen von vier (4) gleichzeitigen Instanzen des
nfsd.
Du solltest durch Modifikation der Zeile <tt>nfsd_flags</tt> in rc.conf.local
eine Konfiguration der Anzahl von NFS-Server-Instanzen vornehmen, entsprechend
der maximalen Zahl gleichzeitiger Client-Anfragen, die du bedienen möchtest.
d2278 2
a2279 2
Originally [OpenBSD: faq6.html,v 1.299 ]<br>
$Translation: faq6.html,v 1.165 2012/08/13 10:25:12 steffen Exp $<br>
@


1.133
log
@Sync with Steelix CVS
@
text
@d1147 2
a1148 2
portmap=YES
nfs_server=YES
d1211 6
a1216 6
>rc.conf(8)</a> übergeben wurden, ermöglichen Verbindungen via TCP (-t) und UDP (-u)
und erlauben das Ausführen von vier (4) gleichzeitigen Instanzen des nfsd.
Du solltest jedoch durch Hinzufügen von nfsd_flags zu rc.conf.local eine
Konfiguration der Anzahl von NFS-Server-Instanzen vornehmen,
entsprechend der maximalen Zahl gleichzeitiger Client-Anfragen, die du bedienen
möchtest.
d2280 2
a2281 2
Originally [OpenBSD: faq6.html,v 1.298 ]<br>
$Translation: faq6.html,v 1.164 2012/05/01 17:47:06 tobias Exp $<br>
@


1.132
log
@Sync with Steelix CVS
@
text
@d1686 1
a1686 1
    Copyright (c) 1995-2011 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1688 1
a1688 1
    OpenBSD 5.0 (RAMDISK_CD) #36: Wed Aug 17 10:27:31 MDT 2011
d2280 2
a2281 2
Originally [OpenBSD: faq6.html,v 1.297 ]<br>
$Translation: faq6.html,v 1.163 2012/04/24 10:39:14 steffen Exp $<br>
@


1.131
log
@Sync with Steelix CVS
@
text
@d11 1
a11 1
<meta name= "copyright"     content= "This document copyright 1998-2011 by OpenBSD.">
d707 2
a708 4
dass sie die Zeile <tt>dhcpd_flags="<i>Interface</i>"</tt> beinhaltet
und ersetze <tt><i>Interface</i></tt> durch eine Liste von Interfaces
auf die dhcpd(8) hören soll. Zum Beispiel so:

d710 1
a710 1
     # <b>echo 'dhcpd_flags="xl1 xl2 xl3"' &gt;&gt;/etc/rc.conf.local</b>
d713 5
d744 2
a745 2
Wenn du den dhcpd(8) von der Befehlszeile aus starten willst, nachdem du
<tt>/etc/dhcpd.conf</tt> editiert hast, versuche:
d748 2
a749 2
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
d752 4
a755 8
<p>
Die <tt>touch</tt>-Zeile ist notwendig, um eine leere
<tt>dhcpd.leases</tt>-Datei zu erzeugen, bevor dhcpd(8) starten kann.
Die OpenBSD-<a href="faq10.html#rc">Startskripte</a> erstellen diese
Datei beim Hochfahren, wenn es notwendig ist. Wenn du aber dhcpd(8)
manuell startest, musst du sie zuerst erstellen.
<tt>fxp0</tt> ist ein Interface, auf dem du beginnen möchtest, DHCP
anzubieten.
d1203 3
a1205 4
# <b>/usr/sbin/portmap</b>
# <b>echo -n &gt;/var/db/mountdtab</b>
# <b>/sbin/mountd</b>
# <b>/sbin/nfsd -tun 4</b>
d1209 8
a1216 5
Die an nfsd übergebenen Argumente ermöglichen Verbindungen über TCP (-t)
und UDP (-u) und starten vier nfsd-Instanzen (-n). Du solltest eine
entsprechende Anzahl NFS-Serverinstanzen setzen, um die von dir
gewünschte maximale Anzahl gleichzeitiger Clientzugriffe verarbeiten zu
können.
d1228 1
a1228 1
# <b>kill -HUP `cat /var/run/mountd.pid`</b>
d1230 1
d2280 2
a2281 2
Originally [OpenBSD: faq6.html,v 1.296 ]<br>
$Translation: faq6.html,v 1.162 2012/04/14 21:08:00 steffen Exp $<br>
@


1.130
log
@Sync with Steelix CVS
@
text
@d503 1
a503 1
Zusätzlich beinhaltet die »Ports«-Kollektion Software wie
d1048 3
a1050 2
<a href="faq15.html#PkgMgmt">Package</a> oder
<a href="faq15.html#Ports">Port</a> installiert werden. Weitere
d1052 1
a1052 1
sich in der Handbuchseite, die mit dem pptp-Package installiert wird.
d1964 1
a1964 1
verfügbar als <a href="faq15.html#Ports">Port</a>, die verwendet werden
d2004 2
a2005 1
er weiterhin als Port und Package verfügbar sein wird. Es existieren
d2279 1
a2279 1
$Translation: faq6.html,v 1.161 2012/03/21 19:22:04 steffen Exp $<br>
@


1.129
log
@Sync with Steelix CVS
@
text
@d27 1
a27 1
<h1><font color="#e00000">6 - Netzwerk</font></h1>
d2277 1
a2277 1
$Translation: faq6.html,v 1.160 2012/01/31 21:20:32 tobias Exp $<br>
@


1.128
log
@Sync with Steelix CVS
@
text
@d82 1
a82 1
>netstat(1)</a>-Manualseiten.
d200 1
a200 1
folgenden Manualseiten:
d253 1
a253 1
Weitere Details über dieser Datei findest du in der Manualseite für <a
d966 1
a966 1
/var/log/ppp.log aufzeichnen. Diese Aufzeichnung, sowie die Manualseite,
d1051 1
a1051 1
sich in der Manualseite, die mit dem pptp-Package installiert wird.
d1097 1
a1097 1
noch folgende Manualseiten lesen, bevor du versuchst, einen eigenen
d1164 1
a1164 1
>exports(5)</a>-Manualseite lesen würdest. Für dieses Beispiel haben wir
d1423 1
a1423 1
>Manualseite</a> aufgeführt.
d2132 1
a2132 1
lies die Manualseiten für präzise Details). Einige dieser Karten können
d2143 1
a2143 1
dann lies die zuvor aufgelisteten Manualseiten. Sie beinhalten
d2277 1
a2277 1
$Translation: faq6.html,v 1.159 2012/01/21 17:24:03 steffen Exp $<br>
@


1.127
log
@Sync with Steelix CVS
@
text
@d33 2
a34 2
<li><a href= "#Intro" >6.1 - Bevor wir weitermachen</a>
<li><a href= "#Setup" >6.2 - Netzwerkkonfiguration</a>
d47 3
a49 3
<li><a href= "#PF"    >6.3 - Wie kann ich mit OpenBSD filtern und eine
    Firewall aufsetzen?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic-Host-Configuration-Protokoll (DHCP)</a>
d54 12
a65 11
<li><a href= "#PPP"   >6.5 - Point-to-Point-Protokoll (PPP)</a>
<li><a href= "#Tuning">6.6 - Tunen von Netzwerkparametern</a>
<li><a href= "#NFS"   >6.7 - NFS benutzen</a>
<li><a href= "#Bridge">6.9 - Aufsetzen einer Bridge mit OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Wie boote ich mit PXE?</a>
<li><a href= "#CARP">6.11 - Das Common-Address-Redundancy-Protokoll (CARP)</a>
<li><a href="#OpenNTPD">6.12 - OpenNTPD verwenden</a>
<li><a href="#Wireless">6.13 - Welche Möglichkeiten stehen mir für
    Drahtlosnetzwerk zur Verfügung?</a>
<li><a href="#Multipath">6.14 - Wie kann ich »equal-cost multipath routing«
    durchführen?</a>
d2277 1
a2277 1
$Translation: faq6.html,v 1.158 2011/12/16 14:29:25 steffen Exp $<br>
@


1.126
log
@Sync with Steelix CVS
@
text
@d8 1
a8 1
<meta name= "description"   content= "OpenBSD FAQ 6 - Vernetzung">
d2276 1
a2276 1
$Translation: faq6.html,v 1.157 2011/12/10 18:27:12 steffen Exp $<br>
@


1.125
log
@Sync with Steelix CVS
@
text
@d4 1
a4 1
<title>6 - Netzwerk</title>
d8 2
a9 2
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
d11 1
a11 1
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
d87 2
a88 3
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf"
>Understanding
IP addressing</a> vertiefen.
d162 5
a166 1
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
a167 3
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
d169 2
a170 1
        address: 00:04:ac:dd:39:6a
d173 1
a173 1
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
d175 7
a181 22
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
d207 7
a219 2
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4"
>enc</a> - Encapsulating Interface
d224 2
d232 4
d239 5
a243 5
Das Interface wird während des Bootvorgangs über die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">/etc/hostname.<i>if</i>(5)</a>-Dateien
konfiguriert, wobei <i>if</i> für den vollständigen Namen deines
Interfaces steht (für das vorherige Beispiel wäre es also
<i>/etc/hostname.fxp0</i>).
d310 2
a311 2
Du kannst auch einen Hostnamen verwenden, doch sei vorsichtig: Du
kannst während des Bootvorgangs nicht davon ausgehen, dass die
d317 1
d352 1
d402 1
d483 1
a483 1
net.inet.ip.forwarding: 0  -&gt; 1
d487 22
a508 12
Nun modifiziere die Routen der anderen Hosts. Es gibt viele verschiedene
Möglichkeiten, OpenBSD als Router einzusetzen, z.&nbsp;B. mittels
Software wie das OpenBSD-eigene <a
href="http://www.openbgpd.org/de/">OpenBGPD</a>, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8"
>routed(8)</a>, <a href="http://www.mrtd.net">mrtd</a>, <a
href="http://www.zebra.org">zebra</a> und <a
href="http://www.quagga.net">quagga</a>. OpenBSD hat Unterstützung im
Portstree sowohl für zebra als auch für quagga und mrtd. OpenBGPD und
routed werden als Teil des Basissystems installiert. OpenBSD unterstützt
mehrere T1-, HSSI-, ATM-, FDDI-, Ethernet- und serielle Schnittstellen
(PPP/SLIP).
d576 1
a576 1
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
d649 1
a649 1
auch Einstellungen wie <tt>hostname</tt> entfernen.
d833 4
a836 4
set log Phase Chat LCP IPCP CCP tun command
set device /dev/cua01
set speed 115200
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
d863 6
a868 6
set phone 1234567
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR
enable dns
d925 8
a932 8
set phone 1234567
set authname ppp
set authkey ppp
set login
set timeout 120
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR
enable dns
a1054 1
<!-- XXXrelease -->
d1064 1
a1064 1
<i>SEHR WENIGE Personen werden sich hierum kümmern müssen!</i>
d1067 1
a1067 3
<h3>6.6.1 - Wie kann ich meinen Kernel optimieren, sodass er eine
größere Anzahl Neuversuche und längere Timeouts für
TCP-Sitzungen hat?</h3>
d1070 2
a1071 3
Normalerweise möchtest du das entweder für Routing oder wegen
Verbindungsproblemen. Selbstverständlich müssen beide Seiten der
Verbindung ähnliche Werte verwenden, damit es am effektivsten ist.
d1073 3
a1075 46
<p>
Um dies zu tunen, verwende <tt>sysctl</tt> und erhöhe die Werte von:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Mittels sysctl -a kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu verändern, verwende etwas
wie <tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Wie kann ich »directed broadcasts« aktivieren?</h3>

<p>
Normalerweise willst du dies nicht tun. Dies erlaubt jemandem,
Datenverkehr zu der Broadcastadresse deines verbundenen Netzwerkes zu
schicken, wenn du deinen OpenBSD-Rechner als Router verwendest.

<p>
Aber manchmal kann dies in geschlossenen Netzwerken nützlich sein;
vor allem wenn man ältere Implementationen des NetBIOS-Protokolles
verwendet. Mit
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> wird dies aktiviert
Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>,
wenn du wissen willst, warum dies standardmäßig nicht aktiviert ist.

<p>
<h3>6.6.3 - Der Kernel soll bestimmte Ports nicht dynamisch allozieren</h3>

<p>
Auch dafür gibt es einen eigenen sysctl-Befehl. Siehe <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a>:

<pre>
Setze die Liste der reservierten TCP-Ports, die nicht dynamisch vom
Kernel vergeben werden sollen. Das kann man benutzen, um Daemons davon
abzuhalten, einen speziellen Port zu benutzen, den ein anderes Programm
braucht, damit es funktionieren kann. Listen-Elemente können
mit Kommas und/oder Leerzeichen getrennt werden.

#  <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>
d1077 1
a1077 2
Es ist ebenso möglich, Ports aus der aktuellen Liste hinzuzufügen
oder zu entfernen.
d1079 3
a1081 3
 #  <b>sysctl net.inet.tcp.baddynamic=+748</b>
 #  <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre>
d1083 2
a1084 3
<p>
<h3>6.6.4 - Wie kann ich die Leistung einer sehr schnellen und
ausgelasteten Verbindung erhöhen?</h3>
d1086 2
a1087 6
Wenn du bei der Verwendung einer Hochgeschwindigkeits-WAN-Verbindung
Leistungsbegrenzungen feststellst, kannst du eventuell einen
Leistungsgewinn feststellen, wenn du die folgenden Sysctls änderst:
<blockquote><pre>
net.inet.tcp.recvspace
net.inet.tcp.sendspace
a1089 5
Probier einen Wert wie zum Beispiel 65536 statt den standardmäßigen
16384. Beachte, dass nur wenige einen echten Nutzen hieraus ziehen
können. Verändere diese Werte nicht, wenn du nicht tatsächlich weniger
Leistung hast, als du erwartet hättest.

d1342 1
d1426 5
a1430 4
einer Datei namens <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"
><tt>bridgename.bridge0</tt></a>. initialisiert. Hier ist zum Beispiel
eine Datei für meine Situation:
d1433 1
a1433 1
$ <b>cat /etc/bridgename.bridge0</b>
d1498 3
a1500 3
Um die Bridge zu überwachen und zu kontrollieren, benutze das <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8"
>brconfig(8)</a>-Kommando, mit dem man eine Bridge auch nach dem Booten
d1511 6
a1516 5
<li>Durch die Benutzung der <i>blocknonip</i>-Option von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8"
>brconfig(8)</a> oder in <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"
>bridgename.bridge0</a> kannst du jeglichen Datenverkehr, der nicht
d1665 1
a1665 1
    >> OpenBSD/i386 PXEBOOT 1.00
d1674 1
a1674 1
    >> OpenBSD/i386 PXEBOOT 1.00
d1682 1
a1682 1
    Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1684 1
a1684 1
    OpenBSD 4.4 (RAMDISK_CD) #857: Tue Aug 12 17:31:49 MDT 2008
d1699 1
d1785 3
a1787 9
<p>Die zweite namens <tt>net.inet.carp.arpbalance</tt> wird für die
Lastverteilung verwendet. Wenn diese Funktion aktiviert ist, wird CARP
ein Sourcehash auf die Quell-IP der Anfrage durchführen. Dieser Hash
wird dann verwendet, um einen virtuellen Host aus dem zur Verfügung
stehenden Pool auszuwählen, damit dieser die Anfrage verarbeitet.
Dies ist standardmäßig deaktiviert.

<p>Die dritte namens <tt>net.inet.carp.log</tt> zeichnet CARP-Fehler
auf. Standardmäßig deaktiviert.
d1789 1
a1789 1
<p>Die vierte namens <tt>net.inet.carp.preempt</tt> aktiviert natürliche
a1932 7
<p>Alles, was wir nun tun müssen, ist die sysctl für die Lastverteilung
auf beiden Systemen zu laden, die wir zuvor besprochen haben:

<blockquote><pre>
# <b>sysctl net.inet.carp.arpbalance=1</b>
</pre></blockquote>

d2062 1
a2062 1

d2068 51
a2118 50
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4"
>awi(4)</a> AMD 802.11 PCnet Mobile.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4"
>an(4)</a> Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4"
>wi(4)</a> Prism2/2.5/3. <sup>(AP</sup>
<li><a
 href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4"
>atw(4)</a> ADMtek ADM8211.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4"
>ath(4)</a> Treiber für Atheros IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4"
>iwi(4)</a> Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g.
<sup>(NFF)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4"
>ipw(4)</a> Intel PRO/Wireless 2100 IEEE 802.11b. <sup>(NFF)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4"
>atu(4)</a> Atmel AT76C50x USB IEEE 802.11b.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4"
>ral(4)</a> und <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4"
>ural(4)</a> [USB] Ralink Technology RT25x0 IEEE 802.11a/b/g.
<sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4"
>rtw(4)</a> Realtek 8180 IEEE 802.11b. <sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4"
>acx(4)</a> TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4"
>pgt(4)</a> Conexant/Intersil Prism GT Full-MAC. <sup>(NFF) (AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4"
>rum(4)</a> Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4"
>wpi(4)</a> Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4"
>uath(4)</a> Atheros AR5005UG/AR5005UX USB2.0 (es wird dran gearbeitet).
<sup>(NFF)</sup>

d2156 1
a2156 1

d2275 2
a2276 2
Originally [OpenBSD: faq6.html,v 1.270 ]<br>
$Translation: faq6.html,v 1.156 2008/10/31 19:20:41 simon Exp $<br>
@


1.124
log
@Sync with Steelix CVS
@
text
@d1729 1
a1729 1
    OpenBSD 4.3 (RAMDISK_CD) #645: Wed Mar 12 11:31:03 MDT 2008
d2331 2
a2332 2
Originally [OpenBSD: faq6.html,v 1.269 ]<br>
$Translation: faq6.html,v 1.155 2008/06/12 08:58:53 simon Exp $<br>
@


1.123
log
@Sync with Steelix CVS
@
text
@d693 6
a698 6
Wenn du OpenBSD als DHCP-Server <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8"
>dhcpd(8)</a> einsetzen willst, editiere <tt>/etc/rc.conf.local</tt> so,
dass sie die Zeile <tt>dhcpd_flags=""</tt> beinhaltet. Die
Netzwerkkarten, auf denen dhcpd(8) <b>lauschen</b> soll, stehen in
<tt>/etc/dhcpd.interfaces</tt>.
d701 1
a701 1
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
d2331 2
a2332 2
Originally [OpenBSD: faq6.html,v 1.268 ]<br>
$Translation: faq6.html,v 1.154 2008/05/02 08:17:14 paldium Exp $<br>
@


1.122
log
@Sync with Steelix CVS
@
text
@d1049 3
a1051 3
Funktion du nicht verstehst, wird dein System eher beeinträchtigen und
nicht die Geschwindigkeit erhöhen. Fang immer mit den Standardwerten an
und ändere <i>nur</i> Einstellungen, die tatsächlich ein Problem
d2331 2
a2332 2
Originally [OpenBSD: faq6.html,v 1.267 ]<br>
$Translation: faq6.html,v 1.153 2008/04/30 23:52:15 simon Exp $<br>
@


1.121
log
@Sync with Steelix CVS
@
text
@d1727 1
a1727 1
    Copyright (c) 1995-2007 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1729 1
a1729 1
    OpenBSD 4.2 (RAMDISK_CD) #468: Tue Aug 28 11:02:17 MDT 2007
d2331 2
a2332 2
Originally [OpenBSD: faq6.html,v 1.266 ]<br>
$Translation: faq6.html,v 1.152 2008/04/26 19:50:56 paldium Exp $<br>
@


1.120
log
@Sync with Steelix CVS
@
text
@d1047 10
d2331 2
a2332 2
Originally [OpenBSD: faq6.html,v 1.265 ]<br>
$Translation: faq6.html,v 1.151 2008/03/05 20:10:36 paldium Exp $<br>
@


1.119
log
@Sync with Steelix CVS
@
text
@d205 2
a206 2
sprich die Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast
10.0.0.255&quot;. Außerdem sind die Flags <b>UP</b> und
d962 1
a962 1
In einigen Situationen möchstest du Befehle ausführen, wenn die
d1115 1
a1115 1
Wenn du bei der Verwendung einer Hochgeschwindigskeits-WAN-Verbindung
d1455 1
a1455 1
IP-Addresse oder ähnliche Information muss für dieses Interface
d1462 1
a1462 1
Jetzt müsen wir die Bridge aufsetzen. Bridges werden durch die Existenz
d1607 1
a1607 1
PXE-Ünterstützung hätten, aber das ist einfach nicht wahr -
d1768 1
a1768 1
Zu konfigurierbaren Intervallen bekündet der Master seine Operation auf
d1770 2
a1771 2
anderen Systeme in der CARP-Gruppe mit dem bekünden. Der Host, der in
der Lage ist am häufigsten zu bekünden, wird der neue Master. Wenn das
d1831 1
a1831 1
in der Lage ist am schnellsten zu bekünden) wird zum Master.
d1901 1
a1901 1
Aber lass uns sagen, dass du nicht von Anfang an aufsetzst.
d1932 1
a1932 1
<p>Dies verzögert die Bekündungen von <i>pris</i> ein wenig, was
d2178 1
a2178 1
jeodch auch im hostbasierten Accesspointmodus genutzt werden, das ihnen
d2210 1
a2210 1
sucht, um Pakete an ein bestimmtes Netzwerk senden zu können, kannn er
d2322 1
a2322 1
$Translation: faq6.html,v 1.148 2008/03/02 11:42:39 paldium Exp $<br>
@


1.118
log
@Sync with Steelix CVS
@
text
@d11 1
a11 1
<meta name= "copyright"     content= "This document copyright 1998-2007 by OpenBSD.">
d162 1
a162 1
$ <strong>ifconfig</strong>
d206 2
a207 2
10.0.0.255&quot;. Außerdem sind die Flags <strong>UP</strong> und
<strong>RUNNING</strong> gesetzt.
d265 1
a265 1
$ <strong>cat /etc/hostname.fxp0</strong>
d296 1
a296 1
$ <strong>cat /etc/hostname.vlan0</strong>
d371 1
a371 1
<strong>/etc/netstart</strong> ausführen, indem du (als root) Folgendes
d375 1
a375 1
# <strong>sh /etc/netstart</strong>
d416 1
a416 1
$ <strong>netstat -rn</strong>
d432 1
a432 1
$ <strong>route show</strong>
d482 1
a482 1
# <strong>sysctl net.inet.ip.forwarding=1</strong>
d540 1
a540 1
inet 192.168.0.2 255.255.255.0 media 100baseTX
d821 1
a821 2
<blockquote>
<pre>
d827 1
a827 2
</pre>
</blockquote>
d851 1
a851 2
<blockquote>
<pre>
d859 1
a859 2
</pre>
</blockquote>
d913 1
a913 2
<blockquote>
<pre>
d923 1
a923 2
</pre>
</blockquote>
d1102 1
a1102 1
#  <strong>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>
d1107 2
a1108 2
 #  <strong>sysctl net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl net.inet.tcp.baddynamic=-871</strong>
a1162 1
<p>
d1169 1
a1169 1
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
d1183 2
a1184 3
<blockquote>
<tt>
portmap=YES<br>
d1186 1
a1186 2
</tt>
</blockquote>
d1216 10
a1225 5
selbst) mounten können. Die <tt>-ro</tt>-Option gibt an, dass nur
Leseberechtigung gestattet wird. Die letzten zwei Argumente bedeuten,
dass nur Clients innerhalb des 10.0.0.0-Netzwerkes mit einer Netzmaske
von 255.255.255.0 dieses Dateisystem mounten dürfen. Dies ist wichtig
für einige Server, die von verschiedenen Netzwerken aus zugänglich sind.
d1239 6
a1244 8
<blockquote>
<tt>
# <b>/usr/sbin/portmap</b><br>
# <b>echo -n &gt;/var/db/mountdtab</b><br>
# <b>/sbin/mountd</b><br>
# <b>/sbin/nfsd -tun 4</b><br>
</tt>
</blockquote>
d1265 1
a1265 1
h3>NFS-Dateisysteme mounten</h3>
d1318 1
a1318 2
<blockquote>
<tt>
d1320 1
a1320 2
</tt>
</blockquote>
d1344 1
a1344 1
$ <strong>rpcinfo -p 10.0.0.1</strong>
d1370 1
a1370 1
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
d1435 1
a1435 2
<blockquote>
<pre>
d1438 1
a1438 2
</pre>
</blockquote>
d1446 1
a1446 2
<blockquote>
<pre>
d1449 1
a1449 2
</pre>
</blockquote>
d1468 1
a1468 2
<blockquote>
<pre>
d1473 1
a1473 2
</pre>
</blockquote>
d1499 1
a1499 2
<blockquote>
<pre>
d1504 1
a1504 2
</pre>
</blockquote>
d1514 1
a1514 2
<blockquote>
<pre>
d1525 1
a1525 2
</pre>
</blockquote>
d1977 1
a1977 1
# <strong>sysctl net.inet.carp.arpbalance=1</strong>
d2222 4
a2225 6
<blockquote>
<tt>
# route add -mpath default 10.130.128.1<br>
# route add -mpath default 10.132.0.1<br>
</tt>
</blockquote>
d2230 2
a2231 3
<blockquote>
<pre>
# netstat -rnf inet | grep default
d2234 1
a2234 2
</pre>
</blockquote>
d2261 4
a2264 6
<blockquote>
<tt>
# sysctl net.inet.ip.multipath=1<br>
# sysctl net.inet6.ip6.multipath=1
</tt>
</blockquote>
d2275 2
a2276 3
<blockquote>
<pre>
# traceroute -n 154.11.0.4
d2283 1
a2283 1
# traceroute -n 154.11.0.5
d2289 1
a2289 2
</pre>
</blockquote>
d2321 2
a2322 2
Originally [OpenBSD: faq6.html,v 1.261 ]<br>
$Translation: faq6.html,v 1.143 2008/02/11 11:05:24 simon Exp $<br>
@


1.117
log
@Sync with Steelix CVS
@
text
@d1170 1
a1170 5
Noch eine wichtige Anmerkung wegen Sicherheit: Füge niemals ein
Dateisystem zu <i>/etc/exports</i> ohne eine Liste mit Rechnern, die
explizit Zugriff haben sollen. Ohne einer solchen Liste, die ein
bestimmtes Verzeichnis mounten können, kann jeder, der den Rechner
erreichen kann, deine NFS-Exports mounten.
d1173 1
a1173 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8"
>portmap(8)</a> muss laufen, damit NFS funktionieren kann. Portmap(8)
ist unter OpenBSD standardmäßig abgeschaltet, sodass du die Zeile
d1175 8
a1182 3
<blockquote><pre>
portmap=YES
</pre></blockquote>
d1184 3
a1186 1
in <a
d1188 1
a1188 2
>rc.conf.local(8)</a> einfügen musst, damit es beim nächsten Start
geladen wird.  Du kannst ihn auch wie folgt manuell starten:
d1190 10
a1199 3
<blockquote><pre>
# <strong>/usr/sbin/portmap</strong>
</pre></blockquote>
d1202 10
a1211 9
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS für
Rechner innerhalb dieses Netzwerkes bereitstellen. Der erste Schritt ist
deine <i>/etc/exports</i>-Datei zu erstellen. Diese Datei listet die
Dateisysteme auf, die du über NFS freigeben willst, und definiert, wer
auf sie zugreifen darf. Es gibt viele Optionen, die du in deiner
<i>/etc/exports</i>-Datei haben kannst. Am besten ist, du liest die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>-Manualseite. Für dieses Beispiel sieht
<i>/etc/exports</i> so aus:
d1222 36
a1257 8
D.&nbsp;h. dass das lokale Dateisystem <tt>/work</tt> via NFS zugänglich
gemacht wird. <tt>-alldirs</tt> bedeutet, dass Clients jedes Verzeichnis
unter dem <tt>/work</tt>-Mountpunkt mounten können. <tt>-ro</tt> bedeutet,
dass nur Leseberechtigung gestattet wird. Die letzten zwei Argumente
bedeuten, dass nur Clients innerhalb des 10.0.0.0-Netzwerkes mit einer
Netzmaske von 255.255.255.0 dieses Dateisystem mounten dürfen. Dies ist
wichtig für einige Server, die von verschiedenen Netzwerken aus
zugänglich sind.
d1260 7
a1266 5
Ist einmal deine <i>/etc/exports</i>-Datei eingerichtet, kannst du
weitergehen und deinen NFS-Server aufsetzen. Du solltest zuerst
sicherstellen, dass deine Kernelkonfiguration die Optionen NFSSERVER
u. NFSCLIENT enthält (der GENERIC-Kernel beinhaltet diese Optionen).
Dann solltest du die Zeile
d1269 1
a1269 1
nfs_server=YES
d1271 1
d1273 14
a1286 8
in <i>/etc/rc.conf.local</i> einfügen. Dies wird sowohl nfsd(8) und
mountd(8) starten, wenn du neustartest. Nun kannst du fortschreiten und
die Dienste selber starten. Diese Dienste müssen als root gestartet
werden und du musst sicherstellen, dass portmap(8) auf deinem System
läuft. Hier ein Beispiel von nfsd(8), der sowohl mit TCP als auch mit
UDP bedient mittels 4 Diensten. Du solltest eine angemessenene Anzahl
NFS-Serverdienste einsetzen, um die maximale Anzahl gleichzeitiger
Clientanfragen, die du bedienen willst, zu bewerkstelligen.
d1289 1
a1289 1
# <strong>/sbin/nfsd -tun 4</strong>
d1293 2
a1294 4
Du musst nicht nur den nfsd(8)-Server starten, sondern auch mountd(8).
Dies ist der Dienst, der eigentlich die Mountanfragen auf NFS bedient. Um
mountd(8) zu starten, stelle sicher, dass eine leere mountdtab-Datei
existiert und starte den Daemon:
d1297 1
a1297 2
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
d1301 5
a1305 3
Wenn du Änderungen an /etc/exports durchführst, während
NFS bereits läuft, musst du mountd dies mitteilen, indem du den
Dienst neustartest!
d1308 1
a1308 1
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
d1312 32
d1347 3
a1349 2
Um zu überprüfen, ob alle Dienste laufen und bei RPC registriert
sind, verwende rpcinfo(8).
d1384 2
a1385 39
<h3>NFS-Dateisysteme mounten</h3>

<p>
NFS-Dateisysteme sollten mittels mount(8) geladen werden, oder genauer
gesagt, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8"
>mount_nfs(8)</a>. Um ein Dateisystem <i>/work</i> von Host 10.0.0.1 auf
dem lokalen Dateisystem <i>/mnt</i> zu laden, tue folgendes (bedenke,
dass du nicht IP-Adressen verwenden musst, denn mount wird Hostnamen
auflösen):

<blockquote><pre>
# <strong>mount -o ro -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Damit dein System dies beim Hochfahren wieder tut, füge Folgendes
deiner <i>/etc/fstab</i> hinzu:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro 0 0
</pre></blockquote>

<p>
Es ist wichtig, dass du <tt>0 0</tt> am Ende dieser Zeile verwendest,
damit dein Rechner nicht versucht, das NFS-Dateisystem beim Hochfahren
mit fsck zu überprüfen!! Die anderen Sicherheitsoptionen wie noexec,
nodev und nosuid sollten auch immer - wenn anwendbar - verwendet werden.
Wie zum Beispiel:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro,nodev,nosuid 0 0
</pre></blockquote>

<p>
Mit diesen Optionen können keine Geräte oder setuid-Programme auf
dem NFS-Server Sicherheitsmaßnahmen auf dem NFS-Client untergraben.
Wenn du keine Programme auf diesem NFS-Dateisystem auf dem NFS-Client
ausführen willst, füge noexec hinzu:
d2347 2
a2348 2
Originally [OpenBSD: faq6.html,v 1.260 ]<br>
$Translation: faq6.html,v 1.141 2008/01/06 11:16:41 paldium Exp $<br>
@


1.116
log
@Sync with Steelix CVS
@
text
@d1294 3
a1296 1
auch noch nfsstat(8), das genauere Statistiken anzeigt. Für
d2307 2
a2308 2
Originally [OpenBSD: faq6.html,v 1.259 ]<br>
$Translation: faq6.html,v 1.140 2007/12/23 01:07:20 simon Exp $<br>
@


1.115
log
@Sync with Steelix CVS
@
text
@d297 1
a297 1
Inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
d2305 2
a2306 2
Originally [OpenBSD: faq6.html,v 1.258 ]<br>
$Translation: faq6.html,v 1.139 2007/12/07 15:24:39 paldium Exp $<br>
@


1.114
log
@Sync with Steelix CVS
@
text
@d2184 1
a2184 1
in der Routingtabelle für das gleiche Netzwerkwerk befinden - zum
d2306 1
a2306 1
$Translation: faq6.html,v 1.138 2007/11/08 21:44:18 paldium Exp $<br>
@


1.113
log
@Sycn with steelix translation CVS
@
text
@d99 1
a99 1
Natürlich kannst du nicht alle lesen. Aber dennoch: lies jene,
d145 1
a145 1
Die Nummer wird nach bestimmten Kriterien zugewiesen: diese
d202 1
a202 1
benötigen. Natürlich sehen wir trotzdem unser Interface. Im
d313 1
a313 1
Du kannst auch einen Hostnamen verwenden, doch sei vorsichtig: du
d317 1
a317 1
Worten: es ist besser eine IP-Adresse oder etwas in
d454 1
a454 1
folgenden Packet-Filter-Instruktionen beachten, um potentiell schädliche
d900 1
a900 1
mit einigen PPP-Implementierungen durchgeführt werden, die keine
d935 1
a935 1
PAP-Authentifizierung genutzt wird: es wird automatisch ermittelt. »set
d1011 1
a1011 1
über eine normale Ethernetkarte und ethernetbasierendes DSL-Modem
d1025 1
a1025 1
>pppoe(8)</a>, welches die Userland-Implementierung ist (auf fast die
d1029 1
a1029 1
Eine Kernel-PPPoE-Implementierung namens <a
d1040 1
a1040 1
>pppd(8)</a> kommuniziert. Er ist in der Lage, sich zu PPTP-basierenden
d1054 2
a1055 2
<h3>6.6.1 - Wie kann ich meinen Kernel optimieren, so dass er eine
größere Anzahl von Neuversuchen und längeren Timeouts für
d1060 1
a1060 1
Verbindungsproblemen. Natürlich müssen beide Seiten der
d1087 1
a1087 1
vor allem wenn man ältere Implementierungen des NetBIOS-Protokolles
d1170 1
a1170 1
Noch eine wichtige Anmerkung wegen Sicherheit: füge niemals ein
d1179 1
a1179 1
ist unter OpenBSD standardmäßig abgeschaltet, so dass du die Zeile
d1239 2
a1240 2
UDP bedient mittels 4 Diensten. Du solltest eine angemessenene Anzahl an
NFS-Serverdiensten einsetzen, um die maximale Anzahl an gleichzeitigen
d1695 1
a1695 1
    OpenBSD 4.1 (RAMDISK_CD) #247: Thu Mar  8 23:21:43 MST 2007
d1708 1
a1708 1
PXE-Booting primär zum Installieren des OS gedacht ist.
d1719 1
a1719 1
zwischen sich errichten, so dass beim Ausfall eines Systems ein
d1808 1
a1808 1
Standardmäßig deaktiviert: das bedeutet, dass ein System, das nicht
d1979 1
a1979 1
synchronisieren, so dass sie alle mit der gleichen Uhrzeit
d2044 1
a2044 1
großen Anzahl von Leuten einfacher, diese zu nutzen. Wenn das
d2163 1
a2163 1
so dass sie nicht in OpenBSD eingebunden werden können. Wenn möglich,
d2165 1
a2165 1
Kontaktadressen für die zuständigen Mitarbeiter der Firma, so dass du
d2170 1
a2170 1
Eine andere Möglichkeit, mit deiner OpenBSD-basierenden Firewall einen
d2305 2
a2306 2
Originally [OpenBSD: faq6.html,v 1.256 ]<br>
$Translation: faq6.html,v 1.135 2007/06/16 16:00:29 paldium Exp $<br>
@


1.112
log
@Sync with Steelix CVS
@
text
@d2059 1
a2059 1
+<h3>6.12.3 - Warum können meine anderen Systeme nicht ihre
d2306 1
a2306 1
$Translation: faq6.html,v 1.134 2007/05/09 19:31:27 paldium Exp $<br>
@


1.111
log
@Sync with steelix translation CVS
@
text
@d336 1
a336 1
definiert und vorgegeben, dass die Datei <tt>/etc/hosts</tt> durchsucht
d2306 1
a2306 1
$Translation: faq6.html,v 1.133 2007/05/01 18:47:26 paldium Exp $<br>
@


1.110
log
@Sync with Steelix CVS
@
text
@d1693 1
a1693 1
    Copyright (c) 1995-2006 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1695 1
a1695 1
    OpenBSD 4.0 (RAMDISK_CD) #39: Sat Sep 16 19:34:26 MDT 2006
d2305 2
a2306 2
Originally [OpenBSD: faq6.html,v 1.255 ]<br>
$Translation: faq6.html,v 1.132 2007/04/28 07:28:39 paldium Exp $<br>
@


1.109
log
@Sync with steelix translation CVS
@
text
@d11 1
a11 1
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
d575 2
a576 2
zum Filtern von TCP/IP-Verkehr und zum Ausführen von Network Address
Translation. PF ist außerdem in der Lage, TCP/IP-Verkehr zu normalisieren
d2305 2
a2306 2
Originally [OpenBSD: faq6.html,v 1.254 ]<br>
$Translation: faq6.html,v 1.131 2007/04/25 21:24:51 paldium Exp $<br>
@


1.108
log
@Sync with steelix translation CVS
@
text
@d86 1
a86 1
über IP-Netzwerke mit 
d126 1
a126 1
Weiterhin kannst du mit dem Befehl 
d129 1
a129 1
von dmesg für eine Intel-Fast-Ethernet-Netzwerkkarte, die als 
d138 2
a139 2
Wenn du deinen Gerätenamen nicht kennst, sieh bitte in der 
<a href="../../de/plat.html">Liste der unterstützten Hardware</a> 
d152 1
a152 1
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem 
d201 3
a203 3
>ifconfig(8)</a> mehr Informationen aus, als wir zu diesem Zeitpunkt 
benötigen. Natürlich sehen wir trotzdem unser Interface. Im 
obigen Beispiel ist die Netzwerkkarte bereits konfiguriert. Das ist 
d205 1
a205 1
sprich die Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 
d284 1
a284 1
(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der 
d291 2
a292 2
Oder vielleicht willst du auch spezielle Flags für ein einzelnes 
Interface benutzen. Das Format der Datei ändert sich dabei nicht 
d528 1
a528 1
delete</tt>« löschen. 
d541 2
a542 2
inet alias 192.168.0.3 255.255.255.255 
inet alias 192.168.0.4 255.255.255.255 
d574 2
a575 2
Packet Filter (ab hier nur noch als PF bezeichnet) ist OpenBSDs System 
zum Filtern von TCP/IP-Verkehr und zum Ausführen von Network Address 
d580 2
a581 2
 
<p> 
d583 1
a583 1
<h2>6.4 - Dynamic-Host-Configuration-Protokoll (DHCP)</h2> 
d610 1
a610 1
seine DNS-Server vom DHCP-Server besorgen.  
d630 1
a630 1
dhclient überschreiben). 
d720 1
a720 1
Dies teilt deinen DHCP-Clients mit, dass die an DNS-Anfragen 
d777 1
a777 1
- der Userland-PPP-Daemon. 
d794 1
a794 1
<li>Deinen Nameserver 
d824 3
a826 3
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
d837 1
a837 1
»set device« eingestellt. Dies ist die Schnittstelle, mit der das 
d856 1
a856 1
set phone 1234567   
d858 1
a858 1
set timeout 120   
d860 1
a860 1
add default HISADDR 
d920 1
a920 1
set phone 1234567   
d924 1
a924 1
set timeout 120   
d926 1
a926 1
add default HISADDR 
d968 1
a968 1
In einigen Situationen möchstest du Befehle ausführen, wenn die 
d1075 1
a1075 1
wie <tt>sysctl net.inet.tcp.keepidle=28800</tt>.  
d1090 1
a1090 1
Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>, 
d1110 1
a1110 1
Es ist ebenso möglich, Ports aus der aktuellen Liste hinzuzufügen 
d1167 1
a1167 1
wurde, dann schützt es gegen die Art von Angriffen. 
d1195 5
a1199 5
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS für 
Rechner innerhalb dieses Netzwerkes bereitstellen. Der erste Schritt ist 
deine <i>/etc/exports</i>-Datei zu erstellen. Diese Datei listet die 
Dateisysteme auf, die du über NFS freigeben willst, und definiert, wer 
auf sie zugreifen darf. Es gibt viele Optionen, die du in deiner 
d1248 2
a1249 2
Du musst nicht nur den nfsd(8)-Server starten, sondern auch mountd(8). 
Dies ist der Dienst, der eigentlich die Mountanfragen auf NFS bedient. Um 
d1259 2
a1260 2
Wenn du Änderungen an /etc/exports durchführst, während 
NFS bereits läuft, musst du mountd dies mitteilen, indem du den 
d1271 2
a1272 2
Um zu überprüfen, ob alle Dienste laufen und bei RPC registriert 
sind, verwende rpcinfo(8). 
d1290 1
a1290 1
Für den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
d1295 1
a1295 1
showmount(8) versuche 
d1329 1
a1329 1
Es ist wichtig, dass du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
d1331 2
a1332 2
mit fsck zu überprüfen!! Die anderen Sicherheitsoptionen wie noexec, 
nodev und nosuid sollten auch immer - wenn anwendbar - verwendet werden. 
d1340 1
a1340 1
Mit diesen Optionen können keine Geräte oder setuid-Programme auf 
d1342 1
a1342 1
Wenn du keine Programme auf diesem NFS-Dateisystem auf dem NFS-Client 
d1362 1
a1362 1
Denk daran, dass aufgrund dieser »unsichtbaren« Natur ein Interface in 
d1379 1
a1379 1
Highspeed-Netzwerk verbunden ist. Das Hinzufügen einer zweiten 
d1397 1
a1397 1
Die Datei <tt>hostname.fxp0</tt> enthält die Konfigurationsdaten 
d1448 1
a1448 1
Das sagt aus, es soll eine Bridge aus zwei NICs aufgesetzt und aktiviert 
d1467 1
a1467 1
über beide Interfaces fließen, aber du nur auf einem Interface 
d1520 1
a1520 1
Wenn es auch möglich ist, auf beiden zu filtern, muss man das vorher 
d1535 1
a1535 1
an das Interface gerichtet ist. Das hat einen höheren Load für 
d1698 1
a1698 1
 
d2179 1
a2179 1
<a name="Multipath">
d2282 1
a2282 1
(z. B. beim Verlust des Carriers) für eine Multipathroute der Kernel 
d2305 2
a2306 2
Originally [OpenBSD: faq6.html,v 1.253 ]<br>
$Translation: faq6.html,v 1.129 2007/03/22 11:44:26 paldium Exp $<br>
@


1.107
log
@Sync with steelix translation CVS
@
text
@d1711 1
a1711 1
<h2>6.11 - Das-Common-Address-Redundancy-Protokoll (CARP)</h2>
d1717 10
a1726 12
CARP ist ein Werkzeug um beim Erreichen von System Redundanz zu helfen, indem
mehrere Computer ein einzelnes, virtuelles Netzwerk Interface zwischen sich
errichten, so dass, falls irgendein System ausfällt, ein anderes
antworten kann, und/oder einen gewissen Grad an Load Sharing zwischen Systemen
erlaubt.
CARP ist eine Verbesserung vom Virtual Router Redundancy Protokoll (VRRP)
Standard.
Es wurde entwickelt, nachdem VRRP als nicht frei genug wegen einem
möglicherweise-überlappendem Cisco Patent angesehen wurde.
Für weitere Informationen über CARPs Ursprünge und den
rechtlichen Problemen um VRRP, besuche bitte
<a href="../../lyrics.html#35">diese Seite</a>.
d1730 3
a1732 4
Michael Shalayeff, Marco Pfatschbacher und Markus Friedl) CARP so, dass es
fundamental anders war.
Die Einbindung von Kryptographie ist eine der prominentesten Änderungen,
aber weiterhin nur eine von vielen.
d1735 7
a1741 9
Wie es funktioniert: CARP ist ein Multicast Protokoll.
Es gruppiert mehrere physikalische Computer unter einer oder mehrerer
virtuellen Adressen zusammen.
Von diesen ist ein System der Master und antwortet auf alle Pakete, die
für diese Gruppe bestimmt sind, während die anderen Systeme
als ,hot spares' agieren.
Unbedeutend wie die IP und MAC Adressen des lokalen Interfaces sind, werden
Pakete, die zum CARP Interface gesendet worden sind, mit CARP Informationen
zurückgesendet.
d1745 19
a1763 21
der IP Protokoll Nummer 112.
Wenn der Master offline geht, beginnen die anderen Systeme in der CARP Gruppe
mit dem bekünden.
Der Host, der in der Lage ist am häufigsten zu bekünden, wird der
neue Master.
Wenn das Hauptsystem wieder online kommt, wird es standardmäßig
ein Backup Host, obwohl, wenn es wünschenswerter ist, dass ein Host
immer Master wird wenn das möglich ist (z.&nbsp;B. wenn ein Host eine schnelle
Sun Fire V120 ist und die anderen vergleichbar langsame SPARCstation IPCs
sind), kannst du sie so konfigurieren.

<p>
Während hoch redundante und Fehler-tolerante Hardware die Notwendigkeit
von CARP verringert, vernichtet sie sie nicht.
Es gibt keine Hardwarefehlertoleranz die in der Lage ist zu helfen, wenn
jemand das Stromkabel herauszieht oder wenn dein Systemadministrator
<tt>reboot</tt> im falschen Fenster eintippt.
CARP macht es außerdem einfacher den Patch- und Rebootzyklus transparent
den Anwendern gegenüber zu gestalten, und einfacher ein Software oder
Hardware Upgrade zu testen -- wenn es nicht funktioniert, kannst du auf deine
,spares' zurückgreifen, bis es behoben ist.
d1766 14
a1779 14
CARPs Design setzt voraus, dass die Mitglieder einer Gruppe sich im selben
physikalischen Subnet mit einer statischen IP-Adresse befinden, obwohl
mit der Einführung der carpdev-Direktive es keine Notwendigkeit mehr gibt,
den physischen Interfaces IP-Adressen zuzuweisen.
Ähnlich werden Dienste, die eine durchgehende Verbindung zum Server
benötigen (so wie SSH oder IRC), nicht transparent auf andere Systeme
weitergeleitet -- obwohl in diesem Fall CARP helfen kann, die Ausfallzeit
zu minimieren.
CARP wird von sich aus Daten zwischen Applikationen nicht synchronisieren,
dies muss durch "alternative Kanäle" wie zum Beispiel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">pfsync(4)</a>
(für redundantes Filtern), manuelles Duplizieren von Daten zwischen
Systemen mit <a href="http://rsync.samba.org/">rsync</a>, oder was auch immer
für deine Anwendungen geeignet ist, durchgeführt werden.
d1784 5
a1788 4
CARPs Kontrollen befinden sich an zwei Orten:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
d1791 9
a1799 12
<p>Die erste sysctl, <tt>net.inet.carp.allow</tt>, definiert, ob der Host
überhaupt CARP Pakete handhabt.
Klarerweise ist dies notwendig, um CARP nutzen zu können.
Diese sysctl ist standardmäßig aktiviert.

<p>Die zweite, <tt>net.inet.carp.arpbalance</tt>, wird für das Load
Balancing verwendet.
Wenn diese Funktion aktiviert ist, wird CARP ein ,source-hash' auf die
Quell-IP der Anfrage durchführen.
Dieser ,hash' wird dann verwendet, um einen virtuellen Host aus dem
zur Verfügung stehenden Pool auszuwählen, damit dieser die Anfrage
verarbeitet.
d1802 2
a1803 2
<p>Die dritte, <tt>net.inet.carp.log</tt>, loggt CARP Fehler.
Standardmäßig deaktiviert.
d1805 5
a1809 6
<p>Vierte, <tt>net.inet.carp.preempt</tt> aktiviert natürliche Auswahl
zwischen CARP Hosts.
Der passendste für den Job (das heißt, wer in der Lage ist am
schnellsten zu Bekünden) wird zum Master.
Standardmäßig deaktiviert, das bedeutet, dass ein System, das nicht
zum Master auserwählt wurde, nicht versuchen wird den Master Status
d1813 12
a1824 11
Alle diese sysctl Variablen sind in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a> dokumentiert.

<p>Für den Rest von CARPs Konfiguration verlassen wir uns auf
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Die CARP-spezifischen Kommandos <tt>advbase</tt> und <tt>advskew</tt>
behandeln das Intervall zwischen CARP-,advertisements'.
Die Formel (in Sekunden) ist <tt>advskew</tt> dividiert durch 256 und dann
addiert zu <tt>advbase</tt>.
<tt>advbase</tt> kann verwendet werden, um Netzwerkverkehr zu verringern oder
eine längere Latenz zuzulassen, bevor ein Backup Host übernimmt;
d1826 1
a1826 1
Host Master sein wird, ohne große ,failover´ Verzögerungen
d1829 5
a1833 5
<p>Als nächstes setzt <tt>pass</tt> ein Passwort und <tt>vhid</tt> setzt
die virtuelle Hostidentifizierungsnummer der CARP Gruppe.
Du musst jeder CARP Gruppe eine einzigartige Nummer verteilen, selbst wenn
(für Load Balancing Zwecke) sie sich die gleiche IP Adresse teilen.
CARP ist auf 255 Gruppen begrenzt.
d1842 4
a1845 3
packen. Angenommen du setzt zwei identische Web Server auf, <i>rachael</i>
(192.168.0.5) und <i>pris</i> (192.168.0.6), um ein älteres System
zu ersetzen, das unter 192.168.0.7 verfügbar war. Die Befehle:
d1853 6
a1858 5
<p>erstellen das carp0 Interface und geben es eine vhid von 1, ein Passwort
das <i>tyrell</i> lautet und die IP Adresse 192.168.0.7 mit der Maske
255.255.255.0. Weise fxp0 als Mitgliedsinterface zu.
Um es über die nächsten Reboots hinaus permanent zu machen, kannst
du eine <tt>/etc/hostnamecarp0</tt> Datei anlegen, die wie folgt aussieht:
d1864 4
a1867 4
Achte darauf, dass die Broadcast-Adresse in der Zeile neben der vhid
und dem Passwort mit angegeben wurde.
Das Vergessen der Angabe dieser Adresse ist ein häufiger Grund für
Fehler, da sie als Platzhalter benötigt wird.
d1870 3
a1872 3
Mache das Gleiche auf <i>pris</i>. Welches System von beiden das CARP
Interface zu erst aufsetzt wird Master (unter der Annahme, dass
,preempt' deaktiviert ist; das Gegenteil ist der Fall, wenn ,preempt'
d1878 7
a1884 8
<i>Rachael</i> war bereits unter der Adresse 192.168.0.7 vorhanden.
Wie umgehst du das?
Glücklicherweise kann CARP mit dieser Situation umgehen. Du kannst
die Adresse einfach dem CARP-Interface zuweisen und das physikalische
Gerät bei der Angabe des ,carpdev'-Schlüsselwortes belassen, ohne eine
IP-Adresse zuzuweisen. Trotz allem tendiert es dazu sauberer zu sein
jeweils eine IP für jedes System zu haben -- es macht individuelle
Überwachungen und Zugriffe viel einfacher.
d1889 4
a1892 4
Hardware Unterschiede, einfache Vorurteile, "wenn das System nicht Master
ist, wird es Probleme geben" oder zu wissen, wer der standardmäßige
Master ist ohne mit Skripten die Ausgabe von ifconfig zu verarbeiten und per
E-Mail zu versenden.
d1894 2
a1895 2
<p>Auf <i>rachael</i> werden wir die sysctl verwenden, die wir weiter oben
erstellt haben und editieren dann <tt>/etc/sysctl.conf</tt>, um sie
d1909 2
a1910 2
bedeutet, dass <i>rachael</i> Master sein wird, wenn der Host angeschlossen
ist.
d1913 1
a1913 1
Bedenke, dass du "proto carp" mit folgender Zeile an alle beteiligten
d1920 1
a1920 1
<h3>6.11.3 - Loadbalancing</h3>
d1922 5
a1926 5
<p>Siehe nun einige Monate nach vorne. Unsere Firma des vorherigen Beispiels
ist so gewachsen, dass sie an dem Punkt angekommen ist, an dem ein einzelner
Web Server die Last gerade so verarbeiten kann. Was nun? CARP ist die
Rettung. Es ist Zeit, Load Balancing zu versuchen. Erstelle ein neues CARP
Interface und eine Gruppe auf <i>rachael</i>:
d1935 1
a1935 1
anlegen und dann das "preempt" sysctl setzen:
d1944 4
a1947 4
<p>Nun haben wir zwei CARP Gruppen mit der gleichen IP Adresse.
Jede Gruppe zeigt auf einen anderen Host, was bedeutet, dass <i>rachael</i>
Master der originalen Gruppe bleibt, aber <i>pris</i> wird die neue
übernehmen.
d1949 2
a1950 2
<p>Alles, was wir nun tun müssen, ist die Load Balancing sysctl auf
beiden Systemen zu laden, die wir zuvor besprochen haben:
d1956 2
a1957 2
<p>Während diese Beispiele für einen zwei-Maschinen Cluster
sind, gelten die gleichen Prinzipien auch für mehrere Systeme.
d1959 3
a1961 3
50/50 Distribution zwischen den beiden Maschinen erreichst -- CARP verwendet
einen ,hash' der ankommenden IP Adresse um zu ermitteln, welches System
die Anfrage verarbeitet, statt durch Auslastung zu entscheiden.
d1975 27
a2001 26
Genaue Zeit ist wichtig für viele Computer Applikationen.
Trotzdem haben viele Leute bemerkt, dass ihre $5 Uhr eine genauere Uhrzeit
halten kann als ihr $2000 Computer.
Zusätzlich zum Wissen, welche Uhrzeit gerade ist, ist es ebenfalls
häufig wichtig, Computer zu synchronisieren, so dass sie alle mit der
gleichen Uhrzeit übereinstimmen. Für eine gewisse Zeit hat
<a href="http://www.ntp.org">ntp.org</a> eine Network Time Protokoll
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>) Applikation
entwickelt, verfügbar durch <a href="faq15.html#Ports">Ports</a>,
die verwendet werden kann, um die Uhren auf den Computern über das
Internet zu synchronisieren.
Trotzdem ist dies ein nicht-triviales Programm zum Einrichten, schwerer
Code zum Überprüfen und hat eine große Speicheranforderung.
Kurz gesagt spielt es eine wichtige Rolle für einige Leute, aber es ist
weit entfernt von einer Lösung für jedermann.

<p>
<a href="http://www.openntpd.org/de">OpenNTPD</a> ist ein Versuch, einige dieser
Probleme zu lösen, es einfacher-zu-administrieren zu machen und ein
sicherer und simpler NTP kompatibler Weg zu sein, um eine genaue Uhrzeit
auf deinem Computer zu haben.
OpenBSDs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a>
wird von einer einfach zu verstehenden Konfigurationsdatei gesteuert,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>.
d2006 3
a2008 3
weiter nach vorne gestellt wird, bis sie sich selbst mit den
<a href="http://www.pool.ntp.org/">pool.ntp.org</a>-Servern synchronisiert
halten kann, einer Sammlung von öffentlich verfügbaren Zeitservern.
d2019 5
a2023 6
<h3>6.12.1 - "Aber OpenNTPD ist nicht so genau wie der ntp.org Daemon!"</h3>
Das mag wahr sein.
Es ist nicht OpenNTPDs
<a href="http://www.openntpd.org/de/goals.html">Entwurfssziel</a>, es ist
vorgesehen, dass es frei, simpel, zuverlässig und sicher ist.
Wenn du wirklich Mikrosekunden Präzision mehr als die Vorteile von
d2025 3
a2027 3
er weiterhin durch Ports und Packages verfügbar sein wird.
Es existieren weder ein Plan noch das Verlangen, OpenNTPD mit allen
vorstellbaren Funktionen vollzustopfen.
d2030 2
a2031 2
<h3>6.12.2 - "Jemand hat behauptet, dass OpenNTPD ,schädlich' ist!"</h3>
Einige Leute haben die Ziele von OpenNTPD nicht verstanden -- ein
d2033 13
a2045 14
Computers genau zu halten.
Wenn genaue Zeit wichtig ist, haben einige Benutzer berichtet, dass die
Ergebnisse von OpenNTPD besser sind als die von ntp.orgs ntpd.
Wenn Sicherheit wichtig ist, ist OpenNTPDs Code sehr viel besser lesbar
(und daher, kontrollierbar) und wurde unter Verwendung von OpenBSD
Funktionsaufrufen wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>
statt portableren Funktionen wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>
entwickelt und wurde von Anfang an sicher geschrieben, nicht "später
sicher gemacht". Wenn es wertvoll ist, dass so viele Leute wie möglich
Zeit Synchronisierung verwenden, macht es OpenNTPD einer großen
Anzahl von Leuten einfacher, diese zu nutzen.
Wenn das "schädlich" ist, stimmen wir dem voll und ganz zu.
d2049 1
a2049 1
geht man davon aus, dass für einen Großteil der anderen Anwender
d2053 4
a2056 3
Eine ausführlichere Antwort hierauf von den Entwicklern von OpenNTPD kann
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">hier</a>
gelesen werden.
d2064 19
a2082 19
»<tt>#listen&nbsp;on&nbsp;*</tt>« in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5">/etc/ntpd.conf</a>
auskommentieren und den ntpd(8)-Daemon neustarten. Selbstverständlich
kannst du auch eine bestimmte IP-Adresse angeben, so dass er nicht auf
allen verfügbaren Adressen und Interfaces hört: ersetze »*« mit der
gewünschten Adresse.

<p>
Obwohl nun ntpd(8) erreichbar ist, kann es durchaus passieren, dass
sich andere Maschinen noch immer nicht synchronisieren können.
Ein erst kürzlich gestarteter ntpd(8)-Daemon (wenn du zum Beispiel
jetzt gerade nach der Anpassung der ntpd.conf neugestartet hast)
verweigert die Angabe von Zeitinformationen an andere Clients, bis
er seine eigene Uhrzeit auf ein hinnehmbar stabiles Maß angepasst hat.
Wenn ntpd(8) seine eigene Zeitinformation als stabil betrachtet, wird
der Eintrag »clock now synced« in <tt>/var/log/daemon</tt> geschrieben.
Selbst wenn die Systemzeit bereits von Anfang an sehr genau war, kann
es bis zu 10 Minuten dauern, bis alles synchronisiert ist - wenn
die Uhrzeit nicht genau eingestellt ist sogar Stunden oder Tage.
d2089 1
a2089 1
OpenBSD hat Unterstützung für  eine Anzahl von Wireless-Chipsätzen:
d2091 49
a2139 31
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3. <sup>(AP</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
Treiber für Atheros IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 IEEE 802.11b. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB IEEE 802.11b.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 IEEE 802.11b. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4">acx(4)</a>
TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4">rum(4)</a>
Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4">wpi(4)</a>
Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4">uath(4)</a>
Atheros AR5005UG/AR5005UX USB2.0 (work-in-progress). <sup>(NFF)</sup>
d2150 7
a2156 8
Netzwerkkarten genutzt werden, um ein OpenBSD-System mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
an ein existierendes Wireless Netzwerk anzubinden (bitte lies die
Manualseiten für präzise Details).
Einige dieser Karten können jeodch auch in dem
,Host-Based Access Point'-Modus genutzt werden, das ihnen erlaubt, in deinen
Wireless Access Point für dein Netzwerk als Teil deiner Firewall gesetzt
zu werden.
d2160 3
a2162 3
beziehen musst, bevor du sie einsetzen kannst. Dies gielt für alle
Firmwaredateien, für die die Hersteller keine
<a href="faq1.html#ReallyFree">freie</a> Weiterverbreitung erlauben,
d2167 1
a2167 1
Oder teile ihnen mit, welches Produkt du statdessen erworben hast.
d2172 1
a2172 1
und einem externen Bridging Access Point.
d2306 1
a2306 1
$Translation: faq6.html,v 1.128 2007/03/21 21:37:50 paldium Exp $<br>
@


1.106
log
@Sync with steelix translation CVS
@
text
@d77 5
a81 5
haben, weiterhin helfen die
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> und
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> Manual Seiten.
d85 4
a88 3
und dein OpenBSD Rechner dein Router wird, dann solltest du dein Wissen
über IP Netzwerke mit 
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">Understanding
d90 4
a93 4
Dies ist wirklich ein exzellentes Dokument. "Understanding IP
addressing" beinhaltet grundlegendes Wissen, auf dem man bei der Arbeit mit
IP Netzwerken aufbauen kann, insbesondere wenn man es mit mehreren Netzwerken
zu tun hat oder für sie verantwortlich ist.
d99 1
a99 1
Natürlich kannst du nicht alle lesen. Aber dennoch, lies jene,
d117 1
a117 1
<a name="Setup.1f"></a>
d121 5
a125 5
Unter OpenBSD werden Netzwerkkarten nach ihrem
Typ, nicht nach Verbindungsart benannt. Du kannst sehen, ob deine 
Netzwerkkarte initialisiert wurde, entweder schon beim Booten oder auch 
später mit Hilfe des Befehls 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>. 
d127 3
a129 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
deine Karte überprüfen. Als Beispiel hier die Ausgabe von
dmesg für eine Intel Fast Ethernet Netzwerkkarte, die als 
d138 1
a138 1
Wenn du deinen Geräte-Namen nicht kennst, sieh bitte in der 
d141 4
a144 3
und ihre OpenBSD Geräte-Namen finden (wie etwa fxp), zusammen mit 
einer Nummer, die vom Kernel zugewiesen wird, und du hast den sogenannten 
Interface-Namen (wie z.&nbsp;B. fxp0).
d153 7
a159 6
du das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
Kommando benutzt.
Das folgende Kommando zeigt uns alle Netzwerk-Interfaces im System an.
Diese Beispielausgabe zeigt ein physikalisches Ethernetinterface, ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.
d199 3
a201 3
Wie du hier sehen kannst, gibt uns
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
eine Menge mehr Informationen, als wir zu diesem Zeitpunkt 
d204 1
a204 1
offensichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, 
d206 2
a207 2
10.0.0.255&quot;. Außerdem sind die <strong>UP</strong> und
<strong>RUNNING</strong> Flags gesetzt.
d210 4
a213 4
Schlussendlich fällt auf, dass standardmäßig eine Menge mehr 
Interfaces aktiviert sind. Dies sind virtuelle Interfaces, die verschiedene 
Funktionen haben. Informationen dazu findest du auf den folgenden Manual
Seiten:
d217 22
a238 22
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - SLIP Netzwerk Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Generic IPv4/IPv6 Tunnel Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Common Address Redundancy Protocol Interface
d255 4
a258 4
Viel mehr Details zu dieser Datei findest du in der Manualseite für
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>.
In ihr finden sich vor allem Informationen für nicht ganz so einfache
Konfigurationen.
d261 1
a261 1
Eine typische Interface-Konfigurationsdatei für eine IPv4 Adresse
d276 2
a277 2
Du solltest auch den ,media type' für Ethernet angeben, wenn du z.&nbsp;B. den
100baseTX full-duplex Modus erzwingen willst.
d285 2
a286 2
Verbindungen auf Voll-Duplex gestellt sind! Wenn du keine besonderen
Anforderungen hast, kannst du diese media Einstellungen einfach
d288 1
a288 1
auf 10base-T oder Half Duplex, wenn das Netzwerk dies erfordert.)
d303 5
a307 5
Schreib die IP-Adresse deines Standardgateways in die Datei <i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5">/etc/mygate</a></i>.
Damit wird dein Gateway während des Bootvorgangs eingestellt. Die
Datei besteht nur aus einer einzigen Zeile, in der die Adresse
deines Gateways steht:
d322 4
a325 3
Die DNS-Auflösung wird über die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"><i>/etc/resolv.conf</i></a>
verwaltet. Hier ist ein Beispiel einer <i>/etc/resolv.conf</i>-Datei:
d341 6
a346 6
gibt es eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5"><i>/etc/hosts</i></a>-Datei,
in die alle Systemene eingetragen werden können, die sich nicht in
einem formalen DNS-System befinden (falls sie dort anders angegeben sind
als gewünscht, kann man die »lookup«-Reihenfolge wie im vorherigen
Beispiel anpassen).
d350 3
a352 2
achte auf den Einsatz von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">resolv.conf.tail(5)</a>.
d358 5
a362 4
Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=myname&amp;sektion=5"><i>/etc/myname</i></a>
angegeben. Falls die Maschine »puffy« heißt und sich in der Domain
»example.com« befindet, würde folgende Zeile in der Datei stehen:
d370 3
a372 2
Jetzt kannst du entweder rebooten oder das <strong>/etc/netstart</strong>
Skript ausführen, indem du (als root) Folgendes eingibst:
d386 5
a390 4
Kernel Routing Tabelle. Von hier ab sollte dein System laufen und online sein.
Du kannst hier erneut mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
prüfen, ob deine Interfaces richtig konfiguriert wurden.
d405 9
a413 9
Deine Routen kannst du via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a> 
überprüfen.
Wenn du Probleme mit dem Routing hast, möchtest du vielleicht
das -n Flag für route(8) benutzen, das die IP-Adressen ausgibt, statt 
einen DNS Lookup zu machen, und um den Hostnamen anzuzeigen.
Hier ist ein Beispiel mit beiden Kommandos, um die Routing Tabelle anzeigen
zu lassen:
d451 8
a458 8
Dies sind nur die grundlegenden Informationen, um deinen OpenBSD Rechner als
Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als Router
im Internet verwenden willst, solltest du auch die unten folgenden Packet Filter
Instruktionen beachten, um potentiell schädliche IP Daten zu blockieren.
Auch solltest du wegen der Knappheit an 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
Adressen die Informationen bezüglich Network Address Translation beachten, 
um deinen IP Adressbereich zu schonen.
d461 8
a468 7
Der GENERIC Kernel hat bereits die Fähigkeit für IP Forwarding,
aber dies muss erst eingeschaltet werden. Du solltest dies mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
tun. Um diese Änderung permanent einzutragen, musst du die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
editieren. Füge einfach folgende Zeile in diese Konfigurationsdatei
ein.
d475 5
a479 4
Ohne Reboot kannst du dies auch direkt mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> 
durchführen. Beachte aber, dass diese Änderung nach einem Reboot
weg ist und dass der folgende Befehl als root ausgeführt werden muss.
d488 11
a498 12
Möglichkeiten, OpenBSD als Router einzusetzen, z.&nbsp;B. mittels Software
wie das OpenBSD-eigene <a href="http://www.openbgpd.org/">OpenBGPD</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.mrtd.net">mrtd</a>,
<a href="http://www.zebra.org">zebra</a> und
<a href="http://www.quagga.net">quagga</a>.
OpenBSD hat Unterstützung in der Ports-Kollektion sowohl für zebra als
auch für quagga und mrtd. OpenBGPD und routed werden als Teil des
Basissystems installiert.
OpenBSD unterstützt
mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP)
Schnittstellen.
d506 8
a513 8
Netzwerkkarten zu setzen. Dazu musst du einfach die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>
editieren. Sie wird beim Booten vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">/etc/netstart(8)</a>
Skript gelesen, das ein Teil der <a href="faq10.html#rc">rc startup
Hierarchie</a> ist. Für dieses Beispiel nehmen wir an, dass der User ein
Interface <b>dc0</b> hat und sich im Netzwerk 192.168.0.0 befindet. Weitere
wichtige Informationen:
d521 16
a536 16
Ein paar Bemerkungen zu Aliasen: In OpenBSD verwendet man nur den Adapternamen.
Es gibt keine Unterschiede zwischen dem ersten und dem zweiten Alias. 
Daher muss man sie nicht - wie in einigen anderen Betriebssystemen - 
als dc0:0, dc0:1 bezeichnen.
Wenn du dich auf einen speziellen IP Alias beziehst oder einen hinzufügst, 
dann nimm "<tt>ifconfig int alias</tt>" anstelle nur "<tt>ifconfig int</tt>" 
auf der Befehlszeile. Du kannst Aliase mit "<tt>ifconfig int delete</tt>" 
löschen. 

<p>
Angenommen du verwendest mehrere IP Adressen im selben IP Subnetz mit Aliases, 
dann ist die Netzmaskeneinstellung für jeden Alias 255.255.255.255.
Sie müssen nicht der Netzmaske der ersten IP der Netzwerkkarte folgen. 
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Aliase zur
Netzwerkkarte dc0 hinzugefügt, die als 192.168.0.2 mit Netzmaske
255.255.255.0 konfiguriert wurde.
d546 1
a546 1
Wenn du einmal diese Datei erstellt hast, benötigst du einen Reboot,
d548 3
a550 3
die Aliase manuell mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
hochbringen. Für den ersten Alias geht das so:
d575 1
a575 1
zum Filtern von TCP/IP Verkehr und zum Ausführen von Network Address 
d577 3
a579 5
und zu konditionieren, eine Priorisierung von Paketen 
durchzuführen und kann verwendet werden, um eine mächtige und
flexible Firewall zu erzeugen.
Er wird im <a href="../pf/de/index.html"><b>PF-Benutzerhandbuch</b></a>
beschrieben.
d585 5
a589 5
Das Dynamic Host Configuration Protokoll ist ein Weg, um die Netzwerkkarten
"automatisch" zu konfigurieren.
OpenBSD kann als DHCP Server (der andere Maschine konfiguriert), als ein
DHCP Client (der von einer anderen Maschine konfiguriert wird) und in
einigen Fällen auch als beides eingesetzt werden.
d596 6
a601 6
Um den DHCP-Client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
zu benutzen, der Teil von OpenBSD ist, editiere
<tt>/etc/hostname.xl0</tt> (wenn deine Hauptethernetkarte xl0 ist.
Deine kann ep0 oder fxp0 oder irgendeine andere sein). Alles, was du
in diese Datei zu schreiben hast, ist ,<tt>dhcp</tt>'.
d608 3
a610 3
Dies wird OpenBSD veranlassen, den DHCP Client automatisch beim Booten zu 
starten.  OpenBSD wird sich seine IP Adresse, sein Standardgateway und seine 
DNS Server vom DHCP Server besorgen.  
d613 2
a614 2
Wenn du den DHCP Client von der Befehlszeile aus starten willst, stelle sicher, 
dass <tt>/etc/dhclient.conf</tt> existiert, dann versuche:
d621 2
a622 1
Wobei <tt>fxp0</tt> die Netzwerkkarte ist, auf der du dhcp empfangen willst.
d625 6
a630 5
Wie auch immer du den DHCP Client startest, kannst du die <tt>/etc/dhclient.conf</tt>
Datei immer so editieren, dass dein DNS <b>nicht</b> erneuert wird aufgrund 
der neuen DNS Informationen, indem du die 'request' Zeilen auskommentierst 
(Es gibt Beispiele in den Standardeinstellungen, aber du musst die 
Standardeinstellungen von dhclient überschreiben). 
d638 2
a639 3
sowie <tt>domain-name-servers</tt> entfernen.
Natürlich möchtest du vermutlich auch Einstellungen wie
<tt>hostname</tt> entfernen.
d642 9
a650 9
Durch das Ändern der Optionen in deiner
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">
dhclient.conf(5)</a>-Datei teilst du dem DHCP-Client mit, wie deine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>-Datei
erzeugt werden soll.
Der DHCP-Client überschreibt jegliche Informationen, die du bereits in
der resolv.conf(5) hast, mit jenen, die er vom DHCP-Server erhält.
Daher wirst du alle Änderungen verlieren, die du manuell an der
resolv.conf vorgenommen hast.
d657 5
a661 4
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">OPTION
MODIFIERS</a></tt>
(<b>default</b>, <b>supersede</b>, <b>prepend</b> und <b>append</b>)
erlauben dir, jegliche Optionen in dhclient.conf(5) zu überschreiben.
d664 5
a668 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"><tt>resolv.conf.tail(5)</tt></a>
ermöglicht dir, alle Informationen, die du haben möchtest, an die
resolv.conf(5)-Datei anzuhängen, die durch dhclient(8) erstellt wurde.
d673 3
a675 4
bind</tt> an die resolv.conf(5) hängen möchtest, die von dhclient(8)
erstellt wurde. Hierfür gibt es keine Option in <tt>dhclient.conf</tt>,
so musst du <tt>resolv.conf.tail</tt> benutzen, um dieses Ziel zu
erreichen.
d681 1
a681 2
Nun sollte deine resolv.conf(5) ,lookup file bind' am Ende stehen
haben.
d693 5
a697 5
Wenn du OpenBSD als DHCP-Server 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>
einsetzen willst, editiere <tt>/etc/rc.conf.local</tt> so, dass
sie die Zeile <tt>dhcpd_flags=""</tt> beinhaltet.
Und die Netzwerkkarten, auf denen dhcpd(8) <b>lauschen</b> soll, stehen in
d705 2
a706 2
Dann editiere <tt>/etc/dhcpd.conf</tt>.
Die Optionen sind selbsterklärend.
d720 1
a720 1
Dies teilt deinen DHCP Clients mit, dass die an DNS Anfragen 
d722 6
a727 6
'telnet joe' schreibt, dann wird an joe.example.com gesendet). Es wird auf
die DNS Server 192.168.1.3 und 192.168.1.5 verwiesen. Für Hosts, die
sich im selben Netzwerk wie die Netzwerkkarte des OpenBSD Rechners befinden,
welche im 192.168.1.0/24 Adressbereich liegt, wird der DHCP Server ihnen eine
IP Adresse zwischen 192.168.1.32 und 192.168.1.127 und als Standardgateway
192.168.1.1 zuweisen.
d739 4
a742 4
Die <tt>touch</tt> Zeile ist notwendig, um eine leere <tt>dhcpd.leases</tt>
Datei zu erzeugen, bevor dhcpd(8) starten kann.
Die OpenBSD <a href="faq10.html#rc">Startup Skripte</a> erstellen diese
Datei beim Hochfahren, wenn es notwendig ist, aber wenn du dhcpd(8)
d748 3
a750 3
Wenn du DHCP Dienste für einen Windows Rechner bereitstellst, dann willst
du vielleicht auch eine 'WINS' Serveradresse liefern.
Dafür füge einfach die folgenden Zeilen zu deiner <tt>/etc/dhcpd.conf</tt>:
d757 5
a761 5
(wobei <tt>192.168.92.55</tt> die IP deines Windows oder Samba Servers ist.)
Siehe auch 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>
für weitere Optionen, die 
deine DHCP Clients wünschen.
d769 3
a771 2
Das Point-to-Point Protokoll wird verwendet, um eine Verbindung zu deinem ISP
mit deinem Einwahl-Modem herzustellen. OpenBSD bietet dafür 2 Möglichkeiten:
d775 1
a775 1
- der Kernel PPP Daemon.
d777 1
a777 1
- der Userland PPP Daemon. 
d781 10
a790 11
Sowohl ppp als auch pppd führen zwar die gleichen Funktionen auf, dieses
jedoch auf unterschiedliche Wege. pppd arbeitet mit dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>-Treiber
des Kernels, während ppp mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>
im Userland arbeitet.
Dieses Dokument wird sich nur mit dem PPP-Daemon des Userlands beschäftigen,
da es mit ihm einfacher ist, Fehlfunktionen zu korrigieren sowie mit ihm zu
interagieren. Um zu beginnen, benötigen wir einige einfache Informationen
über deinen ISP. Hier eine Liste hilfreicher Informationen, die du brauchen
wirst.
d801 7
a807 6
beim Aufsetzen des ppp hilfreich. Der Userland PPP Daemon benutzt die Datei 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
als seine Konfigurationsdatei. Es gibt viele hilfreiche Dateien in
<i>/etc/ppp</i>, die verschiedene Einstellungen für verschiedene
Situationen zeigen. Du solltest dir dieses Verzeichnis ansehen und es
durchforsten.
d813 7
a819 7
Die ersten Einstellungen für den Userland PPP Daemon bestehen im
Erstellen deiner <i>/etc/ppp/ppp.conf</i> Datei. Diese Datei existiert nicht 
standardmäßig, aber du kannst einfach
<i>/etc/ppp/ppp.conf.sample</i> editieren, um deine eigene <i>ppp.conf</i>
Datei zu erstellen. Hier werde ich mit den einfachsten und gebräuchlichsten
Einstellungen beginnen. Hier eine kurze <i>ppp.conf</i> Datei, die einfach
einige Standardwerte setzt:
d832 12
a843 12
Der Absatz unter der <tt>default:</tt> Bezeichnung wird jedes Mal
ausgeführt. Hier stehen alle wichtigen Informationen. Mit &quot;set
log&quot; stellen wir unsere Loglevel ein. Um dies zu ändern, siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
für weitere Info. Unsere Schnittstelle wird mit
&quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit der das 
Modem verbunden ist. In diesem Beispiel hängt das Modem auf COM Port 2.
Daher wird COM Port 1 auf <i>/dev/cua00</i> gesetzt. Mit &quot;set speed&quot;
setzen wir die Geschwindigkeit unserer Einwahl-Verbindung und mit &quot;set
dail&quot; setzen wir unsere Dialup Parameter, mit denen wir den Timeout
usw. setzen können. Diese Zeile sollte eigentlich ziemlich genau so bleiben,
wie sie jetzt ist.
d849 3
a851 3
nimmst du den Namen deines ISP. Hier werde ich <tt>myisp:</tt> als Verweis
auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, das alles
beinhaltet, um uns zu verbinden:
d867 5
a871 5
Die erste Option &quot;set phone&quot; setzt die Einwahlnummer deines ISPs.
&quot;set login&quot; setzt unsere login-Optionen. Hier haben wir den Timeout
auf 5 gesetzt, was bedeutet, dass wir unseren login-Versuch nach 5 Sekunden
abbrechen, wenn wir kein Trägersignal bekommen. Ansonsten wird er auf
&quot;login:&quot; warten und dann deinen Benutzernamen und dein Passwort
d875 5
a879 5
In diesem Beispiel ist unser Benutzername = ppp 
und das Passwort = ppp. Diese Werte müssen geändert werden. Die
Zeile &quot;set timeout&quot; setzt den Idle Timeout für die gesamte
Verbindungsdauer auf 120 Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein
bisschen schwieriger. Hier ist eine genauere Erklärung.
d886 23
a908 23
Die obige Zeile folgt dem Format von 
&quot;<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske
[startAdr]]]]</b>&quot;. Daher ist die erste spezifizierte IP diejenige,
die wir als unsere IP wollen. Wenn du eine statische IP Adresse hast, dann
kannst du sie hier einsetzen. In unserem Beispiel benutzen wir /0, was besagt,
dass keine Bits von dieser IP Adresse übereinstimmen müssen und der gesamte
Ausdruck ersetzt werden kann. Die zweite IP behandelt die von uns erwartete
IP unserer Gegenstelle. Wenn du sie weißt, dann kannst du sie hier 
angeben. Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also
lassen wir sie uns wieder mitteilen. Die dritte Option ist unsere Netzmaske,
hier auf 255.255.255.0 gesetzt. Wenn startAdr spezifiziert ist, dann wird
diese anstelle von meineAdr während der initialen IPCP Verhandlung; aber
es wird nur eine Adresse aus dem meineAdr-Adressbereich akzeptiert. Dies ist
nützlich, wenn Verhandlungen mit einigen PPP Implementierungen durchgeführt
werden, die keine IP Nummer vergeben, es sei denn, ihr Peer fordert
``0.0.0.0'' an.

<p>
Die nächste Option &quot;add default HISADDR&quot; setzt unsere
Standardroute zu deren IP. Dies ist ,klebrig', d.&nbsp;h. falls deren IP sich
ändern sollte, dann wird unsere Route auch automatisch upgedatet. Mit
&quot;enable dns&quot; teilen wir unserem ISP mit, unsere Nameserveradresse
zu authentifizieren. Tu dies NICHT, wenn du deinen eigenen lokalen DNS
d913 1
a913 1
Gegenüber den herkömmlichen Login-Methoden, verwenden viele IPS nun
d933 5
a937 5
das Passwort (ppp) unter jeweiliger Verwendung von authname und authkey an.
Es ist nicht notwendig, anzugeben, ob CHAP- oder PAP-Authentifizierung
genutzt wird - es wird automatisch ermittelt. "set login" gibt lediglich
an, dass versucht wird, sich mit dem zuvor genannten Benutzernamen und
dem Passwort anzumelden.
d943 1
a943 1
Nun, da wir unsere <i>ppp.conf</i> Datei fertig eingerichtet haben,
d970 2
a971 2
gibt es zwei Dateien, die du erstellen kannst: <i>/etc/ppp/ppp.linkup</i> und
<i>/etc/ppp/ppp.linkdown</i>.
d975 6
a980 2
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
d988 1
a988 1
herkömmlichen Einwähl-Methoden sind. Dies beinhaltet Varianten wie
d1003 5
a1007 4
Das ,Point to Point Protocol over Ethernet' (PPPoE) ist eine Methode,
um PPP-Pakete in Ethernet-Frames zu versenden.
Das ,Point to Point Protocol over ATM' (PPPoA) läuft typischerweise
in ATM-Netzwerken, wie sie in UK oder Belgien gefunden werden können.
d1011 2
a1012 2
über eine normale Ethernetkarte und Ethernet-basierendes DSL-Modem
herstellen kannst (im Gegensatzu zu einem Nur-USB-Modem).
d1017 4
a1020 3
Wenn das Modem einen ,bridge'-Modus hat, ist es alternativ möglich,
dies zu aktivieren und so das Modem die Pakete einfach zu einer Maschine
,durchleiten zu lassen', welche PPPoE-Software einsetzt (siehe unten).
d1023 9
a1031 9
Das Haupt-Softwareinterface für PPPoE/PPPoA unter OpenBSD ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)</a>,
welches die Userland-Implementierung ist (auf fast die gleiche Art und
Weise, wie wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
weiter oben beschrieben haben).
Eine Kernel-PPPoE-Implementierung,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)</a>,
wurde in OpenBSD eingebunden.
d1037 10
a1046 11
Das ,Point to Point Tunneling Protocol' (PPTP) ist eine proprietäres
Microsoft-Protokoll.
Ein pptp-Client ist verfügbar, welcher mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
kommuniziert und ist in der Lage, sich zu PPTP-basierenden
Virtuellen Privaten Netzwerken (VPN) zu verbindungen, die von einigen
Kabel- und xDSL-Anbietern verwendet werden.
pptp selbst muss von den <a href="faq15.html#PkgMgmt">Packages</a> oder
<a href="faq15.html#Ports">Ports</a> aus installiert werden.
Weitere Anleitungen, wie man pptp einrichtet und verwendet, befinden
sich in der Manualseite, welche mit dem pptp-Package installiert wird.
d1059 1
a1059 1
Normalerweise möchtest du das tun, um Routing zuzulassen oder wegen
d1078 1
a1078 1
<h3>6.6.2 - Wie kann ich ,directed broadcasts' aktivieren?</h3>
d1081 3
a1083 3
Normalerweise willst du dies nicht tun.  Dies erlaubt jemandem, Datenverkehr
zu der broadcast Adresse deines verbundenen Netzwerkes zu schicken, wenn du
deinen OpenBSD Rechner als Router verwendest.
d1086 4
a1089 5
Aber manchmal kann dies, in geschlossenen Netzwerken, nützlich sein,
vor allem wenn man ältere Implementierungen des NetBIOS Protokolles
verwendet.
Wiederum mit sysctl.
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> aktiviert dies.
d1097 3
a1099 2
Auch dafür gibt es einen eigenen sysctl Befehl.  Siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:
d1102 1
a1102 1
Setze die Liste der reservierten TCP Ports, die nicht dynamisch vom
d1106 1
a1106 1
mit Kommata und/oder Leerzeichen getrennt werden.
d1131 1
a1131 1
können. Verändere diese Wert nicht, wenn du nicht tatsächlich weniger
d1138 4
a1141 4
<p>NFS, oder Network File System (Netzwerkdateisystem), wird verwendet, um 
ein Dateisystem über das Netzwerk zu verwenden. Du solltest vorher noch 
folgende Manual Seiten lesen, bevor du versuchst, einen eigenen NFS Server 
aufzusetzen:
d1144 9
a1152 3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
d1156 24
a1179 24
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS System aufzusetzen: 
Einen Server im LAN und Clients im LAN, die NFS verwenden. Es behandelt nicht, 
wie man NFS sicher macht. Wir nehmen an, dass du bereits Paketfilterung 
oder irgendeinen anderen Firewallschutz eingerichtet hast, damit von 
außerhalb nicht auf NFS zugegriffen werden kann.
Wenn du Zugriff via NFS von außerhalb erlauben willst und sensible Daten 
dort gespeichert hast, dann empfehlen wir dir wärmstens den Gebrauch von 
IPsec.  Ansonsten können andere Leute 
möglicherweise deinen NFS Datenverkehr sehen. Jemand könnte auch 
vortäuschen, die IP Adresse zu haben, der du Zugriff auf den NFS Server 
zulässt. Es gibt mehrere Angriffe, die möglich sind. Wenn IPsec 
richtig konfiguriert ist, dann schützt es gegen die Art von Angriffen. 

<p>
Noch eine wichtige Anmerkung wegen Sicherheit. Füge niemals ein 
Dateisystem zu <i>/etc/exports</i> ohne eine Liste mit Rechnern, die explizit
Zugriff haben sollen. Ohne einer solchen Liste, die ein bestimmtes Verzeichnis 
mounten können, kann jeder, der den Rechner erreichen kann, deine NFS 
exports mounten.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
muss laufen, damit NFS funktionieren kann. Portmap(8) ist unter OpenBSD
standardmäßig abgeschaltet, so dass du die Zeile
d1185 4
a1188 4
in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>
einfügen musst, damit es beim nächsten Start geladen wird.
Du kannst ihn auch wie folgt manuel starten:
d1197 1
a1197 1
deine <i>/etc/exports</i> Datei zu erstellen. Diese Datei listet die 
d1200 4
a1203 3
<i>/etc/exports</i> Datei haben kannst, und am besten ist, du liest die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
Manual Seite. Für dieses Beispiel sieht <i>/etc/exports</i> so aus:
d1214 7
a1220 7
D.h., dass das lokale Dateisystem <tt>/work</tt> via NFS zugänglich 
gemacht wird. <tt>-alldirs</tt> bedeutet, dass Clients jedes Verzeichnis 
unter dem <tt>/work</tt> Mount Point mounten können. <tt>-ro</tt> bedeutet,  
dass nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, dass nur Clients innerhalb des 10.0.0.0 Netzwerkes mit einer 
Netzmaske von 255.255.255.0 dieses Dateisystem mounten dürfen. Dies ist 
wichtig für einige Server, die von verschiedenen Netzwerken 
d1224 5
a1228 5
Ist einmal deine <i>/etc/exports</i> Datei eingerichtet, kannst du 
weitergehen und deinen NFS Server aufsetzen. Du solltest zuerst sicherstellen, 
dass deine Kernelkonfiguration die Optionen NFSSERVER &amp; NFSCLIENT 
enthält (der GENERIC-Kernel beinhaltet diese Optionen). Dann 
solltest du die Zeile
d1234 8
a1241 9
in <i>/etc/rc.conf.local</i> einfügen. 
Dies wird sowohl nfsd(8) und mountd(8) starten, wenn du neustartest.
Nun kannst du fortschreiten und die Dienste selber starten. Diese Dienste 
müssen als root gestartet werden und du musst sicherstellen,
dass portmap(8) auf deinem System läuft. Hier ein Beispiel von 
nfsd(8), der sowohl mit TCP als auch mit UDP bedient mittels 4 Diensten. 
Du solltest eine angemessenene Anzahl von NFS Serverdiensten einsetzen, um 
die maximale Anzahl von gleichzeitigen Clientanfragen, die du bedienen 
willst, zu bewerkstelligen.
d1248 1
a1248 1
Du musst nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
d1250 1
a1250 1
mountd(8) zu starten stelle sicher, dass eine leere mountdtab Datei
d1291 5
a1295 4
du den Status von NFS überprüfen kannst. Eines ist 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>
das dir anzeigt, was und wer gerade mountet. Dann gibt es auch noch nfsstat(8),
das genauere Statistiken anzeigt. Für showmount(8), versuche 
d1309 6
a1314 5
gesagt,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Um ein Dateisystem <i>/work</i> von Host 10.0.0.1 auf dem lokalen
Dateisystem <i>/mnt</i> zu laden, tue folgendes (bedenke, dass du nicht
IP-Adressen verwenden musst, mount wird Hostnamen auflösen):
d1321 1
a1321 1
Damit dein System dies beim Hochfahren wieder tut, füge folgendes
d1330 3
a1332 3
damit dein Rechner nicht versucht, das NFS Dateisystem beim Hochfahren mit 
fsck zu überprüfen!!!! Die anderen Sicherheitsoptionen wie noexec, 
nodev und nosuid, sollten auch immer - wenn anwendbar - verwendet werden. 
d1340 3
a1342 3
Mit diesen Optionen können keine Geräte oder setuid Programme auf 
dem NFS Server Sicherheitsmaßnahmen auf dem NFS Client untergraben. 
Wenn du keine Programme auf diesem NFS Dateisystem auf dem NFS Client 
d1350 10
a1359 9
Eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">Bridge</a>
ist ein Link zwischen zwei oder mehr separaten Netzwerken. Anders als 
ein Router reisen Pakete durch die Bridge "unsichtbar" -- logisch 
erscheinen die beiden Netzwerksegmente als eines für Rechner auf 
beiden Seiten der Bridge. Die Bridge wird nur Pakete weiterleiten, die 
auch von einem Segment in das andere müssen, sie bieten also
auch einen einfachen Weg den Verkehr in einem komplexen Netzwerk zu 
reduzieren und erlauben trotzdem den Zugriff jedes Rechners zu jedem
anderen, falls nötig.
d1362 1
a1362 1
Denk daran, dass aufgrund dieser "unsichtbaren" Natur ein Interface in 
d1364 5
a1368 5
hat, hat die Karte effektiv zwei Betriebsmodi, nämlich eine
als Teil der Bridge, die andere als normale, stand-alone Netzwerk-Karte.
Wenn keine der Karten eine IP-Adresse hat, wird die Bridge einfach
Netz-Daten verschieben, aber nicht extern administrierbar 
oder wartbar sein (was auch ein Feature sein kann).
d1374 7
a1380 7
Eines meiner Computer Racks hat eine Anzahl alter Systeme, von denen keines
eine eingebaute 10BASE-TX Netzwerkkarte hat. Während sie alle einen 
AUI oder AAUI Stecker haben, sind die Transceiver auf Koax beschränkt.
Eine der Maschinen in diesem Rack ist ein OpenBSD-basierender 
Terminal-Server, der dauerhaft eingeschaltet und auch immer mit einem
High-Speed-Netzwerk verbunden ist. Das Hinzufügen einer zweiten 
Netzwerkkarte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge 
d1384 11
a1394 10
Dieses System hat jetzt zwei Netzwerkkarten (NICs), eine Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
und eine 3c590-Combo Karte 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
für den Koax-Port. <tt>fxp0</tt> ist der Link in mein restliches 
Netzwerk und wird daher eine IP-Adresse haben, <tt>ep0</tt> macht nur
Bridging und hat daher keine.
Maschinen, die an das Koax-Segment angeschlossen sind, sollen genauso
kommunizieren, als wenn sie im Rest meines Netzwerkes wären.
Wie also bewerkstelligen wir das?
d1398 1
a1398 1
für die <tt>fxp0</tt> Karte.  Diese Maschine soll DHCP machen,
d1412 1
a1412 1
Die <tt>ep0</tt> Karte ist ein wenig anders, wie du dir denken kannst:
d1422 8
a1429 8
Hier sagen wir dem System, es möge das Interface mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
aktivieren und auf 10BASE-2 (Koax) setzen. Keine IP Addresse oder ähnliche 
Information muss für dieses Interface spezifiziert werden. Die 
Optionen, die von der <tt>ep</tt> Karte akzeptiert werden, sind
detailliert in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">Manual
Seite</a> aufgeführt.
d1433 4
a1436 3
einer Datei namens
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
initialisiert. Hier ist zum Beispiel eine Datei für meine Situation:
d1449 3
a1451 4
werden, fxp0 und ep0.
Es ist egal, in welcher Reihenfolge die Karten aufgeführt werden.
Denke daran, die Bridge ist symmetrisch -- Pakete fließen ja in beide
Richtungen.
d1454 1
a1454 1
Das war es!  Reboote, und du wirst eine funktionierende Bridge haben.
d1459 5
a1463 6
Während es sicher auch eine Menge Anwendungen für eine 
solch einfache Bridge gibt, ist es doch wahrscheinlich, dass du
etwas mit den ganzen Paketen TUN willst, während sie durch deine Bridge
laufen. Wie zu erwarten, kann man
<a href="#PF">Packet Filter</a> dazu benutzen, den Traffic einzuschränken,
der durch deine Bridge fließt.
d1468 1
a1468 1
filtern brauchst. Deine "Pass all" Statements würden dann
d1481 6
a1486 5
Sagen wir nun, ich wollte den Traffic filtern, der auf diese alten Maschinen
trifft. Ich möchte, dass nur Web- und SSH-Verkehr zu ihnen durchkommt.
In diesem Fall lassen wir jeglichen Verkehr durch das <tt>ep0</tt> Interface
zu, sowohl rein als auch raus, aber filtern auf dem <tt>fxp0</tt> Interface,
indem wir <tt>keep state</tt> für die Antwort-Daten benutzen:
d1504 3
a1506 3
Denke daran, dass dieses Regelwerk jeglichen Netzwerk-Verkehr
mit Ausnahme von hereinkommendem HTTP- und SSH-Verkehr zur Bridge selbst und
den Maschinen "dahinter" verhindert. Andere Resultate werden erzielt,
d1510 4
a1513 3
Um die Bridge zu überwachen und zu kontrollieren, benutze das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>-Kommando,
mit dem man eine Bridge auch nach dem Booten erzeugen kann.
d1523 9
a1531 8
<li>Durch die Benutzung der <i>blocknonip</i> Option von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
oder in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>
kannst du jeglichen nicht-IP Traffic (wie etwa IPX oder NETBEUI) davon 
abhalten, sich um deine Filter herumzustehlen. Das kann in einigen Situationen
sehr wichtig sein, aber du solltest wissen, dass Bridges für jeglichen
Traffic funktionieren, nicht nur für IP.
d1533 2
a1534 2
<li>Für Bridging müssen die NICs im "Promiscuous mode" sein -- sie
lauschen einfach am GESAMTEN Netzwerk-Verkehr, nicht nur an dem, der
d1537 4
a1540 3
nicht sauber in diesem Modus, der TI ThunderLAN Chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
ist leider so ein Beispiel, der nicht als Teil einer Bridge funktioniert.
d1545 12
a1556 12
Das ,Preboot Execution Environment', oder PXE, ist ein Weg, um einen
Computer aus dem Netzwerk heraus zu booten, statt von Festplatte, Diskette
oder CD-ROM. Diese Technologie wurde zuerst von Intel entwickelt,
doch wird nun von den meisten führenden Netzwerkkarten- und
Computer-Herstellern unterstützt. Bedenke, dass es viele verschiedene
Netzwerkboot Protokolle gibt, PXE ist relativ neu.
Traditionellerweise wird das PXE Booting unter Verwendung von ROMs auf
dem NIC oder dem Mainboard ausgeführt, doch sind ebenfalls Bootdisketten
von etlichen Quellen verfügbar, die ebenfalls das PXE Booting zulassen.
Viele ROMs auf älteren NICs unterstützen zwar das Booten vom
Netzwerk aus, allerdings NICHT PXE; OpenBSD/i386 oder am64 können
mit diesen zurzeit nicht über das Netzwerk gebootet werden.
d1562 16
a1577 18
Zuallerst ist es klug zu verstehen, wie der
<a href="faq14.html#Boot386">OpenBSD Bootprozess</a> auf i386 und
am64 Plattformen funktioniert.
Auf den Bootprozess folgend, sendet die PXE-fähige NIC einen DHCP
Request über das Netzwerk.
Der DHCP Server wird dem Adapter eine IP zuweisen und gibt ihm den Namen
einer Datei, die von einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">tftp(1)</a>
Server bezogen und ausgeführt werden muss.
Diese Datei leitet dann den Rest des Bootprozesses ein.
Für OpenBSD ist es die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386">pxeboot</a>
Datei, die den Platz der standardmäßigen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
Datei einnimmt.
pxeboot(8) ist dann in der Lage, einen Kernel (wie zum Beispiel <tt>bsd</tt>
oder <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a> vom gleichen tftp(1)
Server zu laden und auszuführen.
d1582 5
a1586 6
Dokumente weisen darauf hin, dass alle modernen NICs und Computer PXE
Ünterstützung hätten, aber das ist einfach nicht wahr --
viele Niedrigpreis Systeme liefern keine PXE ROMs mit oder verwenden
ein älteres Netzwerkboot Protokoll.
Du brauchst außerdem einen ordentlich konfigurierten
<a href="#DHCP">DHCP</a> und TFTP Server.
d1589 4
a1592 4
Davon ausgehend, dass eine OpenBSD Maschine die Quelle der Bootdateien
ist, muss die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">dhcpd.conf</a>
Datei des DHCP Servers folgende Zeile beinhalten:
d1596 1
a1596 1
damit der DHCP Server diese Datei dem bootenden Arbeitsplatz anbietet.
d1615 3
a1617 3
Du musst außerdem den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)</a>
Daemon aktivieren. Dies wird normalerweise durch
d1620 1
a1620 1
Die standardmäßige OpenBSD Installation hat eine Beispielzeile in
d1626 1
a1626 1
von der lediglich das ,#' Zeichen entfernt werden muss und sende inetd(8)
d1628 6
a1633 7
geladen werden soll.
tftpd(8) bietet die Dateien von einem bestimmten Verzeichnis an, in dem
Fall von dieser Zeile ist es das <tt>/tftpboot</tt> Verzeichnis, welches
wir für dieses Beispiel verwenden werden.
Offensichtlich ist, dass dieses Verzeichnis angelegt und eingerichtet
werden muss. Typischerweise wirst du hier nur ein paar Dateien für das
PXE Booting haben:
d1636 7
a1642 6
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, der PXE Bootloader (der die gleichen Funktionen bereitstellt
wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> auf einem Platten-basierten System).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, der Installationskernel oder
d1644 3
a1646 2
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, eine Boot Konfigurationsdatei.
d1649 3
a1651 3
Denke daran, dass <tt>/etc/boot.conf</tt> nur gebraucht wird, wenn der Kernel,
den du booten möchtest, nicht <tt>bsd</tt> heißt oder andere
pxeboot Standardwerte nicht so sind, wie du sie haben möchtest
d1653 1
a1653 1
Du kannst deinen tftpd(8) Server mit einem
d1655 1
a1655 1
>tftp(1)</a> Client testen, indem du sicherstellst, dass du die
d1659 4
a1662 5
Wenn deine DHCP und TFTP Server laufen, bist du bereit, es auszuprobieren.
Du wirst PXE boot auf deinem System oder auf der Netzwerkkarte aktivieren
müssen; konsultiere deine Systemdokumentation.
Wenn du es gesetzt hast, solltest du etwas sehen, das diesem ähnlich
ist:
d1680 3
a1682 3
Zu diesem Zeitpunkt hast du den normalen OpenBSD Bootprompt.
Wenn du hier einfach "<tt>bsd.rd</tt>" eintippst, wirst du die Datei
<tt>bsd.rd</tt> von dem TFTP Server laden.
d1699 2
a1700 1
Der <a href="faq4.html#bsd.rd">bsd.rd Installationskernel</a> wird nun booten.
d2297 1
a2297 1
$Translation: faq6.html,v 1.126 2007/03/19 15:07:23 paldium Exp $<br>
@


1.105
log
@sync with Steelix CVS
@
text
@d34 1
a34 1
<li><a href= "#Setup" >6.2 - Erste Netzwerkeinrichtung</a>
d36 10
a45 6
  <li><a href="#Setup.1" >6.2.1 - Identifizieren und Einstellen deiner
    Netzwerkkarten</a>
  <li><a href="#Setup.2" >6.2.2 - Einrichten deines OpenBSD Rechners als
    Gateway</a>
  <li><a href="#Setup.3" >6.2.3 - Einrichten von Aliases auf deiner
    Netzwerkkarte</a>
d63 2
d106 8
a113 1
<h2>6.2 - Erste Netzwerkeinrichtung</h2>
d116 1
a116 1
<a name="Setup.1"></a>
d120 1
a120 2
Um beginnen zu können, musst du zunächst deine Netzwerkkarte
identifizieren können. Bei OpenBSD werden Netzwerkkarten nach ihrem
d143 5
d155 1
a155 1
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface, ein
d239 8
a246 5
Falls du deine Netzwerkkarte noch nicht konfiguriert hast, ist der erste Schritt
das Erstellen der <i>/etc/hostname.xxx</i> Datei, wobei der Name deiner Karte
den Platz von ,xxx' einnnimmt. Aus der Information der obigen Beispiele
würde der Name <i>/etc/hostname.fxp0</i> lauten. Das Layout dieser Datei
ist simpel:<br>
d252 4
a255 3
(Viel mehr Details zu dieser Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
Manual Seite.)
d267 6
d283 3
a285 1
Anforderungen hast, kannst du diese media Einstellungen einfach ignorieren.)
d294 1
a294 1
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
a296 17
<p>
Der nächste Schritt ist das Einstellen deines Standard-Gateways
(default gateway). Dazu trage einfach die IP deines Gateways in die Datei
<i>/etc/mygate</i> ein. Dies erlaubt das Aktivieren deines Gateways beim
Starten. Jetzt solltest du deine Nameserver eintragen und die Datei
<i>/etc/hosts</i> einrichten (siehe die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>-Manualseite).
Für die Nameserver benötigst du eine Datei namens
<i>/etc/resolv.conf</i>. Mehr über das Format dieser Datei findest du in
der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>
Manual Seite.
Wenn du DHCP einsetzt, solltest du <a href="#DHCP">6.4 - DHCP</a>
lesen und den Einsatz von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">resolv.conf.tail(5)</a>
in Erwägung ziehen. Aber hier folgt nun ein Beispiel für eine normale
Verwendung.
d298 24
a321 3
<p>
In diesem Beispiel sind deine Nameserver 125.2.3.4 und 125.2.3.5.
Du gehörst ebenfalls zur Domain ,example.com'.
a323 1
$ <strong>cat /etc/resolv.conf</strong>
d330 14
d345 19
d383 14
d439 2
a440 2
<a name="Setup.2"></a>
<h3>6.2.2 - Einrichten deines OpenBSD Rechners als Gateway</h3>
d492 2
a493 2
<a name="Setup.3"></a>
<h3>6.2.3 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>
d547 3
a562 1
<a name="NAT"></a>
d2143 113
d2270 2
a2271 2
Originally [OpenBSD: faq6.html,v 1.248 ]<br>
$Translation: faq6.html,v 1.125 2007/02/09 18:13:48 paldium Exp $<br>
@


1.104
log
@sync with steelix translation CVS
@
text
@d750 1
a750 1
dail&quot; setzen wir unsere Dialup Parameter, mit denen wir den Timeout,
d2077 1
a2077 1
$Translation: faq6.html,v 1.124 2006/11/01 09:15:01 paldium Exp $<br>
@


1.103
log
@sync with steelix translation CVS
@
text
@d1589 1
a1589 1
    OpenBSD 3.9 (RAMDISK_CD) #1025: Thu Mar  2 02:43:29 MST 2006
d1993 1
a1993 1
AMD 802.11 PCnet Mobile 
d1995 1
a1995 1
Aironet Communications 4500/4800
d1997 1
a1997 1
Prism2/2.5/3
d1999 1
a1999 1
ADMtek ADM8211
d2001 1
a2001 1
Treiber für Atheros IEEE 802.11a/b/g.
d2003 1
a2003 1
Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g.
d2005 1
a2005 1
Intel PRO/Wireless 2100 IEEE 802.11b.
d2010 1
a2010 1
Ralink Technology RT25x0 IEEE 802.11a/b/g.
d2012 11
a2022 1
Realtek 8180 IEEE 802.11b.
d2026 6
d2033 4
a2036 3
Netzwerkkarten genutzt werden, um ein OpenBSD System an ein existierendes
Wireless Netzwerk anzubinden (bitte siehe die Manual Seiten für
präzise Details).
d2043 11
a2062 20
Bedenke, dass du, um die Intel-basierten Karten nutzen zu können, die
Firmware-Dateien beziehen musst, welche Intel nicht für
<a href="faq1.html#ReallyFree">freie</a> Distribution zur Verfügung
stellet, wodurch sie nicht mit OpenBSD ausgeliefert werden können.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4#FILES">Kontaktiere
Intel</a>, um ihnen zu sagen, was du darüber denkst oder um ihnen
zu sagen, welches andere Produkt du stattdessen gekauft hast.

<p>
Andere Anbieter, wie zum Beispiel Broadcom, Texas Instruments und
Connexant, haben sich aktiv gegen unsere Versuche aufgelehnt, freie
Treiber für ihre Produkte zu entwicklen.
Wir bitten dich, ihre Wünsche zu akzeptieren, indem du ihre Produkte
nicht kaufst. Realtek, Ralink, Atmel und ADMtex erstellen gute Produkte
und unterstützen den Wunsch der Open-Source-Gemeinschaft nach freien
Treibern und haben sich somit unsere Unterstützung und das Geschäft
verdient.


<p>
d2076 2
a2077 2
Originally [OpenBSD: faq6.html,v 1.246 ]<br>
$Translation: faq6.html,v 1.123 2006/10/29 09:44:47 paldium Exp $<br>
@


1.102
log
@sync with Steelix CVS
@
text
@d1298 1
a1298 1
dhcp NONE NONE NONE NONE
d2068 2
a2069 2
Originally [OpenBSD: faq6.html,v 1.244 ]<br>
$Translation: faq6.html,v 1.122 2006/09/07 17:56:00 paldium Exp $<br>
@


1.101
log
@sync with steelix translation CVS
@
text
@d1911 6
a1916 5
Minuten falsch gehen, so wird *dringend* dazu geraten, sie zuerst genau
einzustellen, da es Tage oder sogar Wochen dauern kann, eine sehr ungenau
eingestellte Uhr zu synchronisieren. Du kannst dies tun, indem du
entweder die Option »<tt>-s</tt>« an ntpd(8) übergibst oder aber einen
anderen Weg findest, wie du deine Systemzeit richtig einstellen kannst.
d2069 1
a2069 1
$Translation: faq6.html,v 1.121 2006/08/23 13:20:59 paldium Exp $<br>
@


1.100
log
@sync with Steelix CVS
@
text
@d35 8
d46 4
d504 2
a505 1
<h3>6.4.1 DHCP-Client</h3>
d599 2
a600 1
<h3>6.4.2 DHCP-Server</h3>
d1904 5
a1908 4
Aktiviere ntpd(8) einfach durch <a href="faq10.html#rc">rc.conf.local</a>
und das Resultat wird sein, dass dein Computer sich selbst ständig mit den
<a href="http://www.pool.ntp.org/">pool.ntp.org</a> Servern synchronisiert,
einer Sammlung von öffentlich verfügbaren Zeit Servern.
d1913 3
a1915 6
eingestellte Uhr zu synchronisieren. Du kannst dies manuell mittels dem
Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=date&amp;sektion=1">date(1)</a>,
semiautomatisch unter Verwendung des Kommandos
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>
oder durch das manuelle Einstellen der Hardwareuhr deines PCs machen.
d1920 2
a1921 2
Es war nicht OpenNTPDs
<a href="http://www.openntpd.org/de/goals.html">Entwurfssziel</a>, es war
d1950 2
a1951 2
geht man davon aus, dass für 95% der anderen Anwender OpenNTPD mehr als
ausreichend sein wird.
d1958 28
d2067 2
a2068 2
Originally [OpenBSD: faq6.html,v 1.238 ]<br>
$Translation: faq6.html,v 1.120 2006/08/05 13:11:50 paldium Exp $<br>
@


1.99
log
@sync with steelix translation CVS
cvs: ----------------------------------------------------------------------
@
text
@d118 1
a118 1
Interface-Namen (wie z.B. fxp0).
d234 1
a234 1
Du solltest auch den ,media type' für Ethernet angeben, wenn du z.B. den
d387 1
a387 1
Möglichkeiten, OpenBSD als Router einzusetzen, z.B. mittels Software
d617 1
a617 1
anzuhängende Domäne example.com ist (d.h., wenn der Benutzer
d800 1
a800 1
Standardroute zu deren IP. Dies ist ,klebrig', d.h., falls deren IP sich
d1429 1
a1429 1
dem NIC oder dem Mainboard ausgeführt, doch sind ebenfalls Boot Floppies
d1636 1
a1636 1
immer Master wird wenn das möglich ist (z.B. wenn ein Host eine schnelle
d1737 1
a1737 1
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 255.255.255.0</b>
d1818 1
a1818 1
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 255.255.255.0</b>
d1826 2
a1827 1
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 192.168.0.7 255.255.255.0</b>
d2027 2
a2028 2
Originally [OpenBSD: faq6.html,v 1.237 ]<br>
$Translation: faq6.html,v 1.119 2006/05/31 19:00:24 paldium Exp $<br>
@


1.98
log
@sync with steelix translation CVS
@
text
@d1825 1
a1825 1
pris# <b>ifconfig create carp1</b>
d2026 2
a2027 2
Originally [OpenBSD: faq6.html,v 1.236 ]<br>
$Translation: faq6.html,v 1.118 2006/05/20 10:18:43 paldium Exp $<br>
@


1.97
log
@sync with steelix translation CVS
@
text
@d130 1
a130 1
$ <strong>ifconfig -a</strong>
d2026 2
a2027 2
Originally [OpenBSD: faq6.html,v 1.235 ]<br>
$Translation: faq6.html,v 1.117 2006/05/14 18:08:09 paldium Exp $<br>
@


1.96
log
@3.9 release time.
@
text
@d1062 1
a1062 1
muss laufen, damit NFS funktionieren kann. Portmap(8) ist ab OpenBSD 3.2 
d1071 6
a1076 1
einfügen und neustarten musst.
d1110 9
a1118 4
enthält. (Der GENERIC Kernel beinhaltet diese Optionen.) Dann 
solltest du die Zeile <tt>nfs_server=YES</tt> in
<i>/etc/rc.conf.local</i> einfügen. 
Dies wird sowohl nfsd(8) und mountd(8) starten, wenn du rebootest.
d2026 2
a2027 2
Originally [OpenBSD: faq6.html,v 1.234 ]<br>
$Translation: faq6.html,v 1.116 2006/05/01 11:17:11 paldium Exp $<br>
@


1.95
log
@sync with Steelix CVS
@
text
@d1007 16
d1563 1
a1563 1
    Copyright (c) 1995-2005 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1565 1
a1565 1
    OpenBSD 3.8 (RAMDISK_CD) #794: Sat Sep 10 15:58:32 MDT 2005
d2016 2
a2017 2
Originally [OpenBSD: faq6.html,v 1.233 ]<br>
$Translation: faq6.html,v 1.115 2006/04/24 17:44:29 paldium Exp $<br>
@


1.94
log
@sync with steelix translation CVS
@
text
@a5 1
<meta http-equiv="Content-Language" content="de">
d8 1
a8 1
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
d11 1
a11 1
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2006.">
d2000 2
a2001 2
Originally [OpenBSD: faq6.html,v 1.233 ]
$Translation: faq6.html,v 1.114 2006/03/23 14:12:59 paldium Exp $
@


1.93
log
@sync with Steelix CVS
@
text
@d1628 3
a1630 2
physikalischen Subnet befinden und jedes Interface benötigt eine reale,
statische IP Adresse zusätzlich zu einer statischen CARP IP Adresse.
d2001 2
a2002 2
Originally [OpenBSD: faq6.html,v 1.232 ]
$Translation: faq6.html,v 1.113 2006/03/09 13:22:37 paldium Exp $
@


1.92
log
@sync with steelix translation CVS
@
text
@d12 1
a12 1
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2005.">
d2000 2
a2001 2
Originally [OpenBSD: faq6.html,v 1.231 ]
$Translation: faq6.html,v 1.112 2006/01/13 21:58:47 paldium Exp $
@


1.91
log
@sync with Steelix CVS
@
text
@d34 2
a35 2
<li><a href= "#Intro" >6.1 - Bevor wir weiter gehen</a>
<li><a href= "#Setup" >6.2 - Erste Netzwerkeinstellungen</a>
d37 4
a40 4
                             Firewall aufsetzen?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic Host Configuration Protokoll (DHCP)</a>
<li><a href= "#PPP"   >6.5 - Point to Point Protokoll (PPP)</a>
<li><a href= "#Tuning">6.6 - Netzwerkparameter tunen</a>
d44 1
a44 1
<li><a href= "#CARP">6.11 - Das Common Address Redundancy Protokoll (CARP)</a>
d46 2
a47 1
<li><a href="#Wireless">6.13 - Was sind meine Wireless Netzwerk Optionen?</a>
d54 1
a54 1
<h2>6.1 - Bevor wir weiter gehen</h2>
d89 1
a89 1
<h2>6.2 - Erste Netzwerkeinstellungen</h2>
d289 1
a289 1
Skript ausführen, indem du (als root) folgendes eingibst:
d484 1
a484 1
<h2>6.4 - Dynamic Host Configuration Protokoll (DHCP)</h2> 
d493 1
a493 1
<h3>6.4.1 DHCP Client</h3>
d496 1
a496 1
Um den DHCP Client
d587 1
a587 1
<h3>6.4.2 DHCP Server</h3>
d590 1
a590 1
Wenn du OpenBSD als DHCP Server 
d946 2
a947 2
größere Anzahl von Neuversuchen und längeren timeouts für
TCP Sitzungen hat?</h3>
d1011 1
a1011 1
<h2>6.7 - Einfache NFS Anleitung</h2>
d1127 1
a1127 1
<h3>NFS Status überprüfen</h3>
d1163 1
a1163 1
<h3>NFS Dateisysteme mounten</h3>
d1227 1
a1227 1
<h3>Ein Beispiel einer Bridge Anwendung</h3>
d1413 1
a1413 1
<h3>Wie funktioniert das PXE Booting?</h3>
d1565 1
a1565 1
<h2>6.11 - Das Common Address Redundancy Protokoll (CARP)</h2>
d1730 1
a1730 1
Mache das gleiche auf <i>pris</i>. Welches System von beiden das CARP
d1781 1
a1781 1
<h3>6.11.3 - Load Balancing</h3>
d1920 2
a1921 1
<h2>6.13 - Was sind meine Wireless Netzwerk Optionen?</h2>
d2001 1
a2001 1
$Translation: faq6.html,v 1.111 2005/12/06 20:37:27 paldium Exp $
@


1.90
log
@sync with Steelix CVS
@
text
@d1407 1
a1407 1
mit diesen zur Zeit nicht über das Netzwerk gebootet werden.
d1560 1
a1560 1
Ja, obwohl mit den Programmen, die zur Zeit in OpenBSD enthalten sind,
d1999 1
a1999 1
$Translation: faq6.html,v 1.110 2005/11/24 14:01:40 paldium Exp $
@


1.89
log
@sync with steelix translation CVS
@
text
@d933 2
a934 2
pptp selbst muss von den <a href="faq8.html#Ports">Ports</a> oder
<a href="faq8.html#Packages">Packages</a> aus installiert werden.
d1843 1
a1843 1
entwickelt, verfügbar durch <a href="faq8.html#Ports">Ports</a>,
d1998 2
a1999 2
Originally [OpenBSD: faq6.html,v 1.230 ]
$Translation: faq6.html,v 1.109 2005/11/04 14:03:55 paldium Exp $
@


1.88
log
@sync with Steelix CVS
@
text
@d920 1
a920 1
wurde in OpenBSD 3.7 eingebunden.
d1549 1
a1549 1
    OpenBSD 3.7 (RAMDISK_CD) #573: Sun Mar 20 00:27:05 MST 2005
d1560 2
a1561 2
Ja, obwohl mit den Programmen, die zur Zeit in OpenBSD 3.7 enthalten sind,
PXE Booting primär zum Installieren des OS gedacht ist.
d1863 1
a1863 1
und das Resultat wird sein, dass dein Computer sich selbst mit den
d1867 9
a1875 1
sehr hohen Genauigkeitsgrad halten.
a1918 1
<!-- XXX remove "new" for 3.8 -->
d1930 1
a1930 1
<li><i>New</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
d1932 1
a1932 1
<li><i>New</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
d1934 1
a1934 1
<li><i>New</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
d1936 1
a1936 1
<li><i>New</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
d1938 1
a1938 1
<li><i>New</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
d1941 1
a1941 1
<li><i>New</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
d1998 2
a1999 2
Originally [OpenBSD: faq6.html,v 1.227 ]
$Translation: faq6.html,v 1.108 2005/10/30 11:18:54 paldium Exp $
@


1.87
log
@sync with Steelix CVS
@
text
@d1991 2
a1992 2
Originally [OpenBSD: faq6.html,v 1.226 ]
$Translation: faq6.html,v 1.107 2005/10/29 10:44:52 paldium Exp $
@


1.86
log
@sync with Steelix CVS
@
text
@d23 3
a25 3
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Source-Code erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirm-Kontrollen]</a>
d1979 3
a1981 3
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Source-Code erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirm-Kontrollen]</a>
d1992 1
a1992 1
$Translation: faq6.html,v 1.106 2005/10/14 13:20:18 paldium Exp $
@


1.85
log
@sync with Steelix CVS
@
text
@d1971 4
a1974 4
nicht kaufst. Realtek, Ralink, Atmel, ADMtex und Atheros erstellen
gute Produkte und unterstützen den Wunsch der Open-Source-Gemeinschaft
nach freien Treibern und haben sich somit unsere Unterstützung und
das Geschäft verdient.
d1991 2
a1992 2
Originally [OpenBSD: faq6.html,v 1.225 ]
$Translation: faq6.html,v 1.105 2005/09/01 17:18:20 paldium Exp $
@


1.84
log
@sync with Steelix CVS
@
text
@d6 1
d9 4
a12 5
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content="Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content="openbsd,faq">
<meta name= "distribution"  content="global">
<meta name= "copyright"     content="This document copyright 1998-2005 by OpenBSD.">
d478 1
a478 1
Er wird im <a href="../pf/index.html"><b>PF Benutzerhandbuch</b></a>
d1072 1
a1072 1
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
d1991 2
a1992 2
Originally [OpenBSD: faq6.html,v 1.224 ]
$Translation: faq6.html,v 1.104 2005/08/11 17:41:38 paldium Exp $
@


1.83
log
@sync with Steelix CVS
@
text
@d851 7
a857 10
Mit dem Aufruf von <i>/usr/sbin/ppp</i> ohne Optionen kommst du in den
interaktiven Modus. Hier kannst du direkt mit dem Modem interagieren; das
eignet sich hervorragend, um Probleme in deiner <i>ppp.conf</i> Datei zu
debuggen.
Wenn das oben genannte fehlschlägt, versuche, <i>/usr/sbin/ppp</i> ohne
Optionen aufzurufen - somit wird ppp im interaktiven Modus gestartet.
Die Optionen können einzeln angegeben werden, um nach Fehlern oder anderen
Problemen zu suchen. Unter Verwendung der zuvor genannten Einstellungen,
wird ppp in /var/log/ppp.log schreiben. Diese Log enthält, wie die
Manual-Seite, hilfreiche Informationen.
d919 1
d1723 5
d1991 2
a1992 2
Originally [OpenBSD: faq6.html,v 1.223 ]
$Translation: faq6.html,v 1.101 2005/06/09 16:30:09 paldium Exp $
@


1.82
log
@sync with Steelix CVS
@
text
@d410 1
a410 1
Skript gelesen, das ein Teil der <a href="../faq10.html#rc">rc startup
d637 1
a637 1
Die OpenBSD <a href="../faq10.html#rc">Startup Skripte</a> erstellen diese
d1859 1
a1859 1
Aktiviere ntpd(8) einfach durch <a href="../faq10.html#rc">rc.conf.local</a>
d1989 1
a1989 1
$Translation: faq6.html,v 1.100 2005/06/08 17:04:49 paldium Exp $
@


1.81
log
@sync with Steelix CVS
@
text
@d1682 3
a1684 4
Zwei von den vier CARP-spezifischen Befehlen, <tt>advbase</tt> und
<tt>advskew</tt>, befassen sich mit dem Intervall zwischen CARP
Bekündungen.
Die Formel (in Sekunden) ist <tt>advskew</tt> dividiert durch 255 und dann
d1698 6
d1711 2
a1712 1
rachael# <b>ifconfig carp0 vhid 1 pass tyrell 192.168.0.7</b>
d1716 2
a1717 1
das <i>tyrell</i> lautet und die IP Adresse 192.168.0.7.
d1722 1
a1722 1
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell
d1727 3
a1729 5
Interface zu erst aufsetzt wird Master.

<p>
Bedenke, dass auf einer Maschine mit mehreren Interfaces das CARP Interface
im gleichen Subnet des physikalischen Interfaces liegt.
d1787 2
a1788 1
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant 192.168.0.7</b>
d1796 1
a1796 1
pris# <b>ifconfig carp1 vhid 2 pass bryant 192.168.0.7</b>
d1988 2
a1989 2
Originally [OpenBSD: faq6.html,v 1.222 ]
$Translation: faq6.html,v 1.99 2005/05/29 12:21:53 paldium Exp $
@


1.80
log
@sync with Steelix CVS
@
text
@d78 1
a78 1
könntest du viel <a href="http://the.rfc-editor.org/rfc.html">vom
d91 1
a91 1
<a name= "Setup.1"></a>
d130 1
a130 1
$ <b>ifconfig -a</b>
d261 6
a266 4
<i>/etc/hosts</i> einrichten. Für die Nameserver benötigst du eine
Datei namens <i>/etc/resolv.conf</i>. Mehr über das Format dieser
Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>
d401 1
a401 1
<a name= "Setup.3"></a>
d590 1
a590 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8">dhcpd(8)</a>
d640 2
d644 1
a644 1
Wenn du DHCP Dienste für einen Windows Rechner bereitstellst, dann willst 
d646 1
a646 1
Dafür füge einfach die folgenden Zeilen zu deiner /etc/dhcpd.conf:
d669 1
a669 1
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8">pppd(8)</a>
d671 1
a671 1
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
d730 1
a730 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
d802 1
a802 1
&quot;enable dns&quit; teilen wir unserem ISP mit, unsere Nameserveradresse
d941 1
a941 1
<a name= "Tuning"></a>
d991 1
a991 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
d1020 3
a1022 3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
d1041 1
a1041 1
Dateisystem zu /etc/exports ohne eine Liste mit Rechnern, die explizit
d1066 1
a1066 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
d1078 3
a1080 3
D.h., dass das lokale Dateisystem <b>/work</b> via NFS zugänglich 
gemacht wird. <b>-alldirs</b> bedeutet, dass Clients jedes Verzeichnis 
unter dem <b>/work</b> Mount Point mounten können. <b>-ro</b> bedeutet,  
d1092 1
a1092 1
solltest du die Zeile <strong>nfs_server=YES</strong> in
d1152 1
a1152 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8">showmount(8)</a>
d1167 1
a1167 1
NFS Dateisysteme sollten mittels mount(8) geladen werden, oder genauer
d1169 4
a1172 4
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8">mount_nfs(8)</a>.
Um ein Dateisystem /work von Host 10.0.0.1 auf dem lokalen Dateisystem /mnt 
zu laden, tue folgendes (bedenke, dass du nicht IP Adressen verwenden musst,
mount wird Hostnamen auflösen):
d1342 1
a1342 1
indem wir ,keep state' für die Antwort-Daten benutzen:
d1367 2
a1368 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
Kommando, mit dem man eine Bridge auch nach dem Booten erzeugen kann.
d1379 1
a1379 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
d1381 1
a1381 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&sektion=5">bridgename.bridge0</a>
d1392 1
a1392 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&sektion=4">tl(4)</a>)
d1903 1
a1903 1
<h3>6.13 - Was sind meine Wireless Netzwerk Optionen?</h3>
d1969 1
a1969 1
<font color= "#0000e0">
d1983 1
a1983 1
$Translation: faq6.html,v 1.98 2005/05/24 11:37:33 paldium Exp $
@


1.79
log
@sync with steelix translation CVS
@
text
@d1949 1
a1949 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&sektion=4#FILES">Kontaktiere
d1978 2
a1979 2
Originally [OpenBSD: faq6.html,v 1.221 ]
$Translation: faq6.html,v 1.97 2005/05/20 10:58:58 paldium Exp $
@


1.78
log
@sync with Steelix CVS
@
text
@d918 1
a918 4
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)</a>,
wurde in OpenBSD -current eingebunden; jedoch wird diese für
Nicht-current-Benutzer nicht bis OpenBSD 3.7 verfügbar sein.
<!-- XXXrelease -->
d1545 1
a1545 1
    Copyright (c) 1995-2004 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1547 1
a1547 1
    OpenBSD 3.6 (RAMDISK_CD) #378: Fri Sep 17 13:04:04 MDT 2004
d1558 1
a1558 1
Ja, obwohl mit den Programmen, die zur Zeit in OpenBSD 3.6 enthalten sind,
d1724 1
a1724 1
Aber lass uns sagen du setzt nicht von Anfang an auf.
d1727 6
a1732 6
Glücklicherweise hat CARP kein Problem mit einem System, das eine
IP als physikalische Interface Adresse und in einer CARP Gruppe besitzt,
so dass kein Grund besteht die vorherigen Befehle zu ändern.
Trotz allem tendiert es dazu sauberer zu sein jeweils eine IP für jedes
System zu haben -- es macht individuelle Überwachungen und Zugriffe
viel einfacher.
a1852 11
<!-- XXXversion 3.6 only -->
Wenn deine Uhr auf deinem Computer sehr falsch geht, solltest du sie zuerst
so genau wie möglichen einstellen, möglicherweise unter Verwendung
von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>,
da ntpd(8) deine Uhr nur SEHR langsam durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adjtime&amp;sektion=2">adjtime(2)</a>
angleicht
-- es kann <i>mehrere Stunden</i> dauern (oder Tage oder sogar noch länger) um
eine sehr ungenau eingestellte Uhr zu synchronisieren (<i>-current</i> wird
unmittelbar nach dem Boot die Uhr setzen).
d1898 1
d1900 1
a1900 1
OpenBSD hat für ein paar Wireless Chipsätze Unterstützung:
d1910 14
d1930 2
a1931 2
Die Prism2 und Prism3-basierenden Karten können jedoch auch in dem
"Host-Based Access Point" Modus genutzt werden, das ihnen erlaubt, in deinen
d1933 1
a1933 22
zu werden. Unglücklicherweise werden die Prism2/3-basierenden
Netzwerkkarten nicht mehr von den meisten der "Massenmarkt" Herstellern
produziert, da sie auf die günstigeren und neuen Chips wechselten, oft,
<a href="#GenSupport">ohne die Modellnummer gewechselt zu haben</a>.
Die meisten der Hersteller von neuen Chips haben entschieden, keine
Dokumentation zu veröffentlichen, die für die Entwicklung von
freien und offenen Treibern für diese Devices benötigt werden
(Wenn du möchtest, kannst du die Hersteller kontaktieren und sie
darum bitten, ihre Richtlinien zu ändern).

<p>
Zum Glück sind Prism2/3-basierende Karten weiterhin durch den
Gebrauchthandel verfügbar und ein paar Hersteller verstehen den Wert
eines ordentlich dokumentierten, Open-Source freundlichen Chipsatzes und
setzen die professionelle Produktion von Prism-basierenden Karten fort.
Ein Verkäufer dieser Karten ist
<a href="http://www.netgate.com">Netgate.com</a>.
Wenn ein Hersteller nicht ausdrücklich ein aktuelles Produkt als
Prism-basierend kennzeichnet, kann man normalerweise davon ausgehen, dass
es nicht mit dem wi(4) Treiber kompatibel sein wird.
Bedenke, dass die neuesten Prism-Serien Chips (wie zum Beispiel Prism-GT)
nicht unterstützt werden.
d1944 19
d1978 2
a1979 2
Originally [OpenBSD: faq6.html,v 1.220 ]
$Translation: faq6.html,v 1.96 2005/05/14 20:00:52 paldium Exp $
@


1.77
log
@sync with OpenBSD CVS
@
text
@d1174 1
a1174 1
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
d1182 1
a1182 1
10.0.0.1:/work /mnt nfs rw 0 0
d1193 1
a1193 1
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
d1979 2
a1980 2
Originally [OpenBSD: faq6.html,v 1.219 ]
$Translation: faq6.html,v 1.95 2005/04/19 13:54:41 paldium Exp $
@


1.76
log
@sync with Steelix CVS
@
text
@d212 1
a212 1
den Platz von xxx einnnimmt. Aus der Information der obigen Beispiele
d265 10
a274 3
Manual Seite. Für den Normalgebrauch ist hier ein Beispiel, in dem
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du gehörst zur Domain
&quot;example.com&quot;.
d495 4
a498 4
zu benutzen, der Teil von OpenBSD ist, editiere <tt>/etc/hostname.xl0</tt>
(wenn deine Hauptethernetkarte xl0 ist. Deine kann ep0 oder fxp0 oder 
irgendeine andere sein!). 
Alles, was du in dieser Datei zu schreiben hast, ist '<tt>dhcp</tt>'.
d500 3
a502 3
<pre>
# <b>echo dhcp &gt;/etc/dhcpd.interfaces</b>
</pre>
d513 3
a515 3
<pre>
# <strong>dhclient fxp0</strong>
</pre>
d521 1
a521 1
Wie du auch immer dhclient startest, kannst du die <tt>/etc/dhclient.conf</tt>
d527 1
a527 1
<pre>
d530 33
a562 1
</pre>
d565 17
a581 2
und dann <b>entferne</b> domain-name-servers.  Natürlich kannst du auch 
hostname oder andere Einstellungen entfernen.
d946 1
a946 1
größe Anzahl an Neuversuchen und längeren timeouts für
d1098 1
a1098 1
Du solltest eine angemessenene Anzahl an NFS Serverdiensten einsetzen, um 
d1898 1
a1898 1
Anzahl an Leuten einfacher, diese zu nutzen.
d1979 2
a1980 2
Originally [OpenBSD: faq6.html,v 1.218 ]
$Translation: faq6.html,v 1.94 2005/03/22 14:15:03 paldium Exp $
@


1.75
log
@sync with Steelix CVS
@
text
@d1830 3
a1832 3
Das wird wahrscheinlich
<a href="http://bradknowles.typepad.com/considered_harmful/2004/09/openntpd.html">Brad
Knowles</a> gewesen sein.
d1925 2
a1926 2
Originally [OpenBSD: faq6.html,v 1.217 ]
$Translation: faq6.html,v 1.93 2005/03/17 20:46:30 paldium Exp $
@


1.74
log
@Sync with Steelix CVS
@
text
@d880 1
a880 1
pptp selbst muss von den <a href="../faq8.html#Ports">Ports</a> oder
d1779 1
a1779 1
entwickelt, verfügbar durch <a href="../faq8.html#Ports">Ports</a>,
d1926 1
a1926 1
$Translation: faq6.html,v 1.92 2005/02/04 09:04:12 paldium Exp $
@


1.73
log
@sync with Steelix CVS
@
text
@d12 1
a12 1
<meta name= "copyright"     content="This document copyright 1998-2004 by OpenBSD.">
d379 10
a388 6
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>
und <a href="http://www.zebra.org">zebra</a>.
OpenBSD hat Unterstützung
in der Ports Kollektion sowohl für gated, zebra als auch mrtd. OpenBSD
unterstützt mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP)
d400 1
a400 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a>
d1925 2
a1926 2
Originally [OpenBSD: faq6.html,v 1.214 ]
$Translation: faq6.html,v 1.90 2005/01/23 19:52:51 paldium Exp $
@


1.72
log
@Sync with Steelix CVS
@
text
@d253 1
a253 1
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
d392 1
a392 1
OpenBSD hat einen einfachen Mechanismus, um IP Aliase für deine
d507 1
a507 1
Wobei ,<tt>fxp0</tt>' die Netzwerkkarte ist, auf der du dhcp empfangen willst.
d680 1
a680 1
Wir tun dies, indem wir unter <b>default:</b> einen weiteren Absatz
d682 1
a682 1
nimmst du den Namen deines ISP. Hier werde ich <b>myisp:</b> als Verweis
d1281 3
a1283 3
In diesem Fall lassen wir jeglichen Verkehr nach draußen zu, filtern aber
auf dem fxp0 Interface, indem wir ,keep state' für die Antwort-Daten
benutzen:
d1692 1
a1692 1
rachael# <strong>sysctl net.inet.carp.preempt=1</strong>
d1698 1
a1698 1
pris# <strong>ifconfig carp0 advskew 100</strong>
d1722 2
a1723 3
rachael# <strong>ifconfig carp1 create</strong>
rachael# <strong>ifconfig carp1 vhid 2 advskew 100 pass bryant
192.168.0.7</strong>
d1730 3
a1732 3
pris# <strong>ifconfig create carp1</strong>
pris# <strong>ifconfig carp1 vhid 2 pass bryant 192.168.0.7</strong>
pris# <strong>sysctl net.inet.carp.preempt=1</strong>
d1921 2
a1922 2
Originally [OpenBSD: faq6.html,v 1.212 ]
$Translation: faq6.html,v 1.89 2005/01/18 14:33:45 paldium Exp $
@


1.71
log
@Sync with Steelix CVS
@
text
@d9 1
a9 1
<meta name= "description"   content="Die OpenBSD FAQ Seite">
d1921 5
a1925 3
Originally [OpenBSD: faq6.html,v 1.212 ]<br>
$Translation: faq6.html,v 1.88 2005/01/12 21:16:17 paldium Exp $<br>
$OpenBSD: faq6.html,v 1.212 2005/01/06 02:23:31 nick Exp $
@


1.70
log
@Sync with Steelix CVS
@
text
@d490 1
a490 1
# <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
d1922 1
a1922 1
$Translation: faq6.html,v 1.87 2005/01/06 11:26:41 paldium Exp $<br>
@


1.69
log
@Sync with Steelix CVS
@
text
@a41 1
<li><a href= "#PPTP"  >6.8 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
d801 1
a801 1
<h3>ppp(8) Extras</h3>
d816 66
a1143 117
<p>
<a name= "PPTP"></a>
<h2>6.8 - Eine PPTP Verbindung mit OpenBSD aufsetzen</h2>

<p>
<strong>HINWEIS:</strong> Dies bezieht sich nicht auf <strong>ALLE</strong>
ADSL Provider, aber viele der Informationen können aus diesem Setup 
übernommen werden. Dieses Setup funktioniert auf jeden Fall bei
<a href="http://www.inode.at">Inode</a>, einem ADSL Provider in
Österreich und <a href="http://www.kpn.nl">KPN</a> in den Niederlanden.

<p>
Um anzufangen, musst du pptp installiert haben. Der Port befindet sich unter
<i>/usr/ports/net/pptp</i>. Lies <a href="../faq8.html#Ports">FAQ 8, 
Ports</a> um mehr Informationen über den OpenBSD Ports Tree zu 
bekommen.

<p>
Obwohl es nicht direkt ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre(4)</a>
Device verwendet, benutzt PPTP GRE ,encapsulation'. Um dem Kernel zu
erlauben, eingehende GREP ,encapsulated' Pakete zu akzeptieren, führe
den folgenden Befehl aus:
<blockquote><pre>
# sysctl net.inet.gre.allow=1
</pre></blockquote>
Und füge folgende Zeile in deine <i>/etc/sysctl.conf</i> Datei ein:
<blockquote><pre>
net.inet.gre.allow=1
</blockquote></pre>
das die zuvor genannte Änderung bei jedem Hochfahren wieder
durchführt.

<p>
Nachdem du das <b>pptp</b> Package installiert und <i>/etc/sysctl.conf</i>
editiert hast, musst du ein paar Dateien für deine neue Verbindung editieren.
Diese Packages benutzen das standarmäßige OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>,
wenn du dich also mit ppp(8) auskennst, kommt dir vieles bekannt vor. 
Siehe auch <a href="#PPP">FAQ 6, PPP</a>.

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
Für die <i>/etc/ppp/options</i> Datei wird ein Setup, wie das unten,
vermutlich alles notwendige tun:

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
<tt>LOGINNAME</tt> sollte mit deiner User-ID ersetzt werden.

<p>
In <i>/etc/ppp/pap-secrets</i> gehört eine Zeile wie diese hier:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
Wobei LOGINNAME deine User-ID und PASSWORD dein Passwort ist. 10.0.0.138 ist
die zugewiesene IP deines Modems im Falle, dass du ADSL nutzt, etc. 
Stelle sicher, dass diese Datei nur von root gelesen werden kann (mode 600).

<p>
<h3>6.8.1 - Deinem Netzwerk Interface eine Adresse zuweisen</h3>

<p>
Im obigen Beispiel hatte unser Modem eine vorkonfigurierte Adresse von
10.0.0.138. Jetzt müssen wir UNSEREM Interface noch eine Adresse zuweisen.
Es ist am besten eine IP zu wählen, die nahe an der deines MODEMS liegt,
oder einfach die statische Adresse zu benutzen, die dir zugewiesen wurde.
Mehr darüber, wie man Interfaces IP-Adressen zuweist, kannst du in
<a href="#Setup">FAQ 6, Setup</a> lesen.

<p>
Wenn dein Interface eingerichtet ist, solltest du mit folgendem Befehl
eine pptp Verbindung aufbauen können:

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

<p>
Da hier auch der ,in-house' OpenBSD ppp(8) benutzt wird, werden hier zwei
Prozesse gestartet. Du kannst pptp beenden, indem du diese beiden Prozesse
killst:

<blockquote><pre>
# <strong>kill -9 [pid of pppd]</strong>
$ <strong>kill -9 [pid of pptp]</strong>
</pre></blockquote>

<p>
Es wird empfohlen, <tt>/var/log/messages</tt> in einem weiteren Terminalfenster
zu öffnen, um mögliche Probleme zu erkennen.

<blockquote>
<pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>

<p>
Wir schlagen vor, die Startsequenz in <i>/etc/rc.local</i> unterzubringen,
so dass bei jedem Neustart die Verbindung automatisch aufgebaut wird.

d1921 3
a1923 3
Originally [OpenBSD: faq6.html,v 1.210 ]<br>
$Translation: faq6.html,v 1.85 2004/12/25 20:31:01 paldium Exp $<br>
$OpenBSD: faq6.html,v 1.210 2004/12/25 04:14:39 nick Exp $
@


1.68
log
@Sync with Steelix CVS
@
text
@d1894 1
a1894 1
Wenn das "schädlich" ist, stimmen wir dem voll überein.
d1897 1
a1897 1
Es gibt einige Anwendungen, bei denen ntp.org ntpd genauer ist, trotzdem
d1973 3
a1975 3
Originally [OpenBSD: faq6.html,v 1.209 ]<br>
$Translation: faq6.html,v 1.84 2004/12/22 12:29:53 paldium Exp $<br>
$OpenBSD: faq6.html,v 1.209 2004/12/22 02:27:16 nick Exp $
@


1.67
log
@sync with Steelix CVS
@
text
@d1901 5
d1973 3
a1975 4
<br>
Originally [OpenBSD: faq6.html,v 1.208 ]
<br>
$Translation: faq6.html,v 1.83 2004/12/10 12:12:12 paldium Exp $
a1976 2
<br>
<small>$OpenBSD: faq6.html,v 1.207 2004/12/10 10:33:42 jmc Exp $</small>
@


1.66
log
@Sync with Steelix CVS, all work by Tobias Stoeckmann
@
text
@d605 1
a605 1
mit deinem Modem herzustellen. OpenBSD bietet dafür 2 Möglichkeiten.
d615 11
a625 3
Die erste, den wir behandeln, wird der Userland PPP Daemon sein. Um zu 
beginnen, benötigen wir einige einfache Informationen über deinen
ISP. Hier eine Liste hilfreicher Informationen, die du brauchen wirst.
d628 1
a628 1
<li>Die Einwahlnummer deines ISP
d636 1
a636 1
hilfreich. Der Userland PPP Daemon benutzt die Datei 
a643 8
Solltest du keinen GENERIC Kernel verwenden, dann stelle sicher, dass du
folgende Zeile in deiner Kernelkonfigurationsdatei hast:

<blockquote><pre><strong>
pseudo-device   tun
</strong></pre></blockquote>

<p>
d673 2
a674 2
Daher wird COM Port 1 auf /dev/cua00 gesetzt. Mit &quot;set speed&quot;
setzen wir die Geschwindigkeit unserer Dialup Verbindung und mit &quot;set
d701 1
a701 1
Die erste Option &quot;set phone&quot; setzt die Telefonnummer deines ISP.
d747 27
d794 6
a816 6
Weitere Informationen findest du im
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD
Handbucheintrag zum Thema User PPP</a>.


<p>
d1969 1
a1969 1
Originally [OpenBSD: faq6.html,v 1.207 ]
d1971 1
a1971 1
$Translation: faq6.html,v 1.82 2004/12/03 15:43:35 paldium Exp $
d1974 1
a1974 1
<small>$OpenBSD: faq6.html,v 1.207 2004/12/03 03:35:16 nick Exp $</small>
@


1.65
log
@Sync with Steelix CVS
@
text
@d1829 1
a1829 1
da ntpd(8) deine Uhr nur langsam durch
d1832 2
a1833 2
-- es kann Stunden dauern (oder Tage oder sogar noch länger) um eine
sehr ungenau eingestellte Uhr zu synchronisieren (<i>-current</i> wird
d1942 1
a1942 1
Originally [OpenBSD: faq6.html,v 1.206 ]
d1944 1
a1944 1
$Translation: faq6.html,v 1.81 2004/11/21 13:41:01 paldium Exp $
d1947 1
a1947 1
<small>$OpenBSD: faq6.html,v 1.206 2004/11/20 22:08:39 nick Exp $</small>
@


1.64
log
@Sync with Steelix CVS
@
text
@d533 1
a533 1
es die Zeile <tt>dhcpd_flags="-q"</tt> beinhaltet.
d1942 1
a1942 1
Originally [OpenBSD: faq6.html,v 1.204 ]
d1944 1
a1944 1
$Translation: faq6.html,v 1.80 2004/11/17 18:27:13 paldium Exp $
d1947 1
a1947 1
<small>$OpenBSD: faq6.html,v 1.203 2004/11/10 17:04:37 nick Exp $</small>
@


1.63
log
@Sync with Steelix CVS
@
text
@d38 2
a39 3
<li><a href= "#DHCP"  >6.4 - DHCP - Dynamic Host Configuration
                             Protokoll</a>
<li><a href= "#PPP"   >6.5 - PPP - Point to Point Protokoll</a>
d471 1
a471 1
<h2>6.4 - DHCP</h2> 
d601 1
a601 1
<h2>6.5 - PPP </h2>
d1944 1
a1944 1
$Translation: faq6.html,v 1.79 2004/11/12 18:20:14 paldium Exp $
@


1.62
log
@Sync with Steelix CVS
@
text
@a48 1

d68 1
a68 1
Wenn du ein Netzwerkadministrator bist und Routingprotokolle aufsetzt
d71 2
a72 2
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP addressing</a> vertiefen.
d105 2
a106 2
deine Karte überprüfen. Als Beispiel hier die Ausgabe in
dmesg für eine Intel Fast Ethernet Netzwerk-Karte, die als 
d115 1
a115 1
Wenn du deinen Geräte-Namen nicht weißt, sieh bitte in der 
d120 1
a120 1
Interface Namen (wie z.B. fxp0).
d127 2
a128 2
Das folgende Kommando zeigt uns alle Netzwerk-Interfaces im System.
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface, eine 
d212 2
a213 2
Falls du deine Netzwerkkarte noch nicht konfiguriert hast, ist der 1. Schritt
das Erstellen der <b>/etc/hostname.xxx</b> Datei, wobei der Name deiner Karte
d223 2
a224 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a> Manual Seite.)
d231 2
a232 2
$ <b>cat /etc/hostname.fxp0
</b>inet 10.0.0.38 255.255.255.0 NONE
d246 1
a246 1
Anforderungen hast, kannst du diese media settings einfach ignorieren.)
d249 1
a249 1
Oder vielleicht willst du auch spezielle flags für ein einzelnes 
d260 1
a260 1
(default gateway). Dazu trag einfach die IP deines Gateways in die Datei
d264 1
a264 1
eine Datei namens <i>/etc/resolv.conf</i>. Mehr über das Format dieser
d280 2
a281 2
Jetzt kannst du entweder rebooten oder das <b>/etc/netstart</b> Script
ausführen, indem du (als root) folgendes eingibst:
d284 2
a285 2
# <b>sh /etc/netstart
</b>writing to routing socket: File exists
d294 1
a294 1
konfiguriert sind. Daher existieren bereits bereits einige der Routen in der
d299 1
a299 1
Deine Routen kannst via
d345 1
a345 1
Dies sind nur die grundlegende Informationen, um deinen OpenBSD Rechner als
d356 1
a356 1
aber dies muß erst eingeschaltet werden. Du solltest dies mit 
d358 1
a358 1
tun. Um diese Änderung permanent einzutragen, mußt du die Datei
d370 1
a370 1
durchführen. Beachte aber, daß diese Änderung nach einem Reboot
d380 1
a380 1
Möglichkeiten, OpenBSD als Router einzusetzen, z. B. mittels Software
d382 1
a382 1
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, 
d385 1
a385 1
in der ports Kollektion sowohl für gated, zebra als auch mrtd. OpenBSD
d395 1
a395 1
Netzwerk-Karten zu setzen. Dazu musst du einfach die Datei
d400 2
a401 2
Hierarchie</a> ist. Für dieses Beispiel nehmen wir an, der User hat ein
Interface <b>dc0</b> und befindet sich im Netzwerk 192.168.0.0. Weitere
d412 1
a412 1
Daher muß man sie nicht - wie in einigen anderen Betriebssystemen - 
d436 1
a436 1
um die Änderung automatisch durchführen. Du kannst aber auch
d474 6
d502 1
a502 1
dass /etc/dhclient.conf existiert, dann versuche:
d509 1
a509 1
Wobei fxp0 die Netzwerkkarte ist, auf der du DHCP empfangen willst.
d512 2
a513 2
Wie du auch immer dhclient startest, du kannst die /etc/dhclient.conf Datei 
immer so editieren, daß dein DNS <b>nicht</b> erneuert wird aufgrund 
d515 2
a516 2
(Es gibt Beispiele in den Standardeinstellungen, aber du mußt die 
Standardeinstellungen von dhclient überschreiben.). 
d558 2
a559 2
Dies teilt deinen DHCP Clienten mit, dass die an DNS Anfragen 
anzuhängende Domäne example.com ist (d. h., wenn der Benutzer
d597 1
a597 1
deine DHCP Klienten wünschen.
d610 1
a610 1
- der Kernel PPP Dämon.
d612 1
a612 1
- der Userland PPP Dämon. 
d616 1
a616 1
Den ersten, den wir behandeln, wird der Userland PPP Dämon sein. Um zu 
d623 1
a623 1
<li>Deinen Benutzernamen und Password
d629 1
a629 1
hilfreich. Der Userland PPP Dämon benutzt die Datei 
d648 1
a648 1
Die ersten Einstellungen für den Userland PPP Dämon bestehen im
d652 2
a653 2
Datei zu erstellen. Hier werde ich mit dem einfachsten und gebrächlichsten
Einstellungen beginnen. Hier eine schnelle <i>ppp.conf</i> Datei, die einfach
d669 1
a669 1
log&quot; stellen wir die Loglevel ein. Um dies zu ändern, siehe 
d674 1
a674 1
Daher wird COM Port 1 auf /dev/cua00 gesetzt. Mit &quot;set speed&quot; setzen
d676 3
a678 3
dail&quot; setzen wir unsere Dialup Parameter, mit denen wir die timeout Zeit,
usw. setzen können. Diese Zeile sollte eigentlich ziemlich genau so,
wie sie jetzt ist, bleiben.
d703 1
a703 1
&quot;set login&quot; setzt unsere login-Optionen. Hier haben wir die timeout
d706 2
a707 1
&quot;login:&quot; warten und dann deinen Benutzernamen und Passwort senden.
d710 3
a712 3
In diesem Beispiel ist unser username = ppp 
und das Password = ppp. Diese Werte müssen geändert werden. Die
Zeile &quot;set timeout&quot; setzt den Idle timeout für die gesamte
d721 1
a721 1
Die obigen Zeile folgt dem Format von 
d726 1
a726 1
dass kein Bits von dieser IP Adresse übereinstimmen muss und der gesamte
d730 1
a730 1
lassen wir sie um wieder mitteilen. Die dritte Option ist unsere Netzmaske,
d734 3
a736 2
nützlich, wenn Verhandlungen mit einigen PPP Implementierungen, die
keine IP Nummer vergeben, es sei denn, ihr Peer fordert ``0.0.0.0'' an.
d740 1
a740 1
Standardroute zu deren IP. Dies ist 'klebrig', d. h falls deren IP sich
d787 1
a787 1
Handbook entry on User PPP</a>.
d819 1
d823 1
a823 1
Normalerweise willst du dies nicht tun.  Dies erlaubt jemand, Datenverkehr
d844 3
a846 3
Setze die Liste der reservierten TCP ports, die nicht dynamisch vom
Kernel vergeben werden sollen. Das kann man benutzen, um daemons davon
abzuhalten, einen speziellen port zu benutzen, den ein anderes Programm
d859 1
d866 1
a866 1
folgende Manualseiten lesen, bevor du versuchst, einen eigenen NFS Server 
d877 2
a878 2
Ein Server im LAN und Klienten im LAN, die NFS verwenden. Es behandelt nicht, 
wie man NFS sicher macht. Wir nehmen an, daß du bereits Paketfilterung 
d885 2
a886 2
vortäuschen, die IP Adresse zu sein, der du Zugriff auf den NFS Server 
läßt. Es gibt mehrere Angriffe, die möglich sind. Wenn IPsec 
d891 1
a891 1
Dateisystem zu /etc/exports ohne eine Liste mit Rechnern, die explizit 
d899 1
a899 1
standardmässig abgeschaltet, so dass du die Zeile
d906 1
a906 2
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>
d915 1
a915 1
<i>/etc/exports</i> Datei haben kannst, und am besten ist, du liest 
d917 1
a917 2
Für dieses Beispiel sieht <i>/etc/exports</i> so aus:
</p>
d930 1
a930 1
unter dem <b>/work</b> Mount-point mounten können. <b>-ro</b> bedeutet,  
d940 1
a940 1
daß deine Kernelkonfiguration die Optionen NFSSERVER &amp; NFSCLIENT 
d946 2
a947 2
müssen als root gestartet werden und du mußt sicherstellen, 
daß portmap(8) auf deinem System läuft. Hier ein Beispiel von 
d949 2
a950 2
Du solltest eine angemessenene Anzahl von NFS Serverdiensten einsetzen, um 
die maximale Anzahl von gleichzeitigen Klientenanfragen, die du bedienen 
d960 2
a961 2
mountd(8) zu starten stelle sicher, dass eien leere mountdtab Datei
existiert, und starte den Daemon:
d970 2
a971 2
NFS bereits läuft, mußt du mountd dies mitteilen, indem du den 
Dienst neu startest!
d1005 1
a1005 1
<tt>/usr/bin/showmount -a host</tt>. Z.B.:
d1017 2
a1018 1
NFS Dateisysteme sollten mittels mount(8) geladen werden, oder genauer 
d1021 2
a1022 2
zu laden, tue folgendes (NB: du mußt nicht IP Adressen verwenden, mount 
wird Hostnamen auflösen):
d1029 2
a1030 2
Damit dein System dies beim Hochfahren wieder tut, füge folgendes zu 
deiner <i>/etc/fstab</i>:
d1037 1
a1037 1
Es ist wichtig, daß du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
d1041 1
a1041 1
Z.B.:
d1049 2
a1050 2
dem NFS Server Sicherheitsmaßnahmen auf dem NFS Klient untergraben. 
Wenn du keine Programme auf diesem NFS Dateisystem auf dem NFS Klient 
d1065 1
a1065 1
Als Anfang musst du pptp installiert haben. Der Port befindet sich unter
d1067 1
a1067 1
Ports</a> um mehr Informationen über den OpenBSD ports tree zu 
d1087 4
a1090 4
Nachdem du das <b>pptp</b> Package und <i>/etc/sysctl.conf</i> editiert
hast, musst du ein paar Dateien für deine neue Verbindung editieren.
Diese packages benutzen das standarmässige OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
d1092 1
a1092 1
Siehe auch <a href="#Setup">FAQ 6, Setup</a>.
d1100 1
a1100 1
Für die <i>/etc/ppp/options</i> Datei wird ein Setup wie das unten
d1124 1
a1124 1
Wobei LOGINNAME deine User-ID und PASSWORD dein Password ist. 10.0.0.138 ist
d1149 1
a1149 1
Prozesse gestartet. Du kannst pptp beenden, indem du diesen beiden Prozesse
d1157 2
a1158 1
Wir empfehlen <tt>/var/log/messages</tt> in einem weiteren Terminalfenster
d1161 2
a1162 1
<blockquote><pre>
d1181 2
a1182 2
auch einen einfachen Weg den Traffic in einem komplexen Netzwerk zu 
reduzieren  und erlauben trotzdem den Zugriff jedes Rechners zu jedem
d1191 1
a1191 1
Netz-Daten verschieben, aber nicht von extern administrierbar 
d1199 1
a1199 1
eine eingebaute 10BASE-TX Netzwerk-Karte hat. Während sie alle einen 
d1203 3
a1205 3
High-Speed-Netzwerk verbunden ist. Das Hinzufügen  einer zweiten 
Netzwerk-Karte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge 
in das Koax-Netzwerk zu benutzen.
d1208 1
a1208 1
Dieses System hat jetzt zwei Netzwerk-Karten (NICs), eine Intel EtherExpress/100
d1212 1
a1212 1
für den Koax Port. <tt>fxp0</tt> ist der Link in mein restliches 
d1251 2
a1252 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man
page</a> aufgeführt.
d1255 2
a1256 2
Jetzt müsen wir die Bridge aufsetzen. Bridges werden durch die Existenz einer Datei
namens
d1258 1
a1258 1
initialisiert. Hier ist zum Beispiel ein Datei für meine Situation:
d1272 2
a1273 2
Es ist egal, in welche Reihenfolge die Karten aufgeführt werden.
Denke daran, die Bridge ist symmetrisch -- Pakete fliessen ja in beide
d1291 2
a1292 2
über beide Interfaces fliessen, aber du nur auf einem Interface 
zu filtern brauchst. Deine "Pass all" Statements würden dann
d1305 4
a1308 4
Sagen wir nun, ich wollte den Traffic filtern, der diesen alten Maschinen
trifft. Ich möchte, dass nur Web und SSH-Traffic zu Ihnen durchkommt.
In diesem Fall lassen wir jeglichen Traffic nach draussen zu, filtern aber
auf dem fxp0 Interface, indem wir keep state für die Antwort-Daten
d1327 2
a1328 2
Denke daran, dass diese Regelwerk jeglichen Netzwerk-Verkehr
mit Ausnahme von hereinkommendem HTTP und SSH-Traffic zur Bridge selbst und
d1348 1
a1348 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&sektion=5">bridgename.bridge0</a>,
d1366 2
a1367 2
Computer aus dem Netzwerk heraus, statt von Festplatte, Diskette oder
CD-ROM aus, zu booten. Diese Technologie wurde zuerst von Intel entwickelt,
d1383 1
a1383 1
<a href="../faq14.html#Boot386">OpenBSD Bootprozess</a> auf i386 und
d1389 2
a1390 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a> Server bezogen und ausgeführt werden muss.
d1393 4
a1396 4
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a> Datei, die den Platz der standardmäßigen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot(8)</a> Datei einnimmt.
d1403 1
a1403 1
PXE-boot-fähigen Computer oder Netzwerkadapter haben musst. Einige
d1407 1
a1407 1
ein älteres Netzwerk Boot Protokoll.
d1412 1
a1412 1
Davon ausgehend, dass eine OpenBSD Maschine die Quelle der Boot Dateien
d1440 1
a1440 1
Daemonen aktivieren. Dies wird normalerweise durch
d1443 1
a1443 1
Die standard OpenBSD Installation hat eine Beispielzeile in
a1928 1

d1938 2
a1939 2
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[zurück]"></a>
<a href= "mailto:www@@openbsd.org">www@@openbsd.org</a>
d1945 1
a1945 1
$Translation: faq6.html,v 1.78 2004/11/11 14:57:34 paldium Exp $
@


1.61
log
@Sync with Steelix CVS
@
text
@d48 2
d1864 13
d1878 38
a1924 1
</p>
d1933 1
a1933 1
Originally [OpenBSD: faq6.html,v 1.203 ]
d1935 1
a1935 1
$Translation: faq6.html,v 1.77 2004/11/04 16:42:14 jufi Exp $
d1938 2
a1939 2
<small>$OpenBSD: faq6.html,v 1.203 2004/11/03 17:27:41 nick Exp $</small>
</p>
@


1.60
log
@more work from Tobias Stoeckmann, thanks !
@
text
@d46 1
a46 1
<li><a href= "#CARP">6.11 - Das Common Address Redundancy Protokoll</a>
d1520 1
a1520 1
<h2>6.11 - Das Common Address Redundancy Protokoll</h2>
d1881 1
a1881 1
Originally [OpenBSD: faq6.html,v 1.202 ]
d1883 1
a1883 1
$Translation: faq6.html,v 1.76 2004/11/02 18:04:30 jufi Exp $
d1886 1
a1886 1
<small>$OpenBSD: faq6.html,v 1.202 2004/10/30 15:51:38 canacar Exp $</small>
@


1.59
log
@Sync with Steelix CVS
@
text
@d5 1
a5 1
<link rev= "made" href="mailto:www@@openbsd.org">
d7 1
a7 1
<meta name="resource-type" content="document">
d9 4
a12 4
<meta name="description" content="Die OpenBSD FAQ Seiten - FAQ 6: Netzwerk">
<meta name="keywords" content="openbsd,faq,Netzwerk,DNS,PPTP,NFS,PPP,DHCP,NAT,PF">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2003 by OpenBSD.">
d18 4
a21 1
<img SRC="../../images/smalltitle.gif" ALT="[OpenBSD]" height=30 width=141>
d24 2
a25 2
<a href="faq5.html">[Zu Sektion 5 - Neuerzeugen des Systems aus dem Quellcode]</a>
<a href="faq7.html">[Zu Sektion 7 - Tastatur- und Bildschirmkontrollen]</a>
d28 1
a28 1
<h2><font color="#E00000">6 - Netzwerk</font></h2>
d31 1
d34 14
a47 10

<li> <a href="#Intro"	>6.0.1 - Bevor wir weiter gehen</a></li>
<li> <a href="#Setup"	>6.1 - Erste Netzwerkeinstellungen</a></li>
<li> <a href="#PF"	>6.2 - Packet Filter (PF)</a></li>
<li> <a href="#DHCP"	>6.4 - DHCP - Dynamic Host Configuration Protocol</a></li>
<li> <a href="#PPP"	>6.5 - PPP - Point to Point Protocol</a></li>
<li> <a href="#Tuning"	>6.6 - Optimieren der Netzwerkparameter</a></li>
<li> <a href="#NFS"	>6.7 - NFS benutzen</a></li>
<li> <a href="#PPTP"	>6.9 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
<li> <a href="#Bridge"  >6.10 - Aufsetzen einer Bridge mit OpenBSD</a>
d51 1
d54 1
a54 1
<h2>6.0.1 - Bevor wir weiter gehen</h2>
d57 5
a61 4
Für den Rest dieses Dokumentes sei gesagt, daß es hilfreich
ist, das Kapitel des FAQ <a href="faq5.html">Kernelkonfiguration und Einstellungen</a>
gelesen und zumindest teilweise verstanden zu haben, weiterhin helfen die
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
d63 3
a65 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>.
d71 15
a85 13
Understanding IP addressing</a>
vertiefen. Dies ist wirklich ein exzellentes Dokument. "Understanding IP addressing" 
beinhaltet grundlegendes Wissen, auf dem man beim IP Netzwerken aufbauen 
kann, insbesondere wenn man mit mehreren Netzwerken arbeitet oder für sie 
verantwortlich ist.
<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailserver arbeitest, dann
könntest du viel vom Lesen der entsprechenden 
<a href="http://the.rfc-editor.org/rfc.html">RFCs</a>
profitieren. Natürlich kannst du nicht alle lesen. Aber dennoch, lies
jene, die dich interessieren oder die du bei deiner Arbeit brauchen könntest.
Lies nach, wie alles funktionieren sollte. Die RFCs definieren mehrere (tausend)
Standards für Protokolle im Internet und wie sie arbeiten sollten.
d89 1
a89 2
<h2>
6.1 - Erste Netzwerkeinstellungen</h2>
d93 4
a96 3
<h3>
6.1.1 - Identifzieren und Einstellen deiner Netzwerkkarten</h3>
Um beginnen zu können, mußt du zunächst deine Netzwerkkarte
d100 1
a100 1
später mittels des Befehls 
d107 1
d112 3
a114 1
Wenn du deinen Geräte-Namen nicht weisst, sieh bitte in der 
d116 1
a116 1
für deine Plattform nach. Du wirst eine Liste vieler bekannte Karten 
d119 2
a120 1
"interface Name" (wie z.B. fxp0).
a121 1

a129 1
<p>
d159 2
d168 1
d170 1
a170 1
gibt uns eine Menge mehr Informationen, als wir zu diesem Zeitpunkt 
d175 2
a176 3
10.0.0.255&quot;. 
Ausserdem sind die <strong>UP</strong> und <strong>RUNNING</strong> 
Flags gesetzt.
d179 1
a179 1
Schlussendlich fällt auf, das standardmässig eine Menge mehr 
d181 2
a182 2
Funktionen haben. Informationen dazu findest du auf den folgenden man 
pages:
d184 1
d186 22
a207 11
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpath=OpenBSD+3.3">pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a> - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a> - Generic IPv4/IPv6 Tunnel Interface
d210 6
a215 5
Der 1. Schritt zur Konfiguration deiner Netzwerkkarte ist das Erstellen
der <b>/etc/hostname.xxx</b> Datei, wobei der Name deiner Karte den Platz
von xxx einnehmen sollte. Aus der Information der obigen Beispiele würde
der Name <b>/etc/hostname.fxp0 </b>lauten. Das Layout dieser Datei sollte
einfach so aussehen: <br>
d220 1
d222 1
a222 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a> man page.)
d224 2
a225 1
Eine typische Interface-Konfigurationsdatei für eine IPv4 Addresse 
d227 1
d234 1
a234 1
Du solltest auch den media type für Ethernet angeben, wenn du z.B. den
a235 1
</p>
d241 1
d243 1
a243 1
Verbindungen auf Voll-Duplex gestellt sind ! Wenn du keine besonderen 
a249 1
</p>
d257 7
a263 7
Der nächste Schritt ist das Einstellen deines Standard-Gateways (default gateway).
Dazu trag einfach die IP deines Gateways in die Datei <b>/etc/mygate</b> ein. 
Dies erlaubt das Aktivieren deines Gateways beim Starten. Jetzt solltest 
du deine Nameserver eintragen und die Datei <b>/etc/hosts</b> einrichten. 
Für die Nameserver benötigst du eine Datei namens 
<b>/etc/resolv.conf</b>. Mehr über das Format dieser Datei findest 
du in der 
d267 1
a267 2
domain &quot;example.com&quot;.
</p>
a279 1
</p>
d290 5
a294 4
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript ausführst, 
versuchst du ein paar Sachen zu konfigurieren, die bereits konfiguriert sind. 
Daher existieren bereits bereits einige der Routen in der kernel routing table. 
Von hier ab sollte dein System laufen und online sein. Du kannst hier erneut mit 
d298 2
a299 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a> oder 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a> 
d302 4
a305 4
das -n Flag für route(8) benutzen, dass die IP-Adressen ausgibt, statt 
einen DNS Lookup zu machen, und den Hostnamen anzuzeigen.
Hier ist ein Beispiel mit beiden Kommandos:
</p>
d323 1
d339 3
a341 3
<a name= "Setup.2"></a>
<h3>
6.1.2 - Einrichten deines OpenBSD Rechners als Gateway</h3>
d348 1
a348 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a> 
a350 1
</p>
a359 1
</p>
d368 2
a369 3
durchführen. Beachte aber, daß diese Änderung nach einem Reboot weg ist und
dass der folgende Befehl als root ausgeführt werden muß.
</p>
d372 2
a373 2
# <b>sysctl -w net.inet.ip.forwarding=1
</b>net.inet.ip.forwarding: 0  -&gt; 1
d383 3
a385 3
in der ports Kollektion sowohl für gated, zebra als auch mrtd. OpenBSD unterstützt
mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP) Schnittstellen.
</p>
d389 2
a390 2
<h3>
6.1.3 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>
d392 2
a393 2
OpenBSD hat einen einfachen Mechanismus, um IP Aliase für deine Netzwerk-Karten
zu setzen. Dazu musst du einfach die Datei
d396 5
a400 5
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a> Skript gelesen,
das ein Teil der <a href="../faq10.html#rc">rc startup
Hierarchie</a> ist. Für dieses Beispiel nehmen wir an, der User hat ein Interface
<b>dc0</b>  und befindet sich im Netzwerk 192.168.0.0. Weitere wichtige Informationen:
</p>
d403 2
a404 4
<li>
IP für dc0 ist 192.168.0.2</li>
<li>
NETMASK ist 255.255.255.0</li>
d408 1
a408 1
Ein paar Bemerkungen zu Aliasen: Bei OpenBSD verwendet man nur den Adapternamen. 
d416 1
a417 1

d421 3
a423 3
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Aliase zur Netzwerkkarte 
dc0 hinzugefügt, die als 192.168.0.2 mit Netzmaske 255.255.255.0 
konfiguriert wurde.
a425 1

a431 1

a437 2
</p>

a444 1
</p>
d454 1
d456 1
d458 2
a459 2
<h2>6.2 - Packet Filter (PF)</h2>
Packet Filter (ab hier nur noch als PF bezeichnet) ist OpenBSD's System 
d461 6
a466 5
Translation. PF ist ausserdem in der Lage TCP/IP-Verkehr zu normalisieren
und zu konditionieren und ausserdem eine Priorisierung von Paketen 
durchzuführen. PF ist seit OpenBSD Version 3.0 Teil des
OpenBSD GENERIC Kernels. Beschrieben wird PF im neuen
<a href="../pf/index.html"><b>PF User's Guide</b></a>.
a467 5
Die alte PF FAQ ist nach wie vor <a href="../faq6pf.html">hier</a>
zu lesen.

<br>

a470 1
</p>
d472 5
a476 2
<h3>6.4.1 DHCP Klient</h3>
<p>Um den DHCP Klient 
d478 1
a478 1
zu benutzen, der Teil von OpenBSD ist, editiere /etc/hostname.xl0
d481 2
a482 1
Alles, was du in dieser Datei zu schreiben hast, ist 'dhcp'.
d484 1
a484 1
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
d486 3
a488 1
Dies wird OpenBSD veranlassen, den DHCP Klient automatisch beim Booten zu 
d491 1
d493 4
a496 3
Wenn du den DHCP Klient von der Befehlszeile starten willst, stelle sicher, 
daß /etc/dhclient.conf existiert, dann versuche:
<PRE>
d499 2
d502 3
a504 1
<P>Wie du auch immer dhclient startest, du kannst die /etc/dhclient.conf Datei 
d509 1
d514 2
d518 2
a519 1
<P>
d522 1
d524 6
a529 4
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8">dhcpd(8)</a>,
einstetzen willst, 
editiere /etc/rc.conf. Setze dhcpd_flags="-q" anstelle von dhcpd_flags=NO.
Und die Netzwerkkarten, auf denen dhcpd(8) <b>lauschen</b> soll, stehen in /etc/dhcpd.interfaces.
d531 1
a531 1
# <strong>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</strong>
d533 3
a535 1
Dann editiere /etc/dhcpd.conf.
d537 1
d548 27
a575 17
Dies teilt deinen DHCP Klienten mit, daß die an DNS Anfragen 
anzuhängende Domäne example.com ist (d. h., wenn der Benutzer schreibt 
'telnet joe', dann wird an joe.example.com gesendet). Es wird auf die DNS Server 
192.168.1.3 und 192.168.1.5 verwiesen. Für Hosts, die sich im selben 
Netzwerk wie die Netzwerkkarte des OpenBSD Rechners befinden, welche im 
192.168.1.0/24 Adressbereich liegt, wird der DHCP Server ihnen eine IP Adresse 
zwischen 192.168.1.32 und 192.168.1.127 und als Standardgateway 192.168.1.1 zuweisen.
<p>
Wenn du den dhcpd(8) von der Befehlszeile starten willst, nachdem du /etc/dhcpd.conf 
editiert hast, versuche:
<PRE>
    # <b>dhcpd -q fxp0</b>
</PRE>
Wobei <tt>fxp0</tt> die Netzwerkkarte ist, auf der DHCP serviert werden soll. 
Die <tt>-q</tt> Option setzt die Ausgabe von dhcpd(8) auf ruhig, ansonsten ist sie sehr 
ausführlich.
<P>
d579 1
d581 1
a581 1
option	netbios-name-servers	192.168.92.55;
d583 2
d587 1
a587 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&sektion=5">dhcp-options(5)</a>
d590 2
a594 1
</p>
d596 3
a598 2
Das "Point-to-Protocol" wird verwendet, um eine Verbindung zu deinem ISP mit 
deinem Modem herzustellen. OpenBSD bietet dafür 2 Möglichkeiten.
d609 2
a610 3
beginnen, benötigen wir einige einfache Informationen über deinen ISP. 
Hier eine Liste hilfreicher Informationen, die du brauchen wirst.
</p>
d620 7
a626 7
Einige von diesen benötigst du nicht unbedingt, aber sie wären hilfreich. 
Der Userland PPP Dämon benutzt die Datei 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> als
seine Konfigurationsdatei. Es gibt viele hilfreiche Dateien in <b>/etc/ppp</b>, 
die verschiedene Einstellungen für verschiedene Situationen zeigen. Du solltest 
dir dieses Verzeichnis ansehen und es durchforsten.
</p>
d629 1
a629 1
Solltest du keinen GENERIC Kernel verwenden, dann stelle sicher, daß du 
a630 1
</p>
d633 1
a633 1
pseudo-device   tun             2
d636 1
d640 7
a646 9
Die ersten Einstellungen für den Userland PPP Dämon bestehen im Erstellen 
deiner <b>/etc/ppp/ppp.conf</b> Datei. Diese Datei existiert nicht 
standardmäßig, aber du kannst einfach <b>/etc/ppp/ppp.conf.sample</b> 
editieren, um deine eigene <b>ppp.conf</b> Datei zu kreieren. Hier werde ich mit 
dem einfachsten und gebrächlichsten Einstellungen beginnen.
Hier eine schnelle <b>ppp.conf</b> Datei, die uns einfach zu deinem ISP verbindet 
und die Standardrouten und Nameserver setzt. Für diese Datei brauchst du nur 
die Telefonnummer deines ISP sowie deinen Benutzernamen und dein Passwort.
</p>
d648 2
a649 1
<blockquote><pre>
d654 3
a656 2
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>
d659 3
a661 3
Der Absatz unter der <b>default:</b> Bezeichnung wird jedes Mal ausgeführt. 
Hier stehen alle wichtigen Informationen. Mit &quot;set log&quot; stellen wir die 
Loglevel ein. Um dies zu ändern, siehe 
d663 16
a678 8
für weitere Info. Unsere Schnittstelle 
wird mit &quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit der das 
Modem verbunden ist. In diesem Beispiel hängt das Modem auf COM Port 2. Daher 
wird COM Port 1 auf /dev/cua00 gesetzt. Mit &quot;set speed&quot; setzen wird die 
Geschwindigkeit unserer Dialup Verbindung und mit &quot;set dial&quot; setzen wir unsere 
Dialup Parameter, mit denen wir die timeout Zeit, usw. setzen können. Diese Zeile 
sollte eigentlich ziemlich genau so, wie sie jetzt ist, bleiben.
</p>
d680 2
a681 9
<p>
Nun können wir die ISP spezifischen Informationen eintragen. Wir tun dies, indem 
wir unter <b>default:</b> einen weiteren Absatz hinzufügen. Dieser kann als alles 
benannt werden, am einfachsten nimmst du den Namen deines ISP. Hier werde ich 
<b>myisp:</b> als Verweis auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, 
das alles beinhaltet, um uns zu verbinden.
<p>

<blockquote><pre>
d689 10
a698 1
</pre></blockquote>
d701 5
a705 11
Hier stehen alle wichtigen Informationen für unseren spezifischen ISP. Die erste 
Option &quot;set phone&quot; setzt die Telefonnummer deines ISP. &quot;set login&quot; 
setzt unsere login-Optionen. Hier haben wir die timeout auf 5 gesetzt, was bedeutet, 
daß wir unseren login-Versuch nach 5 Sekunden abbrechen, wenn wir kein 
Trägersignal bekommen. Ansonsten wird er auf &quot;login:&quot; warten und dann 
deinen Benutzernamen und Passwort senden. In diesem Beispiel ist unser username = ppp 
und das Password = ppp. Diese Werte müssen geändert werden. Die Zeile 
&quot;set timeout&quot; setzt den Idle timeout für die gesamte Verbindungsdauer auf 120 
Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein bißchen schwieriger. Hier ist 
eine genauere Erklärung.
</p>
d713 23
a735 12
&quot;<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske [startAdr]]]]</b>&quot;. 
Daher ist die erste spezifizierte IP diejenige, die wir als unsere IP wollen. Wenn du 
eine statische IP Adresse hast, dann kannst du sie hier einsetzen. In unserem Beispiel 
benutzen wir /0, was besagt, daß kein Bits von dieser IP Adresse übereinstimmen 
muß und der gesamte Ausdruck ersetzt werden kann. Die zweite IP behandelt die von 
uns erwartete IP unserer Gegenstelle. Wenn du sie weißt, dann kannst du sie hier 
angeben. Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also lassen 
wir sie um wieder mitteilen. Die dritte Option ist unsere Netzmaske, hier auf 
255.255.255.0 gesetzt. Wenn startAdr spezifiziert ist, dann wird diese anstelle von 
meineAdr während der initialen IPCP Verhandlung; aber es wird nur eine Adresse aus 
dem meineAdr-Adressbereich akzeptiert. 
</p>
a737 8
Die nächste Option &quot;add default HISADDR&quot; setzt unsere Standardroute 
zu deren IP. Dies ist 'klebrig', d. h falls deren IP sich ändern sollte, dann 
wird unsere Route auch automatisch upgedatet. Mit &quot;enable dns&quot; teilen wir 
unserem ISP mit, unsere Nameserveradresse zu authentifizieren. Tu dies NICHT, wenn du 
deinen eigenen lokalen DNS laufen hast, da PPP dies umgehen wird, indem es einige 
Zeilen in /etc/resolv.conf schreibt.
</p>

d741 3
a743 4
Nun, da wir unsere <b>ppp.conf</b> Datei fertig eingerichtet haben, können wir 
beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier einige Details über 
häufig verwendete Parameter.
</p>
d746 5
a750 4
<li><b>ppp -auto myisp</b> - Startet PPP, konfiguriert deine Schnittstellen und 
wird dich mit deinem ISP verbinden und dann in den Hintergrund verschwinden.
<li><b>ppp -ddial myisp</b> - Ähnlich wie -auto, aber wenn deine Verbindung 
abbricht, wird PPP versuchen, sich erneut zu verbinden.
d754 4
a757 4
Mit dem Aufruf von <b>/usr/sbin/ppp</b> ohne Optionen kommst du in den interaktiven 
Modus. Hier kannst du direkt mit dem Modem interagieren, was sich hervorragend eignet, 
um Probleme in deiner <b>ppp.conf</b> Datei zu debuggen.
</p>
d759 1
d764 4
a767 5
Verbindung gerade errichtet oder beendet wurde. Für diese Fälle gibts es zwei 
Dateien, die du kreieren kannst: <b>/etc/ppp/ppp.linkup</b> und 
<b>/etc/ppp/ppp.linkdown</b>.
Beispielskonfigurationen kannst du hier finden:
</p>
d776 3
a778 2
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD Handbook entry on User PPP</a>. 
</p>
d785 11
a795 1
<P>
d797 1
d803 15
a817 9
Mittels <tt>sysctl -a</tt> kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu verändern, verwende 
<tt>sysctl -w</tt>, wie z. B. <tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.  

<h3>6.6.2 - Wie kann ich "directed broadcasts" aktivieren?</h3>
Normalerweise willst du dies nicht tun.  Dies erlaubt jemand, Datenverkehr zu
der broadcast Adresse deines verbundenen Netzwerkes zu schicken, wenn du deinen 
OpenBSD Rechner als Router verwendest.<P>
Aber manchmal kann dies (in geschlossenen Netzwerken) nützlich sein,
d820 3
a822 2
Wiederum mit sysctl.  <tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
aktiviert dies.  Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>, 
d825 4
a828 1
<H3>6.6.3 - Der Kernel soll Ports nicht dynamisch allozieren</h3>
d831 2
a832 1
<PRE>
d839 1
a839 1
#  <strong>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>
d841 1
a841 1
Es ist ebenso möglich ports aus der aktuellen Liste hinzuzufügen 
d844 2
a845 2
 #  <strong>sysctl -w net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl -w net.inet.tcp.baddynamic=-871</strong>
d849 1
a849 1
<a name= "NFS"></a>
a850 1
</p>
a856 2
<p>

d876 2
a877 1
<P>
a882 1
</p>
a884 1
NFS hängt von
d886 2
a887 4
ab, bevor es funktionieren kann. Portmap(8) ist ab OpenBSD 3.2 
standardmässig abgeschaltet, du musst es also in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
wieder einschalten, indem du die <tt>portmap</tt> Zeile wie folgt änderst:
d892 5
a896 1
und ein Reboot ist notwendig, damit die Änderung wirksam wird.
d918 2
a919 2
D.h., daß das lokale Dateisystem <b>/work</b> via NFS zugänglich 
gemacht wird. <b>-alldirs</b> bedeutet, daß Klienten jedes Verzeichnis 
d921 2
a922 2
daß nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, daß nur Klienten innerhalb des 10.0.0.0 Netzwerkes mit einer 
a925 1
</p>
d927 2
a928 1
<p> Ist einmal deine <i>/etc/exports</i> Datei eingerichtet, kannst du 
d932 2
a933 1
solltest du <strong>nfs_server=YES</strong> in <i>/etc/rc.conf</i> eintragen. 
a942 2
<P>

d948 1
a948 1
Du mußt nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
a951 1
<p>
d958 1
a958 1
<P>
d963 1
a963 1
<UL><PRE>
d967 1
a967 2
<P>

a972 1
<p>
d989 2
a990 1
<p> Für den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
d995 1
a995 3
<b>/usr/bin/showmount -a host</b>. Z. B.:

<P>
d1003 1
a1011 1
<p>
d1017 1
a1017 1
<P>
a1019 1
<P>
d1021 1
a1021 1
<UL><PRE>
d1025 1
a1025 1
<P>
d1030 1
a1030 2
Z. B.:
<P>
d1032 1
a1032 1
<UL><PRE>
d1036 1
a1036 1
<P>
d1044 1
a1044 2
<h2>6.9 - Eine PPTP Verbindung mit OpenBSD aufsetzen</h2>
</p>
d1047 5
a1051 3
<strong>HINWEIS:</strong> Dies bezieht sich nicht auf <strong>ALLE</strong> ADSL Provider, aber viele der Informationen können aus diesem Setup 
übernommen werden. Dieses Setup funktioniert auf jeden Fall bei <a href="http://www.inode.at">Inode</a>, einem ADSL Provider in Österreich.
</p>
a1057 1
</p>
d1060 1
a1060 1
Wegen des Konflikts der "Im-Kernel" 
d1062 5
a1066 22
Unterstützung und pptp wirst du deinen Kernel neu kompilieren 
müssen und die Unterstützung für gre(4) entfernen müssen.
</p>

<blockquote>Patch, um die GRE(4) Unterstützung zu entfernen.
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@@@ -87,7 +87,7 @@@@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
d1068 6
d1076 2
a1077 9
Um deinen Kernel neu zu kompilieren mache einen "check out" von OpenBSD 
via cvs (siehe die <a href="../../de/stable.html">OpenBSD Stable</a> 
Webseite) , benutze den folgenden Patch, und baue einen neuen Kernel 
wie unter <a href="faq5.html#Building">FAQ 5, Building a kernel</a>.
</p>

<p>
Nachdem du das <b>pptp</b> package und einen neuen Kernel installiert hast,
musst du ein paar Dateien für deine neue Verbindung editieren.
a1081 1
</p>
d1089 2
a1090 2
Für eine <i>/etc/ppp/options</i> Datei wird ein Setup wie das unten vermutlich alles notwendige tun:
</p>
a1102 1
</p>
d1113 2
a1114 1
Wobei LOGINNAME deine User-ID und PASSWORD dein Password ist. 10.0.0.138 ist die zugewiesene IP deines Modems im Falle, dass du ADSL nutzt, etc. 
a1115 1
</p>
d1117 2
a1118 1
<h3>6.9.1 - Deinem Network Interface eine Adresse zuweisen</h3>
d1121 6
a1126 4
Im obigen Beispiel hatte unser Modem eine vorkonfigurierte Adresse von 10.0.0.138. Jetzt müssen wir UNSEREM Interface noch eine Adresse zuweisen.
Es ist am besten eine IP zu wählen, die nahe an der deines MODEMS liegt, oder einfach die statische Adresse zu benutzen, die dir zugewiesen wurde.
Mehr darüber, wie man Interfaces IP-Adressen zuweist, kannst du in <a href="#6.1">FAQ 6.1</a> lesen.
</p>
d1129 2
a1130 1
Wenn dein Interface eingerichtet ist, solltest du eine pptp Verbindung mit dem Kommando 
a1135 1
aufbauen können.
d1137 2
a1138 1
Da hier auch der "in-house" OpenBSD ppp(8) benutzt wird, werden hier zwei Prozesse gestartet. Du kannst pptp beenden, indem du diesen beiden Prozesse
a1139 1
</p>
d1146 2
a1147 1
Wir empfehlen <tt>/var/log/messages</tt> in einem weiteren Terminalfenster zu öffnen, um mögliche Probleme zu erkennen.
a1151 1
</p>
d1154 2
a1155 4
Wir schlagen vor, die Startsequenz in <i>/etc/rc.local</i> unterzubringen, so dass bei jedem reboot die Verbindung automatisch 
aufgebaut wird.
</p>

d1159 1
a1159 1
<h2>6.10 - Aufsetzen einer Bridge mit OpenBSD</h2>
d1161 1
d1181 1
d1183 2
d1204 1
a1204 1
Wie also bewerkstelligen wir das ?
d1218 2
a1219 1
Noch keinerlei Überraschungen
d1223 1
d1231 1
d1256 1
d1266 1
d1268 1
d1274 1
a1274 1
 der durch deine Bridge fliesst.
d1291 1
d1313 1
d1324 3
a1326 1
<h3>Tips zum Bridging</h3>
d1350 515
d1869 2
a1870 2
<a href= "faq5.html">[Zu Kapitel 5 - Neuerzeugen des Systems aus dem Quellcode]</a>
<a href= "faq7.html">[Zu Kapitel 7 - Tastatur- und Bildschirmkontrollen]</a>
d1881 1
a1881 1
Originally [OpenBSD: faq6.html,v 1.177 ]
d1883 1
a1883 1
$Translation: faq6.html,v 1.75 2004/10/29 21:28:09 jufi Exp $
d1886 1
a1886 1
<small>$OpenBSD: faq6.html,v 1.177 2003/07/25 20:05:19 nick Exp $</small>
@


1.58
log
@sync with steelix translation CVS
@
text
@d48 1
a48 1
F&uuml;r den Rest dieses Dokumentes sei gesagt, da&szlig; es hilfreich
d57 1
a57 1
&uuml;ber IP Netzwerke mit 
d62 1
a62 1
kann, insbesondere wenn man mit mehreren Netzwerken arbeitet oder f&uuml;r sie 
d66 1
a66 1
k&ouml;nntest du viel vom Lesen der entsprechenden 
d68 2
a69 2
profitieren. Nat&uuml;rlich kannst du nicht alle lesen. Aber dennoch, lies
jene, die dich interessieren oder die du bei deiner Arbeit brauchen k&ouml;nntest.
d71 1
a71 1
Standards f&uuml;r Protokolle im Internet und wie sie arbeiten sollten.
d82 2
a83 2
Um beginnen zu k&ouml;nnen, mu&szlig;t du zun&auml;chst deine Netzwerkkarte
identifizieren k&ouml;nnen. Bei OpenBSD werden Netzwerkkarten nach ihrem
d86 1
a86 1
sp&auml;ter mittels des Befehls 
d90 3
a92 3
deine Karte &uuml;berpr&uuml;fen. Als Beispiel hier die Ausgabe in
dmesg f&uuml;r eine Intel Fast Ethernet Netzwerk-Karte, die als 
Ger&auml;tenamen fxp hat.
d97 4
a100 4
Wenn du deinen Ger&auml;te-Namen nicht weisst, sieh bitte in der 
<a href="../../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> 
f&uuml;r deine Plattform nach. Du wirst eine Liste vieler bekannte Karten 
und ihre OpenBSD Ger&auml;te-Namen finden (wie etwa fxp), zusammen mit 
d152 1
a152 1
ben&ouml;tigen. Nat&uuml;rlich sehen wir trotzdem unser Interface. Im 
d161 1
a161 1
Schlussendlich f&auml;llt auf, das standardm&auml;ssig eine Menge mehr 
d182 1
a182 1
von xxx einnehmen sollte. Aus der Information der obigen Beispiele w&uuml;rde
d192 2
a193 2
Eine typische Interface-Konfigurationsdatei f&uuml;r eine IPv4 Addresse 
w&uuml;rde so aussehen:
d200 1
a200 1
Du solltest auch den media type f&uuml;r Ethernet angeben, wenn du z.B. den
d213 2
a214 2
Oder vielleicht willst du auch spezielle flags f&uuml;r ein einzelnes 
Interface benutzen. Das Format der Datei &auml;ndert sich dabei nicht 
d224 1
a224 1
Der n&auml;chste Schritt ist das Einstellen deines Standard-Gateways (default gateway).
d228 2
a229 2
F&uuml;r die Nameserver ben&ouml;tigst du eine Datei namens 
<b>/etc/resolv.conf</b>. Mehr &uuml;ber das Format dieser Datei findest 
d232 2
a233 2
Manual Seite. F&uuml;r den Normalgebrauch ist hier ein Beispiel, in dem
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du geh&ouml;rst zur Domain
d247 1
a247 1
ausf&uuml;hren, indem du (als root) folgendes eingibst:
d259 1
a259 1
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript ausf&uuml;hrst, 
d264 1
a264 1
pr&uuml;fen, ob deine Interfaces richtig konfiguriert wurden.
d268 3
a270 3
&uuml;berpr&uuml;fen.
Wenn du Probleme mit dem Routing hast, m&ouml;chtest du vielleicht
das -n Flag f&uuml;r route(8) benutzen, dass die IP-Adressen ausgibt, statt 
d313 1
a313 1
Instruktionen beachten, um potentiell sch&auml;dliche IP Daten zu blockieren.
d316 1
a316 1
Adressen die Informationen bez&uuml;glich Network Address Translation beachten, 
d321 2
a322 2
Der GENERIC Kernel hat bereits die F&auml;higkeit f&uuml;r IP Forwarding,
aber dies mu&szlig; erst eingeschaltet werden. Du solltest dies mit 
d324 1
a324 1
tun. Um diese &Auml;nderung permanent einzutragen, mu&szlig;t du die Datei
d326 1
a326 1
editieren. F&uuml;ge einfach folgende Zeile in diese Konfigurationsdatei
d337 2
a338 2
durchf&uuml;hren. Beachte aber, da&szlig; diese &Auml;nderung nach einem Reboot weg ist und
dass der folgende Befehl als root ausgef&uuml;hrt werden mu&szlig;.
d348 1
a348 1
M&ouml;glichkeiten, OpenBSD als Router einzusetzen, z. B. mittels Software
d352 2
a353 2
OpenBSD hat Unterst&uuml;tzung
in der ports Kollektion sowohl f&uuml;r gated, zebra als auch mrtd. OpenBSD unterst&uuml;tzt
d362 1
a362 1
OpenBSD hat einen einfachen Mechanismus, um IP Aliase f&uuml;r deine Netzwerk-Karten
d368 1
a368 1
Hierarchie</a> ist. F&uuml;r dieses Beispiel nehmen wir an, der User hat ein Interface
d374 1
a374 1
IP f&uuml;r dc0 ist 192.168.0.2</li>
d382 1
a382 1
Daher mu&szlig; man sie nicht - wie in einigen anderen Betriebssystemen - 
d384 1
a384 1
Wenn du dich auf einen speziellen IP Alias beziehst oder einen hinzuf&uuml;gst, 
d387 1
a387 1
l&ouml;schen. 
d391 2
a392 2
dann ist die Netzmaskeneinstellung f&uuml;r jeden Alias 255.255.255.255.
Sie m&uuml;ssen nicht der Netzmaske der ersten IP der Netzwerkkarte folgen. 
d394 1
a394 1
dc0 hinzugef&uuml;gt, die als 192.168.0.2 mit Netzmaske 255.255.255.0 
d407 2
a408 2
Wenn du einmal diese Datei erstellt hast, ben&ouml;tigst du einen Reboot,
um die &Auml;nderung automatisch durchf&uuml;hren. Du kannst aber auch
d411 1
a411 1
hochbringen. F&uuml;r den ersten Alias geht das so:
d435 1
a435 1
zum Filtern von TCP/IP Verkehr und zum Ausf&uuml;hren von Network Address 
d438 1
a438 1
durchzuf&uuml;hren. PF ist seit OpenBSD Version 3.0 Teil des
d467 1
a467 1
da&szlig; /etc/dhclient.conf existiert, dann versuche:
d473 1
a473 1
immer so editieren, da&szlig; dein DNS <b>nicht</b> erneuert wird aufgrund 
d475 2
a476 2
(Es gibt Beispiele in den Standardeinstellungen, aber du mu&szlig;t die 
Standardeinstellungen von dhclient &uuml;berschreiben.). 
d481 1
a481 1
und dann <b>entferne</b> domain-name-servers.  Nat&uuml;rlich kannst du auch 
d495 1
a495 1
Die Optionen sind selbsterkl&auml;rend.
d507 2
a508 2
Dies teilt deinen DHCP Klienten mit, da&szlig; die an DNS Anfragen 
anzuh&auml;ngende Dom&auml;ne example.com ist (d. h., wenn der Benutzer schreibt 
d510 1
a510 1
192.168.1.3 und 192.168.1.5 verwiesen. F&uuml;r Hosts, die sich im selben 
d522 1
a522 1
ausf&uuml;hrlich.
d524 1
a524 1
Wenn du DHCP Dienste f&uuml;r einen Windows Rechner bereitstellst, dann willst 
d526 1
a526 1
Daf&uuml;r f&uuml;ge einfach die folgenden Zeilen zu deiner /etc/dhcpd.conf:
d533 2
a534 2
f&uuml;r weitere Optionen, die 
deine DHCP Klienten w&uuml;nschen.
d541 1
a541 1
deinem Modem herzustellen. OpenBSD bietet daf&uuml;r 2 M&ouml;glichkeiten.
d545 1
a545 1
- der Kernel PPP D&auml;mon.
d547 1
a547 1
- der Userland PPP D&auml;mon. 
d551 2
a552 2
Den ersten, den wir behandeln, wird der Userland PPP D&auml;mon sein. Um zu 
beginnen, ben&ouml;tigen wir einige einfache Informationen &uuml;ber deinen ISP. 
d564 2
a565 2
Einige von diesen ben&ouml;tigst du nicht unbedingt, aber sie w&auml;ren hilfreich. 
Der Userland PPP D&auml;mon benutzt die Datei 
d568 1
a568 1
die verschiedene Einstellungen f&uuml;r verschiedene Situationen zeigen. Du solltest 
d573 1
a573 1
Solltest du keinen GENERIC Kernel verwenden, dann stelle sicher, da&szlig; du 
d581 1
a581 1
<h3>Erste Einstellungen - f&uuml;r PPP(8)</h3>
d584 1
a584 1
Die ersten Einstellungen f&uuml;r den Userland PPP D&auml;mon bestehen im Erstellen 
d586 1
a586 1
standardm&auml;&szlig;ig, aber du kannst einfach <b>/etc/ppp/ppp.conf.sample</b> 
d588 1
a588 1
dem einfachsten und gebr&auml;chlichsten Einstellungen beginnen.
d590 1
a590 1
und die Standardrouten und Nameserver setzt. F&uuml;r diese Datei brauchst du nur 
d603 1
a603 1
Der Absatz unter der <b>default:</b> Bezeichnung wird jedes Mal ausgef&uuml;hrt. 
d605 1
a605 1
Loglevel ein. Um dies zu &auml;ndern, siehe 
d607 1
a607 1
f&uuml;r weitere Info. Unsere Schnittstelle 
d609 1
a609 1
Modem verbunden ist. In diesem Beispiel h&auml;ngt das Modem auf COM Port 2. Daher 
d612 1
a612 1
Dialup Parameter, mit denen wir die timeout Zeit, usw. setzen k&ouml;nnen. Diese Zeile 
d617 2
a618 2
Nun k&ouml;nnen wir die ISP spezifischen Informationen eintragen. Wir tun dies, indem 
wir unter <b>default:</b> einen weiteren Absatz hinzuf&uuml;gen. Dieser kann als alles 
d635 1
a635 1
Hier stehen alle wichtigen Informationen f&uuml;r unseren spezifischen ISP. Die erste 
d638 2
a639 2
da&szlig; wir unseren login-Versuch nach 5 Sekunden abbrechen, wenn wir kein 
Tr&auml;gersignal bekommen. Ansonsten wird er auf &quot;login:&quot; warten und dann 
d641 4
a644 4
und das Password = ppp. Diese Werte m&uuml;ssen ge&auml;ndert werden. Die Zeile 
&quot;set timeout&quot; setzt den Idle timeout f&uuml;r die gesamte Verbindungsdauer auf 120 
Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein bi&szlig;chen schwieriger. Hier ist 
eine genauere Erkl&auml;rung.
d656 3
a658 3
benutzen wir /0, was besagt, da&szlig; kein Bits von dieser IP Adresse &uuml;bereinstimmen 
mu&szlig; und der gesamte Ausdruck ersetzt werden kann. Die zweite IP behandelt die von 
uns erwartete IP unserer Gegenstelle. Wenn du sie wei&szlig;t, dann kannst du sie hier 
d662 1
a662 1
meineAdr w&auml;hrend der initialen IPCP Verhandlung; aber es wird nur eine Adresse aus 
d667 2
a668 2
Die n&auml;chste Option &quot;add default HISADDR&quot; setzt unsere Standardroute 
zu deren IP. Dies ist 'klebrig', d. h falls deren IP sich &auml;ndern sollte, dann 
d678 3
a680 3
Nun, da wir unsere <b>ppp.conf</b> Datei fertig eingerichtet haben, k&ouml;nnen wir 
beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier einige Details &uuml;ber 
h&auml;ufig verwendete Parameter.
d686 1
a686 1
<li><b>ppp -ddial myisp</b> - &Auml;hnlich wie -auto, aber wenn deine Verbindung 
d699 2
a700 2
In einigen Situationen m&ouml;chstest du Befehle ausf&uuml;hren, wenn die 
Verbindung gerade errichtet oder beendet wurde. F&uuml;r diese F&auml;lle gibts es zwei 
d722 1
a722 1
Um dies zu tunen, verwende <tt>sysctl</tt> und erh&ouml;he die Werte von:
d729 1
a729 1
anderer) Parameter sehen. Um einen Wert zu ver&auml;ndern, verwende 
d736 2
a737 2
Aber manchmal kann dies (in geschlossenen Netzwerken) n&uuml;tzlich sein,
vor allem wenn man &auml;ltere Implementierungen des NetBIOS Protokolles
d741 1
a741 1
wenn du wissen willst, warum dies standardm&auml;&szlig;ig nicht aktiviert ist.
d744 1
a744 1
Auch daf&uuml;r gibt es einen eigenen sysctl Befehl.  Siehe 
d750 1
a750 1
braucht, damit es funktionieren kann. Listen-Elemente k&ouml;nnen
d755 1
a755 1
Es ist ebenso m&ouml;glich ports aus der aktuellen Liste hinzuzuf&uuml;gen 
d768 1
a768 1
ein Dateisystem &uuml;ber das Netzwerk zu verwenden. Du solltest vorher noch 
d783 1
a783 1
wie man NFS sicher macht. Wir nehmen an, da&szlig; du bereits Paketfilterung 
d785 8
a792 8
au&szlig;erhalb nicht auf NFS zugegriffen werden kann.
Wenn du Zugriff via NFS von au&szlig;erhalb erlauben willst und sensible Daten 
dort gespeichert hast, dann empfehlen wir dir w&auml;rmstens den Gebrauch von 
IPsec.  Ansonsten k&ouml;nnen andere Leute 
m&ouml;glicherweise deinen NFS Datenverkehr sehen. Jemand k&ouml;nnte auch 
vort&auml;uschen, die IP Adresse zu sein, der du Zugriff auf den NFS Server 
l&auml;&szlig;t. Es gibt mehrere Angriffe, die m&ouml;glich sind. Wenn IPsec 
richtig konfiguriert ist, dann sch&uuml;tzt es gegen die Art von Angriffen. 
d794 1
a794 1
Noch eine wichtige Anmerkung wegen Sicherheit. F&uuml;ge niemals ein 
d797 1
a797 1
mounten k&ouml;nnen, kann jeder, der den Rechner erreichen kann, deine NFS 
d802 1
a802 1
NFS h&auml;ngt von
d805 1
a805 1
standardm&auml;ssig abgeschaltet, du musst es also in
d807 1
a807 1
wieder einschalten, indem du die <tt>portmap</tt> Zeile wie folgt &auml;nderst:
d812 1
a812 1
und ein Reboot ist notwendig, damit die &Auml;nderung wirksam wird.
d815 1
a815 1
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS f&uuml;r 
d818 1
a818 1
Dateisysteme auf, die du &uuml;ber NFS freigeben willst, und definiert, wer 
d822 1
a822 1
F&uuml;r dieses Beispiel sieht <i>/etc/exports</i> so aus:
d834 8
a841 8
D.h., da&szlig; das lokale Dateisystem <b>/work</b> via NFS zug&auml;nglich 
gemacht wird. <b>-alldirs</b> bedeutet, da&szlig; Klienten jedes Verzeichnis 
unter dem <b>/work</b> Mount-point mounten k&ouml;nnen. <b>-ro</b> bedeutet,  
da&szlig; nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, da&szlig; nur Klienten innerhalb des 10.0.0.0 Netzwerkes mit einer 
Netzmaske von 255.255.255.0 dieses Dateisystem mounten d&uuml;rfen. Dies ist 
wichtig f&uuml;r einige Server, die von verschiedenen Netzwerken 
zug&auml;nglich sind.
d846 2
a847 2
da&szlig; deine Kernelkonfiguration die Optionen NFSSERVER &amp; NFSCLIENT 
enth&auml;lt. (Der GENERIC Kernel beinhaltet diese Optionen.) Dann 
d851 2
a852 2
m&uuml;ssen als root gestartet werden und du mu&szlig;t sicherstellen, 
da&szlig; portmap(8) auf deinem System l&auml;uft. Hier ein Beispiel von 
d865 1
a865 1
Du mu&szlig;t nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
d877 2
a878 2
Wenn du &Auml;nderungen an /etc/exports durchf&uuml;hrst, w&auml;hrend 
NFS bereits l&auml;uft, mu&szlig;t du mountd dies mitteilen, indem du den 
d887 1
a887 1
<h3>NFS Status &uuml;berpr&uuml;fen</h3>
d890 1
a890 1
Um zu &uuml;berpr&uuml;fen, ob alle Dienste laufen und bei RPC registriert 
d909 2
a910 2
<p> F&uuml;r den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
du den Status von NFS &uuml;berpr&uuml;fen kannst. Eines ist 
d913 1
a913 1
das genauere Statistiken anzeigt. F&uuml;r showmount(8), versuche 
d930 2
a931 2
zu laden, tue folgendes (NB: du mu&szlig;t nicht IP Adressen verwenden, mount 
wird Hostnamen aufl&ouml;sen):
d939 1
a939 1
Damit dein System dies beim Hochfahren wieder tut, f&uuml;ge folgendes zu 
d948 1
a948 1
Es ist wichtig, da&szlig; du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
d950 1
a950 1
fsck zu &uuml;berpr&uuml;fen!!!! Die anderen Sicherheitsoptionen wie noexec, 
d960 2
a961 2
Mit diesen Optionen k&ouml;nnen keine Ger&auml;te oder setuid Programme auf 
dem NFS Server Sicherheitsma&szlig;nahmen auf dem NFS Klient untergraben. 
d963 1
a963 1
ausf&uuml;hren willst, f&uuml;ge noexec hinzu:
d971 2
a972 2
<strong>HINWEIS:</strong> Dies bezieht sich nicht auf <strong>ALLE</strong> ADSL Provider, aber viele der Informationen k&ouml;nnen aus diesem Setup 
&uuml;bernommen werden. Dieses Setup funktioniert auf jeden Fall bei <a href="http://www.inode.at">Inode</a>, einem ADSL Provider in &Ouml;sterreich.
d978 1
a978 1
Ports</a> um mehr Informationen &uuml;ber den OpenBSD ports tree zu 
d985 2
a986 2
Unterst&uuml;tzung und pptp wirst du deinen Kernel neu kompilieren 
m&uuml;ssen und die Unterst&uuml;tzung f&uuml;r gre(4) entfernen m&uuml;ssen.
d989 1
a989 1
<blockquote>Patch, um die GRE(4) Unterst&uuml;tzung zu entfernen.
d1018 2
a1019 2
musst du ein paar Dateien f&uuml;r deine neue Verbindung editieren.
Diese packages benutzen das standarm&auml;ssige OpenBSD 
d1031 1
a1031 1
F&uuml;r eine <i>/etc/ppp/options</i> Datei wird ein Setup wie das unten vermutlich alles notwendige tun:
d1048 1
a1048 1
In <i>/etc/ppp/pap-secrets</i> geh&ouml;rt eine Zeile wie diese hier:
d1063 3
a1065 3
Im obigen Beispiel hatte unser Modem eine vorkonfigurierte Adresse von 10.0.0.138. Jetzt m&uuml;ssen wir UNSEREM Interface noch eine Adresse zuweisen.
Es ist am besten eine IP zu w&auml;hlen, die nahe an der deines MODEMS liegt, oder einfach die statische Adresse zu benutzen, die dir zugewiesen wurde.
Mehr dar&uuml;ber, wie man Interfaces IP-Adressen zuweist, kannst du in <a href="#6.1">FAQ 6.1</a> lesen.
d1075 1
a1075 1
aufbauen k&ouml;nnen.
d1086 1
a1086 1
Wir empfehlen <tt>/var/log/messages</tt> in einem weiteren Terminalfenster zu &ouml;ffnen, um m&ouml;gliche Probleme zu erkennen.
d1106 1
a1106 1
erscheinen die beiden Netzwerksegmente als eines f&uuml;r Rechner auf 
d1108 1
a1108 1
auch von einem Segment in das andere m&uuml;ssen, sie bieten also
d1111 1
a1111 1
anderen, falls n&ouml;tig.
d1116 1
a1116 1
hat, hat die Karte effektiv zwei Betriebsmodi, n&auml;mlich eine
d1124 2
a1125 2
eine eingebaute 10BASE-TX Netzwerk-Karte hat. W&auml;hrend sie alle einen 
AUI oder AAUI Stecker haben, sind die Transceiver auf Koax beschr&auml;nkt.
d1128 1
a1128 1
High-Speed-Netzwerk verbunden ist. Das Hinzuf&uuml;gen  einer zweiten 
d1137 1
a1137 1
f&uuml;r den Koax Port. <tt>fxp0</tt> ist der Link in mein restliches 
d1141 1
a1141 1
kommunizieren, als wenn sie im Rest meines Netzwerkes w&auml;ren.
d1145 2
a1146 2
Die Datei <tt>hostname.fxp0</tt> enth&auml;lt die Konfigurationsdaten 
f&uuml;r die <tt>fxp0</tt> Karte.  Diese Maschine soll DHCP machen,
d1156 1
a1156 1
Noch keinerlei &Uuml;berraschungen
d1167 1
a1167 1
Hier sagen wir dem System, es m&ouml;ge das Interface mittels 
d1169 2
a1170 2
aktivieren und auf 10BASE-2 (Koax) setzen. Keine IP Addresse oder &auml;hnliche 
Information muss f&uuml;r dieses Interface spezifiziert werden. Die 
d1174 1
a1174 1
page</a> aufgef&uuml;hrt.
d1177 1
a1177 1
Jetzt m&uuml;sen wir die Bridge aufsetzen. Bridges werden durch die Existenz einer Datei
d1180 1
a1180 1
initialisiert. Hier ist zum Beispiel ein Datei f&uuml;r meine Situation:
d1193 1
a1193 1
Es ist egal, in welche Reihenfolge die Karten aufgef&uuml;hrt werden.
d1201 1
a1201 1
W&auml;hrend es sicher auch eine Menge Anwendungen f&uuml;r eine 
d1203 1
a1203 1
etwas mit den ganzen Paketen TUN willst, w&auml;hrend sie durch deine Bridge
d1205 1
a1205 1
<a href="#PF">Packet Filter</a> dazu benutzen, den Traffic einzuschr&auml;nken,
d1210 2
a1211 2
&uuml;ber beide Interfaces fliessen, aber du nur auf einem Interface 
zu filtern brauchst. Deine "Pass all" Statements w&uuml;rden dann
d1224 1
a1224 1
trifft. Ich m&ouml;chte, dass nur Web und SSH-Traffic zu Ihnen durchkommt.
d1226 1
a1226 1
auf dem fxp0 Interface, indem wir keep state f&uuml;r die Antwort-Daten
d1250 1
a1250 1
Um die Bridge zu &uuml;berwachen und zu kontrollieren, benutze das 
d1256 2
a1257 2
<li>Es wird W&Auml;RMSTENS empfohlen, nur auf einem Interface zu filtern.
Wenn es auch m&ouml;glich ist, auf beiden zu filtern, muss man das vorher 
d1266 2
a1267 2
sehr wichtig sein, aber du solltest wissen, dass Bridges f&uuml;r jeglichen
Traffic funktionieren, nicht nur f&uuml;r IP.
d1269 1
a1269 1
<li>F&uuml;r Bridging m&uuml;ssen die NICs im "Promiscuous mode" sein -- sie
d1271 1
a1271 1
an das Interface gerichtet ist. Das hat einen h&ouml;heren Load f&uuml;r 
d1289 1
a1289 1
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[zur&uuml;ck]"></a>
d1296 1
a1296 1
$Translation: faq6.html,v 1.74 2003/07/27 16:22:36 jufi Exp $
@


1.57
log
@sync with steelix translation CVS
@
text
@a37 1
<li> <a href="#DNS"	>6.8 - DNS - Domain Name Service  - DNS, BIND und named</a>
d39 1
a39 1
<li> <a href="#Bridge"   >6.10 - Aufsetzen einer Bridge mit OpenBSD</a>
a44 1
<a name="6.0.1"></a>
a74 1
<a name="6.1"></a>
a79 1
<a name="6.1.1"></a>
a306 1
<a NAME="6.1.2"></a>
a358 1
<a NAME="6.1.3"></a>
a448 1
<a name= "6.4"></a> 
d536 1
a536 1
<a name= "6.5"></a>
a717 1
<a name= "6.6"></a>
a720 6
<H3>6.6.1 - Wie kann ich den Kernel einstellen, damit es eine h&ouml;here
Anzahl an Verbindungsversuchen und l&auml;ngere Timeouts f&uuml;r TCP Sitzungen
gibt?</h3>
Du solltest dies normalerweise nur verwenden, wenn du Routing- oder
Verbindungsprobleme hast. Nat&uuml;rlich sollten - um die beste Wirkung zu
erzielen - beide Seiten der Verbindung dieselben Werte verwenden.
a763 1
<a name="6.7"></a>
d788 1
a788 1
<A HREF="../faq13.html">IPsec</a>.  Ansonsten k&ouml;nnen andere Leute 
a965 572
<a name= "DNS"></a>
<a name="6.8"></a>
<h2>6.8 - Domain Name Service  - DNS, BIND und named</h2>
</p>

<i>Hinweis: Der folgende Abschnit wurde f&uuml;r OpenBSD 3.2 und 
fr&uuml;here  Versionen geschrieben, die noch BIND4 beinhaltet
haben. OpenBSD v3.3 enth&auml;t dagegen BIND9, das sowohl in
schriftlicher Form als auch im Internet besser dokumentiert ist
als BIND4 es war.</i> 

<p><i>Wie bei OpenBSD's BIND4, l&auml;uft BIND9 unter OpenBSD 
in einem chroot(2) und hat eine ganze Anzahl an 
Sicherheitssverbesserungen gegen&uuml;ber der Standard-Version von
BIND9:
</i>
<ul>
<li><i>arc4random() Unterst&uuml;tzung (integriert im 9.3.0-snapshot)</i>
<li><i>Rufe tzset vor dem chroot auf</i>
<li><i>&ouml;ffne /dev/null vor dem chroot</i>
<li><i>beim chroot wird das Standardger&auml;t des Systems f&uuml;r Zufallszahlen benutzt</i>
<li><i>Eine LCG (Linear Congruential Generator) Implementation wurde der libisc hinzugef&uuml;gt</i>
<li><i>Benutzen von LCG anstelle von LFSR zur ID Generierung bis sich LFSR als zuverl&auml;ssig erwiesen hat</i>
<li><i>IPv{4,6} query transport selection f&uuml;r dig(1)</i>
<li><i>ge&auml;ndertes sha1.c, um einen gcc optimization Bug (auf sparc64) zu umgehen</i>
<li><i>chroot nach <tt>/var/named</tt></i>
<li><i>setuid als user <tt>named</tt></i>
<li><i>Schreiben der pid-Datei vor dem chroot</i>
</ul>
<i>OpenBSD 3.3 User m&ouml;chten sich vielleicht das hier ansehen: </i>
<ul>
<li><i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8">named(8)</a></i>
<li><i><a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.sbin/bind/doc/arm/Bv9ARM.html"
>BIND 9 Administrator Reference Manual</a> (Diese Seiten sind auch im 
Verzeichnis <tt>/usr/share/doc/html/bind/</tt> auf deinem installierten
System vorhanden)</i>
</ul>

<h3>6.8.1 Was ist DNS?</h3>

<p>
Domain Name Service bietet die M&ouml;glichkeit, Name-zu-IP Adresse 
Aufl&ouml;sung und IP Adresse-zu-Namen Aufl&ouml;sung auf eine Anfrage zu 
generieren. Deine OpenBSD Installation ist standardm&auml;&szlig;ig als DNS 
Klient, aber nicht als DNS Server konfiguriert. D.h., deine OpenBSD 
Installation kann eine DNS Anfrage an einen Domain Name Server f&uuml;r die
Adresse einer Maschine stellen, aber sie kann nicht selbst solche DNS 
Anfrage beantworten, bis du dies nicht selbst so konfigurierst.</p>

<p>
Meine OpenBSD Maschine ist derzeit mit dem Internet durch meinen ISP verbunden, 
so da&szlig; ich mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8">nslookup(8)</a>
DNS Anfragen ausf&uuml;hren kann:
</p>

<blockquote><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
<b>165.87.201.244</b> ist der Nameserver, der geantwortet hat, weil es der 
Nameserver ist, den mein ISP mir zu meinem Konto zugeteilt hat und in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">/etc/resolv.conf</a>
eingetragen ist. Aber die Antwort war nicht authoritativ. F&uuml;r eine 
authoritative Antwort m&uuml;ssen wir den DNS Server f&uuml;r
die <i>openbsd.org</i> Dom&auml;ne finden und ihn nach der Adresse von 
<i>www.openbsd.org</i> fragen:
</p>

<blockquote><pre>
# Identifiziere die Nameserver f&uuml;r openbsd.org
# mit der Hilfe des Nameservers meines ISP.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet Adresse = 199.185.137.3
gandalf.sigmasoft.com   internet Adresse = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Verwende die gefundenen Informationen, um eine Anfrage 
# f&uuml;r eine authoritative Aufl&ouml;sung zu stellen:
# befrage zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Adresse:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
Auf <i>zeus.theos.com</i> l&auml;ft OpenBSD und ist korrekt als DNS server 
f&uuml;r die <i>openbsd.org</i> Dom&auml;ne konfiguriert.
</p>

<a name="DNS.1.1"></a>
<a name="6.8.1.1"></a>
<h3>6.8.1.1 Wo kann ich alles &uuml;ber DNS und seine Implementationen unter 
OpenBSD lernen?</h3>

<ul>
<li>Siehe die RFCs <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, 
<a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a> und 
<a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> f&uuml;r weitere 
Informationen &uuml;ber DNS zu erhalten.</li>
<li>Lies das O'Reilly Associates Buch <i><a href="../../de/books.html#6">DNS and BIND</a> </i>.</li>
<li>Lies die <a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manualseiten</a> 
vorallem die Seiten von</li>
      <ul>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8">nslookup(8)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3">gethostbyname(3)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8">named(8)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3">resolver(3)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5">resolver(5)</a>
      </ul>
</ul>

<p>
Der <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
Befehl ist besonders n&uuml;tzlich, weil er eine Dom&auml;ne befragen kann 
und Informationen zur&uuml;ckliefert, die einem Format unterliegen, das 
BIND Konfigurationsdateien sehr &auml;hnlich ist. Du kannst mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
Nameserver untersuchen, von denen du wei&szlig;t, da&szlig; sie richtig 
funktionieren, und sie mit deinen Einstellungen vergleichen.
</p>

<h3>6.8.2 Mu&szlig; meine Maschine ein Domain Name Server sein?</h3>

<p>
Wenn du dir nicht sicher bist, ob dein Rechner die Rolle eines DNS Server 
spielen soll, dann konfiguriere ihn nicht als solchen. Die OpenBSD Installation
konfiguriert nicht standardm&auml;&szlig;ig deine Maschine als einen Domain 
Name Server, obwohl alle notwendigen Dateien daf&uuml;r installiert werden. 
F&uuml;r die meisten Arbeitsplatzrechner gen&uuml;gt die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5">/etc/hosts</a>
Datei, um IP Adressen lokaler Rechner zu benennen und die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">/etc/resolv.conf</a>
Datei, um die DNS Server im Intranet oder Internet einzustellen.
</p>

<p>
Aber wenn du vielleicht doch deinen Rechner als Domain Name Server 
konfigurieren mu&szlig;t:
<ul>
<li>Wenn du ein IP LAN betreibst, f&uuml;r das du nicht auf jedem Rechner 
die "hosts" Dateien mit den lokalen IP Adressen. In so einem Fall kannst du 
deinen OpenBSD Rechner als DNS Server konfigurieren und Anfragen der anderen 
Maschinen aus deinem LAN bedienen.</li>
<ul>
<li><b>Anmerkung:</b> Es gibt keine praktische Einschr&auml;kung bzgl. der 
Anzahl von DNS Servern in einem LAN. Einige oder alle Maschinen im LAN 
k&ouml;nnen DNS Dienste anbieten, wenn sie so konfiguriert sind. Ob einige 
dieser Server als authoritativ von au&szlig;erhalb deines LANs betrachtet 
werden (oder sie &uuml;berhaupt au&szlig;erhalb deines LANs bekannt sind), 
ist ein Konfigurationsfaktor, der typischerweise eine Ebene oberhalb deines 
LANs in der Dom&auml;nenhierarchie bestimmt wird.</li>
</ul>
<li>Wenn du ein IP LAN mit Rechnern hast, die auch via DNS von Rechnern 
anderer IP LANs und WANs auffindbar sein sollen.</li>
<li>Wenn du Schwierigkeiten hast, lokale Rechnernamen auf eine IP Adresse 
aufzul&ouml;sen oder andere lokale Namen zu IP Adressen, obwohl du korrekte 
<i>/etc/hosts</i> und <i>/etc/resolv.conf</i> Dateien hast (z.B.: Netscape 
auf OpenBSD hat manchmal dieses Verhalten, weil es seinen eigenen DNS 
Aufl&ouml;ser verwendet, anstatt einfach <i>gethostbyname(3)</i> zu 
ben&uuml;tzen, um IP Adressen nachzusehen.)</li>
</ul>

<p>
Eine weitere &Uuml;berlegung ist die Ausf&uuml;hrungsgeschwindigkeit. 
Da die Namensaufl&ouml;sung ein iterativer Prozess ist, in dem der Nameserver 
wiederholende Anfragen an andere Nameserver in entfernten Dom&auml;nen 
stellt, kann die Namensaufl&ouml;sung l&auml;nger dauern, wenn du eine 
Modemverbindung ins Internet hast und deinen DNS Server nach anderen, 
entfernten IP Adressen auf der Modemleitung befragst (die ihrerseits wieder 
andere entfernte DNS Server befragen), als wenn du den Nameserver deines ISP 
befragst (der wahrscheinlich eine schnellere Verbindung zu entfernten 
Nameservern hat). 
</p>

<h3>6.8.3 Was sind die Softwarekomponenten der DNS Server?</h3>

<ul>
<li>named <i>("name daemon")</i></li>
<li>Konfigurationsdateien in der Verzeichnishierarchie unter 
<i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 Welche Versionen von BIND werden unterst&uuml;tzt?</h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
BIND ist der Name einer Spezifikation eines Dom&auml;nennamensservers mit 
einem bestimmten Verhalten. Die DNS Komponenten ergeben gemeinsam 
die Implementation von BIND. 
</p>

<p>
Es gibt drei getrennte BIND Specifikationen:
<ol>
<li>BIND 4</li>
<li>BIND 8</li>
<li>BIND 9</li>
</ol>

<p>
Standardm&auml;ssig unterst&uuml;tzt OpenBSDs <b>named</b> BIND 4.x.

<h4>6.8.3.2 Welche Alternativen zu der Standard-BIND 4.x-Implementation 
gibt, um DNS Dienste bereitzustellen?</h4>
<!-- XXXexpires - goes away when 3.2 becomes unsupported -->

<ul>
<li>Die BIND 9.x Implementation ist in <i>/usr/ports/net/bind9</i>.(Siehe <a href="../../de/ports.html">ports</a>)
</ul>

<h5>6.8.3.2.1 <u>Sicherheitsanmerkung</u></h5>

<p>
Wenn du diese alternativen Implementationen von DNS Diensten in betracht 
ziehst, dann stellst du einen kritischen Netzwerkdienst zur Verf&uuml;gung, 
dessen Software nicht dem selben Niveau an &Uuml;berpr&uuml;fung wie durch
<a href="../../de/security.html">Sicherheit</a> dem <b>named</b> name daemon in 
der Basisinstallation zu Teil wurde. Dies ist eine signifikante &Uuml;berlegung,
da, falls ein DNS Server kompromittiert wird, die Klients zu 
betr&uuml;gerischen Webseiten umgeleitet werden k&ouml;nnen.
</p>

<h3>6.8.4 Wieviel mu&szlig; ich installieren?</h3>

<p>
Wenn die standardm&auml;ssige Netzwerkinstallation korrekt bei der 
Installation von OpenBSD eingerichtet hast, dann ist bereits alles 
installiert. Du mu&szlig;t nur mehr den Nameserverdienst ("<tt>named</tt>") 
konfigurieren.
</p>

<h3>6.8.5 Wie konfiguriere ich DNS?</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
Du konfigurierst OpenBSD DNS, indem du Dateien editierst und/oder erstellst, 
die den Nameserverdienst <tt>named</tt> steuern. Diese Dateien liegen 
standardm&auml;&szlig;ig im Verzeichnis <i>/var/named</i> und dessen 
Unterverzeichnisse, haupts&auml;chlich in der Datei 
<i>/var/named/named.boot</i>, das die Initialisierungsdatei f&uuml;r 
<b>named</b> ist. Weiterhin gibt es ein paar andere notwendige 
Konfigurationsschritte in <i>/etc</i>.
</p>

<p>
In diesem Dokument werden wir den Nameserverdienst auf <i>nemo.yewtopia.com</i>
konfigurieren, der der prim&auml;re Nameserver f&uuml;r die (sehr kleine!) 
Dom&auml;ne <i>yewtopia.com</i> sein wird. Die Adresse von 
<i>nemo.yewtopia.com</i> ist <i>192.168.1.9</i>. Zwei andere Maschinen 
befinden sich im selben Subnet, <i>crater.yewtopia.com </i> auf 192.168.1.1 
und <i>earhart.yewtopia.com</i> auf 192.168.1.2.
</p>

<h4>6.8.5.1 Konfiguration in <i>/var/named</i></h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<blockquote><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain                source host/file
; type    domain   source host/file backup file
cache     .       root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></blockquote>

<p>
Dies teilt dem Initialisierungsproze&szlig; mit, in welchem Unterverzeichnis 
und unter welchem Dateinamen die Konfigurationsdateien f&uuml;r 
<i>yewtopia.com</i> zu finden sind. 

<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<blockquote><pre>
; Reverse lookup f&uuml;r localhost interface
@@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></blockquote>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<blockquote><pre>
; yewtopia.com domain database
@@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></blockquote>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<blockquote><pre>
; yewtopia domain reverse lookup database
@@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></blockquote>

<h4>6.8.5.2 Konfiguration in <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>
<p>
Stelle sicher, da&szlig; <i>/etc/resolv.conf</i> nun auf die Dom&auml;ne 
des lokalen Rechners (anstatt auf, z. B., den Nameserver deines ISPs) zeigt, 
so da&szlig; die Namensaufl&ouml;sungsanfragen auch wirklich zu dem 
<b>named</b> geschickt werden, den du konfiguriert hast!
</p>

<blockquote><pre>
domain yewtopia.com
lookup file bind
</pre></blockquote>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
Wenn du vorher die Adressen von diversen Rechnern zu der <i>/etc/hosts</i> 
Datei hinzugef&uuml;gt hattest, dann solltest du in Betracht ziehen, deine 
<i>/etc/hosts</i> Datei wieder auf Standardgr&ouml;&szlig;e zu k&uuml;rzen: 
</p>

<blockquote><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></blockquote>

<p>
Damit <b>named</b> nicht zugunsten von (m&ouml;glicherweise veralteten) 
Adressen in der <i>/etc/hosts</i> Datei &uuml;bergangen wird. <u>Stelle 
sicher, da&szlig; du zumindest den Standardeintrag<i>localhost</i></u> 
hast, oder dein Netzwerk wird nicht richtig starten!! Auch <i>nemo</i> 
mu&szlig; in seiner eigenen hosts-Datei aufscheinen, oder du wirst eine 
(eher harmlosen) Fehlermeldung zu Bootzeit bemerken,  wenn <i>/etc/netstart</i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8">route(8)</a>
aufruft, um <i>nemo</i> hinzuzuf&uuml;gen (dessen Name in <i>/etc/myname</i> 
aufscheint).
</p>

<h4>6.8.5.3 Mittels <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
die Ergebnisse untersuchen.</h4>

<blockquote><pre>
$ <strong>dig @@nemo.yewtopia.com yewtopia.com any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @@nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia.com, type = ANY, class = ANY

;; ANSWERS:
yewtopia.com.   3600    SOA    nemo.yewtopia.com.  your_id.nemo.yewtopia.com. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.com.   3600    NS      nemo.yewtopia.com.

;; ADDITIONAL RECORDS:
nemo.yewtopia.com.  3600    A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.com  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></blockquote>

<h3>6.8.6 Wie kann ich DNS starten und stoppen?</h3>

<h4>6.8.6.1 DNS starten</h4>

<p>
Der Nameserverdienst <b>named</b> wird beim Systemstart von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc</a>
gestartet, wenn die folgende Zeile (standardm&auml;&szlig;ig vorhanden) sich 
in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf</a>
befindet.
</p>

<blockquote><pre>
named_flags=NO          # f&uuml;r normal use: ""
</pre></blockquote>
 
<p>
ver&auml;ndere in
</p>

<blockquote><pre>
named_flags=""          # f&uuml;r normal use: ""
</pre></blockquote>

<p>
Beachte auch diese Zeilen in /etc/rc.conf:
</p>

<blockquote><pre>
named_user=named                # Named should not run as root unless neccesary
named_chroot=/var/named         # Where to chroot named if not empty
</ul></pre>

<p>
Diese Standardeinstellungen werden f&uuml;r beinahe alle Installationen 
korrekt sein.
</p>

<p>
Um <b>named</b> h&auml;ndisch zu starten, verwende den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a>
Befehl. Z. B.:
</p>

<blockquote><pre>
# <strong>ndc start</strong>
          oder
# <strong>ndc reload</strong>
</pre></blockquote>

<h4>6.8.6.2 DNS Stoppen</h4>

<p>
Der beste Weg, um den Nameserverdienst zu stoppen, ist den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a>
Befehl zu verwenden. Z. B.:
</p>

<blockquote><pre>
# <strong>ndc stop</strong>
</pre></blockquote>

<p>
Wenn dies fehlschl&auml;gt, finde die Proze&szlig;-ID von named und 
verwende den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1">kill(1)</a>
Befehl, um diesen Proze&szlig; zu beenden. Die PID f&uuml;r <b>named</b>, 
solange er l&auml;uft, kannst du in der ersten Zeile der Datei 
<i>/var/named/named.pid</i> finden.
</p>

<blockquote><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></blockquote>

<h4>6.8.6.3 Restarting DNS with an altered configuration</h4>

<p>
<h3>6.8.7 How do I block AXFR queries? </h3>
<p>
Beispiel:
<blockquote><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></blockquote>
<p>
Diese Information ist n&uuml;tzlich f&uuml;r das Debuggen von DNS, aber in manchen F&auml;llen willst du diesen
Output nicht in aller Welt zeigen.
Wenn du klassenloses in-addr(rfc2317) f&uuml;r reverse benutzt, k&ouml;nnte 'host -l' jede Domain anzeigen, die
dein System hostet!
Dies kann man einfach mit der 'allow-transfer' Formulierung in deinem zone file verhindern.
<br><br>
Wenn du Bind8 benutzt, musst du die Hosts spezifizieren, denen du den "Zonen-Transfer" erlauben willst, und zwar in deinen
individuellen Zone Datei(en):
<blockquote><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></blockquote>
Du kannst auch Transfers f&uuml;r alle Domains stoppen, indem du /var/named.conf anpasst und und den 'allow-transfer' Parameter 
zur options Sektion der Konfigurationsdatei hinzuf&uuml;gst:
<blockquote><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></blockquote>
Die Bind8 Methode funktioniert auch mit Bind9.<br>
Bei Bind 4 (Standard in OpenBSD) kannst du /var/named/named.boot anpassen und die 'xfrnets' Option nutzen.<br>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></blockquote><br>
Bind 4 erlaubt Transfers von ganzen Klassen, ist also nicht so exakt.
Typischerweise sind die einzigen Hosts, die Transfers durchf&uuml;hren m&uuml;ssen deine DNS Slaves und Hosts 
von denen du vielleicht 'debug'en  willst (127.0.0.1 ist meist ein guter Host, dem man Transfers erlauben sollte!)
AXFR queries zu blocken f&uuml;gt einen zus&auml;tzlichen Level an Privatsphere ein, kann aber ein sinnvolles DNS 
debugging behindern.
(Danke an <a href=mailto:ntang@@nachtwache.org>Nicholas Tang</a> f&uuml;r diesen Tip)
</p>

<h3>6.8.8 Was hast du mir nicht &uuml;ber das Aufsetzen von DNS erz&auml;hlt?</h3>
Es gibt eine Menge von Dingen, die ich dir nicht erz&auml;hlt habe, z.B. 
wie man DNS so aufsetzt, dass Anfragen f&uuml;r Intranet Domains, die von 
der root der Domain-Hierarchie aus nicht sichtbar sind, zu Servern innerhalb deines Unternehmens weitergeleitet werden.
Lies die <a href="#DNS.1.1">empfohlenen Dokumente</a>, um mehr Informationen &uuml;ber DNS zu erhalten.
</p>

<p>
a966 1
<a name="6.9"></a>
d1100 1
a1100 1
<a name= "Bridge"></a>
d1294 1
a1294 1
Originally [OpenBSD: faq6.html,v 1.174 ]
d1296 1
a1296 1
$Translation: faq6.html,v 1.73 2003/07/13 13:53:13 jufi Exp $
d1299 1
a1299 1
<small>$OpenBSD: faq6.html,v 1.174 2003/07/06 16:04:04 nick Exp $</small>
@


1.56
log
@sync with steelix translation CVS
@
text
@d69 1
a69 1
<a href="http://the.rfceditor.org/rfc.html">RFCs</a>
d1882 1
a1882 1
Originally [OpenBSD: faq6.html,v 1.173 ]
d1884 1
a1884 1
$Translation: faq6.html,v 1.72 2003/07/06 10:37:31 jufi Exp $
d1887 1
a1887 1
<small>$OpenBSD: faq6.html,v 1.173 2003/05/30 15:16:59 nick Exp $</small>
@


1.55
log
@sync with steelix translation CVS
@
text
@d444 1
a444 1
durchzuf&uuml;hren. PF ist ein seit der Version 3.0 Teil des
d448 2
a449 1
Die alte PF FAQ ist nach wie vor unter <a href="../faq6pf.html">zu lesen</a>.
d1884 1
a1884 1
$Translation: faq6.html,v 1.71 2003/07/05 20:19:13 jufi Exp $
@


1.54
log
@
sync with steelix transaltion CVS
@
text
@d21 2
a22 2
<a href="faq5.html">[Zu Sektion 5 - Kernel Konfiguration und Festplatten-Setup]</a>
<a href="faq7.html">[Zu Sektion 7 - Tastaturkontrollen]</a>
a33 1
<li> <a href="#NAT"	>6.3 - NAT - Network Address Translation</a></li>
d121 1
a121 1
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
d123 1
a123 1
        inet 127.0.0.1 netmask 0xff000000 
d126 1
d129 2
a130 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::202:b3ff:fe2b:10f7%fxp0 prefixlen 64 scopeid 0x1
d132 1
d143 1
d145 2
a146 1
gre0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1450
d173 1
a173 1
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a> - Packet Filter Logging Interface
d238 1
a238 1
&quot;deinedomaene.com&quot;.
d242 2
a243 2
$ <b>cat /etc/resolv.conf
</b>search deinedomaene.com
d438 1
a438 2
<a NAME="6.2"></a>
<a name= "PF"></a>
d440 7
a446 744
<!-- XXXrelease -->
<p>

<h4>Hinweis:  Ab OpenBSD 3.2 sind die Funtionen von <i>/etc/nat.conf</i>
in <i>/etc/pf.conf</i> eingebaut worden, die beiden Dateien somit 
verschmolzen. 
</h4>

<p>
Die neue
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><i>/etc/pf.conf</i></a>
Datei hat vier Teile:

<ul>
<li><b>Options:</b> Verschiedene Optionen, um das Verhalten von PF zu kontrollieren.
<li><b>Scrub:</b> &Uuml;berarbeitung von Paketen zur Normalisierung und Defragmentierung.
<li><b><a href="#NAT">NAT and Redirection Rules:</a></b> NAT erlaubt 
  den Zugang von vielen Maschinen durch eine IP-Adresse. Redirection erlaubt
  hereinkommende Anfragen an eine bestimmte Maschine hinter dem NAT weiterzuleiten.
<li><b>Filter Rules:</b> Erlaubt das selektive Filtern oder Blocken von Paketen, die 
   &uuml;ber eines der Interfaces laufen.
</ul>

Keine dieser Sektionen muss existieren, aber wenn, dann m&uuml;ssen sie
in der oben genannten Reihenfolge sein.


<p>
Das Packet Filter Subsystem wurde erstellt, um zwei Dinge zu tun: die Rechte von
Forwarding auf Paketlevel zu setzen und zu &uuml;berpr&uuml;fen (Paketfilter)
und das mapping von Hosts/Subnetzen zu einer Reihe von externen Adressen zu steuern
(NAT).
Die Konfigurationsdateien f&uuml;r diese zwei Dienste sind
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5">/etc/pf.conf(5)</a></i> 
und 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5">/etc/nat.conf(5)</a></i>.

<p>
Um diese Dienste auf deinem System zu starten, musst du die Datei
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
editieren und die Zeile wie folgt setzen:
</p>

<blockquote><pre>
pf=YES
</pre></blockquote>

<p>
Wenn du NAT benutzt, musst du h&ouml;chstwahrscheinlich auch den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
Wert <tt>net.inet.ip.forwarding</tt> auf 1 setzen. Das kannst du machen, indem die
relevanten Zeilen in der Datei
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a></i>
&auml;nderst und deinen Computer rebootest.

<p>
Wenn du Packet Filter in deinen Kernel einkompiliert hast, aber es nicht in deiner
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
Datei aktiviert hast, kannst du das mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8">pfctl(8)</a> Befehl
nachholen.
<p>

<blockquote><pre>
# <b>pfctl -R /etc/pf.conf</b>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

Die erste Zeile setzt den Filter mittels <i>/etc/pf.conf</i> und die zweite
aktivert das NAT mit den Regeln aus <i>/etc/nat.conf</i> (mehr zu NAT sp&auml;ter
in <a href="#NAT">Sektion 6.3, NAT</a>), und zuletzt aktiviert die letzte Zeile
PF.
</p>
Das kann man auch in einer einzigen Zeile kombinieren.

<blockquote><pre>
# <strong>pfctl -R /etc/pf.conf -N /etc/nat.conf -e</strong>
</pre></blockquote>

<p>
Wenn du &Auml;nderungen an <i>/etc/pf.conf</i> vornimmst, nachdem du
PF gestartet hast, kannst du deine Regeln neu laden, indem du die passende
Datei neu l&auml;dst:
<blockquote><pre>
# <b>pfctl -R /etc/pf.conf</b>
</pre></blockquote>

<p>
Dieses Dokument wird einige grundlegende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5">pf.conf(5)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5">nat.conf(5)</a> 
Konfigurationen weiter unten behandeln.  Du kannst dir auch das <a href="#sample_pf.conf">resultierende 
ruleset</a> ansehen, mit all den Anpassungen, die unten im Details erkl&auml;rt sind.
Weitere Packet Filter Informationen finden sich auf der
<a href="http://www.benzedrine.cx/pf.html">Packet Filter web site</a> 
und im
<a href="http://www.inebriated.demon.nl/pf-howto/">Packet Filter HOWTO</a>. 

<p>
<h3>Packet Filter</h3>

<p>
Um den Packet Filter beim Booten zu aktivieren, musst du
<i>/etc/rc.conf</i> so anpassen, dass dann <tt>pf=YES</tt> enthalten ist. Packet Filter (pf)
wird von <i>/etc/pf.conf</i> kontrolliert, das beim Booten gelesen wird. 
Eine detailliertere Erkl&auml;rung bekommt man hier:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5">pf.conf(5)</a>. 
In den folgende Beispielen wird <tt>fxp0</tt> das externe Interface zum Internet hin
darstellen. Abh&auml;ngig von deinen Netzwerkkarten in deinem Computer wird
das bei dir nat&uuml;rlich anders sein. Diese Regeln gehen von einer full-time 
Internetverbindung aus, wie man sie z.B. bei einem Webserver hat.
<p>

Packet Filter Regeln werden sequentiell vom Anfang bis zum Schluss abgearbeitet; 
das hilft jedes Paket beim Passieren jeder Regel zu beobachten, bevor es
dann seinen Zielort erreicht.

<p>Z. B. erlauben die Standardregeln, da&szlig; alle Pakete rein und raus
d&uuml;rfen:

<blockquote><pre>
pass out all 
pass in all
</pre></blockquote>

Das ist die Kurzform von:
<blockquote><pre>
pass in from any to any
pass out from any to any
</pre></blockquote>

was man auch auffassen kann als &quot;lasse alle hereinkommenden Pakete von jeder Quelle 
zu jedem Ziel passieren&quot;, mit einem eingebauten &quot;auf jedem Interface (was immer 
angenommen wenn kein Interface sepzifiziert wird) f&uuml;r jede Adress-Familie
, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&amp;sektion=4">inet (v4)</a> oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&amp;sektion=4">inet6 (v6)</a>&quot;.
<p>
Das ist nat&uuml;rlich noch kein wirklicher Filter. N&uuml;tzlichere Filter basieren auf 
der Address-Familie (IPv4 oder IPv6), Protokoll(en) 
und Port(s), die von den Diensten genutzt werden, die gefiltert werden sollen.
Jedes der in 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5">/etc/protocols(5)</a></i>
aufgef&uuml;hrten Protokolle kann entweder mit Namen oder Nummer angegeben werden, wir werden
uns allerdings nur mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4">udp(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4">icmp(4)</a>
befassen.

<p>
Nun nehmen wir mal an, wir wollten keinerlei eingehende Verbindung zum
TCP Port 3306 (MySQL) zulassen, weil die Datenbank nur von
localhost aus erreichbar sein soll. Unser "ruleset" w&uuml;rde dann wie folgt aussehen:
<ul>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</ul>

Das bedeutet &quot;blocke alle hereinkommenden IPv4 (inet) Pakete von jeder Quelle
zu jeglichem Ziel mit dem Zielport 3306.&quot;  Es ist notwendig, dass du bei jedem
port-basiertem Filter ein Protokoll angibst und die Adress-Familie spezifizierst.
Dienste, die in der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5">/etc/services(5)</a>
definiert sind, kannst du auch einfach bei ihrem Namen nennen, wie z.B. <em>www</em>
oder <em>mysql</em>.
Ein Paket, das in Richtung des TCP Port 3306 auf Interface 
<tt>fxp0</tt> hereinkommt, wird die erste &quot;pass in&quot; Regel noch passieren, und
dann von der &quot;block 
in port 3306&quot; Regel geblockt werden. Wenn du die Reihenfolge deiner "incoming" Regeln 
umgedreht hast (denke immer daran, die Reihenfolge ist wichtig):

<blockquote><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

Pakete, die an den TCP Port 3306 adressiert sind, w&uuml;rden dann passieren, da die letzte Regel
es allen Paketen erlaubt, den Filter zu passieren. Es ist wichtig, dass im Auge zu behalten,
wenn man Filter-Regeln schreibt:
<b>Die letzte passende Regel gibt den Ausschlag</b>.

<p>
Nat&uuml;rlich gibt es jeder Regel eine Ausnahme, so auch hier. Die <em>quick</em> 
Option z.B. l&auml;sst das Paket schickt das Paket gem&auml;ss der ersten daf&uuml;r passenden 
Regel weiter. Sehen wir uns mal unser obiges, fehlerhaftes Beispiel an, wenn wir
<em>quick</em> zur &quot;block in&quot; Regel hinzuf&uuml;gen:

<blockquote><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
Ein Paket, dass an unseren Host und den TCP Port 3306 adressiert ist, trifft zuerst auf die
&quot;block in quick&quot; Regel und wird sofort verworfen. Alle Pakete, die an andere Ports
oder Protokolle adressiert sind, finden keine passende Regel, bis sie unsere 
&quot;pass in&quot; Regel erreichen, die allen Paketen das Passieren gestattet.
<p>

<b>Standardm&auml;&szlig;iges Ablehnen</b>
<p> 

Die sicherste Paketfilter "policy" ist ein standardm&auml;ssiges Ablehnen.
Jeglicher Traffic, der nicht explizit erlaubt ist, wird abgelehnt.
Diese Policy ist bedeutend sicherer als jeden einzelnen zu sch&uuml;tzenden Dienst abzusichern, 
erlaubt kleinere Regelwerke, und sch&uuml;tzt auch vor einem m&ouml;glicherweise falsch
konfiguriertem Dienst, der f&auml;lschlicherweise vergessen wurde.
<p>

Sehen wir uns nun ein weiteres Beispiel-Regelwerk (ruleset) Zeile f&uuml;r Zeile an.
Hier ein Beispiel f&uuml;r einen Webserver mit einer Standard-Ablehnungs-Policy, die
SSH Verbindungen zul&auml;sst (zum Administrieren) und Verbindungen auf http (port 80) und https 
(port 443).

<blockquote><pre>
block in on fxp0 from all
pass  in on fxp0 inet proto tcp from any to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 from all
</pre></blockquote>

<p>
Das wir eingehende Verbindungen von &uuml;berall zu den Ports
22(ssh), 80(http) und 443(https) erlauben. Alle anderen Verbindungsversuche
wurden fallengelassen, und alle ausgehenden Verbindungen erlaubt. 
Das ist schon ein recht strenges Regelwerk. Aber was, wenn nur interne
Hosts aus deinem 1.1.1.0 Address-Block Zugriff auf SSH haben sollen, aber
HTTP und HTTPS von &uuml;berall aus erreichbar sein sollen ?

<blockquote><pre>
block in on fxp0 from all
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 from all
</pre></blockquote>
Recht nett, aber wenn nur eine einzige Machine (1.1.1.1) den Webserver
administrieren darf? In diesem Fall &auml;ndern wir dies:
<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>
in:
<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></blockquote>
<p>

<b>Beispielregeln</b>
<p>
Hier sind einige gute Regeln, die fast jeder gebrauchen kann (Mit der Annahme, dass
fxp0 das externe Interface mit der Anbindung ins Internet ist). Zuerst schaffen
einen einfachen Schutz gegen "address spoofing". Diese Adressen sollten normalerweise 
nicht im Internet herumfliegen, und wenn doch, ist das nicht gut, also 
blocken wir sie:
<blockquote><pre>
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \ 
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

Unser Regelwerk sieht schon recht gut aus; wenn wir alles zusammentun, sieht
das ganze wie folgt aus:

<blockquote><pre>
# adress spoofing wird geblockt
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
 
# nur unsere Administrationsmaschine darf sich auf ssh verbinden
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
 
# andere duerfen http und https erreichen
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443
 
# den Rest mit einem pauschalen block ausschliessen
block in quick on fxp0 from any to any
 
# und ausgehenden Traffic rauslassen
pass out on fxp0 from any to any
</pre></blockquote>
 
<b>Packet Logging</b>
<p>Nun, dies ist zwar schon recht gut, aber es k&ouml;nnte besser sein.
Was, wenn wir z.B. alle Verbindungsversuche zu Port 22(ssh) loggen wollten,
die von unserer Firewall blockiert werden? Einfach - daf&uuml;r hat Packet Filter 
das <em>log</em> Stichwort:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></blockquote>

Diese Regel wird erlauben, da&szlig; sich unser Administrationsrechner
auf Port 22 verbinden darf, aber alle anderen Verbindungsversuche auf Port
22 ablehnt und aufzeichnet.

Pakete, die geloggt wurden (also die mitprotokolliert worden sind) werden 
zum pflog0 Interface gesendet, das wiederum vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8">pflogd(8)</a>,
&uuml;berwacht wird, der normalerweise die Pakete im
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8">tcpdump(8)</a>
Bin&auml;rformat in die Datei <i>/var/log/pflog</i> schreibt. Der pflogd(8) wird 
standarm&auml;ssig in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a></i>
gestartet, wenn pf in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>.
eingeschaltet ist.
Lesen kannst du diese Logfiles wie folgt:
<blockquote><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></blockquote>

Man sollte wissen, dass die Benutzung von tcpdump KEINE real-time Anzeige der pflog Datei 
erm&ouml;glicht. Die kann man aber wie folgt bekommen:

<blockquote><pre>
# <b>tcpdump -i pflog0</b>
</pre></blockquote>

Man k&ouml;nnte tcpdump auch benutzen, um den Focus beim Debugging zu sch&auml;rfen:
<blockquote><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></blockquote>

Wenn man das eingibt, hat das KEINEN Einfluss auf die Daten, die in die Datei
<i>/var/log/pflog</i> geschrieben werden.  
<p>

Wenn man seine Logdateien untersucht, sollte man besondere Aufmerksamkeit 
auf das "verbose protocol decoding" von tcpdump richten (wird mittels der -v 
Kommandzeilen Option aktiviert). Tcpdump's protocol decoder haben keine
perfekte Sicherheitshistorie.  Zumindest in der Theorie ist ein 
verz&ouml;gerter Angriff &uuml;ber die "partial packet payloads" denkbar,
der vom Logging-Device aufgezeichnet wird.
<p>
Auch wer &uuml;berhaupt Zugriff auf die Logs hat, sollte man genau pr&uuml;fen. Pflogd
greift sich 96 Bytes des Paketes und loggt es. Zugriff auf die Logs kann teilweisen
Zugriff auf sensible Teile von Paketen bedeuten (wie z.B. bei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&amp;sektion=1">telnet(1)</a> oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a> Logins).

<p>
<b>Packet Logging mittels syslog</b>
<p>
In vielen Situationen ist es w&uuml;nschenswert, die Firewall-Logs im
ASCII Format zu haben und/oder sie an einen remote logging Server zu senden.
All das kann man mittels 2 kleinen Shell-Skripten und geringf&uuml;gigen
&Auml;nderungen an den OpenBSD-Konfigurationsdateien erreichen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=OpenBSD+3.2">Syslogd(8)</a>
ist der Standard-Daemon f&uuml;r das logging, er loggt in ASCII und ist 
auch in der Lage, die Logs an einen anderen, entfernten Log-Server zu 
senden.

<p>
Zuerst m&uuml;ssen wir einen User namens <em>pflogger</em> mit einer 
.nologin. Shell erzeugen. 
Der einfachste Weg dazu ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8&amp;manpath=OpenBSD+3.2">adduser(8)</a>.

<p>
Nach dem Erzeugen des Users <em>pflogger</em> erzeuge die folgenden
zwei Skripte:

<p>
<i>/etc/pflogrotate</i>

<blockquote><pre>
FILE=/home/pflogger/pflog5min.$(date "+%Y%m%d%H%M")
kill -ALRM $(cat /var/run/pflogd.pid)
if [ $(ls -l /var/log/pflog | cut -d " " -f 8) -gt 24 ]; then
        mv /var/log/pflog $FILE
        chown pflogger $FILE
        kill -HUP $(cat /var/run/pflogd.pid)
fi
</pre></blockquote>


<p>
<i>/home/pflogger/pfl2sysl</i>

<blockquote><pre>
#!/bin/sh
# feed rotated pflog file(s) to syslog
for logfile in /home/pflogger/pflog5min* ; do
        tcpdump -n -e -ttt -r $logfile | logger -t pf -p local0.info
        rm $logfile
done
</pre></blockquote>

<p>
Editiere den cron job f&uuml;r den User <em>root</em>

<blockquote><pre>
# <b>crontab -u root -e</b>
</pre></blockquote>

<p>
und f&uuml;ge die folgende zwei Zeilen ein:

<blockquote><pre>
# rotate pf log file every 5 minutes
0-59/5 *       *       *       *       /bin/sh /etc/pflogrotate
</pre></blockquote>

<p>
Erzeuge einen cron job f&uuml;r den User <em>pflogger</em>

<blockquote><pre>
# <b>crontab -u pflogger -e</b>
</pre></blockquote>

<p>
und f&uuml;ge die folgende zwei Zeilen ein:

<blockquote><pre>
# feed rotated pflog file(s) to syslog
0-59/5 *       *       *       *       /bin/sh /home/pflogger/pfl2sysl
</pre></blockquote>

<p>
F&uuml;ge die folgende Zeile in <i>/etc/syslog.conf</i> ein:

<blockquote><pre>
local0.info    /var/log/pflog.txt
</pre></blockquote>

<p>
Wenn du zu einem entfernten Log-Server loggen willst, musst du ausserdem
folgende Zeile einf&uuml;gen:

<blockquote><pre>
local0.info    @@syslogger
</pre></blockquote>

<p>
und stelle sicher, dass der Host <i>syslogger</i> in der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5&amp;manpath=OpenBSD+3.2">
/etc/hosts(5)</a> definiert wurde.

<p>
Alle geloggten Pakete werden nun nach <i>/var/log/pflog.txt</i> gesendet.
Wenn man die zweite Zeile hinzuf&uuml;gt, werden sie alle zum entfernten
Logging Host <i>syslogger</i> geschickt.

<p>
<i>/etc/pflogrotate</i> verarbeitet nun und l&ouml;scht dann <i>/var/log/pflog</i>,
so dass eine Rotation von <i>pflog</i> mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&amp;sektion=8&amp;manpath=OpenBSD+3.2">
newsyslogd(8)</a> nicht mehr notwendig und daher abgeschaltet werden sollte.
Trotzdem ersetzt <i>/var/log/pflog.txt</i> <i>/var/log/pflog</i> und 
seine Rotation sollte daher aktiviert werden.
&Auml;ndere <i>/etc/newsyslog.conf</i> wie folgt:

<blockquote><pre>
#/var/log/pflog        600     3       250     *       ZB      /var/run/pflogd.pid
/var/log/pflog.txt     600     7       *       24
</pre></blockquote>

<p>
Pf wird nun im ASCII-Format nach /var/log/pflog.txt loggen. Wenn es so 
in <em>/etc/syslog.conf</em> konfiguriert ist, wird es das Logfile
auch zu einem anderen Log-Server schicken.
Das Logging geht nicht sofort los, sondern es dauert etwa 5-6 Minuten
(dem cron-Job-Intervall) bis die geloggten Pakete in der Datei
erscheinen.

<p>
<b>Multiple Protokolle</b>
<p>
Was aber, wenn wir Verbindungen zu einem Dienst erlauben wollen, der
&uuml;ber mehrere Protokolle l&auml;uft, wie z.B. BIND, der TCP und 
UDP benutzt ?
Mit Packet Filter kannst du mehrere Regeln zu einer zusammenfassen
(mehr dazu sp&auml;ter): 
<blockquote><pre>
# Passierenlassen von DNS traffic f&uuml;r BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

Beachte die Spaces (Leerzeichen) auf beiden Seiten der '{ }' Zeichen. Das
ist viel netter, als die Variante, die du sonst benutzen m&uuml;sstest:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre></blockquote>



<p>
<a name="normalization"></a>
<b>Packet Normalization</b>
<p> 
Packet Normalization bedeutet das erneute Zusammenf&uuml;gen von 
fragmentierten Paketen und das Leeren der IP Options.
Einige BSs und Applikationen haben Schwierigkeiten mit anormalen und
fragmentierten Paketen, und daher ist es im allgemeinen richtig und gut
Pakete von den Filter-Regeln normalisieren zu lassen.
Das macht man mit Hilfe der <b>scrub</b> Direktive, die man wie folgt benutzt:
<blockquote><pre>
scrub in all
</pre></blockquote>
Das f&uuml;gt dem System eine minimale zus&auml;tzliche Last hinzu, 
und verlangt ein wenig Speicher, um die Paket-Fragmente zu cachen. 
Die Vorteile von Packet Normalization wiegen diesen kleinen Nachteil
jedoch fast jedesmal aus.

<p>
<b>IP Optionen</b>

<p>
PF blockt standardm&auml;ssig Pakete, deren IP Optionen gesetzt sind. Das kann die Arbeit
von &quot;OS fingerprinting&quot; Werkzeugen wie nmap erschweren.
Wenn du eine Anwendung hast, die das Passierenlassen solcher Pakete erfordert, wie z.B.
multicast oder IGMP, kannst du die
<b>allow-opts</b>
Direktive benutzen:

<blockquote><pre>
pass in quick on fxp0 all allow-opts
</pre></blockquote>

<p>
<b>TCP Flags, bestehende Verbindungen und keep state</b>
<p>
Packet Filter kann also Pakete auf Basis von TCP flags filtern und 
kann bereits bestehende Verbindungen verfolgen und den Status
der Verbindungen ebenso. Es wird also empfohlen, dass alle User, die
Paketen auf Basis von TCP flags filtern wollen, die Rolle jedes einzelnen
flags auch wirklich verstehen.
Wenn du z.B. alle Pakete ablehnen willst, die die FIN, URG, und PSH 
flags gesetzt haben (wie z.B. ein nmap OS fingerprinting Versuch) 
k&ouml;nntest du dazu ein Regel wie diese hier verwenden:

<blockquote><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></blockquote>

(Danke an <a href="mailto:halogen@@nol.net">Kyle Hargraves</a> f&uuml;r
diesen Tip)

Der n&auml;chste coole Trick von Packet Filter ist seine F&auml;higkeit,
sich den Zustand eine Verbindung zu merken (sog. stateful filtering). 
Den "state" (Status) zu verwalten oder zu halten, wurde zum Beispiel 
als &quot;nichts sagen, bis man angesprochen wird&quot; beschrieben, 
oder in anderen Worten: sobald eine Verbindung einmal hergestellt wurde, 
m&uuml;ssen Pakete nicht mehr die ganzen Regeln passieren.
Das ist ein sehr m&auml;chtiges Feature, das es erlaubt viel einfachere
und dennoch sicherere Regeln zu schreiben.

<p>
Als Beispiel sehen wir uns mal an, wie wir "state" in unser bisheriges Regelwerk einbauen 
k&ouml;nnen (na, schon verwirrt?). Zur Wiederholung: Wir erlauben administrativen Zugriff
aus unserem Class C-Netz auf port 22 (ssh) und erlauben hereinkommenden Web-Traffic auf den
Port 80(http) und 442 (https). Alles andere wird abgeblockt. Was aber, wenn ich z.B.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
vom Webserver wonaders hin machen will ?
Was, wenn ich 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&amp;sektion=1">lynx(1)</a> 
benutzen muss, um etwas in den FAQs nachzulesen ? Nunja, das kann ich 
zun&auml;chst nicht, weil ich ja allen einkommenden Traffic bis auf die
angebenen Ports geblockt habe. W&auml;hrend das nat&uuml;rlich das sicherste ist,
ist es mit Sicherheit auch ziemlich unbequem.
Indem man die Worte 
<em>keep state</em> in unsere &quot;pass 
out&quot; Regel einf&uuml;gt, erlauben wir automatisch, dass eingehende Pakete,
die Antworten auf unsere ausgehenden Verbindungsaufbauten sind, passieren d&uuml;rfen,
wie z.B. beim Web-Browsen. Denke daran, wir m&uuml;ssen nicht angeben, f&uuml;r welches
Protokoll wir "keep state" einbauen.

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 keep state
pass  out on fxp0 inet proto tcp all keep state
</pre></blockquote>
<p>
Diese kleine &Auml;nderung wird die Flexibilit&auml;t und Sicherheit unseres
Regelwerkes erheblich erh&ouml;hen: Zum Beispiel erlauben wir im Regelwerk
oben allen TCP traffic zu den Ports 80 &amp; 442. Das k&ouml;nnen wir noch 
weiter einschr&auml;nken. Um den Aufbau einer TCP Verbindung zu erlauben,
m&uuml;ssen wir nur den anf&auml;nglichen Handshake zulassen; nachdem
das geschehen ist, k&ouml;nnen wir den Traffic zu diesem Port blocken und
es "keep state" &uuml;berlassen, die Verbindung zu managen.
Um den anf&auml;nglichen Handshake zuzulassen brauchen wir nur Pakete
mit gesetztem SYN-Flag und nicht gesetztem ACK-Flag zuzulassen.
Dadurch, das wir nur Pakete durchlassen, die nur das SYN Flag gesetzt haben,
verhinden wir auch viele Formen des Portscanning. Flags S/SA bedeutet:
Von den Flags S (SYN) und A (ACK) darf nur S gesetzt sein. Andere Flags werden
nicht betrachtet.
Die Regeln sehen jetzt wie folgt aus:
<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
       flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 \
       flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 \
       flags S/SA keep state
block out on fxp0 inet proto tcp all
pass  out on fxp0 inet proto tcp all flags S/SA keep state
</pre></blockquote>

<p>
F&uuml;hren wir jetzt alle Dinge zusammen, indem wir alle bisherigen
Regeln einfach in ein einziges Regelwerk umwandeln.
Dieses Regelwerk wird IPv4 unterst&uuml;tzen, die Standard-Regel wird 
zun&auml;chst alles abblocken, Management-Verbindungen aus dem internen
Netzwerk (via SSH) erlauben und ebenso hereinkommenden Traffic zu den Ports
80 (http) und 443(hhtps). Es wird auch nicht routbare gespoofte
IP Adressen abblocken, und alle Pakete verwerfen, die zu fragmentiert sind,
um sie zu untersuchen. Ein recht gutes Setup f&uuml;r einen 
&ouml;ffentlichen Webserver. Und so k&ouml;nnte
<i>/etc/pf.conf</i> aussehen:
<blockquote><pre>
# Aufr&auml;umen von fragmentierten und abnormalen Paketen
scrub in all

# Das Spoofen nicht-routbarer Addressen verhindern
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# Standardm&auml;ssig alles verbieten, was nicht sp&auml;ter explizit
# erlaubt wird.
block in on fxp0 all

# Andere d&uuml;rfen http und https benutzen
pass in on fxp0 inet proto tcp from any to any port 80 \
       flags S/SA keep state
pass in on fxp0 inet proto tcp from any to any port 443 \
       flags S/SA keep state

# Ausgehender Traffic darf raus und es wird ein "state" dabei erzeugt 
# Alle Protokolle einschliesslich TCP, UDP und ICMP d&uuml;rfen raus und
# erzeugen einen "state", so das externe DNS-Server auf unsere DNS-Requests 
# (UDP) antworten k&ouml;nnen.
block out on fxp0                 all
pass  out on fxp0 inet proto tcp  all flags S/SA keep state
pass  out on fxp0 inet proto udp  all            keep state
pass  out on fxp0 inet proto icmp all            keep state
</pre></blockquote>

<p>
Obwohl das schon ganz gut aussieht, erlaubt es Packet Filter,
einige Dinge zu tun und zu nutzen, die deine 
<i>pf.conf</i> Datei besser lesbar machen und leichter zu pflegen.
</p>

<p>
<b>Sets</b>
<p>


Sets sind n&uuml;tzliche "shortcuts" zum Schreiben einfacher und sauberer 
Regel in PF.  Was w&auml;re, zum Beispiel, wenn du Verbindungen zu einem Dienst
erlauben musst, der auf verschiedenen Protokollen l&auml;uft, wie etwa BIND,
der TCP und UDP benutzt ?
<blockquote><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>
Beachte die Spaces auf beiden Seiten der '{ }' Klammern. 
</p>
<p>
Gruppen von IPs, die irgendwie miteinander in Beziehung stehen, k&ouml;nnen ebenfalls
in sets zusammengefasst werden, die &uuml;berall benutzt werden k&ouml;nnen, wo man
auch eine einzelne IP benutzen kann. Nehmen wir als Beispiel unsere anti-spoofing
Regeln von oben:
<blockquote><pre>
# Erlaube niemandem nicht-routebare Addressen zu spoofen
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
<b>Variablen-Auswertung</b>
</p>
<p>
Ein Problem der obigen Beispiel-<i>pf.conf</i>Datei ist, dass du eine Menge Zeilen
auswechseln musst, sobald du deine Netzwerkkarte oder IP-Adresse &auml;ndern musst.
Das kann man durch Variablen-Asuwertung vermindern:

<blockquote><pre>
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></blockquote>
</p>
 
<p>
<a name="sample_pf.conf"></a>
<b>Alles zusammengenommen</b>
</p>
<p>
F&uuml;gen wir nun alles zusammen und betrachten die Eleganz der Datei:
<blockquote><pre>
# Sinnvolle Variablen definieren
ExtIF="fxp0"              # External Interface
IntNet="1.1.1.0/24"       # Our internal network
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"
 
# Aufr&auml;umen bei fragmentierten und unnormalen Paketen
scrub in all
 
# Keine nicht-routbaren Addressen erlauben
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
 
# standardm&auml;ssig alle einkommenden Pakete blocken, mit Ausnahmen jener,
# die explizit erlaubt sind
block in on $ExtIF all
 
# Andere d&uuml;rfen HTTP und HTTPS benutzen
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

pass  in on $ExtIF inet proto tcp from any to any port $Services \
       flags S/SA keep state
 
# und ausgehender Traffic darf raus, 
# alle Protokolle, einschliesslich TCP, UDP und ICMP, es wird ein "state",
# erzeugt, so dass externe DNS Server auch auf unsere DNS Anfragen antworten k&ouml;nnen (UDP).
block out on $ExtIF                 all
pass  out on $ExtIF inet proto tcp  all flags S/SA keep state
pass  out on $ExtIF inet proto udp  all            keep state
pass  out on $ExtIF inet proto icmp all            keep state
</pre></blockquote>
</p>
d448 1
a448 783
<p>
Wenn du Probleme bekommst, wirst du vermutlich gerne das Logging bei bestimmten Regeln 
aktivieren, um effektiv deine Probleme l&ouml;sen zu k&ouml;nnen, wie z.B.:
<blockquote><pre>
pass in log quick on fxp0 proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8">pflogd(8)</a> schreibt Logeintr&auml;ge in <i>/var/log/pflog</i>.
Denke daran, dass <i>/var/log/pflog</i> eine Bin&auml;r-Datei ist, und von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8">tcpdump(8)</a> gelesen werden
soll, NICHT direkt von Menschen.
</p>
<p>
Wenn du die Konfigurationsdatei ver&auml;nderst, so dass jetzt in das Logfile geschrieben wird, denke daran,
dass du <b>pfctl -R /etc/pf.conf</b> durchf&uuml;hren musst, damit die &Auml;nderung auch wirksam wird !
</p>
 
<p>
<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT</h2>
<!-- XXXrelease -->

<p>
<h4>Hinweis: Ab OpenBSD 3.2 sind die NAT Funktionen in die Datei
<i>/etc/pf.conf</i> integriert und nicht mehr in der separaten 
Datei <i>/etc/nat.conf</i>, die noch in OpenBSD 3.0 und 3.1
genutzt wurde.</h4>


<p>
<h5>Hinweis: Packet Filter ist das Filtersystem in OpenBSD 3.0 und h&ouml;her.
Wenn du nach der IPF/IPNAT FAQ f&uuml;r OpenBSD 2.9 und vorher
suchst, klicke <a href="../faqipf.html">hier</a>.</h5>

<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Einf&uuml;hrung</u></h3>

<a name="nat1.1"></a>
<b>Kapiteleinf&uuml;hrung</b>

<p>
Gem&auml;&szlig; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> 
bietet NAT einen einfachen Weg, um interne Netzwerke auf eine einzige routebare 
(&quot;reale&quot;) Internetadresse umzulegen. 
Dies ist sehr n&uuml;tzlich, wenn man nicht f&uuml;r jeden Rechner des 
internen Netzwerkes eine offizielle Adresse zugewiesen bekommen hat.
Wenn man ein privates/internes Netzwerk besitzt, dann kann man diese 
(in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a> 
definierten) Adressbereiche benutzen:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

<p>
Es wird angenommen, dass der User bereits eine OpenBSD-Maschine mit zwei
Netzwerkkarten installiert und eingerichtet hat (eine
hin zum Internet und die anderen f&uuml;r das lokale Netzwerk).

<p>
<a name="nat1.3"></a>
<b>Konfiguration</b>

<p>
Als Beispiel nehmen wir das unten beschriebene System. Dein Setup
wird h&ouml;chstwahrscheinlich davon abweichen, sei also sehr
vorsichtig damit, einfach irgendetwas von hier abzutippen und
dann zu erwarten, dass das auch funktioniert.

<ul>
Intel EtherExpress Pro/100 <b>fxp0</b>
verbunden mit dem EXTERNEN LAN (oder WAN)
<b>IP Addresse: </b>24.5.0.5
<b>Netmaske: </b>255.255.255.0

Compaq Netelligent 10/100Mb <b>tl0</b>
Verbunden mit dem INTERNEN LAN
<b>IP Addresse: </b>192.168.1.1
<b>Netmaske: </b>255.255.255.0
</ul>
<br>
<b>Externe, Internet-routebare IP (vom ISP bereitgestellt, in diesem 
Beispiel ein Kabelmodemprovider)<br></b>
<ul>
<b>IP Addresse: </b>24.5.0.5
<b>Netmaske: </b>255.255.255.0
<b>Gateway: </b>24.5.0.1
</ul>
<br>
<b>LAN - Lokales Netzwerk</b><br>
<ul>
In diesem Beispiel-Szenario werden die Rechner im LAN das IP 
Adressierungsschema 192.168.1.xxx (wobei xxx eine eindeutige Nummer 
darstellt) verwenden. 
Es kann eine gro&szlig;e Anzahl verschiedener Betriebssysteme im internen 
LAN wie Windows 98, Windows NT, OpenBSD und Linux geben, aber das 
Betriebssystem des Client ist wirklch keine Sache des NAT.
F&uuml;r dieses Beispiel wird der Rechner im LAN die IP Adresse 
192.168.1.40 annehmen.
</ul>
<br>
<b>Diagramm der Konfiguration</b>
<blockquote><pre>
+-----+              +---------+         +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Rechner A
  +---- Weitere Rechner 

                              +-------------------------+
                              |         LEGENDE         |
                              +-------------------------+
                              |  NIC fxp0 - 24.5.0.5     |
                              |  NIC tl0 - 192.168.1.1  |
                              |Rechner A - 192.168.1.40 |
                              +-------------------------+

</pre></blockquote>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Einf&uuml;hrung zu NAT</b>

<p>
Jede Station im Internet ben&ouml;tigt eine einzigartige IP Addresse. 
Zumindest mit IPv4 gibt es ziemlich begrenzte Anzahl von einzigartigen
und verf&uuml;gbaren IP-Adressen, und als Ergebnis davon sind sie nicht
frei erh&auml;ltlich. Die meisten Low-Cost ISPs begrenzen daher eine Site
mit 1 bis 30 Adressen, und obwohl Organisationen mit gr&ouml;sserem
Budget sich gr&ouml;ssere Bl&ouml;cke leisten k&ouml;nnen, ist es in den
meisten F&auml;llen ohne grossen Vorteil aber mit h&ouml;herem Risiko
verbunden, jeden Computer mit einer individuellen Adresse 
im Internet zu haben.
</p>
<p>
Network Address Translation, oder NAT, (auch bekannt als &quot;IP 
Masquerading&quot; wenn du aus einem Linux-Hintergrund kommst) erlaubt 
es mehreren Computern, sich &quot;hinter&quot; einer (oder einer kleinen 
Anzahl von) IP Addressen zu verbergen. Jeder &quot;interne&quot; 
Computer hat eine lokal zugewiesene, unregistrierte IP Addresse 
(gem&auml;&szlig; <a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
und alle benutzen gleichzeitig die gleiche externe IP Addresse.
</p>

<p>
NAT arbeitet auf ziemlich einfache Weise. Wenn ein Rechner im LAN
sich mit einem Rechner im Internet verbinden will, sendet er ein TCP Paket 
mit einer Verbindungsanfrage. Innerhalb des TCP Paketdatenkopfes 
(&quot;headers&quot;) steht die Rechner IP Adresse (hier 192.168.1.40) und 
die erw&uuml;nschte Server IP Adresse (z. B. 123.45.67.89). Die Maschine 
mit NAT f&auml;ngt das TCP Paket ab und &auml;ndert die Rechner IP Adresse 
in die Adresse des Rechners, der mit dem Internet verbunden ist 
(z. B. 24.5.0.5). Dies t&auml;uscht den Server eigentlich, indem es ihn 
glauben macht, da&szlig; die Verbindung vom NAT Rechner und nicht vom 
eigentlichen Client kommt. Der Server schickt dann die Antworten 
zur&uuml;ck zum NAT Rechner. Wenn der NAT Rechner die Antwort erh&auml;lt, 
dann &uuml;bersetzt er die Zieladresse zur&uuml;ck von seiner eigenen 
IP zu der vom Client und schickt das Paket an den Client weiter. Der 
Client bekommt von alledem nichts mit und die vorget&auml;uschte 
Internetverbindung ist f&uuml;r den Benutzer und seine Anwendung 
total transparent.
</p>

<p>
Das folgende Beispiel zeigt NAT noch ein bi&szlig;chen deutlicher:
</p>

<blockquote><pre>
Client ----------------- tl0 [ NAT ] fxp0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

AUSGEHENDES TCP Paket                   AUSGEHENDES TCP Paket
Von: 192.168.1.40   &gt;&gt;=== NAT ===&gt;&gt;     Von: 24.5.0.5
Nach: 123.45.67.89                      Nach: 123.45.67.89

INCOMING TCP Paket                     EINGEHENDES TCP Paket
Von:  123.45.67.89 			 Von:  123.45.67.89
Nach: 192.168.1.40   &lt;&lt;=== NAT ===&lt;&lt;     Nach: 24.5.0.5
</pre></blockquote>

<br>
<a name="nat2.2"></a>
<b>Warum NAT verwenden</b>

<p>
In meiner neuen Wohnung bekam ich ein Kabelmodem und somit ein kleines 
Problem. Wie k&ouml;nnen meine Zimmerkameraden Internetanschlu&szlig; 
bekommen, wenn 
das Kabelmodem in meinem Zimmer steht? Ich hatte ein paar Alternativen 
wie zus&auml;tzliche IP Adressen kaufen, einen Proxyserver aufsetzen 
oder eben NAT einsetzen. 
(La&szlig; dich nicht vom Kabelmodembeispiel t&auml;uschen: NAT ist 
f&auml;hig, ein gro&szlig;es Netzwerk mit hunderten oder auch tausenden 
Computern zu maskieren!)
</p>

<p>
Es gibt viele Gr&uuml;nde, warum ich NAT aufsetzen wollte. Nummer eins: 
Geld sparen. Zwei Zimmerkameraden in meinem Haus haben ihre eigenen PCs 
und ich besitze insgesamt 3 Computer. Mein ISP erlaubt nur drei IP 
Adressen pro Haushalt. D. h., da&szlig; wir nicht genug IPs h&auml;tten, 
um jedem Rechner Internetzugang zu verschaffen.
</p>

<p>
Mit NAT hat jeder Rechner eine eindeutige (interne) IP Adresse, aber 
alle teilen sich eine IP Adresse von meinem ISP. Die Kosten sinken.
</p>

<br>
<a name="nat2.4"></a>
<b>Setup</b>

<p>
Damit NAT auf deinem OpenBSD Rechner l&auml;uft, mu&szlig;t du zun&auml;chst 
PF aktivieren. Dies geschieht einfach, indem du die unten angef&uuml;hrten 
Dateien editierst (&auml;ndere die Dateien gem&auml;&szlig; den folgenden Optionen):
</p>

<p>
<b>/etc/rc.conf</b> (diese Datei wird beim Booten f&uuml;rs Starten von Diensten gelesen)
</p>

<blockquote><pre>
pf=YES<br>
</pre></blockquote>

<p>
<b>/etc/sysctl.conf</b>
</p>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Nachdem diese &Auml;nderungen durchgef&uuml;hrt wurden, ist der Rechner endlich f&uuml;r die 
Konfiguration von NAT bereit.
</p>

<br>
<a name="nat2.5"></a>
<b>Konfiguration</b>

<p>
Der erste Schritt ist die Konfiguration der PF Regeldatei
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.1">/etc/pf.conf</a></i>).
Daf&uuml;r werden wir in diesem Dokument jeglichen Datenverkehr durch diese Firewall passieren 
lassen. Die Datei sollte so aussehen:
</p>

<blockquote><pre>
pass in all
pass out all
</pre></blockquote>

<p>
Siehe wiederum <a href="#PF">FAQ 6, Packet Filter</a> f&uuml;r weitere Informationen.
</p>

<p>
Die NAT Konfigurationsdatei 
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5&amp;manpath=OpenBSD+3.1">/etc/nat.conf</a></i>)
folgt einer sehr einfachen Syntax.
Um obige Konfiguration fortzusetzen, sollte die Datei die folgenden Eintr&auml;ge enthalten: 
</p>

<blockquote><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></blockquote>

<p>
Hier eine Erkl&auml;rung f&uuml;r die obigen Zeilen.
</p>

<dl>
<strong>"nat"</strong>
<p>
Das zeigt an, dass du eine NAT Regel aufsetzt.
</p>
</dl>

<dl>
<strong>"fxp0"</strong>
<p>
Die Netzwerkkarte, die mit dem Internet verbunden ist.
</p>
</dl>

<dl>
<b>"192.168.1.0/24"</b>
<p>
Die IP Adresse und Netzmaske (die Netzmaske ist im
CIDR Format). Kombiniert besagen sie, da&szlig; "jede IP Adresse von 
192.168.1.1 bis 192.168.1.254" umgelegt werden soll. 
</p>
</dl>

<dl>
<b>"24.5.0.5"</b>
<p>
Auf diese IP Adresse sollen die LAN IP Adressen umgelegt werden.
</p>
</dl>

<p>
<a name="nat2.6"></a>
<b>Betrieb</b>

<p>
Ist die Konfiguration erst einmal komplett, dann gibt es zwei 
M&ouml;glichkeiten, um NAT zu aktivieren. Die erste (und beste), ist, 
wenn m&ouml;glich, deinen OpenBSD Rechner zu rebooten.
Dies geschieht mit dem Befehl "<i>reboot</i>"
</p>

<p>
Wenn du NAT von der Kommandozeile starten willst, dann benutze die folgenden
Befehle:
</p>

<blockquote><pre>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
Die erste Zeile dient dazu einen Satz von NAT Regeln in PF zu laden
(und jegilche alten Regeln zu l&ouml;schen), die zweite Zeile schaltet
PF ein. Trotzdem ist ein Reboot der bessere Test, um einfach 
sicherzustellen, dass auch dann alles glatt l&auml;uft.
</p>


<p>
<b>NB:</b> Um die NAT Einstellungen neu zu laden (im Falle, da&szlig; du die 
Datei editiert hast, aber nicht rebooten willst), mu&szlig;t du nur den ersten
Befehl wiederholen. Die Einstellungen werden neu geladen. 
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 NAT Grundwissen</u></h3>

<br>
<a name="nat3.1"></a>
<b>&Uuml;berpr&uuml;fen des NAT Status</b>

<p>
Um herauszufinden, was NAT tut oder um sicherzustellen, da&szlig; die 
gew&uuml;nschten Einstellungen auch in Kraft sind, kannst du die "-ss" Option 
verwenden. Diese Option listet alle Einstellungen und laufende Sitzungen:
</p>

<blockquote><pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></blockquote>

<p>
Erkl&auml;rungen (nur die erste Zeile, die anderen sind entsprechend):
</p>

<ul>
<b>"192.168.1.40:2132"</b>
<p>
Dies zeigt dir die IP Adresse (192.168.1.40) des LAN Rechners, der NAT 
benutzt. Die Portnummer (2132) der Verbindung wird anschlie&szlig;end 
gezeigt.
</p>
</ul>

<ul>
<b>"24.5.0.5:53136"</b>
<p>
Dies zeigt, da&szlig; die Verbindung via der Adresse 24.5.0.5 und
der Portnummer 53136 ins Internet geht.
</p>
</ul>

<ul>
<b>"65.42.33.245:22"</b>
<p>
IP Adresse und Port zu dem verbunden worden ist.
</p>
</ul>

<ul>
<b>"TIME_WAIT:TIME_WAIT"</b>
<p>
Der Status, in dem sich die Verbindung, nach Glauben von PF, befindet.
</p>
</ul>

<a name="nat3.2"></a>
<b>Probleme mit FTP und NAT</b>

<p>
Es gibt ein paar Einschr&auml;nkungen bei NAT, die am h&auml;figsten
anzutreffende ist bei FTP. Man kann FTP in zwei Weisen benutzen:
aktiv oder passiv. Von diesen beiden wird passiv allgemein als die
sicherere angesehen.
</p>
<p>
Wenn ein User bei aktivem FTP sich mit einem entfernten FTP-Server 
verbindet und Informationen oder eine Datei anfordert, sendet der FTP
Client dem Server eine zuf&auml;llige Port-Nummer, auf die sich der 
FTP-Server beim Client verbindet um dort die Information hinzuschicken.
Das ist ein Problem f&uuml;r all die User, die aus dem LAN eine 
FTP-Verbindung aufbauen wollen. Wenn der FTP-Server seine Daten senden
will, verbindet er sich mit einem zuf&auml;lligen Port auf der
externen Netzwerk-Karte. Die NAT-Maschine empf&auml;ngt die Daten, hat
aber kein Mapping daf&uuml;r, und liefert das Paket nicht aus, sondern
verwirft es.
</p>
<p>
Mit passivem FTP (dem Standard mit dem OpenBSD <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
Client) fragt der Client den Server nach einem zuf&auml;lligen Port, auf dem
der Server in Erwartung der Datenverbindung lauschen wird. Der Server 
informiert den Client &uuml;ber den ausgew&auml;hlten Port, und der Client
verbindet sich dorthin, um Daten zu &uuml;bertragen. Dummerweise ist das nicht
immer m&ouml;glich oder w&uuml;nschenswert.
ftp(1) benutzt diesen Modus standardm&auml;ssig; um aktives FTP zu erzwingen
benutze die -A Option von ftp, oder schalte den passiven Modus mit folgendem
Befehl 
</dt></dl>
am ftp&gt; prompt
</p>
ab:
<dl><dt>
<pre>passive off
</pre>
<P>

Packet Filter bietet eine weitere L&ouml;sung f&uuml;r diese Situation, 
umleiten von FTP Traffic durch einen FTP Proxy-Server, ein Prozess, der 
deinen FTP-Traffic durch die Filter "leitet". Der FTP-Proxy, der von 
OpenBSD und PF genutzt wird, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.1">ftp-proxy(8)</a>.
Um ihn zu aktivieren, musst du sowas wie das hier in deine 
<i>/etc/nat.conf</i> Datei tun:
<blockquote><pre>
rdr on tl0 proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>
Eine Kurzerkl&auml;rung dieser Zeile ist: "Verkehr auf dem inneren 
Interface wird auf den Proxy-Server umgeleitet, der auf dieser Maschine
auf dem Port 8081 l&auml;uft." 
</p>
<P>
Dazu muss der Proxy-Server nat&uuml;rlich gestartet werden und auf der  
OpenBSD Maschine laufen, das macht man, indem man die folgende Zeile in 
die 
<i>/etc/inetd.conf</i> einf&uuml;gt:
<blockquote><pre>
127.0.0.1:8081 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></blockquote>
und entweder das System neu botet, oder dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>.
ein 'HUP' Signal schickt.
Ein Weg dazu ist das folgende Kommando:
<blockquote><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></blockquote>
Du musst sicherstellen, dass der FTP-Proxy auf Port 8081 l&auml;uft, dem 
selben Port an den das rdr Statement FTP Traffic sendet. Die Wahl von 
Port 8081 ist zuf&auml;llig, obwohl 8081 eine gute Wahl ist, da er 
nicht f&uuml;r andere Anwndungen belegt ist.
</p>

<br>
<a name="nat3.3"></a>
<b>Datenverkehr umleiten</b>

<p>
F&uuml;r manche Anweungen ist es notwendig, ein- oder ausgehenden 
Verkehr umzuleiten f&uuml;r ein bestimmtes Protokoll und/oder einen 
bestimmten Port zu einer bestimmten Maschine hinter dem Filtersystem 
umzuleiten.
Ein Beispiel daf&uuml;r ist ein Rechner im LAN, der einen Webserver
beinhaltet, der von aussen erreichbar sein muss. Ein Beispiel w&auml;re 
ein Webserver in deinem interne Netzwerk, der von aussen erreichbar 
sein muss, (oder nat&uuml;rlich der bereits erw&auml;hnte FTP-Proxy(8)).
Eingehende Verbindungen zu deiner g&uuml;ltigen Internetadresse 
k&ouml;nnen keine Verbindung herstellen, es sei denn, auf der
NAT Box l&auml;uft auch ein Webserver. Daher benutzen wir die
NAT 'rdr' Direktive in der Regeldatei, um festzulegen, wohin
eine bestimmte Verbindung hingeleitet werden soll.
</p>

<p>

F&uuml;r unser Beispiel nehmen wir an, da&szlig; ein Webserver im LAN mit 
der IP Adresse 192.168.1.80 existiert. Die NAT Regeldatei ben&ouml;tigt 
eine neue Direktive. F&uuml;ge eine Zeile wie folgende in 
<i>/etc/nat.conf</i> ein: 
</p>

<blockquote><pre>
rdr on fxp0 proto tcp from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></blockquote>

<p>
Die Erkl&auml;rung:
</p>

<ul>
<b>"rdr"</b>
<p>
Diesen Befehl gibst du NAT: NAT soll eine Verbindung umleiten. 
</p>
</ul>


<ul>
<b>"on fxp0"</b>
<p>
Die mit dem Internet verbundene Netzwerkkarte. 
</p>
</ul>

<ul>
<b>"from any to any"</b>
<p>
Das gibt an, welche IP Addressen umgelitet werden sollen (von jeder, die 
auf fxp0 hereinkommt, so wie oben beschrieben, zu jeder Ziel-IP)
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
Der hereinkommende Port (80), der umgeleitet werden soll. Die Zahl 
"80" mu&szlig; nicht explizit benutzt werden. Du kannst auch 
"port www" verwenden. Wenn du den Namen anstelle der Nummer verwendest, 
dann m&uuml;ssen auch Name und die korrespondierende Zahl in der 
Datei /etc/services existieren.
</p>
</ul>

<ul>
<b>"192.168.1.80 port 80"</b>
<p>
Die IP Addresse der Maschine im LAN, zu der Pakete umgeleitet werden 
sollen. Denk daran, dass der Ziel-Port NICHT dem port entsprechen muss,
auf dem das Paket hereinkommt. Das folgende ist beispielsweise
sowohl korrekt, als auch potentiell n&uuml;tzlich:
<pre>
rdr on fxp0 proto tcp from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
Diese Zeile lenkt hereinkommende Verbindungen auf Port 8080 zu einem
Webserver auf dessen Port 80 um, der im internen Netzwerk l&auml;uft.
</p>
</ul>

<p>
Danach lade die NAT Regeln neu und die Umleitungen werden sofort in Kraft treten.
</p>
<p>
<b>Verneinung</b>
</p>
<p>
Manchmal muss man Ausnahmen f&uuml;r eine NAT oder Umleitungs-Regel
festlegen. Hier ein Beispiel: AOL Instant Messenger ist bekannt daf&uuml;r
, dass er sich &uuml;ber jeden verf&uuml;gbaren Port durch eine
Firewall schleicht. Du kannst entdecken, dass sich der FTP-Proxy nicht 
mit dem AIM vertr&auml;gt, sobald der sich den Port 21 aussucht.
Wenn du das auch als schlecht betrachtest (viele Leute verbringen
jede Menge Zeit damit AIM zu blocken!), kannst du die IP-Adressen
der AIM-Server einfach vom Traffic ausnehmen, der von deiner FTP-Proxy
Zeile umgeleitet wird. Das geht etwa wie folgt:
<blockquote><pre>
rdr on tl0 proto tcp from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>
Interpretation: Leite eingehenden Traffic auf tl0 Richtung Port 21 um, aber
NICHT von 64.12.163.199 (die AIM Server. mit denen die User Probleme hatten)
zu localhost port 8081 (wo sinnvollerweiser der FTP-Proxy wartet).  
Leider gibt es recht viele AIM-Server, wenn dich diese Anwendung interessiert,
wirst du ein wenig mit den IP-Adressen herumpobieren m&uuml;ssen
(64.12.0.0/16 k&ouml;nnte produktiver sein, aber auch einige Nicht-AOL-Sites
treffen). 
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
Der Unterschied zwischen NAT und einem applikationsbasierten Proxy liegt darin,  
da&szlig; die Proxysoftware als Mittelsmann zwischen Internet und den im LAN 
verbundenen Rechnern agiert. Nur mu&szlig; f&uuml;r jede Anwendung und 
Internetverbindung ein daf&uuml;r geeigneter Proxy bereitstehen. Nicht alle 
Anwendungen k&ouml;nnen dies (vor allem Spiele nicht). 
NAT "mapped" dein internes Netzwerk transparent, sodass es mit dem Internet 
verbunden ist. Der einzige Sicherheitsvorteil von Proxysoftware gegen&uuml;ber 
NAT ist, da&szlig; die Proxysoftware sicherheitstechnisch im Vorteil ist, wenn 
man den Inhalt filtern kann; z. B. Makroviren f&uuml;r Windowsrechner filtert, 
oder gegen Buffer-overflows sch&uuml;tzt, udgl. Diese Filter zu administrieren 
bedeutet viel Arbeit.
</p>

<p>
<a name="nat3.5"></a>
<b>Redirection und reflection</b>

<p>
Oft werden redirection Regeln benutzt, um hereinkommende Verbindungen vom
Internet zu einem lokalen Server mit privater Adresse im LAN umzuleiten, 
wie etwa hier:

<pre>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server port 80
</pre>

<p>
Wenn aber die redirection Regel von einem Client aus dem LAN getestet
wird, bemerkt man, dass sie nicht funktioniert.
Der Grund ist, dass redirection Regeln nur f&uuml;r Regeln gelten,
die auch &uuml;ber das entsprechende Interface hereinkommen ($ext_if, 
das externe Interface, in diesem Fall).
Sich mit der externen Adresse der Firewall von einem Host aus dem
LAN zu verbinden, heisst aber nicht zwangsl&auml;ufig, dass die Pakete
auch durch das externe Interface kommen.
Der TCP/IP stack auf der Firewall vergleicht die Zieladresse des 
einkommenden Paketes mit seiner eigenen Adresse und Aliasen und 
entdeckt Verbindungen zu sich selbst, sobald sie das interne Interface
passiert haben. Solche Pakete gehen physikalisch nicht durch das externe 
Interface, und der Stack simuliert das auch in keiner Weise.
pf sieht diese Pakete nie auf dem externen Interface, und daher
greift die redirection Regel auch nicht.

<p>
Eine zweite redirection Regel f&uuml;r das interne Interface einzuf&uuml;gen
hat nicht fen gew&uuml;nschten Effekt.
Wenn der lokale Client sich zur externen Addresse der Firewall verbindet,
kommt das erste Paket des TCP handshake bei der Firewall durch das interne
Interface an.
Die redirection Regel greift und die Ziel-Adresse wird mit der des internen
Servers ersetzt. Das Paket wird &uuml;ber das interne Interface weitergeleitet,
und erreich den internen Server.
Aber die Quell-Adresse wurde nicht ver&auml;ndert, und enth&auml;lt somit
immernoch die lokale Adresse, somit sendet der Server seine Antwort
direkt daran. Die Firewall bekommt die Antwort nie zu Gesicht, und hat
daher keine Chance, die &Auml;nderung sauber durchzuf&uuml;hren.
Der Client hingegen erh&aulm;lt eine Antwort von einer Maschine, die
er nie erwartet hat, und verwirft das Paket, der TCP handshake 
schl&auml;gt fehl, und keine Verbindung kann zustande kommen.

<p>
Trotzdem ist es oft w&uuml;schenswert f&uuml;r die Clients aus dem LAN
sich transparent mit dem selben internen Server als externe Clients zu 
verbinden.
F&uuml;r dieses Problem gibt es mehrere L&ouml;sungen.

<p>
<b>Split horizon DNS</b>
<p>
Es ist m&ouml;glich, DNS-Server zu konfigurieren, dass die Anfragen
lokaler Clients anders beantwortet werden, als die externer Clients,
und zwar so, dass die internen Clients auch die interne Adresse
des Servers erhalten.
Sie verbinden sich direkt mit dem Server, ohne &uuml;berhaupt
mit der Firewall in Ber&uuml;hrung zu kommen.
Das reduziert den lokalen Traffic, da die Pakete ja gar nicht
mehr bis zur Firewall m&uuml;ssen.

<p>
<b>Den Server in ein separates lokales Netzwerk stellen</b>
<p>
Ein zus&auml;tzliches Netzwerk-Interface einzubauen und den lokalen 
Server in ein eigenes, daf&uuml;r gedachtes Netzwerk (DMZ) zu stellen,
erlaubt das Umleiten der Verbindungen von lokalen Clients in der selben
Weise wie das Umleiten externer Verbindungen.
Die Benutzung verschiedener Netzwerke hat verschiedene Vorteile,
einschliesslich der Verbesserung der Sicherheit durch die Isolierung
des Servers von den anderen Maschinen.
Sollte der Server (der ja in unserem Fall aus dem Internet erreichbar
ist) jemals kompromittiert werden, kann er die lokalen Clients nicht
direkt erreichen, da alle Verbindungen durch die Firewall gehen 
m&uuml;ssen.

<p>
<b>TCP proxying</b>
<p>
Ein generischer TCP Proxy kann auf der Firewall aufgesetzt werden, der
entweder auf dem Port lauscht, der weitergeleitet werden soll oder der die
Verbindungen auf dem internen Interface umlenkt.
Wenn sich ein lokaler Client mit der Firewall verbindet, akzeptiert der
Proxy die Verbindung, &ouml;ffnet eine zweite Verbindung, und zwar hin 
zum Server, und leitet dann die Daten zwischen den beiden Verbindungen
jeweils weiter.

<p>
Einfache Proxies kann man mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1">nc(1)</a>
erzeugen.
Der folgende <i>/etc/inetd.conf</i> Eintrag erzeugt einen horchenden Socket,
der an die loopback-Adresse und Port 5000 gebunden ist.
Die Verbindungen werden nach Port 80 auf dem Server 192.168.1.10 weitergeleitet.

<pre>
127.0.0.1:5000 stream tcp wait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
</pre>

<p>
Die folgende redirection Regel leitet von port 80 auf dem internen Interface
an den Proxy weiter:

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; 127.0.0.1 port 5000
</pre>

<p>
<b>RDR und NAT Kombination</b>
<p>
Mit einer zus&auml;tzlichen NAT-Regel auf dem internen Interface kann die
fehlende Adress-Umsetzung, die oben beschrieben wurde, erg&auml;nzt werden. 

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
</pre>

<p>
Das f&uuml;hrt dazu, dass der erste Paket vom Client erneut
&uuml;bersetzt wird, wenn es durch das interne Interface 
zur&uuml;ckgeschickt wird, wobei die Quell-Adresse des Clients mit
der internen Adresse der Firewall ersetzt wird.
Der interne Server wird dann an die Firewall seine Antwort schicken,
die dann mittels NAT und RDR wiederum an den Client weiterleitet.
Dieses Konstrukt ist recht komplex, das es zwei separate states f&uuml;r
jede solche Verbindung erzeugt.
Man muss sicherstellen, dass die NAT Regel keinen anderen Teil der Pakete
betrifft, zum Beispiel Verbindungen von externen Clients (durch andere
Weiterleitungen) oder der Firewall selbst.
Bedenke, dass die obige rdr Regel den TCP/IP Stack dazu veranlasst, Pakete, die
auf dem inneren Interface ankommen, so zu sehen, dass sie eine Zieladresse
aus dem inneren Netzwerk haben.
Um zu verhindern, dass der Stack ICMP redirect messages versendet (und damit
dem Client erz&auml;hlt, dass sein Ziel direkt erreichbar ist, und daher die
reflection kaputtmacht), schalte redirects auf dem Gateway mittels 

<pre>
# <strong>sysctl -w net.inet.ip.redirect=0</strong>
</pre>

ab.
Im allgemeinen sollten man eine der anderen genannten L&ouml;sungen 
vorziehen.

<p>
<a name="nat4.0"></a>
<b>6.3.4 Links und Querverweise</b>

<p>
OpenBSD Dateien:
<ul>
<li>/etc/nat.conf - NAT Regeldatei
<li>/etc/rc.conf - muss man editieren, damit NAT und PF beim Booten gestartet werden
<li>/etc/sysctl.conf - editieren, damit IP Forwarding aktiviert wird
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5&amp;manpath=OpenBSD+3.1">nat.conf man page</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.1">pfctl man page</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>
d503 1
a503 1
        option  domain-name "xyz.mil";
d514 2
a515 2
anzuh&auml;ngende Dom&auml;ne xyz.mil ist (d. h., wenn der Benutzer schreibt 
'telnet joe', dann wird an joe.xyz.mil gesendet). Es wird auf die DNS Server 
d985 33
d1869 2
a1870 2
<a href= "faq5.html">[Zu Kapitel 5 - Kernelkonfiguration]</a>
<a href= "faq7.html">[Zu Kapitel 7 - Tastatureinstellungen]</a>
d1881 1
a1881 1
Originally [OpenBSD: faq6.html,v 1.168 ]
d1883 1
a1883 1
$Translation: faq6.html,v 1.70 2003/04/09 18:38:29 jufi Exp $
d1886 1
a1886 1
<small>$OpenBSD: faq6.html,v 1.168 2003/04/04 17:49:08 nick Exp $</small>
@


1.53
log
@
sync with steelix translation CVS
@
text
@d3367 1
a3367 1
$Translation: faq6.html,v 1.69 2003/02/16 11:44:14 jufi Exp $
@


1.52
log
@
s/IPSec/IPsec
@
text
@d4 1
a4 1
<title>6.0 - Netzwerk</title>
d19 7
a25 1
<h2><font color="#E00000">6.0 - Netzwerk</font></h2>
d61 2
a62 3
<a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">
Understanding IP addressing</a> (oder 
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">hier</a>)
d167 1
d206 1
a206 1
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX media-opt full-duplex
d225 2
a226 2
Der n&auml;chste Schritt ist das Einstellen deines Gateways. Dazu trag
einfach die IP deines Gateways in die Datei <b>/etc/mygate</b> ein. 
d270 3
d363 1
a363 1
6.1.3 - Einrichten von Aliases auf deiner Netzwerkkarte.</h3>
d438 1
d1203 1
d1359 1
a1359 1
192.168.1.35 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89
d1362 1
a1362 1
Von: 192.168.1.35   &gt;&gt;=== NAT ===&gt;&gt;     Von: 24.5.0.5
d1546 3
a1548 3
TCP  192.168.1.35:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.35:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.35:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
d1556 1
a1556 1
<b>"192.168.1.35:2132"</b>
d1558 1
a1558 1
Dies zeigt dir die IP Adresse (192.168.1.35) des LAN Rechners, der NAT 
d1930 12
d2243 1
d2277 5
a2281 4
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.
d2285 2
a2286 1
It is also possible to add or remove ports from the current list.
d2298 1
a2298 1
<p> NFS, oder Network File System (Netzwerkdateisystem), wird verwendet, um 
d2333 13
d2672 1
d2693 1
d2721 1
d2743 1
d3352 3
a3354 3
<a href= "index.html">[Zur&uuml;ck zum Hauptindex]</a>
<a href= "faq5.html">[Zu Kapitel 5.0 - Kernelkonfiguration]</a>
<a href= "faq7.html">[Zu Kapitel 7.0 - Tastatureinstellungen]</a>
d3365 1
a3365 1
Originally [OpenBSD: faq6.html,v 1.154 ]
d3370 1
a3370 1
<small>$OpenBSD: faq6.html,v 1.154 2002/11/10 17:59:05 nick Exp $</small>
@


1.51
log
@
cleaning up keywords and description
@
text
@d2293 1
a2293 1
<A HREF="../faq13.html">IPSec</a>.  Ansonsten k&ouml;nnen andere Leute 
d2296 1
a2296 1
l&auml;&szlig;t. Es gibt mehrere Angriffe, die m&ouml;glich sind. Wenn IPSec 
d3324 1
a3324 1
$Translation: faq6.html,v 1.68 2003/01/17 14:02:59 jufi Exp $
@


1.50
log
@
sync with steelix translation CVS
@
text
@d5 1
a5 1
<link rev= "made" href= "mailto:www@@openbsd.org">
d9 1
a9 1
<meta name="description" content="Die OpenBSD FAQ Seiten - FAQ 6">
d12 1
a12 1
<meta name="copyright" content="This document copyright 1998-2002 by OpenBSD.">
d3324 1
a3324 1
$Translation: faq6.html,v 1.67 2003/01/15 22:42:16 jufi Exp $
@


1.49
log
@
sync
@
text
@d9 2
a10 2
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq">
d3324 1
a3324 1
$Translation: faq6.html,v 1.66 2002/11/11 20:34:59 jufi Exp $
@


1.48
log
@
sync with badlands translation CVS
@
text
@a563 1
</p>
d572 1
a572 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp:sektion=4">tcp(4)</a>,
a575 1
</p>
a769 1
</p>
d792 1
a792 1
Zuerst m&uulm;ssen wir einen User namens <em>pflogger</em> mit einer 
a905 1
</p>
a925 1
</p>
a929 1
</p>
a943 1
</p>
d978 1
a978 1
</p>
d987 1
a987 1
</p>
d1007 1
a1007 1
</p>
d1041 1
a1041 1
</p>
d1076 1
a1076 1
# (UDP) antworten k&oum;nnen.
d1082 1
a1082 1
</p>
d1624 1
a1624 1
rdr on tl0 from any to any port 21 -&gt; 127.0.0.1 port 8081
d1680 1
a1680 1
rdr on fxp0 from any to any port 80 -&gt; 192.168.1.80 port 80
d1729 1
a1729 1
rdr on fxp0 from any to any port 8080 -&gt; 192.168.1.35 port 80
d1753 1
a1753 1
rdr on tl0 from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8081
d1792 1
a1792 1
rdr on $ext_if from any to $ext_if port 80 -&gt; $server port 80
d3322 1
a3322 1
Originally [OpenBSD: faq6.html,v 1.153 ]
d3324 1
a3324 1
$Translation: faq6.html,v 1.65 2002/11/05 21:43:40 jufi Exp $
d3327 1
a3327 1
<small>$OpenBSD: faq6.html,v 1.153 2002/11/05 21:45:02 jufi Exp $</small>
@


1.47
log
@
sync with badlands translation CVS
@
text
@d1 1
d6 1
d15 3
a17 1
<body bgcolor= "#ffffff" text= "#000000">
d19 2
a20 3
<h2>
<font color="#E00000">6.0 - Netzwerk</font>
<hr></h2>
d22 2
a23 1
<ul><h3>Inhaltsverzeichnis</h3>
d35 1
a35 1
<li><a href="#Bridge"   >6.10 - Aufsetzen einer Bridge mit OpenBSD</a>
a36 1
</p>
d39 6
a44 4
<a name= "Intro"></a>
<p><a NAME="6.0.1"></a>
<h2>
6.0.1 - Bevor wir weiter gehen</h2>
d48 1
a48 1
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">
d50 1
a50 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&sektion=1">netstat(1)</a>.
d55 3
a57 2
<A HREF="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding IP addressing</a>
(oder <a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">hier</a>)
d71 2
a72 1
<a name= "Setup"></a>
d84 4
a87 3
Typ, nicht nach Verbindungsart benannt. Du kannst sehen, ob deine Netzwerkkarte
initialisiert wurde, entweder schon beim Booten oder auch sp&auml;ter mittels des
Befehls <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&sektion=8">dmesg(8)</a>. 
d89 1
a89 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>
d91 3
a93 3
dmesg f&uuml;r eine Intel Fast Ethernet Netzwerk-Karte, die als Ger&auml;tenamen 
fxp hat.
<ul>
d96 1
a96 1
</pre></ul>
d98 5
a102 5
<a href="../../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> f&uuml;r 
deine Plattform nach. Du wirst eine Liste vieler bekannte Karten und ihre
OpenBSD Ger&auml;te-Namen finden (wie etwa fxp), zusammen mit einer Nummer, die vom
Kernel zugewiesen wird, und du hast den sogenannten "interface Name" (wie
z.B. fxp0).
d105 3
a107 2
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem du das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>
d110 2
a111 3
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface,
eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&sektion=4">fxp(4)</a>.
</p>
d113 3
a115 2
<ul>
<pre>$ <b>ifconfig -a</b>
d143 1
a143 1
</pre></ul>
d146 27
a172 23
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> 
gibt uns eine Menge mehr Informationen, als wir zu diesem Zeitpunkt ben&ouml;tigen.
Nat&uuml;rlich sehen wir trotzdem unser Interface. Im obigen Beispiel ist die Netzwerkkarte bereits 
konfiguriert. Das ist offensichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, sprich die 
Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;. 
Ausserdem sind die <strong>UP</strong> und <strong>RUNNING</strong> Flags gesetzt.
</p>
<p>
Schlussendlich f&auml;llt auf, das standardm&auml;ssig eine Menge mehr Interfaces aktiviert sind.
Dies sind virtuelle Interfaces, die verschiedene Funktionen haben. Informationen dazu findest 
du auf den folgenden man pages:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion=4">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&sektion=4">pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4">sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=4">ppp</a> - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4">bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&sektion=4">vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&sektion=4">gif</a> - Generic IPv4/IPv6 Tunnel Interface
d180 2
a181 1
<ul><pre>
d183 1
a183 1
</pre></ul>
d185 1
a185 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5">hostname.if(5)</a> man page.)
d189 2
a190 2
<ul>
<pre>$ <b>cat /etc/hostname.fxp0
d192 1
a192 1
</pre></ul>
d199 1
a199 1
<ul><pre>
d201 1
a201 1
</pre></ul>
d203 3
a205 3
(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der Verbindungen
auf Voll-Duplex gestellt sind ! Wenn du keine besonderen Anforderungen hast,
kannst du diese media settings einfach ignorieren.)
d208 3
a210 2
Oder vielleicht willst du auch spezielle flags f&uuml;r ein einzelnes Interface 
benutzen. Das Format der Datei &auml;ndert sich dabei nicht besonders!
d213 1
a213 1
<ul><pre>
d216 1
a216 1
</pre></ul>
d220 7
a226 6
einfach die IP deines Gateways in die Datei <b>/etc/mygate</b> ein. Dies erlaubt
das Aktivieren deines Gateways beim Starten. Jetzt solltest du deine Nameserver
eintragen und die Datei <b>/etc/hosts</b> einrichten. F&uuml;r die Nameserver
ben&ouml;tigst du eine Datei namens <b>/etc/resolv.conf</b>. Mehr &uuml;ber
das Format dieser Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">resolv.conf(5)</a>
d232 2
a233 2
<ul>
<pre>$ <b>cat /etc/resolv.conf
d238 1
a238 1
</pre></ul>
d245 2
a246 2
<ul>
<pre># <b>sh /etc/netstart
d251 1
a251 1
</pre></ul>
d258 1
a258 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> 
d261 2
a262 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&sektion=1">netstat(1)</a> oder 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8">route(8)</a> 
d267 1
a267 1
<ul><pre>
d295 1
a295 1
</pre></ul>
d308 1
a308 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&sektion=4">IPv4</a> 
d316 1
a316 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>
d318 1
a318 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5">/etc/sysctl.conf</a>
d323 3
a325 3
<ul>
<pre>net.inet.ip.forwarding=1
</pre></ul>
d329 1
a329 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a> 
d334 2
a335 2
<ul>
<pre># <b>sysctl -w net.inet.ip.forwarding=1
d337 1
a337 1
</pre></ul>
d342 1
a342 1
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&sektion=8">routed(8)</a>,
d358 1
a358 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>
d360 1
a360 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc(8)</a> Skript gelesen,
d391 1
a391 2
<ul>
<pre>
d397 2
a398 2
</pre>
</ul>
d404 1
a404 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>
d409 3
a411 3
<ul>
<pre># <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></ul>
d417 2
a418 2
<ul>
<pre>$ <b>ifconfig -A</b>
d423 1
a423 1
</pre></ul>
d431 23
a453 3
<h5>Hinweis: Packet Filter ist das Paket-Filter-System in OpenBSD 3.0 und 
sp&auml;ter. Wenn du nach den IPF/IPNAT FAQ f&uuml;r OpenBSD 2.9 und 
vorher suchst, klicke <a href="../faqipf.html">hier</a>.</h5>
d461 1
a461 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf(5)</a></i> 
d463 1
a463 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf(5)</a></i>.
d467 1
a467 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>
d471 1
a471 1
<ul><pre>
d473 1
a473 1
</pre></ul>
d477 1
a477 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>
d480 1
a480 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5">/etc/sysctl.conf(5)</a></i>
d485 1
a485 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>
d487 1
a487 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&sektion=8">pfctl(8)</a> Befehl
d491 1
a491 1
<ul><pre>
d495 1
a495 1
</pre></ul>
d504 1
a504 1
<ul><pre>
d506 1
a506 1
</pre></ul>
d512 1
a512 1
<ul><pre>
d514 1
a514 1
</pre></ul>
d518 2
a519 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">pf.conf(5)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">nat.conf(5)</a> 
d535 1
a535 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">pf.conf(5)</a>. 
d549 1
a549 1
<ul><pre>
d552 1
a552 1
</pre></ul>
d555 1
a555 1
<ul><pre>
d558 1
a558 1
</pre></ul>
d563 1
a563 1
, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&sektion=4">inet (v4)</a> oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&sektion=4">inet6 (v6)</a>&quot;.
d570 1
a570 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&sektion=5">/etc/protocols(5)</a></i>
d573 3
a575 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&sektion=4">udp(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&sektion=4">icmp(4)</a>
d593 1
a593 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&sektion=5">/etc/services(5)</a>
d602 1
a602 1
<ul><pre>
d606 1
a606 1
</pre></ul>
d619 1
a619 1
<ul><pre>
d623 1
a623 1
</pre></ul>
d647 1
a647 1
<ul><pre>
d653 1
a653 1
</pre></ul>
d663 1
a663 2
<ul>
<pre>
d669 1
a669 2
</pre>
</ul>
d672 1
a672 2
<ul>
<pre>
d674 1
a674 2
</pre>
</ul>
d676 1
a676 2
<ul>
<pre>
d678 1
a678 2
</pre>
</ul>
d688 1
a688 1
<ul><pre>
d693 1
a693 1
</pre></ul>
d698 1
a698 1
<ul><pre>
d717 1
a717 1
</pre></ul>
d725 1
a725 1
<ul><pre>
d728 1
a728 1
</pre></ul>
d736 1
a736 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&sektion=8">pflogd(8)</a>,
d738 1
a738 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>
d741 1
a741 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc(8)</a></i>
d743 1
a743 1
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>.
d746 1
a746 1
<ul><pre>
d748 1
a748 1
</pre></ul>
d753 1
a753 1
<ul><pre>
d755 1
a755 1
</pre></ul>
d758 1
a758 1
<ul><pre>
d760 1
a760 1
</pre></ul>
d777 129
a905 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&sektion=1">telnet(1)</a> oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&sektion=1">ftp(1)</a> Logins).
</p>
d916 1
a916 1
<ul><pre>
d919 1
a919 1
</pre></ul>
d924 1
a924 1
<ul><pre>
d927 1
a927 1
</pre></ul>
d943 1
a943 1
<ul><pre>
d945 1
a945 1
</pre></ul>
d963 1
a963 1
<ul><pre>
d965 1
a965 1
</pre></ul>
d979 1
a979 1
<ul><pre>
d981 1
a981 1
</pre></ul>
d1000 1
a1000 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&sektion=1">ssh(1)</a>
d1003 1
a1003 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&sektion=1">lynx(1)</a> 
d1015 1
a1015 1
<ul><pre>
d1021 1
a1021 1
</pre></ul>
d1037 1
a1037 1
<ul><pre>
d1047 1
a1047 1
</pre></ul>
d1060 1
a1060 1
<ul><pre>
d1088 1
a1088 1
</pre></ul>
d1105 1
a1105 1
<ul><pre>
d1107 1
a1107 1
</pre></ul>
d1115 1
a1115 1
<ul><pre>
d1121 1
a1121 1
</pre></ul>
d1131 1
a1131 1
<ul><pre>
d1136 1
a1136 1
</pre></ul>
d1145 1
a1145 1
<ul><pre>
d1177 1
a1177 1
</pre></ul>
d1183 1
a1183 1
<ul><pre>
d1185 2
a1186 2
</pre></ul>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&sektion=8">pflogd(8)</a> schreibt Logeintr&auml;ge in <i>/var/log/pflog</i>.
d1188 1
a1188 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a> gelesen werden
a1196 30
<h3>Unterschiede zwischen PF und IPF</h3>
</p>
<p>
Packet Filter (PF) wurde entworfen. um sehr kompatibel mit IPF's 
<i>ipf.rules</i> Datei zu sein. Trotzdem ist PF nicht einfach ein 
Austausch-Ersatz f&uuml;r IPF.
Die grossen Syntax-Unterschiede f&uuml;r (pf.conf) Regeln sind wie folgt:
</p>
<ul>
<li><b>group und head:</b> Diese Optionen werden nicht l&auml;nger benutzt, 
da die Filter-Regeln automatisch optimiert werden. Wenn du deine alten Regels&auml;tze
von IPF migrierst, solltest du alle <em>group</em>
oder <em>head</em> Definitionen l&ouml;schen, deine Regeln von Hand ordnen, und sie dabei 
gleich auf ge&auml;nderte Semantik pr&uuml;fen.</li>
<li><b>level:</b> Beim logging akzeptiert PF keine <em>level</em> Option mit dem log Schl&uuml;sselwort,
da das Logging nicht von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&sektion=8">syslogd(8)</a>, 
sondern von einem separaten Logging-Daemon gemacht wird.  
Um einen bestimmten Teil des Traffic zu untersuchen, wie man das mit der <em>level</em>
Option machen k&ouml;nnte, benutze eine der verf&uuml;gbaren Optionen von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>.</li>
<li><b>keep frags:</b>  Das wurde durch die Normalisierung ersetzt, die die 
<a href="#normalization">scrub</a> Option vornimmt.</li>
<li><b>@@n Rules:</b>  PF unterst&uuml;tzt kein Voranstellen von Regeln mittels <em>@@n</em>,
wie IPF das tut, wo dann die Regeln an bestimmten Punkten in der Regelliste eingef&uuml;gt werden.  
Um dir die Nummern anzusehen, die PF deinen Regeln gegeben hat, benutze 
<tt>pfctl -sr</tt></li>
</ul>
 
 <p>
d1202 7
a1211 1
</p>
d1250 9
a1258 9
Intel EtherExpress Pro/100 <b>fxp0</b><br>
verbunden mit dem EXTERNEN LAN (oder WAN)<br>
<b>IP Addresse: </b>24.5.0.5<br>
<b>Netmaske: </b>255.255.255.0<br>
<br>
Compaq Netelligent 10/100Mb <b>tl0</b><br>
Verbunden mit dem INTERNEN LAN<br>
<b>IP Addresse: </b>192.168.1.1<br>
<b>Netmaske: </b>255.255.255.0<br>      
d1264 3
a1266 3
<b>IP Addresse: </b>24.5.0.5<br>
<b>Netmaske: </b>255.255.255.0<br>
<b>Gateway: </b>24.5.0.1<br>
d1282 1
a1282 1
<ul><pre>
d1298 1
a1298 1
</pre></ul>
d1353 1
a1353 1
<ul><pre>
d1364 1
a1364 1
</pre></ul>
d1409 1
a1409 1
<ul><pre>
d1411 1
a1411 1
</pre></ul>
d1417 1
a1417 1
<ul><pre>
d1419 1
a1419 1
</pre></ul>
d1432 1
a1432 1
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5&manpath=OpenBSD+3.1">/etc/pf.conf</a></i>).
d1437 1
a1437 1
<ul><pre>
d1440 1
a1440 1
</pre></ul>
d1448 1
a1448 1
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5&manpath=OpenBSD+3.1">/etc/nat.conf</a></i>)
d1453 1
a1453 1
<ul><pre>
d1455 1
a1455 1
</pre></ul>
d1461 1
a1461 1
<ul>
d1466 1
a1466 1
</ul>
d1468 1
a1468 1
<ul>
d1473 1
a1473 1
</ul>
d1475 1
a1475 1
<ul>
d1482 1
a1482 1
</ul>
d1484 1
a1484 1
<ul>
d1489 1
a1489 1
</ul>
d1491 1
d1507 1
a1507 1
<ul><pre>
d1510 1
a1510 1
</pre></ul>
d1540 1
a1540 1
<ul><pre>
d1545 1
a1545 1
</pre></ul>
d1605 1
a1605 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&sektion=1">ftp(1)</a>
d1627 1
a1627 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&sektion=8&manpath=OpenBSD+3.1">ftp-proxy(8)</a>.
d1630 1
a1630 1
<ul><pre>
d1632 1
a1632 1
</pre></ul>
d1642 1
a1642 1
<ul><pre>
d1644 1
a1644 1
</pre></ul>
d1646 1
a1646 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&sektion=8">inetd(8)</a>.
d1649 1
a1649 1
<ul><pre>
d1651 1
a1651 1
</pre></ul>
d1686 1
a1686 1
<ul><pre>
d1688 1
a1688 1
</pre></ul>
d1759 1
a1759 1
<ul><pre>
d1761 1
a1761 1
</pre></ul>
d1784 1
a1784 1
wenn den Inhalt filtern kann; z. B. Makroviren f&uuml;r Windowsrechner filtert, 
d1789 141
d1945 2
a1946 2
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5&manpath=OpenBSD+3.1">nat.conf man page</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&sektion=8&manpath=OpenBSD+3.1">pfctl man page</a>
d1961 1
a1961 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&sektion=8">dhclient(8)</a>
d1967 1
a1967 1
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
d1997 1
a1997 1
Und die Netzwerkkarten, auf denen dhcpd <b>lauschen</b> soll, stehen in /etc/dhcpd.interfaces.
d2022 1
a2022 1
Wenn du dhcpd von der Befehlszeile starten willst, nachdem du /etc/dhcpd.conf 
d2025 1
a2025 1
# <strong>dhcpd -q fxp0</strong>
d2027 2
a2028 2
Wobei fxp0 die Netzwerkkarte ist, auf der DHCP serviert werden soll. 
Die -q Option setzt die Ausgabe von dhcpd auf ruhig, ansonsten ist sie sehr 
d2037 1
a2037 1
(wobei 192.168.92.55 die IP deines Windows oder Samba Servers ist.)
d2084 1
a2084 1
<ul><pre><strong>
d2086 1
a2086 1
</strong></pre></ul>
d2101 1
a2101 2
<ul>
<pre>
d2107 1
a2107 2
</pre>
</ul>
d2131 1
a2131 2
<ul>
<pre>
d2139 1
a2139 2
</pre>
</ul>
d2154 1
a2154 1
<ul><pre>
d2156 1
a2156 1
</pre></ul>
d2324 1
a2324 1
<ul><pre>
d2330 1
a2330 1
</pre></ul>
d2359 1
a2359 1
<ul><pre>
d2361 1
a2361 1
</pre></ul>
d2370 1
a2370 1
<ul><pre>
d2373 1
a2373 1
</pre></ul>
d2382 1
a2382 1
</pre></ul>
d2393 1
a2393 1
<ul><pre>
d2406 1
a2406 1
</pre></ul>
d2417 1
a2417 1
<ul><pre>
d2421 1
a2421 1
</pre></ul>
d2433 1
a2433 1
<ul><pre>
d2435 1
a2435 1
</pre></ul>
d2444 1
a2444 1
</pre></ul>
d2456 1
a2456 1
</pre></ul>
d2488 1
a2488 1
<ul><pre>
d2496 1
a2496 1
</pre></ul>
d2508 1
a2508 1
<ul><pre>
d2538 1
a2538 1
</pre></ul>
d2711 1
a2711 1
<ul><pre>
d2723 1
a2723 1
</pre></ul>
d2732 1
a2732 1
<ul><pre>
d2742 1
a2742 1
</pre></ul>
d2746 1
a2746 1
<ul><pre>
d2761 1
a2761 1
</pre></ul>
d2765 1
a2765 1
<ul><pre>
d2779 1
a2779 1
</pre></ul>
d2791 1
a2791 1
<ul><pre>
d2794 1
a2794 1
</pre></ul>
d2804 1
a2804 1
<ul><pre>
d2808 1
a2808 1
</pre></ul>
d2825 1
a2825 1
<ul><pre>
d2853 1
a2853 1
</pre></ul>
d2867 1
a2867 1
<ul><pre>
d2869 1
a2869 1
</pre></ul>
d2875 1
a2875 1
<ul><pre>
d2877 1
a2877 1
</pre></ul>
d2883 1
a2883 1
<ul><pre>
d2899 1
a2899 1
<ul><pre>
d2903 1
a2903 1
</pre></ul>
d2913 1
a2913 1
<ul><pre>
d2915 1
a2915 1
</pre></ul>
d2926 1
a2926 1
<ul><pre>
d2931 1
a2931 1
</pre></ul>
d2939 1
a2939 1
<ul><pre>
d2949 1
a2949 1
</pre></ul>
d2959 1
a2959 1
<ul><pre>
d2969 1
a2969 1
</pre></ul>
d2972 1
a2972 1
<ul><pre>
d2976 1
a2976 1
</pre></ul>
d2983 1
a2983 1
</pre></ul><br>
d3024 1
a3024 1
<ul>Patch, um die GRE(4) Unterst&uuml;tzung zu entfernen.
d3042 1
a3042 1
</pre></ul>
d3069 1
a3069 1
<ul><pre>
d3076 1
a3076 1
</pre></ul>
d3085 1
a3085 1
<ul><pre>
d3088 1
a3088 1
</pre></ul>
d3106 1
a3106 1
<ul><pre>
d3108 1
a3108 1
</pre></ul>
d3116 1
a3116 1
<ul><pre>
d3119 1
a3119 1
</pre></ul>
d3123 1
a3123 2
<ul>
<pre>
d3125 1
a3125 1
</pre></ul>
d3138 1
a3138 1
Eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4">Bridge</a>
d3169 1
a3169 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&sektion=4"><tt>fxp0</tt></a>)
d3171 1
a3171 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4"><tt>ep0</tt></a>)
d3203 1
a3203 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>
d3208 1
a3208 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4">man
d3214 1
a3214 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&sektion=5"><tt>bridgename.bridge0</tt></a>. 
d3329 1
a3329 1
Originally [OpenBSD: faq6.html,v 1.144 ]
d3331 1
a3331 1
$Translation: faq6.html,v 1.61 2002/08/06 20:59:15 jufi Exp $
d3334 1
a3334 1
<small>$OpenBSD: faq6.html,v 1.144 2002/07/25 22:06:57 nick Exp $</small>
@


1.46
log
@
sync with badlands translation CVS
@
text
@d31 1
d782 5
a786 3
Da einige Anwendungen und auch ganze Betriebssysteme Probleme mit abnormen oder 
fragmentierten Paketen haben, ist es manchmal vorteilhaft, die Pakete erst zu 
normaliseren, bevor sie zu ihrem endg&uuml;ltigen Bestimmungsort weiterreisen.
d791 4
a794 3
Das das zus&auml;tzliche Last auf dem System erzeugt, gibt es keinen Grund, diese
Anweisung zu benutzen, es sei denn, das System sch&uuml;tzt ein Ger&auml;lt mit einer
schlechten Implementierung von TCP/IP.
d1535 1
a1535 1
Ein Beispiel daf&uulm;r ist ein Rechner im LAN, der einen Webserver
d2865 181
d3061 1
a3061 1
Originally [OpenBSD: faq6.html,v 1.141 ]
d3063 1
a3063 1
$Translation: faq6.html,v 1.59 2002/07/14 14:46:54 jufi Exp $
d3066 1
a3066 1
<small>$OpenBSD: faq6.html,v 1.141 2002/07/12 02:51:35 nick Exp $</small>
@


1.45
log
@
sync with badlands translation CVS
@
text
@d450 1
a450 1
Datei aktiviert hast, kannst du mit dem
d2876 1
a2876 1
Originally [OpenBSD: faq6.html,v 1.140 ]
d2878 1
a2878 1
$Translation: faq6.html,v 1.58 2002/07/02 09:38:38 jufi Exp $
d2881 1
a2881 1
<small>$OpenBSD: faq6.html,v 1.140 2002/07/02 01:17:58 nick Exp $</small>
@


1.44
log
@
typos, better grammar
@
text
@d1992 1
a1992 1
   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871
d1996 2
a1997 2
   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
d2834 1
a2834 1
# <strong>/usr/local/sbin/pptp 10.0.0.138 &</strong>
d2845 1
a2845 1
% <strong>kill -9 [pid of pptp]</strong>
d2876 1
a2876 1
Originally [OpenBSD: faq6.html,v 1.138 ]
d2878 1
a2878 1
$Translation: faq6.html,v 1.57 2002/06/28 21:08:26 jufi Exp $
d2881 1
a2881 1
<small>$OpenBSD: faq6.html,v 1.138 2002/06/24 12:09:54 espie Exp $</small>
@


1.43
log
@
sync with badlands translation CVS
@
text
@d61 1
a61 1
Lies nach, wie sie arbeiten sollten. Die RFCs definieren mehrere (tausend)
d83 1
a83 1
fxpi hat.
d89 1
a89 1
<a href="../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> f&uuml;r 
d162 1
a162 1
der <b>/etc/hostname.xxx</b> Datei. Wobei der Name deiner Karte den Platz
d314 1
a314 1
der folgende Befehl als root ausgef&uuml;hrt werden mu&szlig;.
d1984 1
a1984 1
Wieder ein eigener sysctl Befehl daf&uuml;r.  Siehe 
d2878 1
a2878 1
$Translation: faq6.html,v 1.56 2002/06/25 23:30:30 jufi Exp $
@


1.42
log
@
sync with badlands translation CVS
@
text
@@


1.41
log
@
sync with badlands translation CVS
@
text
@d3 1
a3 1
<title>6.0 - Netzwerken</title>
d16 1
a16 1
<font color="#E00000">6.0 - Netzwerken</font>
d88 1
a88 1
Wenn du deinen Ger&auml;lte-Namen nicht weisst, sieh bitte in der 
d138 2
a139 2
Nat&uuml;rlich sehen wir trotzdem unser Interface. Im obugen Beispiel ist die Netzwerkkarte bereits 
konfiguriert. Das ist offesichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, sprich die 
d659 1
a659 1
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
d805 1
a805 1
pass in quick on fxp0 allow-opts
d1025 1
a1025 1
pass in log quick on fxp0 from 1.1.1.0/24 to any port 22
d1085 8
a1092 8
Gem&auml;&szlig; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> bietet NAT
einen einfachen Weg, um interne Netzwerke auf eine einzige routebare (&quot;reale&quot;) 
Internetadresse umzulegen. 
Dies ist sehr n&uuml;tzlich, wenn man nicht f&uuml;r jeden Rechner des internen Netzwerkes eine 
offizielle Adresse zugewiesen bekommen hat.
Wenn man ein privates/internes Netzwerk besitzt, dann kann man die 
(in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a> definierten) Adressbereiche 
benutzen:
d1100 3
a1102 3
The user is assumed to have already set up
and configured an OpenBSD machine with two network cards (one
connected to the Internet and the other to the local network).
d1104 1
a1104 1
<br>
d1109 4
a1112 4
So sind die Computer eingerichtet, die in diesem Dokument beschrieben werden. Deine werden 
von diesen abweichen, aber der Zweck dieses Dokumentes ist, dir eine &Uuml;bersicht zu verschaffen, 
damit du diese Information f&uuml;r deine Bed&uuml;rfnisse verwenden kannst.
</p>
d1115 4
a1118 1
<b>Computer Betriebssystem: </b>OpenBSD v2.7 i386<br>
d1120 4
a1123 11
<b>Netzwerkkarten: </b>
<ul>
	NetGear 10/100MB <b>dc0</b><br>
	Verbunden mit dem EXTERNEN LAN (oder WAN)<br>
	<b>IP Adresse: </b>24.5.0.5<br>
	<b>Netzmaske: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>dc1</b><br>
	Verbunden mit dem INTERNEN LAN<br>
	<b>IP Adresse: </b>192.168.1.1<br>
	<b>Netzmaske: </b>255.255.255.0<br>	
d1126 2
a1127 1
<b>Externe, Internet-routebare IP (vom ISP bereitgestellt, in diesem Beispiel ein Kabelmodemprovider)<br></b>
d1129 3
a1131 3
	<b>IP Adresse: </b>24.5.0.5<br>
	<b>Netzmaske: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
d1136 8
a1143 6
In diesem Beispiel werden die Rechner im LAN das IP Adressierungsschema 
192.168.1.xxx (wobei xxx eine eindeutige Nummer darstellt) verwenden. 
Es gibt eine gro&szlig;e Anzahl verschiedener Betriebssysteme im internen LAN wie Windows 98,
Windows NT, OpenBSD und Linux. Jeder Rechner ist mit einem Hub, der f&uuml;r den internen 
Gebrauch bereitsteht, verbunden. F&uuml;r diese Dokument und dessen Beispiele wird der 
Rechner im LAN die IP Adresse 192.168.1.40 annehmen.
d1149 1
a1149 1
| Hub |--------- dc1 |   NAT   | dc0 ----| Internet |
d1158 2
a1159 2
                              |  NIC dc0 - 24.5.0.5     |
                              |  NIC dc1 - 192.168.1.1  |
d1175 18
a1192 14
Da immer mehr und mehr Firmen und Private das Internet benutzen, 
mu&szlig; jeder eine IP Adresse haben. &Ouml;ffentliche IP Adressen sind immer 
schwieriger zu bekommen. Die L&ouml;sung f&uuml;r viele Leute ist Network 
Address Translation (oder "NAT"). NAT ist ein sehr einfaches, aber 
sehr wirkungsvoller Weg, um dein LAN mit dem Internet zu verbinden, 
ohne IP Adressen kaufen oder mieten zu m&uuml;ssen. NAT ist unter Linuxbenutzern 
auch als "IP Masquerading" bekannt.
</p>

<p>
Wenn NAT richtig eingerichtet ist, erlaubt es den Benutzern des internen 
LANs, das Internet mit einer anderen IP Adresse (jene von deinen Provider) 
zu benutzen. Jeder Rechner im LAN benutzt diese eine IP Adresse (transparent) 
vom Rechner mit der vom ISP zugewiesenen IP Adresse.
d1196 1
a1196 1
NAT arbeitet auf verbl&uuml;ffend einfache Weise. Wenn ein Rechner im LAN
d1200 12
a1211 10
die erw&uuml;nschte Server IP Adresse (z. B. 123.45.67.89). Die Maschine mit NAT 
f&auml;ngt das TCP Paket ab und &auml;ndert die Rechner IP Adresse in die Adresse des 
Rechners, der mit dem Internet verbunden ist (z. B. 24.5.0.5). Dies t&auml;uscht 
den Server eigentlich, indem es ihn glauben macht, da&szlig; die Verbindung vom 
NAT Rechner und nicht vom eigentlichen Rechner A kommt. Der Server schickt 
dann die Antworten zur&uuml;ck zum NAT Rechner. Wenn der NAT Rechner 
die Antwort erh&auml;lt, dann &uuml;bersetzt er die Zieladresse zur&uuml;ck von seiner 
eigenen IP zu der von Rechner A und schickt das Paket an Rechner A weiter. 
Rechner A bekommt von alledem nichts mit und die vorget&auml;uschte Internetverbindung 
ist total transparent.
d1219 2
a1220 2
Rechner ---------------- dc1 [ NAT ] dc0 ---------- Internetserver
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 ----- 123.45.67.89
d1223 1
a1223 1
Von:  192.168.1.40   &gt;&gt;=== NAT ===&gt;&gt;     Von:  24.5.0.5
d1227 1
a1227 1
Von:  123.45.67.89 			Von:  123.45.67.89
d1237 8
a1244 6
Problem. Wie k&ouml;nnen meine Zimmerkameraden Internetanschlu&szlig; bekommen, wenn 
das Kabelmodem in meinem Zimmer steht? Ich hatte ein paar Alternativen wie 
zus&auml;tzliche IP Adressen kaufen, einen Proxyserver aufsetzen oder eben NAT 
einsetzen. 
(La&szlig; dich nicht vom Kabelmodembeispiel t&auml;uschen: NAT ist f&auml;hig, ein gro&szlig;es 
Netzwerk mit hunderten oder auch tausenden Computern zu maskieren!)
d1248 5
a1252 5
Es gibt viele Gr&uuml;nde, warum ich NAT aufsetzen wollte. Nummer eins: Geld sparen. 
Zwei Zimmerkameraden in meinem Haus haben ihre eigenen PCs und ich besitze 
insgesamt 3 Computer. Mein ISP erlaubt nur drei IP Adressen pro Haushalt.
D. h., da&szlig; wir nicht genug IPs h&auml;tten, um jedem Rechner Internetzugang zu 
verschaffen.
d1261 1
a1261 1
<a name="nat2.3"></a>
d1266 1
a1266 1
IPF und NAT aktivieren. Dies geschieht einfach, indem du die unten angef&uuml;hrten 
d1274 3
a1276 4
<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>
d1282 3
a1284 3
<ul>
	net.inet.ip.forwarding=1
</ul>
d1292 1
a1292 1
<a name="nat2.4"></a>
d1296 3
a1298 2
Der erste Schritt ist die Konfiguration der IPF Regelsatzdatei (<i>/etc/ipf.rules</i>).
Daf&uuml;r werden wir in diesem Dokument jeden Datenverkehr durch diese Firewall passieren 
d1303 2
a1304 2
pass in from any to any
pass out from any to any
d1308 1
a1308 1
Siehe wiederum <a href="#6.2">FAQ 6.2</a> f&uuml;r weitere Informationen.
d1312 3
a1314 1
Die NAT Konfigurationsdatei (<i>/etc/ipnat.rules</i>) folgt einer sehr einfachen Syntax.
d1319 1
a1319 2
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32
d1327 1
a1327 1
<strong>"map"</strong>
d1329 1
a1329 2
Der Befehl an ipnat. Er besagt, da&szlig; dieser Eintrag die IP Adressen zwischen 
LAN und the Internet &auml;ndert.
d1334 1
a1334 1
<strong>"dc0"</strong>
d1345 1
a1345 16
192.168.1.1 bis 192.168.1.254" umgelegt werden soll. Wenn du die CIDR 
nicht verwenden willst, dann kannst du "/24" f&uuml;r 
"/255.255.255.0" verwenden.
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
Diese IP Adresse und Netzmaske sind die IP Adresse, auf 
die die LAN IP Adressen umgelegt werden.  /32 bedeutet eine einzige 
IP Adresse.  Du kannst also auf /24, oder 256 IP Adressen (oder auf /27,
oder wieviele Bits du auch immer w&uuml;nscht) umlegen!! Dies ist
n&uuml;tzlich, wenn du  mehrere tausend Rechner hinter deinem NAT hast....
(Nat&uuml;rlich ist dies nur n&uuml;tzlich, wenn diese /24 &uuml;ber deinen 
OpenBSD Rechner gerouted werden!)
d1350 1
a1350 1
<b>"portmap tcp/udp 10000:60000"</b>
d1352 1
a1352 2
Dies legt alle tcp/udp Pakete
auf Ports von 10000 auf 60000.
a1355 28
<p>
Die zweite Zeile hat beinahe den selben Eintrag au&szlig;er f&uuml;r den 
letzten Teil. Dies bedeutet f&uuml;r ipnat, auch alle anderen (nicht 
tcp/udp Pakete, die bereits von der ersten Zeile erfa&szlig;t worden sind) 
zu jenen Ports umzulegen, die erfragt werden (z. B. ICMP und andere 
Protokolle). Wenn dies einmal in dieser Datei ist, dann hat man alles, um 
den IPF Dienst zu betreiben.
</p>

<br>

<a name="nat2.5"></a>
<b>Selektives NAT</b>

<p>
Du m&ouml;chstest NAT vielleicht auf einige Adressbereiche beschr&auml;nken.
Aufbauend auf das obige Beispiel nehmen wir an es g&auml;be Hosts auf dem 
24.5.0.0/28 Netzwerk, f&uuml;r das dein NAT gateway als simpler Router
agieren soll, und zwar ohne Adressumsetzung.
Du kannst die "adress translation" f&uuml;r Netzwerkverkehr, der von dc0 in dieses
Subnetz geht, wie folgt unterdr&uuml;cken:
</p>

<ul><pre>
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -&gt; 24.5.0.5/32
</pre></ul>

d1360 3
a1362 4
NAT zu betreiben ist auch ein sehr einfacher Vorgang. Ist die Konfiguration 
erst einmal komplett, dann gibt es zwei M&ouml;glichkeiten, um NAT zu aktivieren. 
Die erste (und beste, um die Rebootphase zu testen), ist, deinen OpenBSD Rechner 
zu rebooten.
d1367 1
a1367 1
Wenn du ipnat von der Kommandozeile starten willst, dann benutze die folgenden
d1372 2
a1373 2
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
d1377 4
a1380 11
Die erste Zeile aktiviert IPF (NB: NAT setzt auf IPF auf, daher mu&szlig; 
IPF initialisiert und gestartet werden, bevor NAT geladen werden kann).
Die Optionen der Kommandozeile "-Fa" kl&auml;ren alle noch existierende 
Eintr&auml;ge. "-f /etc/ipf.rules" sagt IPF, wo die Regeldatei gefunden werden 
kann. "-E" ist die Option, um den IPF Dienst zu aktivieren.
</p>

<p>
Die zweite Kommandozeile aktiviert NAT. "-CF" kl&auml;rt alle existierenden 
Entr&auml;ge in der NAT Tabelle. "-f /etc/ipnat.rules" sagt NAT, 
wo die NAT Regeldatei zu finden ist. NAT l&auml;uft nun. So einfach ist das.
d1386 1
a1386 1
Datei editiert hast, aber nicht rebooten willst), mu&szlig;t du nur den zweiten
d1400 1
a1400 1
gew&uuml;nschten Einstellungen auch in Kraft sind, kannst du die "-l" Option 
d1405 4
a1408 6
# <b>ipnat -l</b>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  &lt;- -&gt; 24.5.0.5  13463 [129.128.5.191 80]
d1412 1
a1412 2
Der Zweck der ersten beiden Zeilen ist, die Einstellungen von /etc/ipnat.rules 
zu best&auml;tigen. Die Zeile(n) darunter zeigen die aktiven NAT Verbindungen.
d1416 1
a1416 1
<b>"MAP 192.168.1.40  2473"</b>
d1418 3
a1420 2
Dies zeigt dir die IP Adresse des LAN Rechners, der NAT benutzt. Die Portnummer 
der Verbindung wird anschlie&szlig;end gezeigt.
d1425 1
a1425 1
<b>"&lt;- -&gt;"</b>
d1427 2
a1428 2
Dies zeigt, da&szlig; NAT den Datenverkehrflu&szlig; in beiden Richtungen 
behandelt.
d1433 1
a1433 1
<b>"24.5.0.5  13463"</b>
d1435 1
a1435 2
Dies stellt dar,  das&szlig; die Verbindung zum Internet &uuml;ber 
die IP Adresse 24.5.0.5 und Port 13463 abgewickelt wird.
d1440 1
a1440 1
<b>"129.128.5.191 80"</b>
d1442 1
a1442 1
Zuletzt werden IP Adresse und Port der Zieladresse angezeigt.
d1447 1
a1447 1
<b> Einschr&auml;nkungen von NAT (bei FTP)</b>
d1450 34
a1483 22
Es gibt ein paar Einschr&auml;nkungen von NAT. Eine ist bei FTP. Wenn ein Benutzer 
sich zu einem entfernten FTP Server verbindet und Informationen oder Dateien 
verlangt, wird der FTP Server eine Verbindung zum Klient aufbauen und die Daten 
auf einem willk&uuml;rlichen freien Port &uuml;bertragen. 
Dies ist ein Problem f&uuml;r Benutzer innerhalb des LAN. 
Denn der FTP Server sendet seine Informationen an die externe Netzwerkkarte 
auf einem willk&uuml;rlichen Port. Der NAT Rechner wird dies zwar empfangen, 
aber weil es keine Umlegungsregeln f&uuml;r dieses unbekannte Paket oder f&uuml;r 
diesen Kanal gibt, wird er das Paket verwerfen und nicht liefern.

<p>
Die L&ouml;sung daf&uuml;r ist, das FTP Programm in "passive mode" zu setzen. 
Dies teilt dem Server mit, da&szlig; du dich selbst aktiv zum Server verbinden 
willst. Wenn du nun eine Verbindung nach draussen machst, wird NAT deine Verbindung 
richtig behandeln. 
<P>
IP Filter bietet eine andere L&ouml;sung f&uuml;r dieses Problem an:
ein FTP Proxy, der im NAT Quelltext eingebaut ist.
Um ihn zu aktivieren, f&uuml;ge etwas wie folgendes VOR deinen anderen NAT Regeln 
ein.
<PRE>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 proxy port ftp ftp/tcp
a1484 8
Mit dieser Regel wird der Kernel deine FTP Verbindungen auf den 
"PORT" Befehl vom FTP Programm &uuml;berwachen und wird die IP Adresse und 
Port mit seiner eigenen externen IP Adresse austauschen und einen Port 
seiner Wahl bestimmen. Dann wird er einen Kanal &ouml;ffen und die Daten zum 
Port, nach dem dein FTP Programm gefragt hat, tunneln. 
Dies ist offensichtlich etwas ressourcenintensiver. Aber es sollte gehen, 
solange dein NAT/IP Filter Rechner nicht &uuml;berm&auml;&szlig;ig beansprucht 
wird.
d1487 34
d1527 13
a1539 7
Zuweilen willst du ankommenden oder ausgehenden Datenverkehr eines 
bestimmten Protokolles oder Kanals umleiten. Ein gutes Beispiel daf&uuml;r ist 
ein Webserver, der im internen LAN h&auml;ngt. Ankommende Verbindungen zu 
deiner g&uuml;ltigen, offziellen IP Adresse werden keine Verbindung aufbauen 
k&ouml;nnen, wenn auf deinem NAT Rechner kein Webserver rennt. Daf&uuml;r gibt 
es bei NAT die 'rdr' Direktive in der Regelsatzdatei, die festlegt, ob und 
wohin eine bestimmte Verbindung umgeleitet werden soll.
d1544 4
a1547 3
F&uuml;r unser Beispiel nehmen wir an, da&szlig; ein Webserver im LAN mit der 
IP Adresse 192.168.1.80 existiert. Die NAT Regeldatei ben&ouml;tigt eine 
neue Direktive. F&uuml;ge eine Zeile wie folgende in ipnat.rules ein: 
d1551 1
a1551 1
rdr dc0 24.5.0.5/32 port 80 -&gt; 192.168.1.80 port 80
d1561 1
a1561 1
Diesen Befehl gibst du ipnat: Ipnat soll eine Verbindung umleiten. 
d1567 1
a1567 1
<b>"dc0"</b>
d1574 1
a1574 1
<b>"24.5.0.5/32"</b>
d1576 2
a1577 2
Dies bezieht sich auf die ankommenden Verbindungen zu dieser IP Adresse (nur 
auf dc0, wie oben)
d1584 5
a1588 4
Der Port (80), der umgeleitet werden soll. Die Zahl "80" mu&szlig; nicht 
explizit benutzt werden. Du kannst auch "port www" verwenden. Wenn du den 
Namen anstelle der Nummer verwendest, dann m&uuml;ssen auch Name und die 
korrespondierende Zahl in der Datei /etc/services existieren.
d1593 1
a1593 1
<b>"192.168.1.80"</b>
d1595 9
a1603 3
Die IP Adresse und Netzmaske des LAN Rechners, zu dem die Pakete umgeleitet 
werden. Die Netzmaske ist immer "/32" (und m&uuml;ussen daher nicht 
spezifiert werden). 
d1610 24
d1659 2
a1660 2
<li>/etc/ipnat.rules - NAT Regelsatzdatei 
<li>/etc/rc.conf - editieren, damit ipnat und ipf beim Starten aktiviert werden
a1661 1
<li>/usr/share/ipf/nat.1 - Beispiele von ipnat.rules
d1668 2
a1669 3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&manpath=OpenBSD+2.7">Man page showing correct ipnat.rules syntax</a>
<li><a href="http://coombs.anu.edu.au/~avalon/">http://coombs.anu.edu.au/~avalon/</a>
d1677 4
a1680 1
<a name= "6.4"></a> <h2>6.4 - DHCP</h2> </p>
d1683 2
a1684 1
<p>Um den DHCP Klient <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>
d1704 1
a1704 1
der neuen DNS Informationen, indem du die 'require' Zeilen auskommentierst 
d1716 3
a1718 1
Wenn du OpenBSD als DHCP Server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a> einstetzen willst, 
d1761 3
a1763 1
Siehe auch <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&apropos=0&sektion=5&format=html">dhcp-options(5)</a> f&uuml;r weitere Optionen, die 
d1774 4
a1777 2
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - der Kernel PPP D&auml;mon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - der Userland PPP D&auml;mon. 
d1795 2
a1796 1
Der Userland PPP D&auml;mon benutzt die Datei <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> als
a1834 8
<b>ANMERKUNG</b> - Mit OpenBSD 2.6 wurde das System mit einer <i>/etc/ppp/ppp.conf.example</i> 
ausgeliefert, die nicht korrekte Einstellungen f&uuml;r die Schnittstelle hatte, dessen 
Name war <i>"set device /dev/cuaa0"</i>. Es sollte aber <i>/dev/cua00</i> sein, was der seriellen 
Schnittstelle 1 (COM1) entspricht. Deine Schnittstelle mu&szlig; nicht COM1 sein, aber 
die Bezeichnung in OpenBSD 2.6 war falsch.
</p>

<p>
d1837 3
a1839 1
Loglevel ein. Um dies zu &auml;ndern, siehe <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> f&uuml;r weitere Info. Unsere Schnittstelle 
d1946 2
a1947 1
Weitere Informationen findest du unter <a href="http://www.freebsd.org/handbook/userppp.html">http://www.freebsd.org/handbook/userppp.html</a> oder <a href="http://www.freebsd.org/faq/userppp.html">http://www.freebsd.org/faq/userppp.html</a>.
d1951 1
d1980 1
a1980 1
aktiviert dies.  Beachte aber <A HREF="http://www.netscan.org">Smurfangriffe</a>, 
d1984 2
a1985 1
Wieder ein eigener sysctl Befehl daf&uuml;r.  Siehe <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
d2000 2
d2004 1
d2014 3
a2016 3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8&format=html">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8&format=html">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
d2047 1
a2047 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>. 
d2072 1
a2072 1
da&szlig; deine Kernelkonfiguration die Optionen NFSSERVER & NFSCLIENT 
d2093 2
a2094 1
mountd(8) zu starten, gib einfach folgendes ein:
d2098 1
d2137 1
a2137 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8&format=html">showmount(8)</a>, 
d2154 1
a2154 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8&format=html">mount_nfs(8)</a>.
d2191 2
a2192 1

d2195 1
d2210 2
a2211 1
so da&szlig; ich mit <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a> 
d2228 1
a2228 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a> 
d2272 1
d2282 1
a2282 1
<li>Lies das O'Reilly Associates Buch <i><a href="../../de/books.html#dns&bind">DNS and BIND</a> </i>.</li>
d2285 8
a2292 8
	<ul>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3&format=html">gethostbyname(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8&format=html">named(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3&format=html">resolver(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5&format=html">resolver(5)</a>
	</ul>
d2296 1
a2296 1
Der <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> 
d2300 1
a2300 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> 
d2313 1
a2313 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5&format=html">/etc/hosts</a> 
d2315 1
a2315 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a> 
d2375 1
a2375 1
Es gibt zwei getrennte BIND Specifikationen:
d2379 1
d2461 1
a2461 2
@@       IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
d2475 1
a2475 2
yewtopia.com.        IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
d2494 1
a2494 2
1.168.192.in-addr.arpa. IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
d2544 1
a2544 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8&format=html">route(8)</a> 
d2549 2
a2550 2
<h4>6.8.5.3 Mittels <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> 
die Ergebnis untersuchen.</h4>
d2553 1
a2553 1
$ <strong>dig @@nemo.yewtopia yewtopia any any</strong>
d2562 1
a2562 1
;;      yewtopia, type = ANY, class = ANY
d2565 1
a2565 2
yewtopia.        3600   SOA     nemo.yewtopia.
your_id.nemo.yewtopia. (
d2571 1
a2571 1
yewtopia.        3600   NS      nemo.yewtopia.
d2574 1
a2574 1
nemo.yewtopia.   3600   A       192.168.1.9
d2577 1
a2577 1
;; FROM: nemo to SERVER: nemo.yewtopia.  192.168.1.9
d2588 1
a2588 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8&format=html">/etc/rc</a> 
d2590 1
a2590 1
in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8&format=html">/etc/rc.conf</a>
d2622 1
a2622 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> 
d2635 2
a2636 1
Der beste Weg, um den Nameserverdienst zu stoppen, ist den <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> 
d2646 2
a2647 1
verwende den <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1&format=html">kill(1)</a> 
d2720 2
a2721 1
Es gibt eine Menge von Dingen, die ich dir nicht erz&auml;hlt habe, z.B. wie man DNS so aufsetzt, dass Anfragen f&uuml;r Intranet Domains, die von 
d2723 1
a2723 1
Lies die <a href="#6.8.1.1">empfohlenen Dokumente</a>, um mehr Informationen &uuml;ber DNS zu erhalten.
d2726 2
d2730 1
d2738 4
a2741 3
Zun&auml;chst ben&ouml;tigt man ein pptp. Ein port wurde dem OpenBSD ports tree NACH der Ver&ouml;ffentlichung von OpenBSD 2.8 hinzugef&uuml;gt 
und arbeitet bestens. Der port ist unter <i>/ports/net/pptp</i> zu finden. Lies die <a href="../faq8.html#8.6">FAQ 8.6</a>,
wenn du mehr &uuml;ber den OpenBSD ports tree herausfinden willst.
d2745 4
a2748 1
Wegen des Konflikts der "Im-Kernel" <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">gre(4)</a> Unterst&uuml;tzung und pptp wirst du deinen Kernel neu kompilieren m&uuml;ssen und die Unterst&uuml;tzung f&uuml;r gre(4) entfernen m&uuml;ssen.
d2753 1
a2753 1
Index: sys/conf/GENERIC
d2756 11
a2766 10
retrieving revision 1.66
diff -u -r1.66 GENERIC
--- sys/conf/GENERIC    2000/10/13 04:21:14     1.66
+++ sys/conf/GENERIC    2000/12/26 19:55:31
@@@@ -97,6 +97,6 @@@@
pseudo-device  ksyms   1      # kernel symbols device
pseudo-device  bridge  2      # network bridging support
#pseudo-device vlan    2      # IEEE 802.1Q VLAN
pseudo-device  gre     1      # GRE encapsulation interface
#pseudo-device gre     1      # GRE encapsulation interface
d2768 1
a2768 1
 option                BOOT_CONFIG     # add support for boot -c
d2772 4
a2775 2
Um deinen Kernel neu zu kompilieren mache einen "check out" von OpenBSD 2.8-stable via cvs (siehe die <a href="../../de/stable.html">OpenBSD Stable</a> 
Webseite) , benutze den folgenden Patch, und baue einen neuen Kernel wie unter <a href="faq5.html#5.3">FAQ 5.3</a>.
d2779 2
a2780 1
Nachdem du das <b>pptp</b> package und einen neuen Kernel installiert hast, musst du ein paar Dateien f&uuml;r deine neue Verbindung editieren.
d2782 3
a2784 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">ppp(8)</a>, 
wenn du dich also mit ppp(8) auskennst, kommt dir vieles bekannt vor. Siehe auch <a href="#6.5">FAQ 6.5</a>.
d2852 1
a2852 1
# <strong>tail -f /var/log/message</strong>
d2874 3
a2876 1
Originally [OpenBSD: faq6.html,v 1.107 ]
d2878 2
a2879 1
$Translation: faq6.html,v 1.51 2002/06/12 20:39:48 jufi Exp $
d2881 1
a2881 1
<small>$OpenBSD: faq6.html,v 1.107 2001/10/16 02:00:43 nick Exp $</small>
@


1.40
log
@
sync with badlands translation CVS
@
text
@d114 1
a114 1
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
d864 14
a877 12
This little change will dramatically increase the flexibility and
security of our ruleset: for instance, in the above ruleset, we are
allowing all tcp traffic into ports 80 &amp; 443. We can tighten this up
even more. In order for a tcp connection to be established, we only need
to allow the initial handshake to occur; once that occurs, we can block
traffic to that port and allow our &quot;keep state&quot; rule to manage
the connection. To allow the initial handshake to complete, we need only
allow packets with the SYN flag set and ACK flag not set. By passing only 
packets with SYN set, we can prevent many forms of portscanning such
as FIN scanning. flags S/SA means: out of flags S (SYN) and A (ACK), only
SYN may be set. Other flags aren't investigated.
The rules now look like this:
d891 10
a900 8
Let's start to tie things together by putting all of the rules we 
have so far into a ruleset. This ruleset will support IPv4, have 
a default deny policy, allow management connections from an 
internal network only (via ssh) and allow incoming traffic on 
ports 80(http) and 443(https). It will also protect against 
spoofed non-routeable ip addresses, and drop all packets that are 
too fragmented to inspect. A pretty comprehensive setup for a public 
webserver. Here's what <i>/etc/pf.conf</i> could look like:
d902 1
a902 1
# Clean up fragmented and abnormal packets
d905 1
a905 1
# don't allow anyone to spoof non-routeable addresses
d911 2
a912 2
# by default, block all incoming packets, except those explicitly
# allowed by further rules
d915 1
a915 1
# allow others to use http and https
d921 4
a924 3
# and let out-going traffic out and maintain state on established connections
# pass out all protocols, including TCP, UDP and ICMP, and create state,
# so that external DNS servers can reply to our own DNS requests (UDP).
d932 3
a934 3
While this may look good, there are some things Packet Filter 
will let you do to make your <i>pf.conf</i> file look neater and easier
to maintain.
d939 11
d952 4
a955 5
For example, let's see how we can apply state to our previous example ruleset (confused yet?). To review, we are allowing management access from our Class C to port 22(ssh) and allowing all incoming web traffic on ports 80(http) and 443(https). We are blocking all other traffic. But what if I want to ssh out of the webserver? What if I need to use lynx to look up something in the FAQ? Well, I can't because I have blocked all incoming connections other than on the specified ports. While this is the safest route, it can be quite inconvenient. By adding the <em>keep state</em> keywords to our &quot;pass out&quot; rule, we can automagically allow incoming connections in response to connections we initiate, such as when web browsing.  Remember, we do need to specify what protocol we are keeping state for.
Sets are useful "shortcuts" for writing simple and clear 
rules in PF.  For example, what if we need to allow 
connections to a service running
over multiple protocols, such as BIND, which uses TCP and UDP?
d957 5
a961 1
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
a962 50
Note the spaces on both sides of the '{ }' characters. 
</ul>
Diese kleine &Auml;nderung wird die Flexibilit&auml;t und Sicherheit unseres
Regelsatzes dramatisch erh&ouml;hen, weil IP Filter extrem flexibel ist.
 Z. B. erlauben wir im obigen Regelsatz jeden TCP-Datenverkehr
auf Ports 80 &amp; 443. Wir k&ouml;nnen dies noch besser machen: Um eine
TCP Verbindung zu errichten, m&uuml;ssen wir nur die erste Verbindungsanfrage
erlauben. Sobald dies geschieht, k&ouml;nnen wir diesen Kanal blockieren
und unsere "keep state" Regel die Verbindung verwalten lassen. Um die erste
Verbindungsanfrage vollenden zu lassen, ben&ouml;tigen wir nur Pakete mit
SYN und SYNACK Kennzeichen. Indem wir nur solche Pakete durchlassen, k&ouml;nnen
wir z. B. viele Arten von "portscanning" aufgrund von FIN Kennzeichen verhindern.
Die Regel sieht nun so aus:
<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
</pre>
</ul>
Nun schreiben wir alles zusammen: Dieser Regelsatz hat standardm&auml;&szlig;iges
Ablehnen, erlaubt Administration nur via ssh vom internen Netzwerk und
erlaubt ankommenden Datenverkehr zu Ports 80 (http) und 443 (https). Er
wird auch gegen Adressenschwindel von nicht-routebaren Adressen sch&uuml;tzen
und alle zu fragmentierten Pakete verwerfen. Eine recht umfassende Einstellung
f&uuml;r einen Webserver. Hier unsere /etc/ipf.rules:
<ul>
<pre>
# loopback rules
pass out quick on lo0
pass in quick on lo0

# drop itsy bitsy frags
block in quick proto tcp all with short

# drop source routed packets
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8
d964 7
a970 2
# only allow our machines to connect via ssh
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
d972 33
a1004 1
# allow others to use http and https
d1008 27
a1034 16
# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out and maintain state on established connections
# -- The flags S on the keep state is to ensure that state tracking starts
#    only on the first outbound packet in a tcp session. 
#    unnecessary consumption of state table entries.
# -- The flag s only works on the tcp protocol, so three entries are required to 
#    to cover all three protocols (tcp, udp, icmp).

pass out      quick on fxp0 proto tcp  from any to any flags S keep state
pass out      quick on fxp0 proto udp  from any to any         keep state
pass out      quick on fxp0 proto icmp from any to any         keep state

</pre>
</ul>
d1036 1
a1036 1

d1038 1
a1038 11
Wenn du Schwierigkeiten hast, dann kannst du Logging f&uuml;r bestimmte 
Regels&auml;tze aktivieren; 
z.B.: pass in log quick on fxp0 from 1.1.1.0/24 to any port = 22
Wenn du die Konfigurationsdatei so modifizierst, um Pakete zu loggen, 
vergi&szlig; nicht, mit "ipf -Fa -f /etc/ipf.rules" die &Auml;nderungen auch 
zu aktivieren! 
ipmon wird die ip-Logeintr&auml;ge in /var/log/ipflog schreiben.
F&uuml;r weitere Informationen &uuml;ber ipf siehe das <a href="http://www.obfuscation.org/ipf/ipf-howto.txt">IPF
how-to</a> als exzellente Informationsquelle sowie die 
<a href="http://coombs.anu.edu.au/~avalon/ip-filter.html">IP
Filter</a> Homepage.
a1039 2


d1041 27
d1069 2
a1070 2
<h2>6.3 - IPNAT</h2>
</p>
d1073 3
a1075 1
Initiale Arbeit von Wayne Fergerstrom &lt;wayne@@methadonia.net&gt;
a1082 11
<p>
Dieses Kapitel versucht jenen zu helfen, die Network Address Translation ("NAT") 
auf ihrem OpenBSD Rechner installieren und konfigurieren wollen. 

Der Benutzer sollte bereits den OpenBSD Rechner mit zwei Netzwerkkarten installiert 
und konfiguriert haben (eine mit dem Internet verbunden, die andere mit dem lokalen 
Netzwerk). 
IP NAT wird auch auf Rechnern mit nur einer Netzwerkkarte laufen, 
aber da die IP Pakete auf ein und demselben Interface ein- und ausgehen, 
werden Ethernetkollisionen die Leistung drastisch vermindern.  
</p>
d1085 1
a1085 1
Gem&auml;&szlig; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> bietet ipnat 
a1098 5
</p>

<a name="nat1.2"></a>
<b>Terminologie</b>

d1100 3
a1102 32
Die in diesem Dokument verwendeten Konventionen sind sehr einfach.
F&uuml;r Documentationszwecke werde ich einige der Terme und Formate erkl&auml;ren.
</p>

<ul>
<strong>"NAT"</strong>
<p>
Dies beschreibt die Funktion von "Network Address Translation" (Netzwerkadress&uuml;bersetzung).
Der Prozess des NAT wird sp&auml;ter in diesem Dokument beschrieben.
</p>
</ul>

<ul>
<strong>"ipnat"</strong>

<p>
Abk&uuml;rzung f&uuml;r "IP Network Address Translation", kann mit NAT austauschbar verwendet werden. 
In diesem Dokument wird der Terminus "ipnat" aber nur f&uuml;r die Kommandozeile verwendet werden.
</p>
</ul>

<ul>
<strong>"IPF"</strong>

<p>
Abk&uuml;rzung f&uuml;r "IP Filter." IP Filter ist eine portable Paketfilterungssoftware, welche 
Teil von OpenBSD ist. IP Filter mu&szlig; zuerst aktiviert werden, bevor man ipnat benutzen kann. 
Ganz einfach: Editiere /etc/rc.conf und &auml;ndere ipfilter=NO in ipfilter=YES. Dies &auml;ndert 
es aber erst f&uuml;r das n&auml;chste Rebooten. 
Mit 'ipf -E' schaltest du es im laufenden Betrieb ein. Genaueres nat&uuml;rlich sp&auml;ter. 
</p>
</ul>
d2821 1
a2821 1
$Translation: faq6.html,v 1.47 2002/06/04 05:50:09 jufi Exp $
@


1.39
log
@
sync with badlands translation CVS
@
text
@d114 1
a114 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
d2832 1
a2832 1
$Translation: faq6.html,v 1.46 2002/06/03 20:58:21 jufi Exp $
@


1.38
log
@
sync with badlands translation CVS
@
text
@d501 1
a501 1
darstellen. Abh&auml;ngig von deinen Netzwerkkarten in deinem COmputer wird
d578 1
a578 1
Nat&uulm;rlich gibt es jeder Regel eine Ausnahme, so auch hier. Die <em>quick</em> 
d692 1
a692 1
die von unserer Firewall blockiert werden? Einfach - Packet Filter hat daf&uuml;r
d810 1
d827 8
a834 6
Packet Filter's next cool trick is its ability to maintain state. 
Maintaining state has been described as &quot;not speaking until 
spoken to&quot;; in other words, once a connection is established, 
packets no longer have to traverse rulesets. This is a very 
powerful feature allowing much simpler and more secure rule 
writing.
d837 4
a840 5
For example, let's see how we can apply state to our previous 
example ruleset (confused yet?). To review, we are allowing 
management access from our Class C to port 22(ssh) and allowing 
all incoming web traffic on ports 80(http) and 443(https). We 
are blocking all other traffic. But, what if I want to
d842 13
a854 10
out of the webserver? What if I need to use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&sektion=1">lynx(1)</a> to look up 
something in the FAQ? Well, I can't because I have blocked all 
incoming connections other than those on the specified ports. While 
this is the safest route, it can be quite inconvenient. By 
adding the <em>keep state</em> keywords to our &quot;pass 
out&quot; rule, we can automatically allow incoming 
packets in response to connections we initiate, such as 
when web browsing.  Remember, we do need to specify what 
protocol we are keeping state for.
d2832 1
a2832 1
$Translation: faq6.html,v 1.45 2002/05/20 20:51:29 jufi Exp $
@


1.37
log
@
sync with badlands translation CVS
@
text
@d578 4
a581 4
Nat&uulm;rlich gibt es jeder Regel eine Ausnahme. The <em>quick</em> 
option drops the packet at the first rule that matches. Let's 
look at our above flawed example, if we add <em>quick</em> to 
the &quot;block in&quot; rule:
d583 5
a587 5
<ul>
<pre>pass out from any to any
block in quick on fxp0 from any to any port = 3306
pass in from any to any</pre>
</ul>
d590 8
a597 5
Ein Paket mit Ziel f&uuml;r unseren Rechner auf Port 3306 wird die "block
in quick" Regel treffen und sofort fallengelassen. Alle Pakete f&uuml;r
die anderen Ports werden keine passende Regel finden bis sie auf unsere
"pass in" Regel treffen, die alle Pakete passieren l&auml;&szlig;t.
</p>
d599 5
a603 7
<p><b>Standardm&auml;&szlig;iges Ablehnen</b>
<p>Die sicherste Paketfilterregel ist standardm&auml;&szlig;iges Ablehnen.
Jeder Datenverkehr, der nicht ausdr&uuml;cklich erlaubt ist, wird abgelehnt.
Diese Richtlinie ist bei weitem sicherer, als jeden gesch&uuml;tzten Dienst
ausdr&uuml;cklich zu erlauben. Erlaubt kleineren Umfang der Regeln und
kann Schutz bieten, wenn ein unabsichtlich mi&szlig;konfigurierter Dienst
ungesch&uuml;tzt zur&uuml;ckgelassen wurde.
d605 13
a617 13
Sehen wir uns einen anderen, realen Beispielregelsatz an und erkl&auml;ren
Zeile f&uuml;r Zeile. Hier ein Beispiel f&uuml;r einen Webserver mit standardm&auml;&szlig;igem
Ablehnen; erlaubt werden nur ssh Verbindungen (f&uuml;r Administration)
und Verbindung zu http (port 80) und https (port 443).
<ul>
<pre>
pass in quick on fxp0 from any to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre>
</ul>
d620 6
a625 7
Dies wird ankommende Verbindungen von &uuml;berall zu Ports 22 (ssh), 80
(http), and 443 (https) erlauben. Es werden alle anderen Verbindungsversuche
fallengelassen und alle ausgehenden Verbindungen erlaubt. Dies ist ein
recht fester Regelsatz. Aber wenn wir nur interne Rechner vom 1.1.1.0 Adressbereich
zu ssh verbinden lassen wollen, aber Verbindungen von au&szlig;erhalb zu
http und https zulassen wollen?
</p>
d629 5
a633 5
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
d640 1
a640 1
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
d646 2
a647 1
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22</pre>
d649 1
a649 7
IP Filter unterst&uuml;tzt sowohl CIDR als auch Punkt/Dezimalformat der
Netzmaskenadresse. Obiges in anderer Schreibweise:
<ul>
<pre>pass in quick on fxp0 from 1.1.1.1/255.255.255.255 to any port = 22</pre>
</ul>
aber warum solltest du?
<b></b>
d651 1
d653 46
a698 24
<b>Beispielregeln</b>
<p>Hier ein paar gute Regeln, die jeder verwenden kann (angenommen wird,
da&szlig; fxp0 das externe Interface mit Internetverbindung ist). Zun&auml;chst
einfacher Schutz gegen Adressenschwindel ("address spoofing").
<ul>
<pre>block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8</pre>
</ul>
Eine gute Idee ist es, das loopback Interface von deinen anderen Regeln
zu trennen.
<ul>
<pre>pass out quick on lo0
pass in quick on lo0</pre>
</ul>
Unsere Regelsatz schaut schon recht gut aus. Zusammen sieht er so aus:
<ul>
<pre>
# Loopback regeln
d700 3
a702 2
pass out quick on lo0
pass in quick on lo0
d704 15
a718 1
# anti-adressenschwindel von nicht-routebaren adressen
d720 2
a721 8
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8
d723 3
a725 1
# nur unser administrationsrechner darf sich mittels ssh verbinden
d727 4
a730 1
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
d732 3
a734 1
# erlaube anderen http und https
d736 14
a749 2
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
d751 13
a763 1
# zuletzt standardmaessiges ablehnen</pre>
d765 2
a766 1
<pre>block in quick on fxp0 from any to any
d768 4
a771 1
# und lass ausgehenden datenverkehr raus
a772 1
pass out on fxp0 from any to any
a773 2
</pre>
</ul>
d776 15
a790 12
<b>Paket logging</b>
<p>Nun, dies ist zwar schon recht gut, aber es k&ouml;nnte besser sein.
Z. B. wenn wir alle Verbindungsversuche zu Port 22(ssh) loggen wollten,
die von unserer Firewall blockiert werden? Einfach - IP Filter hat daf&uuml;r
das <em>log</em> Stichwort:
<ul>
<pre>pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 from any to any port = 22</pre>
</ul>
Diese Regel wird erlauben, da&szlig; sich unser Administrationsrechner
auf Port 22 verbinden darf, aber alle anderen Verbindungsversuche auf Port
22 ablehnt und aufzeichnet.
d793 14
a806 22
<b>Protokollbasierende Paketfilterung</b>
<p>IP Filter kann auch nach jedem IP Protokoll filtern, entweder nach seiner Nummer oder seinem Name, der in <a href="file://localhost/etc/protocols">/etc/protocols</a>
aufgelistet ist. Im Sinne der Klarheit werden wir uns nur mit tcp, udp
und icmp besch&auml;ftigen.
Dies sind die am meisten verwendeten Protokolle, auf denen alle grundlegenden Internetanwendungen basieren. 
<p>Damit IPF protokollbasierend filtert mu&szlig; das Stichwort <i>proto</i>
verwendet werden. Um unsere fr&uuml;here ssh Beispielsregel zu verwenden,
da ssh ja &uuml;ber tcp rennt,&nbsp; sollten wir nur tcp Pakete zur Verbindung
zulassen. Mit dem <i>proto</i> Stichwort erlauben wir nur tcp, und wir
bekommen eine Regel wie folgt:
<ul>
<pre>pass in quick on fxp0 proto tcp from 1.1.1.1/32 to any port = 22</pre>
</ul>
Aber wenn wir eine Verbindung f&uuml;r einen Dienst brauchen, die tcp und
udp ben&ouml;tigt (wie z. B. bind)? Nun im Falle von tcp/udp erlaubt uns
IP Filter beide Protokolle zusammen zu schreiben. NB: Dies gilt nur f&uuml;r
tcp/udp. F&uuml;r das bind Beispiel w&uuml;rde folgende Regel tcp und udp
Verbindungen (bei standardm&auml;&szlig;igem Ablehnen) erlauben:
<ul>
<pre>pass in quick on fxp0 proto tcp/udp from any to any port = 53</pre>
</ul>
</p>
d808 1
a808 29
<b>Paketfilterung</b>
<p>Zus&auml;tzlich zur protokollbasierenden Filterung ist IP Filter auch
zum Handhaben der zersplitterten IP Pakete f&auml;hig (eine allgemeine
Methode des Besiegens der Paketfilter). Es gibt zwei m&ouml;gliche Schl&uuml;sselw&ouml;rter:&nbsp;
<em>frag</em> f&uuml;r allgemein zersplitterte IP Pakete, oder <em>short</em>
f&uuml;r IP Pakete mit f&uuml;r Vergleiche zu kurzen Informationen (<em>headers</em>).
Da zersplitterte Pakete auch normalerweise auftreten k&ouml;nnen, abh&auml;ngig
von den Verbindungsumst&auml;nden, es ist am besten, Pakete mit den Vors&auml;tzen
nur zu filtern, die f&uuml;r g&uuml;ltigen Vergleich zu klein sind. Dieses
kann mit der folgenden Richtlinie vollendet werden:
<ul>
<pre>block in quick proto tcp all with short</pre>
</ul>
Und bzgl. IP Optionen? IP Filter kann jene Pakete auch behandeln. Pakete
k&ouml;nnen entweder fallengelassen werden, wenn sie IP Optionen haben,
oder sie spezifischen IP Optionen besitzen, die eingestellt werden. Z.
B. l&auml;&szlig;t die folgende Richtlinie fallen und protokolliert alle
Pakete mit den eingestellten IP Optionen.
<ul>
<pre>block in log quick on fxp0 all with ipopts</pre>
</ul>
Dies kann aber einige Dinge wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=traceroute&sektion=8&format=html">traceroute(8)</a>
brechen. Du kannst auch bestimmte Optionen verbieten. Z. B. ist eine gute
Regel, alle Pakete mit "source routing" Option zu verbieten. Dies geschieht
mit dieser Regel:
<ul>
<pre>block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr</pre>
</ul>
d810 13
a822 10
<p>Nun kommt IP Filter in vollem Ernst: IP Filters gr&ouml;&szlig;te
St&auml;rken liegen in der F&auml;higkeit, Pakete anhand ihrer TCP flags
(=Kennzeichen) zu filtern und bestehende Verbindungen und Verbindungszust&auml;nde
aufrechtzuerhalten. Man sollte die Rolle jedes TCP flags verstehen, wenn
man die Pakete danach filtern will. Z. B. wenn du alle Pakete mit den FIN,
URG und PSH flags filtern willst (f&uuml;r z. B. einen "nmap OS fingerprinting
attempt"), dann solltest du eine Regel wie diese einsetzen:
<ul>
<pre>block in quick on fxp0 proto tcp from any to any flags FUP</pre>
</ul>
d826 114
a939 29
<p>Die n&auml;chste F&auml;higkeit von IP Filter ist, Verbindungszust&auml;nde
beizubehalten. Den Zustand beizubehalten ist beschrieben worden, wie "
nicht sprechend bis gesprochen mit ", das hei&szlig;t, sobald ein Anschlu&szlig;
hergestellt ist, m&uuml;ssen Pakete die Regels&auml;tze nicht mehr &uuml;berqueren.
Dieses ist eine sehr leistungsf&auml;hige Eigenschaft, was viel einfacheres
und sichereres Richtlinie Schreiben erlaubt.
</p>
<p>Z. B. lassen sehen wir uns an, wie wir Zustand an unserem vorhergehenden
Beispielregelsatz anwenden k&ouml;nnen (schon verwirrt?). Zu Wiederholung,
wir erlauben Managementzugriff von unserem Klasse C Netz zu Kanal 22 (ssh)
und erlauben allen ankommenden Web-Verkehr auf Kan&auml;len 80 (http) und
443 (https). Wir blocken jeglichen weiteren Verkehr. Aber was, wenn ich
mit ssh aus dem webserver heraus w&uuml;nsche? Was, wenn ich lynx benutzen
mu&szlig;, um etwas im FAQ nachzuschauen? Gut, kann ich nicht, weil ich
alle ankommenden Anschl&uuml;sse anders als auf den spezifizierten Kan&auml;len
geblockt habe. W&auml;hrend dieses der sicherste Weg ist, kann es ziemlich
ung&uuml;nstig bzw. unhandlich sein. Indem wir die Schl&uuml;sselw&ouml;rter
<em>keep state</em> unserer "pass out" Richtlinie hinzuf&uuml;gen, k&ouml;nnen
wir ankommende Verbindungen in Erwiderung auf von uns selbst initialisierte
Verbindungen automatisch erlauben, wie z. B. beim Webbrowsen.
NB: Wir m&uuml;ssen das Protokol angeben, f&uuml;r das wir "keep state" 
halten.
<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
d2827 1
a2827 1
$Translation: faq6.html,v 1.44 2002/05/20 18:12:40 jufi Exp $
@


1.36
log
@
sync with badlands translation CVS
@
text
@d29 2
a30 2
<li> <a href= "#DNS"	>6.8 - DNS - Domain Name Service  - DNS, BIND und named</a>
<li> <a href= "#PPTP"	>6.9 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
d42 2
a43 1
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> und
d57 2
a58 1
k&ouml;nntest du viel vom Lesen der entsprechenden <a href="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">RFCs</a>
d61 2
a62 2
Lies nach, wie sie arbeiten sollten. Die RFCs definieren mehrere (tausende)
Standards f&uuml;r Protokolle im Internet und wie sie arbeiten sollten.&nbsp;
d81 3
a83 2
deine Karte &uuml;berpr&uuml;fen. Zum Beispiel ist hier die Ausgabe in
dmesg f&uuml;r eine ne2k Netzwerkkarte, die den Ger&auml;tenamen ne hat.
d88 6
a93 14
Wenn du nicht weisst, wie der Name deiner Karte ist, sieh bitte in der
<a href="../../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> unter deiner Plattform nach.
Dort findest du eine Liste der gebr&auml;chlichsten Kartennamen und ihrer OpenBSD device Namen.
Kombiniere den kurzen alphabetischen Namen (z.B. fxp) mit einer Nummer, die vom Kernel zugewiesen
wird, und du hast den "interface name" (z.B. fxp0).

Falls du von einer &auml;lteren Version von OpenBSD upgradest: Alte Ethernet-Treiber
werden manchmal durch neuere ersetzt, und wenn das passiert,
kann sich der Interfacename &auml;ndern. Nach OpenBSD 2.6, z.B., wurden die
mx, al, ax, und pn Treiber alle durch den dc Treiber ersetzt.
Alle Referenzen in <i>/etc/dhcpd.interfaces</i>, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf(5)</a>, oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf(5)</a>
m&uuml;ssen auf den neuen Interfacenamen ge&auml;ndert werden.
Genauso nat&uuml;rlich alle <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5">/etc/hostname.xxx</a> Dateien. ( Wobei xxx der alte Interfacename und die Zahl darstellt)
</p>
d95 4
a98 1
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem du das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> Kommando benutzt.
d144 1
a144 1
Schlussendlich f&auml;llt auf, das standarm&auml;ssig eine Menge mehr Interfaces aktiviert sind.
d167 1
a167 1
address_family address netmask broadcast [other options]
d190 1
a190 2
HIERGETHESWEITER!
kann du diese media settings einfach ignorieren.)
d208 2
a209 1
das Format dieser Datei findest du in der <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">resolv.conf(5)</a>
d211 1
a211 1
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du geh&ouml;rst zur Dom&auml;ne
d229 1
a229 1
<pre>$ <b>sh /etc/netstart
d237 11
a247 6
Die Fehlermeldung betrifft das loopback Interface. Daher kann dies ignoriert
werden. Ab jetzt sollte dein System funktionieren. Du kannst wiederum mit
<b>ifconfig(8)</b>
&uuml;berpr&uuml;fen, ob deine Netzwerkkarte aktiv ist. Die Routingtabelle
&uuml;berpr&uuml;fe mit <b>netstat(1)</b> oder <b>route(8)</b>. Hier ist
ein Beispiel f&uuml;r beides.
d256 1
a256 1
default            10.0.0.1           UGS         0       86      -  ne3
d259 2
a260 2
10.0.0/24          link#1             UC          0        0      -  ne3
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  ne3
d281 1
d286 1
a286 1
Dies ist nur die grundlegende Information, um deinen OpenBSD Rechner als
d288 1
a288 1
im Internet verwenden willst, solltest du auch die IP Filter unten folgenden
d290 4
a293 3
Auch solltest du wegen der Knappheit an IPv4 Adressen die Informationen
bez&uuml;glich Network Address Translation beachten, um deinen IP Adressbereich
zu schonen.
d298 2
a299 1
aber dies mu&szlig; erst eingeschaltet werden. Du solltest dies mit <b>sysctl(8)</b>
d301 1
a301 1
<b>/etc/sysctl.conf</b>
d311 3
a313 2
Ohne Reboot kannst du dies auch direkt mit <b>sysctl(8)</b> durchf&uuml;hren.
Beachte aber, da&szlig; diese &Auml;nderung nach einem Reboot weg ist und
d325 5
a329 5
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>,
<a href="http://www.gated.org">gated</a>,
<a href="http://www.mrtd.net">mrtd</a>
und <a href="http://www.zebra.org">zebra</a>. OpenBSD hat Unterst&uuml;tzung
in der ports Kollektion sowohl f&uuml;r gated als auch mrtd. OpenBSD unterst&uuml;tzt
d334 1
d339 8
a346 10
<strong>Beginnend mit OpenBSD 2.8 wird <i>/etc/ifaliases</i> nicht mehr benutzt!</strong>
<p>
OpenBSD hat einen einfachen Mechanismus, um IP Aliases auf einer Schnittstelle
einzurichten. Dazu mu&szlig;t du nur die Datei 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html"><i>/etc/hostname.&lt;if&gt;</i></a>
editieren.
Diese Datei wird beim Starten vom <i>/etc/rc</i> Script gelesen, welches
Teil der <a href="../faq10.html#10.3">rc startup Hierarchie</a> ist. F&uuml;r
das Beispiel nehmen wir an, da&szlig; der Benutzer eine Schnittstelle <b>dc0</b>
hat und sich im Netzwerk 192.168.0.0 befindet. Weitere wichtige Informationen:
d357 4
a360 3
Bei OpenBSD verwendet man nur den Adapternamen. Es gibt keine Unterschiede
zwischen dem ersten und dem zweiten Alias. Daher mu&szlig; man sie nicht
- wie in einigen anderen Betriebssystemen - als dc0:0, dc0:1 bezeichnen.
d365 1
a365 1
</p>
a366 1
<p>
d370 1
a370 1
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Alias zur Netzwerkkarte 
a372 1
</p>
d379 2
a380 2
inet alias 192.168.0.3 255.255.255.255 NONE
inet alias 192.168.0.4 255.255.255.255 NONE
d387 3
a389 2
die Aliases manuell mit <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
hochbringen. F&uuml;r das erste Alias:
d411 7
a417 2
<h2>
6.2 - IP Filter</h2></p>
d420 8
a427 4
Das IP Filter Packet wurde geschaffen, um zwei Aufgaben zu erf&uuml;llen:
Berechtigungen von packet level forwarding <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8&manpath=OpenBSD+2.7">ipf(8)</a>
und das Umlegen von hosts/subnets auf einen externen Adressbereich <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a>. 
Die Konfigurationsdateien dieser zwei Dienste sind /etc/ipf.rules und /etc/ipnat.rules.</p>
d430 3
a432 1
Um diese Dienste in deinem System zu starten, musst du die <i>/etc/rc.conf</i> so editieren:
d436 1
a436 2
ipfilter=YES
ipnat=YES
d440 6
a445 3
<b>HINWEIS:</b> Du musst nicht unbedingt beide Optionen dauernd aktiviert haben, es sei denn du nutzt auch beide.  Wenn du allerdings
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> benutzt, muss ipfilter auch zwingend aktiviert sein.
</p>
d448 17
a464 3
Wenn du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> benutzt, musst du h&ouml;chstwahrscheinlich 
auch den sysctl Wert &quot;net.inet.ip.forwarding&quot; auf 1 setzen. Du kannst das tun, indem du die zugeh&ouml;rigen Zeilen
in der Datei <i>/etc/sysctl.conf</i> auskommentierst. 
d466 5
d473 6
a478 6
Wenn du IP Filter im Kernel einkompiliert hast, aber nicht in <i>/etc/rc.conf</i>
eingeschalten hast, kannst du es einfach aktivieren.
<ul>
# <strong>ipf -Fa -f /etc/ipf.rules -E</strong><br>
# <strong>ipnat -CF -f /etc/ipnat.rules</strong>
</ul>
d481 9
a489 17
Die <tt>-E</tt> Option bei ipf aktiviert ('enables') IP Filter. <tt>-Fa</tt>
l&ouml;scht alle Regeln, die du noch hast. <tt>-f /etc/ipf.rules</tt> l&auml;dt
die Regeln aus der Datei <i>/etc/ipf.rules</i>.

<p>Wenn du <i>/etc/ipf.rules</i> nach dem Laden von ipf &auml;nderst, kannst du
deine Regeln sehr leicht neu laden!
<ul>
# <strong>ipf -Fa -f /etc/ipf.rules</strong>
</ul>
Gleiches f&uuml;r ipnat...
<ul>
# <strong>ipnat -CF -f /etc/ipnat.rules</strong>
</ul>
Um <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipmon&sektion=8&manpath=OpenBSD+2.7">ipmon(8)</a> im Debugmodus zu starten:
<ul>
# <strong>ipmon -Ds</strong>
</ul>
d492 1
a492 11
Dieses Dokument wird einige grundlegende <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8&manpath=OpenBSD+2.7">ipf(8)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> Konfigurationen
im Folgenden darstellen. In <i>/usr/share/ipf/</i> findest du ein paar nette Beispiele
f&uuml;r ipnat und ipf. Wir empfehlen dir, jenes, da&szlig; dir am ehesten
pa&szlig;t, auszuw&auml;hlen und auf deine Bed&uuml;rfnisse abzu&auml;ndern.
Du kannst weitere Informationen im IP Filter
<a href="http://false.net/ipfilter/">Mailinglistenarchiv</a>,
auf der <a href="http://coombs.anu.edu.au/~avalon/">IP Filter Website</a>
und noch im <a href="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>
finden.
</p>
d495 9
a503 3
<h3>
IPF</h3>

a504 8
Um ipf beim Booten zu aktivieren, mu&szlig;t du /etc/rc.conf modifzieren:
IPFILTER=YES. IP Filter (ipf) wird von /etc/ipf.rules gesteuert, welche
beim Booten gelesen wird. F&uuml;r weitere Erkl&auml;rungen siehe <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=5&manpath=OpenBSD+2.7">ipf(5)</a>.
In den folgenden Beispielen wird fxp0 das externe Netzwerkinterface zum
Internet sein. Dies wird f&uuml;r dich anders sein, wenn du einen anderen
Ethernetadapter in deinem Computer hast. Diese Regeln nehmen eine Standleitungsverbindung
an, so wie sie bei einem Webserver zu erwarten ist.
</p>
d506 3
a508 4
<p>IP Filter Regeln werden sequentiell von Anfang bis Ende abgearbeitet.
Es mag hilfreich sein, sich vorzustellen, da&szlig; jedes einzelne Paket
zun&auml;chst jede Regel erf&uuml;llen mu&szlig;, bevor es sein Ziel erreicht.
</p>
d513 4
a516 4
<ul>
<pre>pass out from any to any&nbsp;
pass in from any to any</pre>
</ul>
d518 2
a519 6
Nun angenommen, wir wollen keine ankommenden Verbindungen zu Port 3306
(mysql) zulassen, weil die Datenbank nur mit dem localhost verbunden sein
soll. Die Regeln w&uuml;rden so aussehen:

<ul>
<pre>pass out from any to any
d521 2
a522 2
block in on fxp0 from any to any port = 3306</pre>
</ul>
d524 18
a541 17
Dies bedeutet, da&szlig; alle ankommenden Pakete von &uuml;berall nach
&uuml;berall mit Zielport 3306 auf dem Interface fxp0 blockiert werden.
Genauergesagt wird ein Paket f&uuml;r Port 3306 auf dem Adapter fxp0 zun&auml;chst
die erste "pass in" Regeln passieren und dann von der "block in port =
3306" Regel blockiert werden. Wenn du die Anordnung unserer ankommenden
Regel vertauschst (NB: die Reihenfolge ist wichtig):

<ul>
<pre>pass out from any to any
block in on fxp0 from any to any port = 3306
pass in from any to any</pre>
</ul>

Pakete mit Zielport 3306 w&uuml;rden passieren, weil die letzte Regel alle
Pakete passieren l&auml;&szlig;t. Dies mu&szlig; man immer im Hinterkopf
behalten, wenn man Paketfilterregeln schreibt: 
<b>Die letzte passende Regel gewinnt</b>.
d544 38
a581 3
Nat&uuml;rlich gibt es Ausnahmen zu jeder Regel. Die <em>quick</em> Option
l&auml;&szlig;t jedes Paket bei der ersten passenden Regel fallen. Bei
obigem "falschen" Beispiel mit <em>quick</em> zur "block in" Regel:
d2713 1
a2713 1
$Translation: faq6.html,v 1.43 2002/05/20 13:21:05 jufi Exp $
@


1.35
log
@
broken links
@
text
@d6 1
d2664 1
a2664 1
$Translation: faq6.html,v 1.42 2002/03/22 07:28:03 jufi Exp $
@


1.34
log
@
sync with badlands translation CVS.
@
text
@d85 1
a85 1
<a href="plat.html">Liste der unterst&uuml;tzten Hardware</a> unter deiner Plattform nach.
d2663 1
a2663 1
$Translation: faq6.html,v 1.41 2002/01/31 18:25:39 jufi Exp $
@


1.33
log
@sync with badlands translation CVS
@
text
@d9 1
a9 1
<meta name="copyright" content="This document copyright 1998-2001 by OpenBSD.">
d12 1
a12 1
<body text="#000000" bgcolor="#FFFFFF" link="#23238E">
d20 10
a29 10
<li> <a href="#6.0.1">6.0.1 - Bevor wir weiter gehen</a></li>
<li> <a href="#6.1">6.1 - Erste Netzwerkeinstellungen</a></li>
<li> <a href="#6.2">6.2 - IPF - IP Filter</a></li>
<li> <a href="#6.3">6.3 - NAT - Network Address Translation</a></li>
<li> <a href="#6.4">6.4 - DHCP - Dynamic Host Configuration Protocol</a></li>
<li> <a href="#6.5">6.5 - PPP - Point to Point Protocol</a></li>
<li> <a href="#6.6">6.6 - Optimieren der Netzwerkparameter</a></li>
<li> <a href="#6.7">6.7 - NFS benutzen</a></li>
<li> <a href= "#6.8">6.8 - DNS - Domain Name Service  - DNS, BIND und named</a>
<li> <a href= "#6.9">6.9 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
d34 1
d41 2
a42 2
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">ifconfig(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">netstat(1)</a>.
d47 2
a48 1
<A HREF="http://www.3com.com/solutions/en_US/ncs/501302.html">Understanding IP addressing</a>
d55 1
a55 1
k&ouml;nntest du viel vom Lesen der entsprechenden <A HREF="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">RFCs</a>
d58 1
a58 1
Lies nach, wie sie arbeiten sollten. Die RFCs definieren mehrere (tausend)
d61 2
a62 1
<a NAME="6.1"></a>
d67 2
a68 1
<a NAME="6.1.1"></a>
d75 3
a77 1
Befehls <b>dmesg(8)</b>. Weiterhin kannst du mit dem Befehl <b>ifconfig(8)</b>
d81 2
a82 2
<pre>ne3 at pcmcia1 function 0 "Linksys, EtherFast 10/100 PC Card (PCMPC100), " port 0x340/16 irq 9
ne3: address 00:e0:98:04:95:ba
d84 19
a102 44
Solltest du nicht deinen Ger&auml;tenamen kennen, dann findest du hier
eine Liste gebr&auml;uchlicher Karten und deren Ger&auml;tenamen.
<ul>
<li>
ne2000 Netzwerkkarten - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ne&sektion=4&format=html">ne</a></li>

<li>
3Com EtherLink III und Fast EtherLink III Ethernet - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4&format=html">ep</a></li>
<li>
3Com EtherLink XL und Fast EtherLink XL Ethernet (3C9xx) - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xl&sektion=4&format=html">xl</a></li>
<li>
Intel 82586 chip Ethernet device driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ie&sektion=4&format=html">ie</a></li>
<ul>Welcher Karten wie folgende beinhaltet:
      <li>3Com 3C507
      <li>AT&amp;T StarLAN 10
      <li>AT&amp;T EN100
      <li>AT&amp;T StarLan Fiber
      <li>Intel EtherExpress 16
</ul>
<li>DEC/Intel 21142/3 und Klone mit 10/100 Ethernet Treiber - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dc&sektion=4&format=html">dc</a>
<ul><font size="-1">
<b>Anmerkung:</b> Einige Treiber in OpenBSD 2.6 (z. B. mx, ax, al und pn wurden durch diesen Treiber ersetzt.</font><br>
Darunter fallen unter anderem folgende Karten:
	<li>Intel 21142/21143 (fr&uuml;her von DEC hergestellt)
	<li>Macronix 98713, 98713A, 98715, 98715A und 98725
	<li>Davicom DM9100 und DM9102
	<li>ASIX Electronics AX88140A und AX88141
	<li>ADMtek AL981 Comet und AN985 Centaur
	<li>Lite-On 82c168 und 82c169 PNIC
	<li>Lite-On/Macronix 82c115 PNIC II
<P>
Jegliche Verweise in /etc/ifaliases, /etc/ipf.rules, /etc/ipnat.rules
auf die alten Kartennamen mx, al, ax oder pn m&uuml;ssen durch dc ersetzt werden. 
Auch alle hostname.xxx Dateien m&uuml;ssen nach hostname.dcX umbenannt werden, um erkannt zu werden. 
Ersetze X mit der Kartennummer.
</ul>
<li>Lucent Technologies WaveLAN/IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&sektion=4">wi</a>
<li>Aironet Communications 4500/4800 IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&sektion=4">an</a>
</ul>

<p>
Nochmals: Du kannst mit <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
&uuml;berpr&uuml;fen, welche Karten identifiziert wurden. Hier ist die
Ausgabe einer&nbsp; ne2k Karte.
d107 8
a114 5
lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
ne3: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; media: Ethernet manual
d116 18
a133 9
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=0&lt;&gt;
bridge0: flags=0&lt;&gt;
bridge1: flags=0&lt;&gt;
d137 23
a159 27
Wie du sehen kannst, gibt <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
reichlich Information aus, die wir ben&ouml;tigen. Aber dies erlaubt uns
auch, unsere Karte zu identifizieren. Im obigen Beispiel wurde die Netzwerkkarte
bereits konfiguriert. Du kannst dies anhand der Werte &quot;inet 10.0.0.38 netmask
0xffffff00 broadcast 10.0.0.255&quot; sehen und da&szlig; die <b>UP</b> und
<b>RUNNING</b>
Kennzeichen eingeschaltet sind. Du wirst auch viele weitere Schnittstellen
bemerken. Hier eine Liste, die vorhanden sein werden.</p>

<ul>
<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion-4&format=html">lo</a>
- Loopback Schnittstelle</li>
<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4&format=html">sl</a>
- Slip Netzwerkschnittstelle</li>
<li>
ppp* - Point to Point Protokoll</li>
<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4&format=html">tun</a>
- Tunnelnetzwerkschnittstelle</li>
<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4&format=html">enc</a>
- Verkapselnde Schnittstelle</li>
<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4&format=html">bridge</a>
- Ethernet bridge Schnittstelle</li>
d163 12
a174 9
der <b>/etc/hostname.${IF}</b> Datei. Wobei der Name deiner Karte den Platz
von ${IF} einnehmen sollte. Aus der Information der obigen Beispiele w&uuml;rde
der Name <b>/etc/hostname.ne3 </b>lauten. Das Layout dieser Datei sollte
so aussehen (siehe f&uuml;r weitere Information die <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html">hostname.if(5)</a>
Manual Seite):
<ul>
<pre>[adressenfamilie] [deine_ip] [deine_netzmaske] [(media) optionen]</pre>
</ul>
F&uuml;r das obige Beispiel w&uuml;rde eine korrekte Datei so aussehen:
d176 1
a176 1
<pre>$ <b>cat /etc/hostname.ne3
d181 24
d2663 1
a2663 1
$Translation: faq6.html,v 1.39 2001/10/18 20:01:25 jufi Exp $
@


1.32
log
@
fixes.
@
text
@d924 2
a925 2
Ganz einfach: Editiere /etc/rc.conf und &auml;ndere ipf=NO in ipf=YES. Dies &auml;ndert es aber erst 
f&uuml;r das n&auml;chste Rebooten. 
d2645 1
a2645 1
Originally [OpenBSD: faq6.html,v 1.106 ]
d2647 1
a2647 1
$Translation: faq6.html,v 1.38 2001/09/19 19:12:14 jufi Exp $
d2649 1
a2649 1
<small>$OpenBSD: faq6.html,v 1.106 2001/08/25 09:31:33 jufi Exp $</small>
@


1.31
log
@
bunch of fixes from Matthias Schmidt <m.schmidt@@stud-mailer.uni-marburg.de>
@
text
@d1648 1
a1648 1
das alles beinh&auml;lt, um uns zu verbinden.
d2647 1
a2647 1
$Translation: faq6.html,v 1.37 2001/09/10 18:40:31 jufi Exp $
@


1.30
log
@
copyrighted extended and updated.
@
text
@d46 1
a46 1
<A HREF="http://www.3com.com/solutions/en_US/ncs/501302.html">Understanding IP addressing</a>.
d56 1
a56 1
Lies nach, wie sich arbeiten sollten. Die RFCs definieren mehrere (tausend)
d78 1
a78 1
Solltest du nicht den deinen Ger&auml;tenamen kennen, dann findest du hier
d90 1
a90 1
<ul>Welche Karte wie folgende beinhalten:
d150 1
a150 1
Kennzeichen eingeschalten sind. Du wirst auch viele weitere Schnittstellen
d276 1
a276 1
aber dies mu&szlig; erst eingeschalten werden. Du solltest dies mit <b>sysctl(8)</b>
d339 1
a339 1
auf der Befehlszeile. Du kannst Alias mit "<tt>ifconfig int delete</tt>" 
d421 1
a421 1
# <strong>ipf -Fa -f /etc/ipf.rules -E</strong>
d464 1
a464 1
beim Booten gelesen wird. F&uuml;r weitere Erkl&auml;rungen siehe <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=5&manpath=OpenBSD+2.7">ipf(5)</a>
d534 1
a534 1
ausdr&uuml;cklich zu erlauben. erlaubt kleineren Umfang der Regeln und
d666 1
a666 1
<p>IP Filter kann auch nach jedem IP Protokoll filtern, entweder nach seiner Nummer oder in <a href="file://localhost/etc/protocols">/etc/protocols</a>
d838 1
a838 1
z.B.: pass in log uick on fxp0 from 1.1.1.0/24 to any port = 22
d877 1
a877 1
Gem&auml;szlig; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> bietet ipnat 
d1019 1
a1019 1
NAT arbeitet auf erbl&uuml;ffend einfache Weise. Wenn ein Rechner im LAN
d1030 1
a1030 1
eigenen IP zu der von Rechner A und schick das Paket an Rechner A weiter. 
d1251 1
a1251 1
wo die NAT Regeldatei zu finden ist. NAT l&auml;ft nun. So einfach ist das.
d1484 1
a1484 1
Alles, was du in diese Datei zu schreiben hast, ist 'dhcp'.
d1514 1
a1514 1
Und die Netzwerkkarten, auf denen dhcpd <b>lauschen</b> soll, gib in /etc/dhcpd.interfaces.
d1635 1
a1635 1
wird mit &quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit dem das 
d1769 2
a1770 2
Aber manchmal kann dies (in geschlossenen Netzwerken) &uuml;tzlich sein,
vor allem wenn man &auml;tere Implementierungen des NetBIOS Protokolles
d1849 1
a1849 1
Dh., da&szlig; das lokale Dateisystem <b>/work</b> via NFS zug&auml;nglich 
d2647 1
a2647 1
$Translation: faq6.html,v 1.36 2001/08/25 09:43:31 jufi Exp $
@


1.29
log
@
cleanup
@
text
@d9 1
a9 1
<meta name="copyright" content="This document copyright 1998-2000 by OpenBSD.">
d2171 1
a2171 12
<li>Die BIND 8.x Implementation in <i>/usr/ports/net/bind8</i>. (Siehe 
<a href="../../de/ports.html">ports</a>)</li>
<li>D. J. Bernsteins <a href="http://cr.yp.to/dnscache.html">DNSCache</a>. 
DNSCAche ist auch im Ports-Verzeichnisbaum in <i>/usr/ports/net/dnscache/</i> 
zu finden. Dieses Programm beinh&auml;lt einen minimalen DNS Server, der sich 
perfekt f&uuml;r Netzwerke eignet, die nicht eine gro&szlig;e Datenbank an DNS 
Eintr&auml;gen haben. DNSCache kann auch leicht scriptgesteuert werden. Die 
Konfiguration ist sehr gut auf der Webseite dokumentiert.</li>
<li>Einige Leute, die sehr unzufrieden mit BIND waren, haben sich entschlossen,
Dents zu schreiben, ein eigener DNS Server: 
<a href="http://www.dents.org"> Dents</a>. Er enth&auml;lt einige interessante 
Optionen.</li>
d2225 2
a2226 3
backup file
cache
root.cache
d2645 1
a2645 1
Originally [OpenBSD: faq6.html,v 1.102 ]
d2647 1
a2647 1
$Translation: faq6.html,v 1.35 2001/08/18 18:42:24 jufi Exp $
d2649 1
a2649 1
<small>$OpenBSD: faq6.html,v 1.102 2001/08/08 21:06:32 jsyn Exp $</small>
@


1.28
log
@
sync with badlands translation CVS.
@
text
@d1376 1
a1376 1
neue Direktive. F&uml;ge eine Zeile wie folgende in ipnat.rules ein: 
d1817 1
a1817 1
m&oumlglicherweise deinen NFS Datenverkehr sehen. Jemand k&ouml;nnte auch 
d2176 1
a2176 1
perfekt f&uml;r Netzwerke eignet, die nicht eine gro&szlig;e Datenbank an DNS 
d2659 1
a2659 1
$Translation: faq6.html,v 1.34 2001/08/14 19:17:46 jufi Exp $
@


1.27
log
@
typos, all found by schobero.
@
text
@d2657 1
a2657 1
Originally [OpenBSD: faq6.html,v 1.101 ]
d2659 1
a2659 1
$Translation: faq6.html,v 1.33 2001/07/26 18:02:14 jufi Exp $
d2661 1
a2661 1
<small>$OpenBSD: faq6.html,v 1.101 2001/07/06 07:41:29 horacio Exp $</small>
@


1.26
log
@
better.
@
text
@d222 1
a222 1
Die Fehlermeldung betreffen das loopback Interface. Daher kann dies ignoriert
d338 1
a338 1
dann nimm "<tt>ifconfig int alias</tt>" anstelle nur nur "<tt>ifconfig int</tt>" 
d412 1
a412 1
Wenn du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> benutzt, musst du h&ouml,chstwahrscheinlich 
d877 1
a877 1
Gem&auml; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> bietet ipnat 
d1208 1
a1208 1
24.5.0.0/28 Netzwerk, f&uuml;r das dein NAt gateway als simpler Router
d1308 1
a1308 1
Dies stellt dar, da&szlig; uuml;ber die Verbindung zum Internet &uuml;ber 
d1324 1
a1324 1
Es gibt a paar Einschr&auml;nkungen von NAT. Eine ist bei FTP. Wenn ein Benutzer 
d1336 1
a1336 1
Dies teilt dem Server mit, da&szlig; dich du selbst aktiv zum Server verbinden 
d1584 1
a1584 1
Einige von diesen ben&ouml;tigst du nicht unbedingt, aber sie w&aum;ren hilfreich. 
d1729 1
a1729 1
Verbindung gerade erichtet oder beendet wurde. F&uuml;r diese F&auml;lle gibts es zwei 
d2171 1
a2171 1
<li>Die BIND 8.x Implementation in <i>/usr/ports/net/bind8</i>. (See 
d2200 1
a2200 1
Wenn die standm&auml;ssige Netzwerkinstallation korrekt bei der 
d2445 1
a2445 1
solange er l&auml;ft, kannst du in der ersten Zeile der Datei 
d2494 1
a2494 1
zur options Sektion der Konfigurationsdatei hinzuf&uulm;gst:
d2659 1
a2659 1
$Translation: faq6.html,v 1.32 2001/07/22 19:56:06 jufi Exp $
@


1.25
log
@
ipf man page changes
@
text
@d90 1
a90 1
<ul>Welche Karte wie folgende inkludieren:
d114 1
a114 1
li>Lucent Technologies WaveLAN/IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&sektion=4">wi</a>
d1830 1
a1830 1
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS f&uml;r 
d1862 1
a1862 1
enth&auml;lt. (Der GENERIC Kernel hat diese Optionen inkludiert.) Dann 
d2659 1
a2659 1
$Translation: faq6.html,v 1.31 2001/07/08 15:11:31 jufi Exp $
@


1.24
log
@
sync with badlands translation CVS.
@
text
@d295 1
a295 1
</b>net.inet.ip.forwarding: 0 -> 1
d393 2
a394 2
Berechtigungen von packet level forwarding <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=8&format=html">ipf(8)</a>
und das Umlegen von hosts/subnets auf einen externen Adressbereich <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&apropos=0&sektion=8&format=html">ipnat(8)</a>.
d408 1
a408 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">ipnat(8)</a> benutzt, muss ipfilter auch zwingend aktiviert sein.
d412 1
a412 1
Wenn du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">ipnat(8)</a> benutzt, musst du h&ouml,chstwahrscheinlich 
d439 1
a439 1
Um ipmon im Debugmodus zu starten:
d445 2
a446 2
Dieses Dokument wird einige grundlegende <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8">ipf(8)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">ipnat(8)</a> Konfigurationen
d464 1
a464 1
beim Booten gelesen wird. F&uuml;r weitere Erkl&auml;rungen siehe <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=5&format=html">ipf(5)</a>.
d1044 1
a1044 1
Von:  192.168.1.40  >>=== NAT ===>>     Von:  24.5.0.5
d1049 1
a1049 1
Nach: 192.168.1.40  <<=== NAT ===<<     Nach: 24.5.0.5
d1136 2
a1137 2
map dc0 192.168.1.0/24 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -> 24.5.0.5/32
d1215 2
a1216 2
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -> 24.5.0.5/32
d1277 2
a1278 2
map dc0 192.168.1.0/24 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -> 24.5.0.5/32
d1281 1
a1281 1
MAP 192.168.1.40  2473  <- -> 24.5.0.5  13463 [129.128.5.191 80]
d1345 1
a1345 1
map dc0 192.168.1.0/24 -> 24.5.0.5/32 proxy port ftp ftp/tcp
d1380 1
a1380 1
rdr dc0 24.5.0.5/32 port 80 -> 192.168.1.80 port 80
d1467 2
a1468 2
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&format=html">Man page showing correct ipnat.rules syntax</a>
d1486 1
a1486 1
# <strong>echo dhcp >/etc/hostname.xl0</strong>
d1516 1
a1516 1
# <strong>echo xl1 xl2 xl3 >/etc/dhcpd.interfaces</strong>
d2352 1
a2352 1
; <<>> DiG 2.2 <<>> @@nemo.yewtopia yewtopia any any
d2356 1
a2356 1
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 59904
d2657 1
a2657 1
Originally [OpenBSD: faq6.html,v 1.100 ]
d2659 1
a2659 1
$Translation: faq6.html,v 1.30 2001/06/15 20:16:48 jufi Exp $
d2661 1
a2661 1
<small>$OpenBSD: faq6.html,v 1.100 2001/06/14 22:57:01 fgsch Exp $</small>
@


1.23
log
@ipnat.conf -> ipnat.rules; spotted by bignose at irc.
@
text
@d2657 1
a2657 1
Originally [OpenBSD: faq6.html,v 1.99 ]
d2659 1
a2659 1
$Translation: faq6.html,v 1.29 2001/05/18 20:13:39 jufi Exp $
d2661 1
a2661 1
<small>$OpenBSD: faq6.html,v 1.22 2001/05/18 21:28:23 jufi Exp $</small>
@


1.22
log
@
Several typos.
@
text
@d1376 1
a1376 1
neue Direktive. F&uml;ge eine Zeile wie folgende in ipnat.conf ein: 
d2661 1
a2661 1
<small>$OpenBSD: faq6.html,v 1.99 2001/05/06 16:33:15 jufi Exp $</small>
@


1.21
log
@
Updated.
@
text
@d100 1
a100 1
Welche Karten wie folgt inkludieren: 
d110 1
a110 1
zu den alten Kartennamen mx, al, ax oder pn m&uuml;ssen durch dc ersetzt werden. 
d2659 1
a2659 1
$Translation: faq6.html,v 1.28 2001/05/06 16:44:56 jufi Exp $
@


1.20
log
@
Link corrected.
@
text
@d114 2
d398 17
a414 5
Du mu&szlig;t /etc/rc.conf editieren, um sie beim Starten zu aktivieren.
Und net.inet.ip.forwarding=1 mu&szlig; in deiner /etc/sysctl.conf gesetzt
sein (oder dein Kernel mu&szlig; mit IPFORWARDING oder GATEWAY Option AN
kompiliert sein.). Du brauchst auch einen Kernel mit den Optionen IPFILTER
und IPFILTER_LOG (GENERIC Kernel haben diese Optionen).
d418 1
a418 1
Wenn du IP Filter im Kernel einkompiliert hast, aber nicht in /etc/rc.conf
d421 2
a422 2
<pre># ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules</pre>
d428 1
a428 1
die Regeln aus der Datei /etc/ipf.rules.
d430 1
a430 1
<p>Wenn du /etc/ipf.rules nach dem Laden von ipf &auml;nderst, kannst du
d433 1
a433 1
<pre># ipf -Fa -f /etc/ipf.rules</pre>
d437 1
a437 1
<pre># ipnat -CF -f /etc/ipnat.rules</pre>
d441 1
a441 1
<pre># ipmon -Ds</pre>
d445 3
a447 2
Dieses Dokument wird einige grundlegende ipf und ipnat Konfigurationen
im Folgenden darstellen. In /usr/share/ipf/ findest du ein paar nette Beispiele
a543 3
#############################
# beginn regelsatz
#############################
a548 3
##############################
# ende regelsatz
##############################
a562 3
#############################
# beginn regelsatz
#############################
a567 3
##############################
# ende regelsatz
##############################
d614 1
a614 4
###########################
# beginn regelsatz
###########################
# loopback regeln
d647 1
a647 3
#############################
# ende regelsatz
#############################</pre>
a754 3
#############################
# beginn regelsatz
#############################
a759 3
##############################
# ende regelsatz
##############################</pre>
a773 3
#############################
# beginn regelsatz
#############################
d779 1
a779 3
##############################
# ende regelsatz
##############################</pre>
a788 3
###########################
# beginn regelsatz
###########################
a830 3
#############################
# ende regelsatz
#############################
d1203 17
d2227 1
a2227 1
<h4>6.8.5.1 Konfiguration in <i>/etc/named</i></h4>
d2657 1
a2657 1
Originally [OpenBSD: faq6.html,v 1.93 ]
d2659 1
a2659 1
$Translation: faq6.html,v 1.26 2001/04/19 18:13:35 jufi Exp $
d2661 1
a2661 1
<small>$OpenBSD: faq6.html,v 1.93 2001/04/18 17:59:57 ericj Exp $</small>
@


1.19
log
@
Updated.
@
text
@d46 1
a46 1
<a href="http://www.3com.com/nsc/501302s.html">Understanding IP addressing</a> 
d2659 1
a2659 1
Originally [OpenBSD: faq6.html,v 1.92 ]
d2661 1
a2661 1
$Translation: faq6.html,v 1.25 2001/04/03 19:14:43 jufi Exp $
d2663 1
a2663 1
<small>$OpenBSD: faq6.html,v 1.92 2001/03/30 18:57:15 ericj Exp $</small>
@


1.18
log
@
Updates and typos.
@
text
@d2429 1
a2429 1
# <strong>ndc restart</strong>
d2659 1
a2659 1
Originally [OpenBSD: faq6.html,v 1.91 ]
d2661 1
a2661 1
$Translation: faq6.html,v 1.24 2001/03/27 18:02:14 jufi Exp $
d2663 1
a2663 1
<small>$OpenBSD: faq6.html,v 1.91 2001/03/27 17:40:26 jufi Exp $</small>
@


1.17
log
@
Updated.
@
text
@d39 1
a39 1
gelesen und zumindest teilweise verstanden zu haben, weiters helfen die
d45 1
a45 1
&uuml;ber IP Netzwerken mit 
d47 1
a47 1
vertiefen. Dies ist ein exzellentes Dokument. "Understanding IP addressing" 
d70 2
a71 2
initialisiert wurde entweder beim Booten oder sp&auml;ter mittel mit dem
Befehl <b>dmesg(8)</b>. Weiters kannst du mit dem Befehl <b>ifconfig(8)</b>
d2216 1
a2216 1
<b>named</b> ist. Weiters gibt es ein paar andere notwendige 
d2659 1
a2659 1
Originally [OpenBSD: faq6.html,v 1.89 ]
d2661 1
a2661 1
$Translation: faq6.html,v 1.23 2001/03/22 21:05:52 jufi Exp $
d2663 1
a2663 1
<small>$OpenBSD: faq6.html,v 1.89 2001/03/17 20:59:33 austin Exp $</small>
@


1.16
log
@
Sync with translation CVS.
@
text
@d2659 1
a2659 1
Originally [OpenBSD: faq6.html,v 1.88 ]
d2661 1
a2661 1
$Translation: faq6.html,v 1.22 2001/02/20 11:42:06 jufi Exp $
d2663 1
a2663 1
<small>$OpenBSD: faq6.html,v 1.88 2001/01/27 22:19:47 ericj Exp $</small>
@


1.15
log
@typo
@
text
@d76 2
a77 2
ne3: address 00:e0:98:04:95:ba</pre>
</ul>
d139 1
a139 2
</pre>
</ul>
d183 2
a184 2
</b>inet 10.0.0.38 255.255.255.0 NONE</pre>
</ul>
d203 2
a204 2
lookup file bind</pre>
</ul>
d216 2
a217 2
add net 224.0.0.0: gateway 127.0.0.1: File exists</pre>
</ul>
d256 1
a256 1
</ul></pre>
d282 2
a283 2
<pre>net.inet.ip.forwarding=1</pre>
</ul>
d293 2
a294 2
</b>net.inet.ip.forwarding: 0 -> 1</pre>
</ul>
d369 2
a370 2
<pre># <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b></pre>
</ul>
d382 1
a382 2
</ul></pre>

a909 1
</pre>
d1600 1
a1600 2
</pre></ul></strong>

d2397 1
a2397 1

d2404 1
a2404 1
</ul></pre>
d2456 1
a2456 1
</ul></pre>
d2484 1
a2484 1
<pre><ul>
d2497 1
a2497 1
<pre><ul>
d2503 1
a2503 1
Bei Bind 4 (Standard in OpenBSD) kannst du /var/named/named.boot anpassen und die 'xfrnets' Option nutzen.<br><pre><ul>
d2567 1
a2567 1
Diese packages benutzen das standardm&auml;ssige OpenBSD 
d2659 1
a2659 1
Originally [OpenBSD: faq6.html,v 1.86 ]
d2661 1
a2661 1
$Translation: faq6.html,v 1.21 2000/12/28 21:43:02 jufi Exp $
d2663 1
a2663 1
<small>$OpenBSD: faq6.html,v 1.14 2000/12/28 21:53:33 jufi Exp $</small>
@


1.14
log
@
Adding pptp
@
text
@d2571 1
a2571 1
Diese packages benutzen das standarm&auml;ssige OpenBSD 
d2667 1
a2667 1
<small>$OpenBSD: faq6.html,v 1.86 2000/12/26 20:07:04 ericj Exp $</small>
@


1.13
log
@
Cleanup
@
text
@d20 10
a29 18
<li>
<a href="#6.0.1">6.0.1 - Bevor wir weiter gehen</a></li>
<li>
<a href="#6.1">6.1 - Erste Netzwerkeinstellungen</a></li>
<li>
<a href="#6.2">6.2 - IPF - IP Filter</a></li>
<li>
<a href="#6.3">6.3 - NAT - Network Address Translation</a></li>
<li>
<a href="#6.4">6.4 - DHCP - Dynamic Host Configuration Protocol</a></li>
<li>
<a href="#6.5">6.5 - PPP - Point to Point Protocol</a></li>
<li>
<a href="#6.6">6.6 - Optimieren der Netzwerkparameter</a></li>
<li>
<a href="#6.7">6.7 - NFS benutzen</a></li>
<li>
<a href= "#6.8">6.8 - DNS - Domain Name Service  - DNS, BIND und named</a>
d2522 95
a2616 3
Um eine laufende Instanz des Nameserverdienstes zum erneuten Einlesen 
seiner Konfiguration zu bewegen, nachdem du &Auml;nderung durchgef&uuml;hrt 
hast, sende ein "hangup" Signal:
d2619 3
d2623 1
a2623 1
# <strong>kill -HUP 4608</strong> 
d2626 1
d2628 2
a2629 2
oder verwende den <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> 
Befehl. Z. B.:
d2633 2
a2634 1
# <strong>ndc restart</strong>
d2637 7
d2645 4
d2663 1
a2663 1
Originally [OpenBSD: faq6.html,v 1.85 ]
d2665 1
a2665 1
$Translation: faq6.html,v 1.20 2000/12/26 19:46:41 jufi Exp $
d2667 1
a2667 1
<small>$OpenBSD: faq6.html,v 1.85 2000/12/26 17:06:36 ericj Exp $</small>
@


1.12
log
@
Typo.
@
text
@d321 2
d324 3
a326 1
einzurichten. Dazu mu&szlig;t du nur die Datei <i>/etc/ifaliases</i> editieren.
a340 9
Das Format der <i>/etc/ifaliases</i> Datei ist:
</p>

<ul>
<pre>[interface] [ip adresse] [netmask]
</pre>
</ul>

<p>
d354 1
a354 1
In diesem Beispiel <i>/etc/ifaliases</i> werden zwei Alias zur Netzwerkkarte 
d360 1
a360 4
<pre>$ <b>cat /etc/ifaliases</b>
dc0	192.168.0.3	255.255.255.255
dc0	192.168.0.4	255.255.255.255
</ul></pre>
d362 1
a362 14
<p>
Auf allen wurde die 255.255.255.255 Netzmaske verwendet, damit keine doppelten 
Routingtabelleneintr&auml;ge f&uml;r dasselbe Netzwerk kreiert werden.

<p>
<b>ANMERKUNG</b>:
<br>
Ab Version OpenBSD 2.7 werden die Aliases in der Datei <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html">/etc/hostname.*</a></i>&nbsp;
gesetzt. F&uuml;r das obige Beispiel m&uuml;&szlig;test du eine Datei <i>/etc/hostname.dc0</i>
mit folgendem Inhalt haben:
</p>

<ul>
<pre>
d1685 1
a1685 1
&quot;set timeout&quot; setzt den timeout f&uuml;r den gesamten login-Prozess auf 120 
d2563 1
a2563 1
Originally [OpenBSD: faq6.html,v 1.83 ]
d2565 1
a2565 1
$Translation: faq6.html,v 1.19 2000/12/12 18:35:47 jufi Exp $
d2567 1
a2567 1
<small>$OpenBSD: faq6.html,v 1.82 2000/11/24 05:36:07 jeremy Exp $</small>
a2570 2


@


1.11
log
@
More updates
@
text
@d930 1
a930 1
Dies ist sehr n&uuml;, wenn man nicht f&uuml; jeden Rechner des internen Netzwerkes eine 
d2586 1
a2586 1
$Translation: faq6.html,v 1.18 2000/11/30 14:49:49 reinhard Exp $
@


1.10
log
@
Updated.
@
text
@d874 3
a876 3
pass in      quick on fxp0 proto tcp  from any to any flags S keep state
pass in      quick on fxp0 proto udp  from any to any         keep state
pass in      quick on fxp0 proto icmp from any to any         keep state
d1683 1
a1683 1
das alles beinh&auml;t, um uns zu verbinden.
d1721 1
a1721 1
mu&szli; und der gesamte Ausdruck ersetzt werden kann. Die zweite IP behandelt die von 
d2550 1
a2550 1
<h3>6.8.8 Was hast du mir nicht &uuml,ber das Aufsetzen von DNS erz&auml;hlt?</h3>
d2584 1
a2584 1
Originally [OpenBSD: faq6.html,v 1.82 ]
d2586 1
a2586 1
$Translation: faq6.html,v 1.15 2000/11/24 19:11:56 jufi Exp $
@


1.9
log
@
Link corrected.
@
text
@d868 9
a876 1
pass out on fxp0 proto tcp from any to any keep state
d2584 1
a2584 1
Originally [OpenBSD: faq6.html,v 1.81 ]
d2586 1
a2586 1
$Translation: faq6.html,v 1.14 2000/11/16 22:50:11 jufi Exp $
d2588 1
a2588 1
<small>$OpenBSD: faq6.html,v 1.81 2000/11/15 22:06:06 chris Exp $</small>
@


1.8
log
@
Updated.
@
text
@d57 2
a58 1
kann!
d61 1
a61 1
k&ouml;nntest du viel vom Lesen der entsprechenden <a href="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">RFCs</a>
d2576 1
a2576 1
Originally [OpenBSD: faq6.html,v 1.80 ]
d2578 1
a2578 1
$Translation: faq6.html,v 1.13 2000/11/10 18:24:07 jufi Exp $
d2580 1
a2580 1
<small>$OpenBSD: faq6.html,v 1.80 2000/11/10 14:03:33 art Exp $</small>
@


1.7
log
@
Even more updates..
@
text
@d2575 1
a2575 1
Originally [OpenBSD: faq6.html,v 1.79 ]
d2577 1
a2577 1
$Translation: faq6.html,v 1.12 2000/09/18 17:57:22 jufi Exp $
d2579 1
a2579 1
<small>$OpenBSD: faq6.html,v 1.79 2000/09/17 16:13:49 jeremy Exp $</small>
@


1.6
log
@
Well... updated.
@
text
@d2485 57
a2559 2
<h3>6.8.7 Was hast du mir nicht &uuml;ber das Einrichten von DNS 
erz&auml;hlt?</h3>
a2560 8
<p>
Es gibt vieles, das wir dir nicht erz&auml;hlt haben. Z. B. wie man DNS 
so einrichtet, da&szlig; Anfragen &uuml;ber Intranetdom&auml;nen, die nicht 
f&uuml;r die Dom&auml;nenhierarchie sichtbar sind, an Server innerhalb 
deines Unternehmens weitergeleitet werden. Lies die von uns 
<a href="#6.8.1.1">Empfohlenen Dokumente</a> f&uuml;r weitergehende Information
&uuml;ber DNS. 
</p>
d2575 1
a2575 1
Originally [OpenBSD: faq6.html,v 1.78 ]
d2577 1
a2577 1
$Translation: faq6.html,v 1.11 2000/09/16 13:19:57 jufi Exp $
d2579 1
a2579 1
<small>$OpenBSD: faq6.html,v 1.78 2000/09/15 21:23:34 jeremy Exp $</small>
@


1.5
log
@
Syncing with badlands-CVS.
@
text
@d794 1
a794 1
pass out on fxp0 from any to any proto tcp keep state
d807 1
a807 1
SIN und SIN/ACK Kennzeichen. Indem wir nur solche Pakete durchlassen, k&ouml;nnen
d819 1
a819 1
pass out on fxp0 from any to any proto tcp keep state
d867 1
a867 1
pass out on fxp0 from any to any proto tcp keep state
d2528 1
a2528 1
Originally [OpenBSD: faq6.html,v 1.76 ]
d2530 1
a2530 1
$Translation: faq6.html,v 1.9 2000/09/12 18:57:59 jufi Exp $
d2532 1
a2532 1
<small>$OpenBSD: faq6.html,v 1.76 2000/09/09 21:31:03 jeremy Exp $</small>
@


1.4
log
@
Updated.
@
text
@d2530 1
a2530 1
$Translation: faq6.html,v 1.8 2000/09/12 18:49:46 jufi Exp $
@


1.3
log
@
Updated and a little cleanup.
@
text
@d455 4
d783 2
d794 1
a794 1
pass out on fxp0 from any to any keep state
d819 1
a819 1
pass out on fxp0 from any to any keep state
d867 1
a867 1
pass out on fxp0 from any to any keep state
d877 7
d2528 1
a2528 1
Originally [OpenBSD: faq6.html,v 1.75 ]
d2530 1
a2530 1
$Translation: faq6.html,v 1.5 2000/08/21 17:38:56 jufi Exp $
d2532 1
a2532 1
<small>$OpenBSD: faq6.html,v 1.75 2000/08/21 16:48:58 jufi Exp $</small>
@


1.2
log
@
Adding two more and modifying the links to them.
@
text
@d56 1
a56 1
beinh&auml;lt grundlegendes Wissen, auf dem man beim IP Netzwerken aufbauen 
d934 1
a934 1
Der Prozess des NAT wird später in diesem Dokument beschrieben.
d942 2
a943 2
Abkürzung für "IP Network Address Translation", kann mit NAT austauschbar verwendet werden. 
In diesem Dokument wird der Terminus "ipnat" aber nur für die Kommandozeile verwendet werden.
d951 5
a955 5
Abkürzung für "IP Filter." IP Filter ist eine portable Paketfilterungssoftware, welche 
Teil von OpenBSD ist. IP Filter muß zuerst aktiviert werden, bevor man ipnat benutzen kann. 
Ganz einfach: Editiere /etc/rc.conf und ändere ipf=NO in ipf=YES. Dies ändert es aber erst 
für das nächste Rebooten. 
Mit 'ipf -E' schaltest du es im laufenden Betrieb ein. Genaueres natürlich später. 
d965 2
a966 2
von diesen abweichen, aber der Zweck dieses Dokumentes ist, dir eine Übersicht zu verschaffen, 
damit du diese Information für deine Bedürfnisse verwenden kannst.
d996 3
a998 3
Es gibt eine große Anzahl verschiedener Betriebssysteme im internen LAN wie Windows 98,
Windows NT, OpenBSD und Linux. Jeder Rechner ist mit einem Hub, der für den internen 
Gebrauch bereitsteht, verbunden. Für diese Dokument und dessen Beispiele wird der 
d1028 1
a1028 1
<b>Einführung zu NAT</b>
d1032 2
a1033 2
muß jeder eine IP Adresse haben. &Ouml;ffentliche IP Adressen sind immer 
schwieriger zu bekommen. Die Lösung für viele Leute ist Network 
d1036 1
a1036 1
ohne IP Adressen kaufen oder mieten zu müssen. NAT ist unter Linuxbenutzern 
d1048 1
a1048 1
NAT arbeitet auf erblüffend einfache Weise. Wenn ein Rechner im LAN
d1052 4
a1055 4
die erwünschte Server IP Adresse (z. B. 123.45.67.89). Die Maschine mit NAT 
fängt das TCP Paket ab und ändert die Rechner IP Adresse in die Adresse des 
Rechners, der mit dem Internet verbunden ist (z. B. 24.5.0.5). Dies täuscht 
den Server eigentlich, indem es ihn glauben macht, daß die Verbindung vom 
d1057 2
a1058 2
dann die Antworten zurück zum NAT Rechner. Wenn der NAT Rechner 
die Antwort erhält, dann übersetzt er die Zieladresse zurück von seiner 
d1060 1
a1060 1
Rechner A bekommt von alledem nichts mit und die vorgetäuschte Internetverbindung 
d1065 1
a1065 1
Das folgende Beispiel zeigt NAT noch ein bißchen deutlicher:
d1087 1
a1087 1
Problem. Wie können meine Zimmerkameraden Internetanschluß bekommen, wenn 
d1089 1
a1089 1
zusätzliche IP Adressen kaufen, einen Proxyserver aufsetzen oder eben NAT 
d1091 1
a1091 1
(Laß dich nicht vom Kabelmodembeispiel täuschen: NAT ist fähig, ein großes 
d1096 1
a1096 1
Es gibt viele Gründe, warum ich NAT aufsetzen wollte. Nummer eins: Geld sparen. 
d1099 1
a1099 1
D. h., daß wir nicht genug IPs hätten, um jedem Rechner Internetzugang zu 
d1113 3
a1115 3
Damit NAT auf deinem OpenBSD Rechner läuft, mußt du zunächst 
IPF und NAT aktivieren. Dies geschieht einfach, indem du die unten angeführten 
Dateien editierst (ändere die Dateien gemäß den folgenden Optionen):
d1119 1
a1119 1
<b>/etc/rc.conf</b> (diese Datei wird beim Booten fürs Starten von Diensten gelesen)
d1136 1
a1136 1
Nachdem diese Änderungen durchgeführt wurden, ist der Rechner endlich für die 
d1146 1
a1146 1
Dafür werden wir in diesem Dokument jeden Datenverkehr durch diese Firewall passieren 
d1156 1
a1156 1
Siehe wiederum <a href="#6.2">FAQ 6.2</a> für weitere Informationen.
d1161 1
a1161 1
Um obige Konfiguration fortzusetzen, sollte die Datei die folgenden Einträge enthalten: 
d1170 1
a1170 1
Hier eine Erklärung für die obigen Zeilen.
d1176 2
a1177 2
Der Befehl an ipnat. Er besagt, daß dieser Eintrag die IP Adressen zwischen 
LAN und the Internet ändert.
d2515 1
a2515 1
Originally [OpenBSD: faq6.html,v 1.74 ]
d2517 1
a2517 1
$Translation: faq6.html,v 1.2 2000/08/11 16:47:26 jufi Exp $
d2519 1
a2519 1
<small>$OpenBSD$</small>
@


1.1
log
@+faq6
@
text
@d2506 1
a2506 1
<a href= "../faq7.html">[Zu Kapitel 7.0 - Tastatureinstellungen]</a>
d2517 1
a2517 1
$Translation: faq6.html,v 1.1 2000/07/18 16:02:00 reinhard Exp $
@

