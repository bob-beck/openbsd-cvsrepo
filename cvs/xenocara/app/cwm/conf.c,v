head	1.230;
access;
symbols
	OPENBSD_6_0:1.202.0.4
	OPENBSD_6_0_BASE:1.202
	OPENBSD_5_9:1.202.0.2
	OPENBSD_5_9_BASE:1.202
	OPENBSD_5_8:1.191.0.2
	OPENBSD_5_8_BASE:1.191
	OPENBSD_5_7:1.184.0.2
	OPENBSD_5_7_BASE:1.184
	OPENBSD_5_6:1.173.0.2
	OPENBSD_5_6_BASE:1.173
	OPENBSD_5_5:1.172.0.2
	OPENBSD_5_5_BASE:1.172
	OPENBSD_5_4:1.145.0.2
	OPENBSD_5_4_BASE:1.145
	OPENBSD_5_3:1.121.0.2
	OPENBSD_5_3_BASE:1.121
	OPENBSD_5_2:1.99.0.2
	OPENBSD_5_2_BASE:1.99
	OPENBSD_5_1_BASE:1.97
	OPENBSD_5_1:1.97.0.2
	OPENBSD_5_0:1.89.0.2
	OPENBSD_5_0_BASE:1.89
	OPENBSD_4_9:1.76.0.4
	OPENBSD_4_9_BASE:1.76
	OPENBSD_4_8:1.76.0.6
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.76.0.2
	OPENBSD_4_7_BASE:1.76
	OPENBSD_4_6:1.66.0.2
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.57.0.2
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.230
date	2016.12.06.21.59.33;	author okan;	state Exp;
branches;
next	1.229;
commitid	YeXGci1FHYjo8hBc;

1.229
date	2016.12.06.15.03.13;	author okan;	state Exp;
branches;
next	1.228;
commitid	FEGvPwQ9VZf4WZtI;

1.228
date	2016.12.02.17.02.17;	author okan;	state Exp;
branches;
next	1.227;
commitid	wZMenVcShdNIKw9I;

1.227
date	2016.12.02.16.50.19;	author okan;	state Exp;
branches;
next	1.226;
commitid	JuAAcvroeYEwbkyt;

1.226
date	2016.12.01.18.17.52;	author okan;	state Exp;
branches;
next	1.225;
commitid	xRY1Peh5GoP8Vw8q;

1.225
date	2016.12.01.17.17.27;	author okan;	state Exp;
branches;
next	1.224;
commitid	Qz0ivc5HOpzrYaDs;

1.224
date	2016.11.15.00.22.02;	author okan;	state Exp;
branches;
next	1.223;
commitid	OqYiQl9bHme9at14;

1.223
date	2016.11.15.00.07.03;	author okan;	state Exp;
branches;
next	1.222;
commitid	PYr7HT01LVQhfDh6;

1.222
date	2016.11.14.21.25.59;	author okan;	state Exp;
branches;
next	1.221;
commitid	vHOoPGxkcPiAilEG;

1.221
date	2016.11.14.19.56.05;	author okan;	state Exp;
branches;
next	1.220;
commitid	od5RWGI7xDBAwCjg;

1.220
date	2016.11.14.13.52.33;	author okan;	state Exp;
branches;
next	1.219;
commitid	7Er2xakZgyNCGbVV;

1.219
date	2016.10.24.20.44.08;	author okan;	state Exp;
branches;
next	1.218;
commitid	lzO3MzgydwqlVR1a;

1.218
date	2016.10.24.17.39.38;	author okan;	state Exp;
branches;
next	1.217;
commitid	4CtR29PGziRtkeB6;

1.217
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.216;
commitid	dIOrHVlb55Ubzrpl;

1.216
date	2016.10.06.14.53.52;	author okan;	state Exp;
branches;
next	1.215;
commitid	bbvW6xIykd8xNbAy;

1.215
date	2016.10.06.14.41.19;	author okan;	state Exp;
branches;
next	1.214;
commitid	dEdTnOYrabSl1oRa;

1.214
date	2016.10.05.13.35.17;	author okan;	state Exp;
branches;
next	1.213;
commitid	9nQrus4AKYuPgz4t;

1.213
date	2016.10.05.13.10.59;	author okan;	state Exp;
branches;
next	1.212;
commitid	LHP16HwBOYF7jUIx;

1.212
date	2016.10.04.15.52.32;	author okan;	state Exp;
branches;
next	1.211;
commitid	YwD6cS669TAwbf4b;

1.211
date	2016.10.04.15.18.20;	author okan;	state Exp;
branches;
next	1.210;
commitid	A3zvKURgft7ltYQX;

1.210
date	2016.10.03.18.43.49;	author okan;	state Exp;
branches;
next	1.209;
commitid	5hMp5cE2gxBlRBhs;

1.209
date	2016.10.03.14.42.34;	author okan;	state Exp;
branches;
next	1.208;
commitid	sciYi1tUXUIu4s4n;

1.208
date	2016.09.30.18.28.06;	author okan;	state Exp;
branches;
next	1.207;
commitid	STecP6DPl2bavnIv;

1.207
date	2016.09.29.00.21.55;	author okan;	state Exp;
branches;
next	1.206;
commitid	T0a7tiQalU2SO4pS;

1.206
date	2016.09.22.14.36.03;	author okan;	state Exp;
branches;
next	1.205;
commitid	ITo2h4srkSgvGLD0;

1.205
date	2016.09.12.13.47.00;	author okan;	state Exp;
branches;
next	1.204;
commitid	8I0BfkPBEKxJkrSn;

1.204
date	2016.08.13.09.59.48;	author matthieu;	state Exp;
branches;
next	1.203;
commitid	shmreKhVdViuVWEI;

1.203
date	2016.08.13.09.58.37;	author matthieu;	state Exp;
branches;
next	1.202;
commitid	iwPE1RQI8qHiaxKZ;

1.202
date	2015.11.17.15.19.19;	author okan;	state Exp;
branches;
next	1.201;
commitid	FgJ4rf0HjYksH369;

1.201
date	2015.11.12.21.28.03;	author okan;	state Exp;
branches;
next	1.200;
commitid	Hq4BZzA3Nlni69Xf;

1.200
date	2015.11.12.18.26.41;	author okan;	state Exp;
branches;
next	1.199;
commitid	6VVx4mZhWgIPlBck;

1.199
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.198;
commitid	vKzF5zXTpUgY9uJK;

1.198
date	2015.09.16.17.58.25;	author okan;	state Exp;
branches;
next	1.197;
commitid	5LZITTZspXcfHMXf;

1.197
date	2015.08.24.15.42.57;	author okan;	state Exp;
branches;
next	1.196;
commitid	xGzIdCzrHkoqADxN;

1.196
date	2015.08.24.14.56.10;	author okan;	state Exp;
branches;
next	1.195;
commitid	3heeYolWUzcrSGXI;

1.195
date	2015.08.21.16.52.37;	author okan;	state Exp;
branches;
next	1.194;
commitid	dg8NUwKKSZKDgRDL;

1.194
date	2015.08.21.16.30.02;	author okan;	state Exp;
branches;
next	1.193;
commitid	MiLmJumEJ6sclldP;

1.193
date	2015.08.21.15.55.39;	author okan;	state Exp;
branches;
next	1.192;
commitid	SWtrldSBzwxPBr2S;

1.192
date	2015.08.20.14.45.15;	author okan;	state Exp;
branches;
next	1.191;
commitid	gS5us9tI3RPO6I5g;

1.191
date	2015.07.12.14.31.47;	author okan;	state Exp;
branches;
next	1.190;
commitid	vbdA9GL2PIvC62Ws;

1.190
date	2015.07.01.14.36.42;	author okan;	state Exp;
branches;
next	1.189;
commitid	HEkKIvh6L9ijX1lH;

1.189
date	2015.06.30.18.44.29;	author okan;	state Exp;
branches;
next	1.188;
commitid	9JN09UpruBUKLPAV;

1.188
date	2015.06.30.18.42.50;	author okan;	state Exp;
branches;
next	1.187;
commitid	mctqLOFykKSdPMbE;

1.187
date	2015.05.21.00.37.04;	author okan;	state Exp;
branches;
next	1.186;
commitid	8wlAl4DgmYSCpXux;

1.186
date	2015.05.17.04.34.01;	author kspillner;	state Exp;
branches;
next	1.185;
commitid	vOYrUv5aGh2lx3AQ;

1.185
date	2015.03.26.21.41.43;	author okan;	state Exp;
branches;
next	1.184;
commitid	4dplVPN42tl2nHll;

1.184
date	2015.01.24.18.16.59;	author okan;	state Exp;
branches;
next	1.183;
commitid	3CW2q5x1lhE8ulvJ;

1.183
date	2015.01.23.20.26.36;	author okan;	state Exp;
branches;
next	1.182;
commitid	DgIBcAtgSJzH0JuJ;

1.182
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.181;
commitid	kLADTGYX3gw0Sf2m;

1.181
date	2014.09.17.18.41.44;	author okan;	state Exp;
branches;
next	1.180;
commitid	7QDlXoO0YzmTdgVS;

1.180
date	2014.09.17.16.00.44;	author okan;	state Exp;
branches;
next	1.179;
commitid	PwtpIdl7nXCakavw;

1.179
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.178;
commitid	jXQ1fztXcP9vyPb1;

1.178
date	2014.09.06.16.14.35;	author okan;	state Exp;
branches;
next	1.177;
commitid	SwO1sBFRHuUKBTtD;

1.177
date	2014.08.25.12.49.19;	author okan;	state Exp;
branches;
next	1.176;
commitid	rbGNqfikQcQWLop3;

1.176
date	2014.08.24.15.49.58;	author okan;	state Exp;
branches;
next	1.175;
commitid	pXioS0fW24I81dRl;

1.175
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.174;
commitid	SsDu0AngUZExtrz4;

1.174
date	2014.08.19.18.39.41;	author okan;	state Exp;
branches;
next	1.173;
commitid	934vsWvyeiN52YO1;

1.173
date	2014.04.21.12.52.14;	author okan;	state Exp;
branches;
next	1.172;

1.172
date	2014.02.02.16.29.04;	author okan;	state Exp;
branches;
next	1.171;

1.171
date	2014.02.02.15.46.05;	author okan;	state Exp;
branches;
next	1.170;

1.170
date	2014.01.30.22.17.22;	author okan;	state Exp;
branches;
next	1.169;

1.169
date	2014.01.30.15.43.53;	author okan;	state Exp;
branches;
next	1.168;

1.168
date	2014.01.30.14.40.21;	author okan;	state Exp;
branches;
next	1.167;

1.167
date	2014.01.29.22.30.00;	author okan;	state Exp;
branches;
next	1.166;

1.166
date	2014.01.29.21.13.52;	author okan;	state Exp;
branches;
next	1.165;

1.165
date	2014.01.29.18.43.27;	author okan;	state Exp;
branches;
next	1.164;

1.164
date	2014.01.29.18.34.22;	author okan;	state Exp;
branches;
next	1.163;

1.163
date	2014.01.28.20.22.21;	author okan;	state Exp;
branches;
next	1.162;

1.162
date	2014.01.23.17.13.38;	author okan;	state Exp;
branches;
next	1.161;

1.161
date	2014.01.22.21.48.27;	author okan;	state Exp;
branches;
next	1.160;

1.160
date	2014.01.21.15.42.44;	author okan;	state Exp;
branches;
next	1.159;

1.159
date	2014.01.20.23.03.51;	author okan;	state Exp;
branches;
next	1.158;

1.158
date	2014.01.20.22.31.53;	author okan;	state Exp;
branches;
next	1.157;

1.157
date	2014.01.20.21.34.32;	author okan;	state Exp;
branches;
next	1.156;

1.156
date	2014.01.20.19.06.04;	author okan;	state Exp;
branches;
next	1.155;

1.155
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.154;

1.154
date	2014.01.02.21.30.20;	author okan;	state Exp;
branches;
next	1.153;

1.153
date	2013.12.17.16.10.43;	author okan;	state Exp;
branches;
next	1.152;

1.152
date	2013.12.16.19.02.17;	author okan;	state Exp;
branches;
next	1.151;

1.151
date	2013.12.13.14.40.52;	author okan;	state Exp;
branches;
next	1.150;

1.150
date	2013.11.27.18.34.34;	author okan;	state Exp;
branches;
next	1.149;

1.149
date	2013.11.27.16.24.17;	author okan;	state Exp;
branches;
next	1.148;

1.148
date	2013.10.20.01.55.32;	author okan;	state Exp;
branches;
next	1.147;

1.147
date	2013.10.19.19.39.34;	author okan;	state Exp;
branches;
next	1.146;

1.146
date	2013.10.07.13.40.26;	author okan;	state Exp;
branches;
next	1.145;

1.145
date	2013.07.16.14.22.25;	author okan;	state Exp;
branches;
next	1.144;

1.144
date	2013.07.16.14.04.44;	author okan;	state Exp;
branches;
next	1.143;

1.143
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.142;

1.142
date	2013.07.10.14.11.42;	author okan;	state Exp;
branches;
next	1.141;

1.141
date	2013.07.08.18.39.20;	author okan;	state Exp;
branches;
next	1.140;

1.140
date	2013.07.08.18.19.22;	author okan;	state Exp;
branches;
next	1.139;

1.139
date	2013.07.08.16.32.51;	author okan;	state Exp;
branches;
next	1.138;

1.138
date	2013.07.08.16.10.55;	author okan;	state Exp;
branches;
next	1.137;

1.137
date	2013.06.23.17.57.50;	author okan;	state Exp;
branches;
next	1.136;

1.136
date	2013.06.20.02.33.57;	author okan;	state Exp;
branches;
next	1.135;

1.135
date	2013.06.17.17.11.10;	author okan;	state Exp;
branches;
next	1.134;

1.134
date	2013.06.17.00.57.47;	author okan;	state Exp;
branches;
next	1.133;

1.133
date	2013.05.23.16.52.39;	author okan;	state Exp;
branches;
next	1.132;

1.132
date	2013.05.22.20.23.21;	author okan;	state Exp;
branches;
next	1.131;

1.131
date	2013.05.22.16.54.09;	author okan;	state Exp;
branches;
next	1.130;

1.130
date	2013.05.22.16.32.15;	author okan;	state Exp;
branches;
next	1.129;

1.129
date	2013.05.20.20.21.04;	author okan;	state Exp;
branches;
next	1.128;

1.128
date	2013.05.19.23.16.29;	author okan;	state Exp;
branches;
next	1.127;

1.127
date	2013.05.19.23.09.59;	author okan;	state Exp;
branches;
next	1.126;

1.126
date	2013.05.11.21.46.27;	author okan;	state Exp;
branches;
next	1.125;

1.125
date	2013.05.10.16.32.48;	author okan;	state Exp;
branches;
next	1.124;

1.124
date	2013.05.10.16.05.34;	author okan;	state Exp;
branches;
next	1.123;

1.123
date	2013.04.17.13.31.47;	author okan;	state Exp;
branches;
next	1.122;

1.122
date	2013.04.17.13.30.38;	author okan;	state Exp;
branches;
next	1.121;

1.121
date	2013.01.08.15.16.05;	author okan;	state Exp;
branches;
next	1.120;

1.120
date	2013.01.04.16.27.58;	author okan;	state Exp;
branches;
next	1.119;

1.119
date	2013.01.04.16.23.51;	author okan;	state Exp;
branches;
next	1.118;

1.118
date	2013.01.04.16.23.04;	author okan;	state Exp;
branches;
next	1.117;

1.117
date	2013.01.01.14.33.52;	author okan;	state Exp;
branches;
next	1.116;

1.116
date	2012.12.19.15.21.34;	author okan;	state Exp;
branches;
next	1.115;

1.115
date	2012.12.18.00.14.41;	author okan;	state Exp;
branches;
next	1.114;

1.114
date	2012.12.17.23.54.57;	author okan;	state Exp;
branches;
next	1.113;

1.113
date	2012.12.17.23.03.41;	author okan;	state Exp;
branches;
next	1.112;

1.112
date	2012.12.17.02.53.29;	author okan;	state Exp;
branches;
next	1.111;

1.111
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.110;

1.110
date	2012.11.28.14.14.44;	author okan;	state Exp;
branches;
next	1.109;

1.109
date	2012.11.14.21.31.53;	author okan;	state Exp;
branches;
next	1.108;

1.108
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.107;

1.107
date	2012.11.07.21.10.32;	author okan;	state Exp;
branches;
next	1.106;

1.106
date	2012.11.07.21.04.55;	author okan;	state Exp;
branches;
next	1.105;

1.105
date	2012.11.07.21.01.48;	author okan;	state Exp;
branches;
next	1.104;

1.104
date	2012.11.07.20.37.55;	author okan;	state Exp;
branches;
next	1.103;

1.103
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.102;

1.102
date	2012.10.31.22.06.24;	author okan;	state Exp;
branches;
next	1.101;

1.101
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.100;

1.100
date	2012.10.29.19.46.03;	author okan;	state Exp;
branches;
next	1.99;

1.99
date	2012.05.13.15.15.54;	author okan;	state Exp;
branches;
next	1.98;

1.98
date	2012.05.10.00.39.47;	author okan;	state Exp;
branches;
next	1.97;

1.97
date	2011.09.13.09.17.30;	author okan;	state Exp;
branches;
next	1.96;

1.96
date	2011.09.08.12.35.33;	author okan;	state Exp;
branches;
next	1.95;

1.95
date	2011.09.08.12.00.49;	author okan;	state Exp;
branches;
next	1.94;

1.94
date	2011.09.03.09.25.39;	author okan;	state Exp;
branches;
next	1.93;

1.93
date	2011.09.03.09.20.58;	author okan;	state Exp;
branches;
next	1.92;

1.92
date	2011.09.03.09.17.16;	author okan;	state Exp;
branches;
next	1.91;

1.91
date	2011.08.29.09.10.49;	author okan;	state Exp;
branches;
next	1.90;

1.90
date	2011.08.22.16.18.05;	author okan;	state Exp;
branches;
next	1.89;

1.89
date	2011.07.26.08.51.24;	author okan;	state Exp;
branches;
next	1.88;

1.88
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.87;

1.87
date	2011.07.14.11.39.53;	author okan;	state Exp;
branches;
next	1.86;

1.86
date	2011.06.25.13.37.05;	author okan;	state Exp;
branches;
next	1.85;

1.85
date	2011.06.24.06.09.26;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2011.06.24.06.06.24;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2011.06.24.05.54.30;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2011.06.24.05.45.57;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2011.06.24.05.40.09;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2011.06.24.05.30.42;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2011.05.07.17.15.37;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2011.03.22.10.57.31;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2010.01.27.03.04.50;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.11.17.51.42;	author oga;	state Exp;
branches;
next	1.72;

1.72
date	2009.12.08.16.52.17;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.07.19.42.59;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2009.08.25.12.05.11;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.25.01.44.39;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.25.01.42.05;	author oga;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.24.23.54.41;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.20.00.19.56;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2009.05.30.00.30.27;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2009.05.17.23.54.17;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2009.05.17.17.04.59;	author sthen;	state Exp;
branches;
next	1.59;

1.59
date	2009.05.14.16.24.04;	author oga;	state Exp;
branches;
next	1.58;

1.58
date	2009.05.04.19.13.33;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.07.21.07.00;	author martynas;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.23.20.47.45;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.23.19.00.59;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.23.18.58.40;	author oga;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.21.15.04.38;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.08.21.35.19;	author oga;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.22.20.51.54;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.11.15.18.29;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.11.14.24.34;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.25.22.44.42;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.25.22.40.27;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.25.22.38.36;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.25.22.37.29;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.17.23.40.33;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.16.19.09.48;	author mk;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.14.21.59.09;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.14.21.51.00;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.14.21.48.54;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.05.00.07.05;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.19.18.53.09;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.19.17.11.19;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.19.15.17.50;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.19.12.56.58;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.18.19.47.19;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.05.18.19.43.50;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.16.13.47.29;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.16.13.38.09;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.08.14.12.28;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.07.23.47.09;	author simon;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	1.22;

1.22
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.18.00.48.56;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.03.01.56.25;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.31.02.49.45;	author okan;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.28.16.35.52;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.28.16.02.37;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.27.17.17.08;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.19.22.18.16;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.13.23.26.04;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.13.23.08.49;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.07.22.00.26;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.07.21.58.03;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.27.13.28.22;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.26.19.34.26;	author niallo;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.05.19.03.20;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.28.21.11.39;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.27.09.23.12;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.27.18.08.14;	author bernd;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.230
log
@stray newlines
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: conf.c,v 1.229 2016/12/06 15:03:13 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

static const char	*conf_bind_getmask(const char *, unsigned int *);
static void		 conf_cmd_remove(struct conf *, const char *);
static void		 conf_unbind_key(struct conf *, struct bind_ctx *);
static void		 conf_unbind_mouse(struct conf *, struct bind_ctx *);

static int cursor_binds[] = {
	XC_left_ptr,		/* CF_NORMAL */
	XC_fleur,		/* CF_MOVE */
	XC_bottom_right_corner,	/* CF_RESIZE */
	XC_question_arrow,	/* CF_QUESTION */
};
static const char *color_binds[] = {
	"#CCCCCC",		/* CWM_COLOR_BORDER_ACTIVE */
	"#666666",		/* CWM_COLOR_BORDER_INACTIVE */
	"#FC8814",		/* CWM_COLOR_BORDER_URGENCY */
	"blue",			/* CWM_COLOR_BORDER_GROUP */
	"red",			/* CWM_COLOR_BORDER_UNGROUP */
	"black",		/* CWM_COLOR_MENU_FG */
	"white",		/* CWM_COLOR_MENU_BG */
	"black",		/* CWM_COLOR_MENU_FONT */
	"",			/* CWM_COLOR_MENU_FONT_SEL */
};
static const struct {
	const char	*tag;
	void		 (*handler)(void *, union arg *, enum xev);
	enum context	 context;
	union arg	 argument;
} name_to_func[] = {
	{ "window-menu-label", kbfunc_menu_client_label, CWM_CONTEXT_CC, {0} },
	{ "window-lower", kbfunc_client_lower, CWM_CONTEXT_CC, {0} },
	{ "window-raise", kbfunc_client_raise, CWM_CONTEXT_CC, {0} },
	{ "window-hide", kbfunc_client_hide, CWM_CONTEXT_CC, {0} },
	{ "window-delete", kbfunc_client_delete, CWM_CONTEXT_CC, {0} },
	{ "window-htile", kbfunc_client_htile, CWM_CONTEXT_CC, {0} },
	{ "window-vtile", kbfunc_client_vtile, CWM_CONTEXT_CC, {0} },
	{ "window-stick", kbfunc_client_toggle_sticky, CWM_CONTEXT_CC, {0} },
	{ "window-fullscreen", kbfunc_client_toggle_fullscreen, CWM_CONTEXT_CC, {0} },
	{ "window-maximize", kbfunc_client_toggle_maximize, CWM_CONTEXT_CC, {0} },
	{ "window-vmaximize", kbfunc_client_toggle_vmaximize, CWM_CONTEXT_CC, {0} },
	{ "window-hmaximize", kbfunc_client_toggle_hmaximize, CWM_CONTEXT_CC, {0} },
	{ "window-freeze", kbfunc_client_toggle_freeze, CWM_CONTEXT_CC, {0} },
	{ "window-cycle", kbfunc_client_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_FORWARD)} },
	{ "window-rcycle", kbfunc_client_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_REVERSE)} },
	{ "window-cycle-ingroup", kbfunc_client_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_FORWARD | CWM_CYCLE_INGROUP)} },
	{ "window-rcycle-ingroup", kbfunc_client_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_REVERSE | CWM_CYCLE_INGROUP)} },
	{ "window-group", kbfunc_client_toggle_group, CWM_CONTEXT_CC, {0} },
	{ "window-movetogroup-1", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 1} },
	{ "window-movetogroup-2", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 2} },
	{ "window-movetogroup-3", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 3} },
	{ "window-movetogroup-4", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 4} },
	{ "window-movetogroup-5", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 5} },
	{ "window-movetogroup-6", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 6} },
	{ "window-movetogroup-7", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 7} },
	{ "window-movetogroup-8", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 8} },
	{ "window-movetogroup-9", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 9} },

	{ "window-move", mousefunc_client_move, CWM_CONTEXT_CC, {0} },
	{ "window-move-up", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_UP)} },
	{ "window-move-down", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_DOWN)} },
	{ "window-move-right", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_RIGHT)} },
	{ "window-move-left", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_LEFT)} },
	{ "window-move-up-big", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_UP | CWM_BIGAMOUNT)} },
	{ "window-move-down-big", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_DOWN | CWM_BIGAMOUNT)} },
	{ "window-move-right-big", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_RIGHT | CWM_BIGAMOUNT)} },
	{ "window-move-left-big", kbfunc_client_move, CWM_CONTEXT_CC,
	    {.i = (CWM_LEFT | CWM_BIGAMOUNT)} },
	{ "window-resize", mousefunc_client_resize, CWM_CONTEXT_CC, {0} },
	{ "window-resize-up", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_UP)} },
	{ "window-resize-down", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_DOWN)} },
	{ "window-resize-right", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_RIGHT)} },
	{ "window-resize-left", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_LEFT)} },
	{ "window-resize-up-big", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_UP | CWM_BIGAMOUNT)} },
	{ "window-resize-down-big", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_DOWN | CWM_BIGAMOUNT)} },
	{ "window-resize-right-big", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_RIGHT | CWM_BIGAMOUNT)} },
	{ "window-resize-left-big", kbfunc_client_resize, CWM_CONTEXT_CC,
	    {.i = (CWM_LEFT | CWM_BIGAMOUNT)} },

	{ "group-cycle", kbfunc_group_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_FORWARD)} },
	{ "group-rcycle", kbfunc_group_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_REVERSE)} },
	{ "group-toggle-all", kbfunc_group_alltoggle, CWM_CONTEXT_SC, {0} },
	{ "group-toggle-1", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 1} },
	{ "group-toggle-2", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 2} },
	{ "group-toggle-3", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 3} },
	{ "group-toggle-4", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 4} },
	{ "group-toggle-5", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 5} },
	{ "group-toggle-6", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 6} },
	{ "group-toggle-7", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 7} },
	{ "group-toggle-8", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 8} },
	{ "group-toggle-9", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 9} },
	{ "group-only-1", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 1} },
	{ "group-only-2", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 2} },
	{ "group-only-3", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 3} },
	{ "group-only-4", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 4} },
	{ "group-only-5", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 5} },
	{ "group-only-6", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 6} },
	{ "group-only-7", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 7} },
	{ "group-only-8", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 8} },
	{ "group-only-9", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 9} },

	{ "pointer-move-up", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_UP)} },
	{ "pointer-move-down", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_DOWN)} },
	{ "pointer-move-left", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_LEFT)} },
	{ "pointer-move-right", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_RIGHT)} },
	{ "pointer-move-up-big", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_UP | CWM_BIGAMOUNT)} },
	{ "pointer-move-down-big", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_DOWN | CWM_BIGAMOUNT)} },
	{ "pointer-move-left-big", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_LEFT | CWM_BIGAMOUNT)} },
	{ "pointer-move-right-big", kbfunc_ptrmove, CWM_CONTEXT_SC,
	    {.i = (CWM_RIGHT | CWM_BIGAMOUNT)} },

	{ "menu-cmd", kbfunc_menu_cmd, CWM_CONTEXT_SC, {0} },
	{ "menu-group", kbfunc_menu_group, CWM_CONTEXT_SC, {0} },
	{ "menu-ssh", kbfunc_menu_ssh, CWM_CONTEXT_SC, {0} },
	{ "menu-window", kbfunc_menu_client, CWM_CONTEXT_SC,
	    {.i = CWM_MENU_WINDOW_ALL} },
	{ "menu-window-hidden", kbfunc_menu_client, CWM_CONTEXT_SC,
	    {.i = CWM_MENU_WINDOW_HIDDEN} },
	{ "menu-exec", kbfunc_menu_exec, CWM_CONTEXT_SC,
	    {.i = CWM_MENU_EXEC_EXEC} },
	{ "menu-exec-wm", kbfunc_menu_exec, CWM_CONTEXT_SC,
	    {.i = CWM_MENU_EXEC_WM} },

	{ "terminal", kbfunc_exec_term, CWM_CONTEXT_SC, {0} },
	{ "lock", kbfunc_exec_lock, CWM_CONTEXT_SC, {0} },
	{ "restart", kbfunc_cwm_status, CWM_CONTEXT_SC, {.i = CWM_EXEC_WM} },
	{ "quit", kbfunc_cwm_status, CWM_CONTEXT_SC, {.i = CWM_QUIT} },

};
static unsigned int ignore_mods[] = {
	0, LockMask, Mod2Mask, Mod2Mask | LockMask
};
static const struct {
	const char	ch;
	int		mask;
} bind_mods[] = {
	{ 'C',	ControlMask },
	{ 'M',	Mod1Mask },
	{ '4',	Mod4Mask },
	{ 'S',	ShiftMask },
};
static const struct {
	const char	*key;
	const char	*func;
} key_binds[] = {
	{ "CM-Return",	"terminal" },
	{ "CM-Delete",	"lock" },
	{ "M-question",	"menu-exec" },
	{ "CM-w",	"menu-exec-wm" },
	{ "M-period",	"menu-ssh" },
	{ "M-Return",	"window-hide" },
	{ "M-Down",	"window-lower" },
	{ "M-Up",	"window-raise" },
	{ "M-slash",	"menu-window" },
	{ "C-slash",	"menu-cmd" },
	{ "M-Tab",	"window-cycle" },
	{ "MS-Tab",	"window-rcycle" },
	{ "CM-n",	"window-menu-label" },
	{ "CM-x",	"window-delete" },
	{ "CM-a",	"group-toggle-all" },
	{ "CM-0",	"group-toggle-all" },
	{ "CM-1",	"group-toggle-1" },
	{ "CM-2",	"group-toggle-2" },
	{ "CM-3",	"group-toggle-3" },
	{ "CM-4",	"group-toggle-4" },
	{ "CM-5",	"group-toggle-5" },
	{ "CM-6",	"group-toggle-6" },
	{ "CM-7",	"group-toggle-7" },
	{ "CM-8",	"group-toggle-8" },
	{ "CM-9",	"group-toggle-9" },
	{ "M-Right",	"group-cycle" },
	{ "M-Left",	"group-rcycle" },
	{ "CM-g",	"window-group" },
	{ "CM-f",	"window-fullscreen" },
	{ "CM-m",	"window-maximize" },
	{ "CM-s",	"window-stick" },
	{ "CM-equal",	"window-vmaximize" },
	{ "CMS-equal",	"window-hmaximize" },
	{ "CMS-f",	"window-freeze" },
	{ "CMS-r",	"restart" },
	{ "CMS-q",	"quit" },
	{ "M-h",	"window-move-left" },
	{ "M-j",	"window-move-down" },
	{ "M-k",	"window-move-up" },
	{ "M-l",	"window-move-right" },
	{ "MS-h",	"window-move-left-big" },
	{ "MS-j",	"window-move-down-big" },
	{ "MS-k",	"window-move-up-big" },
	{ "MS-l",	"window-move-right-big" },
	{ "CM-h",	"window-resize-left" },
	{ "CM-j",	"window-resize-down" },
	{ "CM-k",	"window-resize-up" },
	{ "CM-l",	"window-resize-right" },
	{ "CMS-h",	"window-resize-left-big" },
	{ "CMS-j",	"window-resize-down-big" },
	{ "CMS-k",	"window-resize-up-big" },
	{ "CMS-l",	"window-resize-right-big" },
},
mouse_binds[] = {
	{ "1",		"menu-window" },
	{ "2",		"menu-group" },
	{ "3",		"menu-cmd" },
	{ "M-1",	"window-move" },
	{ "CM-1",	"window-group" },
	{ "M-2",	"window-resize" },
	{ "M-3",	"window-lower" },
	{ "CMS-3",	"window-hide" },
};

void
conf_init(struct conf *c)
{
	unsigned int	i;

	c->stickygroups = 0;
	c->bwidth = 1;
	c->mamount = 1;
	c->snapdist = 0;
	c->ngroups = 10;
	c->nameqlen = 5;

	TAILQ_INIT(&c->ignoreq);
	TAILQ_INIT(&c->cmdq);
	TAILQ_INIT(&c->keybindq);
	TAILQ_INIT(&c->autogroupq);
	TAILQ_INIT(&c->mousebindq);

	for (i = 0; i < nitems(key_binds); i++)
		conf_bind_key(c, key_binds[i].key, key_binds[i].func);

	for (i = 0; i < nitems(mouse_binds); i++)
		conf_bind_mouse(c, mouse_binds[i].key, mouse_binds[i].func);

	for (i = 0; i < nitems(color_binds); i++)
		c->color[i] = xstrdup(color_binds[i]);

	conf_cmd_add(c, "lock", "xlock");
	conf_cmd_add(c, "term", "xterm");

	(void)snprintf(c->known_hosts, sizeof(c->known_hosts), "%s/%s",
	    homedir, ".ssh/known_hosts");

	c->font = xstrdup("sans-serif:pixelsize=14:bold");
	c->wmname = xstrdup("CWM");
}

void
conf_clear(struct conf *c)
{
	struct autogroup	*ag;
	struct bind_ctx		*kb, *mb;
	struct winname		*wn;
	struct cmd_ctx		*cmd;
	int			 i;

	while ((cmd = TAILQ_FIRST(&c->cmdq)) != NULL) {
		TAILQ_REMOVE(&c->cmdq, cmd, entry);
		free(cmd->name);
		free(cmd);
	}
	while ((kb = TAILQ_FIRST(&c->keybindq)) != NULL) {
		TAILQ_REMOVE(&c->keybindq, kb, entry);
		free(kb);
	}
	while ((ag = TAILQ_FIRST(&c->autogroupq)) != NULL) {
		TAILQ_REMOVE(&c->autogroupq, ag, entry);
		free(ag->class);
		free(ag->name);
		free(ag);
	}
	while ((wn = TAILQ_FIRST(&c->ignoreq)) != NULL) {
		TAILQ_REMOVE(&c->ignoreq, wn, entry);
		free(wn->name);
		free(wn);
	}
	while ((mb = TAILQ_FIRST(&c->mousebindq)) != NULL) {
		TAILQ_REMOVE(&c->mousebindq, mb, entry);
		free(mb);
	}
	for (i = 0; i < CWM_COLOR_NITEMS; i++)
		free(c->color[i]);

	free(c->font);
	free(c->wmname);
}

int
conf_cmd_add(struct conf *c, const char *name, const char *path)
{
	struct cmd_ctx	*cmd;

	cmd = xmalloc(sizeof(*cmd));
	cmd->name = xstrdup(name);
	if (strlcpy(cmd->path, path, sizeof(cmd->path)) >= sizeof(cmd->path)) {
		free(cmd->name);
		free(cmd);
		return(0);
	}
	conf_cmd_remove(c, name);

	TAILQ_INSERT_TAIL(&c->cmdq, cmd, entry);
	return(1);
}

static void
conf_cmd_remove(struct conf *c, const char *name)
{
	struct cmd_ctx	*cmd = NULL, *cmdnxt;

	TAILQ_FOREACH_SAFE(cmd, &c->cmdq, entry, cmdnxt) {
		if (strcmp(cmd->name, name) == 0) {
			TAILQ_REMOVE(&c->cmdq, cmd, entry);
			free(cmd->name);
			free(cmd);
		}
	}
}

void
conf_autogroup(struct conf *c, int num, const char *name, const char *class)
{
	struct autogroup	*ag;
	char			*p;

	ag = xmalloc(sizeof(*ag));
	if ((p = strchr(class, ',')) == NULL) {
		if (name == NULL)
			ag->name = NULL;
		else
			ag->name = xstrdup(name);

		ag->class = xstrdup(class);
	} else {
		*(p++) = '\0';
		if (name == NULL)
			ag->name = xstrdup(class);
		else
			ag->name = xstrdup(name);

		ag->class = xstrdup(p);
	}
	ag->num = num;
	TAILQ_INSERT_TAIL(&c->autogroupq, ag, entry);
}

void
conf_ignore(struct conf *c, const char *name)
{
	struct winname	*wn;

	wn = xmalloc(sizeof(*wn));
	wn->name = xstrdup(name);
	TAILQ_INSERT_TAIL(&c->ignoreq, wn, entry);
}

void
conf_cursor(struct conf *c)
{
	unsigned int	 i;

	for (i = 0; i < nitems(cursor_binds); i++)
		c->cursor[i] = XCreateFontCursor(X_Dpy, cursor_binds[i]);
}

void
conf_client(struct client_ctx *cc)
{
	struct winname	*wn;
	int		 ignore = 0;

	TAILQ_FOREACH(wn, &Conf.ignoreq, entry) {
		if (strncasecmp(wn->name, cc->name, strlen(wn->name)) == 0) {
			ignore = 1;
			break;
		}
	}
	cc->bwidth = (ignore) ? 0 : Conf.bwidth;
	cc->flags |= (ignore) ? CLIENT_IGNORE : 0;
}

void
conf_screen(struct screen_ctx *sc)
{
	unsigned int	 i;
	XftColor	 xc;
	Colormap	 colormap = DefaultColormap(X_Dpy, sc->which);
	Visual		*visual = DefaultVisual(X_Dpy, sc->which);

	sc->gap = Conf.gap;
	sc->snapdist = Conf.snapdist;

	sc->xftfont = XftFontOpenXlfd(X_Dpy, sc->which, Conf.font);
	if (sc->xftfont == NULL) {
		sc->xftfont = XftFontOpenName(X_Dpy, sc->which, Conf.font);
		if (sc->xftfont == NULL)
			errx(1, "%s: XftFontOpenName: %s", __func__, Conf.font);
	}

	for (i = 0; i < nitems(color_binds); i++) {
		if (i == CWM_COLOR_MENU_FONT_SEL && *Conf.color[i] == '\0') {
			xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_BG],
			    sc->xftcolor[CWM_COLOR_MENU_FG], &xc);
			xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_FONT], xc, &xc);
			if (!XftColorAllocValue(X_Dpy, visual, colormap,
			    &xc.color, &sc->xftcolor[CWM_COLOR_MENU_FONT_SEL]))
				warnx("XftColorAllocValue: %s", Conf.color[i]);
			break;
		}
		if (XftColorAllocName(X_Dpy, visual, colormap,
		    Conf.color[i], &xc)) {
			sc->xftcolor[i] = xc;
			XftColorFree(X_Dpy, visual, colormap, &xc);
		} else {
			warnx("XftColorAllocName: %s", Conf.color[i]);
			XftColorAllocName(X_Dpy, visual, colormap,
			    color_binds[i], &sc->xftcolor[i]);
		}
	}

	sc->menu.win = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1,
	    Conf.bwidth,
	    sc->xftcolor[CWM_COLOR_MENU_FG].pixel,
	    sc->xftcolor[CWM_COLOR_MENU_BG].pixel);

	sc->menu.xftdraw = XftDrawCreate(X_Dpy, sc->menu.win, visual, colormap);
	if (sc->menu.xftdraw == NULL)
		errx(1, "%s: XftDrawCreate", __func__);

	conf_grab_kbd(sc->rootwin);
}

static const char *
conf_bind_getmask(const char *name, unsigned int *mask)
{
	char		*dash;
	const char	*ch;
	unsigned int 	 i;

	*mask = 0;
	if ((dash = strchr(name, '-')) == NULL)
		return(name);
	for (i = 0; i < nitems(bind_mods); i++) {
		if ((ch = strchr(name, bind_mods[i].ch)) != NULL && ch < dash)
			*mask |= bind_mods[i].mask;
	}
	/* Skip past modifiers. */
	return(dash + 1);
}

int
conf_bind_key(struct conf *c, const char *bind, const char *cmd)
{
	struct bind_ctx	*kb;
	const char	*key;
	unsigned int	 i;

	if ((strcmp(bind, "all") == 0) && (cmd == NULL)) {
		conf_unbind_key(c, NULL);
		goto out;
	}
	kb = xmalloc(sizeof(*kb));
	key = conf_bind_getmask(bind, &kb->modmask);
	kb->press.keysym = XStringToKeysym(key);
	if (kb->press.keysym == NoSymbol) {
		warnx("unknown symbol: %s", key);
		free(kb);
		return(0);
	}
	conf_unbind_key(c, kb);
	if (cmd == NULL) {
		free(kb);
		goto out;
	}
	for (i = 0; i < nitems(name_to_func); i++) {
		if (strcmp(name_to_func[i].tag, cmd) != 0)
			continue;
		kb->callback = name_to_func[i].handler;
		kb->context = name_to_func[i].context;
		kb->argument = name_to_func[i].argument;
		TAILQ_INSERT_TAIL(&c->keybindq, kb, entry);
		goto out;
	}
	kb->callback = kbfunc_exec_cmd;
	kb->context = CWM_CONTEXT_NONE;
	kb->argument.c = xstrdup(cmd);
	TAILQ_INSERT_TAIL(&c->keybindq, kb, entry);
out:
	return(1);
}

static void
conf_unbind_key(struct conf *c, struct bind_ctx *unbind)
{
	struct bind_ctx	*key = NULL, *keynxt;

	TAILQ_FOREACH_SAFE(key, &c->keybindq, entry, keynxt) {
		if ((unbind == NULL) ||
		    ((key->modmask == unbind->modmask) &&
		     (key->press.keysym == unbind->press.keysym))) {
			TAILQ_REMOVE(&c->keybindq, key, entry);
			if (key->context == CWM_CONTEXT_NONE)
				free(key->argument.c);
			free(key);
		}
	}
}

int
conf_bind_mouse(struct conf *c, const char *bind, const char *cmd)
{
	struct bind_ctx	*mb;
	const char	*button, *errstr;
	unsigned int	 i;

	if ((strcmp(bind, "all") == 0) && (cmd == NULL)) {
		conf_unbind_mouse(c, NULL);
		goto out;
	}
	mb = xmalloc(sizeof(*mb));
	button = conf_bind_getmask(bind, &mb->modmask);
	mb->press.button = strtonum(button, Button1, Button5, &errstr);
	if (errstr) {
		warnx("button number is %s: %s", errstr, button);
		free(mb);
		return(0);
	}
	conf_unbind_mouse(c, mb);
	if (cmd == NULL) {
		free(mb);
		goto out;
	}
	for (i = 0; i < nitems(name_to_func); i++) {
		if (strcmp(name_to_func[i].tag, cmd) != 0)
			continue;
		mb->callback = name_to_func[i].handler;
		mb->context = name_to_func[i].context;
		mb->argument = name_to_func[i].argument;
		TAILQ_INSERT_TAIL(&c->mousebindq, mb, entry);
		goto out;
	}
	mb->callback = kbfunc_exec_cmd;
	mb->context = CWM_CONTEXT_NONE;
	mb->argument.c = xstrdup(cmd);
	TAILQ_INSERT_TAIL(&c->mousebindq, mb, entry);
out:
	return(1);
}

static void
conf_unbind_mouse(struct conf *c, struct bind_ctx *unbind)
{
	struct bind_ctx		*mb = NULL, *mbnxt;

	TAILQ_FOREACH_SAFE(mb, &c->mousebindq, entry, mbnxt) {
		if ((unbind == NULL) || 
		    ((mb->modmask == unbind->modmask) &&
		     (mb->press.button == unbind->press.button))) {
			TAILQ_REMOVE(&c->mousebindq, mb, entry);
			if (mb->context == CWM_CONTEXT_NONE)
				free(mb->argument.c);
			free(mb);
		}
	}
}

void
conf_grab_kbd(Window win)
{
	struct bind_ctx	*kb;
	KeyCode		 kc;
	unsigned int	 i;

	XUngrabKey(X_Dpy, AnyKey, AnyModifier, win);

	TAILQ_FOREACH(kb, &Conf.keybindq, entry) {
		kc = XKeysymToKeycode(X_Dpy, kb->press.keysym);
		if ((XkbKeycodeToKeysym(X_Dpy, kc, 0, 0) != kb->press.keysym) &&
		    (XkbKeycodeToKeysym(X_Dpy, kc, 0, 1) == kb->press.keysym))
			kb->modmask |= ShiftMask;

		for (i = 0; i < nitems(ignore_mods); i++)
			XGrabKey(X_Dpy, kc, (kb->modmask | ignore_mods[i]), win,
			    True, GrabModeAsync, GrabModeAsync);
	}
}

void
conf_grab_mouse(Window win)
{
	struct bind_ctx	*mb;
	unsigned int	 i;

	XUngrabButton(X_Dpy, AnyButton, AnyModifier, win);

	TAILQ_FOREACH(mb, &Conf.mousebindq, entry) {
		if (mb->context != CWM_CONTEXT_CC)
			continue;
		for (i = 0; i < nitems(ignore_mods); i++) {
			XGrabButton(X_Dpy, mb->press.button,
			    (mb->modmask | ignore_mods[i]), win, False,
			    BUTTONMASK, GrabModeAsync, GrabModeSync,
			    None, None);
		}
	}
}

static char *cwmhints[] = {
	"WM_STATE",
	"WM_DELETE_WINDOW",
	"WM_TAKE_FOCUS",
	"WM_PROTOCOLS",
	"_MOTIF_WM_HINTS",
	"UTF8_STRING",
	"WM_CHANGE_STATE",
};
static char *ewmhints[] = {
	"_NET_SUPPORTED",
	"_NET_SUPPORTING_WM_CHECK",
	"_NET_ACTIVE_WINDOW",
	"_NET_CLIENT_LIST",
	"_NET_CLIENT_LIST_STACKING",
	"_NET_NUMBER_OF_DESKTOPS",
	"_NET_CURRENT_DESKTOP",
	"_NET_DESKTOP_VIEWPORT",
	"_NET_DESKTOP_GEOMETRY",
	"_NET_VIRTUAL_ROOTS",
	"_NET_SHOWING_DESKTOP",
	"_NET_DESKTOP_NAMES",
	"_NET_WORKAREA",
	"_NET_WM_NAME",
	"_NET_WM_DESKTOP",
	"_NET_CLOSE_WINDOW",
	"_NET_WM_STATE",
	"_NET_WM_STATE_STICKY",
	"_NET_WM_STATE_MAXIMIZED_VERT",
	"_NET_WM_STATE_MAXIMIZED_HORZ",
	"_NET_WM_STATE_HIDDEN",
	"_NET_WM_STATE_FULLSCREEN",
	"_NET_WM_STATE_DEMANDS_ATTENTION",
	"_CWM_WM_STATE_FREEZE",
};

void
conf_atoms(void)
{
	XInternAtoms(X_Dpy, cwmhints, nitems(cwmhints), False, cwmh);
	XInternAtoms(X_Dpy, ewmhints, nitems(ewmhints), False, ewmh);
}
@


1.229
log
@'window-search' is spelled 'menu-window'; the former snuck in during the
conversion('menu-window' already existed and was properlly documented); found
the hard way by sthen@@ while trying to convert.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.228 2016/12/02 17:02:17 okan Exp $
d377 1
@


1.228
log
@Fold unbinding functions into one for each, key and mouse; plugs a leak when
unbinding a mouse button bound to a command.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.227 2016/12/02 16:50:19 okan Exp $
a65 1
	{ "window-search", kbfunc_menu_client, CWM_CONTEXT_SC, {0} },
@


1.227
log
@use the correct type
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.226 2016/12/01 18:17:52 okan Exp $
a37 1
static void		 conf_unbind_key_all(struct conf *);
a38 1
static void		 conf_unbind_mouse_all(struct conf *);
d517 1
a517 1
		conf_unbind_key_all(c);
d556 3
a558 3
		if (key->modmask != unbind->modmask)
			continue;
		if (key->press.keysym == unbind->press.keysym) {
a566 13
static void
conf_unbind_key_all(struct conf *c)
{
	struct bind_ctx	*key = NULL, *keynxt;

	TAILQ_FOREACH_SAFE(key, &c->keybindq, entry, keynxt) {
		TAILQ_REMOVE(&c->keybindq, key, entry);
		if (key->context == CWM_CONTEXT_NONE)
			free(key->argument.c);
		free(key);
	}
}

d575 1
a575 1
		conf_unbind_mouse_all(c);
d614 3
a616 3
		if (mb->modmask != unbind->modmask)
			continue;
		if (mb->press.button == unbind->press.button) {
d618 2
a621 13
	}
}

static void
conf_unbind_mouse_all(struct conf *c)
{
	struct bind_ctx		*mb = NULL, *mbnxt;

	TAILQ_FOREACH_SAFE(mb, &c->mousebindq, entry, mbnxt) {
		TAILQ_REMOVE(&c->mousebindq, mb, entry);
		if (mb->context == CWM_CONTEXT_NONE)
			free(mb->argument.c);
		free(mb);
@


1.226
log
@Change 'menu-window' to display all windows; then add 'menu-window-hidden' for
the previous behaviour of 'menu-window'.  'menu-window' becomes the default
binding; use 'bind-mouse "1" menu-window-hidden' to restore old behaviour for
those who prefer.

OK sthen@@ (long long time ago on a different version)
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.225 2016/12/01 17:17:27 okan Exp $
d62 1
a62 1
	int		 context;
@


1.225
log
@Normalize bind function names, based on a few categories: window, group, menu
and pointer.

Replace 'bind' and 'mousebind' options with 'bind-key' and 'bind-mouse',
respectively, replace special 'unmap' keyword with 'unbind-key' and
'unbind-mouse', and additionally allow unbinding all with 'all' keyword.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.224 2016/11/15 00:22:02 okan Exp $
d177 4
a180 1
	{ "menu-window", kbfunc_menu_client, CWM_CONTEXT_SC, {0} },
@


1.224
log
@revert previous; upcoming changes will hopefully deal with these more
naturally.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.222 2016/11/14 21:25:59 okan Exp $
d38 1
d40 1
d65 15
a79 7
	{ "lower", kbfunc_client_lower, CWM_CONTEXT_CC, {0} },
	{ "raise", kbfunc_client_raise, CWM_CONTEXT_CC, {0} },
	{ "search", kbfunc_menu_client, CWM_CONTEXT_SC, {0} },
	{ "menusearch", kbfunc_menu_cmd, CWM_CONTEXT_SC, {0} },
	{ "groupsearch", kbfunc_menu_group, CWM_CONTEXT_SC, {0} },
	{ "hide", kbfunc_client_hide, CWM_CONTEXT_CC, {0} },
	{ "cycle", kbfunc_client_cycle, CWM_CONTEXT_SC,
d81 1
a81 1
	{ "rcycle", kbfunc_client_cycle, CWM_CONTEXT_SC,
d83 1
a83 35
	{ "label", kbfunc_menu_client_label, CWM_CONTEXT_CC, {0} },
	{ "delete", kbfunc_client_delete, CWM_CONTEXT_CC, {0} },
	{ "group1", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 1} },
	{ "group2", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 2} },
	{ "group3", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 3} },
	{ "group4", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 4} },
	{ "group5", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 5} },
	{ "group6", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 6} },
	{ "group7", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 7} },
	{ "group8", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 8} },
	{ "group9", kbfunc_group_toggle, CWM_CONTEXT_SC, {.i = 9} },
	{ "grouponly1", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 1} },
	{ "grouponly2", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 2} },
	{ "grouponly3", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 3} },
	{ "grouponly4", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 4} },
	{ "grouponly5", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 5} },
	{ "grouponly6", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 6} },
	{ "grouponly7", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 7} },
	{ "grouponly8", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 8} },
	{ "grouponly9", kbfunc_group_only, CWM_CONTEXT_SC, {.i = 9} },
	{ "movetogroup1", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 1} },
	{ "movetogroup2", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 2} },
	{ "movetogroup3", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 3} },
	{ "movetogroup4", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 4} },
	{ "movetogroup5", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 5} },
	{ "movetogroup6", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 6} },
	{ "movetogroup7", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 7} },
	{ "movetogroup8", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 8} },
	{ "movetogroup9", kbfunc_client_movetogroup, CWM_CONTEXT_CC, {.i = 9} },
	{ "nogroup", kbfunc_group_alltoggle, CWM_CONTEXT_SC, {0} },
	{ "cyclegroup", kbfunc_group_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_FORWARD)} },
	{ "rcyclegroup", kbfunc_group_cycle, CWM_CONTEXT_SC,
	    {.i = (CWM_CYCLE_REVERSE)} },
	{ "cycleingroup", kbfunc_client_cycle, CWM_CONTEXT_SC,
d85 1
a85 1
	{ "rcycleingroup", kbfunc_client_cycle, CWM_CONTEXT_SC,
d87 13
a99 17
	{ "grouptoggle", kbfunc_client_toggle_group, CWM_CONTEXT_CC, {0} },
	{ "stick", kbfunc_client_toggle_sticky, CWM_CONTEXT_CC, {0} },
	{ "fullscreen", kbfunc_client_toggle_fullscreen, CWM_CONTEXT_CC, {0} },
	{ "maximize", kbfunc_client_toggle_maximize, CWM_CONTEXT_CC, {0} },
	{ "vmaximize", kbfunc_client_toggle_vmaximize, CWM_CONTEXT_CC, {0} },
	{ "hmaximize", kbfunc_client_toggle_hmaximize, CWM_CONTEXT_CC, {0} },
	{ "freeze", kbfunc_client_toggle_freeze, CWM_CONTEXT_CC, {0} },
	{ "restart", kbfunc_cwm_status, CWM_CONTEXT_SC, {.i = CWM_EXEC_WM} },
	{ "quit", kbfunc_cwm_status, CWM_CONTEXT_SC, {.i = CWM_QUIT} },
	{ "exec", kbfunc_menu_exec, CWM_CONTEXT_SC,
	    {.i = CWM_MENU_EXEC_EXEC} },
	{ "exec_wm", kbfunc_menu_exec, CWM_CONTEXT_SC,
	    {.i = CWM_MENU_EXEC_WM} },
	{ "ssh", kbfunc_menu_ssh, CWM_CONTEXT_SC, {0} },
	{ "terminal", kbfunc_exec_term, CWM_CONTEXT_SC, {0} },
	{ "lock", kbfunc_exec_lock, CWM_CONTEXT_SC, {0} },
	{ "moveup", kbfunc_client_move, CWM_CONTEXT_CC,
d101 1
a101 1
	{ "movedown", kbfunc_client_move, CWM_CONTEXT_CC,
d103 1
a103 1
	{ "moveright", kbfunc_client_move, CWM_CONTEXT_CC,
d105 1
a105 1
	{ "moveleft", kbfunc_client_move, CWM_CONTEXT_CC,
d107 1
a107 1
	{ "bigmoveup", kbfunc_client_move, CWM_CONTEXT_CC,
d109 1
a109 1
	{ "bigmovedown", kbfunc_client_move, CWM_CONTEXT_CC,
d111 1
a111 1
	{ "bigmoveright", kbfunc_client_move, CWM_CONTEXT_CC,
d113 1
a113 1
	{ "bigmoveleft", kbfunc_client_move, CWM_CONTEXT_CC,
d115 2
a116 1
	{ "resizeup", kbfunc_client_resize, CWM_CONTEXT_CC,
d118 1
a118 1
	{ "resizedown", kbfunc_client_resize, CWM_CONTEXT_CC,
d120 1
a120 1
	{ "resizeright", kbfunc_client_resize, CWM_CONTEXT_CC,
d122 1
a122 1
	{ "resizeleft", kbfunc_client_resize, CWM_CONTEXT_CC,
d124 1
a124 1
	{ "bigresizeup", kbfunc_client_resize, CWM_CONTEXT_CC,
d126 1
a126 1
	{ "bigresizedown", kbfunc_client_resize, CWM_CONTEXT_CC,
d128 1
a128 1
	{ "bigresizeright", kbfunc_client_resize, CWM_CONTEXT_CC,
d130 1
a130 1
	{ "bigresizeleft", kbfunc_client_resize, CWM_CONTEXT_CC,
d132 26
a157 1
	{ "ptrmoveup", kbfunc_ptrmove, CWM_CONTEXT_SC,
d159 1
a159 1
	{ "ptrmovedown", kbfunc_ptrmove, CWM_CONTEXT_SC,
d161 1
a161 1
	{ "ptrmoveleft", kbfunc_ptrmove, CWM_CONTEXT_SC,
d163 1
a163 1
	{ "ptrmoveright", kbfunc_ptrmove, CWM_CONTEXT_SC,
d165 1
a165 1
	{ "bigptrmoveup", kbfunc_ptrmove, CWM_CONTEXT_SC,
d167 1
a167 1
	{ "bigptrmovedown", kbfunc_ptrmove, CWM_CONTEXT_SC,
d169 1
a169 1
	{ "bigptrmoveleft", kbfunc_ptrmove, CWM_CONTEXT_SC,
d171 1
a171 1
	{ "bigptrmoveright", kbfunc_ptrmove, CWM_CONTEXT_SC,
d173 15
a187 11
	{ "htile", kbfunc_client_htile, CWM_CONTEXT_CC, {0} },
	{ "vtile", kbfunc_client_vtile, CWM_CONTEXT_CC, {0} },
	{ "window_lower", kbfunc_client_lower, CWM_CONTEXT_CC, {0} },
	{ "window_raise", kbfunc_client_raise, CWM_CONTEXT_CC, {0} },
	{ "window_hide", kbfunc_client_hide, CWM_CONTEXT_CC, {0} },
	{ "window_move", mousefunc_client_move, CWM_CONTEXT_CC, {0} },
	{ "window_resize", mousefunc_client_resize, CWM_CONTEXT_CC, {0} },
	{ "window_grouptoggle", kbfunc_client_toggle_group, CWM_CONTEXT_CC, {0} },
	{ "menu_group", kbfunc_menu_group, CWM_CONTEXT_SC, {0} },
	{ "menu_unhide", kbfunc_menu_client, CWM_CONTEXT_SC, {0} },
	{ "menu_cmd", kbfunc_menu_cmd, CWM_CONTEXT_SC, {0} },
d207 32
a238 32
	{ "M-question",	"exec" },
	{ "CM-w",	"exec_wm" },
	{ "M-period",	"ssh" },
	{ "M-Return",	"hide" },
	{ "M-Down",	"lower" },
	{ "M-Up",	"raise" },
	{ "M-slash",	"search" },
	{ "C-slash",	"menusearch" },
	{ "M-Tab",	"cycle" },
	{ "MS-Tab",	"rcycle" },
	{ "CM-n",	"label" },
	{ "CM-x",	"delete" },
	{ "CM-a",	"nogroup" },
	{ "CM-0",	"nogroup" },
	{ "CM-1",	"group1" },
	{ "CM-2",	"group2" },
	{ "CM-3",	"group3" },
	{ "CM-4",	"group4" },
	{ "CM-5",	"group5" },
	{ "CM-6",	"group6" },
	{ "CM-7",	"group7" },
	{ "CM-8",	"group8" },
	{ "CM-9",	"group9" },
	{ "M-Right",	"cyclegroup" },
	{ "M-Left",	"rcyclegroup" },
	{ "CM-g",	"grouptoggle" },
	{ "CM-f",	"fullscreen" },
	{ "CM-m",	"maximize" },
	{ "CM-s",	"stick" },
	{ "CM-equal",	"vmaximize" },
	{ "CMS-equal",	"hmaximize" },
	{ "CMS-f",	"freeze" },
d241 16
a256 16
	{ "M-h",	"moveleft" },
	{ "M-j",	"movedown" },
	{ "M-k",	"moveup" },
	{ "M-l",	"moveright" },
	{ "MS-h",	"bigmoveleft" },
	{ "MS-j",	"bigmovedown" },
	{ "MS-k",	"bigmoveup" },
	{ "MS-l",	"bigmoveright" },
	{ "CM-h",	"resizeleft" },
	{ "CM-j",	"resizedown" },
	{ "CM-k",	"resizeup" },
	{ "CM-l",	"resizeright" },
	{ "CMS-h",	"bigresizeleft" },
	{ "CMS-j",	"bigresizedown" },
	{ "CMS-k",	"bigresizeup" },
	{ "CMS-l",	"bigresizeright" },
d259 8
a266 8
	{ "1",		"menu_unhide" },
	{ "2",		"menu_group" },
	{ "3",		"menu_cmd" },
	{ "M-1",	"window_move" },
	{ "CM-1",	"window_grouptoggle" },
	{ "M-2",	"window_resize" },
	{ "M-3",	"window_lower" },
	{ "CMS-3",	"window_hide" },
d515 4
a526 1
	/* Remove duplicates. */
d528 1
a528 2

	if (strcmp("unmap", cmd) == 0) {
d530 1
a530 1
		return(1);
d539 1
a539 1
		return(1);
d545 1
d566 13
d586 4
a597 1
	/* Remove duplicates. */
d599 1
a599 2

	if (strcmp("unmap", cmd) == 0) {
d601 1
a601 1
		return(1);
d610 1
a610 1
		return(1);
d612 6
a617 1
	return(0);
d632 13
@


1.223
log
@Add a wrapper based upon xevent handlers around client move/resize for key and
mouse bindings.
@
text
@d180 2
a181 2
	{ "window_move", kbfunc_client_move, CWM_CONTEXT_CC, {0} },
	{ "window_resize", kbfunc_client_resize, CWM_CONTEXT_CC, {0} },
@


1.222
log
@Define callbacks, then default bindings.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.221 2016/11/14 19:56:05 okan Exp $
d180 2
a181 2
	{ "window_move", mousefunc_client_move, CWM_CONTEXT_CC, {0} },
	{ "window_resize", mousefunc_client_resize, CWM_CONTEXT_CC, {0} },
@


1.221
log
@Reorganize for upcoming changes.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.220 2016/11/14 13:52:33 okan Exp $
d37 1
a37 1
static void		 conf_unbind_kbd(struct conf *, struct bind_ctx *);
a57 67
	const char	*key;
	const char	*func;
} kbd_binds[] = {
	{ "CM-Return",	"terminal" },
	{ "CM-Delete",	"lock" },
	{ "M-question",	"exec" },
	{ "CM-w",	"exec_wm" },
	{ "M-period",	"ssh" },
	{ "M-Return",	"hide" },
	{ "M-Down",	"lower" },
	{ "M-Up",	"raise" },
	{ "M-slash",	"search" },
	{ "C-slash",	"menusearch" },
	{ "M-Tab",	"cycle" },
	{ "MS-Tab",	"rcycle" },
	{ "CM-n",	"label" },
	{ "CM-x",	"delete" },
	{ "CM-a",	"nogroup" },
	{ "CM-0",	"nogroup" },
	{ "CM-1",	"group1" },
	{ "CM-2",	"group2" },
	{ "CM-3",	"group3" },
	{ "CM-4",	"group4" },
	{ "CM-5",	"group5" },
	{ "CM-6",	"group6" },
	{ "CM-7",	"group7" },
	{ "CM-8",	"group8" },
	{ "CM-9",	"group9" },
	{ "M-Right",	"cyclegroup" },
	{ "M-Left",	"rcyclegroup" },
	{ "CM-g",	"grouptoggle" },
	{ "CM-f",	"fullscreen" },
	{ "CM-m",	"maximize" },
	{ "CM-s",	"stick" },
	{ "CM-equal",	"vmaximize" },
	{ "CMS-equal",	"hmaximize" },
	{ "CMS-f",	"freeze" },
	{ "CMS-r",	"restart" },
	{ "CMS-q",	"quit" },
	{ "M-h",	"moveleft" },
	{ "M-j",	"movedown" },
	{ "M-k",	"moveup" },
	{ "M-l",	"moveright" },
	{ "MS-h",	"bigmoveleft" },
	{ "MS-j",	"bigmovedown" },
	{ "MS-k",	"bigmoveup" },
	{ "MS-l",	"bigmoveright" },
	{ "CM-h",	"resizeleft" },
	{ "CM-j",	"resizedown" },
	{ "CM-k",	"resizeup" },
	{ "CM-l",	"resizeright" },
	{ "CMS-h",	"bigresizeleft" },
	{ "CMS-j",	"bigresizedown" },
	{ "CMS-k",	"bigresizeup" },
	{ "CMS-l",	"bigresizeright" },
},
mouse_binds[] = {
	{ "1",		"menu_unhide" },
	{ "2",		"menu_group" },
	{ "3",		"menu_cmd" },
	{ "M-1",	"window_move" },
	{ "CM-1",	"window_grouptoggle" },
	{ "M-2",	"window_resize" },
	{ "M-3",	"window_lower" },
	{ "CMS-3",	"window_hide" },
};
static const struct {
d187 3
d199 67
a265 1
static unsigned int ign_mods[] = { 0, LockMask, Mod2Mask, Mod2Mask | LockMask };
d285 2
a286 2
	for (i = 0; i < nitems(kbd_binds); i++)
		conf_bind_kbd(c, kbd_binds[i].key, kbd_binds[i].func);
d507 1
a507 1
conf_bind_kbd(struct conf *c, const char *bind, const char *cmd)
d522 1
a522 1
	conf_unbind_kbd(c, kb);
d545 1
a545 1
conf_unbind_kbd(struct conf *c, struct bind_ctx *unbind)
d625 2
a626 2
		for (i = 0; i < nitems(ign_mods); i++)
			XGrabKey(X_Dpy, kc, (kb->modmask | ign_mods[i]), win,
d642 1
a642 1
		for (i = 0; i < nitems(ign_mods); i++) {
d644 1
a644 1
			    (mb->modmask | ign_mods[i]), win, False,
@


1.220
log
@Remove the (8) default bindings for pointer move since they conflict with
default bindings for emacs, which wins; the feature remains and can be bound to
whatever users wish with cwmrc(5).

from mpi@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.219 2016/10/24 20:44:08 okan Exp $
d40 6
a45 74
int
conf_cmd_add(struct conf *c, const char *name, const char *path)
{
	struct cmd_ctx	*cmd;

	cmd = xmalloc(sizeof(*cmd));

	cmd->name = xstrdup(name);
	if (strlcpy(cmd->path, path, sizeof(cmd->path)) >= sizeof(cmd->path)) {
		free(cmd->name);
		free(cmd);
		return(0);
	}

	conf_cmd_remove(c, name);

	TAILQ_INSERT_TAIL(&c->cmdq, cmd, entry);

	return(1);
}

static void
conf_cmd_remove(struct conf *c, const char *name)
{
	struct cmd_ctx	*cmd = NULL, *cmdnxt;

	TAILQ_FOREACH_SAFE(cmd, &c->cmdq, entry, cmdnxt) {
		if (strcmp(cmd->name, name) == 0) {
			TAILQ_REMOVE(&c->cmdq, cmd, entry);
			free(cmd->name);
			free(cmd);
		}
	}
}
void
conf_autogroup(struct conf *c, int num, const char *name, const char *class)
{
	struct autogroup	*ag;
	char			*p;

	ag = xmalloc(sizeof(*ag));

	if ((p = strchr(class, ',')) == NULL) {
		if (name == NULL)
			ag->name = NULL;
		else
			ag->name = xstrdup(name);

		ag->class = xstrdup(class);
	} else {
		*(p++) = '\0';

		if (name == NULL)
			ag->name = xstrdup(class);
		else
			ag->name = xstrdup(name);

		ag->class = xstrdup(p);
	}
	ag->num = num;

	TAILQ_INSERT_TAIL(&c->autogroupq, ag, entry);
}

void
conf_ignore(struct conf *c, const char *name)
{
	struct winname	*wn;

	wn = xmalloc(sizeof(*wn));
	wn->name = xstrdup(name);
	TAILQ_INSERT_TAIL(&c->ignoreq, wn, entry);
}

d47 9
a55 9
	"#CCCCCC",	/* CWM_COLOR_BORDER_ACTIVE */
	"#666666",	/* CWM_COLOR_BORDER_INACTIVE */
	"#FC8814",	/* CWM_COLOR_BORDER_URGENCY */
	"blue",		/* CWM_COLOR_BORDER_GROUP */
	"red",		/* CWM_COLOR_BORDER_UNGROUP */
	"black",	/* CWM_COLOR_MENU_FG */
	"white",	/* CWM_COLOR_MENU_BG */
	"black",	/* CWM_COLOR_MENU_FONT */
	"",		/* CWM_COLOR_MENU_FONT_SEL */
a56 52

void
conf_screen(struct screen_ctx *sc)
{
	unsigned int	 i;
	XftColor	 xc;
	Colormap	 colormap = DefaultColormap(X_Dpy, sc->which);
	Visual		*visual = DefaultVisual(X_Dpy, sc->which);

	sc->gap = Conf.gap;
	sc->snapdist = Conf.snapdist;

	sc->xftfont = XftFontOpenXlfd(X_Dpy, sc->which, Conf.font);
	if (sc->xftfont == NULL) {
		sc->xftfont = XftFontOpenName(X_Dpy, sc->which, Conf.font);
		if (sc->xftfont == NULL)
			errx(1, "%s: XftFontOpenName: %s", __func__, Conf.font);
	}

	for (i = 0; i < nitems(color_binds); i++) {
		if (i == CWM_COLOR_MENU_FONT_SEL && *Conf.color[i] == '\0') {
			xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_BG],
			    sc->xftcolor[CWM_COLOR_MENU_FG], &xc);
			xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_FONT], xc, &xc);
			if (!XftColorAllocValue(X_Dpy, visual, colormap,
			    &xc.color, &sc->xftcolor[CWM_COLOR_MENU_FONT_SEL]))
				warnx("XftColorAllocValue: %s", Conf.color[i]);
			break;
		}
		if (XftColorAllocName(X_Dpy, visual, colormap,
		    Conf.color[i], &xc)) {
			sc->xftcolor[i] = xc;
			XftColorFree(X_Dpy, visual, colormap, &xc);
		} else {
			warnx("XftColorAllocName: %s", Conf.color[i]);
			XftColorAllocName(X_Dpy, visual, colormap,
			    color_binds[i], &sc->xftcolor[i]);
		}
	}

	sc->menu.win = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1,
	    Conf.bwidth,
	    sc->xftcolor[CWM_COLOR_MENU_FG].pixel,
	    sc->xftcolor[CWM_COLOR_MENU_BG].pixel);

	sc->menu.xftdraw = XftDrawCreate(X_Dpy, sc->menu.win, visual, colormap);
	if (sc->menu.xftdraw == NULL)
		errx(1, "%s: XftDrawCreate", __func__);

	conf_grab_kbd(sc->rootwin);
}

a123 100

void
conf_init(struct conf *c)
{
	unsigned int	i;

	c->stickygroups = 0;
	c->bwidth = 1;
	c->mamount = 1;
	c->snapdist = 0;
	c->ngroups = 10;
	c->nameqlen = 5;

	TAILQ_INIT(&c->ignoreq);
	TAILQ_INIT(&c->cmdq);
	TAILQ_INIT(&c->keybindq);
	TAILQ_INIT(&c->autogroupq);
	TAILQ_INIT(&c->mousebindq);

	for (i = 0; i < nitems(kbd_binds); i++)
		conf_bind_kbd(c, kbd_binds[i].key, kbd_binds[i].func);

	for (i = 0; i < nitems(mouse_binds); i++)
		conf_bind_mouse(c, mouse_binds[i].key, mouse_binds[i].func);

	for (i = 0; i < nitems(color_binds); i++)
		c->color[i] = xstrdup(color_binds[i]);

	conf_cmd_add(c, "lock", "xlock");
	conf_cmd_add(c, "term", "xterm");

	(void)snprintf(c->known_hosts, sizeof(c->known_hosts), "%s/%s",
	    homedir, ".ssh/known_hosts");

	c->font = xstrdup("sans-serif:pixelsize=14:bold");
	c->wmname = xstrdup("CWM");
}

void
conf_clear(struct conf *c)
{
	struct autogroup	*ag;
	struct bind_ctx		*kb, *mb;
	struct winname		*wn;
	struct cmd_ctx		*cmd;
	int			 i;

	while ((cmd = TAILQ_FIRST(&c->cmdq)) != NULL) {
		TAILQ_REMOVE(&c->cmdq, cmd, entry);
		free(cmd->name);
		free(cmd);
	}

	while ((kb = TAILQ_FIRST(&c->keybindq)) != NULL) {
		TAILQ_REMOVE(&c->keybindq, kb, entry);
		free(kb);
	}

	while ((ag = TAILQ_FIRST(&c->autogroupq)) != NULL) {
		TAILQ_REMOVE(&c->autogroupq, ag, entry);
		free(ag->class);
		free(ag->name);
		free(ag);
	}

	while ((wn = TAILQ_FIRST(&c->ignoreq)) != NULL) {
		TAILQ_REMOVE(&c->ignoreq, wn, entry);
		free(wn->name);
		free(wn);
	}

	while ((mb = TAILQ_FIRST(&c->mousebindq)) != NULL) {
		TAILQ_REMOVE(&c->mousebindq, mb, entry);
		free(mb);
	}

	for (i = 0; i < CWM_COLOR_NITEMS; i++)
		free(c->color[i]);

	free(c->font);
	free(c->wmname);
}

void
conf_client(struct client_ctx *cc)
{
	struct winname	*wn;
	int		 ignore = 0;

	TAILQ_FOREACH(wn, &Conf.ignoreq, entry) {
		if (strncasecmp(wn->name, cc->name, strlen(wn->name)) == 0) {
			ignore = 1;
			break;
		}
	}

	cc->bwidth = (ignore) ? 0 : Conf.bwidth;
	cc->flags |= (ignore) ? CLIENT_IGNORE : 0;
}

a253 1

d263 1
d265 2
a266 2
static const char *
conf_bind_getmask(const char *name, unsigned int *mask)
d268 1
a268 3
	char		*dash;
	const char	*ch;
	unsigned int 	 i;
d270 6
a275 7
	*mask = 0;
	if ((dash = strchr(name, '-')) == NULL)
		return(name);
	for (i = 0; i < nitems(bind_mods); i++) {
		if ((ch = strchr(name, bind_mods[i].ch)) != NULL && ch < dash)
			*mask |= bind_mods[i].mask;
	}
d277 223
a512 1

d519 1
a519 2

	/* We now have the correct binding, remove duplicates. */
a525 1

a528 1

a534 1

a549 1

a567 1

d574 1
a574 2

	/* We now have the correct binding, remove duplicates. */
a580 1

a583 1

a589 1

a600 1

a607 7
static int cursor_binds[] = {
	XC_left_ptr,		/* CF_NORMAL */
	XC_fleur,		/* CF_MOVE */
	XC_bottom_right_corner,	/* CF_RESIZE */
	XC_question_arrow,	/* CF_QUESTION */
};

d609 1
a609 1
conf_cursor(struct conf *c)
d611 2
d615 12
a626 2
	for (i = 0; i < nitems(cursor_binds); i++)
		c->cursor[i] = XCreateFontCursor(X_Dpy, cursor_binds[i]);
a628 2
static unsigned int ign_mods[] = { 0, LockMask, Mod2Mask, Mod2Mask | LockMask };

d633 1
a633 1
	unsigned int	i;
a645 22
	}

}

void
conf_grab_kbd(Window win)
{
	struct bind_ctx	*kb;
	KeyCode		 kc;
	unsigned int	 i;

	XUngrabKey(X_Dpy, AnyKey, AnyModifier, win);

	TAILQ_FOREACH(kb, &Conf.keybindq, entry) {
		kc = XKeysymToKeycode(X_Dpy, kb->press.keysym);
		if ((XkbKeycodeToKeysym(X_Dpy, kc, 0, 0) != kb->press.keysym) &&
		    (XkbKeycodeToKeysym(X_Dpy, kc, 0, 1) == kb->press.keysym))
			kb->modmask |= ShiftMask;

		for (i = 0; i < nitems(ign_mods); i++)
			XGrabKey(X_Dpy, kc, (kb->modmask | ign_mods[i]), win,
			    True, GrabModeAsync, GrabModeAsync);
@


1.219
log
@Make it clear these are flags.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.218 2016/10/24 17:39:38 okan Exp $
a232 8
	{ "C-Left",	"ptrmoveleft" },
	{ "C-Down",	"ptrmovedown" },
	{ "C-Up",	"ptrmoveup" },
	{ "C-Right",	"ptrmoveright" },
	{ "CS-Left",	"bigptrmoveleft" },
	{ "CS-Down",	"bigptrmovedown" },
	{ "CS-Up",	"bigptrmoveup" },
	{ "CS-Right",	"bigptrmoveright" },
@


1.218
log
@Sprinkle __func__ in appropriate error messages.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.217 2016/10/18 17:03:30 okan Exp $
d365 1
a365 1
	    {.i = CWM_CYCLE_FORWARD} },
d367 1
a367 1
	    {.i = CWM_CYCLE_REVERSE} },
d399 1
a399 1
	    {.i = CWM_CYCLE_FORWARD} },
d401 1
a401 1
	    {.i = CWM_CYCLE_REVERSE} },
@


1.217
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.216 2016/10/06 14:53:52 okan Exp $
d141 1
a141 1
			errx(1, "XftFontOpenName: %s", Conf.font);
d172 1
a172 1
		errx(1, "XftDrawCreate");
@


1.216
log
@Rename 2 kbfunc to match closer to what they do
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.215 2016/10/06 14:41:19 okan Exp $
d37 2
a38 2
static void		 conf_unbind_kbd(struct conf *, struct binding *);
static void		 conf_unbind_mouse(struct conf *, struct binding *);
d43 1
a43 1
	struct cmd	*cmd;
d64 1
a64 1
	struct cmd	*cmd = NULL, *cmdnxt;
d77 1
a77 1
	struct autogroupwin	*aw;
d80 1
a80 1
	aw = xmalloc(sizeof(*aw));
d84 1
a84 1
			aw->name = NULL;
d86 1
a86 1
			aw->name = xstrdup(name);
d88 1
a88 1
		aw->class = xstrdup(class);
d93 1
a93 1
			aw->name = xstrdup(class);
d95 1
a95 1
			aw->name = xstrdup(name);
d97 1
a97 1
		aw->class = xstrdup(p);
d99 1
a99 1
	aw->num = num;
d101 1
a101 1
	TAILQ_INSERT_TAIL(&c->autogroupq, aw, entry);
d267 1
a267 1
	TAILQ_INIT(&c->keybindingq);
d269 1
a269 1
	TAILQ_INIT(&c->mousebindingq);
d293 2
a294 2
	struct autogroupwin	*aw;
	struct binding		*kb, *mb;
d296 1
a296 1
	struct cmd		*cmd;
d305 2
a306 2
	while ((kb = TAILQ_FIRST(&c->keybindingq)) != NULL) {
		TAILQ_REMOVE(&c->keybindingq, kb, entry);
d310 5
a314 5
	while ((aw = TAILQ_FIRST(&c->autogroupq)) != NULL) {
		TAILQ_REMOVE(&c->autogroupq, aw, entry);
		free(aw->class);
		free(aw->name);
		free(aw);
d323 2
a324 2
	while ((mb = TAILQ_FIRST(&c->mousebindingq)) != NULL) {
		TAILQ_REMOVE(&c->mousebindingq, mb, entry);
d354 1
a354 1
	void		 (*handler)(struct client_ctx *, union arg *, int);
d358 60
a417 72
	{ "lower", kbfunc_client_lower, CWM_CONTEXT_CLIENT, {0} },
	{ "raise", kbfunc_client_raise, CWM_CONTEXT_CLIENT, {0} },
	{ "search", kbfunc_menu_client, CWM_CONTEXT_SCREEN, {0} },
	{ "menusearch", kbfunc_menu_cmd, CWM_CONTEXT_SCREEN, {0} },
	{ "groupsearch", kbfunc_menu_group, CWM_CONTEXT_SCREEN, {0} },
	{ "hide", kbfunc_client_hide, CWM_CONTEXT_CLIENT, {0} },
	{ "cycle", kbfunc_client_cycle, CWM_CONTEXT_SCREEN,
	    {.i = CWM_CLIENT_CYCLE} },
	{ "rcycle", kbfunc_client_cycle, CWM_CONTEXT_SCREEN,
	    {.i = CWM_CLIENT_RCYCLE} },
	{ "label", kbfunc_menu_client_label, CWM_CONTEXT_CLIENT, {0} },
	{ "delete", kbfunc_client_delete, CWM_CONTEXT_CLIENT, {0} },
	{ "group1", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 1} },
	{ "group2", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 2} },
	{ "group3", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 3} },
	{ "group4", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 4} },
	{ "group5", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 5} },
	{ "group6", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 6} },
	{ "group7", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 7} },
	{ "group8", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 8} },
	{ "group9", kbfunc_group_toggle, CWM_CONTEXT_SCREEN, {.i = 9} },
	{ "grouponly1", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 1} },
	{ "grouponly2", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 2} },
	{ "grouponly3", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 3} },
	{ "grouponly4", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 4} },
	{ "grouponly5", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 5} },
	{ "grouponly6", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 6} },
	{ "grouponly7", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 7} },
	{ "grouponly8", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 8} },
	{ "grouponly9", kbfunc_group_only, CWM_CONTEXT_SCREEN, {.i = 9} },
	{ "movetogroup1", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 1} },
	{ "movetogroup2", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 2} },
	{ "movetogroup3", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 3} },
	{ "movetogroup4", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 4} },
	{ "movetogroup5", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 5} },
	{ "movetogroup6", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 6} },
	{ "movetogroup7", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 7} },
	{ "movetogroup8", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 8} },
	{ "movetogroup9", kbfunc_client_movetogroup, CWM_CONTEXT_CLIENT,
	    {.i = 9} },
	{ "nogroup", kbfunc_group_alltoggle, CWM_CONTEXT_SCREEN, {0} },
	{ "cyclegroup", kbfunc_group_cycle, CWM_CONTEXT_SCREEN,
	    {.i = CWM_CLIENT_CYCLE} },
	{ "rcyclegroup", kbfunc_group_cycle, CWM_CONTEXT_SCREEN,
	    {.i = CWM_CLIENT_RCYCLE} },
	{ "cycleingroup", kbfunc_client_cycle, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_CLIENT_CYCLE | CWM_CLIENT_CYCLE_INGRP)} },
	{ "rcycleingroup", kbfunc_client_cycle, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_CLIENT_RCYCLE | CWM_CLIENT_CYCLE_INGRP)} },
	{ "grouptoggle", kbfunc_client_toggle_group, CWM_CONTEXT_CLIENT, {0} },
	{ "stick", kbfunc_client_toggle_sticky, CWM_CONTEXT_CLIENT, {0} },
	{ "fullscreen", kbfunc_client_toggle_fullscreen, CWM_CONTEXT_CLIENT,
	    {0} },
	{ "maximize", kbfunc_client_toggle_maximize, CWM_CONTEXT_CLIENT, {0} },
	{ "vmaximize", kbfunc_client_toggle_vmaximize, CWM_CONTEXT_CLIENT,
	    {0} },
	{ "hmaximize", kbfunc_client_toggle_hmaximize, CWM_CONTEXT_CLIENT,
	    {0} },
	{ "freeze", kbfunc_client_toggle_freeze, CWM_CONTEXT_CLIENT, {0} },
	{ "restart", kbfunc_cwm_status, CWM_CONTEXT_SCREEN,
	    {.i = CWM_EXEC_WM} },
	{ "quit", kbfunc_cwm_status, CWM_CONTEXT_SCREEN, {.i = CWM_QUIT} },
	{ "exec", kbfunc_menu_exec, CWM_CONTEXT_SCREEN, {.i = CWM_MENU_EXEC} },
	{ "exec_wm", kbfunc_menu_exec, CWM_CONTEXT_SCREEN,
d419 4
a422 4
	{ "ssh", kbfunc_menu_ssh, CWM_CONTEXT_SCREEN, {0} },
	{ "terminal", kbfunc_exec_term, CWM_CONTEXT_SCREEN, {0} },
	{ "lock", kbfunc_exec_lock, CWM_CONTEXT_SCREEN, {0} },
	{ "moveup", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d424 1
a424 1
	{ "movedown", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d426 1
a426 1
	{ "moveright", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d428 1
a428 1
	{ "moveleft", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d430 1
a430 1
	{ "bigmoveup", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d432 1
a432 1
	{ "bigmovedown", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d434 1
a434 1
	{ "bigmoveright", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d436 1
a436 1
	{ "bigmoveleft", kbfunc_client_move, CWM_CONTEXT_CLIENT,
d438 1
a438 1
	{ "resizeup", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d440 1
a440 1
	{ "resizedown", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d442 1
a442 1
	{ "resizeright", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d444 1
a444 1
	{ "resizeleft", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d446 1
a446 1
	{ "bigresizeup", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d448 1
a448 1
	{ "bigresizedown", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d450 1
a450 1
	{ "bigresizeright", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d452 1
a452 1
	{ "bigresizeleft", kbfunc_client_resize, CWM_CONTEXT_CLIENT,
d454 1
a454 1
	{ "ptrmoveup", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d456 1
a456 1
	{ "ptrmovedown", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d458 1
a458 1
	{ "ptrmoveleft", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d460 1
a460 1
	{ "ptrmoveright", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d462 1
a462 1
	{ "bigptrmoveup", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d464 1
a464 1
	{ "bigptrmovedown", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d466 1
a466 1
	{ "bigptrmoveleft", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d468 1
a468 1
	{ "bigptrmoveright", kbfunc_ptrmove, CWM_CONTEXT_SCREEN,
d470 11
a480 13
	{ "htile", kbfunc_client_tile, CWM_CONTEXT_CLIENT,
	    {.i = CWM_CLIENT_TILE_HORIZ} },
	{ "vtile", kbfunc_client_tile, CWM_CONTEXT_CLIENT,
	    {.i = CWM_CLIENT_TILE_VERT} },
	{ "window_lower", kbfunc_client_lower, CWM_CONTEXT_CLIENT, {0} },
	{ "window_raise", kbfunc_client_raise, CWM_CONTEXT_CLIENT, {0} },
	{ "window_hide", kbfunc_client_hide, CWM_CONTEXT_CLIENT, {0} },
	{ "window_move", mousefunc_client_move, CWM_CONTEXT_CLIENT, {0} },
	{ "window_resize", mousefunc_client_resize, CWM_CONTEXT_CLIENT, {0} },
	{ "window_grouptoggle", kbfunc_client_toggle_group, CWM_CONTEXT_CLIENT, {0} },
	{ "menu_group", kbfunc_menu_group, CWM_CONTEXT_SCREEN, {0} },
	{ "menu_unhide", kbfunc_menu_client, CWM_CONTEXT_SCREEN, {0} },
	{ "menu_cmd", kbfunc_menu_cmd, CWM_CONTEXT_SCREEN, {0} },
d515 1
a515 1
	struct binding	*kb;
d544 1
a544 1
		TAILQ_INSERT_TAIL(&c->keybindingq, kb, entry);
d548 1
a548 1
	kb->callback = kbfunc_exec;
d551 1
a551 1
	TAILQ_INSERT_TAIL(&c->keybindingq, kb, entry);
d556 1
a556 1
conf_unbind_kbd(struct conf *c, struct binding *unbind)
d558 1
a558 1
	struct binding	*key = NULL, *keynxt;
d560 1
a560 1
	TAILQ_FOREACH_SAFE(key, &c->keybindingq, entry, keynxt) {
d565 1
a565 1
			TAILQ_REMOVE(&c->keybindingq, key, entry);
d576 1
a576 1
	struct binding	*mb;
d605 1
a605 1
		TAILQ_INSERT_TAIL(&c->mousebindingq, mb, entry);
d613 1
a613 1
conf_unbind_mouse(struct conf *c, struct binding *unbind)
d615 1
a615 1
	struct binding		*mb = NULL, *mbnxt;
d617 1
a617 1
	TAILQ_FOREACH_SAFE(mb, &c->mousebindingq, entry, mbnxt) {
d622 1
a622 1
			TAILQ_REMOVE(&c->mousebindingq, mb, entry);
d649 1
a649 1
	struct binding	*mb;
d654 2
a655 2
	TAILQ_FOREACH(mb, &Conf.mousebindingq, entry) {
		if (mb->context != CWM_CONTEXT_CLIENT)
d670 1
a670 1
	struct binding	*kb;
d676 1
a676 1
	TAILQ_FOREACH(kb, &Conf.keybindingq, entry) {
@


1.215
log
@Add an argument to the callbacks to pass the xevent context, button or
key press. This allows to remove a few hacks to duplicate functions only
for behaviour changes; now differing behaviours are pushed down to the
callback. Also will allow for previously unavailable actions to be bind-able
down the road.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.214 2016/10/05 13:35:17 okan Exp $
d368 1
a368 1
	{ "label", kbfunc_client_label, CWM_CONTEXT_CLIENT, {0} },
d415 1
a415 1
	{ "grouptoggle", kbfunc_client_grouptoggle, CWM_CONTEXT_CLIENT, {0}},
d491 1
a491 1
	{ "window_grouptoggle", kbfunc_client_grouptoggle, CWM_CONTEXT_CLIENT, {0} },
@


1.214
log
@Add CM-a for 'nogroup' (CM-0 stays for now); update manpage to reflect.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.213 2016/10/05 13:10:59 okan Exp $
d354 1
a354 1
	void		 (*handler)(struct client_ctx *, union arg *);
d415 1
a415 2
	{ "grouptoggle", kbfunc_client_grouptoggle, CWM_CONTEXT_CLIENT,
	    {.i = CWM_KBD}},
d491 4
a494 8
	{ "window_grouptoggle", kbfunc_client_grouptoggle, CWM_CONTEXT_CLIENT,
	   {.i = CWM_MOUSE} },
	{ "menu_group", kbfunc_menu_group, CWM_CONTEXT_SCREEN,
	    {.i = CWM_MOUSE} },
	{ "menu_unhide", kbfunc_menu_client, CWM_CONTEXT_SCREEN,
	    {.i = CWM_MOUSE} },
	{ "menu_cmd", kbfunc_menu_cmd, CWM_CONTEXT_SCREEN,
	    {.i = CWM_MOUSE} },
@


1.213
log
@Stash wmname into conf.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.212 2016/10/04 15:52:32 okan Exp $
d195 1
@


1.212
log
@Calculate client nameqlen in client_setname(), the only place it's
needed/used.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.211 2016/10/04 15:18:20 okan Exp $
d286 1
d331 1
@


1.211
log
@Turn CALMWM_NGROUPS define into variable, ngroups.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.210 2016/10/03 18:43:49 okan Exp $
d262 1
@


1.210
log
@Start simplifying menu code; and in turn, remove a cursor no longer
needed.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.209 2016/10/03 14:42:34 okan Exp $
d261 1
@


1.209
log
@Defaults are split between defines and conf_init(); normalize these, as
well as give 'sticky' groups its own variable.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.208 2016/09/30 18:28:06 okan Exp $
d643 1
a643 1
	XC_X_cursor,		/* CF_DEFAULT */
d645 1
a645 1
	XC_left_ptr,		/* CF_NORMAL */
a646 1
	XC_bottom_right_corner,	/* CF_RESIZE */
@


1.208
log
@Use instinsic X11 functions for key/btn/ptr grab/ungrab/regrab requests;
the one line wrappers provided no value and limited altering calls where
needed; additionally, most of them had but one caller.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.207 2016/09/29 00:21:55 okan Exp $
d257 4
a260 3
	c->bwidth = CONF_BWIDTH;
	c->mamount = CONF_MAMOUNT;
	c->snapdist = CONF_SNAPDIST;
d283 1
a283 1
	c->font = xstrdup(CONF_FONT);
@


1.207
log
@Mechanical change: move screen menu bits to their own struct.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.206 2016/09/22 14:36:03 okan Exp $
d658 2
d664 1
d666 1
a666 1
	xu_btn_ungrab(win);
d669 8
a676 2
		if (mb->context == CWM_CONTEXT_CLIENT)
			xu_btn_grab(win, mb->modmask, mb->press.button);
d678 1
d685 2
d688 1
a688 1
	xu_key_ungrab(win);
d690 10
a699 2
	TAILQ_FOREACH(kb, &Conf.keybindingq, entry)
		xu_key_grab(win, kb->modmask, kb->press.keysym);
@


1.206
log
@Continue merging kb and mouse functions: fold
mousefunc_menu_{client,cmd,group} into the respective
kbfunc_menu_{client,cmd,group} functions; simply pass a flag down from
config denoting mouse action behaviour.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.205 2016/09/12 13:47:00 okan Exp $
d165 1
a165 1
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1,
d170 2
a171 2
	sc->xftdraw = XftDrawCreate(X_Dpy, sc->menuwin, visual, colormap);
	if (sc->xftdraw == NULL)
@


1.205
log
@change 'sticky' to 'stick' to toggle client stickiness (seems the
default binding worked for everyone for a long time!); conflict with
group sticky found by Ali Farzanrad - thanks!
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.204 2016/08/13 09:59:48 matthieu Exp $
d488 6
a493 3
	{ "menu_group", mousefunc_menu_group, CWM_CONTEXT_SCREEN, {0} },
	{ "menu_unhide", mousefunc_menu_client, CWM_CONTEXT_SCREEN, {0} },
	{ "menu_cmd", mousefunc_menu_cmd, CWM_CONTEXT_SCREEN, {0} },
@


1.204
log
@add a column to previous commit for consitency.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.203 2016/08/13 09:58:37 matthieu Exp $
d210 1
a210 1
	{ "CM-s",	"sticky" },
d411 1
a411 1
	{ "sticky", kbfunc_client_toggle_sticky, CWM_CONTEXT_CLIENT, {0} },
@


1.203
log
@conf_screen: report the fontname that can't be opened in case of failure.
ok dcoppa@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.202 2015/11/17 15:19:19 okan Exp $
d141 1
a141 1
			errx(1, "XftFontOpenName %s", Conf.font);
@


1.202
log
@Fix a typo from r1.201; fixes window_grouptoggle binding.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.201 2015/11/12 21:28:03 okan Exp $
d141 1
a141 1
			errx(1, "XftFontOpenName");
@


1.201
log
@more client vs screen context differences
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.200 2015/11/12 18:26:41 okan Exp $
d486 1
a486 1
	{ "window_grouptoggle", kbfunc_group_toggle, CWM_CONTEXT_CLIENT,
@


1.200
log
@Move kb pointer movement out of the kbfunc_client_moveresize since it's
got nothing to do with clients, thus doing flags work causes lots of
waste and almost useless jumpy pointer movements; while here, split out
move and resize since they share almost no code, just like mouse client
move/resize; factor out amount and factor. Still wonder why this is
here, but it works now.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.199 2015/11/10 20:05:33 okan Exp $
d364 18
a381 18
	{ "group1", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 1} },
	{ "group2", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 2} },
	{ "group3", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 3} },
	{ "group4", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 4} },
	{ "group5", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 5} },
	{ "group6", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 6} },
	{ "group7", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 7} },
	{ "group8", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 8} },
	{ "group9", kbfunc_client_group, CWM_CONTEXT_SCREEN, {.i = 9} },
	{ "grouponly1", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 1} },
	{ "grouponly2", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 2} },
	{ "grouponly3", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 3} },
	{ "grouponly4", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 4} },
	{ "grouponly5", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 5} },
	{ "grouponly6", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 6} },
	{ "grouponly7", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 7} },
	{ "grouponly8", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 8} },
	{ "grouponly9", kbfunc_client_grouponly, CWM_CONTEXT_SCREEN, {.i = 9} },
d400 2
a401 2
	{ "nogroup", kbfunc_client_nogroup, CWM_CONTEXT_SCREEN, {0} },
	{ "cyclegroup", kbfunc_client_cyclegroup, CWM_CONTEXT_SCREEN,
d403 1
a403 1
	{ "rcyclegroup", kbfunc_client_cyclegroup, CWM_CONTEXT_SCREEN,
d486 1
a486 1
	{ "window_grouptoggle", kbfunc_client_grouptoggle, CWM_CONTEXT_CLIENT,
@


1.199
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.198 2015/09/16 17:58:25 okan Exp $
d429 48
a476 48
	{ "moveup", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_UP | CWM_MOVE)} },
	{ "movedown", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_DOWN | CWM_MOVE)} },
	{ "moveright", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_RIGHT | CWM_MOVE)} },
	{ "moveleft", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_LEFT | CWM_MOVE)} },
	{ "bigmoveup", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_UP | CWM_MOVE | CWM_BIGMOVE)} },
	{ "bigmovedown", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_DOWN | CWM_MOVE | CWM_BIGMOVE)} },
	{ "bigmoveright", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_RIGHT | CWM_MOVE | CWM_BIGMOVE)} },
	{ "bigmoveleft", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_LEFT | CWM_MOVE | CWM_BIGMOVE)} },
	{ "resizeup", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_UP | CWM_RESIZE)} },
	{ "resizedown", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_DOWN | CWM_RESIZE)} },
	{ "resizeright", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_RIGHT | CWM_RESIZE)} },
	{ "resizeleft", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_LEFT | CWM_RESIZE)} },
	{ "bigresizeup", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_UP | CWM_RESIZE | CWM_BIGMOVE)} },
	{ "bigresizedown", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_DOWN | CWM_RESIZE | CWM_BIGMOVE)} },
	{ "bigresizeright", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_RIGHT | CWM_RESIZE | CWM_BIGMOVE)} },
	{ "bigresizeleft", kbfunc_client_moveresize, CWM_CONTEXT_CLIENT,
	    {.i = (CWM_LEFT | CWM_RESIZE | CWM_BIGMOVE)} },
	{ "ptrmoveup", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_UP | CWM_PTRMOVE)} },
	{ "ptrmovedown", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_DOWN | CWM_PTRMOVE)} },
	{ "ptrmoveleft", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_LEFT | CWM_PTRMOVE)} },
	{ "ptrmoveright", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_RIGHT | CWM_PTRMOVE)} },
	{ "bigptrmoveup", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_UP | CWM_PTRMOVE | CWM_BIGMOVE)} },
	{ "bigptrmovedown", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_DOWN | CWM_PTRMOVE | CWM_BIGMOVE)} },
	{ "bigptrmoveleft", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_LEFT | CWM_PTRMOVE | CWM_BIGMOVE)} },
	{ "bigptrmoveright", kbfunc_client_moveresize, CWM_CONTEXT_SCREEN,
	    {.i = (CWM_RIGHT | CWM_PTRMOVE | CWM_BIGMOVE)} },
@


1.198
log
@On execwm, we should properly release resources before exec'ing into a
new window manager; so allow CWM_EXEC_WM to assign new wm to wm_argv and
pass through cwm_status (now EXECWM) so that x_teardown() gets called
before exec'ing the new window manager.  Removes the need for a separate
x_restart() now, using new wm_argv; and consolidates errno for execvp.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.197 2015/08/24 15:42:57 okan Exp $
d349 1
a349 1
	int		 flags;
d352 78
a429 59
	{ "lower", kbfunc_client_lower, CWM_WIN, {0} },
	{ "raise", kbfunc_client_raise, CWM_WIN, {0} },
	{ "search", kbfunc_client_search, 0, {0} },
	{ "menusearch", kbfunc_menu_cmd, 0, {0} },
	{ "groupsearch", kbfunc_menu_group, 0, {0} },
	{ "hide", kbfunc_client_hide, CWM_WIN, {0} },
	{ "cycle", kbfunc_client_cycle, 0, {.i = CWM_CYCLE} },
	{ "rcycle", kbfunc_client_cycle, 0, {.i = CWM_RCYCLE} },
	{ "label", kbfunc_client_label, CWM_WIN, {0} },
	{ "delete", kbfunc_client_delete, CWM_WIN, {0} },
	{ "group1", kbfunc_client_group, 0, {.i = 1} },
	{ "group2", kbfunc_client_group, 0, {.i = 2} },
	{ "group3", kbfunc_client_group, 0, {.i = 3} },
	{ "group4", kbfunc_client_group, 0, {.i = 4} },
	{ "group5", kbfunc_client_group, 0, {.i = 5} },
	{ "group6", kbfunc_client_group, 0, {.i = 6} },
	{ "group7", kbfunc_client_group, 0, {.i = 7} },
	{ "group8", kbfunc_client_group, 0, {.i = 8} },
	{ "group9", kbfunc_client_group, 0, {.i = 9} },
	{ "grouponly1", kbfunc_client_grouponly, 0, {.i = 1} },
	{ "grouponly2", kbfunc_client_grouponly, 0, {.i = 2} },
	{ "grouponly3", kbfunc_client_grouponly, 0, {.i = 3} },
	{ "grouponly4", kbfunc_client_grouponly, 0, {.i = 4} },
	{ "grouponly5", kbfunc_client_grouponly, 0, {.i = 5} },
	{ "grouponly6", kbfunc_client_grouponly, 0, {.i = 6} },
	{ "grouponly7", kbfunc_client_grouponly, 0, {.i = 7} },
	{ "grouponly8", kbfunc_client_grouponly, 0, {.i = 8} },
	{ "grouponly9", kbfunc_client_grouponly, 0, {.i = 9} },
	{ "movetogroup1", kbfunc_client_movetogroup, CWM_WIN, {.i = 1} },
	{ "movetogroup2", kbfunc_client_movetogroup, CWM_WIN, {.i = 2} },
	{ "movetogroup3", kbfunc_client_movetogroup, CWM_WIN, {.i = 3} },
	{ "movetogroup4", kbfunc_client_movetogroup, CWM_WIN, {.i = 4} },
	{ "movetogroup5", kbfunc_client_movetogroup, CWM_WIN, {.i = 5} },
	{ "movetogroup6", kbfunc_client_movetogroup, CWM_WIN, {.i = 6} },
	{ "movetogroup7", kbfunc_client_movetogroup, CWM_WIN, {.i = 7} },
	{ "movetogroup8", kbfunc_client_movetogroup, CWM_WIN, {.i = 8} },
	{ "movetogroup9", kbfunc_client_movetogroup, CWM_WIN, {.i = 9} },
	{ "nogroup", kbfunc_client_nogroup, 0, {0} },
	{ "cyclegroup", kbfunc_client_cyclegroup, 0, {.i = CWM_CYCLE} },
	{ "rcyclegroup", kbfunc_client_cyclegroup, 0, {.i = CWM_RCYCLE} },
	{ "cycleingroup", kbfunc_client_cycle, CWM_WIN,
	    {.i = (CWM_CYCLE | CWM_INGROUP)} },
	{ "rcycleingroup", kbfunc_client_cycle, CWM_WIN,
	    {.i = (CWM_RCYCLE | CWM_INGROUP)} },
	{ "grouptoggle", kbfunc_client_grouptoggle, CWM_WIN, {.i = 0}},
	{ "sticky", kbfunc_client_toggle_sticky, CWM_WIN, {0} },
	{ "fullscreen", kbfunc_client_toggle_fullscreen, CWM_WIN, {0} },
	{ "maximize", kbfunc_client_toggle_maximize, CWM_WIN, {0} },
	{ "vmaximize", kbfunc_client_toggle_vmaximize, CWM_WIN, {0} },
	{ "hmaximize", kbfunc_client_toggle_hmaximize, CWM_WIN, {0} },
	{ "freeze", kbfunc_client_toggle_freeze, CWM_WIN, {0} },
	{ "restart", kbfunc_cwm_status, 0, {.i = CWM_EXECWM} },
	{ "quit", kbfunc_cwm_status, 0, {.i = CWM_QUIT} },
	{ "exec", kbfunc_exec, 0, {.i = CWM_EXEC_PROGRAM} },
	{ "exec_wm", kbfunc_exec, 0, {.i = CWM_EXEC_WM} },
	{ "ssh", kbfunc_ssh, 0, {0} },
	{ "terminal", kbfunc_term, 0, {0} },
	{ "lock", kbfunc_lock, 0, {0} },
	{ "moveup", kbfunc_client_moveresize, CWM_WIN,
d431 1
a431 1
	{ "movedown", kbfunc_client_moveresize, CWM_WIN,
d433 1
a433 1
	{ "moveright", kbfunc_client_moveresize, CWM_WIN,
d435 1
a435 1
	{ "moveleft", kbfunc_client_moveresize, CWM_WIN,
d437 1
a437 1
	{ "bigmoveup", kbfunc_client_moveresize, CWM_WIN,
d439 1
a439 1
	{ "bigmovedown", kbfunc_client_moveresize, CWM_WIN,
d441 1
a441 1
	{ "bigmoveright", kbfunc_client_moveresize, CWM_WIN,
d443 1
a443 1
	{ "bigmoveleft", kbfunc_client_moveresize, CWM_WIN,
d445 1
a445 1
	{ "resizeup", kbfunc_client_moveresize, CWM_WIN,
d447 1
a447 1
	{ "resizedown", kbfunc_client_moveresize, CWM_WIN,
d449 1
a449 1
	{ "resizeright", kbfunc_client_moveresize, CWM_WIN,
d451 1
a451 1
	{ "resizeleft", kbfunc_client_moveresize, CWM_WIN,
d453 1
a453 1
	{ "bigresizeup", kbfunc_client_moveresize, CWM_WIN,
d455 1
a455 1
	{ "bigresizedown", kbfunc_client_moveresize, CWM_WIN,
d457 1
a457 1
	{ "bigresizeright", kbfunc_client_moveresize, CWM_WIN,
d459 1
a459 1
	{ "bigresizeleft", kbfunc_client_moveresize, CWM_WIN,
d461 1
a461 1
	{ "ptrmoveup", kbfunc_client_moveresize, 0,
d463 1
a463 1
	{ "ptrmovedown", kbfunc_client_moveresize, 0,
d465 1
a465 1
	{ "ptrmoveleft", kbfunc_client_moveresize, 0,
d467 1
a467 1
	{ "ptrmoveright", kbfunc_client_moveresize, 0,
d469 1
a469 1
	{ "bigptrmoveup", kbfunc_client_moveresize, 0,
d471 1
a471 1
	{ "bigptrmovedown", kbfunc_client_moveresize, 0,
d473 1
a473 1
	{ "bigptrmoveleft", kbfunc_client_moveresize, 0,
d475 1
a475 1
	{ "bigptrmoveright", kbfunc_client_moveresize, 0,
d477 14
a490 11
	{ "htile", kbfunc_tile, CWM_WIN, {.i = CWM_TILE_HORIZ} },
	{ "vtile", kbfunc_tile, CWM_WIN, {.i = CWM_TILE_VERT} },
	{ "window_lower", kbfunc_client_lower, CWM_WIN, {0} },
	{ "window_raise", kbfunc_client_raise, CWM_WIN, {0} },
	{ "window_hide", kbfunc_client_hide, CWM_WIN, {0} },
	{ "window_move", mousefunc_client_move, CWM_WIN, {0} },
	{ "window_resize", mousefunc_client_resize, CWM_WIN, {0} },
	{ "window_grouptoggle", kbfunc_client_grouptoggle, CWM_WIN, {.i = 1} },
	{ "menu_group", mousefunc_menu_group, 0, {0} },
	{ "menu_unhide", mousefunc_menu_unhide, 0, {0} },
	{ "menu_cmd", mousefunc_menu_cmd, 0, {0} },
d552 1
a552 1
		kb->flags = name_to_func[i].flags;
d558 2
a559 2
	kb->callback = kbfunc_cmdexec;
	kb->flags = CWM_CMD;
d576 1
a576 1
			if (key->flags & CWM_CMD)
d613 1
a613 1
		mb->flags = name_to_func[i].flags;
d663 1
a663 1
		if (mb->flags & CWM_WIN)
@


1.197
log
@Implement _NET_CLIENT_LIST_STACKING (from Thomas Admin), but
bottom-to-top order, as per spec (notified Thomas as well).
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.196 2015/08/24 14:56:10 okan Exp $
d403 1
a403 1
	{ "restart", kbfunc_cwm_status, 0, {.i = CWM_RESTART} },
@


1.196
log
@Sort _NET_WM_STATE Atoms like the spec.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.195 2015/08/21 16:52:37 okan Exp $
d671 1
@


1.195
log
@Fix whitespace.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.194 2015/08/21 16:30:02 okan Exp $
a682 1
	"_CWM_WM_STATE_FREEZE",
d689 1
@


1.194
log
@Add client freeze extension to _NET_WM_STATE Atom, allowing flag to
persist. As usual with new Atoms, requires X restart.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.193 2015/08/21 15:55:39 okan Exp $
d393 1
a393 1
	    {.i = CWM_CYCLE|CWM_INGROUP} },
d395 1
a395 1
	    {.i = CWM_RCYCLE|CWM_INGROUP} },
d411 1
a411 1
	    {.i = (CWM_UP|CWM_MOVE)} },
d413 1
a413 1
	    {.i = (CWM_DOWN|CWM_MOVE)} },
d415 1
a415 1
	    {.i = (CWM_RIGHT|CWM_MOVE)} },
d417 1
a417 1
	    {.i = (CWM_LEFT|CWM_MOVE)} },
d419 1
a419 1
	    {.i = (CWM_UP|CWM_MOVE|CWM_BIGMOVE)} },
d421 1
a421 1
	    {.i = (CWM_DOWN|CWM_MOVE|CWM_BIGMOVE)} },
d423 1
a423 1
	    {.i = (CWM_RIGHT|CWM_MOVE|CWM_BIGMOVE)} },
d425 1
a425 1
	    {.i = (CWM_LEFT|CWM_MOVE|CWM_BIGMOVE)} },
d427 1
a427 1
	    {.i = (CWM_UP|CWM_RESIZE)} },
d429 1
a429 1
	    {.i = (CWM_DOWN|CWM_RESIZE)} },
d431 1
a431 1
	    {.i = (CWM_RIGHT|CWM_RESIZE)} },
d433 1
a433 1
	    {.i = (CWM_LEFT|CWM_RESIZE)} },
d435 1
a435 1
	    {.i = (CWM_UP|CWM_RESIZE|CWM_BIGMOVE)} },
d437 1
a437 1
	    {.i = (CWM_DOWN|CWM_RESIZE|CWM_BIGMOVE)} },
d439 1
a439 1
	    {.i = (CWM_RIGHT|CWM_RESIZE|CWM_BIGMOVE)} },
d441 1
a441 1
	    {.i = (CWM_LEFT|CWM_RESIZE|CWM_BIGMOVE)} },
d443 1
a443 1
	    {.i = (CWM_UP|CWM_PTRMOVE)} },
d445 1
a445 1
	    {.i = (CWM_DOWN|CWM_PTRMOVE)} },
d447 1
a447 1
	    {.i = (CWM_LEFT|CWM_PTRMOVE)} },
d449 1
a449 1
	    {.i = (CWM_RIGHT|CWM_PTRMOVE)} },
d451 1
a451 1
	    {.i = (CWM_UP|CWM_PTRMOVE|CWM_BIGMOVE)} },
d453 1
a453 1
	    {.i = (CWM_DOWN|CWM_PTRMOVE|CWM_BIGMOVE)} },
d455 1
a455 1
	    {.i = (CWM_LEFT|CWM_PTRMOVE|CWM_BIGMOVE)} },
d457 1
a457 1
	    {.i = (CWM_RIGHT|CWM_PTRMOVE|CWM_BIGMOVE)} },
@


1.193
log
@Leave command list order from .cwmrc alone; remove sort.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.192 2015/08/20 14:45:15 okan Exp $
d683 1
@


1.192
log
@Alter big move and resize bindings to match what's in cwm(1);
functionally the same, but re-binding should be based on default
bindings. Matches other similiar bindings.

Discovered by a portable user.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.191 2015/07/12 14:31:47 okan Exp $
d43 1
a43 1
	struct cmd	*cmd, *prev;
a56 7

	/* keep queue sorted by name */
	while ((prev = TAILQ_PREV(cmd, cmd_q, entry)) &&
	    (strcmp(prev->name, cmd->name) > 0)) {
		TAILQ_REMOVE(&c->cmdq, cmd, entry);
		TAILQ_INSERT_BEFORE(prev, cmd, entry);
	}
@


1.191
log
@introduce 'groupsearch' for group menu search; matches on either group
number/shortcut and/or name.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.190 2015/07/01 14:36:42 okan Exp $
d227 4
a230 4
	{ "M-H",	"bigmoveleft" },
	{ "M-J",	"bigmovedown" },
	{ "M-K",	"bigmoveup" },
	{ "M-L",	"bigmoveright" },
d235 4
a238 4
	{ "CM-H",	"bigresizeleft" },
	{ "CM-J",	"bigresizedown" },
	{ "CM-K",	"bigresizeup" },
	{ "CM-L",	"bigresizeright" },
@


1.190
log
@style
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.189 2015/06/30 18:44:29 okan Exp $
d363 1
@


1.189
log
@keep cmdq sorted
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.188 2015/06/30 18:42:50 okan Exp $
d349 2
a350 2
	cc->bwidth = ignore ? 0 : Conf.bwidth;
	cc->flags |= ignore ? CLIENT_IGNORE : 0;
@


1.188
log
@style and spacing nits
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.187 2015/05/21 00:37:04 okan Exp $
d43 1
a43 1
	struct cmd	*cmd;
d57 8
@


1.187
log
@merge kbd and mouse grouptoggle
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.186 2015/05/17 04:34:01 kspillner Exp $
d36 3
a38 3
static void	 	 conf_cmd_remove(struct conf *, const char *);
static void	 	 conf_unbind_kbd(struct conf *, struct binding *);
static void	 	 conf_unbind_mouse(struct conf *, struct binding *);
@


1.186
log
@Make window name and window class separate parameters to conf_autogroup.
No functional change, but will be used shortly.

ok okan@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.185 2015/03/26 21:41:43 okan Exp $
d394 1
a394 1
	{ "grouptoggle", kbfunc_client_grouptoggle, CWM_WIN, {0}},
d463 1
a463 1
	{ "window_grouptoggle", mousefunc_client_grouptoggle, CWM_WIN, {0} },
@


1.185
log
@Simplify key/mb binding moving argtype into flags and dropping another
variable; removes the need to zero out struct binding, leaving a simple
malloc.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.184 2015/01/24 18:16:59 okan Exp $
d74 1
a74 1
conf_autogroup(struct conf *c, int num, const char *val)
d81 7
a87 3
	if ((p = strchr(val, ',')) == NULL) {
		aw->name = NULL;
		aw->class = xstrdup(val);
d90 6
a95 1
		aw->name = xstrdup(val);
@


1.184
log
@calloc -> malloc
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.183 2015/01/23 20:26:36 okan Exp $
d494 1
a494 1
	unsigned int	 i, mask;
d496 2
a497 3
	kb = xcalloc(1, sizeof(*kb));
	key = conf_bind_getmask(bind, &mask);
	kb->modmask |= mask;
a520 1
		kb->argtype |= ARG_INT;
d526 1
a526 1
	kb->flags = 0;
a527 1
	kb->argtype |= ARG_CHAR;
d543 1
a543 1
			if (key->argtype & ARG_CHAR)
d555 1
a555 1
	unsigned int	 i, mask;
d557 2
a558 3
	mb = xcalloc(1, sizeof(*mb));
	button = conf_bind_getmask(bind, &mask);
	mb->modmask |= mask;
@


1.183
log
@use malloc over calloc here
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.182 2015/01/19 14:54:16 okan Exp $
d79 1
a79 1
	aw = xcalloc(1, sizeof(*aw));
@


1.182
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.181 2014/09/17 18:41:44 okan Exp $
d99 1
a99 1
	wn = xcalloc(1, sizeof(*wn));
@


1.181
log
@these client actions are just toggles; less confusing with better names
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.180 2014/09/17 16:00:44 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d27 1
@


1.180
log
@Implement EWMH _NET_WM_STATE_HIDDEN.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.179 2014/09/07 19:27:30 okan Exp $
d385 6
a390 6
	{ "sticky", kbfunc_client_sticky, CWM_WIN, {0} },
	{ "fullscreen", kbfunc_client_fullscreen, CWM_WIN, {0} },
	{ "maximize", kbfunc_client_maximize, CWM_WIN, {0} },
	{ "vmaximize", kbfunc_client_vmaximize, CWM_WIN, {0} },
	{ "hmaximize", kbfunc_client_hmaximize, CWM_WIN, {0} },
	{ "freeze", kbfunc_client_freeze, CWM_WIN, {0} },
@


1.179
log
@more style nits
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.178 2014/09/06 16:14:35 okan Exp $
d678 1
@


1.178
log
@Move termpath and lockpath into cmdq; side effect is that 'lock' and
'term' now show up in the application menu.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.177 2014/08/25 12:49:19 okan Exp $
d478 1
a478 1
		return (name);
d485 1
a485 1
	return (dash + 1);
d503 1
a503 1
		return (0);
d511 1
a511 1
		return (1);
d523 1
a523 1
		return (1);
d531 1
a531 1
	return (1);
d567 1
a567 1
		return (0);
d575 1
a575 1
		return (1);
d586 1
a586 1
		return (1);
d589 1
a589 1
	return (0);
@


1.177
log
@Implement _NET_WM_STATE_STICKY, bound to CM-s by default; allows any
client to 'stick' to all desktops (ewmh speak) or groups - this
currently has the same affect as setting a client's group to 'nogroup',
with the exception that the client can also be in a group, so when
un-sticking, the client will go back to its original group/desktop.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.176 2014/08/24 15:49:58 okan Exp $
d44 7
a50 19
	/* "term" and "lock" have special meanings. */
	if (strcmp(name, "term") == 0) {
		if (strlcpy(c->termpath, path, sizeof(c->termpath)) >=
		    sizeof(c->termpath))
			return (0);
	} else if (strcmp(name, "lock") == 0) {
		if (strlcpy(c->lockpath, path, sizeof(c->lockpath)) >=
		    sizeof(c->lockpath))
			return (0);
	} else {
		conf_cmd_remove(c, name);

		cmd = xmalloc(sizeof(*cmd));

		cmd->name = xstrdup(name);
		if (strlcpy(cmd->path, path, sizeof(cmd->path)) >=
		    sizeof(cmd->path))
			return (0);
		TAILQ_INSERT_TAIL(&c->cmdq, cmd, entry);
d52 5
a56 1
	return (1);
@


1.176
log
@Continue effort to bring keyboard and mouse functions together; merge
name_to_kbfunc and name_to_mousefunc.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.175 2014/08/20 15:15:29 okan Exp $
d207 1
d393 1
d683 1
@


1.175
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.174 2014/08/19 18:39:41 okan Exp $
d347 1
a347 1
} name_to_kbfunc[] = {
d454 9
d520 2
a521 2
	for (i = 0; i < nitems(name_to_kbfunc); i++) {
		if (strcmp(name_to_kbfunc[i].tag, cmd) != 0)
d524 3
a526 3
		kb->callback = name_to_kbfunc[i].handler;
		kb->flags = name_to_kbfunc[i].flags;
		kb->argument = name_to_kbfunc[i].argument;
a557 19
static const struct {
	const char	*tag;
	void		 (*handler)(struct client_ctx *, union arg *);
	int		 flags;
	union arg	 argument;
} name_to_mousefunc[] = {
	{ "window_lower", kbfunc_client_lower, CWM_WIN, {0} },
	{ "window_raise", kbfunc_client_raise, CWM_WIN, {0} },
	{ "window_hide", kbfunc_client_hide, CWM_WIN, {0} },
	{ "cyclegroup", kbfunc_client_cyclegroup, 0, {.i = CWM_CYCLE} },
	{ "rcyclegroup", kbfunc_client_cyclegroup, 0, {.i = CWM_RCYCLE} },
	{ "window_move", mousefunc_client_move, CWM_WIN, {0} },
	{ "window_resize", mousefunc_client_resize, CWM_WIN, {0} },
	{ "window_grouptoggle", mousefunc_client_grouptoggle, CWM_WIN, {0} },
	{ "menu_group", mousefunc_menu_group, 0, {0} },
	{ "menu_unhide", mousefunc_menu_unhide, 0, {0} },
	{ "menu_cmd", mousefunc_menu_cmd, 0, {0} },
};

d584 2
a585 2
	for (i = 0; i < nitems(name_to_mousefunc); i++) {
		if (strcmp(name_to_mousefunc[i].tag, cmd) != 0)
d588 3
a590 3
		mb->callback = name_to_mousefunc[i].handler;
		mb->flags = name_to_mousefunc[i].flags;
		mb->argument = name_to_mousefunc[i].argument;
@


1.174
log
@Remove unnecessary memset since reload was replaced with restart;
from Kent Spillner.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.173 2014/04/21 12:52:14 okan Exp $
d81 1
a81 1
conf_autogroup(struct conf *c, int no, const char *val)
d96 1
a96 1
	aw->num = no;
@


1.173
log
@plug memleak (currently unused func); from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.172 2014/02/02 16:29:04 okan Exp $
a251 2

	(void)memset(c, 0, sizeof(*c));
@


1.172
log
@No need to store screen colormap and visual; rather just use the X
macros in the one place they are needed.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.171 2014/02/02 15:46:05 okan Exp $
d312 1
@


1.171
log
@The menu already limits entries with MENU_MAXENTRY, so don't bother
holding a command name limit as well.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.170 2014/01/30 22:17:22 okan Exp $
d128 2
d146 1
a146 1
			if (!XftColorAllocValue(X_Dpy, sc->visual, sc->colormap,
d151 1
a151 1
		if (XftColorAllocName(X_Dpy, sc->visual, sc->colormap,
d154 1
a154 1
			XftColorFree(X_Dpy, sc->visual, sc->colormap, &xc);
d157 1
a157 1
			XftColorAllocName(X_Dpy, sc->visual, sc->colormap,
d167 1
a167 2
	sc->xftdraw = XftDrawCreate(X_Dpy, sc->menuwin,
	    sc->visual, sc->colormap);
@


1.170
log
@Switch ignoreq to winname struct since it's basically the same thing;
removes limit on name matching.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.169 2014/01/30 15:43:53 okan Exp $
d54 2
d58 1
a58 5
		conf_cmd_remove(c, name);

		if (strlcpy(cmd->name, name, sizeof(cmd->name)) >=
		    sizeof(cmd->name))
			return (0);
d75 1
d293 1
@


1.169
log
@use the same autogroupwin variable as everywhere else
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.168 2014/01/30 14:40:21 okan Exp $
d102 2
a103 2
int
conf_ignore(struct conf *c, const char *val)
d105 1
a105 3
	struct winmatch	*wm;

	wm = xcalloc(1, sizeof(*wm));
d107 3
a109 5
	if (strlcpy(wm->title, val, sizeof(wm->title)) >= sizeof(wm->title))
		return (0);

	TAILQ_INSERT_TAIL(&c->ignoreq, wm, entry);
	return (1);
d288 1
a288 1
	struct winmatch		*wm;
d309 3
a311 3
	while ((wm = TAILQ_FIRST(&c->ignoreq)) != NULL) {
		TAILQ_REMOVE(&c->ignoreq, wm, entry);
		free(wm);
d328 1
a328 2
	struct winmatch	*wm;
	char		*wname = cc->name;
d331 2
a332 2
	TAILQ_FOREACH(wm, &Conf.ignoreq, entry) {
		if (strncasecmp(wm->title, wname, strlen(wm->title)) == 0) {
@


1.168
log
@Remove duplicate mouse functions and instead use the kbfunc ones.  No
user visable changes at this point, but they'll merge at an appropriate
time.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.167 2014/01/29 22:30:00 okan Exp $
d290 1
a290 1
	struct autogroupwin	*ag;
d306 5
a310 5
	while ((ag = TAILQ_FIRST(&c->autogroupq)) != NULL) {
		TAILQ_REMOVE(&c->autogroupq, ag, entry);
		free(ag->class);
		free(ag->name);
		free(ag);
@


1.167
log
@Minimize trivial differences between a few kb and mb functions.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.166 2014/01/29 21:13:52 okan Exp $
d560 5
a567 5
	{ "window_lower", mousefunc_client_lower, CWM_WIN, {0} },
	{ "window_raise", mousefunc_client_raise, CWM_WIN, {0} },
	{ "window_hide", mousefunc_client_hide, CWM_WIN, {0} },
	{ "cyclegroup", mousefunc_client_cyclegroup, 0, {.i = CWM_CYCLE} },
	{ "rcyclegroup", mousefunc_client_cyclegroup, 0, {.i = CWM_RCYCLE} },
@


1.166
log
@Merge keybinding and mousebinding queues into using the same merged
struct, binding; they were essentially the same accept for what was
'pressed', keysym or button.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.165 2014/01/29 18:43:27 okan Exp $
d356 1
a356 1
	{ "menusearch", kbfunc_menu_search, 0, {0} },
@


1.165
log
@Much like we do for keyboard and mouse bindings, remove duplicates for
command name - last match.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.164 2014/01/29 18:34:22 okan Exp $
d36 2
a37 2
static void	 	 conf_unbind_kbd(struct conf *, struct keybinding *);
static void	 	 conf_unbind_mouse(struct conf *, struct mousebinding *);
d291 1
a291 1
	struct keybinding	*kb;
a293 1
	struct mousebinding	*mb;
d493 3
a495 3
	struct keybinding	*kb;
	const char		*key;
	unsigned int		 i, mask;
d501 2
a502 2
	kb->keysym = XStringToKeysym(key);
	if (kb->keysym == NoSymbol) {
d537 1
a537 1
conf_unbind_kbd(struct conf *c, struct keybinding *unbind)
d539 1
a539 1
	struct keybinding	*key = NULL, *keynxt;
d545 1
a545 1
		if (key->keysym == unbind->keysym) {
d576 3
a578 3
	struct mousebinding	*mb;
	const char		*button, *errstr;
	unsigned int		 i, mask;
d584 1
a584 1
	mb->button = strtonum(button, Button1, Button5, &errstr);
d614 1
a614 1
conf_unbind_mouse(struct conf *c, struct mousebinding *unbind)
d616 1
a616 1
	struct mousebinding	*mb = NULL, *mbnxt;
d622 1
a622 1
		if (mb->button == unbind->button) {
d649 1
a649 1
	struct mousebinding	*mb;
d655 1
a655 1
			xu_btn_grab(win, mb->modmask, mb->button);
d662 1
a662 1
	struct keybinding	*kb;
d667 1
a667 1
		xu_key_grab(win, kb->modmask, kb->keysym);
@


1.164
log
@Check command name/path for truncation and provide user feedback during
config parse (and use conf_cmd_add to populate defaults); based on a
discussion with Tiago Cunha.  While this looks ugly, there are likely
some other changes here to come.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.163 2014/01/28 20:22:21 okan Exp $
d35 1
d56 2
d69 12
@


1.163
log
@Check ignore windowname for truncation and provide user feedback during
config parse; based on a discussion with Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.162 2014/01/23 17:13:38 okan Exp $
d38 1
a38 2
/* Add an command menu entry to the end of the menu */
void
d41 2
d44 17
a60 8
	if (strcmp(name, "term") == 0)
		(void)strlcpy(c->termpath, path, sizeof(c->termpath));
	else if (strcmp(name, "lock") == 0)
		(void)strlcpy(c->lockpath, path, sizeof(c->lockpath));
	else {
		struct cmd *cmd = xmalloc(sizeof(*cmd));
		(void)strlcpy(cmd->name, name, sizeof(cmd->name));
		(void)strlcpy(cmd->path, path, sizeof(cmd->path));
d63 1
d263 2
a264 3
	/* Default term/lock */
	(void)strlcpy(c->termpath, "xterm", sizeof(c->termpath));
	(void)strlcpy(c->lockpath, "xlock", sizeof(c->lockpath));
@


1.162
log
@no need to quote within warning
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.161 2014/01/22 21:48:27 okan Exp $
d76 1
a76 1
void
d83 2
a84 1
	(void)strlcpy(wm->title, val, sizeof(wm->title));
d87 1
@


1.161
log
@Somewhat streamline event loop/restart/quit handling; most notable
change allows a restart to trigger proper teardown first, even though
teardown is not (yet) complete.

After some discussion with oga@@nicotinebsd.org regarding a more
complicated version/idea.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.160 2014/01/21 15:42:44 okan Exp $
d123 1
a123 1
				warnx("XftColorAllocValue: '%s'", Conf.color[i]);
d131 1
a131 1
			warnx("XftColorAllocName: '%s'", Conf.color[i]);
@


1.160
log
@Sprinkle a few more const; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.159 2014/01/20 23:03:51 okan Exp $
d376 2
a377 2
	{ "restart", kbfunc_restart, 0, {0} },
	{ "quit", kbfunc_quit_wm, 0, {0} },
@


1.159
log
@merge KBFLAG_NEEDCLIENT and MOUSEBIND_CTX_*; brings kbfunc and mousefunc
bits even closer.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.158 2014/01/20 22:31:53 okan Exp $
d88 1
a88 1
static char *color_binds[] = {
d150 3
a152 3
static struct {
	char	*key;
	char	*func;
d321 2
a322 2
static struct {
	char		*tag;
d435 3
a437 3
static struct {
	char	ch;
	int	mask;
d528 2
a529 2
static struct {
	char		*tag;
@


1.158
log
@Use argument to pass down flags for mousefunc cyclegroup; removes
rcyclegroup wrapper need - now similar to kbfunc.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.157 2014/01/20 21:34:32 okan Exp $
d327 2
a328 2
	{ "lower", kbfunc_client_lower, KBFLAG_NEEDCLIENT, {0} },
	{ "raise", kbfunc_client_raise, KBFLAG_NEEDCLIENT, {0} },
d331 1
a331 1
	{ "hide", kbfunc_client_hide, KBFLAG_NEEDCLIENT, {0} },
d334 2
a335 2
	{ "label", kbfunc_client_label, KBFLAG_NEEDCLIENT, {0} },
	{ "delete", kbfunc_client_delete, KBFLAG_NEEDCLIENT, {0} },
d354 9
a362 18
	{ "movetogroup1", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 1} },
	{ "movetogroup2", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 2} },
	{ "movetogroup3", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 3} },
	{ "movetogroup4", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 4} },
	{ "movetogroup5", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 5} },
	{ "movetogroup6", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 6} },
	{ "movetogroup7", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 7} },
	{ "movetogroup8", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 8} },
	{ "movetogroup9", kbfunc_client_movetogroup, KBFLAG_NEEDCLIENT,
	    {.i = 9} },
d366 1
a366 1
	{ "cycleingroup", kbfunc_client_cycle, KBFLAG_NEEDCLIENT,
d368 1
a368 1
	{ "rcycleingroup", kbfunc_client_cycle, KBFLAG_NEEDCLIENT,
d370 6
a375 6
	{ "grouptoggle", kbfunc_client_grouptoggle, KBFLAG_NEEDCLIENT, {0}},
	{ "fullscreen", kbfunc_client_fullscreen, KBFLAG_NEEDCLIENT, {0} },
	{ "maximize", kbfunc_client_maximize, KBFLAG_NEEDCLIENT, {0} },
	{ "vmaximize", kbfunc_client_vmaximize, KBFLAG_NEEDCLIENT, {0} },
	{ "hmaximize", kbfunc_client_hmaximize, KBFLAG_NEEDCLIENT, {0} },
	{ "freeze", kbfunc_client_freeze, KBFLAG_NEEDCLIENT, {0} },
d383 1
a383 1
	{ "moveup", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d385 1
a385 1
	{ "movedown", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d387 1
a387 1
	{ "moveright", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d389 1
a389 1
	{ "moveleft", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d391 1
a391 1
	{ "bigmoveup", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d393 1
a393 1
	{ "bigmovedown", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d395 1
a395 1
	{ "bigmoveright", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d397 1
a397 1
	{ "bigmoveleft", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d399 1
a399 1
	{ "resizeup", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d401 1
a401 1
	{ "resizedown", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d403 1
a403 1
	{ "resizeright", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d405 1
a405 1
	{ "resizeleft", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d407 1
a407 1
	{ "bigresizeup", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d409 1
a409 1
	{ "bigresizedown", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d411 1
a411 1
	{ "bigresizeright", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d413 1
a413 1
	{ "bigresizeleft", kbfunc_client_moveresize, KBFLAG_NEEDCLIENT,
d431 2
a432 4
	{ "htile", kbfunc_tile, KBFLAG_NEEDCLIENT,
	    {.i = CWM_TILE_HORIZ } },
	{ "vtile", kbfunc_tile, KBFLAG_NEEDCLIENT,
	    {.i = CWM_TILE_VERT } },
d534 11
a544 14
	{ "window_move", mousefunc_client_move, MOUSEBIND_CTX_WIN, {0} },
	{ "window_resize", mousefunc_client_resize, MOUSEBIND_CTX_WIN, {0} },
	{ "window_grouptoggle", mousefunc_client_grouptoggle,
	    MOUSEBIND_CTX_WIN, {0} },
	{ "window_lower", mousefunc_client_lower, MOUSEBIND_CTX_WIN, {0} },
	{ "window_raise", mousefunc_client_raise, MOUSEBIND_CTX_WIN, {0} },
	{ "window_hide", mousefunc_client_hide, MOUSEBIND_CTX_WIN, {0} },
	{ "cyclegroup", mousefunc_client_cyclegroup,
	    MOUSEBIND_CTX_ROOT, {.i = CWM_CYCLE} },
	{ "rcyclegroup", mousefunc_client_cyclegroup,
	    MOUSEBIND_CTX_ROOT, {.i = CWM_RCYCLE} },
	{ "menu_group", mousefunc_menu_group, MOUSEBIND_CTX_ROOT, {0} },
	{ "menu_unhide", mousefunc_menu_unhide, MOUSEBIND_CTX_ROOT, {0} },
	{ "menu_cmd", mousefunc_menu_cmd, MOUSEBIND_CTX_ROOT, {0} },
d628 2
a629 3
		if (mb->flags != MOUSEBIND_CTX_WIN)
			continue;
		xu_btn_grab(win, mb->modmask, mb->button);
@


1.157
log
@constify and rename some confusing variables around cmdq.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.156 2014/01/20 19:06:04 okan Exp $
d552 4
a555 3
	{ "cyclegroup", mousefunc_client_cyclegroup, MOUSEBIND_CTX_ROOT, {0} },
	{ "rcyclegroup", mousefunc_client_rcyclegroup,
	    MOUSEBIND_CTX_ROOT, {0} },
@


1.156
log
@ - remove redundant range check for buttons in conf_bind_mouse.
 - make conf_bind_kbd return error on non-matches to match what
   conf_bind_mouse does.
 - rename some variables while here for clarity.
 - constify bind and cmd.

from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.155 2014/01/03 15:29:06 okan Exp $
d40 1
a40 1
conf_cmd_add(struct conf *c, char *image, char *label)
d43 4
a46 4
	if (strcmp(label, "term") == 0)
		(void)strlcpy(c->termpath, image, sizeof(c->termpath));
	else if (strcmp(label, "lock") == 0)
		(void)strlcpy(c->lockpath, image, sizeof(c->lockpath));
d49 2
a50 2
		(void)strlcpy(cmd->image, image, sizeof(cmd->image));
		(void)strlcpy(cmd->label, label, sizeof(cmd->label));
d56 1
a56 1
conf_autogroup(struct conf *c, int no, char *val)
d77 1
a77 1
conf_ignore(struct conf *c, char *val)
@


1.155
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.154 2014/01/02 21:30:20 okan Exp $
d475 2
a476 2
void
conf_bind_kbd(struct conf *c, char *name, char *binding)
d478 13
a490 12
	struct keybinding	*current_binding;
	const char		*substring;
	unsigned int			 i, mask;

	current_binding = xcalloc(1, sizeof(*current_binding));
	substring = conf_bind_getmask(name, &mask);
	current_binding->modmask |= mask;

	current_binding->keysym = XStringToKeysym(substring);
	if (current_binding->keysym == NoSymbol) {
		free(current_binding);
		return;
d494 1
a494 1
	conf_unbind_kbd(c, current_binding);
d496 3
a498 3
	if (strcmp("unmap", binding) == 0) {
		free(current_binding);
		return;
d502 1
a502 1
		if (strcmp(name_to_kbfunc[i].tag, binding) != 0)
d505 6
a510 6
		current_binding->callback = name_to_kbfunc[i].handler;
		current_binding->flags = name_to_kbfunc[i].flags;
		current_binding->argument = name_to_kbfunc[i].argument;
		current_binding->argtype |= ARG_INT;
		TAILQ_INSERT_TAIL(&c->keybindingq, current_binding, entry);
		return;
d513 6
a518 5
	current_binding->callback = kbfunc_cmdexec;
	current_binding->flags = 0;
	current_binding->argument.c = xstrdup(binding);
	current_binding->argtype |= ARG_CHAR;
	TAILQ_INSERT_TAIL(&c->keybindingq, current_binding, entry);
a559 4
static unsigned int mouse_btns[] = {
	Button1, Button2, Button3, Button4, Button5
};

d561 1
a561 1
conf_bind_mouse(struct conf *c, char *name, char *binding)
d563 12
a574 20
	struct mousebinding	*current_binding;
	const char		*errstr, *substring;
	unsigned int		 button, i, mask;

	current_binding = xcalloc(1, sizeof(*current_binding));
	substring = conf_bind_getmask(name, &mask);
	current_binding->modmask |= mask;

	button = strtonum(substring, 1, 5, &errstr);
	if (errstr)
		warnx("button number is %s: %s", errstr, substring);

	for (i = 0; i < nitems(mouse_btns); i++) {
		if (button == mouse_btns[i]) {
			current_binding->button = button;
			break;
		}
	}
	if (!current_binding->button || errstr) {
		free(current_binding);
d579 1
a579 1
	conf_unbind_mouse(c, current_binding);
d581 2
a582 2
	if (strcmp("unmap", binding) == 0) {
		free(current_binding);
d587 1
a587 1
		if (strcmp(name_to_mousefunc[i].tag, binding) != 0)
d590 4
a593 4
		current_binding->callback = name_to_mousefunc[i].handler;
		current_binding->flags = name_to_mousefunc[i].flags;
		current_binding->argument = name_to_mousefunc[i].argument;
		TAILQ_INSERT_TAIL(&c->mousebindingq, current_binding, entry);
@


1.154
log
@bring mousefunc closer to kbfunc
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.153 2013/12/17 16:10:43 okan Exp $
d34 1
a34 1
static const char	*conf_bind_getmask(const char *, u_int *);
d103 1
a103 1
	u_int		 i;
d227 1
a227 1
	u_int	i;
d457 1
a457 1
conf_bind_getmask(const char *name, u_int *mask)
d461 1
a461 1
	u_int	 	 i;
d480 1
a480 1
	u_int			 i, mask;
d567 1
a567 1
	u_int			 button, i, mask;
d637 1
a637 1
	u_int	 i;
@


1.153
log
@replace with memset
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.152 2013/12/16 19:02:17 okan Exp $
d538 4
a541 3
	char *tag;
	void (*handler)(struct client_ctx *, void *);
	int flags;
d543 2
a544 2
	{ "window_move", mousefunc_client_move, MOUSEBIND_CTX_WIN },
	{ "window_resize", mousefunc_client_resize, MOUSEBIND_CTX_WIN },
d546 10
a555 9
	    MOUSEBIND_CTX_WIN },
	{ "window_lower", mousefunc_client_lower, MOUSEBIND_CTX_WIN },
	{ "window_raise", mousefunc_client_raise, MOUSEBIND_CTX_WIN },
	{ "window_hide", mousefunc_client_hide, MOUSEBIND_CTX_WIN },
	{ "cyclegroup", mousefunc_client_cyclegroup, MOUSEBIND_CTX_ROOT },
	{ "rcyclegroup", mousefunc_client_rcyclegroup, MOUSEBIND_CTX_ROOT },
	{ "menu_group", mousefunc_menu_group, MOUSEBIND_CTX_ROOT },
	{ "menu_unhide", mousefunc_menu_unhide, MOUSEBIND_CTX_ROOT },
	{ "menu_cmd", mousefunc_menu_cmd, MOUSEBIND_CTX_ROOT },
d602 1
@


1.152
log
@Implement support for EWMH's _NET_WM_STATE_FULLSCREEN hint.

Since we already have a form of 'maximize', we need to differentiate
between 'maximize' and the new 'fullscreen' mode.  The 'maximize' mode
will continue to honor gap but now *retains* the border, matching the
'vert/horz maximize' behaviour.  The new 'fullscreen' mode supports and
follows the _NET_WM_STATE_FULLSCREEN hint, allowing the client perform
additional window modifications; in this mode, cwm(1) will *ignore* gap,
remove borders and freeze(move/resize) the client.  Additionally,
'fullscreen' mode will remember various combinations of previous states.

* default keybinding changes: CM-f 'fullscreen', CM-m 'maximize' (re-map
  as desired).

Positive feedback from a few, testing and ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.151 2013/12/13 14:40:52 okan Exp $
d229 1
a229 1
	bzero(c, sizeof(*c));
@


1.151
log
@Add support for XUrgency and matching _NET_WM_STATE_DEMANDS_ATTENTION
ewmh hint; urgencyborder is configurable.  The urgency flag will stick,
even while on a client in a non-viewable group, until the client
receives focus (where the border is reset).  Initial diff from Thomas
Adam with some changes/enhancements from me.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.150 2013/11/27 18:34:34 okan Exp $
d181 2
a182 1
	{ "CM-f",	"maximize" },
d380 1
d693 1
@


1.150
log
@like gap, make snapdist per screen
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.149 2013/11/27 16:24:17 okan Exp $
d91 1
d691 1
@


1.149
log
@Remove the option to bind a key by keycode with brackets; it never
worked (and no one complained!).  While it's fairly easy to fix, users
should be using keysym names and not keycodes.

Discussed at length months ago with todd@@, matthieu@@ and Owain.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.148 2013/10/20 01:55:32 okan Exp $
d106 1
@


1.148
log
@wrap key ungrab like btn ungrab, for it'll be used again
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.147 2013/10/19 19:39:34 okan Exp $
d482 2
a483 11
	if (substring[0] == '[' &&
	    substring[strlen(substring)-1] == ']') {
		sscanf(substring, "[%d]", &current_binding->keycode);
		current_binding->keysym = NoSymbol;
	} else {
		current_binding->keycode = 0;
		current_binding->keysym = XStringToKeysym(substring);
	}

	if (current_binding->keysym == NoSymbol &&
	    current_binding->keycode == 0) {
d524 1
a524 3
		if ((key->keycode != 0 && key->keysym == NoSymbol &&
		    key->keycode == unbind->keycode) ||
		    key->keysym == unbind->keysym) {
@


1.147
log
@Using xu_btn_ungrab() buttons during client_leave doesn't work (error
BadValue) when the modifier is already AnyModifier .  Instead alter
xu_btn_ungrab() to ungrab AnyButton/AnyModifier and call it only when a
client is coming into focus in client_setactive(), instead of iterating
over ignore mods - matches how we handle key grabs.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.146 2013/10/07 13:40:26 okan Exp $
d666 1
a666 1
	XUngrabKey(X_Dpy, AnyKey, AnyModifier, win);
@


1.146
log
@trying parsing a XLFD string first, then by pattern
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.145 2013/07/16 14:22:25 okan Exp $
d651 2
@


1.145
log
@don't need the size here
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.144 2013/07/16 14:04:44 okan Exp $
d107 6
a112 3
	sc->xftfont = XftFontOpenName(X_Dpy, sc->which, Conf.font);
	if (sc->xftfont == NULL)
		errx(1, "XftFontOpenName");
@


1.144
log
@max -> nitems
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.143 2013/07/15 14:50:44 okan Exp $
d627 1
a627 1
static int cursor_binds[CF_NITEMS] = {
@


1.143
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.142 2013/07/10 14:11:42 okan Exp $
d291 1
a291 1
	for (i = 0; i < CWM_COLOR_MAX; i++)
@


1.142
log
@type fixes
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.141 2013/07/08 18:39:20 okan Exp $
d665 37
@


1.141
log
@add support for mouse based group {,r}cycle; from Rodrigo Mosconi.  not
bound by default.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.140 2013/07/08 18:19:22 okan Exp $
d102 2
a103 2
	int			 i;
	XftColor		 xc;
@


1.140
log
@move kbfunc and mousefunc closer together
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.139 2013/07/08 16:32:51 okan Exp $
d553 2
@


1.139
log
@clarify kbd vs mouse functions
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.138 2013/07/08 16:10:55 okan Exp $
d35 1
a36 1
static void	 	 conf_unbind_kbd(struct conf *, struct keybinding *);
d385 1
a385 1
	{ "moveup", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d387 1
a387 1
	{ "movedown", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d389 1
a389 1
	{ "moveright", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d391 1
a391 1
	{ "moveleft", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d393 1
a393 1
	{ "bigmoveup", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d395 1
a395 1
	{ "bigmovedown", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d397 1
a397 1
	{ "bigmoveright", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d399 1
a399 1
	{ "bigmoveleft", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d401 1
a401 1
	{ "resizeup", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d403 1
a403 1
	{ "resizedown", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d405 1
a405 1
	{ "resizeright", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d407 1
a407 1
	{ "resizeleft", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d409 1
a409 1
	{ "bigresizeup", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d411 1
a411 1
	{ "bigresizedown", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d413 1
a413 1
	{ "bigresizeright", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d415 1
a415 1
	{ "bigresizeleft", kbfunc_moveresize, KBFLAG_NEEDCLIENT,
d417 7
a423 4
	{ "ptrmoveup", kbfunc_moveresize, 0, {.i = (CWM_UP|CWM_PTRMOVE)} },
	{ "ptrmovedown", kbfunc_moveresize, 0, {.i = (CWM_DOWN|CWM_PTRMOVE)} },
	{ "ptrmoveleft", kbfunc_moveresize, 0, {.i = (CWM_LEFT|CWM_PTRMOVE)} },
	{ "ptrmoveright", kbfunc_moveresize, 0,
d425 1
a425 1
	{ "bigptrmoveup", kbfunc_moveresize, 0,
d427 1
a427 1
	{ "bigptrmovedown", kbfunc_moveresize, 0,
d429 1
a429 1
	{ "bigptrmoveleft", kbfunc_moveresize, 0,
d431 1
a431 1
	{ "bigptrmoveright", kbfunc_moveresize, 0,
d544 1
a544 1
	int context;
d546 3
a548 3
	{ "window_move", mousefunc_window_move, MOUSEBIND_CTX_WIN },
	{ "window_resize", mousefunc_window_resize, MOUSEBIND_CTX_WIN },
	{ "window_grouptoggle", mousefunc_window_grouptoggle,
d550 3
a552 3
	{ "window_lower", mousefunc_window_lower, MOUSEBIND_CTX_WIN },
	{ "window_raise", mousefunc_window_raise, MOUSEBIND_CTX_WIN },
	{ "window_hide", mousefunc_window_hide, MOUSEBIND_CTX_WIN },
a599 1
		current_binding->context = name_to_mousefunc[i].context;
d601 1
d648 1
a648 1
		if (mb->context != MOUSEBIND_CTX_WIN)
@


1.138
log
@move duplicate kbd and mouse modifier parsing to a generic function;
from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.137 2013/06/23 17:57:50 okan Exp $
d35 2
a36 2
static void	 	 conf_mouseunbind(struct conf *, struct mousebinding *);
static void	 	 conf_unbind(struct conf *, struct keybinding *);
d148 1
a148 1
} kb_binds[] = {
d207 1
a207 1
m_binds[] = {
d235 2
a236 2
	for (i = 0; i < nitems(kb_binds); i++)
		conf_bindname(c, kb_binds[i].key, kb_binds[i].func);
d238 2
a239 2
	for (i = 0; i < nitems(m_binds); i++)
		conf_mousebind(c, m_binds[i].key, m_binds[i].func);
d437 1
a437 1
	char	chr;
d457 1
a457 1
		if ((ch = strchr(name, bind_mods[i].chr)) != NULL && ch < dash)
d466 1
a466 1
conf_bindname(struct conf *c, char *name, char *binding)
d492 1
a492 1
	conf_unbind(c, current_binding);
d519 1
a519 1
conf_unbind(struct conf *c, struct keybinding *unbind)
d560 1
a560 1
conf_mousebind(struct conf *c, char *name, char *binding)
d586 1
a586 1
	conf_mouseunbind(c, current_binding);
d607 1
a607 1
conf_mouseunbind(struct conf *c, struct mousebinding *unbind)
@


1.137
log
@properly fix (and re-organize) selfont selection.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.136 2013/06/20 02:33:57 okan Exp $
d34 3
a36 2
static void	 conf_mouseunbind(struct conf *, struct mousebinding *);
static void	 conf_unbind(struct conf *, struct keybinding *);
d446 19
d469 2
a470 2
	char			*substring, *tmp;
	u_int			 i;
d473 2
a474 13

	if ((substring = strchr(name, '-')) != NULL) {
		for (i = 0; i < nitems(bind_mods); i++) {
			if ((tmp = strchr(name, bind_mods[i].chr)) !=
			    NULL && tmp < substring) {
				current_binding->modmask |= bind_mods[i].mask;
			}
		}

		/* skip past the modifiers */
		substring++;
	} else
		substring = name;
d563 2
a564 4
	char			*substring, *tmp;
	u_int			 button;
	const char		*errstr;
	u_int			 i;
d567 2
a568 13

	if ((substring = strchr(name, '-')) != NULL) {
		for (i = 0; i < nitems(bind_mods); i++) {
			if ((tmp = strchr(name, bind_mods[i].chr)) !=
			    NULL && tmp < substring) {
				current_binding->modmask |= bind_mods[i].mask;
			}
		}

		/* skip past the modifiers */
		substring++;
	} else
		substring = name;
@


1.136
log
@when selfont is configured, make sure we continue and configure the rest
of the screen (quick fix); discovered the hard way by Rodrigo Mosconi.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.135 2013/06/17 17:11:10 okan Exp $
d87 1
a87 1
static char *color_binds[CWM_COLOR_MAX] = {
d110 8
a117 2
	for (i = 0; i < CWM_COLOR_MAX; i++) {
		if (*Conf.color[i] == '\0')
d119 1
a129 2
	if (i == CWM_COLOR_MAX)
		goto out;
a130 7
	xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_BG],
		    sc->xftcolor[CWM_COLOR_MENU_FG], &xc);
	xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_FONT], xc, &xc);
	if (!XftColorAllocValue(X_Dpy, sc->visual, sc->colormap,
	    &xc.color, &sc->xftcolor[CWM_COLOR_MENU_FONT_SEL]))
		warnx("XftColorAllocValue: '%s'", Conf.color[i]);
out:
@


1.135
log
@move Cursors into conf.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.134 2013/06/17 00:57:47 okan Exp $
d124 1
a124 1
		return;
d132 1
a132 1

@


1.134
log
@allow mouse button4 and button5; from Rodrigo Mosconi
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.133 2013/05/23 16:52:39 okan Exp $
d628 17
a666 1

@


1.133
log
@alter conf_grab(_kbd) to first ungrab AnyKey/AnyModifier, then proceed
to grab keys in keybindingq.  we don't need to ungrab/grab on every
addition to the queue, just once with a complete keybindingq; simplify
grabbing keys per screen (during init) and during a MappingNotify.

while here, change conf_grab_{kbd,mouse} to require only a Window.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.132 2013/05/22 20:23:21 okan Exp $
d548 3
a550 1
static unsigned int mouse_btns[] = { Button1, Button2, Button3 };
d576 1
a576 1
	button = strtonum(substring, 1, 3, &errstr);
@


1.132
log
@since we don't have any screens yet, there's no reason to conf_{,un}grab
here; just build keybindingq.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.131 2013/05/22 16:54:09 okan Exp $
a100 1
	struct keybinding	*kb;
d143 1
a143 2
	TAILQ_FOREACH(kb, &Conf.keybindingq, entry)
		xu_key_grab(sc->rootwin, kb->modmask, kb->keysym);
a436 31
/*
 * The following two functions are used when grabbing and ungrabbing keys for
 * bindings
 */

/*
 * Grab key combination on all screens and add to the global queue
 */
void
conf_grab(struct conf *c, struct keybinding *kb)
{
	extern struct screen_ctx_q	 Screenq;
	struct screen_ctx		*sc;

	TAILQ_FOREACH(sc, &Screenq, entry)
		xu_key_grab(sc->rootwin, kb->modmask, kb->keysym);
}

/*
 * Ungrab key combination from all screens and remove from global queue
 */
void
conf_ungrab(struct conf *c, struct keybinding *kb)
{
	extern struct screen_ctx_q	 Screenq;
	struct screen_ctx		*sc;

	TAILQ_FOREACH(sc, &Screenq, entry)
		xu_key_ungrab(sc->rootwin, kb->modmask, kb->keysym);
}

a625 3
/*
 * Grab the mouse buttons that we need for bindings for this client
 */
d627 1
a627 1
conf_grab_mouse(struct client_ctx *cc)
d634 1
a634 1
		xu_btn_grab(cc->win, mb->modmask, mb->button);
d637 12
@


1.131
log
@get rid of long standing XXX: now that we configure screens based on
config options, add the keybinding GrabKey calls here
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.130 2013/05/22 16:32:15 okan Exp $
a532 1
		conf_grab(c, current_binding);
a540 1
	conf_grab(c, current_binding);
a555 1
			conf_ungrab(c, key);
@


1.130
log
@move validation of pointer Button into conf_mousebind so we check
validity during the parse phase and not bother adding it to the queue,
instead of each time a client needs to grab (when it's too late);
furthermore, make this a config error, stop parsing and load the
default config.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.129 2013/05/20 20:21:04 okan Exp $
d101 3
a103 2
	int		 i;
	XftColor	 xc;
d143 3
@


1.129
log
@- configure menuwin with the screen, then create the xft drawable using
  the menu window since that's the only place on which we draw
- elminate the need to change the drawable on every font draw
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.128 2013/05/19 23:16:29 okan Exp $
d580 3
a582 1
void
d587 1
d606 1
a606 1
	current_binding->button = strtonum(substring, 1, 3, &errstr);
d608 12
a619 1
		warnx("number of buttons is %s: %s", errstr, substring);
d626 1
a626 1
		return;
d636 1
a636 1
		return;
d638 2
a664 1
	u_int			 button;
d669 1
a669 16

		switch(mb->button) {
		case 1:
			button = Button1;
			break;
		case 2:
			button = Button2;
			break;
		case 3:
			button = Button3;
			break;
		default:
			warnx("strange button in mousebinding\n");
			continue;
		}
		xu_btn_grab(cc->win, mb->modmask, button);
@


1.128
log
@move the rest of xft init into screen_conf, since most of it is based on
config parameters.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.127 2013/05/19 23:09:59 okan Exp $
a105 5
	sc->xftdraw = XftDrawCreate(X_Dpy, sc->rootwin,
	    sc->visual, sc->colormap);
	if (sc->xftdraw == NULL)
		errx(1, "XftDrawCreate");

d132 10
@


1.127
log
@- switch border colors to Xft
- merge border/menu color structures/functions since they now both use Xft
- switch xu_xorcolor to operating on XftColor instead of just
  XRenderColor (basically adding pixel)
- if color name allocation fails, revert back to default (this, along
  with font validation should occur during config parse, but we don't
  have screens setup yet - likely to change at some point)
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.126 2013/05/11 21:46:27 okan Exp $
d106 8
a113 1
	font_init(sc, Conf.font);
@


1.126
log
@replace conf_{gap,color,font} with conf_screen since really we are
configuring the screen *after* parsing, just as we do a conf_client on
client manage.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.125 2013/05/10 16:32:48 okan Exp $
d87 5
a91 1
static char *menu_color_binds[CWM_COLOR_MENU_MAX] = {
a97 7
static char *color_binds[CWM_COLOR_BORDER_MAX] = {
	"#CCCCCC",	/* CWM_COLOR_BORDER_ACTIVE */
	"#666666",	/* CWM_COLOR_BORDER_INACTIVE */
	"blue",		/* CWM_COLOR_BORDER_GROUP */
	"red",		/* CWM_COLOR_BORDER_UNGROUP */
};

d101 2
a102 1
	int	 i;
d106 1
a106 1
	font_init(sc, Conf.font, (const char **)Conf.menucolor);
d108 22
a129 2
	for (i = 0; i < CWM_COLOR_BORDER_MAX; i++)
		sc->color[i] = xu_getcolor(sc, Conf.color[i]);
a230 3
	for (i = 0; i < nitems(menu_color_binds); i++)
		c->menucolor[i] = xstrdup(menu_color_binds[i]);

d278 1
a278 1
	for (i = 0; i < CWM_COLOR_BORDER_MAX; i++)
@


1.125
log
@more type fixes for mask/button
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.124 2013/05/10 16:05:34 okan Exp $
a86 12
void
conf_gap(struct conf *c, struct screen_ctx *sc)
{
	sc->gap = c->gap;
}

void
conf_font(struct conf *c, struct screen_ctx *sc)
{
	font_init(sc, c->font, (const char **)c->menucolor);
}

d102 1
a102 1
conf_color(struct conf *c, struct screen_ctx *sc)
d106 4
d111 1
a111 1
		sc->color[i] = xu_getcolor(sc, c->color[i]);
@


1.124
log
@int type fixes
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.123 2013/04/17 13:31:47 okan Exp $
d630 1
a630 1
	int			 button;
@


1.123
log
@zap extra space
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.122 2013/04/17 13:30:38 okan Exp $
d198 1
a198 1
	int	i;
d462 1
a462 1
	int			 i;
d567 1
a567 1
	int			 i;
@


1.122
log
@add conf_ignore and move group_make_autogroup to conf_autogroup to match.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.121 2013/01/08 15:16:05 okan Exp $
a41 1

@


1.121
log
@add per-group vert/horiz tiling support; introduces 2 new bind commands,
'vtile' and 'htile'; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.120 2013/01/04 16:27:58 okan Exp $
d53 33
@


1.120
log
@really these are just border colors, so adjust the define
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.119 2013/01/04 16:23:51 okan Exp $
d378 4
@


1.119
log
@spacing
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.118 2013/01/04 16:23:04 okan Exp $
d74 1
a74 1
static char *color_binds[CWM_COLOR_MAX] = {
d86 1
a86 1
	for (i = 0; i < CWM_COLOR_MAX; i++)
d239 1
a239 1
	for (i = 0; i < CWM_COLOR_MAX; i++)
@


1.118
log
@get rid of struct color
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.117 2013/01/01 14:33:52 okan Exp $
d68 4
a71 4
	"black", /* CWM_COLOR_MENU_FG */
	"white", /* CWM_COLOR_MENU_BG */
	"black", /* CWM_COLOR_MENU_FONT */
	"",  	 /* CWM_COLOR_MENU_FONT_SEL */
d75 4
a78 4
	"#CCCCCC", /* CWM_COLOR_BORDER_ACTIVE */
	"#666666", /* CWM_COLOR_BORDER_INACTIVE */
	"blue",	   /* CWM_COLOR_BORDER_GROUP */
	"red",	   /* CWM_COLOR_BORDER_UNGROUP */
@


1.117
log
@least intrusive way to plug a memleak when unbinding a duplicate key for
kbfunc_cmdexec; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.116 2012/12/19 15:21:34 okan Exp $
d74 5
a78 5
static struct color color_binds[CWM_COLOR_MAX] = {
	{ "#CCCCCC",	0 }, /* CWM_COLOR_BORDER_ACTIVE */
	{ "#666666",	0 }, /* CWM_COLOR_BORDER_INACTIVE */
	{ "blue",	0 }, /* CWM_COLOR_BORDER_GROUP */
	{ "red",	0 }, /* CWM_COLOR_BORDER_UNGROUP */
d87 1
a87 1
		sc->color[i].pixel = xu_getcolor(sc, c->color[i].name);
d187 1
a187 1
		c->color[i].name = xstrdup(color_binds[i].name);
d240 1
a240 1
		free(c->color[i].name);
@


1.116
log
@gc unused cmd 'flags' variable
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.115 2012/12/18 00:14:41 okan Exp $
d473 1
d480 1
d482 1
a482 1
	current_binding->flags = 0;
d501 2
@


1.115
log
@simplify config file setup; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.114 2012/12/17 23:54:57 okan Exp $
d39 1
a39 1
conf_cmd_add(struct conf *c, char *image, char *label, int flags)
a48 1
		cmd->flags = flags;
@


1.114
log
@put a default known_hosts into conf
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.113 2012/12/17 23:03:41 okan Exp $
d169 2
a170 1
	c->flags = 0;
a243 28
}

void
conf_setup(struct conf *c, const char *conf_file)
{
	char		 conf_path[MAXPATHLEN];
	struct stat	 sb;
	int		 parse = 0;

	conf_init(c);

	if (conf_file == NULL) {
		(void)snprintf(conf_path, sizeof(conf_path), "%s/%s",
		    homedir, CONFFILE);

		if (stat(conf_path, &sb) == 0 && (sb.st_mode & S_IFREG))
			parse = 1;
	} else {
		if (stat(conf_file, &sb) == -1 || !(sb.st_mode & S_IFREG))
			errx(1, "%s: %s", conf_file, strerror(errno));
		else {
			(void)strlcpy(conf_path, conf_file, sizeof(conf_path));
			parse = 1;
		}
	}

	if (parse && (parse_config(conf_path, c) == -1))
		warnx("config file %s has errors, not loading", conf_path);
@


1.113
log
@pull user home directory via getenv or getpwuid and stash it so we don't
need to do this everytime; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.112 2012/12/17 02:53:29 okan Exp $
d195 3
@


1.112
log
@knf
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.111 2012/12/17 02:28:45 okan Exp $
a245 1
	char		*home;
a251 3
		if ((home = getenv("HOME")) == NULL)
			errx(1, "No HOME directory.");

d253 1
a253 1
		    home, CONFFILE);
@


1.111
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.110 2012/11/28 14:14:44 okan Exp $
d65 1
a65 1
	font_init(sc, c->font, (const char**)c->menucolor);
d69 4
a72 4
	"black",  /* CWM_COLOR_MENU_FG */
	"white",  /* CWM_COLOR_MENU_BG */
	"black",  /* CWM_COLOR_MENU_FONT */
	"",  	  /* CWM_COLOR_MENU_FONT_SEL */
@


1.110
log
@replace hand rolled font_make() with XftFontOpenName() and merge into
font_init().
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.109 2012/11/14 21:31:53 okan Exp $
d65 1
a65 1
	font_init(sc, c->font, c->color[CWM_COLOR_FONT].name);
d68 8
a75 1
static struct color color_binds[] = {
a79 3
	{ "black",	0 }, /* CWM_COLOR_FG_MENU */
	{ "white",	0 }, /* CWM_COLOR_BG_MENU */
	{ "black",	0 }, /* CWM_COLOR_FONT */
d188 3
@


1.109
log
@variable name consistency; from Thomas Pfaff
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.108 2012/11/09 03:52:02 okan Exp $
d65 1
a65 2
	font_init(sc, c->color[CWM_COLOR_FONT].name);
	sc->font = font_make(sc, c->font);
@


1.108
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.107 2012/11/07 21:10:32 okan Exp $
d449 1
a449 1
	int			 iter;
d454 2
a455 2
		for (iter = 0; iter < nitems(bind_mods); iter++) {
			if ((tmp = strchr(name, bind_mods[iter].chr)) !=
d457 1
a457 2
				current_binding->modmask |=
				    bind_mods[iter].mask;
d489 2
a490 2
	for (iter = 0; iter < nitems(name_to_kbfunc); iter++) {
		if (strcmp(name_to_kbfunc[iter].tag, binding) != 0)
d493 3
a495 3
		current_binding->callback = name_to_kbfunc[iter].handler;
		current_binding->flags = name_to_kbfunc[iter].flags;
		current_binding->argument = name_to_kbfunc[iter].argument;
d550 1
a550 1
	int			 iter;
d555 2
a556 2
		for (iter = 0; iter < nitems(bind_mods); iter++) {
			if ((tmp = strchr(name, bind_mods[iter].chr)) !=
d558 1
a558 2
				current_binding->modmask |=
				    bind_mods[iter].mask;
d579 2
a580 2
	for (iter = 0; iter < nitems(name_to_mousefunc); iter++) {
		if (strcmp(name_to_mousefunc[iter].tag, binding) != 0)
d583 2
a584 2
		current_binding->context = name_to_mousefunc[iter].context;
		current_binding->callback = name_to_mousefunc[iter].handler;
@


1.107
log
@style nit; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.106 2012/11/07 21:04:55 okan Exp $
d27 1
a29 1
#include <stdio.h>
@


1.106
log
@add comment why we mouse unbind, just like kbd
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.105 2012/11/07 21:01:48 okan Exp $
d464 1
a464 1
	} else {
a465 1
	}
@


1.105
log
@now that we have FOREACH_SAFE queue macros, use them where appropriate;
from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.104 2012/11/07 20:37:55 okan Exp $
d574 1
@


1.104
log
@plug a leak when using 'unmap' for kbd/mouse bindings; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.103 2012/11/07 20:34:39 okan Exp $
d515 1
a515 4
	for (key = TAILQ_FIRST(&c->keybindingq);
	    key != TAILQ_END(&c->keybindingq); key = keynxt) {
		keynxt = TAILQ_NEXT(key, entry);

d597 1
a597 4
	for (mb = TAILQ_FIRST(&c->mousebindingq);
	    mb != TAILQ_END(&c->mousebindingq); mb = mbnxt) {
		mbnxt = TAILQ_NEXT(mb, entry);

@


1.103
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.102 2012/10/31 22:06:24 okan Exp $
d486 2
a487 1
	if (strcmp("unmap", binding) == 0)
d489 1
d579 2
a580 1
	if (strcmp("unmap", binding) == 0)
d582 1
@


1.102
log
@no longer a reason to carry conf_path in struct conf, so dice.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.101 2012/10/31 19:30:19 okan Exp $
d205 1
a205 1
		xfree(cmd);
d210 1
a210 1
		xfree(kb);
d215 3
a217 4
		xfree(ag->class);
		if (ag->name)
			xfree(ag->name);
		xfree(ag);
d222 1
a222 1
		xfree(wm);
d227 1
a227 1
		xfree(mb);
d231 1
a231 1
		xfree(c->color[i].name);
d233 1
a233 1
	xfree(c->font);
d479 1
a479 1
		xfree(current_binding);
d525 1
a525 1
			xfree(key);
d605 1
a605 1
			xfree(mb);
@


1.101
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.100 2012/10/29 19:46:03 okan Exp $
d240 1
d251 1
a251 1
		(void)snprintf(c->conf_path, sizeof(c->conf_path), "%s/%s",
d254 1
a254 1
		if (stat(c->conf_path, &sb) == 0 && (sb.st_mode & S_IFREG))
d260 1
a260 2
			(void)strlcpy(c->conf_path, conf_file,
			    sizeof(c->conf_path));
d265 2
a266 2
	if (parse && (parse_config(c->conf_path, c) == -1))
		warnx("config file %s has errors, not loading", c->conf_path);
@


1.100
log
@on reload, run each client through conf_client to pick up potential
ignore and bwidth changes; also add a hack for existing maximized
windows so they don't inherit a new bwidth.

based on a diff from, and discussion with, Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.99 2012/05/13 15:15:54 okan Exp $
d84 1
a84 2
	for (i = 0; i < CWM_COLOR_MAX; i++) {
		xu_freecolor(sc, sc->color[i].pixel);
a85 27
	}
}

void
conf_reload(struct conf *c)
{
	struct screen_ctx	*sc;
	struct client_ctx	*cc;

	if (parse_config(c->conf_path, c) == -1) {
		warnx("config file %s has errors, not reloading", c->conf_path);
		return;
	}

	TAILQ_FOREACH(sc, &Screenq, entry) {
		conf_gap(c, sc);
		conf_color(c, sc);
		conf_font(c, sc);
		menu_init(sc);
	}
	TAILQ_FOREACH(cc, &Clientq, entry) {
		conf_client(cc);
		/* XXX Does not take hmax/vmax into account. */
		if ((cc->flags & CLIENT_MAXFLAGS) == CLIENT_MAXIMIZED)
			cc->bwidth = 0;
		client_draw_border(cc);
	}
d123 1
a123 1
	{ "CMS-r",	"reload" },
d350 1
a350 1
	{ "reload", kbfunc_reload, 0, {0} },
@


1.99
log
@knf, some from a diff from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.98 2012/05/10 00:39:47 okan Exp $
d107 5
a111 1
	TAILQ_FOREACH(cc, &Clientq, entry)
d113 1
@


1.98
log
@wrap long lines; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.97 2011/09/13 09:17:30 okan Exp $
d645 1
a645 1
 			continue;
@


1.97
log
@fix spelling I keep getting wrong for some unknown reason; found by and
diff from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.96 2011/09/08 12:35:33 okan Exp $
d364 4
a367 2
	{ "cycleingroup", kbfunc_client_cycle, KBFLAG_NEEDCLIENT, {.i = CWM_CYCLE|CWM_INGROUP} },
	{ "rcycleingroup", kbfunc_client_cycle, KBFLAG_NEEDCLIENT, {.i = CWM_RCYCLE|CWM_INGROUP} },
@


1.96
log
@allow configurable menu font color; from Alexander Polakov with a tweak
from me.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.95 2011/09/08 12:00:49 okan Exp $
d70 4
a73 4
	{ "#CCCCCC",	0 }, /* CWM_COLOR_BORDOR_ACTIVE */
	{ "#666666",	0 }, /* CWM_COLOR_BORDOR_INACTIVE */
	{ "blue",	0 }, /* CWM_COLOR_BORDOR_GROUP */
	{ "red",	0 }, /* CWM_COLOR_BORDOR_UNGROUP */
@


1.95
log
@reinit menu on reload; from Alexander Polakov.  needed for catching
upcoming menu config changes.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.94 2011/09/03 09:25:39 okan Exp $
d65 1
d76 1
@


1.94
log
@simplify color initialization.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.93 2011/09/03 09:20:58 okan Exp $
d103 1
@


1.93
log
@Add {r,}cycleingroup to cycle through clients belonging to the same
group as the active client (as opposed to all unhidden clients); from
Alexander Polakov, with a tiny tweak requested by oga.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.92 2011/09/03 09:17:16 okan Exp $
d68 9
d203 3
a208 13

	c->color[CWM_COLOR_BORDER_ACTIVE].name =
	    xstrdup(CONF_COLOR_ACTIVEBORDER);
	c->color[CWM_COLOR_BORDER_INACTIVE].name =
	    xstrdup(CONF_COLOR_INACTIVEBORDER);
	c->color[CWM_COLOR_BORDER_GROUP].name =
	    xstrdup(CONF_COLOR_GROUPBORDER);
	c->color[CWM_COLOR_BORDER_UNGROUP].name =
	    xstrdup(CONF_COLOR_UNGROUPBORDER);
	c->color[CWM_COLOR_FG_MENU].name =
	    xstrdup(CONF_COLOR_MENUFG);
	c->color[CWM_COLOR_BG_MENU].name =
	    xstrdup(CONF_COLOR_MENUBG);
@


1.92
log
@"defaultfont" is unclear (and confusing while reading code) when it also
applies to the user supplied font, so rename.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.91 2011/08/29 09:10:49 okan Exp $
d362 2
@


1.91
log
@zap unused macro. ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.90 2011/08/22 16:18:05 okan Exp $
d65 1
a65 1
	sc->font = font_make(sc, c->DefaultFontName);
d211 1
a211 1
	c->DefaultFontName = xstrdup(DEFAULTFONTNAME);
d255 1
a255 1
	xfree(c->DefaultFontName);
@


1.90
log
@revert r1.11 of parse.y and create logic in conf_setup instead to deal
with the various scenarios of when to attempt a parse of the config,
load defaults, and when to warn and/or exit.  triggered by bogus warning
first noticed by sobrado@@.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.89 2011/07/26 08:51:24 okan Exp $
a32 7

#ifndef timespeccmp
#define timespeccmp(tsp, usp, cmp)			\
	(((tsp)->tv_sec == (usp)->tv_sec) ?		\
	    ((tsp)->tv_nsec cmp (usp)->tv_nsec) :	\
	    ((tsp)->tv_sec cmp (usp)->tv_sec))
#endif
@


1.89
log
@Re-draw borders after reloading, not before; from Alexander Polakov.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.88 2011/07/25 15:10:24 okan Exp $
d268 1
d270 3
d275 1
a275 3
		char *home = getenv("HOME");

		if (home == NULL)
d280 4
a283 1
	} else
d286 1
a286 1
		else
d289 3
d293 1
a293 3
	conf_init(c);

	if (parse_config(c->conf_path, c) == -1)
@


1.88
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.87 2011/07/14 11:39:53 okan Exp $
a96 2
	TAILQ_FOREACH(cc, &Clientq, entry)
		client_draw_border(cc);
d102 2
@


1.87
log
@correct spelling; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.86 2011/06/25 13:37:05 okan Exp $
d51 1
a51 1
		strlcpy(c->termpath, image, sizeof(c->termpath));
d53 1
a53 1
		strlcpy(c->lockpath, image, sizeof(c->lockpath));
d57 2
a58 2
		strlcpy(cmd->image, image, sizeof(cmd->image));
		strlcpy(cmd->label, label, sizeof(cmd->label));
d202 2
a203 2
	strlcpy(c->termpath, "xterm", sizeof(c->termpath));
	strlcpy(c->lockpath, "xlock", sizeof(c->lockpath));
d276 2
a277 2
		snprintf(c->conf_path, sizeof(c->conf_path), "%s/%s", home,
		    CONFFILE);
d282 2
a283 1
			strlcpy(c->conf_path, conf_file, sizeof(c->conf_path));
@


1.86
log
@warn if we can't parse the config file on start, just like we do on reload.

part of a larger diff that was ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.85 2011/06/24 06:09:26 okan Exp $
d205 1
a205 1
	c->color[CWM_COLOR_BORDOR_ACTIVE].name =
@


1.85
log
@New option to raise a client via the mouse (unbound by default);
opposing action, lower, already exists and bound.  Both keyboard
mappings already exist.

'no opinion either way' oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.84 2011/06/24 06:06:24 okan Exp $
d286 2
a287 1
	(void)parse_config(c->conf_path, c);
@


1.84
log
@introduce a new config option to snap to the screen edge.  'snapdist'
keyword taken from a diff from Sviatoslav Chagaev to do the same thing,
but implemented in a completely way (based on some very old code from
mk@@).  default set to 0, so no behavior change.

ok oga@@ (who would also like to take it further...)
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.83 2011/06/24 05:54:30 okan Exp $
d557 1
@


1.83
log
@more nitems usage.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.82 2011/06/24 05:45:57 okan Exp $
d187 1
@


1.82
log
@struct XftFont already has height which we can use directly instead of
calculating ourselves, so do so.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.81 2011/06/24 05:40:09 okan Exp $
a416 1
	{ NULL, NULL, 0, {0}},
d505 1
a505 1
	for (iter = 0; name_to_kbfunc[iter].tag != NULL; iter++) {
a559 1
	{ NULL, NULL, 0 },
d595 1
a595 1
	for (iter = 0; name_to_mousefunc[iter].tag != NULL; iter++) {
@


1.81
log
@alter a few function returns and prototypes; found by lint.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.80 2011/06/24 05:30:42 okan Exp $
a72 1
	sc->fontheight = font_ascent(sc) + font_descent(sc) + 1;
@


1.80
log
@collapse client and group {r,}cycle defines since they are really
the same thing.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.79 2011/05/11 13:53:51 okan Exp $
a523 1
	return;
@


1.79
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: conf.c,v 1.78 2011/05/07 17:15:37 okan Exp $
d359 2
a360 2
	{ "cyclegroup", kbfunc_client_cyclegroup, 0, {.i = CWM_CYCLEGROUP} },
	{ "rcyclegroup", kbfunc_client_cyclegroup, 0, {.i = CWM_RCYCLEGROUP} },
@


1.78
log
@introduce a new 'freeze' flag (CMS-f by default) which may be applied to
any window, after which all move/resize requests will be ignored,
essentially freezing the window in place.

there's a possibility to merge this with the 'ignore' concept, pending
on how ignore+freeze should behave (really more ewmh stuff), but punting
for now since ponies are on the line.

requested and tested by thib at k2k11 with ponies, unicorns and rainbows.

'save the unicorns' todd@@, ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.77 2011/03/22 10:57:31 okan Exp $
@


1.77
log
@introduce nitems macro, with the appropriate ifndef.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.76 2010/01/27 03:04:50 okan Exp $
d141 1
d365 1
@


1.76
log
@- allow per-screen gap; not (yet) user configurable.
- teach _NET_WORKAREA about gap.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.75 2009/12/15 04:10:42 okan Exp $
d194 1
a194 1
	for (i = 0; i < sizeof(kb_binds) / sizeof(kb_binds[0]); i++)
d197 1
a197 1
	for (i = 0; i < sizeof(m_binds) / sizeof(m_binds[0]); i++)
d470 1
a470 2
		for (iter = 0; iter < (sizeof(bind_mods) /
		    sizeof(bind_mods[0])); iter++) {
d575 1
a575 2
		for (iter = 0; iter < (sizeof(bind_mods) /
		    sizeof(bind_mods[0])); iter++) {
@


1.75
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.74 2009/12/15 03:24:36 okan Exp $
d64 6
d101 1
@


1.74
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.73 2009/12/11 17:51:42 oga Exp $
d20 11
@


1.73
log
@Implement _NET_DESKTOP_NAMES, this one was a bit tricky since thespec
says that a pager can change the property at any time (most need a
clientmessage). So deal with property updates.

Needed to shuffle some of the other code around since we can't just use
shortcut_to_name[] everywhere now.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.72 2009/12/08 16:52:17 okan Exp $
a20 1
#include "headers.h"
@


1.72
log
@start fixing screen_ctx usage, for it is utterly broken.  bring font
into screen_ctx and start passing screen_ctx around to in order get rid
of Curscreen; fixup per-screen config colors the same way.

diff mostly from oga@@, with a bit harsher reaction to the state of screen_ctx.

"please commit" oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.71 2009/12/07 19:42:59 okan Exp $
a227 1
		xfree(ag->group);
@


1.71
log
@remove unused extern

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.70 2009/08/25 12:05:11 okan Exp $
d54 1
a54 1
conf_font(struct conf *c)
d56 2
a57 6
	struct screen_ctx	*sc;

	sc = screen_current();

	c->DefaultFont = font_make(sc, c->DefaultFontName);
	c->FontHeight = font_ascent() + font_descent() + 1;
d61 1
a61 1
conf_color(struct conf *c)
d63 1
a63 4
	struct screen_ctx	*sc;
	int			 i;

	sc = screen_current();
d74 1
a81 1
	conf_color(c);
d84 4
a87 1
	conf_font(c);
@


1.70
log
@static; ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.69 2009/08/25 01:44:39 oga Exp $
a32 2

extern struct screen_ctx	*Curscreen;
@


1.69
log
@Reduce duplciation of code for checking modifiers in key/mouse bindings.
shaves a bunch of bytes.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.68 2009/08/25 01:42:05 oga Exp $
d96 1
a96 1
struct defbind {
d440 1
a440 1
struct {
@


1.68
log
@Instead of calling conf_bind*() 50 gazillion times in a row, store an
array with all the parameters in and just loop over that to setup the
default keybindings - it's so much easier to read.

okan@@ "love love love"ed this
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.67 2009/08/24 23:54:41 oga Exp $
d440 10
d454 1
a454 1
	char			*substring;
d459 9
a467 15
	if (strchr(name, 'C') != NULL &&
	    strchr(name, 'C') < strchr(name, '-'))
		current_binding->modmask |= ControlMask;

	if (strchr(name, 'M') != NULL &&
	    strchr(name, 'M') < strchr(name, '-'))
		current_binding->modmask |= Mod1Mask;

	if (strchr(name, '4') != NULL &&
	    strchr(name, '4') < strchr(name, '-'))
		current_binding->modmask |= Mod4Mask;

	if (strchr(name, 'S') != NULL &&
	    strchr(name, 'S') < strchr(name, '-'))
		current_binding->modmask |= ShiftMask;
d469 3
a471 4
	substring = strchr(name, '-') + 1;

	/* If there is no '-' in name, continue as is */
	if (strchr(name, '-') == NULL)
d473 1
d559 1
a559 1
	char			*substring;
d565 9
a573 3
	if (strchr(name, 'C') != NULL &&
	    strchr(name, 'C') < strchr(name, '-'))
		current_binding->modmask |= ControlMask;
d575 3
a577 15
	if (strchr(name, 'M') != NULL &&
	    strchr(name, 'M') < strchr(name, '-'))
		current_binding->modmask |= Mod1Mask;

	if (strchr(name, 'S') != NULL &&
	    strchr(name, 'S') < strchr(name, '-'))
		current_binding->modmask |= ShiftMask;

	if (strchr(name, '4') != NULL &&
	    strchr(name, '4') < strchr(name, '-'))
		current_binding->modmask |= Mod4Mask;

	substring = strchr(name, '-') + 1;

	if (strchr(name, '-') == NULL)
@


1.67
log
@Add a keybinding to allow horizontal maximisation of a window (CMS-enter).

based on a diff by Thomas Pfaff; thanks!

ok okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.66 2009/06/26 12:21:58 okan Exp $
d96 72
d171 2
d183 5
a187 68
	conf_bindname(c, "CM-Return", "terminal");
	conf_bindname(c, "CM-Delete", "lock");
	conf_bindname(c, "M-question", "exec");
	conf_bindname(c, "CM-w", "exec_wm");
	conf_bindname(c, "M-period", "ssh");
	conf_bindname(c, "M-Return", "hide");
	conf_bindname(c, "M-Down", "lower");
	conf_bindname(c, "M-Up", "raise");
	conf_bindname(c, "M-slash", "search");
	conf_bindname(c, "C-slash", "menusearch");
	conf_bindname(c, "M-Tab", "cycle");
	conf_bindname(c, "MS-Tab", "rcycle");
	conf_bindname(c, "CM-n", "label");
	conf_bindname(c, "CM-x", "delete");
	conf_bindname(c, "CM-0", "nogroup");
	conf_bindname(c, "CM-1", "group1");
	conf_bindname(c, "CM-2", "group2");
	conf_bindname(c, "CM-3", "group3");
	conf_bindname(c, "CM-4", "group4");
	conf_bindname(c, "CM-5", "group5");
	conf_bindname(c, "CM-6", "group6");
	conf_bindname(c, "CM-7", "group7");
	conf_bindname(c, "CM-8", "group8");
	conf_bindname(c, "CM-9", "group9");
	conf_bindname(c, "M-Right", "cyclegroup");
	conf_bindname(c, "M-Left", "rcyclegroup");
	conf_bindname(c, "CM-g", "grouptoggle");
	conf_bindname(c, "CM-f", "maximize");
	conf_bindname(c, "CM-equal", "vmaximize");
	conf_bindname(c, "CMS-equal", "hmaximize");
	conf_bindname(c, "CMS-r", "reload");
	conf_bindname(c, "CMS-q", "quit");

	conf_bindname(c, "M-h", "moveleft");
	conf_bindname(c, "M-j", "movedown");
	conf_bindname(c, "M-k", "moveup");
	conf_bindname(c, "M-l", "moveright");
	conf_bindname(c, "M-H", "bigmoveleft");
	conf_bindname(c, "M-J", "bigmovedown");
	conf_bindname(c, "M-K", "bigmoveup");
	conf_bindname(c, "M-L", "bigmoveright");

	conf_bindname(c, "CM-h", "resizeleft");
	conf_bindname(c, "CM-j", "resizedown");
	conf_bindname(c, "CM-k", "resizeup");
	conf_bindname(c, "CM-l", "resizeright");
	conf_bindname(c, "CM-H", "bigresizeleft");
	conf_bindname(c, "CM-J", "bigresizedown");
	conf_bindname(c, "CM-K", "bigresizeup");
	conf_bindname(c, "CM-L", "bigresizeright");

	conf_bindname(c, "C-Left", "ptrmoveleft");
	conf_bindname(c, "C-Down", "ptrmovedown");
	conf_bindname(c, "C-Up", "ptrmoveup");
	conf_bindname(c, "C-Right", "ptrmoveright");
	conf_bindname(c, "CS-Left", "bigptrmoveleft");
	conf_bindname(c, "CS-Down", "bigptrmovedown");
	conf_bindname(c, "CS-Up", "bigptrmoveup");
	conf_bindname(c, "CS-Right", "bigptrmoveright");

	conf_mousebind(c, "1", "menu_unhide");
	conf_mousebind(c, "2", "menu_group");
	conf_mousebind(c, "3", "menu_cmd");
	conf_mousebind(c, "M-1", "window_move");
	conf_mousebind(c, "CM-1", "window_grouptoggle");
	conf_mousebind(c, "M-2", "window_resize");
	conf_mousebind(c, "M-3", "window_lower");
	conf_mousebind(c, "CMS-3", "window_hide");
@


1.66
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.65 2009/06/20 00:22:39 okan Exp $
d138 1
d342 1
@


1.65
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.64 2009/06/20 00:19:56 okan Exp $
d31 3
d284 1
a284 1
struct {
d499 1
a499 1
void
d521 1
a521 1
struct {
d589 1
a589 1
void
@


1.64
log
@spacing
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.63 2009/05/30 00:30:27 okan Exp $
d44 1
a44 2
		struct cmd *cmd;
		XMALLOC(cmd, struct cmd);
d431 1
a431 1
	XCALLOC(current_binding, struct keybinding);
d543 1
a543 1
	XCALLOC(current_binding, struct mousebinding);
@


1.63
log
@'no' is the answer to the comment question: cc->name can't be NULL at
this point due to client_setname()'s work; remove this check.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.62 2009/05/17 23:54:17 okan Exp $
a71 1

a409 1

@


1.62
log
@redraw all borders at once on reload

"sure" oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.61 2009/05/17 23:40:57 okan Exp $
d272 4
a275 8
	/* Can wname be NULL? */
	if (wname != NULL) {
		TAILQ_FOREACH(wm, &Conf.ignoreq, entry) {
			if (strncasecmp(wm->title, wname, strlen(wm->title))
			    == 0) {
				ignore = 1;
				break;
			}
d277 1
a277 2
	} else
		ignore = 1;
@


1.61
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.60 2009/05/17 17:04:59 sthen Exp $
d82 2
d90 2
@


1.60
log
@add a "movetogroup" function, which hides the current window from
display and moves it to another group. useful with the recently added
"grouponly" function, giving the ability to use groups as simple
virtual desktops (similar to e.g. xmonad, dwm and scrotwm).

this doesn't have default keyboard bindings; cwmrc(5) now shows how
you could use these functions (use M-1...9 for grouponly1...9 and
MS-1...9 for movetogroup1...9 to emulate the default dwm bindings).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.59 2009/05/14 16:24:04 oga Exp $
d65 15
d87 1
d176 13
d200 1
d230 3
@


1.59
log
@Add a new command (currently no default keybindings for it), grouponly[1-9].

This works like the group select binding, but hides all other groups.

So, the people who've been complaining that they don't get "virtual
desktops" in cwm may want to try this out in cwmrc (from memory, untested):

---

#cwmrc

# add new windows to the current group
set sticky

# automatically sticky windows. xclock for now.
# to make more windows sticky use group_toggle to unset their group
autogroup 0 xclock

# make the group selection keys hide other groups, emulate virtual desktops
bind CM-1 grouponly1
bind CM-2 grouponly2
bind CM-3 grouponly3
bind CM-4 grouponly4
bind CM-5 grouponly5
bind CM-6 grouponly6
bind CM-7 grouponly7
bind CM-8 grouponly8
bind CM-9 grouponly9

---

mostly by sthen, tweaks from me.

ok todd@@, "if it works i'm ok with it" okan@@, ok sthen@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.58 2009/05/04 19:13:33 okan Exp $
d284 18
@


1.58
log
@no need to use the global here.

ok todd@@ oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.57 2009/02/07 21:07:00 martynas Exp $
d275 9
@


1.57
log
@add 'moveamount' to cwmrc;  it sets keyboard movement amount, making
it more useful on large screens
manpage tweak & ok jmc@@
ok okan@@, oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.56 2009/01/23 20:47:45 okan Exp $
d60 1
a60 1
	c->DefaultFont = font_make(sc, Conf.DefaultFontName);
@


1.56
log
@passing a null pointer to free() is valid; sprinkle a few free->xfree.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.55 2009/01/23 19:00:59 okan Exp $
d80 1
@


1.55
log
@move conf_clear() and add proto.

ok todd@@ oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.54 2009/01/23 18:58:40 oga Exp $
d173 1
a173 1
		free(cmd);
d178 1
a178 1
		free(kb);
d183 1
a183 1
		free(ag->class);
d185 3
a187 3
			free(ag->name);
		free(ag->group);
		free(ag);
d192 1
a192 1
		free(wm);
d197 1
a197 1
		free(mb);
d200 1
a200 2
	if (c->DefaultFontName != NULL)
		free(c->DefaultFontName);
@


1.54
log
@Move the keybinding argument to a union to prevent warnings where
sizeof(int) != sizeof(void *). This has been annoying me for ages.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.53 2009/01/21 15:04:38 todd Exp $
d160 42
@


1.53
log
@borderwidth as a cwmrc(5) keyword, really helps debugging
from okan@@
ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.52 2009/01/16 15:24:14 okan Exp $
d210 4
a213 4
	char *tag;
	void (*handler)(struct client_ctx *, void *);
	int flags;
	void *argument;
d215 31
a245 31
	{ "lower", kbfunc_client_lower, KBFLAG_NEEDCLIENT, 0 },
	{ "raise", kbfunc_client_raise, KBFLAG_NEEDCLIENT, 0 },
	{ "search", kbfunc_client_search, 0, 0 },
	{ "menusearch", kbfunc_menu_search, 0, 0 },
	{ "hide", kbfunc_client_hide, KBFLAG_NEEDCLIENT, 0 },
	{ "cycle", kbfunc_client_cycle, 0, (void *)CWM_CYCLE },
	{ "rcycle", kbfunc_client_cycle, 0, (void *)CWM_RCYCLE },
	{ "label", kbfunc_client_label, KBFLAG_NEEDCLIENT, 0 },
	{ "delete", kbfunc_client_delete, KBFLAG_NEEDCLIENT, 0 },
	{ "group1", kbfunc_client_group, 0, (void *)1 },
	{ "group2", kbfunc_client_group, 0, (void *)2 },
	{ "group3", kbfunc_client_group, 0, (void *)3 },
	{ "group4", kbfunc_client_group, 0, (void *)4 },
	{ "group5", kbfunc_client_group, 0, (void *)5 },
	{ "group6", kbfunc_client_group, 0, (void *)6 },
	{ "group7", kbfunc_client_group, 0, (void *)7 },
	{ "group8", kbfunc_client_group, 0, (void *)8 },
	{ "group9", kbfunc_client_group, 0, (void *)9 },
	{ "nogroup", kbfunc_client_nogroup, 0, 0 },
	{ "cyclegroup", kbfunc_client_cyclegroup, 0, (void *)CWM_CYCLEGROUP },
	{ "rcyclegroup", kbfunc_client_cyclegroup, 0, (void *)CWM_RCYCLEGROUP },
	{ "grouptoggle", kbfunc_client_grouptoggle, KBFLAG_NEEDCLIENT, 0},
	{ "maximize", kbfunc_client_maximize, KBFLAG_NEEDCLIENT, 0 },
	{ "vmaximize", kbfunc_client_vmaximize, KBFLAG_NEEDCLIENT, 0 },
	{ "reload", kbfunc_reload, 0, 0 },
	{ "quit", kbfunc_quit_wm, 0, 0 },
	{ "exec", kbfunc_exec, 0, (void *)CWM_EXEC_PROGRAM },
	{ "exec_wm", kbfunc_exec, 0, (void *)CWM_EXEC_WM },
	{ "ssh", kbfunc_ssh, 0, 0 },
	{ "terminal", kbfunc_term, 0, 0 },
	{ "lock", kbfunc_lock, 0, 0 },
d247 1
a247 1
	    (void *)(CWM_UP|CWM_MOVE) },
d249 1
a249 1
	    (void *)(CWM_DOWN|CWM_MOVE) },
d251 1
a251 1
	    (void *)(CWM_RIGHT|CWM_MOVE) },
d253 1
a253 1
	    (void *)(CWM_LEFT|CWM_MOVE) },
d255 1
a255 1
	    (void *)(CWM_UP|CWM_MOVE|CWM_BIGMOVE) },
d257 1
a257 1
	    (void *)(CWM_DOWN|CWM_MOVE|CWM_BIGMOVE) },
d259 1
a259 1
	    (void *)(CWM_RIGHT|CWM_MOVE|CWM_BIGMOVE) },
d261 1
a261 1
	    (void *)(CWM_LEFT|CWM_MOVE|CWM_BIGMOVE) },
d263 1
a263 1
	    (void *)(CWM_UP|CWM_RESIZE) },
d265 1
a265 1
	    (void *)(CWM_DOWN|CWM_RESIZE) },
d267 1
a267 1
	    (void *)(CWM_RIGHT|CWM_RESIZE) },
d269 1
a269 1
	    (void *)(CWM_LEFT|CWM_RESIZE) },
d271 1
a271 1
	    (void *)(CWM_UP|CWM_RESIZE|CWM_BIGMOVE) },
d273 1
a273 1
	    (void *)(CWM_DOWN|CWM_RESIZE|CWM_BIGMOVE) },
d275 1
a275 1
	    (void *)(CWM_RIGHT|CWM_RESIZE|CWM_BIGMOVE) },
d277 4
a280 4
	    (void *)(CWM_LEFT|CWM_RESIZE|CWM_BIGMOVE) },
	{ "ptrmoveup", kbfunc_moveresize, 0, (void *)(CWM_UP|CWM_PTRMOVE) },
	{ "ptrmovedown", kbfunc_moveresize, 0, (void *)(CWM_DOWN|CWM_PTRMOVE) },
	{ "ptrmoveleft", kbfunc_moveresize, 0, (void *)(CWM_LEFT|CWM_PTRMOVE) },
d282 1
a282 1
	    (void *)(CWM_RIGHT|CWM_PTRMOVE) },
d284 1
a284 1
	    (void *)(CWM_UP|CWM_PTRMOVE|CWM_BIGMOVE) },
d286 1
a286 1
	    (void *)(CWM_DOWN|CWM_PTRMOVE|CWM_BIGMOVE) },
d288 1
a288 1
	    (void *)(CWM_LEFT|CWM_PTRMOVE|CWM_BIGMOVE) },
d290 2
a291 2
	    (void *)(CWM_RIGHT|CWM_PTRMOVE|CWM_BIGMOVE) },
	{ NULL, NULL, 0, 0},
d391 1
a391 1
	current_binding->argument = xstrdup(binding);
@


1.52
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.51 2009/01/08 21:35:19 oga Exp $
d79 1
d205 1
a205 1
	cc->bwidth = ignore ? 0 : CLIENT_BWIDTH;
@


1.51
log
@If the mousebutton is unknown when we go to grab, don't just print a
warning, but also skip the XGrabButton call. Noticed by code inspection
by okan@@, but we agreed my fix was cleaner.

ok okan.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.50 2008/07/22 20:51:54 oga Exp $
d204 1
a204 1
	cc->bwidth = ignore ? 0 : 3;
d533 1
a533 1
		xu_btn_grab(cc->pwin, mb->modmask, button);
@


1.50
log
@We've been handling grabbing wrong all this time (noticed at c2k8).

add conf_grab() and conf_ungrab, and use them in the keybinding manipulation
functions to {,un}grab the binding for all screens we have defined.

the lovely little ordering problem comes in here, since when we parse
the config initially Screenq is empty, so regrab after we fill the
queue, hopefully later reordering will remove this little need and there
will be much rejoicing.

ok okan.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.49 2008/07/11 15:18:29 okan Exp $
d531 1
@


1.49
log
@no more hidden (and mysterious) config reloads and allow binding a key
to a config reload; CMS-r by default.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.48 2008/07/11 14:24:34 okan Exp $
d293 32
d384 1
d392 1
d397 2
a398 1
void conf_unbind(struct conf *c, struct keybinding *unbind)
d412 1
@


1.48
log
@replace snprintf with strlcpy

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.47 2008/07/11 14:21:28 okan Exp $
a63 17
int
conf_changed(char *path)
{
	static struct timespec	 old_ts;
	struct stat 		 sb;
	int 			 changed;

	/* If the file does not exist we pretend that nothing changed */
	if (stat(path, &sb) == -1 || !(sb.st_mode & S_IFREG))
		return (0);

	changed = !timespeccmp(&sb.st_mtimespec, &old_ts, ==);
	old_ts = sb.st_mtimespec;

	return (changed);
}

a66 3
	if (!conf_changed(c->conf_path))
		return;

d115 1
d238 1
@


1.47
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.46 2008/06/25 22:44:42 oga Exp $
d197 1
a197 2
			snprintf(c->conf_path, sizeof(c->conf_path), "%s",
			    conf_file);
@


1.46
log
@Allow a mouse binding to hide a window, and add a default keybinding for CMS-M3,
so it's hard to press by accident, but there if you need it.

requested (in a way) and tested by johan and todd.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.45 2008/06/25 22:40:27 oga Exp $
d56 3
a58 1
	struct screen_ctx *sc = screen_current();
d67 3
a69 3
	static struct timespec old_ts;
	struct stat sb;
	int changed;
d183 1
a183 1
	struct stat sb;
d315 3
a317 3
	int iter;
	struct keybinding *current_binding;
	char *substring;
d361 1
a361 1
	if (strcmp("unmap",binding) == 0)
d384 1
a384 1
	struct keybinding *key = NULL, *keynxt;
d422 4
a425 4
	int iter;
	struct mousebinding *current_binding;
	char *substring;
	const char *errstr;
d473 1
a473 1
	struct mousebinding *mb = NULL, *mbnxt;
a496 1
	
@


1.45
log
@Support mod4 (windows key) in mouse bindings too.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.44 2008/06/25 22:38:36 oga Exp $
d169 1
d410 1
@


1.44
log
@Support shift in mouse bindings. There's really no reason not to.

tested by johan@@ and todd@@.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.43 2008/06/25 22:37:29 oga Exp $
d436 4
@


1.43
log
@Actually grab the correct mouse buttons for a window, instead of doing the
old hardcoded ones (which now can be wrong).

tested by todd@@ and johan@@.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.42 2008/06/17 23:40:33 oga Exp $
d432 4
@


1.42
log
@Ignore caps lock and numlock for keyboard bindings. The way Xlib makes
you do this is ugly. Also remove mod2 (numlock) and mod3 (odd) from the
list of keybinding modifiers. They don't make much sense here.

based on a heavily modified diff from Martynas.

ok okan.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.41 2008/06/16 19:09:48 mk Exp $
d477 30
@


1.41
log
@Make this not crash when compiled with -g.

Found by myself, analysis by kurt@@, fix by me with input from otto.

``Just get some fix in...'' deraadt
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.40 2008/06/15 02:47:46 oga Exp $
a324 8

	if (strchr(name, '2') != NULL &&
	    strchr(name, '2') < strchr(name, '-'))
		current_binding->modmask |= Mod2Mask;

	if (strchr(name, '3') != NULL &&
	    strchr(name, '3') < strchr(name, '-'))
		current_binding->modmask |= Mod3Mask;
@


1.40
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.39 2008/06/14 21:59:09 okan Exp $
d174 1
a174 1
	c->DefaultFontName = DEFAULTFONTNAME;
@


1.39
log
@unbreak
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.38 2008/06/14 21:51:00 okan Exp $
d53 9
d90 1
a90 1
	DefaultFont = font_getx(Curscreen, c->DefaultFontName);
@


1.38
log
@slightly alter the semantics of config files:
 - if no config file, continue silently and apply defaults
 - if config file, parse and move on
 - if config file specified but not found, error out

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.37 2008/06/14 21:48:54 okan Exp $
d437 1
a437 1
	current_binding->button = strtonum(substring);
@


1.37
log
@confable menu and window mouse bindings from rivo nurges (thanks!) with
some minor fixups, man page bits and knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.36 2008/06/05 00:07:05 okan Exp $
d171 2
d182 5
a186 1
		snprintf(c->conf_path, sizeof(c->conf_path), "%s", conf_file);
@


1.36
log
@actually honor termpath and lockpath if specified in cwmrc.

"now" oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.35 2008/05/19 18:53:09 oga Exp $
d93 1
d153 8
d391 79
@


1.35
log
@General cleanup.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.34 2008/05/19 17:11:19 okan Exp $
d39 5
a43 5
	if (strcmp(label, "term") == 0) {
		strlcpy(Conf.termpath, image, sizeof(Conf.termpath));
	} else if (strcmp(label, "lock") == 0) {
		strlcpy(Conf.lockpath, image, sizeof(Conf.lockpath));
	} else {
@


1.34
log
@as done with cycle/rcycle, make prev/next group switching one kbfuncs
and use a flag; adjusted to match and rename to {r,}cycle.

"ok, since i came up with the same thing" oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.33 2008/05/19 15:17:50 oga Exp $
d160 1
a160 1
conf_setup(struct conf *c, const char *conffile)
d162 1
a162 1
	if (conffile == NULL) {
d171 1
a171 1
		snprintf(c->conf_path, sizeof(c->conf_path), "%s", conffile);
@


1.33
log
@Use the XGrabKeyboard hack in for alt-tabbing as well. This stops the
mru getting the order messed up when gvim/xpdf et all steal key events.

While i'm here, change the logic in client_cyclenext() to use break instead
of goto, it's nicer that way.

Thirdly, instead of two different kbfuncs, just use the one and a flag.

"put your cycle diff in so I can pkg_delete gvim" okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.32 2008/05/19 12:56:58 okan Exp $
d118 2
a119 2
	conf_bindname(c, "M-Right", "nextgroup");
	conf_bindname(c, "M-Left", "prevgroup");
d226 2
a227 2
	{ "nextgroup", kbfunc_client_nextgroup, 0, 0 },
	{ "prevgroup", kbfunc_client_prevgroup, 0, 0 },
@


1.32
log
@finally implement keyboard binding for group toggling

idea for the
    "slightly-less-abhorrent-hack-but-a-hack-nonetheless-TM" from oga@@

grab and ungrab the keyboard to get around some silly X apps that like
stealing events

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.31 2008/05/18 19:47:19 oga Exp $
d212 2
a213 2
	{ "cycle", kbfunc_client_cycle, 0, 0 },
	{ "rcycle", kbfunc_client_rcycle, 0, 0 },
@


1.31
log
@Fix two problems with conf_unbind():

1) it used TAILQ_FOREACH() when it's removing entrys from the list, this
   is bad.
2) We didn't free key, so there was a small memleak too.

also rework conf_bindname's logic slightly to be more simple.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.30 2008/05/18 19:43:50 oga Exp $
d120 1
d228 1
@


1.30
log
@Kill conf_get_int(), it was a silly function anyway.

Since it's only used once just put the (simplified) logic into
conf_client() instead. This  means we can kill an enum and
CONF_IGNORECASE, too.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.29 2008/05/15 22:18:00 oga Exp $
d351 1
a351 1
		break;
a353 3
	if (name_to_kbfunc[iter].tag != NULL)
		return;

d363 5
a367 1
	struct keybinding *key = NULL;
a368 1
	TAILQ_FOREACH(key, &c->keybindingq, entry) {
d374 1
a374 1
		    key->keysym == unbind->keysym)
d376 2
@


1.29
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.28 2008/04/16 13:47:29 oga Exp $
d177 2
a178 2
int
conf_get_int(struct client_ctx *cc, enum conftype ctype)
d180 3
a182 5
	int val = -1, ignore = 0;
	char *wname;
	struct winmatch *wm;

	wname = cc->name;
a184 1

d187 2
a188 3
			int (*cmpfun)(const char *, const char *, size_t) =
			    wm->opts & CONF_IGNORECASE ? strncasecmp : strncmp;
			if ((*cmpfun)(wm->title, wname, strlen(wm->title)) == 0) {
a192 1

d196 2
a197 23
	switch (ctype) {
	case CONF_BWIDTH:
		/*
		 * XXX this will be a list, specified in the
		 * configuration file.
		 */
		val = ignore ? 0 : 3;
		break;
	case CONF_IGNORE:
		val = ignore;
		break;
	default:
		break;
	}

	return (val);
}

void
conf_client(struct client_ctx *cc)
{
	cc->bwidth = conf_get_int(cc, CONF_BWIDTH);
	cc->flags |= conf_get_int(cc, CONF_IGNORE) ? CLIENT_IGNORE : 0;
@


1.28
log
@merge kbfunc_{ptrmove,client_{move,resize}} into one function that takes a flag,
this code was almost identical...

ok okan.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.27 2008/04/16 13:38:09 oga Exp $
d399 2
a400 2
			key->keycode == unbind->keycode) ||
			key->keysym == unbind->keysym)
@


1.27
log
@Replace a few leftover calls to strdup and calloc with xstrdup and xcalloc
respectively.

ok okan.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.26 2008/04/15 20:24:41 oga Exp $
a240 8
	{ "ptrmoveup", kbfunc_ptrmove, 0, (void *)CWM_UP },
	{ "ptrmovedown", kbfunc_ptrmove, 0, (void *)CWM_DOWN },
	{ "ptrmoveleft", kbfunc_ptrmove, 0, (void *)CWM_LEFT },
	{ "ptrmoveright", kbfunc_ptrmove, 0, (void *)CWM_RIGHT },
	{ "bigptrmoveup", kbfunc_ptrmove, 0, (void *)(CWM_UP|CWM_BIGMOVE) },
	{ "bigptrmovedown", kbfunc_ptrmove, 0, (void *)(CWM_DOWN|CWM_BIGMOVE) },
	{ "bigptrmoveleft", kbfunc_ptrmove, 0, (void *)(CWM_LEFT|CWM_BIGMOVE) },
	{ "bigptrmoveright", kbfunc_ptrmove, 0, (void *)(CWM_RIGHT|CWM_BIGMOVE) },
d261 45
a305 16
	{ "moveup", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)CWM_UP },
	{ "movedown", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)CWM_DOWN },
	{ "moveright", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)CWM_RIGHT },
	{ "moveleft", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)CWM_LEFT },
	{ "bigmoveup", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)(CWM_UP|CWM_BIGMOVE) },
	{ "bigmovedown", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)(CWM_DOWN|CWM_BIGMOVE) },
	{ "bigmoveright", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)(CWM_RIGHT|CWM_BIGMOVE) },
	{ "bigmoveleft", kbfunc_client_move, KBFLAG_NEEDCLIENT, (void *)(CWM_LEFT|CWM_BIGMOVE) },
	{ "resizeup", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)(CWM_UP) },
	{ "resizedown", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)CWM_DOWN },
	{ "resizeright", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)CWM_RIGHT },
	{ "resizeleft", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)CWM_LEFT },
	{ "bigresizeup", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)(CWM_UP|CWM_BIGMOVE) },
	{ "bigresizedown", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)(CWM_DOWN|CWM_BIGMOVE) },
	{ "bigresizeright", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)(CWM_RIGHT|CWM_BIGMOVE) },
	{ "bigresizeleft", kbfunc_client_resize, KBFLAG_NEEDCLIENT, (void *)(CWM_LEFT|CWM_BIGMOVE) },
@


1.26
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.25 2008/04/08 14:12:28 okan Exp $
d363 1
a363 1
	current_binding->argument = strdup(binding);
@


1.25
log
@better 'quit' keybinding default (CMS-q)

feedback from oga@@ and simon@@

ok oga@@ simon@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.24 2008/04/07 23:47:09 simon Exp $
d26 3
a28 3
        (((tsp)->tv_sec == (usp)->tv_sec) ?		\
            ((tsp)->tv_nsec cmp (usp)->tv_nsec) :	\
            ((tsp)->tv_sec cmp (usp)->tv_sec))
d91 1
a91 1
        TAILQ_INIT(&c->keybindingq);
d169 1
a169 2
	}
	else
d197 1
a197 1
		
d302 1
a302 1
	    strchr(name, 'M') < strchr(name, '-')) 
d306 1
a306 1
	    strchr(name, '2') < strchr(name, '-')) 
d310 1
a310 1
	    strchr(name, '3') < strchr(name, '-')) 
d314 1
a314 1
	    strchr(name, '4') < strchr(name, '-')) 
d318 1
a318 1
	    strchr(name, 'S') < strchr(name, '-')) 
d337 1
a337 1
	    current_binding->keycode == 0 ) {
d343 1
a343 1
	conf_unbind(c, current_binding);	
d378 1
a378 1
			key->keycode == unbind->keycode) || 
@


1.24
log
@Add quit function, bind it per default to CM-q and change exec_wm
binding to CM-w.

Inital diff from Gleydson Soares
Feedback from oga@@ and okan@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.23 2008/03/23 15:09:21 simon Exp $
d122 1
a122 1
	conf_bindname(c, "CM-q", "quit");
@


1.23
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.22 2008/03/22 15:09:45 oga Exp $
d97 1
a97 1
	conf_bindname(c, "CM-q", "exec_wm");
d122 1
d264 1
@


1.22
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.21 2008/03/18 00:48:56 oga Exp $
d31 1
a31 52
#define CONF_MAX_WINTITLE 256
#define CONF_IGNORECASE   0x01


/*
 * Match a window.
 */
struct winmatch {
	TAILQ_ENTRY(winmatch) entry;

	char title[CONF_MAX_WINTITLE];
	int  opts;
};

TAILQ_HEAD(winmatch_q, winmatch);
struct winmatch_q ignoreq;

/* XXX - until we get a real configuration parser. */
#define WINMATCH_ADD(queue, str) do {			\
	struct winmatch *wm;				\
	XCALLOC(wm, struct winmatch);		\
	strlcpy(wm->title, str, sizeof(wm->title));	\
	wm->opts |= CONF_IGNORECASE;			\
	TAILQ_INSERT_TAIL(queue, wm, entry);		\
} while (0)

/* Initializes the command menu */

void
conf_cmd_init(struct conf *c)
{
	TAILQ_INIT(&c->cmdq);
}

/* Removes all static entries */

void
conf_cmd_clear(struct conf *c)
{
	struct cmd *cmd, *next;

	for (cmd = TAILQ_FIRST(&c->cmdq); cmd != NULL; cmd = next) {
		next = TAILQ_NEXT(cmd, entry);

		/* Do not remove static entries */
		if (cmd->flags & CMD_STATIC)
			continue;

		TAILQ_REMOVE(&c->cmdq, cmd, entry);
		free(cmd);
	}
}
d54 1
a54 1
conf_cmd_changed(char *path)
a55 1
#ifdef __OpenBSD__
a56 3
#else
	static time_t old_time;
#endif
d60 2
a61 2
	/* If the directory does not exist we pretend that nothing changed */
	if (stat(path, &sb) == -1 || !(sb.st_mode & S_IFDIR))
a63 1
#ifdef __OpenBSD__
a65 4
#else
	changed = old_time != sb.st_mtime;
	old_time = sb.st_mtime;
#endif
d71 1
a71 1
conf_cmd_populate(struct conf *c, char *path)
d73 2
a74 18
	DIR *dir;
	struct dirent *file;
	char fullname[PATH_MAX];
	int off;

	if (strlen(path) >= sizeof (fullname) - 2)
		errx(1, "directory name too long");

	dir = opendir(path);
	if (dir == NULL)
		err(1, "opendir");

	strlcpy(fullname, path, sizeof (fullname));
	off = strlen(fullname);
	if (fullname[off - 1] != '/') {
		strlcat(fullname, "/", sizeof(fullname));
		off++;
	}
d76 3
a78 9
	while ((file = readdir(dir)) != NULL) {
		char *filename = file->d_name;
                if (filename[0] == '.')
			continue;

		strlcpy(fullname + off, filename, sizeof(fullname) - off);

		/* Add a dynamic entry to the command menu */
		conf_cmd_add(c, fullname, filename, 0);
d81 1
a81 2
	closedir(dir);

d85 1
a85 1
conf_cmd_refresh(struct conf *c)
d87 1
a87 21
	if (!conf_cmd_changed(c->menu_path))
		return;

	conf_cmd_clear(c);
	conf_cmd_populate(c, c->menu_path);
}

void
conf_setup(struct conf *c)
{
 	char dir_keydefs[MAXPATHLEN];
 	char dir_settings[MAXPATHLEN];
 	char dir_ignored[MAXPATHLEN];
	char dir_autogroup[MAXPATHLEN];
	char *home = getenv("HOME");

	if (home == NULL)
		errx(1, "No HOME directory.");
	snprintf(c->menu_path, sizeof(c->menu_path), "%s/.calmwm", home);

	conf_cmd_init(c);
d89 2
d92 1
d150 12
a161 20
        snprintf(dir_keydefs, sizeof(dir_keydefs), "%s/.calmwm/.keys", home);
        if (dirent_isdir(dir_keydefs))
                conf_parsekeys(c, dir_keydefs);

 	snprintf(dir_settings, sizeof(dir_settings),
	    "%s/.calmwm/.settings", home);
 	if (dirent_isdir(dir_settings))
 		conf_parsesettings(c, dir_settings);

	TAILQ_INIT(&ignoreq);

	snprintf(dir_ignored, sizeof(dir_ignored), "%s/.calmwm/.ignore", home);
	if (dirent_isdir(dir_ignored))
		conf_parseignores(c, dir_ignored);
	else {
		WINMATCH_ADD(&ignoreq, "XMMS");
		WINMATCH_ADD(&ignoreq, "xwi");
		WINMATCH_ADD(&ignoreq, "xapm");
		WINMATCH_ADD(&ignoreq, "xclock");
	}
d163 2
a164 1
	TAILQ_INIT(&c->autogroupq);
d166 5
a170 4
	snprintf(dir_autogroup, sizeof(dir_autogroup),
	    "%s/.calmwm/.autogroup", home);
	if (dirent_isdir(dir_autogroup))
		conf_parseautogroups(c, dir_autogroup);
d172 1
a172 1
	c->flags = 0;
d174 1
a174 3
	/* Default term/lock */
	strlcpy(Conf.termpath, "xterm", sizeof(Conf.termpath));
	strlcpy(Conf.lockpath, "xlock", sizeof(Conf.lockpath));
d189 1
a189 1
		TAILQ_FOREACH(wm, &ignoreq, entry) {
a287 31
conf_parsekeys(struct conf *c, char *filename)
{
	DIR *dir;
	struct dirent *ent;
	char buffer[MAXPATHLEN];
	char current_file[MAXPATHLEN];

	dir = opendir(filename);
	while ((ent = readdir(dir)) != NULL) {
		if (ent->d_name[0] == '.')
			continue;

		snprintf(current_file, sizeof(current_file),
		    "%s/%s", filename, ent->d_name);
		if (strchr(ent->d_name, '-') == NULL && ent->d_name[0] != '[')
			continue;
		if (!dirent_islink(current_file))
			continue;


		memset(buffer, 0, MAXPATHLEN);
		if (readlink(current_file, buffer, MAXPATHLEN) < 0)
			continue;

		conf_bindname(c, ent->d_name, buffer);
	}

	closedir(dir);
}

void
a380 76
}

void
conf_parsesettings(struct conf *c, char *filename)
{
	DIR *dir;
	struct dirent *ent;

	dir = opendir(filename);
	while ((ent = readdir(dir)) != NULL) {
		if (ent->d_name[0] == '.')
			continue;
		if (strncmp(ent->d_name, "sticky", 7)==0)
			Conf.flags |= CONF_STICKY_GROUPS;
	}
	closedir(dir);
}

void
conf_parseignores(struct conf *c, char *filename)
{
	DIR *dir;
	struct dirent *ent;

	dir = opendir(filename);
	while ((ent = readdir(dir)) != NULL) {
		if (ent->d_name[0] == '.')
			continue;
		WINMATCH_ADD(&ignoreq, ent->d_name);
	}

	closedir(dir);
}

void
conf_parseautogroups(struct conf *c, char *filename)
{
	DIR *dir;
	struct dirent *ent;
	struct autogroupwin *aw;
	char current_file[MAXPATHLEN], *p;
	char group[CALMWM_MAXNAMELEN];
	int len;

	dir = opendir(filename);
	while ((ent = readdir(dir)) != NULL) {
		if (ent->d_name[0] == '.')
			continue;

		snprintf(current_file, sizeof(current_file),
		    "%s/%s", filename, ent->d_name);
		if (!dirent_islink(current_file))
			continue;

		if ((len = readlink(current_file,
			    group, sizeof(group) - 1)) < 0)
			continue;
		group[len] = '\0';

		XCALLOC(aw, struct autogroupwin);
		
		if ((p = strchr(ent->d_name, ',')) == NULL) {
			aw->name = NULL;
			aw->class = xstrdup(ent->d_name);
		} else {
			*(p++) = '\0';
			aw->name = xstrdup(ent->d_name);
			aw->class = xstrdup(p);
		}
		aw->group = xstrdup(group);

		TAILQ_INSERT_TAIL(&c->autogroupq, aw, entry);
	}

	closedir(dir);

@


1.21
log
@client_{,r}cycle() doens't need a client. so get rid of KBFUNC_NEEDSCLIENT.

this prevents the issue where you close or hide a window, and end up
with no client selected (you're on the root window). When that happened
alt-tab failed.  This, however, exposed to me a few more issues in the
alt-tabbing code:

-the code to detect how many lines we need looks bogus (you always get
three)

-alt-tabbing when everything is hidden always reawakes the most recent
window.

Fixes for these will be forthcoming.

ok simon@@.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.20 2008/01/16 11:39:20 oga Exp $
a56 2
/* #define SYSTR_PRE "systrace -C -g /usr/local/bin/notification -d /usr/home/marius/policy/X11 " */

a207 1
	conf_bindname(c, "CM-Escape", "groupselect");
a356 1
	{ "groupselect", kbfunc_client_groupselect, 0, 0 },
@


1.20
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.19 2008/01/11 16:06:44 oga Exp $
d348 2
a349 2
	{ "cycle", kbfunc_client_cycle, KBFLAG_NEEDCLIENT, 0 },
	{ "rcycle", kbfunc_client_rcycle, KBFLAG_NEEDCLIENT, 0 },
@


1.19
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: conf.c,v 1.18 2008/01/03 01:56:25 oga Exp $
a329 13
char *
conf_get_str(struct client_ctx *cc, enum conftype ctype)
{
	switch (ctype) {
	case CONF_NOTIFIER:
		return xstrdup("./notifier.py"); /* XXX */
		break;
	default:
		break;
	}
    return NULL;
}

a397 17

void
conf_bindkey(struct conf *c, void (*arg_callback)(struct client_ctx *, void *),
    int arg_keysym, int arg_modmask, int arg_flags, void * arg_arg)
{
	struct keybinding *kb;

	XMALLOC(kb, struct keybinding);

	kb->modmask = arg_modmask;
	kb->keysym = arg_keysym;
	kb->keycode = 0;
	kb->flags = arg_flags;
	kb->callback = arg_callback;
	kb->argument = arg_arg;
	TAILQ_INSERT_TAIL(&c->keybindingq, kb, entry);
}
@


1.18
log
@Kill some warnings intoduced with the execwm feature.

ok marc@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: conf.c,v 1.17 2007/12/31 02:49:45 okan Exp $
@


1.17
log
@allow the search feature to work in the root window, like other similar ones.

ok todd@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.16 2007/11/28 16:35:52 ian Exp $
d377 2
a378 2
	{ "exec", kbfunc_exec, 0, CWM_EXEC_PROGRAM },
	{ "exec_wm", kbfunc_exec, 0, CWM_EXEC_WM },
@


1.16
log
@Add a "restart wm" function. ok oga@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.15 2007/11/28 16:02:37 oga Exp $
d347 1
a347 1
	{ "search", kbfunc_client_search, KBFLAG_NEEDCLIENT, 0 },
@


1.15
log
@Another messed up keybinding.
I blame todd...

ok okan@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.14 2007/11/27 17:17:08 okan Exp $
d188 1
d377 2
a378 1
	{ "exec", kbfunc_exec, 0, 0 },
@


1.14
log
@re-add a lost group keybinding

ok oga@@ todd@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.13 2007/11/19 22:18:16 oga Exp $
d199 1
a199 1
	conf_bindname(c, "CM-0", "group0");
@


1.13
log
@Make cwm default keybindings always exist. Additional keybindings now
overlap with the new ones, overriding them. Also a new "unmap" keyword
in binding definitions now unmaps a binding without adding a new one.

This seriously shrinks the ~/.calmwm/.keys directory of anyone who defines
their own bindings whilst wanting some of the defaults.

Looked over, liked and ok todd@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.12 2007/11/13 23:26:04 todd Exp $
d203 1
@


1.12
log
@introduce conf_bindname() to drastically simplify conf.c
really liked by oga@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.11 2007/11/13 23:08:49 todd Exp $
d184 56
d241 1
a241 1
        if (dirent_isdir(dir_keydefs)) {
a242 58
        } else {
		conf_bindname(c, "CM-Return", "terminal");
		conf_bindname(c, "CM-Delete", "lock");
		conf_bindname(c, "M-question", "exec");
		conf_bindname(c, "M-period", "ssh");
		conf_bindname(c, "M-Return", "hide");
		conf_bindname(c, "M-Down", "lower");
		conf_bindname(c, "M-Up", "raise");
		conf_bindname(c, "M-slash", "search");
		conf_bindname(c, "C-slash", "menusearch");
		conf_bindname(c, "M-Tab", "cycle");
		conf_bindname(c, "MS-Tab", "rcycle");
		conf_bindname(c, "CM-n", "label");
		conf_bindname(c, "CM-x", "delete");
		conf_bindname(c, "CM-Escape", "groupselect");
		conf_bindname(c, "CM-0", "group0");
		conf_bindname(c, "CM-1", "group1");
		conf_bindname(c, "CM-2", "group2");
		conf_bindname(c, "CM-3", "group3");
		conf_bindname(c, "CM-4", "group4");
		conf_bindname(c, "CM-5", "group5");
		conf_bindname(c, "CM-6", "group6");
		conf_bindname(c, "CM-7", "group7");
		conf_bindname(c, "CM-8", "group8");
		conf_bindname(c, "CM-9", "group9");
		conf_bindname(c, "M-Right", "nextgroup");
		conf_bindname(c, "M-Left", "prevgroup");
		conf_bindname(c, "CM-f", "maximize");
		conf_bindname(c, "CM-equal", "vmaximize");

		conf_bindname(c, "M-h", "moveleft");
		conf_bindname(c, "M-j", "movedown");
		conf_bindname(c, "M-k", "moveup");
		conf_bindname(c, "M-l", "moveright");
		conf_bindname(c, "M-H", "bigmoveleft");
		conf_bindname(c, "M-J", "bigmovedown");
		conf_bindname(c, "M-K", "bigmoveup");
		conf_bindname(c, "M-L", "bigmoveright");

		conf_bindname(c, "CM-h", "resizeleft");
		conf_bindname(c, "CM-j", "resizedown");
		conf_bindname(c, "CM-k", "resizeup");
		conf_bindname(c, "CM-l", "resizeright");
		conf_bindname(c, "CM-H", "bigresizeleft");
		conf_bindname(c, "CM-J", "bigresizedown");
		conf_bindname(c, "CM-K", "bigresizeup");
		conf_bindname(c, "CM-L", "bigresizeright");

		conf_bindname(c, "C-Left", "ptrmoveleft");
		conf_bindname(c, "C-Down", "ptrmovedown");
		conf_bindname(c, "C-Up", "ptrmoveup");
		conf_bindname(c, "C-Right", "ptrmoveright");
		conf_bindname(c, "CS-Left", "bigptrmoveleft");
		conf_bindname(c, "CS-Down", "bigptrmovedown");
		conf_bindname(c, "CS-Up", "bigptrmoveup");
		conf_bindname(c, "CS-Right", "bigptrmoveright");

	}
d500 6
d525 15
@


1.11
log
@enable pointer movement in cwm via C-<arrowkeys>
looked over by oga@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.10 2007/11/07 22:00:26 oga Exp $
d188 56
a243 117
		conf_bindkey(c, kbfunc_term,
		    XK_Return, ControlMask|Mod1Mask, 0, NULL);
		conf_bindkey(c, kbfunc_lock,
		    XK_Delete, ControlMask|Mod1Mask, 0, NULL);
		conf_bindkey(c, kbfunc_exec, XK_question, Mod1Mask, 0, NULL);
		conf_bindkey(c, kbfunc_ssh, XK_period, Mod1Mask, 0, NULL);
		conf_bindkey(c, kbfunc_client_hide,
		    XK_Return, Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_lower,
		    XK_Down, Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_raise,
		    XK_Up, Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_search, XK_slash, Mod1Mask, 0, 0);
		conf_bindkey(c, kbfunc_menu_search,
		    XK_slash, ControlMask, 0, 0);
		conf_bindkey(c, kbfunc_client_cycle,
		    XK_Tab, Mod1Mask, 0, 0);
		conf_bindkey(c, kbfunc_client_rcycle,
		    XK_Tab, Mod1Mask|ShiftMask, 0, 0);
		conf_bindkey(c, kbfunc_client_label, XK_n,
		    ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_delete, XK_x,
		    ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_groupselect,
		    XK_Escape, ControlMask|Mod1Mask, 0, 0);
		conf_bindkey(c, kbfunc_client_group,
		    XK_1, ControlMask|Mod1Mask, 0, (void *) 1);
		conf_bindkey(c, kbfunc_client_group,
		    XK_2, ControlMask|Mod1Mask, 0, (void *) 2);
		conf_bindkey(c, kbfunc_client_group,
		    XK_3, ControlMask|Mod1Mask, 0, (void *) 3);
		conf_bindkey(c, kbfunc_client_group,
		    XK_4, ControlMask|Mod1Mask, 0, (void *) 4);
		conf_bindkey(c, kbfunc_client_group,
		    XK_5, ControlMask|Mod1Mask, 0, (void *) 5);
		conf_bindkey(c, kbfunc_client_group,
		    XK_6, ControlMask|Mod1Mask, 0, (void *) 6);
		conf_bindkey(c, kbfunc_client_group,
		    XK_7, ControlMask|Mod1Mask, 0, (void *) 7);
		conf_bindkey(c, kbfunc_client_group,
		    XK_8, ControlMask|Mod1Mask, 0, (void *) 8);
		conf_bindkey(c, kbfunc_client_group,
		    XK_9, ControlMask|Mod1Mask, 0, (void *) 9);
		conf_bindkey(c, kbfunc_client_nogroup,
		    XK_0, ControlMask|Mod1Mask, 0, 0);
		conf_bindkey(c, kbfunc_client_nextgroup,
		    XK_Right, Mod1Mask, 0, 0);
		conf_bindkey(c, kbfunc_client_prevgroup,
		    XK_Left, Mod1Mask, 0, 0);
                conf_bindkey(c, kbfunc_client_maximize,
		    XK_f, ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_vmaximize,
		    XK_equal, ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT, 0);
		conf_bindkey(c, kbfunc_client_move,
		    XK_k, Mod1Mask, KBFLAG_NEEDCLIENT, (void *)CWM_UP);
		conf_bindkey(c, kbfunc_client_move,
		    XK_j, Mod1Mask, KBFLAG_NEEDCLIENT, (void *)CWM_DOWN);
		conf_bindkey(c, kbfunc_client_move,
		    XK_l, Mod1Mask, KBFLAG_NEEDCLIENT, (void *)CWM_RIGHT);
		conf_bindkey(c, kbfunc_client_move,
		    XK_h, Mod1Mask, KBFLAG_NEEDCLIENT, (void *)CWM_LEFT);
		conf_bindkey(c, kbfunc_client_move,
		    XK_K, Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_UP|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_move,
		    XK_J, Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_DOWN|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_move,
		    XK_L, Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_RIGHT|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_move,
		    XK_H, Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_LEFT|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_resize,
		    XK_k, ControlMask|Mod1Mask, 
		    KBFLAG_NEEDCLIENT, (void *)CWM_UP);
		conf_bindkey(c, kbfunc_client_resize,
		    XK_j, ControlMask|Mod1Mask, 
		    KBFLAG_NEEDCLIENT, (void *)CWM_DOWN);
		conf_bindkey(c, kbfunc_client_resize,
		    XK_l, ControlMask|Mod1Mask, 
		    KBFLAG_NEEDCLIENT, (void *)CWM_RIGHT);
		conf_bindkey(c, kbfunc_client_resize,
		    XK_h, ControlMask|Mod1Mask, 
		    KBFLAG_NEEDCLIENT, (void *)CWM_LEFT);
		conf_bindkey(c, kbfunc_client_resize,
		    XK_K, ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_UP|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_resize,
		    XK_J, ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_DOWN|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_resize,
		    XK_L, ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_RIGHT|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_client_resize,
		    XK_H, ControlMask|Mod1Mask, KBFLAG_NEEDCLIENT,
		    (void *)(CWM_LEFT|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Up, ControlMask, 0, (void *)CWM_UP);
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Down, ControlMask, 0, (void *)CWM_DOWN);
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Right, ControlMask, 0, (void *)CWM_RIGHT);
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Left, ControlMask, 0, (void *)CWM_LEFT);
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Up, ControlMask|ShiftMask, 0,
		    (void *)(CWM_UP|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Left, ControlMask|ShiftMask, 0,
		    (void *)(CWM_LEFT|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Right, ControlMask|ShiftMask, 0,
		    (void *)(CWM_RIGHT|CWM_BIGMOVE));
		conf_bindkey(c, kbfunc_ptrmove,
		    XK_Down, ControlMask|ShiftMask, 0,
		    (void *)(CWM_DOWN|CWM_BIGMOVE));
d354 8
a361 8
	{ "ptru", kbfunc_ptrmove, 0, (void *)CWM_UP },
	{ "ptrd", kbfunc_ptrmove, 0, (void *)CWM_DOWN },
	{ "ptrl", kbfunc_ptrmove, 0, (void *)CWM_LEFT },
	{ "ptrr", kbfunc_ptrmove, 0, (void *)CWM_RIGHT },
	{ "bigptru", kbfunc_ptrmove, 0, (void *)(CWM_UP|CWM_BIGMOVE) },
	{ "bigptrd", kbfunc_ptrmove, 0, (void *)(CWM_DOWN|CWM_BIGMOVE) },
	{ "bigptrl", kbfunc_ptrmove, 0, (void *)(CWM_LEFT|CWM_BIGMOVE) },
	{ "bigptrr", kbfunc_ptrmove, 0, (void *)(CWM_RIGHT|CWM_BIGMOVE) },
a421 2
	struct keybinding *current_binding;
	int iter;
a426 1
		char *substring;
a436 1
		XCALLOC(current_binding, struct keybinding);
d438 44
a481 38
		if (strchr(ent->d_name, 'C') != NULL &&
		    strchr(ent->d_name, 'C') < strchr(ent->d_name, '-'))
			current_binding->modmask |= ControlMask;

		if (strchr(ent->d_name, 'M') != NULL &&
		    strchr(ent->d_name, 'M') < strchr(ent->d_name, '-')) 
			current_binding->modmask |= Mod1Mask;

		if (strchr(ent->d_name, '2') != NULL &&
		    strchr(ent->d_name, '2') < strchr(ent->d_name, '-')) 
			current_binding->modmask |= Mod2Mask;

		if (strchr(ent->d_name, '3') != NULL &&
		    strchr(ent->d_name, '3') < strchr(ent->d_name, '-')) 
			current_binding->modmask |= Mod3Mask;

		if (strchr(ent->d_name, '4') != NULL &&
		    strchr(ent->d_name, '4') < strchr(ent->d_name, '-')) 
			current_binding->modmask |= Mod4Mask;

		if (strchr(ent->d_name, 'S') != NULL &&
		    strchr(ent->d_name, 'S') < strchr(ent->d_name, '-')) 
			current_binding->modmask |= ShiftMask;

		substring = strchr(ent->d_name, '-') + 1;

		/* If there is no '-' in name, continue as is */
		if (strchr(ent->d_name, '-') == NULL)
			substring = ent->d_name;

		if (substring[0] == '[' &&
		    substring[strlen(substring)-1] == ']') {
			sscanf(substring, "[%d]", &current_binding->keycode);
			current_binding->keysym = NoSymbol;
		} else {
			current_binding->keycode = 0;
			current_binding->keysym = XStringToKeysym(substring);
		}
d483 3
a485 5
		if (current_binding->keysym == NoSymbol &&
		    current_binding->keycode == 0 ) {
			xfree(current_binding);
			continue;
		}
d487 8
a494 5
		memset(buffer, 0, MAXPATHLEN);
		if (readlink(current_file, buffer, MAXPATHLEN) < 0) {
			free(current_binding);
			continue;
		}
d496 5
a500 10
		for (iter = 0; name_to_kbfunc[iter].tag != NULL; iter++) {
			if (strcmp(name_to_kbfunc[iter].tag, buffer) != 0)
				continue;

			current_binding->callback = name_to_kbfunc[iter].handler;
			current_binding->flags = name_to_kbfunc[iter].flags;
            current_binding->argument = name_to_kbfunc[iter].argument;
			TAILQ_INSERT_TAIL(&c->keybindingq, current_binding, entry);
			break;
		}
d502 2
a503 1
		if (name_to_kbfunc[iter].tag != NULL)
d506 3
a508 3
		current_binding->callback = kbfunc_cmdexec;
		current_binding->argument = strdup(buffer);
		current_binding->flags = 0;
d510 1
d513 8
a520 1
	closedir(dir);
@


1.10
log
@Document cwm's keybinding support. It was already there, but not in the manpage.

While I'm here add support for extra modifier keys.

"commit commit!" jasper@@, ok todd@@.
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.9 2007/11/07 21:58:03 oga Exp $
d285 20
d415 8
@


1.9
log
@Add support to cwm for resizing the windows using Control-Meta-[hjkl].

Please note that this remaps Control-Meta-L (label) to Control-Meta-N (name).

ok jasper@@, todd@@.
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.8 2007/06/27 13:28:22 todd Exp $
d389 1
d396 34
a429 14
	{ "group1", kbfunc_client_group, 0, (void *) 1 },
	{ "group2", kbfunc_client_group, 0, (void *) 2 },
	{ "group3", kbfunc_client_group, 0, (void *) 3 },
	{ "group4", kbfunc_client_group, 0, (void *) 4 },
	{ "group5", kbfunc_client_group, 0, (void *) 5 },
	{ "group6", kbfunc_client_group, 0, (void *) 6 },
	{ "group7", kbfunc_client_group, 0, (void *) 7 },
	{ "group8", kbfunc_client_group, 0, (void *) 8 },
	{ "group9", kbfunc_client_group, 0, (void *) 9 },
	{ "nogroup", kbfunc_client_nogroup, 0, 0},
	{ "nextgroup", kbfunc_client_nextgroup, 0, 0},
	{ "prevgroup", kbfunc_client_prevgroup, 0, 0},
	{ "maximize", kbfunc_client_maximize, KBFLAG_NEEDCLIENT, 0},
	{ "vmaximize", kbfunc_client_vmaximize, KBFLAG_NEEDCLIENT, 0},
d482 16
@


1.8
log
@implement keyboard initiated movement of windows
enhanced version of diff originally from niallo@@
man bits from niallo@@
ok niallo@@ japser@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.7 2007/06/26 19:34:26 niallo Exp $
d207 1
a207 1
		conf_bindkey(c, kbfunc_client_label, XK_l,
d261 25
a285 1
        }
@


1.7
log
@modify "exec" dialog so that it auto-completes based on executables in
_PATH_DEFPATH

add an "ssh-to" dialog which auto-completes based on contents of
 ~/.ssh/known_hosts (M-.)

testing and eyeballing by Simon Kuhnle <simonkuhnle at web.de>, todd@@, pedro@@
mk@@ and David Cathcart <david at cathcart.cx>

ok todd@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.6 2007/06/05 19:03:20 jasper Exp $
d23 1
d241 20
@


1.6
log
@make it possible to cycle through the windows when non are selected.
(eg. when they're hidden, now you can cycle through them)

from aon@@iki.fi
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.5 2007/05/28 21:11:39 jasper Exp $
d192 1
@


1.5
log
@add two missing closedir()'s

from Antti Nyknen <aon at iki.fi> via bernd@@

ok pedro@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.4 2007/05/28 18:34:27 jasper Exp $
d202 1
a202 1
		    XK_Tab, Mod1Mask, KBFLAG_NEEDCLIENT, 0);
d204 1
a204 1
		    XK_Tab, Mod1Mask|ShiftMask, KBFLAG_NEEDCLIENT, 0);
@


1.4
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.3 2007/05/27 09:23:12 jasper Exp $
d152 3
d537 3
@


1.3
log
@full screen sized windows

ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.2 2007/04/27 18:08:14 bernd Exp $
d81 1
a81 1
		strlcpy(G_conf.termpath, image, sizeof(G_conf.termpath));
d83 1
a83 1
		strlcpy(G_conf.lockpath, image, sizeof(G_conf.lockpath));
d265 2
a266 2
	strlcpy(G_conf.termpath, "xterm", sizeof(G_conf.termpath));
	strlcpy(G_conf.lockpath, "xlock", sizeof(G_conf.lockpath));
d474 1
a474 1
			G_conf.flags |= CONF_STICKY_GROUPS;
@


1.2
log
@Apply cwm-3-exec.diff from http://aon.iki.fi/cwm/. Document the new
key binding.
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
d232 2
d415 1
a415 1
		// if there is no '-' in name, continue as is
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: conf.c,v 1.43 2005/08/28 09:36:44 marius Exp $
d188 1
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
