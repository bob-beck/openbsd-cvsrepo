head	1.101;
access;
symbols
	OPENBSD_6_1:1.101.0.2
	OPENBSD_6_1_BASE:1.101
	OPENBSD_6_0:1.90.0.2
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.89.0.2
	OPENBSD_5_9_BASE:1.89
	OPENBSD_5_8:1.87.0.2
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.78.0.2
	OPENBSD_5_7_BASE:1.78
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.2
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.12.0.2
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6;
locks; strict;
comment	@ * @;


1.101
date	2016.12.06.21.59.33;	author okan;	state Exp;
branches;
next	1.100;
commitid	YeXGci1FHYjo8hBc;

1.100
date	2016.12.06.21.54.10;	author okan;	state Exp;
branches;
next	1.99;
commitid	GTK8UjM1rfae1rvk;

1.99
date	2016.12.01.20.28.19;	author okan;	state Exp;
branches;
next	1.98;
commitid	BV26iM1x8TsKqz4Z;

1.98
date	2016.10.24.20.44.08;	author okan;	state Exp;
branches;
next	1.97;
commitid	lzO3MzgydwqlVR1a;

1.97
date	2016.10.03.18.43.49;	author okan;	state Exp;
branches;
next	1.96;
commitid	5hMp5cE2gxBlRBhs;

1.96
date	2016.09.30.18.28.06;	author okan;	state Exp;
branches;
next	1.95;
commitid	STecP6DPl2bavnIv;

1.95
date	2016.09.30.15.12.19;	author okan;	state Exp;
branches;
next	1.94;
commitid	uC9f6GlGiQkjBS9C;

1.94
date	2016.09.29.00.21.55;	author okan;	state Exp;
branches;
next	1.93;
commitid	T0a7tiQalU2SO4pS;

1.93
date	2016.09.28.17.06.33;	author okan;	state Exp;
branches;
next	1.92;
commitid	UDBUlJ5kvU8CcYZj;

1.92
date	2016.09.20.19.58.54;	author okan;	state Exp;
branches;
next	1.91;
commitid	SDiPnhn5RhRvwghb;

1.91
date	2016.08.28.15.23.24;	author okan;	state Exp;
branches;
next	1.90;
commitid	mx4w4nirc939JTkk;

1.90
date	2016.04.28.16.28.38;	author okan;	state Exp;
branches;
next	1.89;
commitid	uCn0uDm6bjVyReFB;

1.89
date	2015.11.11.14.22.01;	author okan;	state Exp;
branches;
next	1.88;
commitid	t4AzuTxPlqQ6EzqO;

1.88
date	2015.11.09.20.03.29;	author okan;	state Exp;
branches;
next	1.87;
commitid	9uKgpfLzKiBWmiSm;

1.87
date	2015.07.12.14.21.09;	author okan;	state Exp;
branches;
next	1.86;
commitid	QUInlnH2lvPTrpud;

1.86
date	2015.07.01.14.36.42;	author okan;	state Exp;
branches;
next	1.85;
commitid	HEkKIvh6L9ijX1lH;

1.85
date	2015.06.30.18.42.50;	author okan;	state Exp;
branches;
next	1.84;
commitid	mctqLOFykKSdPMbE;

1.84
date	2015.06.26.17.17.46;	author okan;	state Exp;
branches;
next	1.83;
commitid	lHlj3PDNu98waqIr;

1.83
date	2015.06.08.15.08.44;	author okan;	state Exp;
branches;
next	1.82;
commitid	Bzlhw1iC9viQ9tp2;

1.82
date	2015.06.05.18.43.36;	author okan;	state Exp;
branches;
next	1.81;
commitid	GZbeEZ1wDXtHRKui;

1.81
date	2015.06.05.15.01.51;	author okan;	state Exp;
branches;
next	1.80;
commitid	zeddTrrTnPr6FqHq;

1.80
date	2015.06.05.14.54.04;	author okan;	state Exp;
branches;
next	1.79;
commitid	YsZRg0KoSgeOylZ9;

1.79
date	2015.03.28.22.09.10;	author okan;	state Exp;
branches;
next	1.78;
commitid	tbg6MddfKkxPXsPN;

1.78
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.77;
commitid	kLADTGYX3gw0Sf2m;

1.77
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.76;
commitid	jXQ1fztXcP9vyPb1;

1.76
date	2014.09.06.16.18.08;	author okan;	state Exp;
branches;
next	1.75;
commitid	6p0OvJjoY6TdwfT0;

1.75
date	2014.02.01.19.28.46;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2014.01.21.15.42.45;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2014.01.20.18.58.03;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2014.01.02.22.49.10;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2013.12.17.16.10.43;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2013.12.13.22.39.13;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2013.12.02.20.01.19;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2013.12.02.19.49.26;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2013.06.17.17.11.10;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2013.05.20.21.32.00;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2013.05.20.20.21.04;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2013.05.20.20.04.36;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.19.23.38.21;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2013.05.14.12.35.56;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2013.05.10.16.10.40;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2013.05.07.01.35.41;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.06.16.00.34;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2013.05.02.20.18.35;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.02.19.41.52;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.02.17.25.15;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.08.13.02.31;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.08.00.56.21;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2013.04.05.17.07.25;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2013.01.07.21.53.23;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2013.01.02.16.26.34;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2013.01.02.02.19.20;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2012.12.17.14.32.39;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2012.12.17.02.53.29;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.14.21.12.24;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2012.11.07.14.39.44;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.23.16.13.59;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.23.16.08.59;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.23.15.50.15;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2012.10.23.15.32.38;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2012.08.07.14.05.49;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2012.05.16.01.04.36;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.08.12.00.50;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.25.15.41.05;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.23.13.09.11;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.27.12.46.54;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.24.06.52.23;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.05.15.32.24;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.22.13.50.40;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.22.11.09.52;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.22.11.05.13;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.22.11.03.05;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2011.03.22.10.47.59;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.10.01.23.05;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.08.16.52.17;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.07.19.48.08;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.28.17.52.12;	author tobias;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.05.14.10.11;	author tobias;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.17.12.30.17;	author okan;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.30.00.29.08;	author okan;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.28.16.38.54;	author martynas;	state Exp;
branches;
next	1.6;

1.6
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.05.04.01.37;	author okan;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.23.18.48.57;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.21.14.11.19;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	;


desc
@@


1.101
log
@stray newlines
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2008 Owain G. Ainsworth <oga@@openbsd.org>
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: menu.c,v 1.100 2016/12/06 21:54:10 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

#define PROMPT_SCHAR	"\xc2\xbb"
#define PROMPT_ECHAR	"\xc2\xab"

enum ctltype {
	CTL_NONE = -1,
	CTL_ERASEONE = 0, CTL_WIPE, CTL_UP, CTL_DOWN, CTL_RETURN,
	CTL_TAB, CTL_ABORT, CTL_ALL
};

struct menu_ctx {
	struct screen_ctx	*sc;
	char			 searchstr[MENU_MAXENTRY + 1];
	char			 dispstr[MENU_MAXENTRY*2 + 1];
	char			 promptstr[MENU_MAXENTRY + 1];
	int			 hasprompt;
	int			 list;
	int			 listing;
	int			 changed;
	int			 noresult;
	int			 prev;
	int			 entry;
	int			 num;
	int 			 flags;
	struct geom		 geom;
	void (*match)(struct menu_q *, struct menu_q *, char *);
	void (*print)(struct menu *, int);
};
static struct menu	*menu_handle_key(XEvent *, struct menu_ctx *,
			     struct menu_q *, struct menu_q *);
static void		 menu_handle_move(struct menu_ctx *,
			     struct menu_q *, int, int);
static struct menu	*menu_handle_release(struct menu_ctx *,
			     struct menu_q *, int, int);
static void		 menu_draw(struct menu_ctx *, struct menu_q *,
			     struct menu_q *);
static void 		 menu_draw_entry(struct menu_ctx *, struct menu_q *,
			     int, int);
static int		 menu_calc_entry(struct menu_ctx *, int, int);
static struct menu	*menu_complete_path(struct menu_ctx *);
static int		 menu_keycode(XKeyEvent *, enum ctltype *, char *);

struct menu *
menu_filter(struct screen_ctx *sc, struct menu_q *menuq, const char *prompt,
    const char *initial, int flags,
    void (*match)(struct menu_q *, struct menu_q *, char *),
    void (*print)(struct menu *, int))
{
	struct menu_ctx		 mc;
	struct menu_q		 resultq;
	struct menu		*mi = NULL;
	XEvent			 e;
	Window			 focuswin;
	int			 evmask, focusrevert;
	int			 xsave, ysave, xcur, ycur;

	TAILQ_INIT(&resultq);

	(void)memset(&mc, 0, sizeof(mc));

	xu_ptr_getpos(sc->rootwin, &xsave, &ysave);

	mc.sc = sc;
	mc.flags = flags;
	mc.match = match;
	mc.print = print;
	mc.entry = mc.prev = -1;
	mc.geom.x = xsave;
	mc.geom.y = ysave;

	if (mc.flags & CWM_MENU_LIST)
		mc.list = 1;

	if (initial != NULL)
		(void)strlcpy(mc.searchstr, initial, sizeof(mc.searchstr));
	else
		mc.searchstr[0] = '\0';

	evmask = MENUMASK;
	if (prompt != NULL) {
		evmask |= KEYMASK; /* accept keys as well */
		(void)strlcpy(mc.promptstr, prompt, sizeof(mc.promptstr));
		mc.hasprompt = 1;
	}

	XSelectInput(X_Dpy, sc->menu.win, evmask);
	XMapRaised(X_Dpy, sc->menu.win);

	if (XGrabPointer(X_Dpy, sc->menu.win, False, MENUGRABMASK,
	    GrabModeAsync, GrabModeAsync, None, Conf.cursor[CF_QUESTION],
	    CurrentTime) != GrabSuccess) {
		XUnmapWindow(X_Dpy, sc->menu.win);
		return(NULL);
	}

	XGetInputFocus(X_Dpy, &focuswin, &focusrevert);
	XSetInputFocus(X_Dpy, sc->menu.win, RevertToPointerRoot, CurrentTime);

	/* make sure keybindings don't remove keys from the menu stream */
	XGrabKeyboard(X_Dpy, sc->menu.win, True,
	    GrabModeAsync, GrabModeAsync, CurrentTime);

	for (;;) {
		mc.changed = 0;

		XWindowEvent(X_Dpy, sc->menu.win, evmask, &e);

		switch (e.type) {
		case KeyPress:
			if ((mi = menu_handle_key(&e, &mc, menuq, &resultq))
			    != NULL)
				goto out;
			/* FALLTHROUGH */
		case Expose:
			menu_draw(&mc, menuq, &resultq);
			break;
		case MotionNotify:
			menu_handle_move(&mc, &resultq,
			    e.xbutton.x, e.xbutton.y);
			break;
		case ButtonRelease:
			if ((mi = menu_handle_release(&mc, &resultq,
			    e.xbutton.x, e.xbutton.y)) != NULL)
				goto out;
			break;
		default:
			break;
		}
	}
out:
	if ((mc.flags & CWM_MENU_DUMMY) == 0 && mi->dummy) {
	       	/* no mouse based match */
		free(mi);
		mi = NULL;
	}

	XSetInputFocus(X_Dpy, focuswin, focusrevert, CurrentTime);
	/* restore if user didn't move */
	xu_ptr_getpos(sc->rootwin, &xcur, &ycur);
	if (xcur == mc.geom.x && ycur == mc.geom.y)
		xu_ptr_setpos(sc->rootwin, xsave, ysave);
	XUngrabPointer(X_Dpy, CurrentTime);

	XMoveResizeWindow(X_Dpy, sc->menu.win, 0, 0, 1, 1);
	XUnmapWindow(X_Dpy, sc->menu.win);
	XUngrabKeyboard(X_Dpy, CurrentTime);

	return(mi);
}

static struct menu *
menu_complete_path(struct menu_ctx *mc)
{
	struct screen_ctx	*sc = mc->sc;
	struct menu		*mi, *mr;
	struct menu_q		 menuq;

	mr = xcalloc(1, sizeof(*mr));

	TAILQ_INIT(&menuq);

	if ((mi = menu_filter(sc, &menuq, mc->searchstr, NULL,
	    (CWM_MENU_DUMMY), search_match_path, search_print_text)) != NULL) {
		mr->abort = mi->abort;
		mr->dummy = mi->dummy;
		if (mi->text[0] != '\0')
			snprintf(mr->text, sizeof(mr->text), "%s \"%s\"",
			    mc->searchstr, mi->text);
		else if (!mr->abort)
			strlcpy(mr->text, mc->searchstr, sizeof(mr->text));
	}
	
	menuq_clear(&menuq);

	return(mr);
}

static struct menu *
menu_handle_key(XEvent *e, struct menu_ctx *mc, struct menu_q *menuq,
    struct menu_q *resultq)
{
	struct menu	*mi;
	enum ctltype	 ctl;
	char		 chr[32];
	size_t		 len;
	int 		 clen, i;
	wchar_t 	 wc;

	if (menu_keycode(&e->xkey, &ctl, chr) < 0)
		return(NULL);

	switch (ctl) {
	case CTL_ERASEONE:
		if ((len = strlen(mc->searchstr)) > 0) {
			clen = 1;
			while (mbtowc(&wc, &mc->searchstr[len-clen], MB_CUR_MAX) == -1)
				clen++;
			for (i = 1; i <= clen; i++)
				mc->searchstr[len - i] = '\0';
			mc->changed = 1;
		}
		break;
	case CTL_UP:
		mi = TAILQ_LAST(resultq, menu_q);
		if (mi == NULL)
			break;

		TAILQ_REMOVE(resultq, mi, resultentry);
		TAILQ_INSERT_HEAD(resultq, mi, resultentry);
		break;
	case CTL_DOWN:
		mi = TAILQ_FIRST(resultq);
		if (mi == NULL)
			break;

		TAILQ_REMOVE(resultq, mi, resultentry);
		TAILQ_INSERT_TAIL(resultq, mi, resultentry);
		break;
	case CTL_RETURN:
		/*
		 * Return whatever the cursor is currently on. Else
		 * even if dummy is zero, we need to return something.
		 */
		if ((mi = TAILQ_FIRST(resultq)) == NULL) {
			mi = xmalloc(sizeof(*mi));
			(void)strlcpy(mi->text,
			    mc->searchstr, sizeof(mi->text));
			mi->dummy = 1;
		}
		mi->abort = 0;
		return(mi);
	case CTL_WIPE:
		mc->searchstr[0] = '\0';
		mc->changed = 1;
		break;
	case CTL_TAB:
		if ((mi = TAILQ_FIRST(resultq)) != NULL) {
			/*
			 * - We are in exec_path menu mode
			 * - It is equal to the input
			 * We got a command, launch the file menu
			 */
			if ((mc->flags & CWM_MENU_FILE) &&
			    (strncmp(mc->searchstr, mi->text,
					strlen(mi->text))) == 0)
				return(menu_complete_path(mc));

			/*
			 * Put common prefix of the results into searchstr
			 */
			(void)strlcpy(mc->searchstr,
					mi->text, sizeof(mc->searchstr));
			while ((mi = TAILQ_NEXT(mi, resultentry)) != NULL) {
				i = 0;
				while (tolower(mc->searchstr[i]) ==
					       tolower(mi->text[i]))
					i++;
				mc->searchstr[i] = '\0';
			}
			mc->changed = 1;
		}
		break;
	case CTL_ALL:
		mc->list = !mc->list;
		break;
	case CTL_ABORT:
		mi = xmalloc(sizeof(*mi));
		mi->text[0] = '\0';
		mi->dummy = 1;
		mi->abort = 1;
		return(mi);
	default:
		break;
	}

	if (chr[0] != '\0') {
		mc->changed = 1;
		(void)strlcat(mc->searchstr, chr, sizeof(mc->searchstr));
	}

	mc->noresult = 0;
	if (mc->changed && mc->searchstr[0] != '\0') {
		(*mc->match)(menuq, resultq, mc->searchstr);
		/* If menuq is empty, never show we've failed */
		mc->noresult = TAILQ_EMPTY(resultq) && !TAILQ_EMPTY(menuq);
	} else if (mc->changed)
		TAILQ_INIT(resultq);

	if (!mc->list && mc->listing && !mc->changed) {
		TAILQ_INIT(resultq);
		mc->listing = 0;
	}

	return(NULL);
}

static void
menu_draw(struct menu_ctx *mc, struct menu_q *menuq, struct menu_q *resultq)
{
	struct screen_ctx	*sc = mc->sc;
	struct menu		*mi;
	struct geom		 area;
	int			 n, xsave, ysave;
	XGlyphInfo		 extents;

	if (mc->list) {
		if (TAILQ_EMPTY(resultq)) {
			/* Copy them all over. */
			TAILQ_FOREACH(mi, menuq, entry)
				TAILQ_INSERT_TAIL(resultq, mi, resultentry);

			mc->listing = 1;
		} else if (mc->changed)
			mc->listing = 0;
	}

	mc->num = 0;
	mc->geom.w = 0;
	mc->geom.h = 0;
	if (mc->hasprompt) {
		(void)snprintf(mc->dispstr, sizeof(mc->dispstr), "%s%s%s%s",
		    mc->promptstr, PROMPT_SCHAR, mc->searchstr, PROMPT_ECHAR);

		XftTextExtentsUtf8(X_Dpy, sc->xftfont,
		    (const FcChar8*)mc->dispstr, strlen(mc->dispstr), &extents);

		mc->geom.w = extents.xOff;
		mc->geom.h = sc->xftfont->height + 1;
		mc->num = 1;
	}

	TAILQ_FOREACH(mi, resultq, resultentry) {
		(*mc->print)(mi, mc->listing);

		XftTextExtentsUtf8(X_Dpy, sc->xftfont,
		    (const FcChar8*)mi->print,
		    MIN(strlen(mi->print), MENU_MAXENTRY), &extents);

		mc->geom.w = MAX(mc->geom.w, extents.xOff);
		mc->geom.h += sc->xftfont->height + 1;
		mc->num++;
	}

	area = screen_area(sc, mc->geom.x, mc->geom.y, CWM_GAP);
	area.w += area.x - Conf.bwidth * 2;
	area.h += area.y - Conf.bwidth * 2;

	xsave = mc->geom.x;
	ysave = mc->geom.y;

	/* Never hide the top, or left side, of the menu. */
	if (mc->geom.x + mc->geom.w >= area.w)
		mc->geom.x = area.w - mc->geom.w;
	if (mc->geom.x < area.x) {
		mc->geom.x = area.x;
		mc->geom.w = MIN(mc->geom.w, (area.w - area.x));
	}
	if (mc->geom.y + mc->geom.h >= area.h)
		mc->geom.y = area.h - mc->geom.h;
	if (mc->geom.y < area.y) {
		mc->geom.y = area.y;
		mc->geom.h = MIN(mc->geom.h, (area.h - area.y));
	}

	if (mc->geom.x != xsave || mc->geom.y != ysave)
		xu_ptr_setpos(sc->rootwin, mc->geom.x, mc->geom.y);

	XClearWindow(X_Dpy, sc->menu.win);
	XMoveResizeWindow(X_Dpy, sc->menu.win, mc->geom.x, mc->geom.y,
	    mc->geom.w, mc->geom.h);

	n = 0;
	if (mc->hasprompt) {
		XftDrawStringUtf8(sc->menu.xftdraw,
		    &sc->xftcolor[CWM_COLOR_MENU_FONT], sc->xftfont,
		    0, sc->xftfont->ascent,
		    (const FcChar8*)mc->dispstr, strlen(mc->dispstr));
		n++;
	}

	TAILQ_FOREACH(mi, resultq, resultentry) {
		int y = n * (sc->xftfont->height + 1) + sc->xftfont->ascent + 1;

		/* Stop drawing when menu doesn't fit inside the screen. */
		if (mc->geom.y + y > area.h)
			break;

		XftDrawStringUtf8(sc->menu.xftdraw,
		    &sc->xftcolor[CWM_COLOR_MENU_FONT], sc->xftfont,
		    0, y,
		    (const FcChar8*)mi->print, strlen(mi->print));
		n++;
	}
	if (mc->hasprompt && n > 1)
		menu_draw_entry(mc, resultq, 1, 1);
}

static void
menu_draw_entry(struct menu_ctx *mc, struct menu_q *resultq,
    int entry, int active)
{
	struct screen_ctx	*sc = mc->sc;
	struct menu		*mi;
	int			 color, i = 0;

	if (mc->hasprompt)
		i = 1;

	TAILQ_FOREACH(mi, resultq, resultentry)
		if (entry == i++)
			break;
	if (mi == NULL)
		return;

	color = (active) ? CWM_COLOR_MENU_FG : CWM_COLOR_MENU_BG;
	XftDrawRect(sc->menu.xftdraw, &sc->xftcolor[color], 0,
	    (sc->xftfont->height + 1) * entry, mc->geom.w,
	    (sc->xftfont->height + 1) + sc->xftfont->descent);
	color = (active) ? CWM_COLOR_MENU_FONT_SEL : CWM_COLOR_MENU_FONT;
	XftDrawStringUtf8(sc->menu.xftdraw,
	    &sc->xftcolor[color], sc->xftfont,
	    0, (sc->xftfont->height + 1) * entry + sc->xftfont->ascent + 1,
	    (const FcChar8*)mi->print, strlen(mi->print));
}

static void
menu_handle_move(struct menu_ctx *mc, struct menu_q *resultq, int x, int y)
{
	mc->prev = mc->entry;
	mc->entry = menu_calc_entry(mc, x, y);

	if (mc->prev == mc->entry)
		return;

	if (mc->prev != -1)
		menu_draw_entry(mc, resultq, mc->prev, 0);
	if (mc->entry != -1) {
		XChangeActivePointerGrab(X_Dpy, MENUGRABMASK,
		    Conf.cursor[CF_NORMAL], CurrentTime);
		menu_draw_entry(mc, resultq, mc->entry, 1);
	}
}

static struct menu *
menu_handle_release(struct menu_ctx *mc, struct menu_q *resultq, int x, int y)
{
	struct menu		*mi;
	int			 entry, i = 0;

	entry = menu_calc_entry(mc, x, y);

	if (mc->hasprompt)
		i = 1;

	TAILQ_FOREACH(mi, resultq, resultentry)
		if (entry == i++)
			break;
	if (mi == NULL) {
		mi = xmalloc(sizeof(*mi));
		mi->text[0] = '\0';
		mi->dummy = 1;
	}
	return(mi);
}

static int
menu_calc_entry(struct menu_ctx *mc, int x, int y)
{
	struct screen_ctx	*sc = mc->sc;
	int			 entry;

	entry = y / (sc->xftfont->height + 1);

	/* in bounds? */
	if (x < 0 || x > mc->geom.w || y < 0 ||
	    y > (sc->xftfont->height + 1) * mc->num ||
	    entry < 0 || entry >= mc->num)
		entry = -1;

	if (mc->hasprompt && entry == 0)
		entry = -1;

	return(entry);
}

static int
menu_keycode(XKeyEvent *ev, enum ctltype *ctl, char *chr)
{
	KeySym		 ks;

	*ctl = CTL_NONE;
	chr[0] = '\0';

	ks = XkbKeycodeToKeysym(X_Dpy, ev->keycode, 0,
	     (ev->state & ShiftMask) ? 1 : 0);

	/* Look for control characters. */
	switch (ks) {
	case XK_BackSpace:
		*ctl = CTL_ERASEONE;
		break;
	case XK_KP_Enter:
	case XK_Return:
		*ctl = CTL_RETURN;
		break;
	case XK_Tab:
		*ctl = CTL_TAB;
		break;
	case XK_Up:
		*ctl = CTL_UP;
		break;
	case XK_Down:
		*ctl = CTL_DOWN;
		break;
	case XK_Escape:
		*ctl = CTL_ABORT;
		break;
	}

	if (*ctl == CTL_NONE && (ev->state & ControlMask)) {
		switch (ks) {
		case XK_s:
		case XK_S:
			/* Emacs "next" */
			*ctl = CTL_DOWN;
			break;
		case XK_r:
		case XK_R:
			/* Emacs "previous" */
			*ctl = CTL_UP;
			break;
		case XK_u:
		case XK_U:
			*ctl = CTL_WIPE;
			break;
		case XK_h:
		case XK_H:
			*ctl = CTL_ERASEONE;
			break;
		case XK_a:
		case XK_A:
			*ctl = CTL_ALL;
			break;
		case XK_bracketleft:
			*ctl = CTL_ABORT;
			break;
		}
	}

	if (*ctl == CTL_NONE && (ev->state & Mod1Mask)) {
		switch (ks) {
		case XK_j:
		case XK_J:
			/* Vi "down" */
			*ctl = CTL_DOWN;
			break;
		case XK_k:
		case XK_K:
			/* Vi "up" */
			*ctl = CTL_UP;
			break;
		}
	}

	if (*ctl != CTL_NONE)
		return(0);

	if (XLookupString(ev, chr, 32, &ks, NULL) < 0)
		return(-1);

	return(0);
}

void
menuq_add(struct menu_q *mq, void *ctx, const char *fmt, ...)
{
	va_list		 ap;
	struct menu	*mi;

	mi = xcalloc(1, sizeof(*mi));
	mi->ctx = ctx;

	va_start(ap, fmt);
	if (fmt != NULL)
		(void)vsnprintf(mi->text, sizeof(mi->text), fmt, ap);
	else
		mi->text[0] = '\0';
	va_end(ap);

	TAILQ_INSERT_TAIL(mq, mi, entry);
}

void
menuq_clear(struct menu_q *mq)
{
	struct menu	*mi;

	while ((mi = TAILQ_FIRST(mq)) != NULL) {
		TAILQ_REMOVE(mq, mi, entry);
		free(mi);
	}
}

void
menu_windraw(struct screen_ctx *sc, Window win, const char *fmt, ...)
{
	va_list			 ap;
	int			 i;
	char			*text;
	XGlyphInfo		 extents;

	va_start(ap, fmt);
	i = vasprintf(&text, fmt, ap);
	va_end(ap);

	if (i < 0 || text == NULL)
		err(1, "vasprintf");

	XftTextExtentsUtf8(X_Dpy, sc->xftfont, (const FcChar8*)text,
	    strlen(text), &extents);

	XReparentWindow(X_Dpy, sc->menu.win, win, 0, 0);
	XMoveResizeWindow(X_Dpy, sc->menu.win, 0, 0,
	    extents.xOff, sc->xftfont->height);
	XMapWindow(X_Dpy, sc->menu.win);
	XClearWindow(X_Dpy, sc->menu.win);

	XftDrawStringUtf8(sc->menu.xftdraw, &sc->xftcolor[CWM_COLOR_MENU_FONT],
	    sc->xftfont, 0, sc->xftfont->ascent + 1,
	    (const FcChar8*)text, strlen(text));

	free(text);
}
@


1.100
log
@Add search_print_text(), a default callback for mi->print in menu_filter(). While
here, normalize the remaining search_print_* argument paramters.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.99 2016/12/01 20:28:19 okan Exp $
a128 1

a668 1

@


1.99
log
@Tame the number of 'exec' and 'path' search_match wrappers. No functional
change now, though more can likely go later, losing the (paritally complete or
incomplete/broken) argument completion bits.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.98 2016/10/24 20:44:08 okan Exp $
d199 1
a199 1
	    (CWM_MENU_DUMMY), search_match_path, NULL)) != NULL) {
d369 1
a369 5
		if (mc->print != NULL)
			(*mc->print)(mi, mc->listing);
		else
			(void)snprintf(mi->print, sizeof(mi->print),
			    "%s", mi->text);
@


1.98
log
@Make it clear these are flags.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.97 2016/10/03 18:43:49 okan Exp $
d199 1
a199 1
	    (CWM_MENU_DUMMY), search_match_path_any, NULL)) != NULL) {
@


1.97
log
@Start simplifying menu code; and in turn, remove a cursor no longer
needed.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.96 2016/09/30 18:28:06 okan Exp $
d199 1
a199 1
	    CWM_MENU_DUMMY, search_match_path_any, NULL)) != NULL) {
@


1.96
log
@Use instinsic X11 functions for key/btn/ptr grab/ungrab/regrab requests;
the one line wrappers provided no value and limited altering calls where
needed; additionally, most of them had but one caller.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.95 2016/09/30 15:12:19 okan Exp $
d66 4
a69 4
static void		 menu_handle_move(XEvent *, struct menu_ctx *,
			     struct menu_q *);
static struct menu	*menu_handle_release(XEvent *, struct menu_ctx *,
			     struct menu_q *);
d154 2
a155 1
			menu_handle_move(&e, &mc, &resultq);
d158 2
a159 2
			if ((mi = menu_handle_release(&e, &mc, &resultq))
			    != NULL)
d412 1
d418 2
a419 3
		n = 1;
	} else
		n = 0;
d467 1
a467 1
menu_handle_move(XEvent *e, struct menu_ctx *mc, struct menu_q *resultq)
d470 1
a470 1
	mc->entry = menu_calc_entry(mc, e->xbutton.x, e->xbutton.y);
a480 3
	} else {
		XChangeActivePointerGrab(X_Dpy, MENUGRABMASK,
		    Conf.cursor[CF_DEFAULT], CurrentTime);
d485 1
a485 1
menu_handle_release(XEvent *e, struct menu_ctx *mc, struct menu_q *resultq)
d490 1
a490 1
	entry = menu_calc_entry(mc, e->xbutton.x, e->xbutton.y);
a529 1
	unsigned int 	 state = ev->state;
d535 1
a535 1
	     (state & ShiftMask) ? 1 : 0);
d560 1
a560 1
	if (*ctl == CTL_NONE && (state & ControlMask)) {
d590 1
a590 1
	if (*ctl == CTL_NONE && (state & Mod1Mask)) {
@


1.95
log
@Replace mousefunc_sweep_draw() with a generic menu_windraw() using va
lists; use it appropriately for both window dimension and position in
the respective mousefunc calls.

ok bryent@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.94 2016/09/29 00:21:55 okan Exp $
d124 3
a126 2
	if (xu_ptr_grab(sc->menu.win, MENUGRABMASK,
	    Conf.cursor[CF_QUESTION]) < 0) {
d129 1
d177 1
a177 1
	xu_ptr_ungrab();
d477 2
a478 1
		(void)xu_ptr_regrab(MENUGRABMASK, Conf.cursor[CF_NORMAL]);
d480 4
a483 2
	} else
		(void)xu_ptr_regrab(MENUGRABMASK, Conf.cursor[CF_DEFAULT]);
@


1.94
log
@Mechanical change: move screen menu bits to their own struct.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.93 2016/09/28 17:06:33 okan Exp $
d641 32
@


1.93
log
@Inline Xft draw and extents wrappers; too much abstraction.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.92 2016/09/20 19:58:54 okan Exp $
d121 2
a122 2
	XSelectInput(X_Dpy, sc->menuwin, evmask);
	XMapRaised(X_Dpy, sc->menuwin);
d124 1
a124 1
	if (xu_ptr_grab(sc->menuwin, MENUGRABMASK,
d126 1
a126 1
		XUnmapWindow(X_Dpy, sc->menuwin);
d131 1
a131 1
	XSetInputFocus(X_Dpy, sc->menuwin, RevertToPointerRoot, CurrentTime);
d134 1
a134 1
	XGrabKeyboard(X_Dpy, sc->menuwin, True,
d140 1
a140 1
		XWindowEvent(X_Dpy, sc->menuwin, evmask, &e);
d177 2
a178 2
	XMoveResizeWindow(X_Dpy, sc->menuwin, 0, 0, 1, 1);
	XUnmapWindow(X_Dpy, sc->menuwin);
d405 2
a406 2
	XClearWindow(X_Dpy, sc->menuwin);
	XMoveResizeWindow(X_Dpy, sc->menuwin, mc->geom.x, mc->geom.y,
d410 1
a410 1
		XftDrawStringUtf8(sc->xftdraw,
d425 1
a425 1
		XftDrawStringUtf8(sc->xftdraw,
d453 1
a453 1
	XftDrawRect(sc->xftdraw, &sc->xftcolor[color], 0,
d457 1
a457 1
	XftDrawStringUtf8(sc->xftdraw,
@


1.92
log
@Allow ctrl-[ for abort (esc); from Benjamin Scher Purcell
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.91 2016/08/28 15:23:24 okan Exp $
d337 1
d356 5
a360 2
		mc->geom.w = xu_xft_width(sc->xftfont, mc->dispstr,
		    strlen(mc->dispstr));
d372 5
a376 2
		mc->geom.w = MAX(mc->geom.w, xu_xft_width(sc->xftfont,
		    mi->print, MIN(strlen(mi->print), MENU_MAXENTRY)));
d410 4
a413 2
		xu_xft_draw(sc, mc->dispstr, CWM_COLOR_MENU_FONT,
		    0, sc->xftfont->ascent);
d425 4
a428 1
		xu_xft_draw(sc, mi->print, CWM_COLOR_MENU_FONT, 0, y);
d457 4
a460 2
	xu_xft_draw(sc, mi->print, color,
	    0, (sc->xftfont->height + 1) * entry + sc->xftfont->ascent + 1);
@


1.91
log
@Enable the use of numpad Enter key on menus; from Henrique N. Lengler.

ok beck phessler
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.90 2016/04/28 16:28:38 okan Exp $
d567 3
@


1.90
log
@If supplied format to menuq_add() is NULL, fill text with an empty
string; found by Christian Neukirchen.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.89 2015/11/11 14:22:01 okan Exp $
d526 1
@


1.89
log
@Partial revert of replacing screen_area() with region_find(); until a
fix for a regression is found; this bug has been around for a long time
it seems, but this change exposed it. Likely need to track clients in to
and out of regions.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.88 2015/11/09 20:03:29 okan Exp $
d604 4
a607 1
	(void)vsnprintf(mi->text, sizeof(mi->text), fmt, ap);
@


1.88
log
@Extend region to include both view and work areas; switch to
region_find() which no longer needs to recalculate gap each time
a client (or menu) is created or altered. If no RandR, fall back
to display dimensions while building regions instead of during
execution.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.87 2015/07/12 14:21:09 okan Exp $
a333 1
	struct region_ctx	*rc;
d374 1
a374 2
	rc = region_find(sc, mc->geom.x, mc->geom.y);
	area = rc->work;
@


1.87
log
@simplify menu print text
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.86 2015/07/01 14:36:42 okan Exp $
d334 1
d375 2
a376 1
	area = screen_area(sc, mc->geom.x, mc->geom.y, CWM_GAP);
@


1.86
log
@style
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.85 2015/06/30 18:42:50 okan Exp $
d362 1
a362 3
		char *text;

		if (mc->print != NULL) {
d364 3
a366 5
			text = mi->print;
		} else {
			mi->print[0] = '\0';
			text = mi->text;
		}
d368 2
a369 2
		mc->geom.w = MAX(mc->geom.w, xu_xft_width(sc->xftfont, text,
		    MIN(strlen(text), MENU_MAXENTRY)));
a409 1
		char *text = (mi->print[0] != '\0') ? mi->print : mi->text;
d416 1
a416 1
		xu_xft_draw(sc, text, CWM_COLOR_MENU_FONT, 0, y);
a428 1
	char 			*text;
a440 1
	text = (mi->print[0] != '\0') ? mi->print : mi->text;
d445 1
a445 1
	xu_xft_draw(sc, text, color,
@


1.85
log
@style and spacing nits
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.84 2015/06/26 17:17:46 okan Exp $
d414 1
a414 2
		char *text = mi->print[0] != '\0' ?
		    mi->print : mi->text;
d446 2
a447 2
	color = active ? CWM_COLOR_MENU_FG : CWM_COLOR_MENU_BG;
	text = mi->print[0] != '\0' ? mi->print : mi->text;
d451 1
a451 1
	color = active ? CWM_COLOR_MENU_FONT_SEL : CWM_COLOR_MENU_FONT;
@


1.84
log
@Mechanical change from xinerama to region backed areas.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.83 2015/06/08 15:08:44 okan Exp $
d75 1
a75 1
static struct menu 	*menu_complete_path(struct menu_ctx *);
d187 1
d195 1
a195 1
	if ((mi = menu_filter(mc->sc, &menuq, mc->searchstr, NULL,
@


1.83
log
@clean up
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.82 2015/06/05 18:43:36 okan Exp $
d334 1
a334 1
	struct geom		 xine;
d377 3
a379 3
	xine = screen_find_xinerama(sc, mc->geom.x, mc->geom.y, CWM_GAP);
	xine.w += xine.x - Conf.bwidth * 2;
	xine.h += xine.y - Conf.bwidth * 2;
d385 11
a395 11
	if (mc->geom.x + mc->geom.w >= xine.w)
		mc->geom.x = xine.w - mc->geom.w;
	if (mc->geom.x < xine.x) {
		mc->geom.x = xine.x;
		mc->geom.w = MIN(mc->geom.w, (xine.w - xine.x));
	}
	if (mc->geom.y + mc->geom.h >= xine.h)
		mc->geom.y = xine.h - mc->geom.h;
	if (mc->geom.y < xine.y) {
		mc->geom.y = xine.y;
		mc->geom.h = MIN(mc->geom.h, (xine.h - xine.y));
d418 1
a418 1
		if (mc->geom.y + y > xine.h)
@


1.82
log
@use the same geometry struct in menus as everywhere else
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.81 2015/06/05 15:01:51 okan Exp $
d96 1
a96 4
	xu_ptr_getpos(sc->rootwin, &mc.geom.x, &mc.geom.y);

	xsave = mc.geom.x;
	ysave = mc.geom.y;
d100 5
a104 7
	if (prompt != NULL) {
		evmask = MENUMASK | KEYMASK; /* accept keys as well */
		(void)strlcpy(mc.promptstr, prompt, sizeof(mc.promptstr));
		mc.hasprompt = 1;
	} else {
		evmask = MENUMASK;
	}
d114 6
a119 3
	mc.match = match;
	mc.print = print;
	mc.entry = mc.prev = -1;
d341 1
a341 2
				TAILQ_INSERT_TAIL(resultq, mi,
				    resultentry);
@


1.81
log
@add a flag to indicate a menu list instead of overloading 'prompt'
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.80 2015/06/05 14:54:04 okan Exp $
a57 2
	int			 height;
	int			 width;
d60 1
a60 2
	int			 x;
	int			 y;
d96 1
a96 1
	xu_ptr_getpos(sc->rootwin, &mc.x, &mc.y);
d98 2
a99 2
	xsave = mc.x;
	ysave = mc.y;
d175 1
a175 1
	if (xcur == mc.x && ycur == mc.y)
d352 2
a353 2
	mc->width = 0;
	mc->height = 0;
d357 1
a357 1
		mc->width = xu_xft_width(sc->xftfont, mc->dispstr,
d359 1
a359 1
		mc->height = sc->xftfont->height + 1;
d374 1
a374 1
		mc->width = MAX(mc->width, xu_xft_width(sc->xftfont, text,
d376 1
a376 1
		mc->height += sc->xftfont->height + 1;
d380 1
a380 1
	xine = screen_find_xinerama(sc, mc->x, mc->y, CWM_GAP);
d384 2
a385 2
	xsave = mc->x;
	ysave = mc->y;
d388 11
a398 11
	if (mc->x + mc->width >= xine.w)
		mc->x = xine.w - mc->width;
	if (mc->x < xine.x) {
		mc->x = xine.x;
		mc->width = MIN(mc->width, (xine.w - xine.x));
	}
	if (mc->y + mc->height >= xine.h)
		mc->y = xine.h - mc->height;
	if (mc->y < xine.y) {
		mc->y = xine.y;
		mc->height = MIN(mc->height, (xine.h - xine.y));
d401 2
a402 2
	if (mc->x != xsave || mc->y != ysave)
		xu_ptr_setpos(sc->rootwin, mc->x, mc->y);
d405 2
a406 2
	XMoveResizeWindow(X_Dpy, sc->menuwin, mc->x, mc->y,
	    mc->width, mc->height);
d421 1
a421 1
		if (mc->y + y > xine.h)
d452 1
a452 1
	    (sc->xftfont->height + 1) * entry, mc->width,
d508 1
a508 1
	if (x < 0 || x > mc->width || y < 0 ||
@


1.80
log
@redundant check for 'list'
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.79 2015/03/28 22:09:10 okan Exp $
d112 3
a115 1
	}
@


1.79
log
@Reshuffle and slightly simplify menu_complete_path(), removing an
allocation, for tab-completion; checked by Alexander Polakov as well.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.78 2015/01/19 14:54:16 okan Exp $
d341 1
a341 1
		if (TAILQ_EMPTY(resultq) && mc->list) {
@


1.78
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.77 2014/09/07 19:27:30 okan Exp $
a191 1
	char			*path = NULL;
a192 1
	path = xcalloc(1, sizeof(mr->text));
d201 5
a205 1
		strlcpy(path, mi->text, sizeof(mi->text));
a209 6
	if (path[0] != '\0')
		snprintf(mr->text, sizeof(mr->text), "%s \"%s\"",
			mc->searchstr, path);
	else if (!mr->abort)
		strlcpy(mr->text,  mc->searchstr, sizeof(mr->text));
	free(path);
@


1.77
log
@more style nits
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.76 2014/09/06 16:18:08 okan Exp $
d22 1
a22 1
#include <sys/param.h>
d28 1
@


1.76
log
@style nit
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.75 2014/02/01 19:28:46 okan Exp $
d129 1
a129 1
		return (NULL);
d183 1
a183 1
	return (mi);
d213 1
a213 1
	return (mr);
d228 1
a228 1
		return (NULL);
d269 1
a269 1
		return (mi);
d284 1
a284 1
				return (menu_complete_path(mc));
d309 1
a309 1
		return (mi);
d332 1
a332 1
	return (NULL);
d500 1
a500 1
	return (mi);
d520 1
a520 1
	return (entry);
d600 1
a600 1
		return (0);
d603 1
a603 1
		return (-1);
d605 1
a605 1
	return (0);
@


1.75
log
@Take menu's bwidth into account for position/size; reported by Thomas Adam.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.74 2014/01/21 15:42:45 okan Exp $
d263 1
a263 1
			mi = xmalloc(sizeof *mi);
d305 1
a305 1
		mi = xmalloc(sizeof *mi);
@


1.74
log
@Sprinkle a few more const; from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.73 2014/01/20 18:58:03 okan Exp $
d385 2
a386 2
	xine.w += xine.x;
	xine.h += xine.y;
@


1.73
log
@Add a function that adds an entry to a menuq, normalizing a common code
path; from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.72 2014/01/03 15:29:06 okan Exp $
d81 2
a82 2
menu_filter(struct screen_ctx *sc, struct menu_q *menuq, char *prompt,
    char *initial, int flags,
@


1.72
log
@use consistent types
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.71 2014/01/02 22:49:10 okan Exp $
d28 1
d606 16
@


1.71
log
@calculate proper menu width/height on the first Expose event; 'jump' (while using gap) noticed by Christian Neukirchen
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.70 2013/12/17 16:10:43 okan Exp $
d525 2
a526 2
	KeySym	 ks;
	u_int 	 state = ev->state;
@


1.70
log
@replace with memset
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.69 2013/12/13 22:39:13 okan Exp $
d395 1
a395 1
		mc->width = xine.w - xine.x;
d401 1
a401 1
		mc->height = xine.h - xine.y;
@


1.69
log
@Teach screen_find_xinerama() to apply gap only when told to do so;
adjust callers.  Needed for an upcoming feature.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.68 2013/12/02 20:01:19 okan Exp $
d95 1
a95 1
	bzero(&mc, sizeof(mc));
@


1.68
log
@When we receive a NotionNotify event, there's no need to (incorrectly
might I add) redraw the top menu selection.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.67 2013/12/02 19:49:26 okan Exp $
d383 1
a383 1
	xine = screen_find_xinerama(sc, mc->x, mc->y);
@


1.67
log
@Always highlight the first menu item (helpful to see selected items when
not using a mouse and therefore not generating Expose/MotionNotify
events); from Thomas Adam.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.66 2013/06/17 17:11:10 okan Exp $
a477 3

	if (mc->hasprompt)
		menu_draw_entry(mc, resultq, 1, 1);
@


1.66
log
@move Cursors into conf.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.65 2013/05/20 21:32:00 okan Exp $
d430 2
a431 4
	if (mc->hasprompt && n > 1 && (mc->searchstr[0] != '\0')) {
		mc->entry = 1;
		menu_draw_entry(mc, resultq, mc->entry, 1);
	}
@


1.65
log
@stray whitespace
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.64 2013/05/20 20:21:04 okan Exp $
d125 2
a126 1
	if (xu_ptr_grab(sc->menuwin, MENUGRABMASK, Cursor_question) < 0) {
d476 1
a476 1
		(void)xu_ptr_regrab(MENUGRABMASK, Cursor_normal);
d479 1
a479 1
		(void)xu_ptr_regrab(MENUGRABMASK, Cursor_default);
@


1.64
log
@- configure menuwin with the screen, then create the xft drawable using
  the menu window since that's the only place on which we draw
- elminate the need to change the drawable on every font draw
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.63 2013/05/20 20:04:36 okan Exp $
d454 1
a454 1
	text = mi->print[0] != '\0' ?  mi->print : mi->text;
@


1.63
log
@no reason to pass around *sc when it's already in menu_ctx.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.62 2013/05/19 23:38:21 okan Exp $
a78 9
void
menu_init(struct screen_ctx *sc)
{
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1,
	    Conf.bwidth,
	    sc->xftcolor[CWM_COLOR_MENU_FG].pixel,
	    sc->xftcolor[CWM_COLOR_MENU_BG].pixel);
}

d411 1
a411 1
		xu_xft_draw(sc, mc->dispstr, sc->menuwin, CWM_COLOR_MENU_FONT,
d426 1
a426 1
		xu_xft_draw(sc, text, sc->menuwin, CWM_COLOR_MENU_FONT, 0, y);
d459 1
a459 1
	xu_xft_draw(sc, text, sc->menuwin, color,
@


1.62
log
@move the 2 small font helper functions to xutil.c
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.61 2013/05/14 12:35:56 okan Exp $
d68 1
a68 1
			     struct screen_ctx *, struct menu_q *);
d70 4
a73 6
			     struct screen_ctx *, struct menu_q *);
static void		 menu_draw(struct screen_ctx *, struct menu_ctx *,
			     struct menu_q *, struct menu_q *);
static void 		 menu_draw_entry(struct screen_ctx *, struct menu_ctx *,
			     struct menu_q *, int, int);
static int		 menu_calc_entry(struct screen_ctx *, struct menu_ctx *,
d75 1
d77 1
a77 2
static int		 menu_keycode(XKeyEvent *, enum ctltype *,
			     char *);
d158 1
a158 1
			menu_draw(sc, &mc, menuq, &resultq);
d161 1
a161 1
			menu_handle_move(&e, &mc, sc, &resultq);
d164 1
a164 1
			if ((mi = menu_handle_release(&e, &mc, sc, &resultq))
d343 1
a343 2
menu_draw(struct screen_ctx *sc, struct menu_ctx *mc, struct menu_q *menuq,
    struct menu_q *resultq)
d345 1
d440 1
a440 1
		menu_draw_entry(sc, mc, resultq, mc->entry, 1);
d445 2
a446 2
menu_draw_entry(struct screen_ctx *sc, struct menu_ctx *mc,
    struct menu_q *resultq, int entry, int active)
d448 4
a451 3
	struct menu	*mi;
	char 		*text;
	int		 color, i = 0;
d473 1
a473 2
menu_handle_move(XEvent *e, struct menu_ctx *mc, struct screen_ctx *sc,
    struct menu_q *resultq)
d476 1
a476 1
	mc->entry = menu_calc_entry(sc, mc, e->xbutton.x, e->xbutton.y);
d482 1
a482 1
		menu_draw_entry(sc, mc, resultq, mc->prev, 0);
d485 1
a485 1
		menu_draw_entry(sc, mc, resultq, mc->entry, 1);
d490 1
a490 1
		menu_draw_entry(sc, mc, resultq, 1, 1);
d494 1
a494 2
menu_handle_release(XEvent *e, struct menu_ctx *mc, struct screen_ctx *sc,
    struct menu_q *resultq)
d496 2
a497 2
	struct menu	*mi;
	int		 entry, i = 0;
d499 1
a499 1
	entry = menu_calc_entry(sc, mc, e->xbutton.x, e->xbutton.y);
d516 1
a516 1
menu_calc_entry(struct screen_ctx *sc, struct menu_ctx *mc, int x, int y)
d518 2
a519 1
	int	 entry;
@


1.61
log
@- let callers of font_draw figure out (and pass) the color instead of an
  'active' flag.
- use strlen() inside of font_draw; the only instance where it wasn't
  used happened to be ignored on a subsequent draw.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.60 2013/05/10 16:10:40 okan Exp $
d370 1
a370 1
		mc->width = font_width(sc->xftfont, mc->dispstr,
d387 1
a387 1
		mc->width = MAX(mc->width, font_width(sc->xftfont, text,
d422 1
a422 1
		font_draw(sc, mc->dispstr, sc->menuwin, CWM_COLOR_MENU_FONT,
d437 1
a437 1
		font_draw(sc, text, sc->menuwin, CWM_COLOR_MENU_FONT, 0, y);
d469 1
a469 1
	font_draw(sc, text, sc->menuwin, color,
@


1.60
log
@spacing
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.59 2013/05/07 01:35:41 okan Exp $
d422 1
a422 1
		font_draw(sc, mc->dispstr, strlen(mc->dispstr), sc->menuwin, 0,
d437 1
a437 2
		font_draw(sc, text, MIN(strlen(text), MENU_MAXENTRY),
		    sc->menuwin, 0, 0, y);
d468 2
a469 1
	font_draw(sc, text, strlen(text), sc->menuwin, active,
@


1.59
log
@border width/color makes sense for some, so put it back
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.58 2013/05/06 16:00:34 okan Exp $
d200 1
a200 1
	char *path = NULL;
@


1.58
log
@border width/color makes no sense on menuwin
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.57 2013/05/02 20:18:35 okan Exp $
d84 3
a86 1
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1, 0, 0,
@


1.57
log
@- no need to position and size the menu window before an Expose event
  since we'll be calculating required size later anyway; allows us to
  consolidate all prompt/display/search string building goop into
  menu_draw.
- reset the pos/size of menuwin when leaving a menu.
- reverse the 'prompt' NULL check to be consistent with 'initial' one
  and fix a whitespace nit while here.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.56 2013/05/02 19:41:52 okan Exp $
d84 1
a84 3
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1,
	    Conf.bwidth,
	    sc->xftcolor[CWM_COLOR_MENU_FG].pixel,
@


1.56
log
@zap leftover debug printf
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.55 2013/05/02 17:25:15 okan Exp $
d45 1
a45 1
	struct screen_ctx 	*sc;
d115 5
a119 1
	if (prompt == NULL) {
a120 1
		mc.promptstr[0] = '\0';
a121 9
	} else {
		evmask = MENUMASK | KEYMASK; /* only accept keys if prompt */
		(void)snprintf(mc.promptstr, sizeof(mc.promptstr), "%s%s",
		    prompt, PROMPT_SCHAR);
		(void)snprintf(mc.dispstr, sizeof(mc.dispstr), "%s%s%s",
		    mc.promptstr, mc.searchstr, PROMPT_ECHAR);
		mc.width = font_width(sc->xftfont, mc.dispstr,
		    strlen(mc.dispstr));
		mc.hasprompt = 1;
a122 1
	mc.height = sc->xftfont->height + 1;
a132 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, mc.x, mc.y, mc.width, mc.height);
d188 1
d368 2
a369 2
		(void)snprintf(mc->dispstr, sizeof(mc->dispstr), "%s%s%s",
		    mc->promptstr, mc->searchstr, PROMPT_ECHAR);
@


1.55
log
@no need for font_{ascent,descent,height} wrappers; limit font_width to
just requiring xftfont.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.54 2013/04/08 13:02:31 okan Exp $
a167 1
			fprintf(stderr, "expose\n");
@


1.54
log
@consistency
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.53 2013/04/08 00:56:21 okan Exp $
d125 2
a126 1
		mc.width = font_width(sc, mc.dispstr, strlen(mc.dispstr));
d129 1
d140 1
a140 2
	XMoveResizeWindow(X_Dpy, sc->menuwin, mc.x, mc.y, mc.width,
	    font_height(sc));
d168 1
d378 3
a380 2
		mc->width = font_width(sc, mc->dispstr, strlen(mc->dispstr));
		mc->height = font_height(sc);
d395 1
a395 1
		mc->width = MAX(mc->width, font_width(sc, text,
d397 1
a397 1
		mc->height += font_height(sc);
d431 1
a431 1
		    0, font_ascent(sc));
d439 1
a439 1
		int y = n * font_height(sc) + font_ascent(sc) + 1;
d475 2
a476 2
	    font_height(sc) * entry, mc->width,
	    font_height(sc) + font_descent(sc));
d478 1
a478 1
	    0, font_height(sc) * entry + font_ascent(sc) + 1);
d531 1
a531 1
	entry = y / font_height(sc);
d535 2
a536 1
	    y > font_height(sc) * mc->num || entry < 0 || entry >= mc->num)
@


1.53
log
@missing prototype
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.52 2013/04/05 17:07:25 okan Exp $
d212 1
@


1.52
log
@zap stray whitespace
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.51 2013/01/07 21:53:23 okan Exp $
d77 1
@


1.51
log
@fix menu/client placement in panning setups; XineramaQueryScreens gives
us the width of the psuedo screen, but here we need the edge instead
(xmax/ymax); just re-use w/h here for now.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.50 2013/01/02 16:26:34 okan Exp $
d62 2
a63 2
    	void (*match)(struct menu_q *, struct menu_q *, char *);
    	void (*print)(struct menu *, int);
d78 1
a78 1
                             char *);
d91 1
a91 1
    char *initial, int flags, 
d220 1
a220 1
	if (path[0] != '\0') 
d289 1
a289 1
			/* 
d299 1
a299 1
			/* 
@


1.50
log
@have screen_find_xinerama() return struct geom *reliably* instead of
XineramaScreenInfo; simplifies goop around the callers.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.49 2013/01/02 02:19:20 okan Exp $
d397 2
@


1.49
log
@more variable consistency
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.48 2012/12/17 14:32:39 okan Exp $
d353 1
a353 2
	XineramaScreenInfo	*xine;
	int			 x_org, y_org, xmax, ymax;
a396 10
	if (xine) {
		x_org = xine->x_org;
		y_org = xine->y_org;
		xmax = xine->x_org + xine->width;
		ymax = xine->y_org + xine->height;
	} else {
		x_org = y_org = 0;
		xmax = sc->view.w;
		ymax = sc->view.h;
	}
d402 11
a412 11
	if (mc->x + mc->width >= xmax)
		mc->x = xmax - mc->width;
	if (mc->x < x_org) {
		mc->x = x_org;
		mc->width = xmax - x_org;
	}
	if (mc->y + mc->height >= ymax)
		mc->y = ymax - mc->height;
	if (mc->y < y_org) {
		mc->y = y_org;
		mc->height = ymax - y_org;
d435 1
a435 1
		if (mc->y + y > ymax)
@


1.48
log
@create and use menuq_clear() helper; from Tiago Cunha
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.47 2012/12/17 02:53:29 okan Exp $
d354 1
a354 1
	int			 xmin, xmax, ymin, ymax;
d399 2
a400 1
		xmin = xine->x_org;
a401 1
		ymin = xine->y_org;
d404 1
a404 1
		xmin = ymin = 0;
d415 3
a417 3
	if (mc->x < xmin) {
		mc->x = xmin;
		mc->width = xmax - xmin;
d421 3
a423 3
	if (mc->y < ymin) {
		mc->y = ymin;
		mc->height = ymax - ymin;
@


1.47
log
@knf
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.46 2012/12/17 02:28:45 okan Exp $
d218 1
a218 4
	while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
		TAILQ_REMOVE(&menuq, mi, entry);
		free(mi);
	}
d631 11
@


1.46
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.45 2012/11/14 21:12:24 okan Exp $
a475 1

d478 1
d480 1
a480 2
	text = mi->print[0] != '\0' ?
		    mi->print : mi->text;
d482 2
a483 2
			font_height(sc) * entry, mc->width,
			font_height(sc) + font_descent(sc));
d485 1
a485 1
			0, font_height(sc) * entry + font_ascent(sc) + 1);
d505 1
@


1.45
log
@tab-complete buglet fix: once exec_path is completed, allow for
subsequent completion; from Alexander Polakov
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.44 2012/11/09 03:52:02 okan Exp $
d68 1
a68 1
			     struct screen_ctx *);
d73 2
a82 2
	XGCValues	 gv;

d85 2
a86 10
	    sc->color[CWM_COLOR_FG_MENU].pixel,
	    sc->color[CWM_COLOR_BG_MENU].pixel);

	gv.foreground =
	    sc->color[CWM_COLOR_FG_MENU].pixel^sc->color[CWM_COLOR_BG_MENU].pixel;
	gv.background = sc->color[CWM_COLOR_BG_MENU].pixel;
	gv.function = GXxor;

	sc->gc = XCreateGC(X_Dpy, sc->menuwin,
	    GCForeground|GCBackground|GCFunction, &gv);
d169 1
a169 1
			menu_handle_move(&e, &mc, sc);
d437 2
a438 2
		font_draw(sc, mc->dispstr, strlen(mc->dispstr), sc->menuwin,
		    0, font_ascent(sc) + 1);
d453 1
a453 1
		    sc->menuwin, 0, y);
d456 5
d462 25
a486 7
	if (mc->hasprompt && n > 1 && (mc->searchstr[0] != '\0'))
		XFillRectangle(X_Dpy, sc->menuwin, sc->gc,
		    0, font_height(sc), mc->width, font_height(sc));

	if (mc->noresult)
		XFillRectangle(X_Dpy, sc->menuwin, sc->gc,
		    0, 0, mc->width, font_height(sc));
d490 2
a491 1
menu_handle_move(XEvent *e, struct menu_ctx *mc, struct screen_ctx *sc)
d496 3
d500 1
a500 2
		XFillRectangle(X_Dpy, sc->menuwin, sc->gc, 0,
		    font_height(sc) * mc->prev, mc->width, font_height(sc));
d503 1
a503 2
		XFillRectangle(X_Dpy, sc->menuwin, sc->gc, 0,
		    font_height(sc) * mc->entry, mc->width, font_height(sc));
d506 2
d541 1
a541 1
	if (x <= 0 || x > mc->width || y <= 0 ||
@


1.44
log
@sort
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.43 2012/11/07 20:34:39 okan Exp $
a301 1
			 * - There's only one result
a305 1
			    (TAILQ_NEXT(mi, resultentry) == NULL) &&
@


1.43
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.42 2012/11/07 14:39:44 okan Exp $
d25 1
d28 1
a30 1
#include <stdio.h>
a31 1
#include <ctype.h>
@


1.42
log
@tab completion support for menus; from Alexander Polakov.

ok sthen@@ on an older incarnation
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.41 2012/10/31 19:30:19 okan Exp $
d191 1
a191 1
		xfree(mi);
d228 1
a228 1
		xfree(mi);
d236 1
a236 1
	xfree(path);
@


1.41
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.40 2012/10/23 16:13:59 okan Exp $
d31 1
d41 1
a41 1
	CTL_ABORT, CTL_ALL
d45 1
d59 1
d99 1
a99 1
    char *initial, int dummy,
d120 2
d189 2
a190 1
	if (dummy == 0 && mi->dummy) { /* no mouse based match */
d209 32
d298 29
d553 3
@


1.40
log
@comment what this whole bit does, not just part of it.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.39 2012/10/23 16:08:59 okan Exp $
a79 2
	if (sc->menuwin)
		XDestroyWindow(X_Dpy, sc->menuwin);
a89 2
	if (sc->gc)
		XFreeGC(X_Dpy, sc->gc);
@


1.39
log
@add a height to struct menu and use it in the most obvious of places.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.38 2012/10/23 15:50:15 okan Exp $
d362 1
a368 1

a370 1
	/* never hide the top of the menu */
@


1.38
log
@treat menu width the same as the height is treated when deciding its
max size and location; partially from a diff from Alexander Polakov.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.37 2012/10/23 15:32:38 okan Exp $
d54 1
d305 1
a305 1
	int			 n, dy, xsave, ysave;
d321 1
a321 1
	dy = 0;
d326 1
a326 1
		dy = font_height(sc);
d343 1
a343 1
		dy += font_height(sc);
d369 2
a370 2
	if (mc->y + dy >= ymax)
		mc->y = ymax - dy;
d374 1
a374 1
		dy = ymax - ymin;
d381 2
a382 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, mc->x, mc->y, mc->width, dy);
@


1.37
log
@Stop drawing when menu doesn't fit inside the screen; picked from a
larger diff from Alexander Polakov.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.36 2012/08/07 14:05:49 okan Exp $
d361 3
a363 1
	if (mc->x < xmin)
d365 2
a366 2
	else if (mc->x + mc->width >= xmax)
		mc->x = xmax - mc->width;
@


1.36
log
@support multibyte input to menu code; from Alexander Polakov with a tiny tweak.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.35 2012/07/13 15:21:35 okan Exp $
d390 5
d397 1
a397 1
		    sc->menuwin, 0, n * font_height(sc) + font_ascent(sc) + 1);
@


1.35
log
@convert xmax/ymax uses to view geometry.
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.34 2012/05/16 01:04:36 okan Exp $
d71 1
a71 1
static int		 menu_keycode(KeyCode, u_int, enum ctltype *,
d211 1
a211 1
	char		 chr;
d213 2
d216 1
a216 1
	if (menu_keycode(e->xkey.keycode, e->xkey.state, &ctl, &chr) < 0)
d222 5
a226 1
			mc->searchstr[len - 1] = '\0';
d276 1
a276 5
	if (chr != '\0') {
		char str[2];

		str[0] = chr;
		str[1] = '\0';
d278 1
a278 1
		(void)strlcat(mc->searchstr, str, sizeof(mc->searchstr));
d464 1
a464 1
menu_keycode(KeyCode kc, u_int state, enum ctltype *ctl, char *chr)
d466 2
a467 1
	int	 ks;
d470 1
a470 1
	*chr = '\0';
d472 2
a473 1
	ks = XkbKeycodeToKeysym(X_Dpy, kc, 0, (state & ShiftMask) ? 1 : 0);
d539 1
a539 5
	/*
	 * For regular characters, only (part of, actually) Latin 1
	 * for now.
	 */
	if (ks < 0x20 || ks > 0x07e)
a540 2

	*chr = (char)ks;
@


1.34
log
@convert from deprecated XKeycodeToKeysym to XkbKeycodeToKeysym

ok sthen@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.33 2011/09/08 12:00:50 okan Exp $
d352 2
a353 2
		xmax = sc->xmax;
		ymax = sc->ymax;
@


1.33
log
@reinit menu on reload; from Alexander Polakov.  needed for catching
upcoming menu config changes.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.32 2011/07/25 15:41:05 okan Exp $
d469 1
a469 1
	ks = XKeycodeToKeysym(X_Dpy, kc, (state & ShiftMask) ? 1 : 0);
@


1.32
log
@use the menu border; from Alexander Polakov, but with the existing define.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.31 2011/07/25 15:10:24 okan Exp $
d79 2
d91 2
@


1.31
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.30 2011/07/23 13:09:11 okan Exp $
d79 3
a81 2
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0, 1, 1, 0,
	    sc->color[CWM_COLOR_BG_MENU].pixel,
@


1.30
log
@Clarify defines and make them not look like non-local ones; started by a
small diff from Thomas Pfaff.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.29 2011/06/27 12:46:54 okan Exp $
d121 4
a124 4
		snprintf(mc.promptstr, sizeof(mc.promptstr), "%s%s", prompt,
		    PROMPT_SCHAR);
		snprintf(mc.dispstr, sizeof(mc.dispstr), "%s%s%s", mc.promptstr,
		    mc.searchstr, PROMPT_ECHAR);
d130 1
a130 1
		strlcpy(mc.searchstr, initial, sizeof(mc.searchstr));
d271 1
a271 1
		strlcat(mc->searchstr, str, sizeof(mc->searchstr));
d315 1
a315 1
		snprintf(mc->dispstr, sizeof(mc->dispstr), "%s%s%s",
d408 1
a408 1
		xu_ptr_regrab(MENUGRABMASK, Cursor_normal);
d412 1
a412 1
		xu_ptr_regrab(MENUGRABMASK, Cursor_default);
@


1.29
log
@UTF8-ify, from Alexander Polakov, but without setlocale(), after
feedback from stsp@@ - thanks!

'go for it' oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.28 2011/06/24 06:52:23 okan Exp $
d116 1
a116 1
		evmask = MenuMask;
d120 1
a120 1
		evmask = MenuMask | KeyMask; /* only accept keys if prompt */
d143 1
a143 1
	if (xu_ptr_grab(sc->menuwin, MenuGrabMask, Cursor_question) < 0) {
d408 1
a408 1
		xu_ptr_regrab(MenuGrabMask, Cursor_normal);
d412 1
a412 1
		xu_ptr_regrab(MenuGrabMask, Cursor_default);
@


1.28
log
@add 'normal' cursor and shuffle the others we use to make a bit more
sense and to be slightly less un-expected.  from Alexander Polakov.
re-use 'normal' cursor now instead XC_hand1 for menu selection.  i
really wish X had real docs and made sense.

ok on earlier diff with '?' removed (but it's back now) oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: menu.c,v 1.27 2011/05/11 13:53:51 okan Exp $
d34 2
a35 2
#define PROMPT_SCHAR	''
#define PROMPT_ECHAR	''
d121 1
a121 1
		snprintf(mc.promptstr, sizeof(mc.promptstr), "%s%c", prompt,
d123 1
a123 1
		snprintf(mc.dispstr, sizeof(mc.dispstr), "%s%s%c", mc.promptstr,
d315 1
a315 1
		snprintf(mc->dispstr, sizeof(mc->dispstr), "%s%s%c",
@


1.27
log
@tag and comment cleanup; ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD$
d408 1
a408 1
		xu_ptr_regrab(MenuGrabMask, Cursor_select);
@


1.26
log
@make the menu window aware of xinerama info; this makes the menu stay
within the current screen, like other cwm window placements and
mutations (vmax/hmax/max) - from Sviatoslav Chagaev.

ok oga@@
@
text
@d2 2
d18 2
@


1.25
log
@warp the pointer back, iff we don't move the mouse, once we are done
with the menu; idea and initial from Sviatoslav Chagaev.

discussion with and ok oga@@
@
text
@d290 4
a293 2
	struct menu	*mi;
	int		 n, dy, xsave, ysave;
d335 12
a348 4
	if (mc->x < 0)
		mc->x = 0;
	else if (mc->x + mc->width >= sc->xmax)
		mc->x = sc->xmax - mc->width;
d350 7
a356 2
	if (mc->y + dy >= sc->ymax)
		mc->y = sc->ymax - dy;
d358 4
a361 2
        if (mc->y < 0)
                mc->y = 0;
@


1.24
log
@we should re-focus the client and ungrab the ptr even if we don't have a
mouse based match (i.e. in the kbd no match case).  update the comment
as well.

ok oga@@
@
text
@d100 1
d108 3
d184 4
@


1.23
log
@fix nousance of always highlighting the first entry even when there is
no match (seen in the ctrl-a case)

ok oga@@
@
text
@d174 2
a175 2
	if (dummy == 0 && mi->dummy) { /* no match */
		xfree (mi);
a176 2
		xu_ptr_ungrab();
		XSetInputFocus(X_Dpy, focuswin, focusrevert, CurrentTime);
d179 3
a393 1
	xu_ptr_ungrab();
@


1.22
log
@move the default case to the end.

ok oga@@
@
text
@d359 1
a359 1
	if (mc->hasprompt && n > 1)
@


1.21
log
@move the single keycode function directly into the menu code.

ok oga@@
@
text
@a152 2
		default:
			break;
d168 2
@


1.20
log
@preserve labels after an edit action is aborted; extending the menu
struct just for this is the least intrusive approach until the menu code
is reviewed.

inspired by Thomas Pfaff's report on tech@@

ok oga@@
@
text
@d33 6
d67 2
d196 1
a196 2
	if (input_keycodetrans(e->xkey.keycode, e->xkey.state,
	    &ctl, &chr) < 0)
d425 86
@


1.19
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d226 1
d239 1
@


1.18
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 10
@


1.17
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@a17 1
#include "headers.h"
@


1.16
log
@start fixing screen_ctx usage, for it is utterly broken.  bring font
into screen_ctx and start passing screen_ctx around to in order get rid
of Curscreen; fixup per-screen config colors the same way.

diff mostly from oga@@, with a bit harsher reaction to the state of screen_ctx.

"please commit" oga@@
@
text
@d72 2
a73 1
menu_filter(struct menu_q *menuq, char *prompt, char *initial, int dummy,
a76 1
	struct screen_ctx	*sc;
a82 2

	sc = screen_current();
@


1.15
log
@fix off-by-one where a mere click would select the first item inside a menu

from Thomas Pfaff

ok oga@@
@
text
@d102 1
a102 1
		mc.width = font_width(mc.dispstr, strlen(mc.dispstr));
d116 1
a116 1
	    font_height());
d286 2
a287 2
		mc->width = font_width(mc->dispstr, strlen(mc->dispstr));
		dy = font_height();
d302 1
a302 1
		mc->width = MAX(mc->width, font_width(text,
d304 1
a304 1
		dy += font_height();
d329 1
a329 1
		    0, font_ascent() + 1);
d339 1
a339 1
		    sc->menuwin, 0, n * font_height() + font_ascent() + 1);
d345 1
a345 1
		    0, font_height(), mc->width, font_height());
d349 1
a349 1
		    0, 0, mc->width, font_height());
d360 1
a360 1
		    font_height() * mc->prev, mc->width, font_height());
d364 1
a364 1
		    font_height() * mc->entry, mc->width, font_height());
d398 1
a398 1
	entry = y / font_height();
d401 2
a402 2
	if (x <= 0 || x > mc->width || y <= 0 || y > font_height() * mc->num ||
	    entry < 0 || entry >= mc->num)
@


1.14
log
@style (whitespaces)

ok oga, okan
@
text
@d401 1
a401 1
	if (x < 0 || x > mc->width || y < 0 || y > font_height() * mc->num ||
@


1.13
log
@style

ok oga
@
text
@d339 1
a339 1
		    sc->menuwin, 0, n*font_height() + font_ascent() + 1);
@


1.12
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d246 1
a246 1
	if (mc->changed && strlen(mc->searchstr) > 0) {
d253 1
a253 1
	 if (!mc->list && mc->listing && !mc->changed) {
@


1.11
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d46 1
a46 1
struct menu		*menu_handle_release(XEvent *, struct menu_ctx *,
d352 1
a352 1
void
d369 1
a369 1
struct menu *
@


1.10
log
@move like defines to a central, logical location; no binary change.

aok oga@@
@
text
@d386 1
a386 1
		XMALLOC(mi, struct menu);
@


1.9
log
@revert the 1.4 change - causes a double free noticed by grange@@ a while
ago while using kazehakase (or clients that don't set a name).

ok oga@@
@
text
@a20 5
#define KeyMask		(KeyPressMask|ExposureMask)
#define MenuMask 	(ButtonMask|ButtonMotionMask|ExposureMask| \
			PointerMotionMask)
#define MenuGrabMask	(ButtonMask|ButtonMotionMask|StructureNotifyMask|\
			PointerMotionMask)
@


1.8
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d164 1
a164 1
	if ((dummy == 0 && mi->dummy) || (mi->text[0] == '\0')) { /* no match */
@


1.7
log
@- avoid shadowed Mask declaration in menu_filter
- make _xev_reincorporate static
evmask naming oga@@, input okan@@.  ok okan@@, oga@@
@
text
@d61 13
a73 2
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0,
	    1, 1, 1, sc->blackpixl, sc->whitepixl);
@


1.6
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d76 1
a76 1
	int			 Mask, focusrevert;
d87 1
a87 1
		Mask = MenuMask;
d91 1
a91 1
		Mask = MenuMask | KeyMask; /* only accept keys if prompt */
d111 1
a111 1
	XSelectInput(X_Dpy, sc->menuwin, Mask);
d129 1
a129 1
		XWindowEvent(X_Dpy, sc->menuwin, Mask, &e);
@


1.5
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d70 1
a70 1
	struct screen_ctx	*sc = screen_current();
d78 2
d260 1
a260 4
	int		 n = 0;
	int		 dy;
	int		 xsave, ysave;
	int		 warp;
d390 3
a392 1
	int entry = y / font_height();
d395 1
a395 1
	if (x < 0 || x > mc->width || y < 0 || y > font_height()*mc->num ||
@


1.4
log
@prevent trying to exec a null char; could potentially happen with a
canceled or empty searchstr.

ok oga@@
@
text
@a76 1
	struct fontdesc		*font = DefaultFont;
d94 1
a94 1
		mc.width = font_width(font, mc.dispstr, strlen(mc.dispstr));
d108 1
a108 1
	    sc->fontheight);
a261 1
	struct fontdesc	*font = DefaultFont;
d281 2
a282 2
		mc->width = font_width(font, mc->dispstr, strlen(mc->dispstr));
		dy = sc->fontheight;
d297 1
a297 1
		mc->width = MAX(mc->width, font_width(font, text,
d299 1
a299 1
		dy += sc->fontheight;
d323 2
a324 2
		font_draw(font, mc->dispstr, strlen(mc->dispstr), sc->menuwin,
		    0, font_ascent(font) + 1);
d333 2
a334 4
		font_draw(font, text,
		    MIN(strlen(text), MENU_MAXENTRY),
		    sc->menuwin,
		    0, n*sc->fontheight + font_ascent(font) + 1);
d340 1
a340 1
		    0, sc->fontheight, mc->width, sc->fontheight);
d344 1
a344 1
		    0, 0, mc->width, sc->fontheight);
d355 1
a355 1
		    sc->fontheight * mc->prev, mc->width, sc->fontheight);
d359 1
a359 1
		    sc->fontheight * mc->entry, mc->width, sc->fontheight);
d391 1
a391 1
	int entry = y / sc->fontheight;
d394 1
a394 1
	if (x < 0 || x > mc->width || y < 0 || y > sc->fontheight*mc->num ||
@


1.3
log
@Grab the keyboard when we initialise the menu. This stops the keyboard
shortcut code stealing our events in some cases.

"put 'er in" okan@@.
@
text
@d152 1
a152 1
	if (dummy == 0 && mi->dummy) { /* no match */
@


1.2
log
@Make menu_filter handle mouse movement too. This enables the keyboard
search dialogues to be manipulated with the mouse, too. It also allows
me to shrink the codebase further by killing grab_menu().

One known issue with highlighting the first entry in a search dialogue,
that'll be fixed soonish.

ok okan@@, tested by Edd Barrett and todd@@.
@
text
@d121 4
d160 1
@


1.1
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d21 7
a27 1
#define KeyMask (KeyPressMask|ExposureMask)
d33 1
d38 4
d43 1
a43 1
	int			 y; /* location */
d49 4
d55 9
d76 1
a76 2
	int			 dx, dy, focusrevert;
	char			 endchar = '';
d85 13
a97 2
	if (prompt == NULL)
		prompt = "search";
d106 1
d108 3
a110 8
	snprintf(mc.promptstr, sizeof(mc.promptstr), "%s", prompt);
	snprintf(mc.dispstr, sizeof(mc.dispstr), "%s%s%c", mc.promptstr,
	    mc.searchstr, endchar);
	dx = font_width(font, mc.dispstr, strlen(mc.dispstr));
	dy = sc->fontheight;

	XMoveResizeWindow(X_Dpy, sc->menuwin, mc.x, mc.y, dx, dy);
	XSelectInput(X_Dpy, sc->menuwin, KeyMask);
d113 1
a113 1
	if (xu_ptr_grab(sc->menuwin, 0, Cursor_question) < 0) {
d124 1
a124 1
		XWindowEvent(X_Dpy, sc->menuwin, KeyMask, &e);
d127 2
d137 8
a253 1
	char		 endchar = '';
d255 1
a255 1
	int		 dx, dy;
d272 10
a281 4
	snprintf(mc->dispstr, sizeof(mc->dispstr), "%s%s%c",
	    mc->promptstr, mc->searchstr, endchar);
	dx = font_width(font, mc->dispstr, strlen(mc->dispstr));
	dy = sc->fontheight;
d294 1
a294 1
		dx = MAX(dx, font_width(font, text,
d297 1
d304 2
a305 2
	else if (mc->x + dx >= sc->xmax)
		mc->x = sc->xmax - dx;
d317 1
a317 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, mc->x, mc->y, dx, dy);
d319 6
a324 2
	font_draw(font, mc->dispstr, strlen(mc->dispstr), sc->menuwin,
	    0, font_ascent(font) + 1);
a325 1
	n = 1;
d337 1
a337 1
	if (n > 1)
d339 1
a339 1
		    0, sc->fontheight, dx, sc->fontheight);
d343 56
a398 1
		    0, 0, dx, sc->fontheight);
d400 1
@

