head	1.61;
access;
symbols
	OPENBSD_6_1:1.59.0.2
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.49.0.2
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.2
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.2
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2017.04.24.15.06.11;	author okan;	state Exp;
branches;
next	1.60;
commitid	p2sgfMU1ChJxrUy2;

1.60
date	2017.04.24.13.35.25;	author okan;	state Exp;
branches;
next	1.59;
commitid	gTSHf9OtnCTzVOU0;

1.59
date	2016.12.06.21.54.10;	author okan;	state Exp;
branches;
next	1.58;
commitid	GTK8UjM1rfae1rvk;

1.58
date	2016.12.01.20.28.19;	author okan;	state Exp;
branches;
next	1.57;
commitid	BV26iM1x8TsKqz4Z;

1.57
date	2016.10.24.18.57.12;	author okan;	state Exp;
branches;
next	1.56;
commitid	rcOQqeRjfo59nGCK;

1.56
date	2016.10.24.17.39.38;	author okan;	state Exp;
branches;
next	1.55;
commitid	4CtR29PGziRtkeB6;

1.55
date	2016.10.24.17.16.23;	author okan;	state Exp;
branches;
next	1.54;
commitid	0zKwnarjAIoRvHGf;

1.54
date	2016.10.22.19.16.43;	author okan;	state Exp;
branches;
next	1.53;
commitid	R5vS4oMj03lD5FxG;

1.53
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.52;
commitid	dIOrHVlb55Ubzrpl;

1.52
date	2016.09.14.19.45.33;	author okan;	state Exp;
branches;
next	1.51;
commitid	lAQwIuCLXRGzG7kf;

1.51
date	2015.08.27.18.53.15;	author okan;	state Exp;
branches;
next	1.50;
commitid	zidCZkwdtbi68xMi;

1.50
date	2015.08.21.16.05.55;	author okan;	state Exp;
branches;
next	1.49;
commitid	1r39soX8fGqXiSh3;

1.49
date	2015.07.12.14.31.47;	author okan;	state Exp;
branches;
next	1.48;
commitid	vbdA9GL2PIvC62Ws;

1.48
date	2015.07.01.14.36.42;	author okan;	state Exp;
branches;
next	1.47;
commitid	HEkKIvh6L9ijX1lH;

1.47
date	2015.07.01.14.29.36;	author okan;	state Exp;
branches;
next	1.46;
commitid	yz6tOxNzwUbFb1jR;

1.46
date	2015.06.30.18.54.12;	author okan;	state Exp;
branches;
next	1.45;
commitid	BFKdrINXu4OZsfXB;

1.45
date	2015.06.30.18.42.50;	author okan;	state Exp;
branches;
next	1.44;
commitid	mctqLOFykKSdPMbE;

1.44
date	2015.06.28.19.50.46;	author okan;	state Exp;
branches;
next	1.43;
commitid	9QJos70x7Vh2VORU;

1.43
date	2015.06.08.15.34.03;	author okan;	state Exp;
branches;
next	1.42;
commitid	zfKKk9H4Onhmb5Bj;

1.42
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.41;
commitid	kLADTGYX3gw0Sf2m;

1.41
date	2014.09.15.13.00.49;	author okan;	state Exp;
branches;
next	1.40;
commitid	VPtTUp6sF9rrEiW2;

1.40
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.39;
commitid	jXQ1fztXcP9vyPb1;

1.39
date	2014.08.22.19.04.00;	author okan;	state Exp;
branches;
next	1.38;
commitid	INCxCbmjnfOT88xa;

1.38
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.37;
commitid	SsDu0AngUZExtrz4;

1.37
date	2014.02.07.21.59.56;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.20.18.58.03;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2013.12.11.14.09.21;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2013.12.08.13.51.38;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2013.12.02.19.30.27;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.30.21.11.07;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.05.17.36.02;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.05.17.07.25;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.03.19.28.00;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.09.21.55.56;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2012.11.07.14.39.44;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.22.10.57.31;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.25.20.01.27;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.15.03.34.34;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.26.12.45.12;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.17.12.30.17;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.18.00.23.35;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.22.14.15.03;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.03.04.39.12;	author canacar;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.19.18.07.53;	author okan;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.22.14.09.02;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.02.18.01.45;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.26.19.34.26;	author niallo;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.61
log
@search_match_path() isn't supposed to return anything.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: search.c,v 1.60 2017/04/24 13:35:25 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <fnmatch.h>
#include <glob.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

#define PATH_ANY 	0x0001
#define PATH_EXEC 	0x0002

static void	search_match_path_type(struct menu_q *, struct menu_q *,
		    char *, int);
static int	strsubmatch(char *, char *, int);

void
search_match_client(struct menu_q *menuq, struct menu_q *resultq, char *search)
{
	struct winname	*wn;
	struct menu	*mi, *tierp[4], *before = NULL;

	TAILQ_INIT(resultq);

	(void)memset(tierp, 0, sizeof(tierp));

	TAILQ_FOREACH(mi, menuq, entry) {
		int tier = -1, t;
		struct client_ctx *cc = (struct client_ctx *)mi->ctx;

		/* Match on label. */
		if (strsubmatch(search, cc->label, 0))
			tier = 0;

		/* Match on window name history, from present to past. */
		if (tier < 0) {
			TAILQ_FOREACH_REVERSE(wn, &cc->nameq, name_q, entry)
				if (strsubmatch(search, wn->name, 0)) {
					tier = 2;
					break;
				}
		}

		/* Match on window resource class. */
		if ((tier < 0) && strsubmatch(search, cc->ch.res_class, 0))
			tier = 3;

		if (tier < 0)
			continue;

		/* Current window is ranked down. */
		if ((tier < nitems(tierp) - 1) && (cc->flags & CLIENT_ACTIVE))
			tier++;

		/* Hidden window is ranked up. */
		if ((tier > 0) && (cc->flags & CLIENT_HIDDEN))
			tier--;

		if (tier >= nitems(tierp))
			errx(1, "%s: invalid tier", __func__);

		/*
		 * If you have a tierp, insert after it, and make it
		 * the new tierp.  If you don't have a tierp, find the
		 * first nonzero tierp above you, insert after it.
		 * Always make your current tierp the newly inserted
		 * entry.
		 */
		for (t = tier; t >= 0 && ((before = tierp[t]) == NULL); t--)
			;

		if (before == NULL)
			TAILQ_INSERT_HEAD(resultq, mi, resultentry);
		else
			TAILQ_INSERT_AFTER(resultq, before, mi, resultentry);

		tierp[tier] = mi;
	}
}

void
search_print_text(struct menu *mi, int listing)
{
	(void)snprintf(mi->print, sizeof(mi->print), "%s", mi->text);
}

void
search_print_cmd(struct menu *mi, int listing)
{
	struct cmd_ctx	*cmd = (struct cmd_ctx *)mi->ctx;

	(void)snprintf(mi->print, sizeof(mi->print), "%s", cmd->name);
}

void
search_print_group(struct menu *mi, int listing)
{
	struct group_ctx	*gc = (struct group_ctx *)mi->ctx;

	(void)snprintf(mi->print, sizeof(mi->print),
	    (group_holds_only_hidden(gc)) ? "%d: [%s]" : "%d: %s",
	    gc->num, gc->name);
}

void
search_print_client(struct menu *mi, int listing)
{
	struct client_ctx	*cc = (struct client_ctx *)mi->ctx;
	char			 flag = ' ';

	if (cc->flags & CLIENT_ACTIVE)
		flag = '!';
	else if (cc->flags & CLIENT_HIDDEN)
		flag = '&';

	(void)snprintf(mi->print, sizeof(mi->print), "(%d) %c[%s] %s",
	    (cc->gc) ? cc->gc->num : 0, flag,
	    (cc->label) ? cc->label : "", cc->name);
}

static void
search_match_path_type(struct menu_q *menuq, struct menu_q *resultq,
    char *search, int flag)
{
	char 	 pattern[PATH_MAX];
	glob_t	 g;
	int	 i;

	(void)strlcpy(pattern, search, sizeof(pattern));
	(void)strlcat(pattern, "*", sizeof(pattern));

	if (glob(pattern, GLOB_MARK, NULL, &g) != 0)
		return;
	for (i = 0; i < g.gl_pathc; i++) {
		if ((flag & PATH_EXEC) && access(g.gl_pathv[i], X_OK))
			continue;
		menuq_add(resultq, NULL, "%s", g.gl_pathv[i]);
	}
	globfree(&g);
}

void
search_match_path(struct menu_q *menuq, struct menu_q *resultq, char *search)
{
	TAILQ_INIT(resultq);

	search_match_path_type(menuq, resultq, search, PATH_ANY);
}

void
search_match_text(struct menu_q *menuq, struct menu_q *resultq, char *search)
{
	struct menu	*mi;

	TAILQ_INIT(resultq);

	TAILQ_FOREACH(mi, menuq, entry)
		if (strsubmatch(search, mi->text, 0))
			TAILQ_INSERT_TAIL(resultq, mi, resultentry);
}

void
search_match_exec(struct menu_q *menuq, struct menu_q *resultq, char *search)
{
	struct menu	*mi, *mj;
	int		 r;

	TAILQ_INIT(resultq);

	TAILQ_FOREACH(mi, menuq, entry) {
		if (strsubmatch(search, mi->text, 1) == 0 &&
		    fnmatch(search, mi->text, 0) == FNM_NOMATCH)
			continue;
		TAILQ_FOREACH(mj, resultq, resultentry) {
			r = strcasecmp(mi->text, mj->text);
			if (r < 0)
				TAILQ_INSERT_BEFORE(mj, mi, resultentry);
			if (r <= 0)
				break;
		}
		if (mj == NULL)
			TAILQ_INSERT_TAIL(resultq, mi, resultentry);
	}

	if (TAILQ_EMPTY(resultq))
		search_match_path_type(menuq, resultq, search, PATH_EXEC);
}

static int
strsubmatch(char *sub, char *str, int zeroidx)
{
	size_t		 len, sublen;
	unsigned int	 n, flen;

	if (sub == NULL || str == NULL)
		return(0);

	len = strlen(str);
	sublen = strlen(sub);

	if (sublen > len)
		return(0);

	if (!zeroidx)
		flen = len - sublen;
	else
		flen = 0;

	for (n = 0; n <= flen; n++)
		if (strncasecmp(sub, str + n, sublen) == 0)
			return(1);

	return(0);
}
@


1.60
log
@Move queue init to caller so it's only called once in a few cases.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.59 2016/12/06 21:54:10 okan Exp $
d173 1
a173 1
	return(search_match_path_type(menuq, resultq, search, PATH_ANY));
@


1.59
log
@Add search_print_text(), a default callback for mi->print in menu_filter(). While
here, normalize the remaining search_print_* argument paramters.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.58 2016/12/01 20:28:19 okan Exp $
a154 2
	TAILQ_INIT(resultq);

d171 2
@


1.58
log
@Tame the number of 'exec' and 'path' search_match wrappers. No functional
change now, though more can likely go later, losing the (paritally complete or
incomplete/broken) argument completion bits.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.57 2016/10/24 18:57:12 okan Exp $
d108 7
a114 1
search_print_cmd(struct menu *mi, int i)
d122 1
a122 1
search_print_group(struct menu *mi, int i)
d132 1
a132 1
search_print_client(struct menu *mi, int list)
@


1.57
log
@Remove duplicate check that strsubmatch() already does; while here, fix a
comment.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.56 2016/10/24 17:39:38 okan Exp $
d39 1
a39 1
static void	search_match_path(struct menu_q *, struct menu_q *,
a40 2
static void	search_match_path_exec(struct menu_q *, struct menu_q *,
		    char *);
d142 2
a143 1
search_match_path(struct menu_q *menuq, struct menu_q *resultq, char *search, int flag)
a163 6
static void
search_match_path_exec(struct menu_q *menuq, struct menu_q *resultq, char *search)
{
	return(search_match_path(menuq, resultq, search, PATH_EXEC));
}

d165 1
a165 1
search_match_path_any(struct menu_q *menuq, struct menu_q *resultq, char *search)
d167 1
a167 1
	return(search_match_path(menuq, resultq, search, PATH_ANY));
a203 1
}
a204 4
void
search_match_exec_path(struct menu_q *menuq, struct menu_q *resultq, char *search)
{
	search_match_exec(menuq, resultq, search);
d206 1
a206 1
		search_match_path_exec(menuq, resultq, search);
@


1.56
log
@Sprinkle __func__ in appropriate error messages.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.55 2016/10/24 17:16:23 okan Exp $
d60 1
a60 1
		if ((cc->label) && strsubmatch(search, cc->label, 0))
d72 1
a72 1
		/* Match on window class name. */
@


1.55
log
@Get rid of 'matchname'; it's too surprising to have the menu change during
client search as different potential str matches are cycled through. If there's
interest, the only string that doesn't exist in the listing is the window's
class - that can be added of course, but it makes the line too long imho.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.54 2016/10/22 19:16:43 okan Exp $
d88 1
a88 1
			errx(1, "search_match_client: invalid tier");
@


1.54
log
@clean up search_match_client(); no behaviour change
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.53 2016/10/18 17:03:30 okan Exp $
d60 1
a60 2
		if ((cc->label) && strsubmatch(search, cc->label, 0)) {
			cc->matchname = cc->label;
a61 1
		}
a66 1
					cc->matchname = wn->name;
d73 1
a73 2
		if ((tier < 0) && strsubmatch(search, cc->ch.res_class, 0)) {
			cc->matchname = cc->ch.res_class;
a74 1
		}
a137 3
	if ((list) || (cc->matchname == cc->label))
		cc->matchname = cc->name;

d140 1
a140 1
	    (cc->label) ? cc->label : "", cc->matchname);
@


1.53
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.52 2016/09/14 19:45:33 okan Exp $
a54 8
	/*
	 * In order of rank:
	 *
	 *   1. Look through labels.
	 *   2. Look at title history, from present to past.
	 *   3. Look at window class name.
	 */

d59 2
a60 2
		/* First, try to match on labels. */
		if (cc->label != NULL && strsubmatch(search, cc->label, 0)) {
d65 1
a65 1
		/* Then, on window names. */
d75 2
a76 2
		/* Then if there is a match on the window class name. */
		if (tier < 0 && strsubmatch(search, cc->ch.res_class, 0)) {
d84 2
a85 6
		/*
		 * De-rank a client one tier if it's the current
		 * window.  Furthermore, this is denoted by a "!" when
		 * printing the window name in the search menu.
		 */
		if ((cc->flags & CLIENT_ACTIVE) && (tier < nitems(tierp) - 1))
d88 2
a89 2
		/* Clients that are hidden get ranked one up. */
		if ((cc->flags & CLIENT_HIDDEN) && (tier > 0))
@


1.52
log
@Fix-up a few simple uses of client_current(): check CLIENT_ACTIVE flag
instead of relying on curcc.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.51 2015/08/27 18:53:15 okan Exp $
d75 1
a75 1
			TAILQ_FOREACH_REVERSE(wn, &cc->nameq, winname_q, entry)
d129 1
a129 1
	struct cmd	*cmd = (struct cmd *)mi->ctx;
@


1.51
log
@Mechanical change: group->gc
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.50 2015/08/21 16:05:55 okan Exp $
d97 1
a97 1
		if (cc == client_current() && tier < nitems(tierp) - 1)
d150 1
a150 1
	if (cc == client_current())
@


1.50
log
@Instead of special casing the 'term' and 'lock' commands, go back to
keeping them hidden; showing them has apparently caused confusion/angst.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.49 2015/07/12 14:31:47 okan Exp $
d159 1
a159 1
	    (cc->group) ? cc->group->num : 0, flag,
@


1.49
log
@introduce 'groupsearch' for group menu search; matches on either group
number/shortcut and/or name.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.48 2015/07/01 14:36:42 okan Exp $
a129 1
	int		 special = 0;
d131 1
a131 6
	if ((strcmp(cmd->name, "lock") == 0) ||
	    (strcmp(cmd->name, "term") == 0))
		special = 1;

	(void)snprintf(mi->print, sizeof(mi->print),
	    (special) ? "[%s]" : "%s", cmd->name);
@


1.48
log
@style
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.47 2015/07/01 14:29:36 okan Exp $
d138 10
@


1.47
log
@only special case label matches (and still list); get rid of the rest - matchname is complete enough
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.46 2015/06/30 18:54:12 okan Exp $
d137 1
a137 1
		(special) ? "[%s]" : "%s", cmd->name);
d155 2
a156 2
	    cc->group ? cc->group->num : 0, flag,
	    cc->label ? cc->label : "", cc->matchname);
@


1.46
log
@Introduce a callback for cmd menu printing, special-casing 'lock' and
'term'.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.45 2015/06/30 18:42:50 okan Exp $
d151 1
a151 1
	if (list)
a156 23

	if (!list && cc->matchname != cc->name &&
	    strlen(mi->print) < sizeof(mi->print) - 1) {
		const char	*marker = "";
		char		 buf[MENU_MAXENTRY + 1];
		int		 diff;

		diff = sizeof(mi->print) - 1 - strlen(mi->print);

		/* One for the ':' */
		diff -= 1;

		if (strlen(cc->name) > diff) {
			marker = "..";
			diff -= 2;
		} else {
			diff = strlen(cc->name);
		}

		(void)strlcpy(buf, mi->print, sizeof(buf));
		(void)snprintf(mi->print, sizeof(mi->print),
		    "%s:%.*s%s", buf, diff, cc->name, marker);
	}
@


1.45
log
@style and spacing nits
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.44 2015/06/28 19:50:46 okan Exp $
d124 14
@


1.44
log
@replace assert usage
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.43 2015/06/08 15:34:03 okan Exp $
a44 4
/*
 * Match: label, title, class.
 */

d65 1
a65 1
		struct client_ctx *cc = mi->ctx;
d129 1
a129 1
	struct client_ctx	*cc;
a130 2

	cc = mi->ctx;
@


1.43
log
@add client label
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.42 2015/01/19 14:54:16 okan Exp $
a23 1
#include <assert.h>
d108 2
a109 1
		assert(tier < nitems(tierp));
@


1.42
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.41 2014/09/15 13:00:49 okan Exp $
d146 3
a148 2
	(void)snprintf(mi->print, sizeof(mi->print), "(%d) %c%s",
	    cc->group ? cc->group->num : 0, flag, cc->matchname);
@


1.41
log
@use similiar style for client flags
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.40 2014/09/07 19:27:30 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d29 1
d176 1
a176 1
	char 	 pattern[MAXPATHLEN];
@


1.40
log
@more style nits
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.39 2014/08/22 19:04:00 okan Exp $
d105 1
a105 1
		if (cc->flags & CLIENT_HIDDEN && tier > 0)
@


1.39
log
@Fix nogroup regression, where nogroup became an actual group - the
symantics between cwm groups and ewmh got in the way.  Ensure a client
that wants to be in nogroup stays in nogroup (thus stays in view), even
when (re)reading NET_WM_DESKTOP.  Paritially reverts patchset 644
(2014-02-07 13:09 PST) which deals with a NULL cc->group.  All to be
revisited when NET_WM_STATE_STICKY hits cwm.

Reported by many; testing and ok phessler.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.38 2014/08/20 15:15:29 okan Exp $
d197 1
a197 1
	return (search_match_path(menuq, resultq, search, PATH_EXEC));
d203 1
a203 1
	return (search_match_path(menuq, resultq, search, PATH_ANY));
d257 1
a257 1
		return (0);
d263 1
a263 1
		return (0);
d272 1
a272 1
			return (1);
d274 1
a274 1
	return (0);
@


1.38
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.37 2014/02/07 21:59:56 okan Exp $
d146 1
a146 1
	    cc->group->num, flag, cc->matchname);
@


1.37
log
@all mapped clients now should have a group, so simplify some cases
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.36 2014/01/20 18:58:03 okan Exp $
d146 1
a146 1
	    cc->group->shortcut, flag, cc->matchname);
@


1.36
log
@Add a function that adds an entry to a menuq, normalizing a common code
path; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.35 2014/01/03 15:29:06 okan Exp $
d146 1
a146 1
	    cc->group ? cc->group->shortcut : 0, flag, cc->matchname);
@


1.35
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.34 2013/12/11 14:09:21 okan Exp $
d175 3
a177 4
	struct menu	*mi;
	char 		 pattern[MAXPATHLEN];
	glob_t		 g;
	int		 i;
d189 1
a189 3
		mi = xcalloc(1, sizeof(*mi));
		(void)strlcpy(mi->text, g.gl_pathv[i], sizeof(mi->text));
		TAILQ_INSERT_TAIL(resultq, mi, resultentry);
@


1.34
log
@Stash Class and WM Hints in client_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.33 2013/12/08 13:51:38 okan Exp $
d256 2
a257 2
	size_t	 len, sublen;
	u_int	 n, flen;
@


1.33
log
@If not using sticky mode (the default), clients aren't automagically
assigned a group, thus cc->group will be NULL - fix the client group
shortcut in menu lists; crash reported by Christian Neukirchen.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.32 2013/12/02 19:30:27 okan Exp $
d88 2
a89 2
		if (tier < 0 && strsubmatch(search, cc->app_class, 0)) {
			cc->matchname = cc->app_class;
@


1.32
log
@Prepend the group shortcut in the client search menu; from Thomas Adam.
Likewise, prepend shortcut in unhide menu.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.31 2013/04/30 21:11:07 okan Exp $
d146 1
a146 1
	    cc->group->shortcut, flag, cc->matchname);
@


1.31
log
@missing proto
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.30 2013/04/05 17:36:02 okan Exp $
d145 2
a146 2
	(void)snprintf(mi->print, sizeof(mi->print), "%c%s", flag,
	    cc->matchname);
@


1.30
log
@add missing proto; replace magic number
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.29 2013/04/05 17:07:25 okan Exp $
d41 2
d197 1
a197 1
void
@


1.29
log
@zap stray whitespace
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.28 2013/04/03 19:28:00 okan Exp $
d36 2
a37 1
#define PATH_EXEC 	0x1
d39 2
d204 1
a204 1
	return (search_match_path(menuq, resultq, search, 0));
@


1.28
log
@honor PATH search order for exec; from Andres Perera.
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.27 2013/03/09 21:55:56 okan Exp $
d192 1
a192 1
void 
d198 1
a198 1
void 
@


1.27
log
@replace handrolled for loop with TAILQ_FOREACH; from andres.p@@zoho.com
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.26 2012/11/09 03:52:02 okan Exp $
d220 1
d229 2
a230 1
			if (strcasecmp(mi->text, mj->text) < 0) {
d232 1
a233 1
			}
@


1.26
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.25 2012/11/07 14:39:44 okan Exp $
d226 2
a227 3
				continue;
		for (mj = TAILQ_FIRST(resultq); mj != NULL;
		     mj = TAILQ_NEXT(mj, resultentry)) {
@


1.25
log
@tab completion support for menus; from Alexander Polakov.

ok sthen@@ on an older incarnation
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.24 2011/07/25 15:10:24 okan Exp $
d28 2
a31 1
#include <stdio.h>
a32 1
#include <glob.h>
@


1.24
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.23 2011/05/11 13:53:51 okan Exp $
d32 1
d36 2
d167 37
d237 8
@


1.23
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: search.c,v 1.22 2011/03/22 10:57:31 okan Exp $
d49 1
a49 1
	memset(tierp, 0, sizeof(tierp));
d137 2
a138 1
	snprintf(mi->print, sizeof(mi->print), "%c%s", flag, cc->matchname);
d158 2
a159 2
		strlcpy(buf, mi->print, sizeof(buf));
		snprintf(mi->print, sizeof(mi->print),
@


1.22
log
@introduce nitems macro, with the appropriate ifndef.

ok oga@@
@
text
@d5 1
d18 1
a18 1
 * $Id: search.c,v 1.21 2010/09/25 20:01:27 okan Exp $
@


1.21
log
@spacing nits
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.20 2009/12/15 04:10:42 okan Exp $
a44 3
	int		 ntiers;

	ntiers = sizeof(tierp) / sizeof(tierp[0]);
d92 1
a92 1
		if (cc == client_current() && tier < ntiers - 1)
d99 1
a99 1
		assert(tier < ntiers);
@


1.20
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.19 2009/12/15 03:34:34 okan Exp $
d81 1
a81 5
		/*
		 * See if there is a match on the window class
		 * name.
		 */

d98 1
a98 3
		/*
		 * Clients that are hidden get ranked one up.
		 */
a110 1

@


1.19
log
@pull these headers only into files that need them.

ok oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.18 2009/12/15 03:24:36 okan Exp $
d20 3
d24 2
d27 4
@


1.18
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.17 2009/06/26 12:45:12 oga Exp $
d20 1
@


1.17
log
@use fnmatch to glob the entries in the exec menu.

allows shell globbing constructs such as *ctl, etc in the exec menu (m-?
by default).

Adapted from a diff from Thomas Pfaff, okan@@ got almost the same diff as
me when reworking it, and oked this one.
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.16 2009/06/17 12:30:17 okan Exp $
d21 1
a21 1
#include "headers.h"
@


1.16
log
@move like defines to a central, logical location; no binary change.

aok oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.15 2009/05/18 00:23:35 okan Exp $
d20 1
d182 3
a184 2
		if (strsubmatch(search, mi->text, 1) == 0)
			continue;
@


1.15
log
@nuke the leading underscore notation for local static functions - there
are far better ways to know.

"go for it" oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.14 2008/09/22 14:15:03 oga Exp $
a21 2

#define SearchMask (KeyPressMask|ExposureMask)
@


1.14
log
@Display the current window title not a previous one in the case of
``show all'' in the window search dialogue. Noticed and diff from Tim
van der Molen, thanks!
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.13 2008/09/03 04:39:12 canacar Exp $
d25 1
a25 1
static int	_strsubmatch(char *, char *, int);
d57 1
a57 1
		if (cc->label != NULL && _strsubmatch(search, cc->label, 0)) {
d65 1
a65 1
				if (_strsubmatch(search, wn->name, 0)) {
d77 1
a77 1
		if (tier < 0 && _strsubmatch(search, cc->app_class, 0)) {
d171 1
a171 1
		if (_strsubmatch(search, mi->text, 0))
d183 1
a183 1
		if (_strsubmatch(search, mi->text, 1) == 0)
d198 1
a198 1
_strsubmatch(char *sub, char *str, int zeroidx)
@


1.13
log
@Keep the exec menu entries sorted.
Go for it okan@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.12 2008/07/11 14:21:28 okan Exp $
d135 1
a135 1
		cc->matchname = TAILQ_FIRST(&cc->nameq)->name;
@


1.12
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.11 2008/05/20 14:50:51 oga Exp $
d178 1
a178 1
	struct menu	*mi;
d182 11
a192 2
	TAILQ_FOREACH(mi, menuq, entry)
		if (_strsubmatch(search, mi->text, 1))
d194 1
@


1.11
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.10 2008/05/19 18:07:53 okan Exp $
d34 5
a38 3
	struct winname *wn;
	struct menu *mi, *tierp[4], *before = NULL;
	int ntiers = sizeof(tierp)/sizeof(tierp[0]);
d124 4
a127 2
	struct client_ctx *cc = mi->ctx;
	char flag = ' ';
d141 5
a145 3
		int diff = sizeof(mi->print) - 1 - strlen(mi->print);
		const char *marker = "";
		char buf[MENU_MAXENTRY + 1];
d166 1
a166 1
	struct menu *mi;
d178 1
a178 1
	struct menu *mi;
d190 2
a191 2
	size_t len, sublen;
	u_int n, flen;
d206 1
@


1.10
log
@stop normalizing search input; searching and matching are still
case-insensitive.  since this was the only use of normalizing input,
simplify as well.

allows one to exec with mixed case unmatched commands.

"works for me" oga@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.9 2008/05/15 22:18:00 oga Exp $
a25 265

void
search_init(struct screen_ctx *sc)
{
	sc->searchwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0,
	    1, 1, 1, sc->blackpixl, sc->whitepixl);
}

/*
 * Input: list of items,
 * Output: choose one
 * so, exactly like menus
 */

struct menu *
search_start(struct menu_q *menuq,
    void (*match)(struct menu_q *, struct menu_q *, char *),
    void (*print)(struct menu *mi, int print),
    char *prompt, int dummy)
{
	struct screen_ctx *sc = screen_current();
	int x, y, dx, dy, fontheight,
	    focusrevert, mutated, xmax, ymax, warp, added, beobnoxious = 0;
	XEvent e;
	char searchstr[MENU_MAXENTRY + 1];
	char dispstr[MENU_MAXENTRY*2 + 1];
	char promptstr[MENU_MAXENTRY + 1];
	Window focuswin;
	struct menu *mi = NULL, *dummy_mi = NULL;
	struct menu_q resultq;
	char chr;
	enum ctltype ctl;
	size_t len;
	u_int n;
	static int list = 0;
	int listing = 0;
	char endchar = '«';
	struct fontdesc *font = DefaultFont;

	if (prompt == NULL)
		prompt = "search";

	TAILQ_INIT(&resultq);

	xmax = DisplayWidth(X_Dpy, sc->which);
	ymax = DisplayHeight(X_Dpy, sc->which);

	xu_ptr_getpos(sc->rootwin, &x, &y);

	searchstr[0] = '\0';

	snprintf(promptstr, sizeof(promptstr), "%s »", prompt);
	dy = fontheight = font_ascent(font) + font_descent(font) + 1;
	snprintf(dispstr, sizeof(dispstr), "%s%c", promptstr, endchar);
	dx = font_width(font, dispstr, strlen(dispstr));

	XMoveResizeWindow(X_Dpy, sc->searchwin, x, y, dx, dy);
	XSelectInput(X_Dpy, sc->searchwin, SearchMask);
	XMapRaised(X_Dpy, sc->searchwin);

	/*
	 * TODO: eventually, the mouse should be able to select
	 * results as well.  Right now we grab it only to set a fancy
	 * cursor.
	 */
	if (xu_ptr_grab(sc->searchwin, 0, Cursor_question) < 0) {
		XUnmapWindow(X_Dpy, sc->searchwin);
		return (NULL);
	}

	XGetInputFocus(X_Dpy, &focuswin, &focusrevert);
	XSetInputFocus(X_Dpy, sc->searchwin, RevertToPointerRoot, CurrentTime);

	for (;;) {
		added = mutated = 0;

		XMaskEvent(X_Dpy, SearchMask, &e);

		switch (e.type) {
		case KeyPress:
			if (input_keycodetrans(e.xkey.keycode, e.xkey.state,
			    &ctl, &chr) < 0)
				continue;

			switch (ctl) {
			case CTL_ERASEONE:
				if ((len = strlen(searchstr)) > 0) {
					searchstr[len - 1] = '\0';
					mutated = 1;
				}
				break;
			case CTL_UP:
				mi = TAILQ_LAST(&resultq, menu_q);
				if (mi == NULL)
					break;

				TAILQ_REMOVE(&resultq, mi, resultentry);
				TAILQ_INSERT_HEAD(&resultq, mi, resultentry);
				break;
			case CTL_DOWN:
				mi = TAILQ_FIRST(&resultq);
				if (mi == NULL)
					break;

				TAILQ_REMOVE(&resultq, mi, resultentry);
				TAILQ_INSERT_TAIL(&resultq, mi, resultentry);
				break;
			case CTL_RETURN:
				/* This is just picking the match the
				 * cursor is over. */
				if ((mi = TAILQ_FIRST(&resultq)) != NULL) {
					goto found;
				} else if (dummy) {
					dummy_mi = xmalloc(sizeof *dummy_mi);
					(void) strlcpy(dummy_mi->text,
					    searchstr, sizeof(dummy_mi->text));
					dummy_mi->dummy = 1;
					goto found;
				}
				goto out;
			case CTL_WIPE:
				searchstr[0] = '\0';
				mutated = 1;
				break;
			case CTL_ALL:
				list = !list;
				break;
			case CTL_ABORT:
				goto out;
			default:
				break;
			}

			if (chr != '\0') {
				char str[2];

				str[0] = chr;
				str[1] = '\0';
				mutated = 1;
				added =
				    strlcat(searchstr, str, sizeof(searchstr));
			}

			beobnoxious = 0;
			if (mutated && strlen(searchstr) > 0) {
				(*match)(menuq, &resultq, searchstr);
				beobnoxious = TAILQ_EMPTY(&resultq);
			} else if (mutated)
				TAILQ_INIT(&resultq);


			 if (!list && listing && !mutated) {
				TAILQ_INIT(&resultq);
				listing = 0;
			}

		case Expose:
			if (list) {
				if (TAILQ_EMPTY(&resultq) && list) {
					/* Copy them all over. */
					TAILQ_FOREACH(mi, menuq, entry)
						TAILQ_INSERT_TAIL(&resultq, mi,
						    resultentry);

					listing = 1;
				} else if (mutated)
					listing = 0;
			}

			snprintf(dispstr, sizeof(dispstr), "%s%s%c",
			    promptstr, searchstr, endchar);
			dx = font_width(font, dispstr, strlen(dispstr));
			dy = fontheight;

			TAILQ_FOREACH(mi, &resultq, resultentry) {
				char *text;

				if (print != NULL) {
					(*print)(mi, listing);
					text = mi->print;
				} else {
					mi->print[0] = '\0';
					text = mi->text;
				}

				dx = MAX(dx, font_width(font, text,
				    MIN(strlen(text), MENU_MAXENTRY)));
				dy += fontheight;
			}

			/*
			 * Calculate new geometry.
			 *
			 * XXX - put this into a util function -- it's
			 * used elsewhere, too.
			 */
			warp = 0;
			if (x < 0) {
				x = 0;
				warp = 1;
			}
			if (x + dx >= xmax) {
				x = xmax - dx;
				warp = 1;
			}

			if (y < 0) {
				y = 0;
				warp = 1;
			}
			if (y + dy >= ymax) {
				y = ymax - dy;
				/* If the menu is too high, never hide the
				 * top of the menu.
				 */
				if (y < 0)
					y = 0;
				warp = 1;
			}

			if (warp)
				xu_ptr_setpos(sc->rootwin, x, y);

			XClearWindow(X_Dpy, sc->searchwin);
			XMoveResizeWindow(X_Dpy, sc->searchwin, x, y, dx, dy);

			font_draw(font, dispstr, strlen(dispstr), sc->searchwin,
			    0, font_ascent(font) + 1);

			n = 1;
			TAILQ_FOREACH(mi, &resultq, resultentry) {
				char *text = mi->print[0] != '\0' ?
				    mi->print : mi->text;

				font_draw(font, text,
				    MIN(strlen(text), MENU_MAXENTRY),
				    sc->searchwin,
				    0, n*fontheight + font_ascent(font) + 1);
				n++;
			}

			if (n > 1)
				XFillRectangle(X_Dpy, sc->searchwin, sc->gc,
				    0, fontheight, dx, fontheight);

			if (beobnoxious)
				XFillRectangle(X_Dpy, sc->searchwin, sc->gc,
				    0, 0, dx, fontheight);

			break;
		}
	}

out:
	/* (if no match) */
	xu_ptr_ungrab();
	XSetInputFocus(X_Dpy, focuswin, focusrevert, CurrentTime);

found:
	XUnmapWindow(X_Dpy, sc->searchwin);

	if (dummy && dummy_mi != NULL)
		return (dummy_mi);
	return (mi);
}
@


1.9
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.8 2008/04/15 20:24:41 oga Exp $
d107 1
a107 1
			    &ctl, &chr, 1) < 0)
@


1.8
log
@hit it with the knf stick.
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.7 2008/03/22 14:09:02 oga Exp $
d107 1
a107 1
				&ctl, &chr, 1) < 0)
d187 2
a188 2
					    TAILQ_INSERT_TAIL(&resultq, mi,
						resultentry);
d212 1
a212 1
					MIN(strlen(text), MENU_MAXENTRY)));
@


1.7
log
@Remove a bunch of unused variables and incorrect comments.

"ok with me" okan@@.
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.6 2008/01/16 11:39:20 oga Exp $
d25 1
a25 1
static int  _strsubmatch(char *, char *, int);
d42 1
a42 1
    void (*match)(struct menu_q *, struct menu_q *, char *), 
d323 1
a323 1
		} 
d328 5
a332 5
			    if (_strsubmatch(search, wn->name, 0)) {
				    cc->matchname = wn->name;
				    tier = 2;
				    break;
			    }
@


1.6
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.5 2008/01/11 16:06:44 oga Exp $
a34 5
 * ranking.  each rank type is assigned a weight.  multiply this by
 * the rank given.  add them up.  simple linear combination.
 */

/*
a42 1
    void (*rank)(struct menu_q *resultq, char *search), 
a105 4
			/*
			 * XXX - C-s & C-r for next and prev.
			 */

a172 2
				if (!beobnoxious && rank != NULL)
					(*rank)(&resultq, searchstr);
d185 1
a185 1
					/* Copy them over and rank them. */
a188 2
					if (rank != NULL)
						(*rank)(&resultq, searchstr);
@


1.5
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d17 1
a17 1
 * $Id: search.c,v 1.4 2007/10/02 18:01:45 jasper Exp $
a457 6
}

void
search_rank_text(struct menu_q *resultq, char *search)
{
	return;
@


1.4
log
@When cycling, only the end of the window names will be printed if the
name is too long. so show the beginning instead.

from Pierre Riteau <pierre.riteau at free.fr>

"looks correct" matthieu@@
@
text
@d5 3
a7 1
 * All rights reserved.
d9 9
a17 1
 * $Id: search.c,v 1.3 2007/06/26 19:34:26 niallo Exp $
@


1.3
log
@modify "exec" dialog so that it auto-completes based on executables in
_PATH_DEFPATH

add an "ssh-to" dialog which auto-completes based on contents of
 ~/.ssh/known_hosts (M-.)

testing and eyeballing by Simon Kuhnle <simonkuhnle at web.de>, todd@@, pedro@@
mk@@ and David Cathcart <david at cathcart.cx>

ok todd@@
@
text
@d7 1
a7 1
 * $Id: search.c,v 1.2 2007/05/28 18:34:27 jasper Exp $
d242 5
@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: search.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
d15 1
a15 1
static int  _strsubmatch(char *, char *);
d40 1
a40 1
    char *prompt)
d50 1
a50 1
	struct menu *mi = NULL;
d136 1
a136 1
				if ((mi = TAILQ_FIRST(&resultq)) != NULL)
d138 8
a145 2
				else
					goto out;
d151 1
a151 1
 				list = !list;
d282 1
d286 2
d319 1
a319 1
		if (cc->label != NULL && _strsubmatch(search, cc->label)) {
d327 1
a327 1
			    if (_strsubmatch(search, wn->name)) {
d339 1
a339 1
		if (tier < 0 && _strsubmatch(search, cc->app_class)) {
d429 13
a441 1
		if (_strsubmatch(search, mi->text))
d452 1
a452 1
_strsubmatch(char *sub, char *str)
d455 1
a455 1
	u_int n;
d466 5
a470 1
	for (n = 0; n <= len - sublen; n++)
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: search.c,v 1.27 2005/08/28 09:36:45 marius Exp $
d20 1
a20 1
	sc->searchwin = XCreateSimpleWindow(G_dpy, sc->rootwin, 0, 0,
d66 2
a67 2
	xmax = DisplayWidth(G_dpy, sc->which);
	ymax = DisplayHeight(G_dpy, sc->which);
d78 3
a80 3
	XMoveResizeWindow(G_dpy, sc->searchwin, x, y, dx, dy);
	XSelectInput(G_dpy, sc->searchwin, SearchMask);
	XMapRaised(G_dpy, sc->searchwin);
d87 2
a88 2
	if (xu_ptr_grab(sc->searchwin, 0, G_cursor_question) < 0) {
		XUnmapWindow(G_dpy, sc->searchwin);
d92 2
a93 2
	XGetInputFocus(G_dpy, &focuswin, &focusrevert);
	XSetInputFocus(G_dpy, sc->searchwin, RevertToPointerRoot, CurrentTime);
d98 1
a98 1
		XMaskEvent(G_dpy, SearchMask, &e);
d242 2
a243 2
			XClearWindow(G_dpy, sc->searchwin);
			XMoveResizeWindow(G_dpy, sc->searchwin, x, y, dx, dy);
d261 1
a261 1
				XFillRectangle(G_dpy, sc->searchwin, sc->gc,
d265 1
a265 1
				XFillRectangle(G_dpy, sc->searchwin, sc->gc,
d275 1
a275 1
	XSetInputFocus(G_dpy, focuswin, focusrevert, CurrentTime);
d277 1
a277 1
	XUnmapWindow(G_dpy, sc->searchwin);
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
