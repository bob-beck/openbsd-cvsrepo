head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.23;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.09;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.26;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.11;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.18;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/* -*- c++ -*- */
/*
 * Copyright © 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once
#ifndef AST_H
#define AST_H

#include "list.h"
#include "glsl_parser_extras.h"

struct _mesa_glsl_parse_state;

struct YYLTYPE;

/**
 * \defgroup AST Abstract syntax tree node definitions
 *
 * An abstract syntax tree is generated by the parser.  This is a fairly
 * direct representation of the gramma derivation for the source program.
 * No symantic checking is done during the generation of the AST.  Only
 * syntactic checking is done.  Symantic checking is performed by a later
 * stage that converts the AST to a more generic intermediate representation.
 *
 *@@{
 */
/**
 * Base class of all abstract syntax tree nodes
 */
class ast_node {
public:
   DECLARE_RALLOC_CXX_OPERATORS(ast_node);

   /**
    * Print an AST node in something approximating the original GLSL code
    */
   virtual void print(void) const;

   /**
    * Convert the AST node to the high-level intermediate representation
    */
   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   /**
    * Retrieve the source location of an AST node
    *
    * This function is primarily used to get the source position of an AST node
    * into a form that can be passed to \c _mesa_glsl_error.
    *
    * \sa _mesa_glsl_error, ast_node::set_location
    */
   struct YYLTYPE get_location(void) const
   {
      struct YYLTYPE locp;

      locp.source = this->location.source;
      locp.first_line = this->location.first_line;
      locp.first_column = this->location.first_column;
      locp.last_line = this->location.last_line;
      locp.last_column = this->location.last_column;

      return locp;
   }

   /**
    * Set the source location of an AST node from a parser location
    *
    * \sa ast_node::get_location
    */
   void set_location(const struct YYLTYPE &locp)
   {
      this->location.source = locp.source;
      this->location.first_line = locp.first_line;
      this->location.first_column = locp.first_column;
      this->location.last_line = locp.last_line;
      this->location.last_column = locp.last_column;
   }

   /**
    * Set the source location range of an AST node using two location nodes
    *
    * \sa ast_node::set_location
    */
   void set_location_range(const struct YYLTYPE &begin, const struct YYLTYPE &end)
   {
      this->location.source = begin.source;
      this->location.first_line = begin.first_line;
      this->location.last_line = end.last_line;
      this->location.first_column = begin.first_column;
      this->location.last_column = end.last_column;
   }

   /**
    * Source location of the AST node.
    */
   struct {
      unsigned source;          /**< GLSL source number. */
      unsigned first_line;      /**< First line number within the source string. */
      unsigned first_column;    /**< First column in the first line. */
      unsigned last_line;       /**< Last line number within the source string. */
      unsigned last_column;     /**< Last column in the last line. */
   } location;

   exec_node link;

protected:
   /**
    * The only constructor is protected so that only derived class objects can
    * be created.
    */
   ast_node(void);
};


/**
 * Operators for AST expression nodes.
 */
enum ast_operators {
   ast_assign,
   ast_plus,        /**< Unary + operator. */
   ast_neg,
   ast_add,
   ast_sub,
   ast_mul,
   ast_div,
   ast_mod,
   ast_lshift,
   ast_rshift,
   ast_less,
   ast_greater,
   ast_lequal,
   ast_gequal,
   ast_equal,
   ast_nequal,
   ast_bit_and,
   ast_bit_xor,
   ast_bit_or,
   ast_bit_not,
   ast_logic_and,
   ast_logic_xor,
   ast_logic_or,
   ast_logic_not,

   ast_mul_assign,
   ast_div_assign,
   ast_mod_assign,
   ast_add_assign,
   ast_sub_assign,
   ast_ls_assign,
   ast_rs_assign,
   ast_and_assign,
   ast_xor_assign,
   ast_or_assign,

   ast_conditional,

   ast_pre_inc,
   ast_pre_dec,
   ast_post_inc,
   ast_post_dec,
   ast_field_selection,
   ast_array_index,

   ast_function_call,

   ast_identifier,
   ast_int_constant,
   ast_uint_constant,
   ast_float_constant,
   ast_bool_constant,

   ast_sequence,
   ast_aggregate
};

/**
 * Representation of any sort of expression.
 */
class ast_expression : public ast_node {
public:
   ast_expression(int oper, ast_expression *,
		  ast_expression *, ast_expression *);

   ast_expression(const char *identifier) :
      oper(ast_identifier)
   {
      subexpressions[0] = NULL;
      subexpressions[1] = NULL;
      subexpressions[2] = NULL;
      primary_expression.identifier = identifier;
      this->non_lvalue_description = NULL;
   }

   static const char *operator_string(enum ast_operators op);

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   virtual void hir_no_rvalue(exec_list *instructions,
                              struct _mesa_glsl_parse_state *state);

   ir_rvalue *do_hir(exec_list *instructions,
                     struct _mesa_glsl_parse_state *state,
                     bool needs_rvalue);

   virtual void print(void) const;

   enum ast_operators oper;

   ast_expression *subexpressions[3];

   union {
      const char *identifier;
      int int_constant;
      float float_constant;
      unsigned uint_constant;
      int bool_constant;
   } primary_expression;


   /**
    * List of expressions for an \c ast_sequence or parameters for an
    * \c ast_function_call
    */
   exec_list expressions;

   /**
    * For things that can't be l-values, this describes what it is.
    *
    * This text is used by the code that generates IR for assignments to
    * detect and emit useful messages for assignments to some things that
    * can't be l-values.  For example, pre- or post-incerement expressions.
    *
    * \note
    * This pointer may be \c NULL.
    */
   const char *non_lvalue_description;
};

class ast_expression_bin : public ast_expression {
public:
   ast_expression_bin(int oper, ast_expression *, ast_expression *);

   virtual void print(void) const;
};

/**
 * Subclass of expressions for function calls
 */
class ast_function_expression : public ast_expression {
public:
   ast_function_expression(ast_expression *callee)
      : ast_expression(ast_function_call, callee,
		       NULL, NULL),
	cons(false)
   {
      /* empty */
   }

   ast_function_expression(class ast_type_specifier *type)
      : ast_expression(ast_function_call, (ast_expression *) type,
		       NULL, NULL),
	cons(true)
   {
      /* empty */
   }

   bool is_constructor() const
   {
      return cons;
   }

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   virtual void hir_no_rvalue(exec_list *instructions,
                              struct _mesa_glsl_parse_state *state);

private:
   /**
    * Is this function call actually a constructor?
    */
   bool cons;
};

class ast_array_specifier : public ast_node {
public:
   /** Unsized array specifier ([]) */
   explicit ast_array_specifier(const struct YYLTYPE &locp)
     : is_unsized_array(true)
   {
      set_location(locp);
   }

   /** Sized array specifier ([dim]) */
   ast_array_specifier(const struct YYLTYPE &locp, ast_expression *dim)
     : is_unsized_array(false)
   {
      set_location(locp);
      array_dimensions.push_tail(&dim->link);
   }

   void add_dimension(ast_expression *dim)
   {
      array_dimensions.push_tail(&dim->link);
   }

   virtual void print(void) const;

   /* If true, this means that the array has an unsized outermost dimension. */
   bool is_unsized_array;

   /* This list contains objects of type ast_node containing the
    * sized dimensions only, in outermost-to-innermost order.
    */
   exec_list array_dimensions;
};

/**
 * C-style aggregate initialization class
 *
 * Represents C-style initializers of vectors, matrices, arrays, and
 * structures. E.g., vec3 pos = {1.0, 0.0, -1.0} is equivalent to
 * vec3 pos = vec3(1.0, 0.0, -1.0).
 *
 * Specified in GLSL 4.20 and GL_ARB_shading_language_420pack.
 *
 * \sa _mesa_ast_set_aggregate_type
 */
class ast_aggregate_initializer : public ast_expression {
public:
   ast_aggregate_initializer()
      : ast_expression(ast_aggregate, NULL, NULL, NULL),
        constructor_type(NULL)
   {
      /* empty */
   }

   /**
    * glsl_type of the aggregate, which is inferred from the LHS of whatever
    * the aggregate is being used to initialize.  This can't be inferred at
    * parse time (since the parser deals with ast_type_specifiers, not
    * glsl_types), so the parser leaves it NULL.  However, the ast-to-hir
    * conversion code makes sure to fill it in with the appropriate type
    * before hir() is called.
    */
   const glsl_type *constructor_type;

   virtual ir_rvalue *hir(exec_list *instructions,
                          struct _mesa_glsl_parse_state *state);

   virtual void hir_no_rvalue(exec_list *instructions,
                              struct _mesa_glsl_parse_state *state);
};

/**
 * Number of possible operators for an ast_expression
 *
 * This is done as a define instead of as an additional value in the enum so
 * that the compiler won't generate spurious messages like "warning:
 * enumeration value ‘ast_num_operators’ not handled in switch"
 */
#define AST_NUM_OPERATORS (ast_sequence + 1)


class ast_compound_statement : public ast_node {
public:
   ast_compound_statement(int new_scope, ast_node *statements);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   int new_scope;
   exec_list statements;
};

class ast_declaration : public ast_node {
public:
   ast_declaration(const char *identifier,
                   ast_array_specifier *array_specifier,
                   ast_expression *initializer);
   virtual void print(void) const;

   const char *identifier;

   ast_array_specifier *array_specifier;

   ast_expression *initializer;
};


enum {
   ast_precision_none = 0, /**< Absence of precision qualifier. */
   ast_precision_high,
   ast_precision_medium,
   ast_precision_low
};

struct ast_type_qualifier {
   DECLARE_RALLOC_CXX_OPERATORS(ast_type_qualifier);

   union {
      struct {
	 unsigned invariant:1;
	 unsigned constant:1;
	 unsigned attribute:1;
	 unsigned varying:1;
	 unsigned in:1;
	 unsigned out:1;
	 unsigned centroid:1;
         unsigned sample:1;
	 unsigned uniform:1;
	 unsigned smooth:1;
	 unsigned flat:1;
	 unsigned noperspective:1;

	 /** \name Layout qualifiers for GL_ARB_fragment_coord_conventions */
	 /*@@{*/
	 unsigned origin_upper_left:1;
	 unsigned pixel_center_integer:1;
	 /*@@}*/

	 /**
	  * Flag set if GL_ARB_explicit_attrib_location "location" layout
	  * qualifier is used.
	  */
	 unsigned explicit_location:1;
	 /**
	  * Flag set if GL_ARB_explicit_attrib_location "index" layout
	  * qualifier is used.
	  */
	 unsigned explicit_index:1;

         /**
          * Flag set if GL_ARB_shading_language_420pack "binding" layout
          * qualifier is used.
          */
         unsigned explicit_binding:1;

         /**
          * Flag set if GL_ARB_shader_atomic counter "offset" layout
          * qualifier is used.
          */
         unsigned explicit_offset:1;

         /** \name Layout qualifiers for GL_AMD_conservative_depth */
         /** \{ */
         unsigned depth_any:1;
         unsigned depth_greater:1;
         unsigned depth_less:1;
         unsigned depth_unchanged:1;
         /** \} */

	 /** \name Layout qualifiers for GL_ARB_uniform_buffer_object */
	 /** \{ */
         unsigned std140:1;
         unsigned shared:1;
         unsigned packed:1;
         unsigned column_major:1;
         unsigned row_major:1;
	 /** \} */

	 /** \name Layout qualifiers for GLSL 1.50 geometry shaders */
	 /** \{ */
	 unsigned prim_type:1;
	 unsigned max_vertices:1;
	 /** \} */

         /**
          * local_size_{x,y,z} flags for compute shaders.  Bit 0 represents
          * local_size_x, and so on.
          */
         unsigned local_size:3;

	 /** \name Layout and memory qualifiers for ARB_shader_image_load_store. */
	 /** \{ */
	 unsigned early_fragment_tests:1;
	 unsigned explicit_image_format:1;
	 unsigned coherent:1;
	 unsigned _volatile:1;
	 unsigned restrict_flag:1;
	 unsigned read_only:1; /**< "readonly" qualifier. */
	 unsigned write_only:1; /**< "writeonly" qualifier. */
	 /** \} */

         /** \name Layout qualifiers for GL_ARB_gpu_shader5 */
         /** \{ */
         unsigned invocations:1;
         /** \} */
      }
      /** \brief Set of flags, accessed by name. */
      q;

      /** \brief Set of flags, accessed as a bitmask. */
      uint64_t i;
   } flags;

   /** Precision of the type (highp/medium/lowp). */
   unsigned precision:2;

   /** Geometry shader invocations for GL_ARB_gpu_shader5. */
   int invocations;

   /**
    * Location specified via GL_ARB_explicit_attrib_location layout
    *
    * \note
    * This field is only valid if \c explicit_location is set.
    */
   int location;
   /**
    * Index specified via GL_ARB_explicit_attrib_location layout
    *
    * \note
    * This field is only valid if \c explicit_index is set.
    */
   int index;

   /** Maximum output vertices in GLSL 1.50 geometry shaders. */
   int max_vertices;

   /** Input or output primitive type in GLSL 1.50 geometry shaders */
   GLenum prim_type;

   /**
    * Binding specified via GL_ARB_shading_language_420pack's "binding" keyword.
    *
    * \note
    * This field is only valid if \c explicit_binding is set.
    */
   int binding;

   /**
    * Offset specified via GL_ARB_shader_atomic_counter's "offset"
    * keyword.
    *
    * \note
    * This field is only valid if \c explicit_offset is set.
    */
   int offset;

   /**
    * Local size specified via GL_ARB_compute_shader's "local_size_{x,y,z}"
    * layout qualifier.  Element i of this array is only valid if
    * flags.q.local_size & (1 << i) is set.
    */
   int local_size[3];

   /**
    * Image format specified with an ARB_shader_image_load_store
    * layout qualifier.
    *
    * \note
    * This field is only valid if \c explicit_image_format is set.
    */
   GLenum image_format;

   /**
    * Base type of the data read from or written to this image.  Only
    * the following enumerants are allowed: GLSL_TYPE_UINT,
    * GLSL_TYPE_INT, GLSL_TYPE_FLOAT.
    *
    * \note
    * This field is only valid if \c explicit_image_format is set.
    */
   glsl_base_type image_base_type;

   /**
    * Return true if and only if an interpolation qualifier is present.
    */
   bool has_interpolation() const;

   /**
    * Return whether a layout qualifier is present.
    */
   bool has_layout() const;

   /**
    * Return whether a storage qualifier is present.
    */
   bool has_storage() const;

   /**
    * Return whether an auxiliary storage qualifier is present.
    */
   bool has_auxiliary_storage() const;

   /**
    * \brief Return string representation of interpolation qualifier.
    *
    * If an interpolation qualifier is present, then return that qualifier's
    * string representation. Otherwise, return null. For example, if the
    * noperspective bit is set, then this returns "noperspective".
    *
    * If multiple interpolation qualifiers are somehow present, then the
    * returned string is undefined but not null.
    */
   const char *interpolation_string() const;

   bool merge_qualifier(YYLTYPE *loc,
			_mesa_glsl_parse_state *state,
			ast_type_qualifier q);

   bool merge_in_qualifier(YYLTYPE *loc,
                           _mesa_glsl_parse_state *state,
                           ast_type_qualifier q,
                           ast_node* &node);

};

class ast_declarator_list;

class ast_struct_specifier : public ast_node {
public:
   /**
    * \brief Make a shallow copy of an ast_struct_specifier.
    *
    * Use only if the objects are allocated from the same context and will not
    * be modified. Zeros the inherited ast_node's fields.
    */
   ast_struct_specifier(const ast_struct_specifier& that):
      ast_node(), name(that.name), declarations(that.declarations),
      is_declaration(that.is_declaration)
   {
      /* empty */
   }

   ast_struct_specifier(const char *identifier,
			ast_declarator_list *declarator_list);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   const char *name;
   /* List of ast_declarator_list * */
   exec_list declarations;
   bool is_declaration;
};



class ast_type_specifier : public ast_node {
public:
   /**
    * \brief Make a shallow copy of an ast_type_specifier, specifying array
    *        fields.
    *
    * Use only if the objects are allocated from the same context and will not
    * be modified. Zeros the inherited ast_node's fields.
    */
   ast_type_specifier(const ast_type_specifier *that,
                      ast_array_specifier *array_specifier)
      : ast_node(), type_name(that->type_name), structure(that->structure),
        array_specifier(array_specifier),
        default_precision(that->default_precision)
   {
      /* empty */
   }

   /** Construct a type specifier from a type name */
   ast_type_specifier(const char *name) 
      : type_name(name), structure(NULL), array_specifier(NULL),
	default_precision(ast_precision_none)
   {
      /* empty */
   }

   /** Construct a type specifier from a structure definition */
   ast_type_specifier(ast_struct_specifier *s)
      : type_name(s->name), structure(s), array_specifier(NULL),
	default_precision(ast_precision_none)
   {
      /* empty */
   }

   const struct glsl_type *glsl_type(const char **name,
				     struct _mesa_glsl_parse_state *state)
      const;

   virtual void print(void) const;

   ir_rvalue *hir(exec_list *, struct _mesa_glsl_parse_state *);

   const char *type_name;
   ast_struct_specifier *structure;

   ast_array_specifier *array_specifier;

   /** For precision statements, this is the given precision; otherwise none. */
   unsigned default_precision:2;
};


class ast_fully_specified_type : public ast_node {
public:
   virtual void print(void) const;
   bool has_qualifiers() const;

   ast_fully_specified_type() : qualifier(), specifier(NULL)
   {
   }

   const struct glsl_type *glsl_type(const char **name,
				     struct _mesa_glsl_parse_state *state)
      const;

   ast_type_qualifier qualifier;
   ast_type_specifier *specifier;
};


class ast_declarator_list : public ast_node {
public:
   ast_declarator_list(ast_fully_specified_type *);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_fully_specified_type *type;
   /** List of 'ast_declaration *' */
   exec_list declarations;

   /**
    * Special flag for vertex shader "invariant" declarations.
    *
    * Vertex shaders can contain "invariant" variable redeclarations that do
    * not include a type.  For example, "invariant gl_Position;".  This flag
    * is used to note these cases when no type is specified.
    */
   int invariant;
};


class ast_parameter_declarator : public ast_node {
public:
   ast_parameter_declarator() :
      type(NULL),
      identifier(NULL),
      array_specifier(NULL),
      formal_parameter(false),
      is_void(false)
   {
      /* empty */
   }

   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_fully_specified_type *type;
   const char *identifier;
   ast_array_specifier *array_specifier;

   static void parameters_to_hir(exec_list *ast_parameters,
				 bool formal, exec_list *ir_parameters,
				 struct _mesa_glsl_parse_state *state);

private:
   /** Is this parameter declaration part of a formal parameter list? */
   bool formal_parameter;

   /**
    * Is this parameter 'void' type?
    *
    * This field is set by \c ::hir.
    */
   bool is_void;
};


class ast_function : public ast_node {
public:
   ast_function(void);

   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_fully_specified_type *return_type;
   const char *identifier;

   exec_list parameters;

private:
   /**
    * Is this prototype part of the function definition?
    *
    * Used by ast_function_definition::hir to process the parameters, etc.
    * of the function.
    *
    * \sa ::hir
    */
   bool is_definition;

   /**
    * Function signature corresponding to this function prototype instance
    *
    * Used by ast_function_definition::hir to process the parameters, etc.
    * of the function.
    *
    * \sa ::hir
    */
   class ir_function_signature *signature;

   friend class ast_function_definition;
};


class ast_expression_statement : public ast_node {
public:
   ast_expression_statement(ast_expression *);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_expression *expression;
};


class ast_case_label : public ast_node {
public:
   ast_case_label(ast_expression *test_value);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   /**
    * An test value of NULL means 'default'.
    */
   ast_expression *test_value;
};


class ast_case_label_list : public ast_node {
public:
   ast_case_label_list(void);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   /**
    * A list of case labels.
    */
   exec_list labels;
};


class ast_case_statement : public ast_node {
public:
   ast_case_statement(ast_case_label_list *labels);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_case_label_list *labels;

   /**
    * A list of statements.
    */
   exec_list stmts;
};


class ast_case_statement_list : public ast_node {
public:
   ast_case_statement_list(void);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   /**
    * A list of cases.
    */
   exec_list cases;
};


class ast_switch_body : public ast_node {
public:
   ast_switch_body(ast_case_statement_list *stmts);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_case_statement_list *stmts;
};


class ast_selection_statement : public ast_node {
public:
   ast_selection_statement(ast_expression *condition,
			   ast_node *then_statement,
			   ast_node *else_statement);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_expression *condition;
   ast_node *then_statement;
   ast_node *else_statement;
};


class ast_switch_statement : public ast_node {
public:
   ast_switch_statement(ast_expression *test_expression,
			ast_node *body);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_expression *test_expression;
   ast_node *body;

protected:
   void test_to_hir(exec_list *, struct _mesa_glsl_parse_state *);
};

class ast_iteration_statement : public ast_node {
public:
   ast_iteration_statement(int mode, ast_node *init, ast_node *condition,
			   ast_expression *rest_expression, ast_node *body);

   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *, struct _mesa_glsl_parse_state *);

   enum ast_iteration_modes {
      ast_for,
      ast_while,
      ast_do_while
   } mode;
   

   ast_node *init_statement;
   ast_node *condition;
   ast_expression *rest_expression;

   ast_node *body;

   /**
    * Generate IR from the condition of a loop
    *
    * This is factored out of ::hir because some loops have the condition
    * test at the top (for and while), and others have it at the end (do-while).
    */
   void condition_to_hir(exec_list *, struct _mesa_glsl_parse_state *);
};


class ast_jump_statement : public ast_node {
public:
   ast_jump_statement(int mode, ast_expression *return_value);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   enum ast_jump_modes {
      ast_continue,
      ast_break,
      ast_return,
      ast_discard
   } mode;

   ast_expression *opt_return_value;
};


class ast_function_definition : public ast_node {
public:
   ast_function_definition() : prototype(NULL), body(NULL)
   {
   }

   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_function *prototype;
   ast_compound_statement *body;
};

class ast_interface_block : public ast_node {
public:
   ast_interface_block(ast_type_qualifier layout,
                       const char *instance_name,
                       ast_array_specifier *array_specifier)
   : layout(layout), block_name(NULL), instance_name(instance_name),
     array_specifier(array_specifier)
   {
   }

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_type_qualifier layout;
   const char *block_name;

   /**
    * Declared name of the block instance, if specified.
    *
    * If the block does not have an instance name, this field will be
    * \c NULL.
    */
   const char *instance_name;

   /** List of ast_declarator_list * */
   exec_list declarations;

   /**
    * Declared array size of the block instance
    *
    * If the block is not declared as an array or if the block instance array
    * is unsized, this field will be \c NULL.
    */
   ast_array_specifier *array_specifier;
};


/**
 * AST node representing a declaration of the input layout for geometry
 * shaders.
 */
class ast_gs_input_layout : public ast_node
{
public:
   ast_gs_input_layout(const struct YYLTYPE &locp, GLenum prim_type)
      : prim_type(prim_type)
   {
      set_location(locp);
   }

   virtual ir_rvalue *hir(exec_list *instructions,
                          struct _mesa_glsl_parse_state *state);

private:
   const GLenum prim_type;
};


/**
 * AST node representing a decalaration of the input layout for compute
 * shaders.
 */
class ast_cs_input_layout : public ast_node
{
public:
   ast_cs_input_layout(const struct YYLTYPE &locp, const unsigned *local_size)
   {
      memcpy(this->local_size, local_size, sizeof(this->local_size));
      set_location(locp);
   }

   virtual ir_rvalue *hir(exec_list *instructions,
                          struct _mesa_glsl_parse_state *state);

private:
   unsigned local_size[3];
};

/*@@}*/

extern void
_mesa_ast_to_hir(exec_list *instructions, struct _mesa_glsl_parse_state *state);

extern ir_rvalue *
_mesa_ast_field_selection_to_hir(const ast_expression *expr,
				 exec_list *instructions,
				 struct _mesa_glsl_parse_state *state);

extern ir_rvalue *
_mesa_ast_array_index_to_hir(void *mem_ctx,
			     struct _mesa_glsl_parse_state *state,
			     ir_rvalue *array, ir_rvalue *idx,
			     YYLTYPE &loc, YYLTYPE &idx_loc);

extern void
_mesa_ast_set_aggregate_type(const glsl_type *type,
                             ast_expression *expr);

void
emit_function(_mesa_glsl_parse_state *state, ir_function *f);

extern void
check_builtin_array_max_size(const char *name, unsigned size,
                             YYLTYPE loc, struct _mesa_glsl_parse_state *state);

#endif /* AST_H */
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a426 1
         unsigned precise:1;
a510 2
         unsigned stream:1; /**< Has stream value assigned  */
         unsigned explicit_stream:1; /**< stream value assigned explicitly by shader code */
a543 3
   /** Stream in GLSL 1.50 geometry shaders. */
   unsigned stream;

d748 5
a752 2
    * Flags for redeclarations. In these cases, no type is specified, to
    * `type` is allowed to be NULL. In all other cases, this would be an error.
d754 1
a754 2
   int invariant;     /** < `invariant` redeclaration */
   int precise;       /** < `precise` redeclaration */
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d427 1
d512 2
d547 3
d754 2
a755 5
    * Special flag for vertex shader "invariant" declarations.
    *
    * Vertex shaders can contain "invariant" variable redeclarations that do
    * not include a type.  For example, "invariant gl_Position;".  This flag
    * is used to note these cases when no type is specified.
d757 2
a758 1
   int invariant;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d52 1
a52 18
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   /* If the user *does* call delete, that's OK, we will just
    * ralloc_free in that case. */
   static void operator delete(void *table)
   {
      ralloc_free(table);
   }
d78 4
a81 4
      locp.first_line = this->location.line;
      locp.first_column = this->location.column;
      locp.last_line = locp.first_line;
      locp.last_column = locp.first_column;
d94 18
a111 2
      this->location.line = locp.first_line;
      this->location.column = locp.first_column;
d118 5
a122 3
      unsigned source;    /**< GLSL source number. */
      unsigned line;      /**< Line number within the source string. */
      unsigned column;    /**< Column in the line. */
d220 7
d297 3
d307 33
d360 10
a369 1
   ast_type_specifier *constructor_type;
d372 3
d401 3
a403 2
   ast_declaration(const char *identifier, bool is_array, ast_expression *array_size,
		   ast_expression *initializer);
d407 2
a408 3
   
   bool is_array;
   ast_expression *array_size;
d422 1
a422 18
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   /* If the user *does* call delete, that's OK, we will just
    * ralloc_free in that case. */
   static void operator delete(void *table)
   {
      ralloc_free(table);
   }
d433 1
d462 6
d484 28
d517 1
a517 1
      unsigned i;
d523 3
d541 6
d556 35
d625 6
d674 2
a675 2
   ast_type_specifier(const ast_type_specifier *that, bool is_array,
                      ast_expression *array_size)
d677 1
a677 1
        is_array(is_array), array_size(array_size),
d685 1
a685 2
      : type_name(name), structure(NULL),
	is_array(false), array_size(NULL),
d693 1
a693 2
      : type_name(s->name), structure(s),
	is_array(false), array_size(NULL),
d710 1
a710 2
   bool is_array;
   ast_expression *array_size;
d722 4
d763 1
a763 2
      is_array(false),
      array_size(NULL),
d777 1
a777 2
   bool is_array;
   ast_expression *array_size;
a974 1
private:
d981 1
a981 1
   void condition_to_hir(class ir_loop *, struct _mesa_glsl_parse_state *);
d1006 4
d1022 2
a1023 2
                     const char *instance_name,
		     ast_expression *array_size)
d1025 1
a1025 1
     array_size(array_size)
a1026 1
      /* empty */
d1049 2
a1050 5
    * If the block is not declared as an array, this field will be \c NULL.
    *
    * \note
    * A block can only be an array if it also has an instance name.  If this
    * field is not \c NULL, ::instance_name must also not be \c NULL.
d1052 22
a1073 1
   ast_expression *array_size;
d1075 22
d1114 2
a1115 3
_mesa_ast_set_aggregate_type(const ast_type_specifier *type,
                             ast_expression *expr,
                             _mesa_glsl_parse_state *state);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d192 2
a193 1
   ast_sequence
d210 2
a211 1
      primary_expression.identifier = (char *) identifier;
d226 1
a226 1
      char *identifier;
d239 12
d296 24
d345 1
a345 1
   ast_declaration(char *identifier, int is_array, ast_expression *array_size,
d349 1
a349 1
   char *identifier;
d351 1
a351 1
   int is_array;
d366 19
d410 11
d429 9
d446 3
d456 15
d478 15
d503 4
d509 2
d513 15
a527 1
   ast_struct_specifier(char *identifier, ast_node *declarator_list);
d533 2
a534 1
   char *name;
d536 1
a539 57
enum ast_types {
   ast_void,
   ast_float,
   ast_int,
   ast_uint,
   ast_bool,
   ast_vec2,
   ast_vec3,
   ast_vec4,
   ast_bvec2,
   ast_bvec3,
   ast_bvec4,
   ast_ivec2,
   ast_ivec3,
   ast_ivec4,
   ast_uvec2,
   ast_uvec3,
   ast_uvec4,
   ast_mat2,
   ast_mat2x3,
   ast_mat2x4,
   ast_mat3x2,
   ast_mat3,
   ast_mat3x4,
   ast_mat4x2,
   ast_mat4x3,
   ast_mat4,
   ast_sampler1d,
   ast_sampler2d,
   ast_sampler2drect,
   ast_sampler3d,
   ast_samplercube,
   ast_sampler1dshadow,
   ast_sampler2dshadow,
   ast_sampler2drectshadow,
   ast_samplercubeshadow,
   ast_sampler1darray,
   ast_sampler2darray,
   ast_sampler1darrayshadow,
   ast_sampler2darrayshadow,
   ast_isampler1d,
   ast_isampler2d,
   ast_isampler3d,
   ast_isamplercube,
   ast_isampler1darray,
   ast_isampler2darray,
   ast_usampler1d,
   ast_usampler2d,
   ast_usampler3d,
   ast_usamplercube,
   ast_usampler1darray,
   ast_usampler2darray,

   ast_struct,
   ast_type_name
};

d543 15
a557 1
   ast_type_specifier(int specifier);
d561 3
a563 3
      : type_specifier(ast_type_name), type_name(name), structure(NULL),
	is_array(false), array_size(NULL), precision(ast_precision_none),
	is_precision_statement(false)
d570 3
a572 3
      : type_specifier(ast_struct), type_name(s->name), structure(s),
	is_array(false), array_size(NULL), precision(ast_precision_none),
	is_precision_statement(false)
a584 2
   enum ast_types type_specifier;

d588 1
a588 1
   int is_array;
d591 2
a592 3
   unsigned precision:2;

   bool is_precision_statement;
d601 4
d619 1
d635 7
a641 1
   ast_parameter_declarator()
d643 1
a643 3
      this->identifier = NULL;
      this->is_array = false;
      this->array_size = 0;
d652 2
a653 2
   char *identifier;
   int is_array;
d683 1
a683 1
   char *identifier;
d726 20
d748 1
a748 1
    * An expression of NULL means 'default'.
d750 45
a794 1
   ast_expression *expression;
d797 1
d816 12
a827 2
   ast_expression *expression;
   exec_list statements;
d892 40
d942 11
d955 4
@


1.1
log
@Initial revision
@
text
@d353 13
a365 1
      } q;
d375 18
a392 1
   unsigned location;
a616 19
class ast_declaration_statement : public ast_node {
public:
   ast_declaration_statement(void);

   enum {
      ast_function,
      ast_declaration,
      ast_precision
   } mode;

   union {
      class ast_function *function;
      ast_declarator_list *declarator;
      ast_type_specifier *type;
      ast_node *node;
   } declaration;
};


d733 1
a733 2
emit_function(_mesa_glsl_parse_state *state, exec_list *instructions,
	      ir_function *f);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d192 1
a192 2
   ast_sequence,
   ast_aggregate
d209 1
a209 2
      primary_expression.identifier = identifier;
      this->non_lvalue_description = NULL;
d224 1
a224 1
      const char *identifier;
a236 12

   /**
    * For things that can't be l-values, this describes what it is.
    *
    * This text is used by the code that generates IR for assignments to
    * detect and emit useful messages for assignments to some things that
    * can't be l-values.  For example, pre- or post-incerement expressions.
    *
    * \note
    * This pointer may be \c NULL.
    */
   const char *non_lvalue_description;
a281 24
/**
 * C-style aggregate initialization class
 *
 * Represents C-style initializers of vectors, matrices, arrays, and
 * structures. E.g., vec3 pos = {1.0, 0.0, -1.0} is equivalent to
 * vec3 pos = vec3(1.0, 0.0, -1.0).
 *
 * Specified in GLSL 4.20 and GL_ARB_shading_language_420pack.
 *
 * \sa _mesa_ast_set_aggregate_type
 */
class ast_aggregate_initializer : public ast_expression {
public:
   ast_aggregate_initializer()
      : ast_expression(ast_aggregate, NULL, NULL, NULL),
        constructor_type(NULL)
   {
      /* empty */
   }

   ast_type_specifier *constructor_type;
   virtual ir_rvalue *hir(exec_list *instructions,
                          struct _mesa_glsl_parse_state *state);
};
d307 1
a307 1
   ast_declaration(const char *identifier, bool is_array, ast_expression *array_size,
d311 1
a311 1
   const char *identifier;
d313 1
a313 1
   bool is_array;
a327 19
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   /* If the user *does* call delete, that's OK, we will just
    * ralloc_free in that case. */
   static void operator delete(void *table)
   {
      ralloc_free(table);
   }

d353 1
a353 33
	 /**
	  * Flag set if GL_ARB_explicit_attrib_location "index" layout
	  * qualifier is used.
	  */
	 unsigned explicit_index:1;

         /**
          * Flag set if GL_ARB_shading_language_420pack "binding" layout
          * qualifier is used.
          */
         unsigned explicit_binding:1;

         /** \name Layout qualifiers for GL_AMD_conservative_depth */
         /** \{ */
         unsigned depth_any:1;
         unsigned depth_greater:1;
         unsigned depth_less:1;
         unsigned depth_unchanged:1;
         /** \} */

	 /** \name Layout qualifiers for GL_ARB_uniform_buffer_object */
	 /** \{ */
         unsigned std140:1;
         unsigned shared:1;
         unsigned packed:1;
         unsigned column_major:1;
         unsigned row_major:1;
	 /** \} */
      }
      /** \brief Set of flags, accessed by name. */
      q;

      /** \brief Set of flags, accessed as a bitmask. */
a356 3
   /** Precision of the type (highp/medium/lowp). */
   unsigned precision:2;

d363 1
a363 52
   int location;
   /**
    * Index specified via GL_ARB_explicit_attrib_location layout
    *
    * \note
    * This field is only valid if \c explicit_index is set.
    */
   int index;

   /**
    * Binding specified via GL_ARB_shading_language_420pack's "binding" keyword.
    *
    * \note
    * This field is only valid if \c explicit_binding is set.
    */
   int binding;

   /**
    * Return true if and only if an interpolation qualifier is present.
    */
   bool has_interpolation() const;

   /**
    * Return whether a layout qualifier is present.
    */
   bool has_layout() const;

   /**
    * Return whether a storage qualifier is present.
    */
   bool has_storage() const;

   /**
    * Return whether an auxiliary storage qualifier is present.
    */
   bool has_auxiliary_storage() const;

   /**
    * \brief Return string representation of interpolation qualifier.
    *
    * If an interpolation qualifier is present, then return that qualifier's
    * string representation. Otherwise, return null. For example, if the
    * noperspective bit is set, then this returns "noperspective".
    *
    * If multiple interpolation qualifiers are somehow present, then the
    * returned string is undefined but not null.
    */
   const char *interpolation_string() const;

   bool merge_qualifier(YYLTYPE *loc,
			_mesa_glsl_parse_state *state,
			ast_type_qualifier q);
a365 2
class ast_declarator_list;

d368 1
a368 15
   /**
    * \brief Make a shallow copy of an ast_struct_specifier.
    *
    * Use only if the objects are allocated from the same context and will not
    * be modified. Zeros the inherited ast_node's fields.
    */
   ast_struct_specifier(const ast_struct_specifier& that):
      ast_node(), name(that.name), declarations(that.declarations),
      is_declaration(that.is_declaration)
   {
      /* empty */
   }

   ast_struct_specifier(const char *identifier,
			ast_declarator_list *declarator_list);
d374 1
a374 2
   const char *name;
   /* List of ast_declarator_list * */
a375 1
   bool is_declaration;
d379 57
d439 1
a439 15
   /**
    * \brief Make a shallow copy of an ast_type_specifier, specifying array
    *        fields.
    *
    * Use only if the objects are allocated from the same context and will not
    * be modified. Zeros the inherited ast_node's fields.
    */
   ast_type_specifier(const ast_type_specifier *that, bool is_array,
                      ast_expression *array_size)
      : ast_node(), type_name(that->type_name), structure(that->structure),
        is_array(is_array), array_size(array_size),
        default_precision(that->default_precision)
   {
      /* empty */
   }
d443 3
a445 3
      : type_name(name), structure(NULL),
	is_array(false), array_size(NULL),
	default_precision(ast_precision_none)
d452 3
a454 3
      : type_name(s->name), structure(s),
	is_array(false), array_size(NULL),
	default_precision(ast_precision_none)
d467 2
d472 1
a472 1
   bool is_array;
d475 3
a477 2
   /** For precision statements, this is the given precision; otherwise none. */
   unsigned default_precision:2;
a485 4
   const struct glsl_type *glsl_type(const char **name,
				     struct _mesa_glsl_parse_state *state)
      const;

a499 1
   /** List of 'ast_declaration *' */
d515 1
a515 7
   ast_parameter_declarator() :
      type(NULL),
      identifier(NULL),
      is_array(false),
      array_size(NULL),
      formal_parameter(false),
      is_void(false)
d517 3
a519 1
      /* empty */
d528 2
a529 2
   const char *identifier;
   bool is_array;
d559 1
a559 1
   const char *identifier;
d588 1
a588 13
class ast_expression_statement : public ast_node {
public:
   ast_expression_statement(ast_expression *);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_expression *expression;
};


class ast_case_label : public ast_node {
d590 1
a590 2
   ast_case_label(ast_expression *test_value);
   virtual void print(void) const;
d592 5
a596 2
   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);
d598 6
a603 4
   /**
    * An test value of NULL means 'default'.
    */
   ast_expression *test_value;
d607 1
a607 1
class ast_case_label_list : public ast_node {
d609 1
a609 1
   ast_case_label_list(void);
d615 1
a615 4
   /**
    * A list of case labels.
    */
   exec_list labels;
d619 1
a619 1
class ast_case_statement : public ast_node {
a620 7
   ast_case_statement(ast_case_label_list *labels);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_case_label_list *labels;
d623 1
a623 1
    * A list of statements.
d625 1
a625 28
   exec_list stmts;
};


class ast_case_statement_list : public ast_node {
public:
   ast_case_statement_list(void);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   /**
    * A list of cases.
    */
   exec_list cases;
};


class ast_switch_body : public ast_node {
public:
   ast_switch_body(ast_case_statement_list *stmts);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_case_statement_list *stmts;
a627 1

d646 2
a647 12
   ast_switch_statement(ast_expression *test_expression,
			ast_node *body);
   virtual void print(void) const;

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_expression *test_expression;
   ast_node *body;

protected:
   void test_to_hir(exec_list *, struct _mesa_glsl_parse_state *);
a711 40

class ast_interface_block : public ast_node {
public:
   ast_interface_block(ast_type_qualifier layout,
                     const char *instance_name,
		     ast_expression *array_size)
   : layout(layout), block_name(NULL), instance_name(instance_name),
     array_size(array_size)
   {
      /* empty */
   }

   virtual ir_rvalue *hir(exec_list *instructions,
			  struct _mesa_glsl_parse_state *state);

   ast_type_qualifier layout;
   const char *block_name;

   /**
    * Declared name of the block instance, if specified.
    *
    * If the block does not have an instance name, this field will be
    * \c NULL.
    */
   const char *instance_name;

   /** List of ast_declarator_list * */
   exec_list declarations;

   /**
    * Declared array size of the block instance
    *
    * If the block is not declared as an array, this field will be \c NULL.
    *
    * \note
    * A block can only be an array if it also has an instance name.  If this
    * field is not \c NULL, ::instance_name must also not be \c NULL.
    */
   ast_expression *array_size;
};
a721 11
extern ir_rvalue *
_mesa_ast_array_index_to_hir(void *mem_ctx,
			     struct _mesa_glsl_parse_state *state,
			     ir_rvalue *array, ir_rvalue *idx,
			     YYLTYPE &loc, YYLTYPE &idx_loc);

extern void
_mesa_ast_set_aggregate_type(const ast_type_specifier *type,
                             ast_expression *expr,
                             _mesa_glsl_parse_state *state);

d723 2
a724 5
emit_function(_mesa_glsl_parse_state *state, ir_function *f);

extern void
check_builtin_array_max_size(const char *name, unsigned size,
                             YYLTYPE loc, struct _mesa_glsl_parse_state *state);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d52 18
a69 1
   DECLARE_RALLOC_CXX_OPERATORS(ast_node);
d95 4
a98 4
      locp.first_line = this->location.first_line;
      locp.first_column = this->location.first_column;
      locp.last_line = this->location.last_line;
      locp.last_column = this->location.last_column;
d111 2
a112 18
      this->location.first_line = locp.first_line;
      this->location.first_column = locp.first_column;
      this->location.last_line = locp.last_line;
      this->location.last_column = locp.last_column;
   }

   /**
    * Set the source location range of an AST node using two location nodes
    *
    * \sa ast_node::set_location
    */
   void set_location_range(const struct YYLTYPE &begin, const struct YYLTYPE &end)
   {
      this->location.source = begin.source;
      this->location.first_line = begin.first_line;
      this->location.last_line = end.last_line;
      this->location.first_column = begin.first_column;
      this->location.last_column = end.last_column;
d119 3
a121 5
      unsigned source;          /**< GLSL source number. */
      unsigned first_line;      /**< First line number within the source string. */
      unsigned first_column;    /**< First column in the first line. */
      unsigned last_line;       /**< Last line number within the source string. */
      unsigned last_column;     /**< Last column in the last line. */
a218 7
   virtual void hir_no_rvalue(exec_list *instructions,
                              struct _mesa_glsl_parse_state *state);

   ir_rvalue *do_hir(exec_list *instructions,
                     struct _mesa_glsl_parse_state *state,
                     bool needs_rvalue);

a288 3
   virtual void hir_no_rvalue(exec_list *instructions,
                              struct _mesa_glsl_parse_state *state);

a295 33
class ast_array_specifier : public ast_node {
public:
   /** Unsized array specifier ([]) */
   explicit ast_array_specifier(const struct YYLTYPE &locp)
     : is_unsized_array(true)
   {
      set_location(locp);
   }

   /** Sized array specifier ([dim]) */
   ast_array_specifier(const struct YYLTYPE &locp, ast_expression *dim)
     : is_unsized_array(false)
   {
      set_location(locp);
      array_dimensions.push_tail(&dim->link);
   }

   void add_dimension(ast_expression *dim)
   {
      array_dimensions.push_tail(&dim->link);
   }

   virtual void print(void) const;

   /* If true, this means that the array has an unsized outermost dimension. */
   bool is_unsized_array;

   /* This list contains objects of type ast_node containing the
    * sized dimensions only, in outermost-to-innermost order.
    */
   exec_list array_dimensions;
};

d316 1
a316 10
   /**
    * glsl_type of the aggregate, which is inferred from the LHS of whatever
    * the aggregate is being used to initialize.  This can't be inferred at
    * parse time (since the parser deals with ast_type_specifiers, not
    * glsl_types), so the parser leaves it NULL.  However, the ast-to-hir
    * conversion code makes sure to fill it in with the appropriate type
    * before hir() is called.
    */
   const glsl_type *constructor_type;

a318 3

   virtual void hir_no_rvalue(exec_list *instructions,
                              struct _mesa_glsl_parse_state *state);
d345 2
a346 3
   ast_declaration(const char *identifier,
                   ast_array_specifier *array_specifier,
                   ast_expression *initializer);
d350 3
a352 2

   ast_array_specifier *array_specifier;
d366 18
a383 1
   DECLARE_RALLOC_CXX_OPERATORS(ast_type_qualifier);
a393 1
         unsigned sample:1;
a421 6
         /**
          * Flag set if GL_ARB_shader_atomic counter "offset" layout
          * qualifier is used.
          */
         unsigned explicit_offset:1;

a437 28

	 /** \name Layout qualifiers for GLSL 1.50 geometry shaders */
	 /** \{ */
	 unsigned prim_type:1;
	 unsigned max_vertices:1;
	 /** \} */

         /**
          * local_size_{x,y,z} flags for compute shaders.  Bit 0 represents
          * local_size_x, and so on.
          */
         unsigned local_size:3;

	 /** \name Layout and memory qualifiers for ARB_shader_image_load_store. */
	 /** \{ */
	 unsigned early_fragment_tests:1;
	 unsigned explicit_image_format:1;
	 unsigned coherent:1;
	 unsigned _volatile:1;
	 unsigned restrict_flag:1;
	 unsigned read_only:1; /**< "readonly" qualifier. */
	 unsigned write_only:1; /**< "writeonly" qualifier. */
	 /** \} */

         /** \name Layout qualifiers for GL_ARB_gpu_shader5 */
         /** \{ */
         unsigned invocations:1;
         /** \} */
d443 1
a443 1
      uint64_t i;
a448 3
   /** Geometry shader invocations for GL_ARB_gpu_shader5. */
   int invocations;

a463 6
   /** Maximum output vertices in GLSL 1.50 geometry shaders. */
   int max_vertices;

   /** Input or output primitive type in GLSL 1.50 geometry shaders */
   GLenum prim_type;

a472 35
    * Offset specified via GL_ARB_shader_atomic_counter's "offset"
    * keyword.
    *
    * \note
    * This field is only valid if \c explicit_offset is set.
    */
   int offset;

   /**
    * Local size specified via GL_ARB_compute_shader's "local_size_{x,y,z}"
    * layout qualifier.  Element i of this array is only valid if
    * flags.q.local_size & (1 << i) is set.
    */
   int local_size[3];

   /**
    * Image format specified with an ARB_shader_image_load_store
    * layout qualifier.
    *
    * \note
    * This field is only valid if \c explicit_image_format is set.
    */
   GLenum image_format;

   /**
    * Base type of the data read from or written to this image.  Only
    * the following enumerants are allowed: GLSL_TYPE_UINT,
    * GLSL_TYPE_INT, GLSL_TYPE_FLOAT.
    *
    * \note
    * This field is only valid if \c explicit_image_format is set.
    */
   glsl_base_type image_base_type;

   /**
a506 6

   bool merge_in_qualifier(YYLTYPE *loc,
                           _mesa_glsl_parse_state *state,
                           ast_type_qualifier q,
                           ast_node* &node);

d550 2
a551 2
   ast_type_specifier(const ast_type_specifier *that,
                      ast_array_specifier *array_specifier)
d553 1
a553 1
        array_specifier(array_specifier),
d561 2
a562 1
      : type_name(name), structure(NULL), array_specifier(NULL),
d570 2
a571 1
      : type_name(s->name), structure(s), array_specifier(NULL),
d588 2
a589 1
   ast_array_specifier *array_specifier;
a600 4
   ast_fully_specified_type() : qualifier(), specifier(NULL)
   {
   }

d638 2
a639 1
      array_specifier(NULL),
d653 2
a654 1
   ast_array_specifier *array_specifier;
d852 1
d859 1
a859 1
   void condition_to_hir(exec_list *, struct _mesa_glsl_parse_state *);
a883 4
   ast_function_definition() : prototype(NULL), body(NULL)
   {
   }

d896 2
a897 2
                       const char *instance_name,
                       ast_array_specifier *array_specifier)
d899 1
a899 1
     array_specifier(array_specifier)
d901 1
d924 5
a928 2
    * If the block is not declared as an array or if the block instance array
    * is unsized, this field will be \c NULL.
d930 1
a930 22
   ast_array_specifier *array_specifier;
};


/**
 * AST node representing a declaration of the input layout for geometry
 * shaders.
 */
class ast_gs_input_layout : public ast_node
{
public:
   ast_gs_input_layout(const struct YYLTYPE &locp, GLenum prim_type)
      : prim_type(prim_type)
   {
      set_location(locp);
   }

   virtual ir_rvalue *hir(exec_list *instructions,
                          struct _mesa_glsl_parse_state *state);

private:
   const GLenum prim_type;
a931 22


/**
 * AST node representing a decalaration of the input layout for compute
 * shaders.
 */
class ast_cs_input_layout : public ast_node
{
public:
   ast_cs_input_layout(const struct YYLTYPE &locp, const unsigned *local_size)
   {
      memcpy(this->local_size, local_size, sizeof(this->local_size));
      set_location(locp);
   }

   virtual ir_rvalue *hir(exec_list *instructions,
                          struct _mesa_glsl_parse_state *state);

private:
   unsigned local_size[3];
};

d949 3
a951 2
_mesa_ast_set_aggregate_type(const glsl_type *type,
                             ast_expression *expr);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a426 1
         unsigned precise:1;
a510 2
         unsigned stream:1; /**< Has stream value assigned  */
         unsigned explicit_stream:1; /**< stream value assigned explicitly by shader code */
a543 3
   /** Stream in GLSL 1.50 geometry shaders. */
   unsigned stream;

d748 5
a752 2
    * Flags for redeclarations. In these cases, no type is specified, to
    * `type` is allowed to be NULL. In all other cases, this would be an error.
d754 1
a754 2
   int invariant;     /** < `invariant` redeclaration */
   int precise;       /** < `precise` redeclaration */
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d427 1
d512 2
d547 3
d754 2
a755 5
    * Special flag for vertex shader "invariant" declarations.
    *
    * Vertex shaders can contain "invariant" variable redeclarations that do
    * not include a type.  For example, "invariant gl_Position;".  This flag
    * is used to note these cases when no type is specified.
d757 2
a758 1
   int invariant;
@


