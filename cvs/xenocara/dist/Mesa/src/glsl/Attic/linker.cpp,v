head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.25;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file linker.cpp
 * GLSL linker implementation
 *
 * Given a set of shaders that are to be linked to generate a final program,
 * there are three distinct stages.
 *
 * In the first stage shaders are partitioned into groups based on the shader
 * type.  All shaders of a particular type (e.g., vertex shaders) are linked
 * together.
 *
 *   - Undefined references in each shader are resolve to definitions in
 *     another shader.
 *   - Types and qualifiers of uniforms, outputs, and global variables defined
 *     in multiple shaders with the same name are verified to be the same.
 *   - Initializers for uniforms and global variables defined
 *     in multiple shaders with the same name are verified to be the same.
 *
 * The result, in the terminology of the GLSL spec, is a set of shader
 * executables for each processing unit.
 *
 * After the first stage is complete, a series of semantic checks are performed
 * on each of the shader executables.
 *
 *   - Each shader executable must define a \c main function.
 *   - Each vertex shader executable must write to \c gl_Position.
 *   - Each fragment shader executable must write to either \c gl_FragData or
 *     \c gl_FragColor.
 *
 * In the final stage individual shader executables are linked to create a
 * complete exectuable.
 *
 *   - Types of uniforms defined in multiple shader stages with the same name
 *     are verified to be the same.
 *   - Initializers for uniforms defined in multiple shader stages with the
 *     same name are verified to be the same.
 *   - Types and qualifiers of outputs defined in one stage are verified to
 *     be the same as the types and qualifiers of inputs defined with the same
 *     name in a later stage.
 *
 * \author Ian Romanick <ian.d.romanick@@intel.com>
 */

#include "main/core.h"
#include "glsl_symbol_table.h"
#include "glsl_parser_extras.h"
#include "ir.h"
#include "program.h"
#include "program/hash_table.h"
#include "linker.h"
#include "link_varyings.h"
#include "ir_optimization.h"
#include "ir_rvalue_visitor.h"

extern "C" {
#include "main/shaderobj.h"
#include "main/enums.h"
}

void linker_error(gl_shader_program *, const char *, ...);

namespace {

/**
 * Visitor that determines whether or not a variable is ever written.
 */
class find_assignment_visitor : public ir_hierarchical_visitor {
public:
   find_assignment_visitor(const char *name)
      : name(name), found(false)
   {
      /* empty */
   }

   virtual ir_visitor_status visit_enter(ir_assignment *ir)
   {
      ir_variable *const var = ir->lhs->variable_referenced();

      if (strcmp(name, var->name) == 0) {
	 found = true;
	 return visit_stop;
      }

      return visit_continue_with_parent;
   }

   virtual ir_visitor_status visit_enter(ir_call *ir)
   {
      foreach_two_lists(formal_node, &ir->callee->parameters,
                        actual_node, &ir->actual_parameters) {
	 ir_rvalue *param_rval = (ir_rvalue *) actual_node;
	 ir_variable *sig_param = (ir_variable *) formal_node;

	 if (sig_param->data.mode == ir_var_function_out ||
	     sig_param->data.mode == ir_var_function_inout) {
	    ir_variable *var = param_rval->variable_referenced();
	    if (var && strcmp(name, var->name) == 0) {
	       found = true;
	       return visit_stop;
	    }
	 }
      }

      if (ir->return_deref != NULL) {
	 ir_variable *const var = ir->return_deref->variable_referenced();

	 if (strcmp(name, var->name) == 0) {
	    found = true;
	    return visit_stop;
	 }
      }

      return visit_continue_with_parent;
   }

   bool variable_found()
   {
      return found;
   }

private:
   const char *name;       /**< Find writes to a variable with this name. */
   bool found;             /**< Was a write to the variable found? */
};


/**
 * Visitor that determines whether or not a variable is ever read.
 */
class find_deref_visitor : public ir_hierarchical_visitor {
public:
   find_deref_visitor(const char *name)
      : name(name), found(false)
   {
      /* empty */
   }

   virtual ir_visitor_status visit(ir_dereference_variable *ir)
   {
      if (strcmp(this->name, ir->var->name) == 0) {
	 this->found = true;
	 return visit_stop;
      }

      return visit_continue;
   }

   bool variable_found() const
   {
      return this->found;
   }

private:
   const char *name;       /**< Find writes to a variable with this name. */
   bool found;             /**< Was a write to the variable found? */
};


class geom_array_resize_visitor : public ir_hierarchical_visitor {
public:
   unsigned num_vertices;
   gl_shader_program *prog;

   geom_array_resize_visitor(unsigned num_vertices, gl_shader_program *prog)
   {
      this->num_vertices = num_vertices;
      this->prog = prog;
   }

   virtual ~geom_array_resize_visitor()
   {
      /* empty */
   }

   virtual ir_visitor_status visit(ir_variable *var)
   {
      if (!var->type->is_array() || var->data.mode != ir_var_shader_in)
         return visit_continue;

      unsigned size = var->type->length;

      /* Generate a link error if the shader has declared this array with an
       * incorrect size.
       */
      if (size && size != this->num_vertices) {
         linker_error(this->prog, "size of array %s declared as %u, "
                      "but number of input vertices is %u\n",
                      var->name, size, this->num_vertices);
         return visit_continue;
      }

      /* Generate a link error if the shader attempts to access an input
       * array using an index too large for its actual size assigned at link
       * time.
       */
      if (var->data.max_array_access >= this->num_vertices) {
         linker_error(this->prog, "geometry shader accesses element %i of "
                      "%s, but only %i input vertices\n",
                      var->data.max_array_access, var->name, this->num_vertices);
         return visit_continue;
      }

      var->type = glsl_type::get_array_instance(var->type->element_type(),
                                                this->num_vertices);
      var->data.max_array_access = this->num_vertices - 1;

      return visit_continue;
   }

   /* Dereferences of input variables need to be updated so that their type
    * matches the newly assigned type of the variable they are accessing. */
   virtual ir_visitor_status visit(ir_dereference_variable *ir)
   {
      ir->type = ir->var->type;
      return visit_continue;
   }

   /* Dereferences of 2D input arrays need to be updated so that their type
    * matches the newly assigned type of the array they are accessing. */
   virtual ir_visitor_status visit_leave(ir_dereference_array *ir)
   {
      const glsl_type *const vt = ir->array->type;
      if (vt->is_array())
         ir->type = vt->element_type();
      return visit_continue;
   }
};


/**
 * Visitor that determines whether or not a shader uses ir_end_primitive.
 */
class find_end_primitive_visitor : public ir_hierarchical_visitor {
public:
   find_end_primitive_visitor()
      : found(false)
   {
      /* empty */
   }

   virtual ir_visitor_status visit(ir_end_primitive *)
   {
      found = true;
      return visit_stop;
   }

   bool end_primitive_found()
   {
      return found;
   }

private:
   bool found;
};

} /* anonymous namespace */

void
linker_error(gl_shader_program *prog, const char *fmt, ...)
{
   va_list ap;

   ralloc_strcat(&prog->InfoLog, "error: ");
   va_start(ap, fmt);
   ralloc_vasprintf_append(&prog->InfoLog, fmt, ap);
   va_end(ap);

   prog->LinkStatus = false;
}


void
linker_warning(gl_shader_program *prog, const char *fmt, ...)
{
   va_list ap;

   ralloc_strcat(&prog->InfoLog, "warning: ");
   va_start(ap, fmt);
   ralloc_vasprintf_append(&prog->InfoLog, fmt, ap);
   va_end(ap);

}


/**
 * Given a string identifying a program resource, break it into a base name
 * and an optional array index in square brackets.
 *
 * If an array index is present, \c out_base_name_end is set to point to the
 * "[" that precedes the array index, and the array index itself is returned
 * as a long.
 *
 * If no array index is present (or if the array index is negative or
 * mal-formed), \c out_base_name_end, is set to point to the null terminator
 * at the end of the input string, and -1 is returned.
 *
 * Only the final array index is parsed; if the string contains other array
 * indices (or structure field accesses), they are left in the base name.
 *
 * No attempt is made to check that the base name is properly formed;
 * typically the caller will look up the base name in a hash table, so
 * ill-formed base names simply turn into hash table lookup failures.
 */
long
parse_program_resource_name(const GLchar *name,
                            const GLchar **out_base_name_end)
{
   /* Section 7.3.1 ("Program Interfaces") of the OpenGL 4.3 spec says:
    *
    *     "When an integer array element or block instance number is part of
    *     the name string, it will be specified in decimal form without a "+"
    *     or "-" sign or any extra leading zeroes. Additionally, the name
    *     string will not include white space anywhere in the string."
    */

   const size_t len = strlen(name);
   *out_base_name_end = name + len;

   if (len == 0 || name[len-1] != ']')
      return -1;

   /* Walk backwards over the string looking for a non-digit character.  This
    * had better be the opening bracket for an array index.
    *
    * Initially, i specifies the location of the ']'.  Since the string may
    * contain only the ']' charcater, walk backwards very carefully.
    */
   unsigned i;
   for (i = len - 1; (i > 0) && isdigit(name[i-1]); --i)
      /* empty */ ;

   if ((i == 0) || name[i-1] != '[')
      return -1;

   long array_index = strtol(&name[i], NULL, 10);
   if (array_index < 0)
      return -1;

   *out_base_name_end = name + (i - 1);
   return array_index;
}


void
link_invalidate_variable_locations(exec_list *ir)
{
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();

      if (var == NULL)
         continue;

      /* Only assign locations for variables that lack an explicit location.
       * Explicit locations are set for all built-in variables, generic vertex
       * shader inputs (via layout(location=...)), and generic fragment shader
       * outputs (also via layout(location=...)).
       */
      if (!var->data.explicit_location) {
         var->data.location = -1;
         var->data.location_frac = 0;
      }

      /* ir_variable::is_unmatched_generic_inout is used by the linker while
       * connecting outputs from one stage to inputs of the next stage.
       *
       * There are two implicit assumptions here.  First, we assume that any
       * built-in variable (i.e., non-generic in or out) will have
       * explicit_location set.  Second, we assume that any generic in or out
       * will not have explicit_location set.
       *
       * This second assumption will only be valid until
       * GL_ARB_separate_shader_objects is supported.  When that extension is
       * implemented, this function will need some modifications.
       */
      if (!var->data.explicit_location) {
         var->data.is_unmatched_generic_inout = 1;
      } else {
         var->data.is_unmatched_generic_inout = 0;
      }
   }
}


/**
 * Set UsesClipDistance and ClipDistanceArraySize based on the given shader.
 *
 * Also check for errors based on incorrect usage of gl_ClipVertex and
 * gl_ClipDistance.
 *
 * Return false if an error was reported.
 */
static void
analyze_clip_usage(struct gl_shader_program *prog,
                   struct gl_shader *shader, GLboolean *UsesClipDistance,
                   GLuint *ClipDistanceArraySize)
{
   *ClipDistanceArraySize = 0;

   if (!prog->IsES && prog->Version >= 130) {
      /* From section 7.1 (Vertex Shader Special Variables) of the
       * GLSL 1.30 spec:
       *
       *   "It is an error for a shader to statically write both
       *   gl_ClipVertex and gl_ClipDistance."
       *
       * This does not apply to GLSL ES shaders, since GLSL ES defines neither
       * gl_ClipVertex nor gl_ClipDistance.
       */
      find_assignment_visitor clip_vertex("gl_ClipVertex");
      find_assignment_visitor clip_distance("gl_ClipDistance");

      clip_vertex.run(shader->ir);
      clip_distance.run(shader->ir);
      if (clip_vertex.variable_found() && clip_distance.variable_found()) {
         linker_error(prog, "%s shader writes to both `gl_ClipVertex' "
                      "and `gl_ClipDistance'\n",
                      _mesa_shader_stage_to_string(shader->Stage));
         return;
      }
      *UsesClipDistance = clip_distance.variable_found();
      ir_variable *clip_distance_var =
         shader->symbols->get_variable("gl_ClipDistance");
      if (clip_distance_var)
         *ClipDistanceArraySize = clip_distance_var->type->length;
   } else {
      *UsesClipDistance = false;
   }
}


/**
 * Verify that a vertex shader executable meets all semantic requirements.
 *
 * Also sets prog->Vert.UsesClipDistance and prog->Vert.ClipDistanceArraySize
 * as a side effect.
 *
 * \param shader  Vertex shader executable to be verified
 */
void
validate_vertex_shader_executable(struct gl_shader_program *prog,
				  struct gl_shader *shader)
{
   if (shader == NULL)
      return;

   /* From the GLSL 1.10 spec, page 48:
    *
    *     "The variable gl_Position is available only in the vertex
    *      language and is intended for writing the homogeneous vertex
    *      position. All executions of a well-formed vertex shader
    *      executable must write a value into this variable. [...] The
    *      variable gl_Position is available only in the vertex
    *      language and is intended for writing the homogeneous vertex
    *      position. All executions of a well-formed vertex shader
    *      executable must write a value into this variable."
    *
    * while in GLSL 1.40 this text is changed to:
    *
    *     "The variable gl_Position is available only in the vertex
    *      language and is intended for writing the homogeneous vertex
    *      position. It can be written at any time during shader
    *      execution. It may also be read back by a vertex shader
    *      after being written. This value will be used by primitive
    *      assembly, clipping, culling, and other fixed functionality
    *      operations, if present, that operate on primitives after
    *      vertex processing has occurred. Its value is undefined if
    *      the vertex shader executable does not write gl_Position."
    *
    * GLSL ES 3.00 is similar to GLSL 1.40--failing to write to gl_Position is
    * not an error.
    */
   if (prog->Version < (prog->IsES ? 300 : 140)) {
      find_assignment_visitor find("gl_Position");
      find.run(shader->ir);
      if (!find.variable_found()) {
	 linker_error(prog, "vertex shader does not write to `gl_Position'\n");
	 return;
      }
   }

   analyze_clip_usage(prog, shader, &prog->Vert.UsesClipDistance,
                      &prog->Vert.ClipDistanceArraySize);
}


/**
 * Verify that a fragment shader executable meets all semantic requirements
 *
 * \param shader  Fragment shader executable to be verified
 */
void
validate_fragment_shader_executable(struct gl_shader_program *prog,
				    struct gl_shader *shader)
{
   if (shader == NULL)
      return;

   find_assignment_visitor frag_color("gl_FragColor");
   find_assignment_visitor frag_data("gl_FragData");

   frag_color.run(shader->ir);
   frag_data.run(shader->ir);

   if (frag_color.variable_found() && frag_data.variable_found()) {
      linker_error(prog,  "fragment shader writes to both "
		   "`gl_FragColor' and `gl_FragData'\n");
   }
}

/**
 * Verify that a geometry shader executable meets all semantic requirements
 *
 * Also sets prog->Geom.VerticesIn, prog->Geom.UsesClipDistance, and
 * prog->Geom.ClipDistanceArraySize as a side effect.
 *
 * \param shader Geometry shader executable to be verified
 */
void
validate_geometry_shader_executable(struct gl_shader_program *prog,
				    struct gl_shader *shader)
{
   if (shader == NULL)
      return;

   unsigned num_vertices = vertices_per_prim(prog->Geom.InputType);
   prog->Geom.VerticesIn = num_vertices;

   analyze_clip_usage(prog, shader, &prog->Geom.UsesClipDistance,
                      &prog->Geom.ClipDistanceArraySize);

   find_end_primitive_visitor end_primitive;
   end_primitive.run(shader->ir);
   prog->Geom.UsesEndPrimitive = end_primitive.end_primitive_found();
}


/**
 * Perform validation of global variables used across multiple shaders
 */
void
cross_validate_globals(struct gl_shader_program *prog,
		       struct gl_shader **shader_list,
		       unsigned num_shaders,
		       bool uniforms_only)
{
   /* Examine all of the uniforms in all of the shaders and cross validate
    * them.
    */
   glsl_symbol_table variables;
   for (unsigned i = 0; i < num_shaders; i++) {
      if (shader_list[i] == NULL)
	 continue;

      foreach_list(node, shader_list[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();

	 if (var == NULL)
	    continue;

	 if (uniforms_only && (var->data.mode != ir_var_uniform))
	    continue;

	 /* Don't cross validate temporaries that are at global scope.  These
	  * will eventually get pulled into the shaders 'main'.
	  */
	 if (var->data.mode == ir_var_temporary)
	    continue;

	 /* If a global with this name has already been seen, verify that the
	  * new instance has the same type.  In addition, if the globals have
	  * initializers, the values of the initializers must be the same.
	  */
	 ir_variable *const existing = variables.get_variable(var->name);
	 if (existing != NULL) {
	    if (var->type != existing->type) {
	       /* Consider the types to be "the same" if both types are arrays
		* of the same type and one of the arrays is implicitly sized.
		* In addition, set the type of the linked variable to the
		* explicitly sized array.
		*/
	       if (var->type->is_array()
		   && existing->type->is_array()
		   && (var->type->fields.array == existing->type->fields.array)
		   && ((var->type->length == 0)
		       || (existing->type->length == 0))) {
		  if (var->type->length != 0) {
		     existing->type = var->type;
		  }
               } else if (var->type->is_record()
		   && existing->type->is_record()
		   && existing->type->record_compare(var->type)) {
		  existing->type = var->type;
	       } else {
		  linker_error(prog, "%s `%s' declared as type "
			       "`%s' and type `%s'\n",
			       mode_string(var),
			       var->name, var->type->name,
			       existing->type->name);
		  return;
	       }
	    }

	    if (var->data.explicit_location) {
	       if (existing->data.explicit_location
		   && (var->data.location != existing->data.location)) {
		     linker_error(prog, "explicit locations for %s "
				  "`%s' have differing values\n",
				  mode_string(var), var->name);
		     return;
	       }

	       existing->data.location = var->data.location;
	       existing->data.explicit_location = true;
	    }

            /* From the GLSL 4.20 specification:
             * "A link error will result if two compilation units in a program
             *  specify different integer-constant bindings for the same
             *  opaque-uniform name.  However, it is not an error to specify a
             *  binding on some but not all declarations for the same name"
             */
            if (var->data.explicit_binding) {
               if (existing->data.explicit_binding &&
                   var->data.binding != existing->data.binding) {
                  linker_error(prog, "explicit bindings for %s "
                               "`%s' have differing values\n",
                               mode_string(var), var->name);
                  return;
               }

               existing->data.binding = var->data.binding;
               existing->data.explicit_binding = true;
            }

            if (var->type->contains_atomic() &&
                var->data.atomic.offset != existing->data.atomic.offset) {
               linker_error(prog, "offset specifications for %s "
                            "`%s' have differing values\n",
                            mode_string(var), var->name);
               return;
            }

	    /* Validate layout qualifiers for gl_FragDepth.
	     *
	     * From the AMD/ARB_conservative_depth specs:
	     *
	     *    "If gl_FragDepth is redeclared in any fragment shader in a
	     *    program, it must be redeclared in all fragment shaders in
	     *    that program that have static assignments to
	     *    gl_FragDepth. All redeclarations of gl_FragDepth in all
	     *    fragment shaders in a single program must have the same set
	     *    of qualifiers."
	     */
	    if (strcmp(var->name, "gl_FragDepth") == 0) {
	       bool layout_declared = var->data.depth_layout != ir_depth_layout_none;
	       bool layout_differs =
		  var->data.depth_layout != existing->data.depth_layout;

	       if (layout_declared && layout_differs) {
		  linker_error(prog,
			       "All redeclarations of gl_FragDepth in all "
			       "fragment shaders in a single program must have "
			       "the same set of qualifiers.");
	       }

	       if (var->data.used && layout_differs) {
		  linker_error(prog,
			       "If gl_FragDepth is redeclared with a layout "
			       "qualifier in any fragment shader, it must be "
			       "redeclared with the same layout qualifier in "
			       "all fragment shaders that have assignments to "
			       "gl_FragDepth");
	       }
	    }

	    /* Page 35 (page 41 of the PDF) of the GLSL 4.20 spec says:
	     *
	     *     "If a shared global has multiple initializers, the
	     *     initializers must all be constant expressions, and they
	     *     must all have the same value. Otherwise, a link error will
	     *     result. (A shared global having only one initializer does
	     *     not require that initializer to be a constant expression.)"
	     *
	     * Previous to 4.20 the GLSL spec simply said that initializers
	     * must have the same value.  In this case of non-constant
	     * initializers, this was impossible to determine.  As a result,
	     * no vendor actually implemented that behavior.  The 4.20
	     * behavior matches the implemented behavior of at least one other
	     * vendor, so we'll implement that for all GLSL versions.
	     */
	    if (var->constant_initializer != NULL) {
	       if (existing->constant_initializer != NULL) {
		  if (!var->constant_initializer->has_value(existing->constant_initializer)) {
		     linker_error(prog, "initializers for %s "
				  "`%s' have differing values\n",
				  mode_string(var), var->name);
		     return;
		  }
	       } else {
		  /* If the first-seen instance of a particular uniform did not
		   * have an initializer but a later instance does, copy the
		   * initializer to the version stored in the symbol table.
		   */
		  /* FINISHME: This is wrong.  The constant_value field should
		   * FINISHME: not be modified!  Imagine a case where a shader
		   * FINISHME: without an initializer is linked in two different
		   * FINISHME: programs with shaders that have differing
		   * FINISHME: initializers.  Linking with the first will
		   * FINISHME: modify the shader, and linking with the second
		   * FINISHME: will fail.
		   */
		  existing->constant_initializer =
		     var->constant_initializer->clone(ralloc_parent(existing),
						      NULL);
	       }
	    }

	    if (var->data.has_initializer) {
	       if (existing->data.has_initializer
		   && (var->constant_initializer == NULL
		       || existing->constant_initializer == NULL)) {
		  linker_error(prog,
			       "shared global variable `%s' has multiple "
			       "non-constant initializers.\n",
			       var->name);
		  return;
	       }

	       /* Some instance had an initializer, so keep track of that.  In
		* this location, all sorts of initializers (constant or
		* otherwise) will propagate the existence to the variable
		* stored in the symbol table.
		*/
	       existing->data.has_initializer = true;
	    }

	    if (existing->data.invariant != var->data.invariant) {
	       linker_error(prog, "declarations for %s `%s' have "
			    "mismatching invariant qualifiers\n",
			    mode_string(var), var->name);
	       return;
	    }
            if (existing->data.centroid != var->data.centroid) {
               linker_error(prog, "declarations for %s `%s' have "
			    "mismatching centroid qualifiers\n",
			    mode_string(var), var->name);
               return;
            }
            if (existing->data.sample != var->data.sample) {
               linker_error(prog, "declarations for %s `%s` have "
                            "mismatching sample qualifiers\n",
                            mode_string(var), var->name);
               return;
            }
	 } else
	    variables.add_variable(var);
      }
   }
}


/**
 * Perform validation of uniforms used across multiple shader stages
 */
void
cross_validate_uniforms(struct gl_shader_program *prog)
{
   cross_validate_globals(prog, prog->_LinkedShaders,
                          MESA_SHADER_STAGES, true);
}

/**
 * Accumulates the array of prog->UniformBlocks and checks that all
 * definitons of blocks agree on their contents.
 */
static bool
interstage_cross_validate_uniform_blocks(struct gl_shader_program *prog)
{
   unsigned max_num_uniform_blocks = 0;
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      if (prog->_LinkedShaders[i])
	 max_num_uniform_blocks += prog->_LinkedShaders[i]->NumUniformBlocks;
   }

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];

      prog->UniformBlockStageIndex[i] = ralloc_array(prog, int,
						     max_num_uniform_blocks);
      for (unsigned int j = 0; j < max_num_uniform_blocks; j++)
	 prog->UniformBlockStageIndex[i][j] = -1;

      if (sh == NULL)
	 continue;

      for (unsigned int j = 0; j < sh->NumUniformBlocks; j++) {
	 int index = link_cross_validate_uniform_block(prog,
						       &prog->UniformBlocks,
						       &prog->NumUniformBlocks,
						       &sh->UniformBlocks[j]);

	 if (index == -1) {
	    linker_error(prog, "uniform block `%s' has mismatching definitions",
			 sh->UniformBlocks[j].Name);
	    return false;
	 }

	 prog->UniformBlockStageIndex[i][index] = j;
      }
   }

   return true;
}


/**
 * Populates a shaders symbol table with all global declarations
 */
static void
populate_symbol_table(gl_shader *sh)
{
   sh->symbols = new(sh) glsl_symbol_table;

   foreach_list(node, sh->ir) {
      ir_instruction *const inst = (ir_instruction *) node;
      ir_variable *var;
      ir_function *func;

      if ((func = inst->as_function()) != NULL) {
	 sh->symbols->add_function(func);
      } else if ((var = inst->as_variable()) != NULL) {
	 sh->symbols->add_variable(var);
      }
   }
}


/**
 * Remap variables referenced in an instruction tree
 *
 * This is used when instruction trees are cloned from one shader and placed in
 * another.  These trees will contain references to \c ir_variable nodes that
 * do not exist in the target shader.  This function finds these \c ir_variable
 * references and replaces the references with matching variables in the target
 * shader.
 *
 * If there is no matching variable in the target shader, a clone of the
 * \c ir_variable is made and added to the target shader.  The new variable is
 * added to \b both the instruction stream and the symbol table.
 *
 * \param inst         IR tree that is to be processed.
 * \param symbols      Symbol table containing global scope symbols in the
 *                     linked shader.
 * \param instructions Instruction stream where new variable declarations
 *                     should be added.
 */
void
remap_variables(ir_instruction *inst, struct gl_shader *target,
		hash_table *temps)
{
   class remap_visitor : public ir_hierarchical_visitor {
   public:
	 remap_visitor(struct gl_shader *target,
		    hash_table *temps)
      {
	 this->target = target;
	 this->symbols = target->symbols;
	 this->instructions = target->ir;
	 this->temps = temps;
      }

      virtual ir_visitor_status visit(ir_dereference_variable *ir)
      {
	 if (ir->var->data.mode == ir_var_temporary) {
	    ir_variable *var = (ir_variable *) hash_table_find(temps, ir->var);

	    assert(var != NULL);
	    ir->var = var;
	    return visit_continue;
	 }

	 ir_variable *const existing =
	    this->symbols->get_variable(ir->var->name);
	 if (existing != NULL)
	    ir->var = existing;
	 else {
	    ir_variable *copy = ir->var->clone(this->target, NULL);

	    this->symbols->add_variable(copy);
	    this->instructions->push_head(copy);
	    ir->var = copy;
	 }

	 return visit_continue;
      }

   private:
      struct gl_shader *target;
      glsl_symbol_table *symbols;
      exec_list *instructions;
      hash_table *temps;
   };

   remap_visitor v(target, temps);

   inst->accept(&v);
}


/**
 * Move non-declarations from one instruction stream to another
 *
 * The intended usage pattern of this function is to pass the pointer to the
 * head sentinel of a list (i.e., a pointer to the list cast to an \c exec_node
 * pointer) for \c last and \c false for \c make_copies on the first
 * call.  Successive calls pass the return value of the previous call for
 * \c last and \c true for \c make_copies.
 *
 * \param instructions Source instruction stream
 * \param last         Instruction after which new instructions should be
 *                     inserted in the target instruction stream
 * \param make_copies  Flag selecting whether instructions in \c instructions
 *                     should be copied (via \c ir_instruction::clone) into the
 *                     target list or moved.
 *
 * \return
 * The new "last" instruction in the target instruction stream.  This pointer
 * is suitable for use as the \c last parameter of a later call to this
 * function.
 */
exec_node *
move_non_declarations(exec_list *instructions, exec_node *last,
		      bool make_copies, gl_shader *target)
{
   hash_table *temps = NULL;

   if (make_copies)
      temps = hash_table_ctor(0, hash_table_pointer_hash,
			      hash_table_pointer_compare);

   foreach_list_safe(node, instructions) {
      ir_instruction *inst = (ir_instruction *) node;

      if (inst->as_function())
	 continue;

      ir_variable *var = inst->as_variable();
      if ((var != NULL) && (var->data.mode != ir_var_temporary))
	 continue;

      assert(inst->as_assignment()
             || inst->as_call()
             || inst->as_if() /* for initializers with the ?: operator */
	     || ((var != NULL) && (var->data.mode == ir_var_temporary)));

      if (make_copies) {
	 inst = inst->clone(target, NULL);

	 if (var != NULL)
	    hash_table_insert(temps, inst, var);
	 else
	    remap_variables(inst, target, temps);
      } else {
	 inst->remove();
      }

      last->insert_after(inst);
      last = inst;
   }

   if (make_copies)
      hash_table_dtor(temps);

   return last;
}

/**
 * Get the function signature for main from a shader
 */
static ir_function_signature *
get_main_function_signature(gl_shader *sh)
{
   ir_function *const f = sh->symbols->get_function("main");
   if (f != NULL) {
      exec_list void_parameters;

      /* Look for the 'void main()' signature and ensure that it's defined.
       * This keeps the linker from accidentally pick a shader that just
       * contains a prototype for main.
       *
       * We don't have to check for multiple definitions of main (in multiple
       * shaders) because that would have already been caught above.
       */
      ir_function_signature *sig = f->matching_signature(NULL, &void_parameters);
      if ((sig != NULL) && sig->is_defined) {
	 return sig;
      }
   }

   return NULL;
}


/**
 * This class is only used in link_intrastage_shaders() below but declaring
 * it inside that function leads to compiler warnings with some versions of
 * gcc.
 */
class array_sizing_visitor : public ir_hierarchical_visitor {
public:
   array_sizing_visitor()
      : mem_ctx(ralloc_context(NULL)),
        unnamed_interfaces(hash_table_ctor(0, hash_table_pointer_hash,
                                           hash_table_pointer_compare))
   {
   }

   ~array_sizing_visitor()
   {
      hash_table_dtor(this->unnamed_interfaces);
      ralloc_free(this->mem_ctx);
   }

   virtual ir_visitor_status visit(ir_variable *var)
   {
      fixup_type(&var->type, var->data.max_array_access);
      if (var->type->is_interface()) {
         if (interface_contains_unsized_arrays(var->type)) {
            const glsl_type *new_type =
               resize_interface_members(var->type, var->max_ifc_array_access);
            var->type = new_type;
            var->change_interface_type(new_type);
         }
      } else if (var->type->is_array() &&
                 var->type->fields.array->is_interface()) {
         if (interface_contains_unsized_arrays(var->type->fields.array)) {
            const glsl_type *new_type =
               resize_interface_members(var->type->fields.array,
                                        var->max_ifc_array_access);
            var->change_interface_type(new_type);
            var->type =
               glsl_type::get_array_instance(new_type, var->type->length);
         }
      } else if (const glsl_type *ifc_type = var->get_interface_type()) {
         /* Store a pointer to the variable in the unnamed_interfaces
          * hashtable.
          */
         ir_variable **interface_vars = (ir_variable **)
            hash_table_find(this->unnamed_interfaces, ifc_type);
         if (interface_vars == NULL) {
            interface_vars = rzalloc_array(mem_ctx, ir_variable *,
                                           ifc_type->length);
            hash_table_insert(this->unnamed_interfaces, interface_vars,
                              ifc_type);
         }
         unsigned index = ifc_type->field_index(var->name);
         assert(index < ifc_type->length);
         assert(interface_vars[index] == NULL);
         interface_vars[index] = var;
      }
      return visit_continue;
   }

   /**
    * For each unnamed interface block that was discovered while running the
    * visitor, adjust the interface type to reflect the newly assigned array
    * sizes, and fix up the ir_variable nodes to point to the new interface
    * type.
    */
   void fixup_unnamed_interface_types()
   {
      hash_table_call_foreach(this->unnamed_interfaces,
                              fixup_unnamed_interface_type, NULL);
   }

private:
   /**
    * If the type pointed to by \c type represents an unsized array, replace
    * it with a sized array whose size is determined by max_array_access.
    */
   static void fixup_type(const glsl_type **type, unsigned max_array_access)
   {
      if ((*type)->is_unsized_array()) {
         *type = glsl_type::get_array_instance((*type)->fields.array,
                                               max_array_access + 1);
         assert(*type != NULL);
      }
   }

   /**
    * Determine whether the given interface type contains unsized arrays (if
    * it doesn't, array_sizing_visitor doesn't need to process it).
    */
   static bool interface_contains_unsized_arrays(const glsl_type *type)
   {
      for (unsigned i = 0; i < type->length; i++) {
         const glsl_type *elem_type = type->fields.structure[i].type;
         if (elem_type->is_unsized_array())
            return true;
      }
      return false;
   }

   /**
    * Create a new interface type based on the given type, with unsized arrays
    * replaced by sized arrays whose size is determined by
    * max_ifc_array_access.
    */
   static const glsl_type *
   resize_interface_members(const glsl_type *type,
                            const unsigned *max_ifc_array_access)
   {
      unsigned num_fields = type->length;
      glsl_struct_field *fields = new glsl_struct_field[num_fields];
      memcpy(fields, type->fields.structure,
             num_fields * sizeof(*fields));
      for (unsigned i = 0; i < num_fields; i++) {
         fixup_type(&fields[i].type, max_ifc_array_access[i]);
      }
      glsl_interface_packing packing =
         (glsl_interface_packing) type->interface_packing;
      const glsl_type *new_ifc_type =
         glsl_type::get_interface_instance(fields, num_fields,
                                           packing, type->name);
      delete [] fields;
      return new_ifc_type;
   }

   static void fixup_unnamed_interface_type(const void *key, void *data,
                                            void *)
   {
      const glsl_type *ifc_type = (const glsl_type *) key;
      ir_variable **interface_vars = (ir_variable **) data;
      unsigned num_fields = ifc_type->length;
      glsl_struct_field *fields = new glsl_struct_field[num_fields];
      memcpy(fields, ifc_type->fields.structure,
             num_fields * sizeof(*fields));
      bool interface_type_changed = false;
      for (unsigned i = 0; i < num_fields; i++) {
         if (interface_vars[i] != NULL &&
             fields[i].type != interface_vars[i]->type) {
            fields[i].type = interface_vars[i]->type;
            interface_type_changed = true;
         }
      }
      if (!interface_type_changed) {
         delete [] fields;
         return;
      }
      glsl_interface_packing packing =
         (glsl_interface_packing) ifc_type->interface_packing;
      const glsl_type *new_ifc_type =
         glsl_type::get_interface_instance(fields, num_fields, packing,
                                           ifc_type->name);
      delete [] fields;
      for (unsigned i = 0; i < num_fields; i++) {
         if (interface_vars[i] != NULL)
            interface_vars[i]->change_interface_type(new_ifc_type);
      }
   }

   /**
    * Memory context used to allocate the data in \c unnamed_interfaces.
    */
   void *mem_ctx;

   /**
    * Hash table from const glsl_type * to an array of ir_variable *'s
    * pointing to the ir_variables constituting each unnamed interface block.
    */
   hash_table *unnamed_interfaces;
};

/**
 * Performs the cross-validation of layout qualifiers specified in
 * redeclaration of gl_FragCoord for the attached fragment shaders,
 * and propagates them to the linked FS and linked shader program.
 */
static void
link_fs_input_layout_qualifiers(struct gl_shader_program *prog,
	                        struct gl_shader *linked_shader,
	                        struct gl_shader **shader_list,
	                        unsigned num_shaders)
{
   linked_shader->redeclares_gl_fragcoord = false;
   linked_shader->uses_gl_fragcoord = false;
   linked_shader->origin_upper_left = false;
   linked_shader->pixel_center_integer = false;

   if (linked_shader->Stage != MESA_SHADER_FRAGMENT ||
       (prog->Version < 150 && !prog->ARB_fragment_coord_conventions_enable))
      return;

   for (unsigned i = 0; i < num_shaders; i++) {
      struct gl_shader *shader = shader_list[i];
      /* From the GLSL 1.50 spec, page 39:
       *
       *   "If gl_FragCoord is redeclared in any fragment shader in a program,
       *    it must be redeclared in all the fragment shaders in that program
       *    that have a static use gl_FragCoord."
       *
       * Exclude the case when one of the 'linked_shader' or 'shader' redeclares
       * gl_FragCoord with no layout qualifiers but the other one doesn't
       * redeclare it. If we strictly follow GLSL 1.50 spec's language, it
       * should be a link error. But, generating link error for this case will
       * be a wrong behaviour which spec didn't intend to do and it could also
       * break some applications.
       */
      if ((linked_shader->redeclares_gl_fragcoord
           && !shader->redeclares_gl_fragcoord
           && shader->uses_gl_fragcoord
           && (linked_shader->origin_upper_left
               || linked_shader->pixel_center_integer))
          || (shader->redeclares_gl_fragcoord
              && !linked_shader->redeclares_gl_fragcoord
              && linked_shader->uses_gl_fragcoord
              && (shader->origin_upper_left
                  || shader->pixel_center_integer))) {
             linker_error(prog, "fragment shader defined with conflicting "
                         "layout qualifiers for gl_FragCoord\n");
      }

      /* From the GLSL 1.50 spec, page 39:
       *
       *   "All redeclarations of gl_FragCoord in all fragment shaders in a
       *    single program must have the same set of qualifiers."
       */
      if (linked_shader->redeclares_gl_fragcoord && shader->redeclares_gl_fragcoord
          && (shader->origin_upper_left != linked_shader->origin_upper_left
          || shader->pixel_center_integer != linked_shader->pixel_center_integer)) {
         linker_error(prog, "fragment shader defined with conflicting "
                      "layout qualifiers for gl_FragCoord\n");
      }

      /* Update the linked shader state.  Note that uses_gl_fragcoord should
       * accumulate the results.  The other values should replace.  If there
       * are multiple redeclarations, all the fields except uses_gl_fragcoord
       * are already known to be the same.
       */
      if (shader->redeclares_gl_fragcoord || shader->uses_gl_fragcoord) {
         linked_shader->redeclares_gl_fragcoord =
            shader->redeclares_gl_fragcoord;
         linked_shader->uses_gl_fragcoord = linked_shader->uses_gl_fragcoord
            || shader->uses_gl_fragcoord;
         linked_shader->origin_upper_left = shader->origin_upper_left;
         linked_shader->pixel_center_integer = shader->pixel_center_integer;
      }
   }
}

/**
 * Performs the cross-validation of geometry shader max_vertices and
 * primitive type layout qualifiers for the attached geometry shaders,
 * and propagates them to the linked GS and linked shader program.
 */
static void
link_gs_inout_layout_qualifiers(struct gl_shader_program *prog,
				struct gl_shader *linked_shader,
				struct gl_shader **shader_list,
				unsigned num_shaders)
{
   linked_shader->Geom.VerticesOut = 0;
   linked_shader->Geom.Invocations = 0;
   linked_shader->Geom.InputType = PRIM_UNKNOWN;
   linked_shader->Geom.OutputType = PRIM_UNKNOWN;

   /* No in/out qualifiers defined for anything but GLSL 1.50+
    * geometry shaders so far.
    */
   if (linked_shader->Stage != MESA_SHADER_GEOMETRY || prog->Version < 150)
      return;

   /* From the GLSL 1.50 spec, page 46:
    *
    *     "All geometry shader output layout declarations in a program
    *      must declare the same layout and same value for
    *      max_vertices. There must be at least one geometry output
    *      layout declaration somewhere in a program, but not all
    *      geometry shaders (compilation units) are required to
    *      declare it."
    */

   for (unsigned i = 0; i < num_shaders; i++) {
      struct gl_shader *shader = shader_list[i];

      if (shader->Geom.InputType != PRIM_UNKNOWN) {
	 if (linked_shader->Geom.InputType != PRIM_UNKNOWN &&
	     linked_shader->Geom.InputType != shader->Geom.InputType) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "input types\n");
	    return;
	 }
	 linked_shader->Geom.InputType = shader->Geom.InputType;
      }

      if (shader->Geom.OutputType != PRIM_UNKNOWN) {
	 if (linked_shader->Geom.OutputType != PRIM_UNKNOWN &&
	     linked_shader->Geom.OutputType != shader->Geom.OutputType) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "output types\n");
	    return;
	 }
	 linked_shader->Geom.OutputType = shader->Geom.OutputType;
      }

      if (shader->Geom.VerticesOut != 0) {
	 if (linked_shader->Geom.VerticesOut != 0 &&
	     linked_shader->Geom.VerticesOut != shader->Geom.VerticesOut) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "output vertex count (%d and %d)\n",
			 linked_shader->Geom.VerticesOut,
			 shader->Geom.VerticesOut);
	    return;
	 }
	 linked_shader->Geom.VerticesOut = shader->Geom.VerticesOut;
      }

      if (shader->Geom.Invocations != 0) {
	 if (linked_shader->Geom.Invocations != 0 &&
	     linked_shader->Geom.Invocations != shader->Geom.Invocations) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "invocation count (%d and %d)\n",
			 linked_shader->Geom.Invocations,
			 shader->Geom.Invocations);
	    return;
	 }
	 linked_shader->Geom.Invocations = shader->Geom.Invocations;
      }
   }

   /* Just do the intrastage -> interstage propagation right now,
    * since we already know we're in the right type of shader program
    * for doing it.
    */
   if (linked_shader->Geom.InputType == PRIM_UNKNOWN) {
      linker_error(prog,
		   "geometry shader didn't declare primitive input type\n");
      return;
   }
   prog->Geom.InputType = linked_shader->Geom.InputType;

   if (linked_shader->Geom.OutputType == PRIM_UNKNOWN) {
      linker_error(prog,
		   "geometry shader didn't declare primitive output type\n");
      return;
   }
   prog->Geom.OutputType = linked_shader->Geom.OutputType;

   if (linked_shader->Geom.VerticesOut == 0) {
      linker_error(prog,
		   "geometry shader didn't declare max_vertices\n");
      return;
   }
   prog->Geom.VerticesOut = linked_shader->Geom.VerticesOut;

   if (linked_shader->Geom.Invocations == 0)
      linked_shader->Geom.Invocations = 1;

   prog->Geom.Invocations = linked_shader->Geom.Invocations;
}


/**
 * Perform cross-validation of compute shader local_size_{x,y,z} layout
 * qualifiers for the attached compute shaders, and propagate them to the
 * linked CS and linked shader program.
 */
static void
link_cs_input_layout_qualifiers(struct gl_shader_program *prog,
                                struct gl_shader *linked_shader,
                                struct gl_shader **shader_list,
                                unsigned num_shaders)
{
   for (int i = 0; i < 3; i++)
      linked_shader->Comp.LocalSize[i] = 0;

   /* This function is called for all shader stages, but it only has an effect
    * for compute shaders.
    */
   if (linked_shader->Stage != MESA_SHADER_COMPUTE)
      return;

   /* From the ARB_compute_shader spec, in the section describing local size
    * declarations:
    *
    *     If multiple compute shaders attached to a single program object
    *     declare local work-group size, the declarations must be identical;
    *     otherwise a link-time error results. Furthermore, if a program
    *     object contains any compute shaders, at least one must contain an
    *     input layout qualifier specifying the local work sizes of the
    *     program, or a link-time error will occur.
    */
   for (unsigned sh = 0; sh < num_shaders; sh++) {
      struct gl_shader *shader = shader_list[sh];

      if (shader->Comp.LocalSize[0] != 0) {
         if (linked_shader->Comp.LocalSize[0] != 0) {
            for (int i = 0; i < 3; i++) {
               if (linked_shader->Comp.LocalSize[i] !=
                   shader->Comp.LocalSize[i]) {
                  linker_error(prog, "compute shader defined with conflicting "
                               "local sizes\n");
                  return;
               }
            }
         }
         for (int i = 0; i < 3; i++)
            linked_shader->Comp.LocalSize[i] = shader->Comp.LocalSize[i];
      }
   }

   /* Just do the intrastage -> interstage propagation right now,
    * since we already know we're in the right type of shader program
    * for doing it.
    */
   if (linked_shader->Comp.LocalSize[0] == 0) {
      linker_error(prog, "compute shader didn't declare local size\n");
      return;
   }
   for (int i = 0; i < 3; i++)
      prog->Comp.LocalSize[i] = linked_shader->Comp.LocalSize[i];
}


/**
 * Combine a group of shaders for a single stage to generate a linked shader
 *
 * \note
 * If this function is supplied a single shader, it is cloned, and the new
 * shader is returned.
 */
static struct gl_shader *
link_intrastage_shaders(void *mem_ctx,
			struct gl_context *ctx,
			struct gl_shader_program *prog,
			struct gl_shader **shader_list,
			unsigned num_shaders)
{
   struct gl_uniform_block *uniform_blocks = NULL;

   /* Check that global variables defined in multiple shaders are consistent.
    */
   cross_validate_globals(prog, shader_list, num_shaders, false);
   if (!prog->LinkStatus)
      return NULL;

   /* Check that interface blocks defined in multiple shaders are consistent.
    */
   validate_intrastage_interface_blocks(prog, (const gl_shader **)shader_list,
                                        num_shaders);
   if (!prog->LinkStatus)
      return NULL;

   /* Link up uniform blocks defined within this stage. */
   const unsigned num_uniform_blocks =
      link_uniform_blocks(mem_ctx, prog, shader_list, num_shaders,
                          &uniform_blocks);

   /* Check that there is only a single definition of each function signature
    * across all shaders.
    */
   for (unsigned i = 0; i < (num_shaders - 1); i++) {
      foreach_list(node, shader_list[i]->ir) {
	 ir_function *const f = ((ir_instruction *) node)->as_function();

	 if (f == NULL)
	    continue;

	 for (unsigned j = i + 1; j < num_shaders; j++) {
	    ir_function *const other =
	       shader_list[j]->symbols->get_function(f->name);

	    /* If the other shader has no function (and therefore no function
	     * signatures) with the same name, skip to the next shader.
	     */
	    if (other == NULL)
	       continue;

	    foreach_list(n, &f->signatures) {
	       ir_function_signature *sig = (ir_function_signature *) n;

	       if (!sig->is_defined || sig->is_builtin())
		  continue;

	       ir_function_signature *other_sig =
		  other->exact_matching_signature(NULL, &sig->parameters);

	       if ((other_sig != NULL) && other_sig->is_defined
		   && !other_sig->is_builtin()) {
		  linker_error(prog, "function `%s' is multiply defined",
			       f->name);
		  return NULL;
	       }
	    }
	 }
      }
   }

   /* Find the shader that defines main, and make a clone of it.
    *
    * Starting with the clone, search for undefined references.  If one is
    * found, find the shader that defines it.  Clone the reference and add
    * it to the shader.  Repeat until there are no undefined references or
    * until a reference cannot be resolved.
    */
   gl_shader *main = NULL;
   for (unsigned i = 0; i < num_shaders; i++) {
      if (get_main_function_signature(shader_list[i]) != NULL) {
	 main = shader_list[i];
	 break;
      }
   }

   if (main == NULL) {
      linker_error(prog, "%s shader lacks `main'\n",
		   _mesa_shader_stage_to_string(shader_list[0]->Stage));
      return NULL;
   }

   gl_shader *linked = ctx->Driver.NewShader(NULL, 0, main->Type);
   linked->ir = new(linked) exec_list;
   clone_ir_list(mem_ctx, linked->ir, main->ir);

   linked->UniformBlocks = uniform_blocks;
   linked->NumUniformBlocks = num_uniform_blocks;
   ralloc_steal(linked, linked->UniformBlocks);

   link_fs_input_layout_qualifiers(prog, linked, shader_list, num_shaders);
   link_gs_inout_layout_qualifiers(prog, linked, shader_list, num_shaders);
   link_cs_input_layout_qualifiers(prog, linked, shader_list, num_shaders);

   populate_symbol_table(linked);

   /* The a pointer to the main function in the final linked shader (i.e., the
    * copy of the original shader that contained the main function).
    */
   ir_function_signature *const main_sig = get_main_function_signature(linked);

   /* Move any instructions other than variable declarations or function
    * declarations into main.
    */
   exec_node *insertion_point =
      move_non_declarations(linked->ir, (exec_node *) &main_sig->body, false,
			    linked);

   for (unsigned i = 0; i < num_shaders; i++) {
      if (shader_list[i] == main)
	 continue;

      insertion_point = move_non_declarations(shader_list[i]->ir,
					      insertion_point, true, linked);
   }

   /* Check if any shader needs built-in functions. */
   bool need_builtins = false;
   for (unsigned i = 0; i < num_shaders; i++) {
      if (shader_list[i]->uses_builtin_functions) {
         need_builtins = true;
         break;
      }
   }

   bool ok;
   if (need_builtins) {
      /* Make a temporary array one larger than shader_list, which will hold
       * the built-in function shader as well.
       */
      gl_shader **linking_shaders = (gl_shader **)
         calloc(num_shaders + 1, sizeof(gl_shader *));
      memcpy(linking_shaders, shader_list, num_shaders * sizeof(gl_shader *));
      linking_shaders[num_shaders] = _mesa_glsl_get_builtin_function_shader();

      ok = link_function_calls(prog, linked, linking_shaders, num_shaders + 1);

      free(linking_shaders);
   } else {
      ok = link_function_calls(prog, linked, shader_list, num_shaders);
   }


   if (!ok) {
      ctx->Driver.DeleteShader(ctx, linked);
      return NULL;
   }

   /* At this point linked should contain all of the linked IR, so
    * validate it to make sure nothing went wrong.
    */
   validate_ir_tree(linked->ir);

   /* Set the size of geometry shader input arrays */
   if (linked->Stage == MESA_SHADER_GEOMETRY) {
      unsigned num_vertices = vertices_per_prim(prog->Geom.InputType);
      geom_array_resize_visitor input_resize_visitor(num_vertices, prog);
      foreach_list(n, linked->ir) {
         ir_instruction *ir = (ir_instruction *) n;
         ir->accept(&input_resize_visitor);
      }
   }

   /* Make a pass over all variable declarations to ensure that arrays with
    * unspecified sizes have a size specified.  The size is inferred from the
    * max_array_access field.
    */
   array_sizing_visitor v;
   v.run(linked->ir);
   v.fixup_unnamed_interface_types();

   return linked;
}

/**
 * Update the sizes of linked shader uniform arrays to the maximum
 * array index used.
 *
 * From page 81 (page 95 of the PDF) of the OpenGL 2.1 spec:
 *
 *     If one or more elements of an array are active,
 *     GetActiveUniform will return the name of the array in name,
 *     subject to the restrictions listed above. The type of the array
 *     is returned in type. The size parameter contains the highest
 *     array element index used, plus one. The compiler or linker
 *     determines the highest index used.  There will be only one
 *     active uniform reported by the GL per uniform array.

 */
static void
update_array_sizes(struct gl_shader_program *prog)
{
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
	 if (prog->_LinkedShaders[i] == NULL)
	    continue;

      foreach_list(node, prog->_LinkedShaders[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();

	 if ((var == NULL) || (var->data.mode != ir_var_uniform) ||
	     !var->type->is_array())
	    continue;

	 /* GL_ARB_uniform_buffer_object says that std140 uniforms
	  * will not be eliminated.  Since we always do std140, just
	  * don't resize arrays in UBOs.
          *
          * Atomic counters are supposed to get deterministic
          * locations assigned based on the declaration ordering and
          * sizes, array compaction would mess that up.
	  */
	 if (var->is_in_uniform_block() || var->type->contains_atomic())
	    continue;

	 unsigned int size = var->data.max_array_access;
	 for (unsigned j = 0; j < MESA_SHADER_STAGES; j++) {
	       if (prog->_LinkedShaders[j] == NULL)
		  continue;

	    foreach_list(node2, prog->_LinkedShaders[j]->ir) {
	       ir_variable *other_var = ((ir_instruction *) node2)->as_variable();
	       if (!other_var)
		  continue;

	       if (strcmp(var->name, other_var->name) == 0 &&
		   other_var->data.max_array_access > size) {
		  size = other_var->data.max_array_access;
	       }
	    }
	 }

	 if (size + 1 != var->type->length) {
	    /* If this is a built-in uniform (i.e., it's backed by some
	     * fixed-function state), adjust the number of state slots to
	     * match the new array size.  The number of slots per array entry
	     * is not known.  It seems safe to assume that the total number of
	     * slots is an integer multiple of the number of array elements.
	     * Determine the number of slots per array element by dividing by
	     * the old (total) size.
	     */
	    if (var->num_state_slots > 0) {
	       var->num_state_slots = (size + 1)
		  * (var->num_state_slots / var->type->length);
	    }

	    var->type = glsl_type::get_array_instance(var->type->fields.array,
						      size + 1);
	    /* FINISHME: We should update the types of array
	     * dereferences of this variable now.
	     */
	 }
      }
   }
}

/**
 * Find a contiguous set of available bits in a bitmask.
 *
 * \param used_mask     Bits representing used (1) and unused (0) locations
 * \param needed_count  Number of contiguous bits needed.
 *
 * \return
 * Base location of the available bits on success or -1 on failure.
 */
int
find_available_slots(unsigned used_mask, unsigned needed_count)
{
   unsigned needed_mask = (1 << needed_count) - 1;
   const int max_bit_to_test = (8 * sizeof(used_mask)) - needed_count;

   /* The comparison to 32 is redundant, but without it GCC emits "warning:
    * cannot optimize possibly infinite loops" for the loop below.
    */
   if ((needed_count == 0) || (max_bit_to_test < 0) || (max_bit_to_test > 32))
      return -1;

   for (int i = 0; i <= max_bit_to_test; i++) {
      if ((needed_mask & ~used_mask) == needed_mask)
	 return i;

      needed_mask <<= 1;
   }

   return -1;
}


/**
 * Assign locations for either VS inputs for FS outputs
 *
 * \param prog          Shader program whose variables need locations assigned
 * \param target_index  Selector for the program target to receive location
 *                      assignmnets.  Must be either \c MESA_SHADER_VERTEX or
 *                      \c MESA_SHADER_FRAGMENT.
 * \param max_index     Maximum number of generic locations.  This corresponds
 *                      to either the maximum number of draw buffers or the
 *                      maximum number of generic attributes.
 *
 * \return
 * If locations are successfully assigned, true is returned.  Otherwise an
 * error is emitted to the shader link log and false is returned.
 */
bool
assign_attribute_or_color_locations(gl_shader_program *prog,
				    unsigned target_index,
				    unsigned max_index)
{
   /* Mark invalid locations as being used.
    */
   unsigned used_locations = (max_index >= 32)
      ? ~0 : ~((1 << max_index) - 1);

   assert((target_index == MESA_SHADER_VERTEX)
	  || (target_index == MESA_SHADER_FRAGMENT));

   gl_shader *const sh = prog->_LinkedShaders[target_index];
   if (sh == NULL)
      return true;

   /* Operate in a total of four passes.
    *
    * 1. Invalidate the location assignments for all vertex shader inputs.
    *
    * 2. Assign locations for inputs that have user-defined (via
    *    glBindVertexAttribLocation) locations and outputs that have
    *    user-defined locations (via glBindFragDataLocation).
    *
    * 3. Sort the attributes without assigned locations by number of slots
    *    required in decreasing order.  Fragmentation caused by attribute
    *    locations assigned by the application may prevent large attributes
    *    from having enough contiguous space.
    *
    * 4. Assign locations to any inputs without assigned locations.
    */

   const int generic_base = (target_index == MESA_SHADER_VERTEX)
      ? (int) VERT_ATTRIB_GENERIC0 : (int) FRAG_RESULT_DATA0;

   const enum ir_variable_mode direction =
      (target_index == MESA_SHADER_VERTEX)
      ? ir_var_shader_in : ir_var_shader_out;


   /* Temporary storage for the set of attributes that need locations assigned.
    */
   struct temp_attr {
      unsigned slots;
      ir_variable *var;

      /* Used below in the call to qsort. */
      static int compare(const void *a, const void *b)
      {
	 const temp_attr *const l = (const temp_attr *) a;
	 const temp_attr *const r = (const temp_attr *) b;

	 /* Reversed because we want a descending order sort below. */
	 return r->slots - l->slots;
      }
   } to_assign[16];

   unsigned num_attr = 0;

   foreach_list(node, sh->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();

      if ((var == NULL) || (var->data.mode != (unsigned) direction))
	 continue;

      if (var->data.explicit_location) {
	 if ((var->data.location >= (int)(max_index + generic_base))
	     || (var->data.location < 0)) {
	    linker_error(prog,
			 "invalid explicit location %d specified for `%s'\n",
			 (var->data.location < 0)
			 ? var->data.location
                         : var->data.location - generic_base,
			 var->name);
	    return false;
	 }
      } else if (target_index == MESA_SHADER_VERTEX) {
	 unsigned binding;

	 if (prog->AttributeBindings->get(binding, var->name)) {
	    assert(binding >= VERT_ATTRIB_GENERIC0);
	    var->data.location = binding;
            var->data.is_unmatched_generic_inout = 0;
	 }
      } else if (target_index == MESA_SHADER_FRAGMENT) {
	 unsigned binding;
	 unsigned index;

	 if (prog->FragDataBindings->get(binding, var->name)) {
	    assert(binding >= FRAG_RESULT_DATA0);
	    var->data.location = binding;
            var->data.is_unmatched_generic_inout = 0;

	    if (prog->FragDataIndexBindings->get(index, var->name)) {
	       var->data.index = index;
	    }
	 }
      }

      /* If the variable is not a built-in and has a location statically
       * assigned in the shader (presumably via a layout qualifier), make sure
       * that it doesn't collide with other assigned locations.  Otherwise,
       * add it to the list of variables that need linker-assigned locations.
       */
      const unsigned slots = var->type->count_attribute_slots();
      if (var->data.location != -1) {
	 if (var->data.location >= generic_base && var->data.index < 1) {
	    /* From page 61 of the OpenGL 4.0 spec:
	     *
	     *     "LinkProgram will fail if the attribute bindings assigned
	     *     by BindAttribLocation do not leave not enough space to
	     *     assign a location for an active matrix attribute or an
	     *     active attribute array, both of which require multiple
	     *     contiguous generic attributes."
	     *
	     * I think above text prohibits the aliasing of explicit and
	     * automatic assignments. But, aliasing is allowed in manual
	     * assignments of attribute locations. See below comments for
	     * the details.
	     *
	     * From OpenGL 4.0 spec, page 61:
	     *
	     *     "It is possible for an application to bind more than one
	     *     attribute name to the same location. This is referred to as
	     *     aliasing. This will only work if only one of the aliased
	     *     attributes is active in the executable program, or if no
	     *     path through the shader consumes more than one attribute of
	     *     a set of attributes aliased to the same location. A link
	     *     error can occur if the linker determines that every path
	     *     through the shader consumes multiple aliased attributes,
	     *     but implementations are not required to generate an error
	     *     in this case."
	     *
	     * From GLSL 4.30 spec, page 54:
	     *
	     *    "A program will fail to link if any two non-vertex shader
	     *     input variables are assigned to the same location. For
	     *     vertex shaders, multiple input variables may be assigned
	     *     to the same location using either layout qualifiers or via
	     *     the OpenGL API. However, such aliasing is intended only to
	     *     support vertex shaders where each execution path accesses
	     *     at most one input per each location. Implementations are
	     *     permitted, but not required, to generate link-time errors
	     *     if they detect that every path through the vertex shader
	     *     executable accesses multiple inputs assigned to any single
	     *     location. For all shader types, a program will fail to link
	     *     if explicit location assignments leave the linker unable
	     *     to find space for other variables without explicit
	     *     assignments."
	     *
	     * From OpenGL ES 3.0 spec, page 56:
	     *
	     *    "Binding more than one attribute name to the same location
	     *     is referred to as aliasing, and is not permitted in OpenGL
	     *     ES Shading Language 3.00 vertex shaders. LinkProgram will
	     *     fail when this condition exists. However, aliasing is
	     *     possible in OpenGL ES Shading Language 1.00 vertex shaders.
	     *     This will only work if only one of the aliased attributes
	     *     is active in the executable program, or if no path through
	     *     the shader consumes more than one attribute of a set of
	     *     attributes aliased to the same location. A link error can
	     *     occur if the linker determines that every path through the
	     *     shader consumes multiple aliased attributes, but implemen-
	     *     tations are not required to generate an error in this case."
	     *
	     * After looking at above references from OpenGL, OpenGL ES and
	     * GLSL specifications, we allow aliasing of vertex input variables
	     * in: OpenGL 2.0 (and above) and OpenGL ES 2.0.
	     *
	     * NOTE: This is not required by the spec but its worth mentioning
	     * here that we're not doing anything to make sure that no path
	     * through the vertex shader executable accesses multiple inputs
	     * assigned to any single location.
	     */

	    /* Mask representing the contiguous slots that will be used by
	     * this attribute.
	     */
	    const unsigned attr = var->data.location - generic_base;
	    const unsigned use_mask = (1 << slots) - 1;
            const char *const string = (target_index == MESA_SHADER_VERTEX)
               ? "vertex shader input" : "fragment shader output";

            /* Generate a link error if the requested locations for this
             * attribute exceed the maximum allowed attribute location.
             */
            if (attr + slots > max_index) {
               linker_error(prog,
                           "insufficient contiguous locations "
                           "available for %s `%s' %d %d %d", string,
                           var->name, used_locations, use_mask, attr);
               return false;
            }

	    /* Generate a link error if the set of bits requested for this
	     * attribute overlaps any previously allocated bits.
	     */
	    if ((~(use_mask << attr) & used_locations) != used_locations) {
               if (target_index == MESA_SHADER_FRAGMENT ||
                   (prog->IsES && prog->Version >= 300)) {
                  linker_error(prog,
                               "overlapping location is assigned "
                               "to %s `%s' %d %d %d\n", string,
                               var->name, used_locations, use_mask, attr);
                  return false;
               } else {
                  linker_warning(prog,
                                 "overlapping location is assigned "
                                 "to %s `%s' %d %d %d\n", string,
                                 var->name, used_locations, use_mask, attr);
               }
	    }

	    used_locations |= (use_mask << attr);
	 }

	 continue;
      }

      to_assign[num_attr].slots = slots;
      to_assign[num_attr].var = var;
      num_attr++;
   }

   /* If all of the attributes were assigned locations by the application (or
    * are built-in attributes with fixed locations), return early.  This should
    * be the common case.
    */
   if (num_attr == 0)
      return true;

   qsort(to_assign, num_attr, sizeof(to_assign[0]), temp_attr::compare);

   if (target_index == MESA_SHADER_VERTEX) {
      /* VERT_ATTRIB_GENERIC0 is a pseudo-alias for VERT_ATTRIB_POS.  It can
       * only be explicitly assigned by via glBindAttribLocation.  Mark it as
       * reserved to prevent it from being automatically allocated below.
       */
      find_deref_visitor find("gl_Vertex");
      find.run(sh->ir);
      if (find.variable_found())
	 used_locations |= (1 << 0);
   }

   for (unsigned i = 0; i < num_attr; i++) {
      /* Mask representing the contiguous slots that will be used by this
       * attribute.
       */
      const unsigned use_mask = (1 << to_assign[i].slots) - 1;

      int location = find_available_slots(used_locations, to_assign[i].slots);

      if (location < 0) {
	 const char *const string = (target_index == MESA_SHADER_VERTEX)
	    ? "vertex shader input" : "fragment shader output";

	 linker_error(prog,
		      "insufficient contiguous locations "
		      "available for %s `%s'",
		      string, to_assign[i].var->name);
	 return false;
      }

      to_assign[i].var->data.location = generic_base + location;
      to_assign[i].var->data.is_unmatched_generic_inout = 0;
      used_locations |= (use_mask << location);
   }

   return true;
}


/**
 * Demote shader inputs and outputs that are not used in other stages
 */
void
demote_shader_inputs_and_outputs(gl_shader *sh, enum ir_variable_mode mode)
{
   foreach_list(node, sh->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();

      if ((var == NULL) || (var->data.mode != int(mode)))
	 continue;

      /* A shader 'in' or 'out' variable is only really an input or output if
       * its value is used by other shader stages.  This will cause the variable
       * to have a location assigned.
       */
      if (var->data.is_unmatched_generic_inout) {
	 var->data.mode = ir_var_auto;
      }
   }
}


/**
 * Store the gl_FragDepth layout in the gl_shader_program struct.
 */
static void
store_fragdepth_layout(struct gl_shader_program *prog)
{
   if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] == NULL) {
      return;
   }

   struct exec_list *ir = prog->_LinkedShaders[MESA_SHADER_FRAGMENT]->ir;

   /* We don't look up the gl_FragDepth symbol directly because if
    * gl_FragDepth is not used in the shader, it's removed from the IR.
    * However, the symbol won't be removed from the symbol table.
    *
    * We're only interested in the cases where the variable is NOT removed
    * from the IR.
    */
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();

      if (var == NULL || var->data.mode != ir_var_shader_out) {
         continue;
      }

      if (strcmp(var->name, "gl_FragDepth") == 0) {
         switch (var->data.depth_layout) {
         case ir_depth_layout_none:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_NONE;
            return;
         case ir_depth_layout_any:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_ANY;
            return;
         case ir_depth_layout_greater:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_GREATER;
            return;
         case ir_depth_layout_less:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_LESS;
            return;
         case ir_depth_layout_unchanged:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_UNCHANGED;
            return;
         default:
            assert(0);
            return;
         }
      }
   }
}

/**
 * Validate the resources used by a program versus the implementation limits
 */
static void
check_resources(struct gl_context *ctx, struct gl_shader_program *prog)
{
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];

      if (sh == NULL)
	 continue;

      if (sh->num_samplers > ctx->Const.Program[i].MaxTextureImageUnits) {
	 linker_error(prog, "Too many %s shader texture samplers",
		      _mesa_shader_stage_to_string(i));
      }

      if (sh->num_uniform_components >
          ctx->Const.Program[i].MaxUniformComponents) {
         if (ctx->Const.GLSLSkipStrictMaxUniformLimitCheck) {
            linker_warning(prog, "Too many %s shader default uniform block "
                           "components, but the driver will try to optimize "
                           "them out; this is non-portable out-of-spec "
			   "behavior\n",
                           _mesa_shader_stage_to_string(i));
         } else {
            linker_error(prog, "Too many %s shader default uniform block "
			 "components",
                         _mesa_shader_stage_to_string(i));
         }
      }

      if (sh->num_combined_uniform_components >
	  ctx->Const.Program[i].MaxCombinedUniformComponents) {
         if (ctx->Const.GLSLSkipStrictMaxUniformLimitCheck) {
            linker_warning(prog, "Too many %s shader uniform components, "
                           "but the driver will try to optimize them out; "
                           "this is non-portable out-of-spec behavior\n",
                           _mesa_shader_stage_to_string(i));
         } else {
            linker_error(prog, "Too many %s shader uniform components",
                         _mesa_shader_stage_to_string(i));
         }
      }
   }

   unsigned blocks[MESA_SHADER_STAGES] = {0};
   unsigned total_uniform_blocks = 0;

   for (unsigned i = 0; i < prog->NumUniformBlocks; i++) {
      for (unsigned j = 0; j < MESA_SHADER_STAGES; j++) {
	 if (prog->UniformBlockStageIndex[j][i] != -1) {
	    blocks[j]++;
	    total_uniform_blocks++;
	 }
      }

      if (total_uniform_blocks > ctx->Const.MaxCombinedUniformBlocks) {
	 linker_error(prog, "Too many combined uniform blocks (%d/%d)",
		      prog->NumUniformBlocks,
		      ctx->Const.MaxCombinedUniformBlocks);
      } else {
	 for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
            const unsigned max_uniform_blocks =
               ctx->Const.Program[i].MaxUniformBlocks;
	    if (blocks[i] > max_uniform_blocks) {
	       linker_error(prog, "Too many %s uniform blocks (%d/%d)",
			    _mesa_shader_stage_to_string(i),
			    blocks[i],
			    max_uniform_blocks);
	       break;
	    }
	 }
      }
   }
}

/**
 * Validate shader image resources.
 */
static void
check_image_resources(struct gl_context *ctx, struct gl_shader_program *prog)
{
   unsigned total_image_units = 0;
   unsigned fragment_outputs = 0;

   if (!ctx->Extensions.ARB_shader_image_load_store)
      return;

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];

      if (sh) {
         if (sh->NumImages > ctx->Const.Program[i].MaxImageUniforms)
            linker_error(prog, "Too many %s shader image uniforms",
                         _mesa_shader_stage_to_string(i));

         total_image_units += sh->NumImages;

         if (i == MESA_SHADER_FRAGMENT) {
            foreach_list(node, sh->ir) {
               ir_variable *var = ((ir_instruction *)node)->as_variable();
               if (var && var->data.mode == ir_var_shader_out)
                  fragment_outputs += var->type->count_attribute_slots();
            }
         }
      }
   }

   if (total_image_units > ctx->Const.MaxCombinedImageUniforms)
      linker_error(prog, "Too many combined image uniforms");

   if (total_image_units + fragment_outputs >
       ctx->Const.MaxCombinedImageUnitsAndFragmentOutputs)
      linker_error(prog, "Too many combined image uniforms and fragment outputs");
}

void
link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
{
   tfeedback_decl *tfeedback_decls = NULL;
   unsigned num_tfeedback_decls = prog->TransformFeedback.NumVarying;

   void *mem_ctx = ralloc_context(NULL); // temporary linker context

   prog->LinkStatus = true; /* All error paths will set this to false */
   prog->Validated = false;
   prog->_Used = false;

   ralloc_free(prog->InfoLog);
   prog->InfoLog = ralloc_strdup(NULL, "");

   ralloc_free(prog->UniformBlocks);
   prog->UniformBlocks = NULL;
   prog->NumUniformBlocks = 0;
   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
      ralloc_free(prog->UniformBlockStageIndex[i]);
      prog->UniformBlockStageIndex[i] = NULL;
   }

   ralloc_free(prog->AtomicBuffers);
   prog->AtomicBuffers = NULL;
   prog->NumAtomicBuffers = 0;
   prog->ARB_fragment_coord_conventions_enable = false;

   /* Separate the shaders into groups based on their type.
    */
   struct gl_shader **shader_list[MESA_SHADER_STAGES];
   unsigned num_shaders[MESA_SHADER_STAGES];

   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
      shader_list[i] = (struct gl_shader **)
         calloc(prog->NumShaders, sizeof(struct gl_shader *));
      num_shaders[i] = 0;
   }

   unsigned min_version = UINT_MAX;
   unsigned max_version = 0;
   const bool is_es_prog =
      (prog->NumShaders > 0 && prog->Shaders[0]->IsES) ? true : false;
   for (unsigned i = 0; i < prog->NumShaders; i++) {
      min_version = MIN2(min_version, prog->Shaders[i]->Version);
      max_version = MAX2(max_version, prog->Shaders[i]->Version);

      if (prog->Shaders[i]->IsES != is_es_prog) {
	 linker_error(prog, "all shaders must use same shading "
		      "language version\n");
	 goto done;
      }

      prog->ARB_fragment_coord_conventions_enable |=
         prog->Shaders[i]->ARB_fragment_coord_conventions_enable;

      gl_shader_stage shader_type = prog->Shaders[i]->Stage;
      shader_list[shader_type][num_shaders[shader_type]] = prog->Shaders[i];
      num_shaders[shader_type]++;
   }

   /* In desktop GLSL, different shader versions may be linked together.  In
    * GLSL ES, all shader versions must be the same.
    */
   if (is_es_prog && min_version != max_version) {
      linker_error(prog, "all shaders must use same shading "
		   "language version\n");
      goto done;
   }

   prog->Version = max_version;
   prog->IsES = is_es_prog;

   /* Geometry shaders have to be linked with vertex shaders.
    */
   if (num_shaders[MESA_SHADER_GEOMETRY] > 0 &&
       num_shaders[MESA_SHADER_VERTEX] == 0 &&
       !prog->SeparateShader) {
      linker_error(prog, "Geometry shader must be linked with "
		   "vertex shader\n");
      goto done;
   }

   /* Compute shaders have additional restrictions. */
   if (num_shaders[MESA_SHADER_COMPUTE] > 0 &&
       num_shaders[MESA_SHADER_COMPUTE] != prog->NumShaders) {
      linker_error(prog, "Compute shaders may not be linked with any other "
                   "type of shader\n");
   }

   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
      if (prog->_LinkedShaders[i] != NULL)
	 ctx->Driver.DeleteShader(ctx, prog->_LinkedShaders[i]);

      prog->_LinkedShaders[i] = NULL;
   }

   /* Link all shaders for a particular stage and validate the result.
    */
   for (int stage = 0; stage < MESA_SHADER_STAGES; stage++) {
      if (num_shaders[stage] > 0) {
         gl_shader *const sh =
            link_intrastage_shaders(mem_ctx, ctx, prog, shader_list[stage],
                                    num_shaders[stage]);

         if (!prog->LinkStatus)
            goto done;

         switch (stage) {
         case MESA_SHADER_VERTEX:
            validate_vertex_shader_executable(prog, sh);
            break;
         case MESA_SHADER_GEOMETRY:
            validate_geometry_shader_executable(prog, sh);
            break;
         case MESA_SHADER_FRAGMENT:
            validate_fragment_shader_executable(prog, sh);
            break;
         }
         if (!prog->LinkStatus)
            goto done;

         _mesa_reference_shader(ctx, &prog->_LinkedShaders[stage], sh);
      }
   }

   if (num_shaders[MESA_SHADER_GEOMETRY] > 0)
      prog->LastClipDistanceArraySize = prog->Geom.ClipDistanceArraySize;
   else if (num_shaders[MESA_SHADER_VERTEX] > 0)
      prog->LastClipDistanceArraySize = prog->Vert.ClipDistanceArraySize;
   else
      prog->LastClipDistanceArraySize = 0; /* Not used */

   /* Here begins the inter-stage linking phase.  Some initial validation is
    * performed, then locations are assigned for uniforms, attributes, and
    * varyings.
    */
   cross_validate_uniforms(prog);
   if (!prog->LinkStatus)
      goto done;

   unsigned prev;

   for (prev = 0; prev <= MESA_SHADER_FRAGMENT; prev++) {
      if (prog->_LinkedShaders[prev] != NULL)
         break;
   }

   /* Validate the inputs of each stage with the output of the preceding
    * stage.
    */
   for (unsigned i = prev + 1; i <= MESA_SHADER_FRAGMENT; i++) {
      if (prog->_LinkedShaders[i] == NULL)
         continue;

      validate_interstage_inout_blocks(prog, prog->_LinkedShaders[prev],
                                       prog->_LinkedShaders[i]);
      if (!prog->LinkStatus)
         goto done;

      cross_validate_outputs_to_inputs(prog,
                                       prog->_LinkedShaders[prev],
                                       prog->_LinkedShaders[i]);
      if (!prog->LinkStatus)
         goto done;

      prev = i;
   }

   /* Cross-validate uniform blocks between shader stages */
   validate_interstage_uniform_blocks(prog, prog->_LinkedShaders,
                                      MESA_SHADER_STAGES);
   if (!prog->LinkStatus)
      goto done;

   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
      if (prog->_LinkedShaders[i] != NULL)
         lower_named_interface_blocks(mem_ctx, prog->_LinkedShaders[i]);
   }

   /* Implement the GLSL 1.30+ rule for discard vs infinite loops Do
    * it before optimization because we want most of the checks to get
    * dropped thanks to constant propagation.
    *
    * This rule also applies to GLSL ES 3.00.
    */
   if (max_version >= (is_es_prog ? 300 : 130)) {
      struct gl_shader *sh = prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
      if (sh) {
	 lower_discard_flow(sh->ir);
      }
   }

   if (!interstage_cross_validate_uniform_blocks(prog))
      goto done;

   /* Do common optimization before assigning storage for attributes,
    * uniforms, and varyings.  Later optimization could possibly make
    * some of that unused.
    */
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      if (prog->_LinkedShaders[i] == NULL)
	 continue;

      detect_recursion_linked(prog, prog->_LinkedShaders[i]->ir);
      if (!prog->LinkStatus)
	 goto done;

      if (ctx->ShaderCompilerOptions[i].LowerClipDistance) {
         lower_clip_distance(prog->_LinkedShaders[i]);
      }

      while (do_common_optimization(prog->_LinkedShaders[i]->ir, true, false,
                                    &ctx->ShaderCompilerOptions[i],
                                    ctx->Const.NativeIntegers))
	 ;
   }

   /* Mark all generic shader inputs and outputs as unpaired. */
   for (unsigned i = MESA_SHADER_VERTEX; i <= MESA_SHADER_FRAGMENT; i++) {
      if (prog->_LinkedShaders[i] != NULL) {
         link_invalidate_variable_locations(prog->_LinkedShaders[i]->ir);
      }
   }

   /* FINISHME: The value of the max_attribute_index parameter is
    * FINISHME: implementation dependent based on the value of
    * FINISHME: GL_MAX_VERTEX_ATTRIBS.  GL_MAX_VERTEX_ATTRIBS must be
    * FINISHME: at least 16, so hardcode 16 for now.
    */
   if (!assign_attribute_or_color_locations(prog, MESA_SHADER_VERTEX, 16)) {
      goto done;
   }

   if (!assign_attribute_or_color_locations(prog, MESA_SHADER_FRAGMENT, MAX2(ctx->Const.MaxDrawBuffers, ctx->Const.MaxDualSourceDrawBuffers))) {
      goto done;
   }

   unsigned first;
   for (first = 0; first <= MESA_SHADER_FRAGMENT; first++) {
      if (prog->_LinkedShaders[first] != NULL)
	 break;
   }

   if (num_tfeedback_decls != 0) {
      /* From GL_EXT_transform_feedback:
       *   A program will fail to link if:
       *
       *   * the <count> specified by TransformFeedbackVaryingsEXT is
       *     non-zero, but the program object has no vertex or geometry
       *     shader;
       */
      if (first == MESA_SHADER_FRAGMENT) {
         linker_error(prog, "Transform feedback varyings specified, but "
                      "no vertex or geometry shader is present.");
         goto done;
      }

      tfeedback_decls = ralloc_array(mem_ctx, tfeedback_decl,
                                     prog->TransformFeedback.NumVarying);
      if (!parse_tfeedback_decls(ctx, prog, mem_ctx, num_tfeedback_decls,
                                 prog->TransformFeedback.VaryingNames,
                                 tfeedback_decls))
         goto done;
   }

   /* Linking the stages in the opposite order (from fragment to vertex)
    * ensures that inter-shader outputs written to in an earlier stage are
    * eliminated if they are (transitively) not used in a later stage.
    */
   int last, next;
   for (last = MESA_SHADER_FRAGMENT; last >= 0; last--) {
      if (prog->_LinkedShaders[last] != NULL)
         break;
   }

   if (last >= 0 && last < MESA_SHADER_FRAGMENT) {
      gl_shader *const sh = prog->_LinkedShaders[last];

      if (num_tfeedback_decls != 0 || prog->SeparateShader) {
         /* There was no fragment shader, but we still have to assign varying
          * locations for use by transform feedback.
          */
         if (!assign_varying_locations(ctx, mem_ctx, prog,
                                       sh, NULL,
                                       num_tfeedback_decls, tfeedback_decls,
                                       0))
            goto done;
      }

      do_dead_builtin_varyings(ctx, sh, NULL,
                               num_tfeedback_decls, tfeedback_decls);

      if (!prog->SeparateShader)
         demote_shader_inputs_and_outputs(sh, ir_var_shader_out);

      /* Eliminate code that is now dead due to unused outputs being demoted.
       */
      while (do_dead_code(sh->ir, false))
         ;
   }
   else if (first == MESA_SHADER_FRAGMENT) {
      /* If the program only contains a fragment shader...
       */
      gl_shader *const sh = prog->_LinkedShaders[first];

      do_dead_builtin_varyings(ctx, NULL, sh,
                               num_tfeedback_decls, tfeedback_decls);

      if (prog->SeparateShader) {
         if (!assign_varying_locations(ctx, mem_ctx, prog,
                                       NULL /* producer */,
                                       sh /* consumer */,
                                       0 /* num_tfeedback_decls */,
                                       NULL /* tfeedback_decls */,
                                       0 /* gs_input_vertices */))
            goto done;
      } else
         demote_shader_inputs_and_outputs(sh, ir_var_shader_in);

      while (do_dead_code(sh->ir, false))
         ;
   }

   next = last;
   for (int i = next - 1; i >= 0; i--) {
      if (prog->_LinkedShaders[i] == NULL)
         continue;

      gl_shader *const sh_i = prog->_LinkedShaders[i];
      gl_shader *const sh_next = prog->_LinkedShaders[next];
      unsigned gs_input_vertices =
         next == MESA_SHADER_GEOMETRY ? prog->Geom.VerticesIn : 0;

      if (!assign_varying_locations(ctx, mem_ctx, prog, sh_i, sh_next,
                next == MESA_SHADER_FRAGMENT ? num_tfeedback_decls : 0,
                tfeedback_decls, gs_input_vertices))
         goto done;

      do_dead_builtin_varyings(ctx, sh_i, sh_next,
                next == MESA_SHADER_FRAGMENT ? num_tfeedback_decls : 0,
                tfeedback_decls);

      demote_shader_inputs_and_outputs(sh_i, ir_var_shader_out);
      demote_shader_inputs_and_outputs(sh_next, ir_var_shader_in);

      /* Eliminate code that is now dead due to unused outputs being demoted.
       */
      while (do_dead_code(sh_i->ir, false))
         ;
      while (do_dead_code(sh_next->ir, false))
         ;

      /* This must be done after all dead varyings are eliminated. */
      if (!check_against_output_limit(ctx, prog, sh_i))
         goto done;
      if (!check_against_input_limit(ctx, prog, sh_next))
         goto done;

      next = i;
   }

   if (!store_tfeedback_info(ctx, prog, num_tfeedback_decls, tfeedback_decls))
      goto done;

   update_array_sizes(prog);
   link_assign_uniform_locations(prog);
   link_assign_atomic_counter_resources(ctx, prog);
   store_fragdepth_layout(prog);

   check_resources(ctx, prog);
   check_image_resources(ctx, prog);
   link_check_atomic_counter_resources(ctx, prog);

   if (!prog->LinkStatus)
      goto done;

   /* OpenGL ES requires that a vertex shader and a fragment shader both be
    * present in a linked program. GL_ARB_ES2_compatibility doesn't say
    * anything about shader linking when one of the shaders (vertex or
    * fragment shader) is absent. So, the extension shouldn't change the
    * behavior specified in GLSL specification.
    */
   if (!prog->SeparateShader && ctx->API == API_OPENGLES2) {
      if (prog->_LinkedShaders[MESA_SHADER_VERTEX] == NULL) {
	 linker_error(prog, "program lacks a vertex shader\n");
      } else if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] == NULL) {
	 linker_error(prog, "program lacks a fragment shader\n");
      }
   }

   /* FINISHME: Assign fragment shader output locations. */

done:
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      free(shader_list[i]);
      if (prog->_LinkedShaders[i] == NULL)
	 continue;

      /* Do a final validation step to make sure that the IR wasn't
       * invalidated by any modifications performed after intrastage linking.
       */
      validate_ir_tree(prog->_LinkedShaders[i]->ir);

      /* Retain any live IR, but trash the rest. */
      reparent_ir(prog->_LinkedShaders[i]->ir, prog->_LinkedShaders[i]->ir);

      /* The symbol table in the linked shaders may contain references to
       * variables that were removed (e.g., unused uniforms).  Since it may
       * contain junk, there is no possible valid use.  Delete it and set the
       * pointer to NULL.
       */
      delete prog->_LinkedShaders[i]->symbols;
      prog->_LinkedShaders[i]->symbols = NULL;
   }

   ralloc_free(mem_ctx);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a76 1
#include "ir_uniform.h"
d252 1
d254 1
a254 2
 * Visitor that determines the highest stream id to which a (geometry) shader
 * emits vertices. It also checks whether End{Stream}Primitive is ever called.
d256 1
a256 1
class find_emit_vertex_visitor : public ir_hierarchical_visitor {
d258 2
a259 6
   find_emit_vertex_visitor(int max_allowed)
      : max_stream_allowed(max_allowed),
        invalid_stream_id(0),
        invalid_stream_id_from_emit_vertex(false),
        end_primitive_found(false),
        uses_non_zero_stream(false)
d264 1
a264 1
   virtual ir_visitor_status visit_leave(ir_emit_vertex *ir)
d266 2
a267 18
      int stream_id = ir->stream_id();

      if (stream_id < 0) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = true;
         return visit_stop;
      }

      if (stream_id > max_stream_allowed) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = true;
         return visit_stop;
      }

      if (stream_id != 0)
         uses_non_zero_stream = true;

      return visit_continue;
d270 1
a270 1
   virtual ir_visitor_status visit_leave(ir_end_primitive *ir)
d272 1
a272 46
      end_primitive_found = true;

      int stream_id = ir->stream_id();

      if (stream_id < 0) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = false;
         return visit_stop;
      }

      if (stream_id > max_stream_allowed) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = false;
         return visit_stop;
      }

      if (stream_id != 0)
         uses_non_zero_stream = true;

      return visit_continue;
   }

   bool error()
   {
      return invalid_stream_id != 0;
   }

   const char *error_func()
   {
      return invalid_stream_id_from_emit_vertex ?
         "EmitStreamVertex" : "EndStreamPrimitive";
   }

   int error_stream()
   {
      return invalid_stream_id;
   }

   bool uses_streams()
   {
      return uses_non_zero_stream;
   }

   bool uses_end_primitive()
   {
      return end_primitive_found;
d276 1
a276 5
   int max_stream_allowed;
   int invalid_stream_id;
   bool invalid_stream_id_from_emit_vertex;
   bool end_primitive_found;
   bool uses_non_zero_stream;
d370 2
a371 2
   foreach_in_list(ir_instruction, node, ir) {
      ir_variable *const var = node->as_variable();
d492 2
a493 2
    * All GLSL ES Versions are similar to GLSL 1.40--failing to write to
    * gl_Position is not an error.
d499 1
a499 8
        if (prog->IsES) {
          linker_warning(prog,
                         "vertex shader does not write to `gl_Position'."
                         "It's value is undefined. \n");
        } else {
          linker_error(prog,
                       "vertex shader does not write to `gl_Position'. \n");
        }
a552 22
}

/**
 * Check if geometry shaders emit to non-zero streams and do corresponding
 * validations.
 */
static void
validate_geometry_shader_emissions(struct gl_context *ctx,
                                   struct gl_shader_program *prog)
{
   if (prog->_LinkedShaders[MESA_SHADER_GEOMETRY] != NULL) {
      find_emit_vertex_visitor emit_vertex(ctx->Const.MaxVertexStreams - 1);
      emit_vertex.run(prog->_LinkedShaders[MESA_SHADER_GEOMETRY]->ir);
      if (emit_vertex.error()) {
         linker_error(prog, "Invalid call %s(%d). Accepted values for the "
                      "stream parameter are in the range [0, %d].",
                      emit_vertex.error_func(),
                      emit_vertex.error_stream(),
                      ctx->Const.MaxVertexStreams - 1);
      }
      prog->Geom.UsesStreams = emit_vertex.uses_streams();
      prog->Geom.UsesEndPrimitive = emit_vertex.uses_end_primitive();
d554 3
a556 29
      /* From the ARB_gpu_shader5 spec:
       *
       *   "Multiple vertex streams are supported only if the output primitive
       *    type is declared to be "points".  A program will fail to link if it
       *    contains a geometry shader calling EmitStreamVertex() or
       *    EndStreamPrimitive() if its output primitive type is not "points".
       *
       * However, in the same spec:
       *
       *   "The function EmitVertex() is equivalent to calling EmitStreamVertex()
       *    with <stream> set to zero."
       *
       * And:
       *
       *   "The function EndPrimitive() is equivalent to calling
       *    EndStreamPrimitive() with <stream> set to zero."
       *
       * Since we can call EmitVertex() and EndPrimitive() when we output
       * primitives other than points, calling EmitStreamVertex(0) or
       * EmitEndPrimitive(0) should not produce errors. This it also what Nvidia
       * does. Currently we only set prog->Geom.UsesStreams to TRUE when
       * EmitStreamVertex() or EmitEndPrimitive() are called with a non-zero
       * stream.
       */
      if (prog->Geom.UsesStreams && prog->Geom.OutputType != GL_POINTS) {
         linker_error(prog, "EmitStreamVertex(n) and EndStreamPrimitive(n) "
                      "with n>0 requires point output");
      }
   }
d577 2
a578 2
      foreach_in_list(ir_instruction, node, shader_list[i]->ir) {
	 ir_variable *const var = node->as_variable();
d847 2
a848 1
   foreach_in_list(ir_instruction, inst, sh->ir) {
d855 1
a855 2
         if (var->data.mode != ir_var_temporary)
            sh->symbols->add_variable(var);
d964 3
a966 1
   foreach_in_list_safe(ir_instruction, inst, instructions) {
d1003 2
a1004 2
ir_function_signature *
link_get_main_function_signature(gl_shader *sh)
d1017 1
a1017 2
      ir_function_signature *sig =
         f->matching_signature(NULL, &void_parameters, false);
d1053 1
a1053 2
               resize_interface_members(var->type,
                                        var->get_max_ifc_array_access());
d1062 1
a1062 1
                                        var->get_max_ifc_array_access());
a1480 2
   if (!prog->LinkStatus)
      return NULL;
d1486 2
a1487 2
      foreach_in_list(ir_instruction, node, shader_list[i]->ir) {
	 ir_function *const f = node->as_function();
d1502 3
a1504 1
	    foreach_in_list(ir_function_signature, sig, &f->signatures) {
d1531 1
a1531 1
      if (link_get_main_function_signature(shader_list[i]) != NULL) {
d1557 1
a1557 1
   /* The pointer to the main function in the final linked shader (i.e., the
d1560 1
a1560 2
   ir_function_signature *const main_sig =
      link_get_main_function_signature(linked);
d1593 2
d1596 1
a1596 5
      ok = linking_shaders != NULL;

      if (ok) {
         memcpy(linking_shaders, shader_list, num_shaders * sizeof(gl_shader *));
         linking_shaders[num_shaders] = _mesa_glsl_get_builtin_function_shader();
d1598 1
a1598 6
         ok = link_function_calls(prog, linked, linking_shaders, num_shaders + 1);

         free(linking_shaders);
      } else {
         _mesa_error_no_memory(__func__);
      }
d1618 2
a1619 1
      foreach_in_list(ir_instruction, ir, linked->ir) {
a1623 3
   if (ctx->Const.VertexID_is_zero_based)
      lower_vertex_id(linked);

d1657 2
a1658 2
      foreach_in_list(ir_instruction, node, prog->_LinkedShaders[i]->ir) {
	 ir_variable *const var = node->as_variable();
d1680 2
a1681 2
	    foreach_in_list(ir_instruction, node2, prog->_LinkedShaders[j]->ir) {
	       ir_variable *other_var = node2->as_variable();
d1701 3
a1703 4
            const unsigned num_slots = var->get_num_state_slots();
	    if (num_slots > 0) {
	       var->set_num_state_slots((size + 1)
                                        * (num_slots / var->type->length));
d1749 1
a1749 1
 * Assign locations for either VS inputs or FS outputs
d1823 2
a1824 2
   foreach_in_list(ir_instruction, node, sh->ir) {
      ir_variable *const var = node->as_variable();
d2042 2
a2043 2
   foreach_in_list(ir_instruction, node, sh->ir) {
      ir_variable *const var = node->as_variable();
a2052 1
         assert(var->data.mode != ir_var_temporary);
d2078 2
a2079 2
   foreach_in_list(ir_instruction, node, ir) {
      ir_variable *const var = node->as_variable();
d2210 2
a2211 2
            foreach_in_list(ir_instruction, node, sh->ir) {
               ir_variable *var = node->as_variable();
a2226 111

/**
 * Initializes explicit location slots to INACTIVE_UNIFORM_EXPLICIT_LOCATION
 * for a variable, checks for overlaps between other uniforms using explicit
 * locations.
 */
static bool
reserve_explicit_locations(struct gl_shader_program *prog,
                           string_to_uint_map *map, ir_variable *var)
{
   unsigned slots = var->type->uniform_locations();
   unsigned max_loc = var->data.location + slots - 1;

   /* Resize remap table if locations do not fit in the current one. */
   if (max_loc + 1 > prog->NumUniformRemapTable) {
      prog->UniformRemapTable =
         reralloc(prog, prog->UniformRemapTable,
                  gl_uniform_storage *,
                  max_loc + 1);

      if (!prog->UniformRemapTable) {
         linker_error(prog, "Out of memory during linking.");
         return false;
      }

      /* Initialize allocated space. */
      for (unsigned i = prog->NumUniformRemapTable; i < max_loc + 1; i++)
         prog->UniformRemapTable[i] = NULL;

      prog->NumUniformRemapTable = max_loc + 1;
   }

   for (unsigned i = 0; i < slots; i++) {
      unsigned loc = var->data.location + i;

      /* Check if location is already used. */
      if (prog->UniformRemapTable[loc] == INACTIVE_UNIFORM_EXPLICIT_LOCATION) {

         /* Possibly same uniform from a different stage, this is ok. */
         unsigned hash_loc;
         if (map->get(hash_loc, var->name) && hash_loc == loc - i)
               continue;

         /* ARB_explicit_uniform_location specification states:
          *
          *     "No two default-block uniform variables in the program can have
          *     the same location, even if they are unused, otherwise a compiler
          *     or linker error will be generated."
          */
         linker_error(prog,
                      "location qualifier for uniform %s overlaps "
                      "previously used location",
                      var->name);
         return false;
      }

      /* Initialize location as inactive before optimization
       * rounds and location assignment.
       */
      prog->UniformRemapTable[loc] = INACTIVE_UNIFORM_EXPLICIT_LOCATION;
   }

   /* Note, base location used for arrays. */
   map->put(var->data.location, var->name);

   return true;
}

/**
 * Check and reserve all explicit uniform locations, called before
 * any optimizations happen to handle also inactive uniforms and
 * inactive array elements that may get trimmed away.
 */
static void
check_explicit_uniform_locations(struct gl_context *ctx,
                                 struct gl_shader_program *prog)
{
   if (!ctx->Extensions.ARB_explicit_uniform_location)
      return;

   /* This map is used to detect if overlapping explicit locations
    * occur with the same uniform (from different stage) or a different one.
    */
   string_to_uint_map *uniform_map = new string_to_uint_map;

   if (!uniform_map) {
      linker_error(prog, "Out of memory during linking.");
      return;
   }

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];

      if (!sh)
         continue;

      foreach_in_list(ir_instruction, node, sh->ir) {
         ir_variable *var = node->as_variable();
         if ((var && var->data.mode == ir_var_uniform) &&
             var->data.explicit_location) {
            if (!reserve_explicit_locations(prog, uniform_map, var)) {
               delete uniform_map;
               return;
            }
         }
      }
   }

   delete uniform_map;
}

d2239 14
a2374 4
   check_explicit_uniform_locations(ctx, prog);
   if (!prog->LinkStatus)
      goto done;

d2435 1
a2435 1
      if (ctx->Const.ShaderCompilerOptions[i].LowerClipDistance) {
d2440 1
a2440 1
                                    &ctx->Const.ShaderCompilerOptions[i],
a2442 2

      lower_const_arrays_to_uniforms(prog->_LinkedShaders[i]->ir);
a2444 3
   /* Check and validate stream emissions in geometry shaders */
   validate_geometry_shader_emissions(ctx, prog);

a2505 15
      if (first == MESA_SHADER_GEOMETRY) {
         /* There was no vertex shader, but we still have to assign varying
          * locations for use by geometry shader inputs in SSO.
          *
          * If the shader is not separable (i.e., prog->SeparateShader is
          * false), linking will have already failed when first is
          * MESA_SHADER_GEOMETRY.
          */
         if (!assign_varying_locations(ctx, mem_ctx, prog,
                                       NULL, sh,
                                       num_tfeedback_decls, tfeedback_decls,
                                       prog->Geom.VerticesIn))
            goto done;
      }

d2593 1
a2593 1
   link_assign_uniform_locations(prog, ctx->Const.UniformBooleanTrue);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d77 1
a252 1

d254 2
a255 1
 * Visitor that determines whether or not a shader uses ir_end_primitive.
d257 1
a257 1
class find_end_primitive_visitor : public ir_hierarchical_visitor {
d259 6
a264 2
   find_end_primitive_visitor()
      : found(false)
d269 63
a331 1
   virtual ir_visitor_status visit(ir_end_primitive *)
d333 1
a333 2
      found = true;
      return visit_stop;
d336 1
a336 1
   bool end_primitive_found()
d338 1
a338 1
      return found;
d342 5
a346 1
   bool found;
d440 2
a441 2
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d562 2
a563 2
    * GLSL ES 3.00 is similar to GLSL 1.40--failing to write to gl_Position is
    * not an error.
d569 8
a576 1
	 linker_error(prog, "vertex shader does not write to `gl_Position'\n");
d630 22
d653 29
a681 3
   find_end_primitive_visitor end_primitive;
   end_primitive.run(shader->ir);
   prog->Geom.UsesEndPrimitive = end_primitive.end_primitive_found();
d702 2
a703 2
      foreach_list(node, shader_list[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();
d972 1
a972 2
   foreach_list(node, sh->ir) {
      ir_instruction *const inst = (ir_instruction *) node;
d979 2
a980 1
	 sh->symbols->add_variable(var);
d1089 1
a1089 3
   foreach_list_safe(node, instructions) {
      ir_instruction *inst = (ir_instruction *) node;

d1126 2
a1127 2
static ir_function_signature *
get_main_function_signature(gl_shader *sh)
d1140 2
a1141 1
      ir_function_signature *sig = f->matching_signature(NULL, &void_parameters);
d1177 2
a1178 1
               resize_interface_members(var->type, var->max_ifc_array_access);
d1187 1
a1187 1
                                        var->max_ifc_array_access);
d1606 2
d1613 2
a1614 2
      foreach_list(node, shader_list[i]->ir) {
	 ir_function *const f = ((ir_instruction *) node)->as_function();
d1629 1
a1629 3
	    foreach_list(n, &f->signatures) {
	       ir_function_signature *sig = (ir_function_signature *) n;

d1656 1
a1656 1
      if (get_main_function_signature(shader_list[i]) != NULL) {
d1682 1
a1682 1
   /* The a pointer to the main function in the final linked shader (i.e., the
d1685 2
a1686 1
   ir_function_signature *const main_sig = get_main_function_signature(linked);
a1718 2
      memcpy(linking_shaders, shader_list, num_shaders * sizeof(gl_shader *));
      linking_shaders[num_shaders] = _mesa_glsl_get_builtin_function_shader();
d1720 5
a1724 1
      ok = link_function_calls(prog, linked, linking_shaders, num_shaders + 1);
d1726 6
a1731 1
      free(linking_shaders);
d1751 1
a1751 2
      foreach_list(n, linked->ir) {
         ir_instruction *ir = (ir_instruction *) n;
d1756 3
d1792 2
a1793 2
      foreach_list(node, prog->_LinkedShaders[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();
d1815 2
a1816 2
	    foreach_list(node2, prog->_LinkedShaders[j]->ir) {
	       ir_variable *other_var = ((ir_instruction *) node2)->as_variable();
d1836 4
a1839 3
	    if (var->num_state_slots > 0) {
	       var->num_state_slots = (size + 1)
		  * (var->num_state_slots / var->type->length);
d1885 1
a1885 1
 * Assign locations for either VS inputs for FS outputs
d1959 2
a1960 2
   foreach_list(node, sh->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d2178 2
a2179 2
   foreach_list(node, sh->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d2189 1
d2215 2
a2216 2
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d2347 2
a2348 2
            foreach_list(node, sh->ir) {
               ir_variable *var = ((ir_instruction *)node)->as_variable();
d2364 111
a2486 14
   ralloc_free(prog->InfoLog);
   prog->InfoLog = ralloc_strdup(NULL, "");

   ralloc_free(prog->UniformBlocks);
   prog->UniformBlocks = NULL;
   prog->NumUniformBlocks = 0;
   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
      ralloc_free(prog->UniformBlockStageIndex[i]);
      prog->UniformBlockStageIndex[i] = NULL;
   }

   ralloc_free(prog->AtomicBuffers);
   prog->AtomicBuffers = NULL;
   prog->NumAtomicBuffers = 0;
d2609 4
d2673 1
a2673 1
      if (ctx->ShaderCompilerOptions[i].LowerClipDistance) {
d2678 1
a2678 1
                                    &ctx->ShaderCompilerOptions[i],
d2681 2
d2685 3
d2749 15
d2851 1
a2851 1
   link_assign_uniform_locations(prog);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d76 1
d80 1
d83 4
d112 4
a115 4
      exec_list_iterator sig_iter = ir->callee->parameters.iterator();
      foreach_iter(exec_list_iterator, iter, *ir) {
	 ir_rvalue *param_rval = (ir_rvalue *)iter.get();
	 ir_variable *sig_param = (ir_variable *)sig_iter.get();
d117 2
a118 2
	 if (sig_param->mode == ir_var_function_out ||
	     sig_param->mode == ir_var_function_inout) {
a124 1
	 sig_iter.next();
d182 99
d300 1
a300 1
   ralloc_strcat(&prog->InfoLog, "error: ");
d368 1
a368 2
link_invalidate_variable_locations(gl_shader *sh, int input_base,
                                   int output_base)
d370 1
a370 1
   foreach_list(node, sh->ir) {
d376 8
a383 10
      int base;
      switch (var->mode) {
      case ir_var_shader_in:
         base = input_base;
         break;
      case ir_var_shader_out:
         base = output_base;
         break;
      default:
         continue;
d386 11
a396 1
      /* Only assign locations for generic attributes / varyings / etc.
d398 2
a399 6
      if ((var->location >= base) && !var->explicit_location)
         var->location = -1;

      if ((var->location == -1) && !var->explicit_location) {
         var->is_unmatched_generic_inout = 1;
         var->location_frac = 0;
d401 1
a401 1
         var->is_unmatched_generic_inout = 0;
d408 4
a411 1
 * Determine the number of attribute slots required for a particular type
d413 1
a413 3
 * This code is here because it implements the language rules of a specific
 * GLSL version.  Since it's a property of the language and not a property of
 * types in general, it doesn't really belong in glsl_type.
d415 4
a418 2
unsigned
count_attribute_slots(const glsl_type *t)
d420 1
a420 14
   /* From page 31 (page 37 of the PDF) of the GLSL 1.50 spec:
    *
    *     "A scalar input counts the same amount against this limit as a vec4,
    *     so applications may want to consider packing groups of four
    *     unrelated float inputs together into a vector to better utilize the
    *     capabilities of the underlying hardware. A matrix input will use up
    *     multiple locations.  The number of locations used will equal the
    *     number of columns in the matrix."
    *
    * The spec does not explicitly say how arrays are counted.  However, it
    * should be safe to assume the total number of slots consumed by an array
    * is the number of entries in the array multiplied by the number of slots
    * consumed by a single element of the array.
    */
d422 12
a433 2
   if (t->is_array())
      return t->array_size() * count_attribute_slots(t->element_type());
d435 16
a450 4
   if (t->is_matrix())
      return t->matrix_columns;

   return 1;
d462 1
a462 1
bool
d467 1
a467 1
      return true;
d500 1
a500 25
	 return false;
      }
   }

   prog->Vert.ClipDistanceArraySize = 0;

   if (!prog->IsES && prog->Version >= 130) {
      /* From section 7.1 (Vertex Shader Special Variables) of the
       * GLSL 1.30 spec:
       *
       *   "It is an error for a shader to statically write both
       *   gl_ClipVertex and gl_ClipDistance."
       *
       * This does not apply to GLSL ES shaders, since GLSL ES defines neither
       * gl_ClipVertex nor gl_ClipDistance.
       */
      find_assignment_visitor clip_vertex("gl_ClipVertex");
      find_assignment_visitor clip_distance("gl_ClipDistance");

      clip_vertex.run(shader->ir);
      clip_distance.run(shader->ir);
      if (clip_vertex.variable_found() && clip_distance.variable_found()) {
         linker_error(prog, "vertex shader writes to both `gl_ClipVertex' "
                      "and `gl_ClipDistance'\n");
         return false;
a501 5
      prog->Vert.UsesClipDistance = clip_distance.variable_found();
      ir_variable *clip_distance_var =
         shader->symbols->get_variable("gl_ClipDistance");
      if (clip_distance_var)
         prog->Vert.ClipDistanceArraySize = clip_distance_var->type->length;
d504 2
a505 1
   return true;
d514 1
a514 1
bool
d519 1
a519 1
      return true;
a529 1
      return false;
a530 2

   return true;
a532 1

d534 6
a539 1
 * Generate a string describing the mode of a variable
d541 3
a543 2
static const char *
mode_string(const ir_variable *var)
d545 12
a556 14
   switch (var->mode) {
   case ir_var_auto:
      return (var->read_only) ? "global constant" : "global variable";

   case ir_var_uniform:    return "uniform";
   case ir_var_shader_in:  return "shader input";
   case ir_var_shader_out: return "shader output";

   case ir_var_const_in:
   case ir_var_temporary:
   default:
      assert(!"Should not get here.");
      return "invalid variable";
   }
d563 1
a563 1
bool
d583 1
a583 1
	 if (uniforms_only && (var->mode != ir_var_uniform))
d589 1
a589 1
	 if (var->mode == ir_var_temporary)
d612 4
d622 1
a622 1
		  return false;
d626 3
a628 3
	    if (var->explicit_location) {
	       if (existing->explicit_location
		   && (var->location != existing->location)) {
d632 1
a632 1
		     return false;
d635 2
a636 2
	       existing->location = var->location;
	       existing->explicit_location = true;
d645 3
a647 3
            if (var->explicit_binding) {
               if (existing->explicit_binding &&
                   var->binding != existing->binding) {
d651 1
a651 1
                  return false;
d654 10
a663 2
               existing->binding = var->binding;
               existing->explicit_binding = true;
d678 1
a678 1
	       bool layout_declared = var->depth_layout != ir_depth_layout_none;
d680 1
a680 1
		  var->depth_layout != existing->depth_layout;
d689 1
a689 1
	       if (var->used && layout_differs) {
d720 1
a720 1
		     return false;
d741 2
a742 2
	    if (var->has_initializer) {
	       if (existing->has_initializer
d749 1
a749 1
		  return false;
d757 1
a757 1
	       existing->has_initializer = true;
d760 1
a760 1
	    if (existing->invariant != var->invariant) {
d764 1
a764 1
	       return false;
d766 1
a766 1
            if (existing->centroid != var->centroid) {
d770 7
a776 1
               return false;
a781 2

   return true;
d788 1
a788 1
bool
d791 2
a792 2
   return cross_validate_globals(prog, prog->_LinkedShaders,
				 MESA_SHADER_TYPES, true);
d803 1
a803 1
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d808 1
a808 1
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d897 1
a897 1
	 if (ir->var->mode == ir_var_temporary) {
d971 1
a971 1
      if ((var != NULL) && (var->mode != ir_var_temporary))
d977 1
a977 1
	     || ((var != NULL) && (var->mode == ir_var_temporary)));
d1017 1
a1017 1
      ir_function_signature *sig = f->matching_signature(&void_parameters);
d1034 13
d1049 34
a1082 6
      if (var->type->is_array() && (var->type->length == 0)) {
         const glsl_type *type =
            glsl_type::get_array_instance(var->type->fields.array,
                                          var->max_array_access + 1);
         assert(type != NULL);
         var->type = type;
d1086 109
d1198 251
d1466 2
a1467 1
   if (!cross_validate_globals(prog, shader_list, num_shaders, false))
d1472 3
a1474 2
   if (!validate_intrastage_interface_blocks((const gl_shader **)shader_list,
                                             num_shaders))
d1477 2
a1478 2
   /* Check that uniform blocks between shaders for a stage agree. */
   const int num_uniform_blocks =
a1480 2
   if (num_uniform_blocks < 0)
      return NULL;
d1502 2
a1503 3
	    foreach_iter (exec_list_iterator, iter, *f) {
	       ir_function_signature *sig =
		  (ir_function_signature *) iter.get();
d1505 1
a1505 1
	       if (!sig->is_defined || sig->is_builtin)
d1509 1
a1509 1
		  other->exact_matching_signature(& sig->parameters);
d1512 1
a1512 1
		   && !other_sig->is_builtin) {
d1539 1
a1539 1
		   _mesa_glsl_shader_target_name(shader_list[0]->Type));
d1551 4
d1577 8
a1584 5
   /* Resolve initializers for global variables in the linked shader.
    */
   unsigned num_linking_shaders = num_shaders;
   for (unsigned i = 0; i < num_shaders; i++)
      num_linking_shaders += shader_list[i]->num_builtins_to_link;
d1586 9
a1594 2
   gl_shader **linking_shaders =
      (gl_shader **) calloc(num_linking_shaders, sizeof(gl_shader *));
d1596 1
a1596 2
   memcpy(linking_shaders, shader_list,
	  sizeof(linking_shaders[0]) * num_shaders);
d1598 3
a1600 5
   unsigned idx = num_shaders;
   for (unsigned i = 0; i < num_shaders; i++) {
      memcpy(&linking_shaders[idx], shader_list[i]->builtins_to_link,
	     sizeof(linking_shaders[0]) * shader_list[i]->num_builtins_to_link);
      idx += shader_list[i]->num_builtins_to_link;
a1602 1
   assert(idx == num_linking_shaders);
d1604 1
a1604 2
   if (!link_function_calls(prog, linked, linking_shaders,
			    num_linking_shaders)) {
d1606 1
a1606 1
      linked = NULL;
a1608 2
   free(linking_shaders);

d1612 11
a1622 2
   if (linked)
      validate_ir_tree(linked->ir);
d1628 3
a1630 5
   if (linked != NULL) {
      array_sizing_visitor v;

      v.run(linked->ir);
   }
d1653 1
a1653 1
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d1660 1
a1660 3
	 if ((var == NULL) || (var->mode != ir_var_uniform &&
			       var->mode != ir_var_shader_in &&
			       var->mode != ir_var_shader_out) ||
d1667 4
d1672 1
a1672 1
	 if (var->is_in_uniform_block())
d1675 2
a1676 2
	 unsigned int size = var->max_array_access;
	 for (unsigned j = 0; j < MESA_SHADER_TYPES; j++) {
d1686 2
a1687 2
		   other_var->max_array_access > size) {
		  size = other_var->max_array_access;
d1826 1
a1826 1
      if ((var == NULL) || (var->mode != (unsigned) direction))
d1829 3
a1831 3
      if (var->explicit_location) {
	 if ((var->location >= (int)(max_index + generic_base))
	     || (var->location < 0)) {
d1834 3
a1836 2
			 (var->location < 0)
			 ? var->location : var->location - generic_base,
d1845 2
a1846 2
	    var->location = binding;
            var->is_unmatched_generic_inout = 0;
d1854 2
a1855 2
	    var->location = binding;
            var->is_unmatched_generic_inout = 0;
d1858 1
a1858 1
	       var->index = index;
d1868 3
a1870 3
      const unsigned slots = count_attribute_slots(var->type);
      if (var->location != -1) {
	 if (var->location >= generic_base && var->index < 1) {
d1879 4
a1882 2
	     * Previous versions of the spec contain similar language but omit
	     * the bit about attribute arrays.
d1884 1
a1884 1
	     * Page 61 of the OpenGL 4.0 spec also says:
d1897 40
a1936 5
	     * These two paragraphs are either somewhat contradictory, or I
	     * don't fully understand one or both of them.
	     */
	    /* FINISHME: The code as currently written does not support
	     * FINISHME: attribute location aliasing (see comment above).
d1938 1
d1942 1
a1942 1
	    const unsigned attr = var->location - generic_base;
d1944 13
d1962 13
a1974 7
	       const char *const string = (target_index == MESA_SHADER_VERTEX)
		  ? "vertex shader input" : "fragment shader output";
	       linker_error(prog,
			    "insufficient contiguous locations "
			    "available for %s `%s' %d %d %d", string,
			    var->name, used_locations, use_mask, attr);
	       return false;
d2027 2
a2028 2
      to_assign[i].var->location = generic_base + location;
      to_assign[i].var->is_unmatched_generic_inout = 0;
d2045 1
a2045 1
      if ((var == NULL) || (var->mode != int(mode)))
d2052 2
a2053 2
      if (var->is_unmatched_generic_inout) {
	 var->mode = ir_var_auto;
d2081 1
a2081 1
      if (var == NULL || var->mode != ir_var_shader_out) {
d2086 1
a2086 1
         switch (var->depth_layout) {
d2113 1
a2113 1
static bool
d2116 1
a2116 29
   static const char *const shader_names[MESA_SHADER_TYPES] = {
      "vertex", "geometry", "fragment"
   };

   const unsigned max_samplers[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxTextureImageUnits,
      ctx->Const.GeometryProgram.MaxTextureImageUnits,
      ctx->Const.FragmentProgram.MaxTextureImageUnits
   };

   const unsigned max_default_uniform_components[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxUniformComponents,
      ctx->Const.GeometryProgram.MaxUniformComponents,
      ctx->Const.FragmentProgram.MaxUniformComponents
   };

   const unsigned max_combined_uniform_components[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxCombinedUniformComponents,
      ctx->Const.GeometryProgram.MaxCombinedUniformComponents,
      ctx->Const.FragmentProgram.MaxCombinedUniformComponents
   };

   const unsigned max_uniform_blocks[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxUniformBlocks,
      ctx->Const.GeometryProgram.MaxUniformBlocks,
      ctx->Const.FragmentProgram.MaxUniformBlocks
   };

   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d2122 1
a2122 1
      if (sh->num_samplers > max_samplers[i]) {
d2124 1
a2124 1
		      shader_names[i]);
d2127 2
a2128 1
      if (sh->num_uniform_components > max_default_uniform_components[i]) {
d2134 1
a2134 1
                           shader_names[i]);
d2138 1
a2138 1
                         shader_names[i]);
d2143 1
a2143 1
	  max_combined_uniform_components[i]) {
d2148 1
a2148 1
                           shader_names[i]);
d2151 1
a2151 1
                         shader_names[i]);
d2156 1
a2156 1
   unsigned blocks[MESA_SHADER_TYPES] = {0};
d2160 1
a2160 1
      for (unsigned j = 0; j < MESA_SHADER_TYPES; j++) {
d2172 4
a2175 2
	 for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
	    if (blocks[i] > max_uniform_blocks[i]) {
d2177 1
a2177 1
			    shader_names[i],
d2179 1
a2179 1
			    max_uniform_blocks[i]);
d2185 36
d2222 3
a2224 1
   return prog->LinkStatus;
d2235 1
a2235 1
   prog->LinkStatus = false;
d2245 1
a2245 1
   for (int i = 0; i < MESA_SHADER_TYPES; i++) {
d2250 5
d2257 8
a2264 8
   struct gl_shader **vert_shader_list;
   unsigned num_vert_shaders = 0;
   struct gl_shader **frag_shader_list;
   unsigned num_frag_shaders = 0;

   vert_shader_list = (struct gl_shader **)
      calloc(2 * prog->NumShaders, sizeof(struct gl_shader *));
   frag_shader_list =  &vert_shader_list[prog->NumShaders];
d2280 6
a2285 14
      switch (prog->Shaders[i]->Type) {
      case GL_VERTEX_SHADER:
	 vert_shader_list[num_vert_shaders] = prog->Shaders[i];
	 num_vert_shaders++;
	 break;
      case GL_FRAGMENT_SHADER:
	 frag_shader_list[num_frag_shaders] = prog->Shaders[i];
	 num_frag_shaders++;
	 break;
      case GL_GEOMETRY_SHADER:
	 /* FINISHME: Support geometry shaders. */
	 assert(prog->Shaders[i]->Type != GL_GEOMETRY_SHADER);
	 break;
      }
d2288 2
a2289 5
   /* Previous to GLSL version 1.30, different compilation units could mix and
    * match shading language versions.  With GLSL 1.30 and later, the versions
    * of all shaders must match.
    *
    * GLSL ES has never allowed mixing of shading language versions.
d2291 1
a2291 2
   if ((is_es_prog || max_version >= 130)
       && min_version != max_version) {
d2300 18
a2317 1
   for (unsigned int i = 0; i < MESA_SHADER_TYPES; i++) {
d2326 5
a2330 4
   if (num_vert_shaders > 0) {
      gl_shader *const sh =
	 link_intrastage_shaders(mem_ctx, ctx, prog, vert_shader_list,
				 num_vert_shaders);
d2332 2
a2333 2
      if (sh == NULL)
	 goto done;
d2335 13
a2347 2
      if (!validate_vertex_shader_executable(prog, sh))
	 goto done;
d2349 2
a2350 2
      _mesa_reference_shader(ctx, &prog->_LinkedShaders[MESA_SHADER_VERTEX],
			     sh);
d2353 6
a2358 14
   if (num_frag_shaders > 0) {
      gl_shader *const sh =
	 link_intrastage_shaders(mem_ctx, ctx, prog, frag_shader_list,
				 num_frag_shaders);

      if (sh == NULL)
	 goto done;

      if (!validate_fragment_shader_executable(prog, sh))
	 goto done;

      _mesa_reference_shader(ctx, &prog->_LinkedShaders[MESA_SHADER_FRAGMENT],
			     sh);
   }
d2364 3
a2366 2
   if (cross_validate_uniforms(prog)) {
      unsigned prev;
d2368 1
a2368 4
      for (prev = 0; prev < MESA_SHADER_TYPES; prev++) {
	 if (prog->_LinkedShaders[prev] != NULL)
	    break;
      }
d2370 4
a2373 6
      /* Validate the inputs of each stage with the output of the preceding
       * stage.
       */
      for (unsigned i = prev + 1; i < MESA_SHADER_TYPES; i++) {
	 if (prog->_LinkedShaders[i] == NULL)
	    continue;
d2375 6
a2380 5
         if (!validate_interstage_interface_blocks(prog->_LinkedShaders[prev],
                                                   prog->_LinkedShaders[i])) {
            linker_error(prog, "interface block mismatch between shader stages\n");
            goto done;
         }
d2382 4
a2385 4
	 if (!cross_validate_outputs_to_inputs(prog,
					       prog->_LinkedShaders[prev],
					       prog->_LinkedShaders[i]))
	    goto done;
d2387 5
a2391 2
	 prev = i;
      }
d2393 1
a2393 1
      prog->LinkStatus = true;
d2396 5
d2402 1
a2402 1
   for (unsigned int i = 0; i < MESA_SHADER_TYPES; i++) {
d2427 1
a2427 1
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d2439 3
a2441 3
      unsigned max_unroll = ctx->ShaderCompilerOptions[i].MaxUnrollIterations;

      while (do_common_optimization(prog->_LinkedShaders[i]->ir, true, false, max_unroll, &ctx->ShaderCompilerOptions[i]))
d2446 4
a2449 10
   if (prog->_LinkedShaders[MESA_SHADER_VERTEX] != NULL) {
      link_invalidate_variable_locations(
            prog->_LinkedShaders[MESA_SHADER_VERTEX],
            VERT_ATTRIB_GENERIC0, VARYING_SLOT_VAR0);
   }
   /* FINISHME: Geometry shaders not implemented yet */
   if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] != NULL) {
      link_invalidate_variable_locations(
            prog->_LinkedShaders[MESA_SHADER_FRAGMENT],
            VARYING_SLOT_VAR0, FRAG_RESULT_DATA0);
d2466 1
a2466 1
   for (first = 0; first < MESA_SHADER_TYPES; first++) {
d2479 1
a2479 1
      if (first >= MESA_SHADER_FRAGMENT) {
d2498 1
a2498 1
   for (last = MESA_SHADER_TYPES-1; last >= 0; last--) {
d2506 1
a2506 1
      if (num_tfeedback_decls != 0) {
d2512 2
a2513 1
                                       num_tfeedback_decls, tfeedback_decls))
d2520 2
a2521 1
      demote_shader_inputs_and_outputs(sh, ir_var_shader_out);
d2536 10
a2545 1
      demote_shader_inputs_and_outputs(sh, ir_var_shader_in);
d2558 2
d2563 1
a2563 1
                tfeedback_decls))
d2581 3
a2583 1
      if (!check_against_varying_limit(ctx, prog, sh_next))
d2594 1
d2597 5
a2601 1
   if (!check_resources(ctx, prog))
d2605 4
a2608 2
    * present in a linked program.  By checking prog->IsES, we also
    * catch the GL_ARB_ES2_compatibility case.
d2610 1
a2610 2
   if (!prog->InternalSeparateShader &&
       (ctx->API == API_OPENGLES2 || prog->IsES)) {
d2621 2
a2622 3
   free(vert_shader_list);

   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d2625 5
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d69 1
d74 1
d106 1
a106 1
      exec_list_iterator sig_iter = ir->get_callee()->parameters.iterator();
d111 2
a112 2
	 if (sig_param->mode == ir_var_out ||
	     sig_param->mode == ir_var_inout) {
d122 9
d204 59
d264 2
a265 2
invalidate_variable_locations(gl_shader *sh, enum ir_variable_mode mode,
			      int generic_base)
d270 14
a283 2
      if ((var == NULL) || (var->mode != (unsigned) mode))
	 continue;
d287 9
a295 2
      if ((var->location >= generic_base) && !var->explicit_location)
	  var->location = -1;
d336 4
a339 1
 * Verify that a vertex shader executable meets all semantic requirements
d350 62
a411 5
   find_assignment_visitor find("gl_Position");
   find.run(shader->ir);
   if (!find.variable_found()) {
      linker_error(prog, "vertex shader does not write to `gl_Position'\n");
      return false;
d456 3
a458 4
   case ir_var_uniform: return "uniform";
   case ir_var_in:      return "shader input";
   case ir_var_out:     return "shader output";
   case ir_var_inout:   return "shader inout";
d544 51
a594 25
        /* Validate layout qualifiers for gl_FragDepth.
         *
         * From the AMD_conservative_depth spec:
         *    "If gl_FragDepth is redeclared in any fragment shader in
         *    a program, it must be redeclared in all fragment shaders in that
         *    program that have static assignments to gl_FragDepth. All
         *    redeclarations of gl_FragDepth in all fragment shaders in
         *    a single program must have the same set of qualifiers."
         */
        if (strcmp(var->name, "gl_FragDepth") == 0) {
           bool layout_declared = var->depth_layout != ir_depth_layout_none;
           bool layout_differs = var->depth_layout != existing->depth_layout;
           if (layout_declared && layout_differs) {
              linker_error(prog,
                 "All redeclarations of gl_FragDepth in all fragment shaders "
                 "in a single program must have the same set of qualifiers.");
           }
           if (var->used && layout_differs) {
              linker_error(prog,
                    "If gl_FragDepth is redeclared with a layout qualifier in"
                    "any fragment shader, it must be redeclared with the same"
                    "layout qualifier in all fragment shaders that have"
                    "assignments to gl_FragDepth");
           }
        }
d596 14
a609 1
	    /* FINISHME: Handle non-constant initializers.
d611 3
a613 3
	    if (var->constant_value != NULL) {
	       if (existing->constant_value != NULL) {
		  if (!var->constant_value->has_value(existing->constant_value)) {
d619 1
a619 1
	       } else
d632 23
a654 2
		  existing->constant_value =
		     var->constant_value->clone(ralloc_parent(existing), NULL);
a687 1

d689 2
a690 1
 * Validate that outputs from one stage match inputs of another
d692 2
a693 3
bool
cross_validate_outputs_to_inputs(struct gl_shader_program *prog,
				 gl_shader *producer, gl_shader *consumer)
d695 4
a698 17
   glsl_symbol_table parameters;
   /* FINISHME: Figure these out dynamically. */
   const char *const producer_stage = "vertex";
   const char *const consumer_stage = "fragment";

   /* Find all shader outputs in the "producer" stage.
    */
   foreach_list(node, producer->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();

      /* FINISHME: For geometry shaders, this should also look for inout
       * FINISHME: variables.
       */
      if ((var == NULL) || (var->mode != ir_var_out))
	 continue;

      parameters.add_variable(var);
d701 2
d704 4
a707 6
   /* Find all shader inputs in the "consumer" stage.  Any variables that have
    * matching outputs already in the symbol table must have the same type and
    * qualifiers.
    */
   foreach_list(node, consumer->ir) {
      ir_variable *const input = ((ir_instruction *) node)->as_variable();
d709 1
a709 4
      /* FINISHME: For geometry shaders, this should also look for inout
       * FINISHME: variables.
       */
      if ((input == NULL) || (input->mode != ir_var_in))
d712 9
a720 58
      ir_variable *const output = parameters.get_variable(input->name);
      if (output != NULL) {
	 /* Check that the types match between stages.
	  */
	 if (input->type != output->type) {
	    /* There is a bit of a special case for gl_TexCoord.  This
	     * built-in is unsized by default.  Applications that variable
	     * access it must redeclare it with a size.  There is some
	     * language in the GLSL spec that implies the fragment shader
	     * and vertex shader do not have to agree on this size.  Other
	     * driver behave this way, and one or two applications seem to
	     * rely on it.
	     *
	     * Neither declaration needs to be modified here because the array
	     * sizes are fixed later when update_array_sizes is called.
	     *
	     * From page 48 (page 54 of the PDF) of the GLSL 1.10 spec:
	     *
	     *     "Unlike user-defined varying variables, the built-in
	     *     varying variables don't have a strict one-to-one
	     *     correspondence between the vertex language and the
	     *     fragment language."
	     */
	    if (!output->type->is_array()
		|| (strncmp("gl_", output->name, 3) != 0)) {
	       linker_error(prog,
			    "%s shader output `%s' declared as type `%s', "
			    "but %s shader input declared as type `%s'\n",
			    producer_stage, output->name,
			    output->type->name,
			    consumer_stage, input->type->name);
	       return false;
	    }
	 }

	 /* Check that all of the qualifiers match between stages.
	  */
	 if (input->centroid != output->centroid) {
	    linker_error(prog,
			 "%s shader output `%s' %s centroid qualifier, "
			 "but %s shader input %s centroid qualifier\n",
			 producer_stage,
			 output->name,
			 (output->centroid) ? "has" : "lacks",
			 consumer_stage,
			 (input->centroid) ? "has" : "lacks");
	    return false;
	 }

	 if (input->invariant != output->invariant) {
	    linker_error(prog,
			 "%s shader output `%s' %s invariant qualifier, "
			 "but %s shader input %s invariant qualifier\n",
			 producer_stage,
			 output->name,
			 (output->invariant) ? "has" : "lacks",
			 consumer_stage,
			 (input->invariant) ? "has" : "lacks");
d724 1
a724 13
	 if (input->interpolation != output->interpolation) {
	    linker_error(prog,
			 "%s shader output `%s' specifies %s "
			 "interpolation qualifier, "
			 "but %s shader input specifies %s "
			 "interpolation qualifier\n",
			 producer_stage,
			 output->name,
			 output->interpolation_string(),
			 consumer_stage,
			 input->interpolation_string());
	    return false;
	 }
d868 2
d921 20
d954 2
d961 13
d1032 1
a1032 2
		   (shader_list[0]->Type == GL_VERTEX_SHADER)
		   ? "vertex" : "fragment");
d1040 4
d1095 6
d1106 1
a1106 16
      class array_sizing_visitor : public ir_hierarchical_visitor {
      public:
	 virtual ir_visitor_status visit(ir_variable *var)
	 {
	    if (var->type->is_array() && (var->type->length == 0)) {
	       const glsl_type *type =
		  glsl_type::get_array_instance(var->type->fields.array,
						var->max_array_access + 1);

	       assert(type != NULL);
	       var->type = type;
	    }

	    return visit_continue;
	 }
      } v;
a1113 7

struct uniform_node {
   exec_node link;
   struct gl_uniform *u;
   unsigned slots;
};

d1140 2
a1141 2
			       var->mode != ir_var_in &&
			       var->mode != ir_var_out) ||
d1145 7
d1169 1
a1169 1
	 if (size + 1 != var->type->fields.array->length) {
a1192 145
static void
add_uniform(void *mem_ctx, exec_list *uniforms, struct hash_table *ht,
	    const char *name, const glsl_type *type, GLenum shader_type,
	    unsigned *next_shader_pos, unsigned *total_uniforms)
{
   if (type->is_record()) {
      for (unsigned int i = 0; i < type->length; i++) {
	 const glsl_type *field_type = type->fields.structure[i].type;
	 char *field_name = ralloc_asprintf(mem_ctx, "%s.%s", name,
					    type->fields.structure[i].name);

	 add_uniform(mem_ctx, uniforms, ht, field_name, field_type,
		     shader_type, next_shader_pos, total_uniforms);
      }
   } else {
      uniform_node *n = (uniform_node *) hash_table_find(ht, name);
      unsigned int vec4_slots;
      const glsl_type *array_elem_type = NULL;

      if (type->is_array()) {
	 array_elem_type = type->fields.array;
	 /* Array of structures. */
	 if (array_elem_type->is_record()) {
	    for (unsigned int i = 0; i < type->length; i++) {
	       char *elem_name = ralloc_asprintf(mem_ctx, "%s[%d]", name, i);
	       add_uniform(mem_ctx, uniforms, ht, elem_name, array_elem_type,
			   shader_type, next_shader_pos, total_uniforms);
	    }
	    return;
	 }
      }

      /* Fix the storage size of samplers at 1 vec4 each. Be sure to pad out
       * vectors to vec4 slots.
       */
      if (type->is_array()) {
	 if (array_elem_type->is_sampler())
	    vec4_slots = type->length;
	 else
	    vec4_slots = type->length * array_elem_type->matrix_columns;
      } else if (type->is_sampler()) {
	 vec4_slots = 1;
      } else {
	 vec4_slots = type->matrix_columns;
      }

      if (n == NULL) {
	 n = (uniform_node *) calloc(1, sizeof(struct uniform_node));
	 n->u = (gl_uniform *) calloc(1, sizeof(struct gl_uniform));
	 n->slots = vec4_slots;

	 n->u->Name = strdup(name);
	 n->u->Type = type;
	 n->u->VertPos = -1;
	 n->u->FragPos = -1;
	 n->u->GeomPos = -1;
	 (*total_uniforms)++;

	 hash_table_insert(ht, n, name);
	 uniforms->push_tail(& n->link);
      }

      switch (shader_type) {
      case GL_VERTEX_SHADER:
	 n->u->VertPos = *next_shader_pos;
	 break;
      case GL_FRAGMENT_SHADER:
	 n->u->FragPos = *next_shader_pos;
	 break;
      case GL_GEOMETRY_SHADER:
	 n->u->GeomPos = *next_shader_pos;
	 break;
      }

      (*next_shader_pos) += vec4_slots;
   }
}

void
assign_uniform_locations(struct gl_shader_program *prog)
{
   /* */
   exec_list uniforms;
   unsigned total_uniforms = 0;
   hash_table *ht = hash_table_ctor(32, hash_table_string_hash,
				    hash_table_string_compare);
   void *mem_ctx = ralloc_context(NULL);

   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
      if (prog->_LinkedShaders[i] == NULL)
	 continue;

      unsigned next_position = 0;

      foreach_list(node, prog->_LinkedShaders[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();

	 if ((var == NULL) || (var->mode != ir_var_uniform))
	    continue;

	 if (strncmp(var->name, "gl_", 3) == 0) {
	    /* At the moment, we don't allocate uniform locations for
	     * builtin uniforms.  It's permitted by spec, and we'll
	     * likely switch to doing that at some point, but not yet.
	     */
	    continue;
	 }

	 var->location = next_position;
	 add_uniform(mem_ctx, &uniforms, ht, var->name, var->type,
		     prog->_LinkedShaders[i]->Type,
		     &next_position, &total_uniforms);
      }
   }

   ralloc_free(mem_ctx);

   gl_uniform_list *ul = (gl_uniform_list *)
      calloc(1, sizeof(gl_uniform_list));

   ul->Size = total_uniforms;
   ul->NumUniforms = total_uniforms;
   ul->Uniforms = (gl_uniform *) calloc(total_uniforms, sizeof(gl_uniform));

   unsigned idx = 0;
   uniform_node *next;
   for (uniform_node *node = (uniform_node *) uniforms.head
	   ; node->link.next != NULL
	   ; node = next) {
      next = (uniform_node *) node->link.next;

      node->link.remove();
      memcpy(&ul->Uniforms[idx], node->u, sizeof(gl_uniform));
      idx++;

      free(node->u);
      free(node);
   }

   hash_table_dtor(ht);

   prog->Uniforms = ul;
}


a1238 6
 *
 * \bug
 * Locations set via \c glBindFragDataLocation are not currently supported.
 * Only locations assigned automatically by the linker, explicitly set by a
 * layout qualifier, or explicitly set by a built-in variable (e.g., \c
 * gl_FragColor) are supported for fragment shaders.
d1262 2
a1263 1
    *    glBindVertexAttribLocation) locations.
d1277 2
a1278 48
      (target_index == MESA_SHADER_VERTEX) ? ir_var_in : ir_var_out;


   invalidate_variable_locations(sh, direction, generic_base);

   if ((target_index == MESA_SHADER_VERTEX) && (prog->Attributes != NULL)) {
      for (unsigned i = 0; i < prog->Attributes->NumParameters; i++) {
	 ir_variable *const var =
	    sh->symbols->get_variable(prog->Attributes->Parameters[i].Name);

	 /* Note: attributes that occupy multiple slots, such as arrays or
	  * matrices, may appear in the attrib array multiple times.
	  */
	 if ((var == NULL) || (var->location != -1))
	    continue;

	 /* From page 61 of the OpenGL 4.0 spec:
	  *
	  *     "LinkProgram will fail if the attribute bindings assigned by
	  *     BindAttribLocation do not leave not enough space to assign a
	  *     location for an active matrix attribute or an active attribute
	  *     array, both of which require multiple contiguous generic
	  *     attributes."
	  *
	  * Previous versions of the spec contain similar language but omit the
	  * bit about attribute arrays.
	  *
	  * Page 61 of the OpenGL 4.0 spec also says:
	  *
	  *     "It is possible for an application to bind more than one
	  *     attribute name to the same location. This is referred to as
	  *     aliasing. This will only work if only one of the aliased
	  *     attributes is active in the executable program, or if no path
	  *     through the shader consumes more than one attribute of a set
	  *     of attributes aliased to the same location. A link error can
	  *     occur if the linker determines that every path through the
	  *     shader consumes multiple aliased attributes, but
	  *     implementations are not required to generate an error in this
	  *     case."
	  *
	  * These two paragraphs are either somewhat contradictory, or I don't
	  * fully understand one or both of them.
	  */
	 /* FINISHME: The code as currently written does not support attribute
	  * FINISHME: location aliasing (see comment above).
	  */
	 const int attr = prog->Attributes->Parameters[i].StateIndexes[0];
	 const unsigned slots = count_attribute_slots(var->type);
a1279 20
	 /* Mask representing the contiguous slots that will be used by this
	  * attribute.
	  */
	 const unsigned use_mask = (1 << slots) - 1;

	 /* Generate a link error if the set of bits requested for this
	  * attribute overlaps any previously allocated bits.
	  */
	 if ((~(use_mask << attr) & used_locations) != used_locations) {
	    linker_error(prog,
			 "insufficient contiguous attribute locations "
			 "available for vertex shader input `%s'",
			 var->name);
	    return false;
	 }

	 var->location = VERT_ATTRIB_GENERIC0 + attr;
	 used_locations |= (use_mask << attr);
      }
   }
a1306 4
	 const unsigned slots = count_attribute_slots(var->type);
	 const unsigned use_mask = (1 << slots) - 1;
	 const int attr = var->location - generic_base;

d1311 2
a1312 1
			 (var->location < 0) ? var->location : attr,
d1315 21
a1335 2
	 } else if (var->location >= generic_base) {
	    used_locations |= (use_mask << attr);
d1339 4
a1342 1
      /* The location was explicitly assigned, nothing to do here.
d1344 55
a1398 1
      if (var->location != -1)
d1400 1
d1402 1
a1402 1
      to_assign[num_attr].slots = count_attribute_slots(var->type);
d1440 1
a1440 1
		      "insufficient contiguous attribute locations "
d1447 1
d1471 1
a1471 1
      if (var->location == -1) {
d1478 11
a1488 8
bool
assign_varying_locations(struct gl_context *ctx,
			 struct gl_shader_program *prog,
			 gl_shader *producer, gl_shader *consumer)
{
   /* FINISHME: Set dynamically when geometry shader support is added. */
   unsigned output_index = VERT_RESULT_VAR0;
   unsigned input_index = FRAG_ATTRIB_VAR0;
d1490 3
a1492 6
   /* Operate in a total of three passes.
    *
    * 1. Assign locations for any matching inputs and outputs.
    *
    * 2. Mark output variables in the producer that do not have locations as
    *    not being outputs.  This lets the optimizer eliminate them.
d1494 2
a1495 2
    * 3. Mark input variables in the consumer that do not have locations as
    *    not being inputs.  This lets the optimizer eliminate them.
d1497 2
d1500 3
a1502 2
   invalidate_variable_locations(producer, ir_var_out, VERT_RESULT_VAR0);
   invalidate_variable_locations(consumer, ir_var_in, FRAG_ATTRIB_VAR0);
d1504 24
a1527 2
   foreach_list(node, producer->ir) {
      ir_variable *const output_var = ((ir_instruction *) node)->as_variable();
d1529 9
a1537 3
      if ((output_var == NULL) || (output_var->mode != ir_var_out)
	  || (output_var->location != -1))
	 continue;
d1539 5
a1543 2
      ir_variable *const input_var =
	 consumer->symbols->get_variable(output_var->name);
d1545 5
a1549 2
      if ((input_var == NULL) || (input_var->mode != ir_var_in))
	 continue;
d1551 5
a1555 1
      assert(input_var->location == -1);
d1557 5
a1561 2
      output_var->location = output_index;
      input_var->location = input_index;
d1563 2
a1564 2
      /* FINISHME: Support for "varying" records in GLSL 1.50. */
      assert(!output_var->type->is_record());
d1566 2
a1567 3
      if (output_var->type->is_array()) {
	 const unsigned slots = output_var->type->length
	    * output_var->type->fields.array->matrix_columns;
d1569 30
a1598 7
	 output_index += slots;
	 input_index += slots;
      } else {
	 const unsigned slots = output_var->type->matrix_columns;

	 output_index += slots;
	 input_index += slots;
d1602 8
a1609 25
   unsigned varying_vectors = 0;

   foreach_list(node, consumer->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();

      if ((var == NULL) || (var->mode != ir_var_in))
	 continue;

      if (var->location == -1) {
	 if (prog->Version <= 120) {
	    /* On page 25 (page 31 of the PDF) of the GLSL 1.20 spec:
	     *
	     *     Only those varying variables used (i.e. read) in
	     *     the fragment shader executable must be written to
	     *     by the vertex shader executable; declaring
	     *     superfluous varying variables in a vertex shader is
	     *     permissible.
	     *
	     * We interpret this text as meaning that the VS must
	     * write the variable for the FS to read it.  See
	     * "glsl1-varying read but not written" in piglit.
	     */

	    linker_error(prog, "fragment shader varying %s not written "
			 "by vertex shader\n.", var->name);
d1611 1
d1613 4
a1616 4
	 /* An 'in' variable is only really a shader input if its
	  * value is written by the previous stage.
	  */
	 var->mode = ir_var_auto;
d1618 9
a1626 4
	 /* The packing rules are used for vertex shader inputs are also used
	  * for fragment shader inputs.
	  */
	 varying_vectors += count_attribute_slots(var->type);
d1630 1
a1630 18
   if (ctx->API == API_OPENGLES2 || prog->Version == 100) {
      if (varying_vectors > ctx->Const.MaxVarying) {
	 linker_error(prog, "shader uses too many varying vectors "
		      "(%u > %u)\n",
		      varying_vectors, ctx->Const.MaxVarying);
	 return false;
      }
   } else {
      const unsigned float_components = varying_vectors * 4;
      if (float_components > ctx->Const.MaxVarying * 4) {
	 linker_error(prog, "shader uses too many varying components "
		      "(%u > %u)\n",
		      float_components, ctx->Const.MaxVarying * 4);
	 return false;
      }
   }

   return true;
a1632 1

d1636 3
d1645 2
a1646 2
   if (prog->InfoLog != NULL)
      ralloc_free(prog->InfoLog);
d1648 7
a1654 1
   prog->InfoLog = ralloc_strdup(NULL, "");
d1669 2
d1675 6
d1700 2
d1703 1
a1703 3
   assert(min_version >= 100);
   assert(max_version <= 130);
   if ((max_version >= 130 || min_version == 100)
d1711 1
d1771 6
d1788 22
d1822 7
a1828 1
      while (do_common_optimization(prog->_LinkedShaders[i]->ir, true, 32))
d1832 12
a1843 3
   update_array_sizes(prog);

   assign_uniform_locations(prog);
d1854 1
a1854 1
   if (!assign_attribute_or_color_locations(prog, MESA_SHADER_FRAGMENT, ctx->Const.MaxDrawBuffers)) {
d1858 3
a1860 3
   unsigned prev;
   for (prev = 0; prev < MESA_SHADER_TYPES; prev++) {
      if (prog->_LinkedShaders[prev] != NULL)
d1864 34
a1897 3
   for (unsigned i = prev + 1; i < MESA_SHADER_TYPES; i++) {
      if (prog->_LinkedShaders[i] == NULL)
	 continue;
d1899 8
a1906 4
      if (!assign_varying_locations(ctx, prog,
				    prog->_LinkedShaders[prev],
				    prog->_LinkedShaders[i])) {
	 goto done;
d1909 9
a1917 1
      prev = i;
d1919 7
d1927 4
a1930 3
   if (prog->_LinkedShaders[MESA_SHADER_VERTEX] != NULL) {
      demote_shader_inputs_and_outputs(prog->_LinkedShaders[MESA_SHADER_VERTEX],
				       ir_var_out);
d1933 4
a1936 2
   if (prog->_LinkedShaders[MESA_SHADER_GEOMETRY] != NULL) {
      gl_shader *const sh = prog->_LinkedShaders[MESA_SHADER_GEOMETRY];
d1938 27
a1964 3
      demote_shader_inputs_and_outputs(sh, ir_var_in);
      demote_shader_inputs_and_outputs(sh, ir_var_inout);
      demote_shader_inputs_and_outputs(sh, ir_var_out);
d1967 6
a1972 2
   if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] != NULL) {
      gl_shader *const sh = prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
d1974 2
a1975 2
      demote_shader_inputs_and_outputs(sh, ir_var_in);
   }
d1978 2
a1979 2
    * present in a linked program.  By checking for use of shading language
    * version 1.00, we also catch the GL_ARB_ES2_compatibility case.
d1981 2
a1982 1
   if (ctx->API == API_OPENGLES2 || prog->Version == 100) {
d2001 8
@


1.1
log
@Initial revision
@
text
@a65 4
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
d167 1
a167 1
linker_error_printf(gl_shader_program *prog, const char *fmt, ...)
d175 15
d261 1
a261 2
      linker_error_printf(prog,
			  "vertex shader does not write to `gl_Position'\n");
d288 2
a289 2
      linker_error_printf(prog,  "fragment shader writes to both "
			  "`gl_FragColor' and `gl_FragData'\n");
d312 1
d374 5
a378 5
		  linker_error_printf(prog, "%s `%s' declared as type "
				      "`%s' and type `%s'\n",
				      mode_string(var),
				      var->name, var->type->name,
				      existing->type->name);
d386 3
a388 3
		     linker_error_printf(prog, "explicit locations for %s "
					 "`%s' have differing values\n",
					 mode_string(var), var->name);
d396 26
d427 3
a429 3
		     linker_error_printf(prog, "initializers for %s "
					 "`%s' have differing values\n",
					 mode_string(var), var->name);
d450 3
a452 3
	       linker_error_printf(prog, "declarations for %s `%s' have "
	                           "mismatching invariant qualifiers\n",
	                           mode_string(var), var->name);
d456 3
a458 3
               linker_error_printf(prog, "declarations for %s `%s' have "
                                   "mismatching centroid qualifiers\n",
                                   mode_string(var), var->name);
d527 1
a527 1
	     * built-in is unsized by default.  Appliations that variable
d546 6
a551 7
	       linker_error_printf(prog,
				   "%s shader output `%s' declared as "
				   "type `%s', but %s shader input declared "
				   "as type `%s'\n",
				   producer_stage, output->name,
				   output->type->name,
				   consumer_stage, input->type->name);
d559 8
a566 8
	    linker_error_printf(prog,
				"%s shader output `%s' %s centroid qualifier, "
				"but %s shader input %s centroid qualifier\n",
				producer_stage,
				output->name,
				(output->centroid) ? "has" : "lacks",
				consumer_stage,
				(input->centroid) ? "has" : "lacks");
d571 8
a578 8
	    linker_error_printf(prog,
				"%s shader output `%s' %s invariant qualifier, "
				"but %s shader input %s invariant qualifier\n",
				producer_stage,
				output->name,
				(output->invariant) ? "has" : "lacks",
				consumer_stage,
				(input->invariant) ? "has" : "lacks");
d583 10
a592 10
	    linker_error_printf(prog,
				"%s shader output `%s' specifies %s "
				"interpolation qualifier, "
				"but %s shader input specifies %s "
				"interpolation qualifier\n",
				producer_stage,
				output->name,
				output->interpolation_string(),
				consumer_stage,
				input->interpolation_string());
d839 2
a840 3
		  linker_error_printf(prog,
				      "function `%s' is multiply defined",
				      f->name);
d864 3
a866 3
      linker_error_printf(prog, "%s shader lacks `main'\n",
			  (shader_list[0]->Type == GL_VERTEX_SHADER)
			  ? "vertex" : "fragment");
d1009 13
d1178 1
a1178 1
 * Find a contiguous set of available bits in a bitmask
d1252 1
a1252 1
    *    glBindVertexAttribLocation) locatoins.
d1263 1
a1263 1
     ? VERT_ATTRIB_GENERIC0 : FRAG_RESULT_DATA0;
d1324 4
a1327 4
	    linker_error_printf(prog,
				"insufficient contiguous attribute locations "
				"available for vertex shader input `%s'",
				var->name);
d1358 1
a1358 1
      if ((var == NULL) || (var->mode != direction))
d1368 4
a1371 5
	    linker_error_printf(prog,
				"invalid explicit location %d specified for "
				"`%s'\n",
				(var->location < 0) ? var->location : attr,
				var->name);
d1420 4
a1423 4
	 linker_error_printf(prog,
			     "insufficient contiguous attribute locations "
			     "available for %s `%s'",
			     string, to_assign[i].var->name);
d1539 2
a1540 3
	    linker_error_printf(prog, "fragment shader varying %s not written "
				"by vertex shader\n.", var->name);
	    prog->LinkStatus = false;
d1557 3
a1559 3
	 linker_error_printf(prog, "shader uses too many varying vectors "
			     "(%u > %u)\n",
			     varying_vectors, ctx->Const.MaxVarying);
d1565 3
a1567 3
	 linker_error_printf(prog, "shader uses too many varying components "
			     "(%u > %u)\n",
			     float_components, ctx->Const.MaxVarying * 4);
d1631 2
a1632 2
      linker_error_printf(prog, "all shaders must use same shading "
			  "language version\n");
d1689 1
a1689 1
      /* Validate the inputs of each stage with the output of the preceeding
d1715 4
a1732 1
      prog->LinkStatus = false;
a1736 1
      prog->LinkStatus = false;
a1752 1
	 prog->LinkStatus = false;
d1784 1
a1784 2
	 linker_error_printf(prog, "program lacks a vertex shader\n");
	 prog->LinkStatus = false;
d1786 1
a1786 2
	 linker_error_printf(prog, "program lacks a fragment shader\n");
	 prog->LinkStatus = false;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d66 4
a72 1
#include "glsl_parser_extras.h"
a76 1
#include "link_varyings.h"
d108 1
a108 1
      exec_list_iterator sig_iter = ir->callee->parameters.iterator();
d113 2
a114 2
	 if (sig_param->mode == ir_var_function_out ||
	     sig_param->mode == ir_var_function_inout) {
a123 9
      if (ir->return_deref != NULL) {
	 ir_variable *const var = ir->return_deref->variable_referenced();

	 if (strcmp(name, var->name) == 0) {
	    found = true;
	    return visit_stop;
	 }
      }

d171 1
a171 1
linker_error(gl_shader_program *prog, const char *fmt, ...)
a178 74

   prog->LinkStatus = false;
}


void
linker_warning(gl_shader_program *prog, const char *fmt, ...)
{
   va_list ap;

   ralloc_strcat(&prog->InfoLog, "error: ");
   va_start(ap, fmt);
   ralloc_vasprintf_append(&prog->InfoLog, fmt, ap);
   va_end(ap);

}


/**
 * Given a string identifying a program resource, break it into a base name
 * and an optional array index in square brackets.
 *
 * If an array index is present, \c out_base_name_end is set to point to the
 * "[" that precedes the array index, and the array index itself is returned
 * as a long.
 *
 * If no array index is present (or if the array index is negative or
 * mal-formed), \c out_base_name_end, is set to point to the null terminator
 * at the end of the input string, and -1 is returned.
 *
 * Only the final array index is parsed; if the string contains other array
 * indices (or structure field accesses), they are left in the base name.
 *
 * No attempt is made to check that the base name is properly formed;
 * typically the caller will look up the base name in a hash table, so
 * ill-formed base names simply turn into hash table lookup failures.
 */
long
parse_program_resource_name(const GLchar *name,
                            const GLchar **out_base_name_end)
{
   /* Section 7.3.1 ("Program Interfaces") of the OpenGL 4.3 spec says:
    *
    *     "When an integer array element or block instance number is part of
    *     the name string, it will be specified in decimal form without a "+"
    *     or "-" sign or any extra leading zeroes. Additionally, the name
    *     string will not include white space anywhere in the string."
    */

   const size_t len = strlen(name);
   *out_base_name_end = name + len;

   if (len == 0 || name[len-1] != ']')
      return -1;

   /* Walk backwards over the string looking for a non-digit character.  This
    * had better be the opening bracket for an array index.
    *
    * Initially, i specifies the location of the ']'.  Since the string may
    * contain only the ']' charcater, walk backwards very carefully.
    */
   unsigned i;
   for (i = len - 1; (i > 0) && isdigit(name[i-1]); --i)
      /* empty */ ;

   if ((i == 0) || name[i-1] != '[')
      return -1;

   long array_index = strtol(&name[i], NULL, 10);
   if (array_index < 0)
      return -1;

   *out_base_name_end = name + (i - 1);
   return array_index;
d183 2
a184 2
link_invalidate_variable_locations(gl_shader *sh, int input_base,
                                   int output_base)
d189 2
a190 14
      if (var == NULL)
         continue;

      int base;
      switch (var->mode) {
      case ir_var_shader_in:
         base = input_base;
         break;
      case ir_var_shader_out:
         base = output_base;
         break;
      default:
         continue;
      }
d194 2
a195 9
      if ((var->location >= base) && !var->explicit_location)
         var->location = -1;

      if ((var->location == -1) && !var->explicit_location) {
         var->is_unmatched_generic_inout = 1;
         var->location_frac = 0;
      } else {
         var->is_unmatched_generic_inout = 0;
      }
d236 1
a236 4
 * Verify that a vertex shader executable meets all semantic requirements.
 *
 * Also sets prog->Vert.UsesClipDistance and prog->Vert.ClipDistanceArraySize
 * as a side effect.
d247 6
a252 62
   /* From the GLSL 1.10 spec, page 48:
    *
    *     "The variable gl_Position is available only in the vertex
    *      language and is intended for writing the homogeneous vertex
    *      position. All executions of a well-formed vertex shader
    *      executable must write a value into this variable. [...] The
    *      variable gl_Position is available only in the vertex
    *      language and is intended for writing the homogeneous vertex
    *      position. All executions of a well-formed vertex shader
    *      executable must write a value into this variable."
    *
    * while in GLSL 1.40 this text is changed to:
    *
    *     "The variable gl_Position is available only in the vertex
    *      language and is intended for writing the homogeneous vertex
    *      position. It can be written at any time during shader
    *      execution. It may also be read back by a vertex shader
    *      after being written. This value will be used by primitive
    *      assembly, clipping, culling, and other fixed functionality
    *      operations, if present, that operate on primitives after
    *      vertex processing has occurred. Its value is undefined if
    *      the vertex shader executable does not write gl_Position."
    *
    * GLSL ES 3.00 is similar to GLSL 1.40--failing to write to gl_Position is
    * not an error.
    */
   if (prog->Version < (prog->IsES ? 300 : 140)) {
      find_assignment_visitor find("gl_Position");
      find.run(shader->ir);
      if (!find.variable_found()) {
	 linker_error(prog, "vertex shader does not write to `gl_Position'\n");
	 return false;
      }
   }

   prog->Vert.ClipDistanceArraySize = 0;

   if (!prog->IsES && prog->Version >= 130) {
      /* From section 7.1 (Vertex Shader Special Variables) of the
       * GLSL 1.30 spec:
       *
       *   "It is an error for a shader to statically write both
       *   gl_ClipVertex and gl_ClipDistance."
       *
       * This does not apply to GLSL ES shaders, since GLSL ES defines neither
       * gl_ClipVertex nor gl_ClipDistance.
       */
      find_assignment_visitor clip_vertex("gl_ClipVertex");
      find_assignment_visitor clip_distance("gl_ClipDistance");

      clip_vertex.run(shader->ir);
      clip_distance.run(shader->ir);
      if (clip_vertex.variable_found() && clip_distance.variable_found()) {
         linker_error(prog, "vertex shader writes to both `gl_ClipVertex' "
                      "and `gl_ClipDistance'\n");
         return false;
      }
      prog->Vert.UsesClipDistance = clip_distance.variable_found();
      ir_variable *clip_distance_var =
         shader->symbols->get_variable("gl_ClipDistance");
      if (clip_distance_var)
         prog->Vert.ClipDistanceArraySize = clip_distance_var->type->length;
d278 2
a279 2
      linker_error(prog,  "fragment shader writes to both "
		   "`gl_FragColor' and `gl_FragData'\n");
d297 4
a300 3
   case ir_var_uniform:    return "uniform";
   case ir_var_shader_in:  return "shader input";
   case ir_var_shader_out: return "shader output";
a301 1
   case ir_var_const_in:
d363 5
a367 5
		  linker_error(prog, "%s `%s' declared as type "
			       "`%s' and type `%s'\n",
			       mode_string(var),
			       var->name, var->type->name,
			       existing->type->name);
d375 3
a377 3
		     linker_error(prog, "explicit locations for %s "
				  "`%s' have differing values\n",
				  mode_string(var), var->name);
d385 1
a385 29
            /* From the GLSL 4.20 specification:
             * "A link error will result if two compilation units in a program
             *  specify different integer-constant bindings for the same
             *  opaque-uniform name.  However, it is not an error to specify a
             *  binding on some but not all declarations for the same name"
             */
            if (var->explicit_binding) {
               if (existing->explicit_binding &&
                   var->binding != existing->binding) {
                  linker_error(prog, "explicit bindings for %s "
                               "`%s' have differing values\n",
                               mode_string(var), var->name);
                  return false;
               }

               existing->binding = var->binding;
               existing->explicit_binding = true;
            }

	    /* Validate layout qualifiers for gl_FragDepth.
	     *
	     * From the AMD/ARB_conservative_depth specs:
	     *
	     *    "If gl_FragDepth is redeclared in any fragment shader in a
	     *    program, it must be redeclared in all fragment shaders in
	     *    that program that have static assignments to
	     *    gl_FragDepth. All redeclarations of gl_FragDepth in all
	     *    fragment shaders in a single program must have the same set
	     *    of qualifiers."
d387 6
a392 43
	    if (strcmp(var->name, "gl_FragDepth") == 0) {
	       bool layout_declared = var->depth_layout != ir_depth_layout_none;
	       bool layout_differs =
		  var->depth_layout != existing->depth_layout;

	       if (layout_declared && layout_differs) {
		  linker_error(prog,
			       "All redeclarations of gl_FragDepth in all "
			       "fragment shaders in a single program must have "
			       "the same set of qualifiers.");
	       }

	       if (var->used && layout_differs) {
		  linker_error(prog,
			       "If gl_FragDepth is redeclared with a layout "
			       "qualifier in any fragment shader, it must be "
			       "redeclared with the same layout qualifier in "
			       "all fragment shaders that have assignments to "
			       "gl_FragDepth");
	       }
	    }

	    /* Page 35 (page 41 of the PDF) of the GLSL 4.20 spec says:
	     *
	     *     "If a shared global has multiple initializers, the
	     *     initializers must all be constant expressions, and they
	     *     must all have the same value. Otherwise, a link error will
	     *     result. (A shared global having only one initializer does
	     *     not require that initializer to be a constant expression.)"
	     *
	     * Previous to 4.20 the GLSL spec simply said that initializers
	     * must have the same value.  In this case of non-constant
	     * initializers, this was impossible to determine.  As a result,
	     * no vendor actually implemented that behavior.  The 4.20
	     * behavior matches the implemented behavior of at least one other
	     * vendor, so we'll implement that for all GLSL versions.
	     */
	    if (var->constant_initializer != NULL) {
	       if (existing->constant_initializer != NULL) {
		  if (!var->constant_initializer->has_value(existing->constant_initializer)) {
		     linker_error(prog, "initializers for %s "
				  "`%s' have differing values\n",
				  mode_string(var), var->name);
d395 1
a395 1
	       } else {
d408 2
a409 23
		  existing->constant_initializer =
		     var->constant_initializer->clone(ralloc_parent(existing),
						      NULL);
	       }
	    }

	    if (var->has_initializer) {
	       if (existing->has_initializer
		   && (var->constant_initializer == NULL
		       || existing->constant_initializer == NULL)) {
		  linker_error(prog,
			       "shared global variable `%s' has multiple "
			       "non-constant initializers.\n",
			       var->name);
		  return false;
	       }

	       /* Some instance had an initializer, so keep track of that.  In
		* this location, all sorts of initializers (constant or
		* otherwise) will propagate the existence to the variable
		* stored in the symbol table.
		*/
	       existing->has_initializer = true;
d413 3
a415 3
	       linker_error(prog, "declarations for %s `%s' have "
			    "mismatching invariant qualifiers\n",
			    mode_string(var), var->name);
d419 3
a421 3
               linker_error(prog, "declarations for %s `%s' have "
			    "mismatching centroid qualifiers\n",
			    mode_string(var), var->name);
d443 1
d445 1
a445 2
 * Accumulates the array of prog->UniformBlocks and checks that all
 * definitons of blocks agree on their contents.
d447 3
a449 2
static bool
interstage_cross_validate_uniform_blocks(struct gl_shader_program *prog)
d451 17
a467 4
   unsigned max_num_uniform_blocks = 0;
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
      if (prog->_LinkedShaders[i])
	 max_num_uniform_blocks += prog->_LinkedShaders[i]->NumUniformBlocks;
a469 2
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];
d471 6
a476 4
      prog->UniformBlockStageIndex[i] = ralloc_array(prog, int,
						     max_num_uniform_blocks);
      for (unsigned int j = 0; j < max_num_uniform_blocks; j++)
	 prog->UniformBlockStageIndex[i][j] = -1;
d478 4
a481 1
      if (sh == NULL)
d484 47
a530 9
      for (unsigned int j = 0; j < sh->NumUniformBlocks; j++) {
	 int index = link_cross_validate_uniform_block(prog,
						       &prog->UniformBlocks,
						       &prog->NumUniformBlocks,
						       &sh->UniformBlocks[j]);

	 if (index == -1) {
	    linker_error(prog, "uniform block `%s' has mismatching definitions",
			 sh->UniformBlocks[j].Name);
d534 25
a558 1
	 prog->UniformBlockStageIndex[i][index] = j;
a701 2
             || inst->as_call()
             || inst->as_if() /* for initializers with the ?: operator */
a752 20
 * This class is only used in link_intrastage_shaders() below but declaring
 * it inside that function leads to compiler warnings with some versions of
 * gcc.
 */
class array_sizing_visitor : public ir_hierarchical_visitor {
public:
   virtual ir_visitor_status visit(ir_variable *var)
   {
      if (var->type->is_array() && (var->type->length == 0)) {
         const glsl_type *type =
            glsl_type::get_array_instance(var->type->fields.array,
                                          var->max_array_access + 1);
         assert(type != NULL);
         var->type = type;
      }
      return visit_continue;
   }
};

/**
a765 2
   struct gl_uniform_block *uniform_blocks = NULL;

a770 13
   /* Check that interface blocks defined in multiple shaders are consistent.
    */
   if (!validate_intrastage_interface_blocks((const gl_shader **)shader_list,
                                             num_shaders))
      return NULL;

   /* Check that uniform blocks between shaders for a stage agree. */
   const int num_uniform_blocks =
      link_uniform_blocks(mem_ctx, prog, shader_list, num_shaders,
                          &uniform_blocks);
   if (num_uniform_blocks < 0)
      return NULL;

d803 3
a805 2
		  linker_error(prog, "function `%s' is multiply defined",
			       f->name);
d829 3
a831 2
      linker_error(prog, "%s shader lacks `main'\n",
		   _mesa_glsl_shader_target_name(shader_list[0]->Type));
a838 4
   linked->UniformBlocks = uniform_blocks;
   linked->NumUniformBlocks = num_uniform_blocks;
   ralloc_steal(linked, linked->UniformBlocks);

a889 6
   /* At this point linked should contain all of the linked IR, so
    * validate it to make sure nothing went wrong.
    */
   if (linked)
      validate_ir_tree(linked->ir);

d895 16
a910 1
      array_sizing_visitor v;
d918 7
d951 2
a952 2
			       var->mode != ir_var_shader_in &&
			       var->mode != ir_var_shader_out) ||
a955 7
	 /* GL_ARB_uniform_buffer_object says that std140 uniforms
	  * will not be eliminated.  Since we always do std140, just
	  * don't resize arrays in UBOs.
	  */
	 if (var->is_in_uniform_block())
	    continue;

d973 1
a973 14
	 if (size + 1 != var->type->length) {
	    /* If this is a built-in uniform (i.e., it's backed by some
	     * fixed-function state), adjust the number of state slots to
	     * match the new array size.  The number of slots per array entry
	     * is not known.  It seems safe to assume that the total number of
	     * slots is an integer multiple of the number of array elements.
	     * Determine the number of slots per array element by dividing by
	     * the old (total) size.
	     */
	    if (var->num_state_slots > 0) {
	       var->num_state_slots = (size + 1)
		  * (var->num_state_slots / var->type->length);
	    }

d984 145
d1130 1
a1130 1
 * Find a contiguous set of available bits in a bitmask.
d1175 6
d1204 1
a1204 2
    *    glBindVertexAttribLocation) locations and outputs that have
    *    user-defined locations (via glBindFragDataLocation).
d1215 1
a1215 1
      ? (int) VERT_ATTRIB_GENERIC0 : (int) FRAG_RESULT_DATA0;
d1218 4
a1221 2
      (target_index == MESA_SHADER_VERTEX)
      ? ir_var_shader_in : ir_var_shader_out;
d1223 64
d1310 1
a1310 1
      if ((var == NULL) || (var->mode != (unsigned) direction))
d1314 4
d1320 5
a1324 5
	    linker_error(prog,
			 "invalid explicit location %d specified for `%s'\n",
			 (var->location < 0)
			 ? var->location : var->location - generic_base,
			 var->name);
d1326 2
a1327 21
	 }
      } else if (target_index == MESA_SHADER_VERTEX) {
	 unsigned binding;

	 if (prog->AttributeBindings->get(binding, var->name)) {
	    assert(binding >= VERT_ATTRIB_GENERIC0);
	    var->location = binding;
            var->is_unmatched_generic_inout = 0;
	 }
      } else if (target_index == MESA_SHADER_FRAGMENT) {
	 unsigned binding;
	 unsigned index;

	 if (prog->FragDataBindings->get(binding, var->name)) {
	    assert(binding >= FRAG_RESULT_DATA0);
	    var->location = binding;
            var->is_unmatched_generic_inout = 0;

	    if (prog->FragDataIndexBindings->get(index, var->name)) {
	       var->index = index;
	    }
d1331 1
a1331 4
      /* If the variable is not a built-in and has a location statically
       * assigned in the shader (presumably via a layout qualifier), make sure
       * that it doesn't collide with other assigned locations.  Otherwise,
       * add it to the list of variables that need linker-assigned locations.
d1333 1
a1333 55
      const unsigned slots = count_attribute_slots(var->type);
      if (var->location != -1) {
	 if (var->location >= generic_base && var->index < 1) {
	    /* From page 61 of the OpenGL 4.0 spec:
	     *
	     *     "LinkProgram will fail if the attribute bindings assigned
	     *     by BindAttribLocation do not leave not enough space to
	     *     assign a location for an active matrix attribute or an
	     *     active attribute array, both of which require multiple
	     *     contiguous generic attributes."
	     *
	     * Previous versions of the spec contain similar language but omit
	     * the bit about attribute arrays.
	     *
	     * Page 61 of the OpenGL 4.0 spec also says:
	     *
	     *     "It is possible for an application to bind more than one
	     *     attribute name to the same location. This is referred to as
	     *     aliasing. This will only work if only one of the aliased
	     *     attributes is active in the executable program, or if no
	     *     path through the shader consumes more than one attribute of
	     *     a set of attributes aliased to the same location. A link
	     *     error can occur if the linker determines that every path
	     *     through the shader consumes multiple aliased attributes,
	     *     but implementations are not required to generate an error
	     *     in this case."
	     *
	     * These two paragraphs are either somewhat contradictory, or I
	     * don't fully understand one or both of them.
	     */
	    /* FINISHME: The code as currently written does not support
	     * FINISHME: attribute location aliasing (see comment above).
	     */
	    /* Mask representing the contiguous slots that will be used by
	     * this attribute.
	     */
	    const unsigned attr = var->location - generic_base;
	    const unsigned use_mask = (1 << slots) - 1;

	    /* Generate a link error if the set of bits requested for this
	     * attribute overlaps any previously allocated bits.
	     */
	    if ((~(use_mask << attr) & used_locations) != used_locations) {
	       const char *const string = (target_index == MESA_SHADER_VERTEX)
		  ? "vertex shader input" : "fragment shader output";
	       linker_error(prog,
			    "insufficient contiguous locations "
			    "available for %s `%s' %d %d %d", string,
			    var->name, used_locations, use_mask, attr);
	       return false;
	    }

	    used_locations |= (use_mask << attr);
	 }

a1334 1
      }
d1336 1
a1336 1
      to_assign[num_attr].slots = slots;
d1373 4
a1376 4
	 linker_error(prog,
		      "insufficient contiguous locations "
		      "available for %s `%s'",
		      string, to_assign[i].var->name);
a1380 1
      to_assign[i].var->is_unmatched_generic_inout = 0;
d1404 1
a1404 1
      if (var->is_unmatched_generic_inout) {
d1411 8
a1418 9
/**
 * Store the gl_FragDepth layout in the gl_shader_program struct.
 */
static void
store_fragdepth_layout(struct gl_shader_program *prog)
{
   if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] == NULL) {
      return;
   }
d1420 6
a1425 5
   struct exec_list *ir = prog->_LinkedShaders[MESA_SHADER_FRAGMENT]->ir;

   /* We don't look up the gl_FragDepth symbol directly because if
    * gl_FragDepth is not used in the shader, it's removed from the IR.
    * However, the symbol won't be removed from the symbol table.
d1427 2
a1428 2
    * We're only interested in the cases where the variable is NOT removed
    * from the IR.
a1429 2
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d1431 5
a1435 3
      if (var == NULL || var->mode != ir_var_shader_out) {
         continue;
      }
d1437 3
a1439 24
      if (strcmp(var->name, "gl_FragDepth") == 0) {
         switch (var->depth_layout) {
         case ir_depth_layout_none:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_NONE;
            return;
         case ir_depth_layout_any:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_ANY;
            return;
         case ir_depth_layout_greater:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_GREATER;
            return;
         case ir_depth_layout_less:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_LESS;
            return;
         case ir_depth_layout_unchanged:
            prog->FragDepthLayout = FRAG_DEPTH_LAYOUT_UNCHANGED;
            return;
         default:
            assert(0);
            return;
         }
      }
   }
}
d1441 2
a1442 9
/**
 * Validate the resources used by a program versus the implementation limits
 */
static bool
check_resources(struct gl_context *ctx, struct gl_shader_program *prog)
{
   static const char *const shader_names[MESA_SHADER_TYPES] = {
      "vertex", "geometry", "fragment"
   };
d1444 2
a1445 5
   const unsigned max_samplers[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxTextureImageUnits,
      ctx->Const.GeometryProgram.MaxTextureImageUnits,
      ctx->Const.FragmentProgram.MaxTextureImageUnits
   };
d1447 1
a1447 5
   const unsigned max_default_uniform_components[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxUniformComponents,
      ctx->Const.GeometryProgram.MaxUniformComponents,
      ctx->Const.FragmentProgram.MaxUniformComponents
   };
d1449 2
a1450 5
   const unsigned max_combined_uniform_components[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxCombinedUniformComponents,
      ctx->Const.GeometryProgram.MaxCombinedUniformComponents,
      ctx->Const.FragmentProgram.MaxCombinedUniformComponents
   };
d1452 2
a1453 5
   const unsigned max_uniform_blocks[MESA_SHADER_TYPES] = {
      ctx->Const.VertexProgram.MaxUniformBlocks,
      ctx->Const.GeometryProgram.MaxUniformBlocks,
      ctx->Const.FragmentProgram.MaxUniformBlocks
   };
d1455 3
a1457 2
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];
d1459 4
a1462 2
      if (sh == NULL)
	 continue;
d1464 2
a1465 30
      if (sh->num_samplers > max_samplers[i]) {
	 linker_error(prog, "Too many %s shader texture samplers",
		      shader_names[i]);
      }

      if (sh->num_uniform_components > max_default_uniform_components[i]) {
         if (ctx->Const.GLSLSkipStrictMaxUniformLimitCheck) {
            linker_warning(prog, "Too many %s shader default uniform block "
                           "components, but the driver will try to optimize "
                           "them out; this is non-portable out-of-spec "
			   "behavior\n",
                           shader_names[i]);
         } else {
            linker_error(prog, "Too many %s shader default uniform block "
			 "components",
                         shader_names[i]);
         }
      }

      if (sh->num_combined_uniform_components >
	  max_combined_uniform_components[i]) {
         if (ctx->Const.GLSLSkipStrictMaxUniformLimitCheck) {
            linker_warning(prog, "Too many %s shader uniform components, "
                           "but the driver will try to optimize them out; "
                           "this is non-portable out-of-spec behavior\n",
                           shader_names[i]);
         } else {
            linker_error(prog, "Too many %s shader uniform components",
                         shader_names[i]);
         }
d1469 26
a1494 8
   unsigned blocks[MESA_SHADER_TYPES] = {0};
   unsigned total_uniform_blocks = 0;

   for (unsigned i = 0; i < prog->NumUniformBlocks; i++) {
      for (unsigned j = 0; j < MESA_SHADER_TYPES; j++) {
	 if (prog->UniformBlockStageIndex[j][i] != -1) {
	    blocks[j]++;
	    total_uniform_blocks++;
d1496 10
d1507 1
d1509 14
a1522 14
      if (total_uniform_blocks > ctx->Const.MaxCombinedUniformBlocks) {
	 linker_error(prog, "Too many combined uniform blocks (%d/%d)",
		      prog->NumUniformBlocks,
		      ctx->Const.MaxCombinedUniformBlocks);
      } else {
	 for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
	    if (blocks[i] > max_uniform_blocks[i]) {
	       linker_error(prog, "Too many %s uniform blocks (%d/%d)",
			    shader_names[i],
			    blocks[i],
			    max_uniform_blocks[i]);
	       break;
	    }
	 }
d1526 1
a1526 1
   return prog->LinkStatus;
d1529 1
a1532 3
   tfeedback_decl *tfeedback_decls = NULL;
   unsigned num_tfeedback_decls = prog->TransformFeedback.NumVarying;

d1539 3
a1541 1
   ralloc_free(prog->InfoLog);
a1543 8
   ralloc_free(prog->UniformBlocks);
   prog->UniformBlocks = NULL;
   prog->NumUniformBlocks = 0;
   for (int i = 0; i < MESA_SHADER_TYPES; i++) {
      ralloc_free(prog->UniformBlockStageIndex[i]);
      prog->UniformBlockStageIndex[i] = NULL;
   }

a1556 2
   const bool is_es_prog =
      (prog->NumShaders > 0 && prog->Shaders[0]->IsES) ? true : false;
a1560 6
      if (prog->Shaders[i]->IsES != is_es_prog) {
	 linker_error(prog, "all shaders must use same shading "
		      "language version\n");
	 goto done;
      }

a1579 2
    *
    * GLSL ES has never allowed mixing of shading language versions.
d1581 3
a1583 1
   if ((is_es_prog || max_version >= 130)
d1585 2
a1586 2
      linker_error(prog, "all shaders must use same shading "
		   "language version\n");
a1590 1
   prog->IsES = is_es_prog;
d1643 1
a1643 1
      /* Validate the inputs of each stage with the output of the preceding
a1649 6
         if (!validate_interstage_interface_blocks(prog->_LinkedShaders[prev],
                                                   prog->_LinkedShaders[i])) {
            linker_error(prog, "interface block mismatch between shader stages\n");
            goto done;
         }

a1660 22

   for (unsigned int i = 0; i < MESA_SHADER_TYPES; i++) {
      if (prog->_LinkedShaders[i] != NULL)
         lower_named_interface_blocks(mem_ctx, prog->_LinkedShaders[i]);
   }

   /* Implement the GLSL 1.30+ rule for discard vs infinite loops Do
    * it before optimization because we want most of the checks to get
    * dropped thanks to constant propagation.
    *
    * This rule also applies to GLSL ES 3.00.
    */
   if (max_version >= (is_es_prog ? 300 : 130)) {
      struct gl_shader *sh = prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
      if (sh) {
	 lower_discard_flow(sh->ir);
      }
   }

   if (!interstage_cross_validate_uniform_blocks(prog))
      goto done;

d1669 1
a1669 11
      detect_recursion_linked(prog, prog->_LinkedShaders[i]->ir);
      if (!prog->LinkStatus)
	 goto done;

      if (ctx->ShaderCompilerOptions[i].LowerClipDistance) {
         lower_clip_distance(prog->_LinkedShaders[i]);
      }

      unsigned max_unroll = ctx->ShaderCompilerOptions[i].MaxUnrollIterations;

      while (do_common_optimization(prog->_LinkedShaders[i]->ir, true, false, max_unroll, &ctx->ShaderCompilerOptions[i]))
d1673 3
a1675 12
   /* Mark all generic shader inputs and outputs as unpaired. */
   if (prog->_LinkedShaders[MESA_SHADER_VERTEX] != NULL) {
      link_invalidate_variable_locations(
            prog->_LinkedShaders[MESA_SHADER_VERTEX],
            VERT_ATTRIB_GENERIC0, VARYING_SLOT_VAR0);
   }
   /* FINISHME: Geometry shaders not implemented yet */
   if (prog->_LinkedShaders[MESA_SHADER_FRAGMENT] != NULL) {
      link_invalidate_variable_locations(
            prog->_LinkedShaders[MESA_SHADER_FRAGMENT],
            VARYING_SLOT_VAR0, FRAG_RESULT_DATA0);
   }
d1683 1
d1687 2
a1688 1
   if (!assign_attribute_or_color_locations(prog, MESA_SHADER_FRAGMENT, MAX2(ctx->Const.MaxDrawBuffers, ctx->Const.MaxDualSourceDrawBuffers))) {
d1692 3
a1694 3
   unsigned first;
   for (first = 0; first < MESA_SHADER_TYPES; first++) {
      if (prog->_LinkedShaders[first] != NULL)
d1698 9
a1706 12
   if (num_tfeedback_decls != 0) {
      /* From GL_EXT_transform_feedback:
       *   A program will fail to link if:
       *
       *   * the <count> specified by TransformFeedbackVaryingsEXT is
       *     non-zero, but the program object has no vertex or geometry
       *     shader;
       */
      if (first >= MESA_SHADER_FRAGMENT) {
         linker_error(prog, "Transform feedback varyings specified, but "
                      "no vertex or geometry shader is present.");
         goto done;
d1709 1
a1709 6
      tfeedback_decls = ralloc_array(mem_ctx, tfeedback_decl,
                                     prog->TransformFeedback.NumVarying);
      if (!parse_tfeedback_decls(ctx, prog, mem_ctx, num_tfeedback_decls,
                                 prog->TransformFeedback.VaryingNames,
                                 tfeedback_decls))
         goto done;
d1712 3
a1714 8
   /* Linking the stages in the opposite order (from fragment to vertex)
    * ensures that inter-shader outputs written to in an earlier stage are
    * eliminated if they are (transitively) not used in a later stage.
    */
   int last, next;
   for (last = MESA_SHADER_TYPES-1; last >= 0; last--) {
      if (prog->_LinkedShaders[last] != NULL)
         break;
d1717 2
a1718 2
   if (last >= 0 && last < MESA_SHADER_FRAGMENT) {
      gl_shader *const sh = prog->_LinkedShaders[last];
d1720 3
a1722 19
      if (num_tfeedback_decls != 0) {
         /* There was no fragment shader, but we still have to assign varying
          * locations for use by transform feedback.
          */
         if (!assign_varying_locations(ctx, mem_ctx, prog,
                                       sh, NULL,
                                       num_tfeedback_decls, tfeedback_decls))
            goto done;
      }

      do_dead_builtin_varyings(ctx, sh, NULL,
                               num_tfeedback_decls, tfeedback_decls);

      demote_shader_inputs_and_outputs(sh, ir_var_shader_out);

      /* Eliminate code that is now dead due to unused outputs being demoted.
       */
      while (do_dead_code(sh->ir, false))
         ;
a1723 4
   else if (first == MESA_SHADER_FRAGMENT) {
      /* If the program only contains a fragment shader...
       */
      gl_shader *const sh = prog->_LinkedShaders[first];
d1725 2
a1726 28
      do_dead_builtin_varyings(ctx, NULL, sh,
                               num_tfeedback_decls, tfeedback_decls);

      demote_shader_inputs_and_outputs(sh, ir_var_shader_in);

      while (do_dead_code(sh->ir, false))
         ;
   }

   next = last;
   for (int i = next - 1; i >= 0; i--) {
      if (prog->_LinkedShaders[i] == NULL)
         continue;

      gl_shader *const sh_i = prog->_LinkedShaders[i];
      gl_shader *const sh_next = prog->_LinkedShaders[next];

      if (!assign_varying_locations(ctx, mem_ctx, prog, sh_i, sh_next,
                next == MESA_SHADER_FRAGMENT ? num_tfeedback_decls : 0,
                tfeedback_decls))
         goto done;

      do_dead_builtin_varyings(ctx, sh_i, sh_next,
                next == MESA_SHADER_FRAGMENT ? num_tfeedback_decls : 0,
                tfeedback_decls);

      demote_shader_inputs_and_outputs(sh_i, ir_var_shader_out);
      demote_shader_inputs_and_outputs(sh_next, ir_var_shader_in);
d1728 1
a1728 12
      /* Eliminate code that is now dead due to unused outputs being demoted.
       */
      while (do_dead_code(sh_i->ir, false))
         ;
      while (do_dead_code(sh_next->ir, false))
         ;

      /* This must be done after all dead varyings are eliminated. */
      if (!check_against_varying_limit(ctx, prog, sh_next))
         goto done;

      next = i;
a1730 10
   if (!store_tfeedback_info(ctx, prog, num_tfeedback_decls, tfeedback_decls))
      goto done;

   update_array_sizes(prog);
   link_assign_uniform_locations(prog);
   store_fragdepth_layout(prog);

   if (!check_resources(ctx, prog))
      goto done;

d1732 2
a1733 2
    * present in a linked program.  By checking prog->IsES, we also
    * catch the GL_ARB_ES2_compatibility case.
d1735 1
a1735 2
   if (!prog->InternalSeparateShader &&
       (ctx->API == API_OPENGLES2 || prog->IsES)) {
d1737 2
a1738 1
	 linker_error(prog, "program lacks a vertex shader\n");
d1740 2
a1741 1
	 linker_error(prog, "program lacks a fragment shader\n");
a1755 8

      /* The symbol table in the linked shaders may contain references to
       * variables that were removed (e.g., unused uniforms).  Since it may
       * contain junk, there is no possible valid use.  Delete it and set the
       * pointer to NULL.
       */
      delete prog->_LinkedShaders[i]->symbols;
      prog->_LinkedShaders[i]->symbols = NULL;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a75 1
#include "ir_rvalue_visitor.h"
a78 1
#include "main/enums.h"
a80 4
void linker_error(gl_shader_program *, const char *, ...);

namespace {

d106 4
a109 4
      foreach_two_lists(formal_node, &ir->callee->parameters,
                        actual_node, &ir->actual_parameters) {
	 ir_rvalue *param_rval = (ir_rvalue *) actual_node;
	 ir_variable *sig_param = (ir_variable *) formal_node;
d111 2
a112 2
	 if (sig_param->data.mode == ir_var_function_out ||
	     sig_param->data.mode == ir_var_function_inout) {
d119 1
a176 99
class geom_array_resize_visitor : public ir_hierarchical_visitor {
public:
   unsigned num_vertices;
   gl_shader_program *prog;

   geom_array_resize_visitor(unsigned num_vertices, gl_shader_program *prog)
   {
      this->num_vertices = num_vertices;
      this->prog = prog;
   }

   virtual ~geom_array_resize_visitor()
   {
      /* empty */
   }

   virtual ir_visitor_status visit(ir_variable *var)
   {
      if (!var->type->is_array() || var->data.mode != ir_var_shader_in)
         return visit_continue;

      unsigned size = var->type->length;

      /* Generate a link error if the shader has declared this array with an
       * incorrect size.
       */
      if (size && size != this->num_vertices) {
         linker_error(this->prog, "size of array %s declared as %u, "
                      "but number of input vertices is %u\n",
                      var->name, size, this->num_vertices);
         return visit_continue;
      }

      /* Generate a link error if the shader attempts to access an input
       * array using an index too large for its actual size assigned at link
       * time.
       */
      if (var->data.max_array_access >= this->num_vertices) {
         linker_error(this->prog, "geometry shader accesses element %i of "
                      "%s, but only %i input vertices\n",
                      var->data.max_array_access, var->name, this->num_vertices);
         return visit_continue;
      }

      var->type = glsl_type::get_array_instance(var->type->element_type(),
                                                this->num_vertices);
      var->data.max_array_access = this->num_vertices - 1;

      return visit_continue;
   }

   /* Dereferences of input variables need to be updated so that their type
    * matches the newly assigned type of the variable they are accessing. */
   virtual ir_visitor_status visit(ir_dereference_variable *ir)
   {
      ir->type = ir->var->type;
      return visit_continue;
   }

   /* Dereferences of 2D input arrays need to be updated so that their type
    * matches the newly assigned type of the array they are accessing. */
   virtual ir_visitor_status visit_leave(ir_dereference_array *ir)
   {
      const glsl_type *const vt = ir->array->type;
      if (vt->is_array())
         ir->type = vt->element_type();
      return visit_continue;
   }
};


/**
 * Visitor that determines whether or not a shader uses ir_end_primitive.
 */
class find_end_primitive_visitor : public ir_hierarchical_visitor {
public:
   find_end_primitive_visitor()
      : found(false)
   {
      /* empty */
   }

   virtual ir_visitor_status visit(ir_end_primitive *)
   {
      found = true;
      return visit_stop;
   }

   bool end_primitive_found()
   {
      return found;
   }

private:
   bool found;
};

} /* anonymous namespace */

d196 1
a196 1
   ralloc_strcat(&prog->InfoLog, "warning: ");
d264 2
a265 1
link_invalidate_variable_locations(exec_list *ir)
d267 1
a267 1
   foreach_list(node, ir) {
d273 10
a282 8
      /* Only assign locations for variables that lack an explicit location.
       * Explicit locations are set for all built-in variables, generic vertex
       * shader inputs (via layout(location=...)), and generic fragment shader
       * outputs (also via layout(location=...)).
       */
      if (!var->data.explicit_location) {
         var->data.location = -1;
         var->data.location_frac = 0;
d285 1
a285 11
      /* ir_variable::is_unmatched_generic_inout is used by the linker while
       * connecting outputs from one stage to inputs of the next stage.
       *
       * There are two implicit assumptions here.  First, we assume that any
       * built-in variable (i.e., non-generic in or out) will have
       * explicit_location set.  Second, we assume that any generic in or out
       * will not have explicit_location set.
       *
       * This second assumption will only be valid until
       * GL_ARB_separate_shader_objects is supported.  When that extension is
       * implemented, this function will need some modifications.
d287 6
a292 2
      if (!var->data.explicit_location) {
         var->data.is_unmatched_generic_inout = 1;
d294 1
a294 1
         var->data.is_unmatched_generic_inout = 0;
d301 1
a301 4
 * Set UsesClipDistance and ClipDistanceArraySize based on the given shader.
 *
 * Also check for errors based on incorrect usage of gl_ClipVertex and
 * gl_ClipDistance.
d303 3
a305 1
 * Return false if an error was reported.
d307 2
a308 4
static void
analyze_clip_usage(struct gl_shader_program *prog,
                   struct gl_shader *shader, GLboolean *UsesClipDistance,
                   GLuint *ClipDistanceArraySize)
d310 14
a323 1
   *ClipDistanceArraySize = 0;
d325 5
a329 12
   if (!prog->IsES && prog->Version >= 130) {
      /* From section 7.1 (Vertex Shader Special Variables) of the
       * GLSL 1.30 spec:
       *
       *   "It is an error for a shader to statically write both
       *   gl_ClipVertex and gl_ClipDistance."
       *
       * This does not apply to GLSL ES shaders, since GLSL ES defines neither
       * gl_ClipVertex nor gl_ClipDistance.
       */
      find_assignment_visitor clip_vertex("gl_ClipVertex");
      find_assignment_visitor clip_distance("gl_ClipDistance");
d331 1
a331 16
      clip_vertex.run(shader->ir);
      clip_distance.run(shader->ir);
      if (clip_vertex.variable_found() && clip_distance.variable_found()) {
         linker_error(prog, "%s shader writes to both `gl_ClipVertex' "
                      "and `gl_ClipDistance'\n",
                      _mesa_shader_stage_to_string(shader->Stage));
         return;
      }
      *UsesClipDistance = clip_distance.variable_found();
      ir_variable *clip_distance_var =
         shader->symbols->get_variable("gl_ClipDistance");
      if (clip_distance_var)
         *ClipDistanceArraySize = clip_distance_var->type->length;
   } else {
      *UsesClipDistance = false;
   }
d343 1
a343 1
void
d348 1
a348 1
      return;
d381 25
a405 1
	 return;
d407 5
d414 1
a414 2
   analyze_clip_usage(prog, shader, &prog->Vert.UsesClipDistance,
                      &prog->Vert.ClipDistanceArraySize);
d423 1
a423 1
void
d428 1
a428 1
      return;
d439 1
d441 2
d445 1
d447 1
a447 6
 * Verify that a geometry shader executable meets all semantic requirements
 *
 * Also sets prog->Geom.VerticesIn, prog->Geom.UsesClipDistance, and
 * prog->Geom.ClipDistanceArraySize as a side effect.
 *
 * \param shader Geometry shader executable to be verified
d449 2
a450 3
void
validate_geometry_shader_executable(struct gl_shader_program *prog,
				    struct gl_shader *shader)
d452 14
a465 12
   if (shader == NULL)
      return;

   unsigned num_vertices = vertices_per_prim(prog->Geom.InputType);
   prog->Geom.VerticesIn = num_vertices;

   analyze_clip_usage(prog, shader, &prog->Geom.UsesClipDistance,
                      &prog->Geom.ClipDistanceArraySize);

   find_end_primitive_visitor end_primitive;
   end_primitive.run(shader->ir);
   prog->Geom.UsesEndPrimitive = end_primitive.end_primitive_found();
d472 1
a472 1
void
d492 1
a492 1
	 if (uniforms_only && (var->data.mode != ir_var_uniform))
d498 1
a498 1
	 if (var->data.mode == ir_var_temporary)
a520 4
               } else if (var->type->is_record()
		   && existing->type->is_record()
		   && existing->type->record_compare(var->type)) {
		  existing->type = var->type;
d527 1
a527 1
		  return;
d531 3
a533 3
	    if (var->data.explicit_location) {
	       if (existing->data.explicit_location
		   && (var->data.location != existing->data.location)) {
d537 1
a537 1
		     return;
d540 2
a541 2
	       existing->data.location = var->data.location;
	       existing->data.explicit_location = true;
d550 3
a552 3
            if (var->data.explicit_binding) {
               if (existing->data.explicit_binding &&
                   var->data.binding != existing->data.binding) {
d556 1
a556 1
                  return;
d559 2
a560 10
               existing->data.binding = var->data.binding;
               existing->data.explicit_binding = true;
            }

            if (var->type->contains_atomic() &&
                var->data.atomic.offset != existing->data.atomic.offset) {
               linker_error(prog, "offset specifications for %s "
                            "`%s' have differing values\n",
                            mode_string(var), var->name);
               return;
d575 1
a575 1
	       bool layout_declared = var->data.depth_layout != ir_depth_layout_none;
d577 1
a577 1
		  var->data.depth_layout != existing->data.depth_layout;
d586 1
a586 1
	       if (var->data.used && layout_differs) {
d617 1
a617 1
		     return;
d638 2
a639 2
	    if (var->data.has_initializer) {
	       if (existing->data.has_initializer
d646 1
a646 1
		  return;
d654 1
a654 1
	       existing->data.has_initializer = true;
d657 1
a657 1
	    if (existing->data.invariant != var->data.invariant) {
d661 1
a661 1
	       return;
d663 1
a663 1
            if (existing->data.centroid != var->data.centroid) {
d667 1
a667 7
               return;
            }
            if (existing->data.sample != var->data.sample) {
               linker_error(prog, "declarations for %s `%s` have "
                            "mismatching sample qualifiers\n",
                            mode_string(var), var->name);
               return;
d673 2
d681 1
a681 1
void
d684 2
a685 2
   cross_validate_globals(prog, prog->_LinkedShaders,
                          MESA_SHADER_STAGES, true);
d696 1
a696 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d701 1
a701 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d790 1
a790 1
	 if (ir->var->data.mode == ir_var_temporary) {
d864 1
a864 1
      if ((var != NULL) && (var->data.mode != ir_var_temporary))
d870 1
a870 1
	     || ((var != NULL) && (var->data.mode == ir_var_temporary)));
d910 1
a910 1
      ir_function_signature *sig = f->matching_signature(NULL, &void_parameters);
a926 13
   array_sizing_visitor()
      : mem_ctx(ralloc_context(NULL)),
        unnamed_interfaces(hash_table_ctor(0, hash_table_pointer_hash,
                                           hash_table_pointer_compare))
   {
   }

   ~array_sizing_visitor()
   {
      hash_table_dtor(this->unnamed_interfaces);
      ralloc_free(this->mem_ctx);
   }

d929 6
a934 34
      fixup_type(&var->type, var->data.max_array_access);
      if (var->type->is_interface()) {
         if (interface_contains_unsized_arrays(var->type)) {
            const glsl_type *new_type =
               resize_interface_members(var->type, var->max_ifc_array_access);
            var->type = new_type;
            var->change_interface_type(new_type);
         }
      } else if (var->type->is_array() &&
                 var->type->fields.array->is_interface()) {
         if (interface_contains_unsized_arrays(var->type->fields.array)) {
            const glsl_type *new_type =
               resize_interface_members(var->type->fields.array,
                                        var->max_ifc_array_access);
            var->change_interface_type(new_type);
            var->type =
               glsl_type::get_array_instance(new_type, var->type->length);
         }
      } else if (const glsl_type *ifc_type = var->get_interface_type()) {
         /* Store a pointer to the variable in the unnamed_interfaces
          * hashtable.
          */
         ir_variable **interface_vars = (ir_variable **)
            hash_table_find(this->unnamed_interfaces, ifc_type);
         if (interface_vars == NULL) {
            interface_vars = rzalloc_array(mem_ctx, ir_variable *,
                                           ifc_type->length);
            hash_table_insert(this->unnamed_interfaces, interface_vars,
                              ifc_type);
         }
         unsigned index = ifc_type->field_index(var->name);
         assert(index < ifc_type->length);
         assert(interface_vars[index] == NULL);
         interface_vars[index] = var;
a937 109

   /**
    * For each unnamed interface block that was discovered while running the
    * visitor, adjust the interface type to reflect the newly assigned array
    * sizes, and fix up the ir_variable nodes to point to the new interface
    * type.
    */
   void fixup_unnamed_interface_types()
   {
      hash_table_call_foreach(this->unnamed_interfaces,
                              fixup_unnamed_interface_type, NULL);
   }

private:
   /**
    * If the type pointed to by \c type represents an unsized array, replace
    * it with a sized array whose size is determined by max_array_access.
    */
   static void fixup_type(const glsl_type **type, unsigned max_array_access)
   {
      if ((*type)->is_unsized_array()) {
         *type = glsl_type::get_array_instance((*type)->fields.array,
                                               max_array_access + 1);
         assert(*type != NULL);
      }
   }

   /**
    * Determine whether the given interface type contains unsized arrays (if
    * it doesn't, array_sizing_visitor doesn't need to process it).
    */
   static bool interface_contains_unsized_arrays(const glsl_type *type)
   {
      for (unsigned i = 0; i < type->length; i++) {
         const glsl_type *elem_type = type->fields.structure[i].type;
         if (elem_type->is_unsized_array())
            return true;
      }
      return false;
   }

   /**
    * Create a new interface type based on the given type, with unsized arrays
    * replaced by sized arrays whose size is determined by
    * max_ifc_array_access.
    */
   static const glsl_type *
   resize_interface_members(const glsl_type *type,
                            const unsigned *max_ifc_array_access)
   {
      unsigned num_fields = type->length;
      glsl_struct_field *fields = new glsl_struct_field[num_fields];
      memcpy(fields, type->fields.structure,
             num_fields * sizeof(*fields));
      for (unsigned i = 0; i < num_fields; i++) {
         fixup_type(&fields[i].type, max_ifc_array_access[i]);
      }
      glsl_interface_packing packing =
         (glsl_interface_packing) type->interface_packing;
      const glsl_type *new_ifc_type =
         glsl_type::get_interface_instance(fields, num_fields,
                                           packing, type->name);
      delete [] fields;
      return new_ifc_type;
   }

   static void fixup_unnamed_interface_type(const void *key, void *data,
                                            void *)
   {
      const glsl_type *ifc_type = (const glsl_type *) key;
      ir_variable **interface_vars = (ir_variable **) data;
      unsigned num_fields = ifc_type->length;
      glsl_struct_field *fields = new glsl_struct_field[num_fields];
      memcpy(fields, ifc_type->fields.structure,
             num_fields * sizeof(*fields));
      bool interface_type_changed = false;
      for (unsigned i = 0; i < num_fields; i++) {
         if (interface_vars[i] != NULL &&
             fields[i].type != interface_vars[i]->type) {
            fields[i].type = interface_vars[i]->type;
            interface_type_changed = true;
         }
      }
      if (!interface_type_changed) {
         delete [] fields;
         return;
      }
      glsl_interface_packing packing =
         (glsl_interface_packing) ifc_type->interface_packing;
      const glsl_type *new_ifc_type =
         glsl_type::get_interface_instance(fields, num_fields, packing,
                                           ifc_type->name);
      delete [] fields;
      for (unsigned i = 0; i < num_fields; i++) {
         if (interface_vars[i] != NULL)
            interface_vars[i]->change_interface_type(new_ifc_type);
      }
   }

   /**
    * Memory context used to allocate the data in \c unnamed_interfaces.
    */
   void *mem_ctx;

   /**
    * Hash table from const glsl_type * to an array of ir_variable *'s
    * pointing to the ir_variables constituting each unnamed interface block.
    */
   hash_table *unnamed_interfaces;
a940 251
 * Performs the cross-validation of layout qualifiers specified in
 * redeclaration of gl_FragCoord for the attached fragment shaders,
 * and propagates them to the linked FS and linked shader program.
 */
static void
link_fs_input_layout_qualifiers(struct gl_shader_program *prog,
	                        struct gl_shader *linked_shader,
	                        struct gl_shader **shader_list,
	                        unsigned num_shaders)
{
   linked_shader->redeclares_gl_fragcoord = false;
   linked_shader->uses_gl_fragcoord = false;
   linked_shader->origin_upper_left = false;
   linked_shader->pixel_center_integer = false;

   if (linked_shader->Stage != MESA_SHADER_FRAGMENT ||
       (prog->Version < 150 && !prog->ARB_fragment_coord_conventions_enable))
      return;

   for (unsigned i = 0; i < num_shaders; i++) {
      struct gl_shader *shader = shader_list[i];
      /* From the GLSL 1.50 spec, page 39:
       *
       *   "If gl_FragCoord is redeclared in any fragment shader in a program,
       *    it must be redeclared in all the fragment shaders in that program
       *    that have a static use gl_FragCoord."
       *
       * Exclude the case when one of the 'linked_shader' or 'shader' redeclares
       * gl_FragCoord with no layout qualifiers but the other one doesn't
       * redeclare it. If we strictly follow GLSL 1.50 spec's language, it
       * should be a link error. But, generating link error for this case will
       * be a wrong behaviour which spec didn't intend to do and it could also
       * break some applications.
       */
      if ((linked_shader->redeclares_gl_fragcoord
           && !shader->redeclares_gl_fragcoord
           && shader->uses_gl_fragcoord
           && (linked_shader->origin_upper_left
               || linked_shader->pixel_center_integer))
          || (shader->redeclares_gl_fragcoord
              && !linked_shader->redeclares_gl_fragcoord
              && linked_shader->uses_gl_fragcoord
              && (shader->origin_upper_left
                  || shader->pixel_center_integer))) {
             linker_error(prog, "fragment shader defined with conflicting "
                         "layout qualifiers for gl_FragCoord\n");
      }

      /* From the GLSL 1.50 spec, page 39:
       *
       *   "All redeclarations of gl_FragCoord in all fragment shaders in a
       *    single program must have the same set of qualifiers."
       */
      if (linked_shader->redeclares_gl_fragcoord && shader->redeclares_gl_fragcoord
          && (shader->origin_upper_left != linked_shader->origin_upper_left
          || shader->pixel_center_integer != linked_shader->pixel_center_integer)) {
         linker_error(prog, "fragment shader defined with conflicting "
                      "layout qualifiers for gl_FragCoord\n");
      }

      /* Update the linked shader state.  Note that uses_gl_fragcoord should
       * accumulate the results.  The other values should replace.  If there
       * are multiple redeclarations, all the fields except uses_gl_fragcoord
       * are already known to be the same.
       */
      if (shader->redeclares_gl_fragcoord || shader->uses_gl_fragcoord) {
         linked_shader->redeclares_gl_fragcoord =
            shader->redeclares_gl_fragcoord;
         linked_shader->uses_gl_fragcoord = linked_shader->uses_gl_fragcoord
            || shader->uses_gl_fragcoord;
         linked_shader->origin_upper_left = shader->origin_upper_left;
         linked_shader->pixel_center_integer = shader->pixel_center_integer;
      }
   }
}

/**
 * Performs the cross-validation of geometry shader max_vertices and
 * primitive type layout qualifiers for the attached geometry shaders,
 * and propagates them to the linked GS and linked shader program.
 */
static void
link_gs_inout_layout_qualifiers(struct gl_shader_program *prog,
				struct gl_shader *linked_shader,
				struct gl_shader **shader_list,
				unsigned num_shaders)
{
   linked_shader->Geom.VerticesOut = 0;
   linked_shader->Geom.Invocations = 0;
   linked_shader->Geom.InputType = PRIM_UNKNOWN;
   linked_shader->Geom.OutputType = PRIM_UNKNOWN;

   /* No in/out qualifiers defined for anything but GLSL 1.50+
    * geometry shaders so far.
    */
   if (linked_shader->Stage != MESA_SHADER_GEOMETRY || prog->Version < 150)
      return;

   /* From the GLSL 1.50 spec, page 46:
    *
    *     "All geometry shader output layout declarations in a program
    *      must declare the same layout and same value for
    *      max_vertices. There must be at least one geometry output
    *      layout declaration somewhere in a program, but not all
    *      geometry shaders (compilation units) are required to
    *      declare it."
    */

   for (unsigned i = 0; i < num_shaders; i++) {
      struct gl_shader *shader = shader_list[i];

      if (shader->Geom.InputType != PRIM_UNKNOWN) {
	 if (linked_shader->Geom.InputType != PRIM_UNKNOWN &&
	     linked_shader->Geom.InputType != shader->Geom.InputType) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "input types\n");
	    return;
	 }
	 linked_shader->Geom.InputType = shader->Geom.InputType;
      }

      if (shader->Geom.OutputType != PRIM_UNKNOWN) {
	 if (linked_shader->Geom.OutputType != PRIM_UNKNOWN &&
	     linked_shader->Geom.OutputType != shader->Geom.OutputType) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "output types\n");
	    return;
	 }
	 linked_shader->Geom.OutputType = shader->Geom.OutputType;
      }

      if (shader->Geom.VerticesOut != 0) {
	 if (linked_shader->Geom.VerticesOut != 0 &&
	     linked_shader->Geom.VerticesOut != shader->Geom.VerticesOut) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "output vertex count (%d and %d)\n",
			 linked_shader->Geom.VerticesOut,
			 shader->Geom.VerticesOut);
	    return;
	 }
	 linked_shader->Geom.VerticesOut = shader->Geom.VerticesOut;
      }

      if (shader->Geom.Invocations != 0) {
	 if (linked_shader->Geom.Invocations != 0 &&
	     linked_shader->Geom.Invocations != shader->Geom.Invocations) {
	    linker_error(prog, "geometry shader defined with conflicting "
			 "invocation count (%d and %d)\n",
			 linked_shader->Geom.Invocations,
			 shader->Geom.Invocations);
	    return;
	 }
	 linked_shader->Geom.Invocations = shader->Geom.Invocations;
      }
   }

   /* Just do the intrastage -> interstage propagation right now,
    * since we already know we're in the right type of shader program
    * for doing it.
    */
   if (linked_shader->Geom.InputType == PRIM_UNKNOWN) {
      linker_error(prog,
		   "geometry shader didn't declare primitive input type\n");
      return;
   }
   prog->Geom.InputType = linked_shader->Geom.InputType;

   if (linked_shader->Geom.OutputType == PRIM_UNKNOWN) {
      linker_error(prog,
		   "geometry shader didn't declare primitive output type\n");
      return;
   }
   prog->Geom.OutputType = linked_shader->Geom.OutputType;

   if (linked_shader->Geom.VerticesOut == 0) {
      linker_error(prog,
		   "geometry shader didn't declare max_vertices\n");
      return;
   }
   prog->Geom.VerticesOut = linked_shader->Geom.VerticesOut;

   if (linked_shader->Geom.Invocations == 0)
      linked_shader->Geom.Invocations = 1;

   prog->Geom.Invocations = linked_shader->Geom.Invocations;
}


/**
 * Perform cross-validation of compute shader local_size_{x,y,z} layout
 * qualifiers for the attached compute shaders, and propagate them to the
 * linked CS and linked shader program.
 */
static void
link_cs_input_layout_qualifiers(struct gl_shader_program *prog,
                                struct gl_shader *linked_shader,
                                struct gl_shader **shader_list,
                                unsigned num_shaders)
{
   for (int i = 0; i < 3; i++)
      linked_shader->Comp.LocalSize[i] = 0;

   /* This function is called for all shader stages, but it only has an effect
    * for compute shaders.
    */
   if (linked_shader->Stage != MESA_SHADER_COMPUTE)
      return;

   /* From the ARB_compute_shader spec, in the section describing local size
    * declarations:
    *
    *     If multiple compute shaders attached to a single program object
    *     declare local work-group size, the declarations must be identical;
    *     otherwise a link-time error results. Furthermore, if a program
    *     object contains any compute shaders, at least one must contain an
    *     input layout qualifier specifying the local work sizes of the
    *     program, or a link-time error will occur.
    */
   for (unsigned sh = 0; sh < num_shaders; sh++) {
      struct gl_shader *shader = shader_list[sh];

      if (shader->Comp.LocalSize[0] != 0) {
         if (linked_shader->Comp.LocalSize[0] != 0) {
            for (int i = 0; i < 3; i++) {
               if (linked_shader->Comp.LocalSize[i] !=
                   shader->Comp.LocalSize[i]) {
                  linker_error(prog, "compute shader defined with conflicting "
                               "local sizes\n");
                  return;
               }
            }
         }
         for (int i = 0; i < 3; i++)
            linked_shader->Comp.LocalSize[i] = shader->Comp.LocalSize[i];
      }
   }

   /* Just do the intrastage -> interstage propagation right now,
    * since we already know we're in the right type of shader program
    * for doing it.
    */
   if (linked_shader->Comp.LocalSize[0] == 0) {
      linker_error(prog, "compute shader didn't declare local size\n");
      return;
   }
   for (int i = 0; i < 3; i++)
      prog->Comp.LocalSize[i] = linked_shader->Comp.LocalSize[i];
}


/**
d958 1
a958 2
   cross_validate_globals(prog, shader_list, num_shaders, false);
   if (!prog->LinkStatus)
d963 2
a964 3
   validate_intrastage_interface_blocks(prog, (const gl_shader **)shader_list,
                                        num_shaders);
   if (!prog->LinkStatus)
d967 2
a968 2
   /* Link up uniform blocks defined within this stage. */
   const unsigned num_uniform_blocks =
d971 2
d994 3
a996 2
	    foreach_list(n, &f->signatures) {
	       ir_function_signature *sig = (ir_function_signature *) n;
d998 1
a998 1
	       if (!sig->is_defined || sig->is_builtin())
d1002 1
a1002 1
		  other->exact_matching_signature(NULL, &sig->parameters);
d1005 1
a1005 1
		   && !other_sig->is_builtin()) {
d1032 1
a1032 1
		   _mesa_shader_stage_to_string(shader_list[0]->Stage));
a1043 4
   link_fs_input_layout_qualifiers(prog, linked, shader_list, num_shaders);
   link_gs_inout_layout_qualifiers(prog, linked, shader_list, num_shaders);
   link_cs_input_layout_qualifiers(prog, linked, shader_list, num_shaders);

d1066 5
a1070 8
   /* Check if any shader needs built-in functions. */
   bool need_builtins = false;
   for (unsigned i = 0; i < num_shaders; i++) {
      if (shader_list[i]->uses_builtin_functions) {
         need_builtins = true;
         break;
      }
   }
d1072 2
a1073 9
   bool ok;
   if (need_builtins) {
      /* Make a temporary array one larger than shader_list, which will hold
       * the built-in function shader as well.
       */
      gl_shader **linking_shaders = (gl_shader **)
         calloc(num_shaders + 1, sizeof(gl_shader *));
      memcpy(linking_shaders, shader_list, num_shaders * sizeof(gl_shader *));
      linking_shaders[num_shaders] = _mesa_glsl_get_builtin_function_shader();
d1075 2
a1076 1
      ok = link_function_calls(prog, linked, linking_shaders, num_shaders + 1);
d1078 5
a1082 3
      free(linking_shaders);
   } else {
      ok = link_function_calls(prog, linked, shader_list, num_shaders);
d1085 1
d1087 2
a1088 1
   if (!ok) {
d1090 1
a1090 1
      return NULL;
d1093 2
d1098 2
a1099 11
   validate_ir_tree(linked->ir);

   /* Set the size of geometry shader input arrays */
   if (linked->Stage == MESA_SHADER_GEOMETRY) {
      unsigned num_vertices = vertices_per_prim(prog->Geom.InputType);
      geom_array_resize_visitor input_resize_visitor(num_vertices, prog);
      foreach_list(n, linked->ir) {
         ir_instruction *ir = (ir_instruction *) n;
         ir->accept(&input_resize_visitor);
      }
   }
d1105 5
a1109 3
   array_sizing_visitor v;
   v.run(linked->ir);
   v.fixup_unnamed_interface_types();
d1132 1
a1132 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d1139 3
a1141 1
	 if ((var == NULL) || (var->data.mode != ir_var_uniform) ||
a1147 4
          *
          * Atomic counters are supposed to get deterministic
          * locations assigned based on the declaration ordering and
          * sizes, array compaction would mess that up.
d1149 1
a1149 1
	 if (var->is_in_uniform_block() || var->type->contains_atomic())
d1152 2
a1153 2
	 unsigned int size = var->data.max_array_access;
	 for (unsigned j = 0; j < MESA_SHADER_STAGES; j++) {
d1163 2
a1164 2
		   other_var->data.max_array_access > size) {
		  size = other_var->data.max_array_access;
d1303 1
a1303 1
      if ((var == NULL) || (var->data.mode != (unsigned) direction))
d1306 3
a1308 3
      if (var->data.explicit_location) {
	 if ((var->data.location >= (int)(max_index + generic_base))
	     || (var->data.location < 0)) {
d1311 2
a1312 3
			 (var->data.location < 0)
			 ? var->data.location
                         : var->data.location - generic_base,
d1321 2
a1322 2
	    var->data.location = binding;
            var->data.is_unmatched_generic_inout = 0;
d1330 2
a1331 2
	    var->data.location = binding;
            var->data.is_unmatched_generic_inout = 0;
d1334 1
a1334 1
	       var->data.index = index;
d1344 3
a1346 3
      const unsigned slots = var->type->count_attribute_slots();
      if (var->data.location != -1) {
	 if (var->data.location >= generic_base && var->data.index < 1) {
d1355 2
a1356 4
	     * I think above text prohibits the aliasing of explicit and
	     * automatic assignments. But, aliasing is allowed in manual
	     * assignments of attribute locations. See below comments for
	     * the details.
d1358 1
a1358 1
	     * From OpenGL 4.0 spec, page 61:
d1371 5
a1375 40
	     * From GLSL 4.30 spec, page 54:
	     *
	     *    "A program will fail to link if any two non-vertex shader
	     *     input variables are assigned to the same location. For
	     *     vertex shaders, multiple input variables may be assigned
	     *     to the same location using either layout qualifiers or via
	     *     the OpenGL API. However, such aliasing is intended only to
	     *     support vertex shaders where each execution path accesses
	     *     at most one input per each location. Implementations are
	     *     permitted, but not required, to generate link-time errors
	     *     if they detect that every path through the vertex shader
	     *     executable accesses multiple inputs assigned to any single
	     *     location. For all shader types, a program will fail to link
	     *     if explicit location assignments leave the linker unable
	     *     to find space for other variables without explicit
	     *     assignments."
	     *
	     * From OpenGL ES 3.0 spec, page 56:
	     *
	     *    "Binding more than one attribute name to the same location
	     *     is referred to as aliasing, and is not permitted in OpenGL
	     *     ES Shading Language 3.00 vertex shaders. LinkProgram will
	     *     fail when this condition exists. However, aliasing is
	     *     possible in OpenGL ES Shading Language 1.00 vertex shaders.
	     *     This will only work if only one of the aliased attributes
	     *     is active in the executable program, or if no path through
	     *     the shader consumes more than one attribute of a set of
	     *     attributes aliased to the same location. A link error can
	     *     occur if the linker determines that every path through the
	     *     shader consumes multiple aliased attributes, but implemen-
	     *     tations are not required to generate an error in this case."
	     *
	     * After looking at above references from OpenGL, OpenGL ES and
	     * GLSL specifications, we allow aliasing of vertex input variables
	     * in: OpenGL 2.0 (and above) and OpenGL ES 2.0.
	     *
	     * NOTE: This is not required by the spec but its worth mentioning
	     * here that we're not doing anything to make sure that no path
	     * through the vertex shader executable accesses multiple inputs
	     * assigned to any single location.
a1376 1

d1380 1
a1380 1
	    const unsigned attr = var->data.location - generic_base;
a1381 13
            const char *const string = (target_index == MESA_SHADER_VERTEX)
               ? "vertex shader input" : "fragment shader output";

            /* Generate a link error if the requested locations for this
             * attribute exceed the maximum allowed attribute location.
             */
            if (attr + slots > max_index) {
               linker_error(prog,
                           "insufficient contiguous locations "
                           "available for %s `%s' %d %d %d", string,
                           var->name, used_locations, use_mask, attr);
               return false;
            }
d1387 7
a1393 13
               if (target_index == MESA_SHADER_FRAGMENT ||
                   (prog->IsES && prog->Version >= 300)) {
                  linker_error(prog,
                               "overlapping location is assigned "
                               "to %s `%s' %d %d %d\n", string,
                               var->name, used_locations, use_mask, attr);
                  return false;
               } else {
                  linker_warning(prog,
                                 "overlapping location is assigned "
                                 "to %s `%s' %d %d %d\n", string,
                                 var->name, used_locations, use_mask, attr);
               }
d1446 2
a1447 2
      to_assign[i].var->data.location = generic_base + location;
      to_assign[i].var->data.is_unmatched_generic_inout = 0;
d1464 1
a1464 1
      if ((var == NULL) || (var->data.mode != int(mode)))
d1471 2
a1472 2
      if (var->data.is_unmatched_generic_inout) {
	 var->data.mode = ir_var_auto;
d1500 1
a1500 1
      if (var == NULL || var->data.mode != ir_var_shader_out) {
d1505 1
a1505 1
         switch (var->data.depth_layout) {
d1532 1
a1532 1
static void
d1535 29
a1563 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d1569 1
a1569 1
      if (sh->num_samplers > ctx->Const.Program[i].MaxTextureImageUnits) {
d1571 1
a1571 1
		      _mesa_shader_stage_to_string(i));
d1574 1
a1574 2
      if (sh->num_uniform_components >
          ctx->Const.Program[i].MaxUniformComponents) {
d1580 1
a1580 1
                           _mesa_shader_stage_to_string(i));
d1584 1
a1584 1
                         _mesa_shader_stage_to_string(i));
d1589 1
a1589 1
	  ctx->Const.Program[i].MaxCombinedUniformComponents) {
d1594 1
a1594 1
                           _mesa_shader_stage_to_string(i));
d1597 1
a1597 1
                         _mesa_shader_stage_to_string(i));
d1602 1
a1602 1
   unsigned blocks[MESA_SHADER_STAGES] = {0};
d1606 1
a1606 1
      for (unsigned j = 0; j < MESA_SHADER_STAGES; j++) {
d1618 2
a1619 4
	 for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
            const unsigned max_uniform_blocks =
               ctx->Const.Program[i].MaxUniformBlocks;
	    if (blocks[i] > max_uniform_blocks) {
d1621 1
a1621 1
			    _mesa_shader_stage_to_string(i),
d1623 1
a1623 1
			    max_uniform_blocks);
a1628 36
}

/**
 * Validate shader image resources.
 */
static void
check_image_resources(struct gl_context *ctx, struct gl_shader_program *prog)
{
   unsigned total_image_units = 0;
   unsigned fragment_outputs = 0;

   if (!ctx->Extensions.ARB_shader_image_load_store)
      return;

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];

      if (sh) {
         if (sh->NumImages > ctx->Const.Program[i].MaxImageUniforms)
            linker_error(prog, "Too many %s shader image uniforms",
                         _mesa_shader_stage_to_string(i));

         total_image_units += sh->NumImages;

         if (i == MESA_SHADER_FRAGMENT) {
            foreach_list(node, sh->ir) {
               ir_variable *var = ((ir_instruction *)node)->as_variable();
               if (var && var->data.mode == ir_var_shader_out)
                  fragment_outputs += var->type->count_attribute_slots();
            }
         }
      }
   }

   if (total_image_units > ctx->Const.MaxCombinedImageUniforms)
      linker_error(prog, "Too many combined image uniforms");
d1630 1
a1630 3
   if (total_image_units + fragment_outputs >
       ctx->Const.MaxCombinedImageUnitsAndFragmentOutputs)
      linker_error(prog, "Too many combined image uniforms and fragment outputs");
d1641 1
a1641 1
   prog->LinkStatus = true; /* All error paths will set this to false */
d1651 1
a1651 1
   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
a1655 5
   ralloc_free(prog->AtomicBuffers);
   prog->AtomicBuffers = NULL;
   prog->NumAtomicBuffers = 0;
   prog->ARB_fragment_coord_conventions_enable = false;

d1658 8
a1665 8
   struct gl_shader **shader_list[MESA_SHADER_STAGES];
   unsigned num_shaders[MESA_SHADER_STAGES];

   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
      shader_list[i] = (struct gl_shader **)
         calloc(prog->NumShaders, sizeof(struct gl_shader *));
      num_shaders[i] = 0;
   }
d1681 14
a1694 6
      prog->ARB_fragment_coord_conventions_enable |=
         prog->Shaders[i]->ARB_fragment_coord_conventions_enable;

      gl_shader_stage shader_type = prog->Shaders[i]->Stage;
      shader_list[shader_type][num_shaders[shader_type]] = prog->Shaders[i];
      num_shaders[shader_type]++;
d1697 5
a1701 2
   /* In desktop GLSL, different shader versions may be linked together.  In
    * GLSL ES, all shader versions must be the same.
d1703 2
a1704 1
   if (is_es_prog && min_version != max_version) {
d1713 1
a1713 18
   /* Geometry shaders have to be linked with vertex shaders.
    */
   if (num_shaders[MESA_SHADER_GEOMETRY] > 0 &&
       num_shaders[MESA_SHADER_VERTEX] == 0 &&
       !prog->SeparateShader) {
      linker_error(prog, "Geometry shader must be linked with "
		   "vertex shader\n");
      goto done;
   }

   /* Compute shaders have additional restrictions. */
   if (num_shaders[MESA_SHADER_COMPUTE] > 0 &&
       num_shaders[MESA_SHADER_COMPUTE] != prog->NumShaders) {
      linker_error(prog, "Compute shaders may not be linked with any other "
                   "type of shader\n");
   }

   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
d1722 4
a1725 5
   for (int stage = 0; stage < MESA_SHADER_STAGES; stage++) {
      if (num_shaders[stage] > 0) {
         gl_shader *const sh =
            link_intrastage_shaders(mem_ctx, ctx, prog, shader_list[stage],
                                    num_shaders[stage]);
d1727 2
a1728 2
         if (!prog->LinkStatus)
            goto done;
d1730 2
a1731 13
         switch (stage) {
         case MESA_SHADER_VERTEX:
            validate_vertex_shader_executable(prog, sh);
            break;
         case MESA_SHADER_GEOMETRY:
            validate_geometry_shader_executable(prog, sh);
            break;
         case MESA_SHADER_FRAGMENT:
            validate_fragment_shader_executable(prog, sh);
            break;
         }
         if (!prog->LinkStatus)
            goto done;
d1733 2
a1734 2
         _mesa_reference_shader(ctx, &prog->_LinkedShaders[stage], sh);
      }
d1737 14
a1750 6
   if (num_shaders[MESA_SHADER_GEOMETRY] > 0)
      prog->LastClipDistanceArraySize = prog->Geom.ClipDistanceArraySize;
   else if (num_shaders[MESA_SHADER_VERTEX] > 0)
      prog->LastClipDistanceArraySize = prog->Vert.ClipDistanceArraySize;
   else
      prog->LastClipDistanceArraySize = 0; /* Not used */
d1756 2
a1757 3
   cross_validate_uniforms(prog);
   if (!prog->LinkStatus)
      goto done;
d1759 4
a1762 1
   unsigned prev;
d1764 6
a1769 4
   for (prev = 0; prev <= MESA_SHADER_FRAGMENT; prev++) {
      if (prog->_LinkedShaders[prev] != NULL)
         break;
   }
d1771 5
a1775 6
   /* Validate the inputs of each stage with the output of the preceding
    * stage.
    */
   for (unsigned i = prev + 1; i <= MESA_SHADER_FRAGMENT; i++) {
      if (prog->_LinkedShaders[i] == NULL)
         continue;
d1777 4
a1780 4
      validate_interstage_inout_blocks(prog, prog->_LinkedShaders[prev],
                                       prog->_LinkedShaders[i]);
      if (!prog->LinkStatus)
         goto done;
d1782 2
a1783 5
      cross_validate_outputs_to_inputs(prog,
                                       prog->_LinkedShaders[prev],
                                       prog->_LinkedShaders[i]);
      if (!prog->LinkStatus)
         goto done;
d1785 1
a1785 1
      prev = i;
a1787 5
   /* Cross-validate uniform blocks between shader stages */
   validate_interstage_uniform_blocks(prog, prog->_LinkedShaders,
                                      MESA_SHADER_STAGES);
   if (!prog->LinkStatus)
      goto done;
d1789 1
a1789 1
   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
d1814 1
a1814 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d1826 3
a1828 3
      while (do_common_optimization(prog->_LinkedShaders[i]->ir, true, false,
                                    &ctx->ShaderCompilerOptions[i],
                                    ctx->Const.NativeIntegers))
d1833 10
a1842 4
   for (unsigned i = MESA_SHADER_VERTEX; i <= MESA_SHADER_FRAGMENT; i++) {
      if (prog->_LinkedShaders[i] != NULL) {
         link_invalidate_variable_locations(prog->_LinkedShaders[i]->ir);
      }
d1859 1
a1859 1
   for (first = 0; first <= MESA_SHADER_FRAGMENT; first++) {
d1872 1
a1872 1
      if (first == MESA_SHADER_FRAGMENT) {
d1891 1
a1891 1
   for (last = MESA_SHADER_FRAGMENT; last >= 0; last--) {
d1899 1
a1899 1
      if (num_tfeedback_decls != 0 || prog->SeparateShader) {
d1905 1
a1905 2
                                       num_tfeedback_decls, tfeedback_decls,
                                       0))
d1912 1
a1912 2
      if (!prog->SeparateShader)
         demote_shader_inputs_and_outputs(sh, ir_var_shader_out);
d1927 1
a1927 10
      if (prog->SeparateShader) {
         if (!assign_varying_locations(ctx, mem_ctx, prog,
                                       NULL /* producer */,
                                       sh /* consumer */,
                                       0 /* num_tfeedback_decls */,
                                       NULL /* tfeedback_decls */,
                                       0 /* gs_input_vertices */))
            goto done;
      } else
         demote_shader_inputs_and_outputs(sh, ir_var_shader_in);
a1939 2
      unsigned gs_input_vertices =
         next == MESA_SHADER_GEOMETRY ? prog->Geom.VerticesIn : 0;
d1943 1
a1943 1
                tfeedback_decls, gs_input_vertices))
d1961 1
a1961 3
      if (!check_against_output_limit(ctx, prog, sh_i))
         goto done;
      if (!check_against_input_limit(ctx, prog, sh_next))
a1971 1
   link_assign_atomic_counter_resources(ctx, prog);
d1974 1
a1974 5
   check_resources(ctx, prog);
   check_image_resources(ctx, prog);
   link_check_atomic_counter_resources(ctx, prog);

   if (!prog->LinkStatus)
d1978 2
a1979 4
    * present in a linked program. GL_ARB_ES2_compatibility doesn't say
    * anything about shader linking when one of the shaders (vertex or
    * fragment shader) is absent. So, the extension shouldn't change the
    * behavior specified in GLSL specification.
d1981 2
a1982 1
   if (!prog->SeparateShader && ctx->API == API_OPENGLES2) {
d1993 3
a1995 2
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      free(shader_list[i]);
a1997 5

      /* Do a final validation step to make sure that the IR wasn't
       * invalidated by any modifications performed after intrastage linking.
       */
      validate_ir_tree(prog->_LinkedShaders[i]->ir);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a76 1
#include "ir_uniform.h"
d252 1
d254 1
a254 2
 * Visitor that determines the highest stream id to which a (geometry) shader
 * emits vertices. It also checks whether End{Stream}Primitive is ever called.
d256 1
a256 1
class find_emit_vertex_visitor : public ir_hierarchical_visitor {
d258 2
a259 6
   find_emit_vertex_visitor(int max_allowed)
      : max_stream_allowed(max_allowed),
        invalid_stream_id(0),
        invalid_stream_id_from_emit_vertex(false),
        end_primitive_found(false),
        uses_non_zero_stream(false)
d264 1
a264 1
   virtual ir_visitor_status visit_leave(ir_emit_vertex *ir)
d266 2
a267 18
      int stream_id = ir->stream_id();

      if (stream_id < 0) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = true;
         return visit_stop;
      }

      if (stream_id > max_stream_allowed) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = true;
         return visit_stop;
      }

      if (stream_id != 0)
         uses_non_zero_stream = true;

      return visit_continue;
d270 1
a270 1
   virtual ir_visitor_status visit_leave(ir_end_primitive *ir)
d272 1
a272 46
      end_primitive_found = true;

      int stream_id = ir->stream_id();

      if (stream_id < 0) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = false;
         return visit_stop;
      }

      if (stream_id > max_stream_allowed) {
         invalid_stream_id = stream_id;
         invalid_stream_id_from_emit_vertex = false;
         return visit_stop;
      }

      if (stream_id != 0)
         uses_non_zero_stream = true;

      return visit_continue;
   }

   bool error()
   {
      return invalid_stream_id != 0;
   }

   const char *error_func()
   {
      return invalid_stream_id_from_emit_vertex ?
         "EmitStreamVertex" : "EndStreamPrimitive";
   }

   int error_stream()
   {
      return invalid_stream_id;
   }

   bool uses_streams()
   {
      return uses_non_zero_stream;
   }

   bool uses_end_primitive()
   {
      return end_primitive_found;
d276 1
a276 5
   int max_stream_allowed;
   int invalid_stream_id;
   bool invalid_stream_id_from_emit_vertex;
   bool end_primitive_found;
   bool uses_non_zero_stream;
d370 2
a371 2
   foreach_in_list(ir_instruction, node, ir) {
      ir_variable *const var = node->as_variable();
d492 2
a493 2
    * All GLSL ES Versions are similar to GLSL 1.40--failing to write to
    * gl_Position is not an error.
d499 1
a499 8
        if (prog->IsES) {
          linker_warning(prog,
                         "vertex shader does not write to `gl_Position'."
                         "It's value is undefined. \n");
        } else {
          linker_error(prog,
                       "vertex shader does not write to `gl_Position'. \n");
        }
a552 22
}

/**
 * Check if geometry shaders emit to non-zero streams and do corresponding
 * validations.
 */
static void
validate_geometry_shader_emissions(struct gl_context *ctx,
                                   struct gl_shader_program *prog)
{
   if (prog->_LinkedShaders[MESA_SHADER_GEOMETRY] != NULL) {
      find_emit_vertex_visitor emit_vertex(ctx->Const.MaxVertexStreams - 1);
      emit_vertex.run(prog->_LinkedShaders[MESA_SHADER_GEOMETRY]->ir);
      if (emit_vertex.error()) {
         linker_error(prog, "Invalid call %s(%d). Accepted values for the "
                      "stream parameter are in the range [0, %d].",
                      emit_vertex.error_func(),
                      emit_vertex.error_stream(),
                      ctx->Const.MaxVertexStreams - 1);
      }
      prog->Geom.UsesStreams = emit_vertex.uses_streams();
      prog->Geom.UsesEndPrimitive = emit_vertex.uses_end_primitive();
d554 3
a556 29
      /* From the ARB_gpu_shader5 spec:
       *
       *   "Multiple vertex streams are supported only if the output primitive
       *    type is declared to be "points".  A program will fail to link if it
       *    contains a geometry shader calling EmitStreamVertex() or
       *    EndStreamPrimitive() if its output primitive type is not "points".
       *
       * However, in the same spec:
       *
       *   "The function EmitVertex() is equivalent to calling EmitStreamVertex()
       *    with <stream> set to zero."
       *
       * And:
       *
       *   "The function EndPrimitive() is equivalent to calling
       *    EndStreamPrimitive() with <stream> set to zero."
       *
       * Since we can call EmitVertex() and EndPrimitive() when we output
       * primitives other than points, calling EmitStreamVertex(0) or
       * EmitEndPrimitive(0) should not produce errors. This it also what Nvidia
       * does. Currently we only set prog->Geom.UsesStreams to TRUE when
       * EmitStreamVertex() or EmitEndPrimitive() are called with a non-zero
       * stream.
       */
      if (prog->Geom.UsesStreams && prog->Geom.OutputType != GL_POINTS) {
         linker_error(prog, "EmitStreamVertex(n) and EndStreamPrimitive(n) "
                      "with n>0 requires point output");
      }
   }
d577 2
a578 2
      foreach_in_list(ir_instruction, node, shader_list[i]->ir) {
	 ir_variable *const var = node->as_variable();
d847 2
a848 1
   foreach_in_list(ir_instruction, inst, sh->ir) {
d855 1
a855 2
         if (var->data.mode != ir_var_temporary)
            sh->symbols->add_variable(var);
d964 3
a966 1
   foreach_in_list_safe(ir_instruction, inst, instructions) {
d1003 2
a1004 2
ir_function_signature *
link_get_main_function_signature(gl_shader *sh)
d1017 1
a1017 2
      ir_function_signature *sig =
         f->matching_signature(NULL, &void_parameters, false);
d1053 1
a1053 2
               resize_interface_members(var->type,
                                        var->get_max_ifc_array_access());
d1062 1
a1062 1
                                        var->get_max_ifc_array_access());
a1480 2
   if (!prog->LinkStatus)
      return NULL;
d1486 2
a1487 2
      foreach_in_list(ir_instruction, node, shader_list[i]->ir) {
	 ir_function *const f = node->as_function();
d1502 3
a1504 1
	    foreach_in_list(ir_function_signature, sig, &f->signatures) {
d1531 1
a1531 1
      if (link_get_main_function_signature(shader_list[i]) != NULL) {
d1557 1
a1557 1
   /* The pointer to the main function in the final linked shader (i.e., the
d1560 1
a1560 2
   ir_function_signature *const main_sig =
      link_get_main_function_signature(linked);
d1593 2
d1596 1
a1596 5
      ok = linking_shaders != NULL;

      if (ok) {
         memcpy(linking_shaders, shader_list, num_shaders * sizeof(gl_shader *));
         linking_shaders[num_shaders] = _mesa_glsl_get_builtin_function_shader();
d1598 1
a1598 6
         ok = link_function_calls(prog, linked, linking_shaders, num_shaders + 1);

         free(linking_shaders);
      } else {
         _mesa_error_no_memory(__func__);
      }
d1618 2
a1619 1
      foreach_in_list(ir_instruction, ir, linked->ir) {
a1623 3
   if (ctx->Const.VertexID_is_zero_based)
      lower_vertex_id(linked);

d1657 2
a1658 2
      foreach_in_list(ir_instruction, node, prog->_LinkedShaders[i]->ir) {
	 ir_variable *const var = node->as_variable();
d1680 2
a1681 2
	    foreach_in_list(ir_instruction, node2, prog->_LinkedShaders[j]->ir) {
	       ir_variable *other_var = node2->as_variable();
d1701 3
a1703 4
            const unsigned num_slots = var->get_num_state_slots();
	    if (num_slots > 0) {
	       var->set_num_state_slots((size + 1)
                                        * (num_slots / var->type->length));
d1749 1
a1749 1
 * Assign locations for either VS inputs or FS outputs
d1823 2
a1824 2
   foreach_in_list(ir_instruction, node, sh->ir) {
      ir_variable *const var = node->as_variable();
d2042 2
a2043 2
   foreach_in_list(ir_instruction, node, sh->ir) {
      ir_variable *const var = node->as_variable();
a2052 1
         assert(var->data.mode != ir_var_temporary);
d2078 2
a2079 2
   foreach_in_list(ir_instruction, node, ir) {
      ir_variable *const var = node->as_variable();
d2210 2
a2211 2
            foreach_in_list(ir_instruction, node, sh->ir) {
               ir_variable *var = node->as_variable();
a2226 111

/**
 * Initializes explicit location slots to INACTIVE_UNIFORM_EXPLICIT_LOCATION
 * for a variable, checks for overlaps between other uniforms using explicit
 * locations.
 */
static bool
reserve_explicit_locations(struct gl_shader_program *prog,
                           string_to_uint_map *map, ir_variable *var)
{
   unsigned slots = var->type->uniform_locations();
   unsigned max_loc = var->data.location + slots - 1;

   /* Resize remap table if locations do not fit in the current one. */
   if (max_loc + 1 > prog->NumUniformRemapTable) {
      prog->UniformRemapTable =
         reralloc(prog, prog->UniformRemapTable,
                  gl_uniform_storage *,
                  max_loc + 1);

      if (!prog->UniformRemapTable) {
         linker_error(prog, "Out of memory during linking.");
         return false;
      }

      /* Initialize allocated space. */
      for (unsigned i = prog->NumUniformRemapTable; i < max_loc + 1; i++)
         prog->UniformRemapTable[i] = NULL;

      prog->NumUniformRemapTable = max_loc + 1;
   }

   for (unsigned i = 0; i < slots; i++) {
      unsigned loc = var->data.location + i;

      /* Check if location is already used. */
      if (prog->UniformRemapTable[loc] == INACTIVE_UNIFORM_EXPLICIT_LOCATION) {

         /* Possibly same uniform from a different stage, this is ok. */
         unsigned hash_loc;
         if (map->get(hash_loc, var->name) && hash_loc == loc - i)
               continue;

         /* ARB_explicit_uniform_location specification states:
          *
          *     "No two default-block uniform variables in the program can have
          *     the same location, even if they are unused, otherwise a compiler
          *     or linker error will be generated."
          */
         linker_error(prog,
                      "location qualifier for uniform %s overlaps "
                      "previously used location",
                      var->name);
         return false;
      }

      /* Initialize location as inactive before optimization
       * rounds and location assignment.
       */
      prog->UniformRemapTable[loc] = INACTIVE_UNIFORM_EXPLICIT_LOCATION;
   }

   /* Note, base location used for arrays. */
   map->put(var->data.location, var->name);

   return true;
}

/**
 * Check and reserve all explicit uniform locations, called before
 * any optimizations happen to handle also inactive uniforms and
 * inactive array elements that may get trimmed away.
 */
static void
check_explicit_uniform_locations(struct gl_context *ctx,
                                 struct gl_shader_program *prog)
{
   if (!ctx->Extensions.ARB_explicit_uniform_location)
      return;

   /* This map is used to detect if overlapping explicit locations
    * occur with the same uniform (from different stage) or a different one.
    */
   string_to_uint_map *uniform_map = new string_to_uint_map;

   if (!uniform_map) {
      linker_error(prog, "Out of memory during linking.");
      return;
   }

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_shader *sh = prog->_LinkedShaders[i];

      if (!sh)
         continue;

      foreach_in_list(ir_instruction, node, sh->ir) {
         ir_variable *var = node->as_variable();
         if ((var && var->data.mode == ir_var_uniform) &&
             var->data.explicit_location) {
            if (!reserve_explicit_locations(prog, uniform_map, var)) {
               delete uniform_map;
               return;
            }
         }
      }
   }

   delete uniform_map;
}

d2239 14
a2374 4
   check_explicit_uniform_locations(ctx, prog);
   if (!prog->LinkStatus)
      goto done;

d2435 1
a2435 1
      if (ctx->Const.ShaderCompilerOptions[i].LowerClipDistance) {
d2440 1
a2440 1
                                    &ctx->Const.ShaderCompilerOptions[i],
a2442 2

      lower_const_arrays_to_uniforms(prog->_LinkedShaders[i]->ir);
a2444 3
   /* Check and validate stream emissions in geometry shaders */
   validate_geometry_shader_emissions(ctx, prog);

a2505 15
      if (first == MESA_SHADER_GEOMETRY) {
         /* There was no vertex shader, but we still have to assign varying
          * locations for use by geometry shader inputs in SSO.
          *
          * If the shader is not separable (i.e., prog->SeparateShader is
          * false), linking will have already failed when first is
          * MESA_SHADER_GEOMETRY.
          */
         if (!assign_varying_locations(ctx, mem_ctx, prog,
                                       NULL, sh,
                                       num_tfeedback_decls, tfeedback_decls,
                                       prog->Geom.VerticesIn))
            goto done;
      }

d2593 1
a2593 1
   link_assign_uniform_locations(prog, ctx->Const.UniformBooleanTrue);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d77 1
a252 1

d254 2
a255 1
 * Visitor that determines whether or not a shader uses ir_end_primitive.
d257 1
a257 1
class find_end_primitive_visitor : public ir_hierarchical_visitor {
d259 6
a264 2
   find_end_primitive_visitor()
      : found(false)
d269 63
a331 1
   virtual ir_visitor_status visit(ir_end_primitive *)
d333 1
a333 2
      found = true;
      return visit_stop;
d336 1
a336 1
   bool end_primitive_found()
d338 1
a338 1
      return found;
d342 5
a346 1
   bool found;
d440 2
a441 2
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d562 2
a563 2
    * GLSL ES 3.00 is similar to GLSL 1.40--failing to write to gl_Position is
    * not an error.
d569 8
a576 1
	 linker_error(prog, "vertex shader does not write to `gl_Position'\n");
d630 22
d653 29
a681 3
   find_end_primitive_visitor end_primitive;
   end_primitive.run(shader->ir);
   prog->Geom.UsesEndPrimitive = end_primitive.end_primitive_found();
d702 2
a703 2
      foreach_list(node, shader_list[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();
d972 1
a972 2
   foreach_list(node, sh->ir) {
      ir_instruction *const inst = (ir_instruction *) node;
d979 2
a980 1
	 sh->symbols->add_variable(var);
d1089 1
a1089 3
   foreach_list_safe(node, instructions) {
      ir_instruction *inst = (ir_instruction *) node;

d1126 2
a1127 2
static ir_function_signature *
get_main_function_signature(gl_shader *sh)
d1140 2
a1141 1
      ir_function_signature *sig = f->matching_signature(NULL, &void_parameters);
d1177 2
a1178 1
               resize_interface_members(var->type, var->max_ifc_array_access);
d1187 1
a1187 1
                                        var->max_ifc_array_access);
d1606 2
d1613 2
a1614 2
      foreach_list(node, shader_list[i]->ir) {
	 ir_function *const f = ((ir_instruction *) node)->as_function();
d1629 1
a1629 3
	    foreach_list(n, &f->signatures) {
	       ir_function_signature *sig = (ir_function_signature *) n;

d1656 1
a1656 1
      if (get_main_function_signature(shader_list[i]) != NULL) {
d1682 1
a1682 1
   /* The a pointer to the main function in the final linked shader (i.e., the
d1685 2
a1686 1
   ir_function_signature *const main_sig = get_main_function_signature(linked);
a1718 2
      memcpy(linking_shaders, shader_list, num_shaders * sizeof(gl_shader *));
      linking_shaders[num_shaders] = _mesa_glsl_get_builtin_function_shader();
d1720 5
a1724 1
      ok = link_function_calls(prog, linked, linking_shaders, num_shaders + 1);
d1726 6
a1731 1
      free(linking_shaders);
d1751 1
a1751 2
      foreach_list(n, linked->ir) {
         ir_instruction *ir = (ir_instruction *) n;
d1756 3
d1792 2
a1793 2
      foreach_list(node, prog->_LinkedShaders[i]->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();
d1815 2
a1816 2
	    foreach_list(node2, prog->_LinkedShaders[j]->ir) {
	       ir_variable *other_var = ((ir_instruction *) node2)->as_variable();
d1836 4
a1839 3
	    if (var->num_state_slots > 0) {
	       var->num_state_slots = (size + 1)
		  * (var->num_state_slots / var->type->length);
d1885 1
a1885 1
 * Assign locations for either VS inputs for FS outputs
d1959 2
a1960 2
   foreach_list(node, sh->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d2178 2
a2179 2
   foreach_list(node, sh->ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d2189 1
d2215 2
a2216 2
   foreach_list(node, ir) {
      ir_variable *const var = ((ir_instruction *) node)->as_variable();
d2347 2
a2348 2
            foreach_list(node, sh->ir) {
               ir_variable *var = ((ir_instruction *)node)->as_variable();
d2364 111
a2486 14
   ralloc_free(prog->InfoLog);
   prog->InfoLog = ralloc_strdup(NULL, "");

   ralloc_free(prog->UniformBlocks);
   prog->UniformBlocks = NULL;
   prog->NumUniformBlocks = 0;
   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
      ralloc_free(prog->UniformBlockStageIndex[i]);
      prog->UniformBlockStageIndex[i] = NULL;
   }

   ralloc_free(prog->AtomicBuffers);
   prog->AtomicBuffers = NULL;
   prog->NumAtomicBuffers = 0;
d2609 4
d2673 1
a2673 1
      if (ctx->ShaderCompilerOptions[i].LowerClipDistance) {
d2678 1
a2678 1
                                    &ctx->ShaderCompilerOptions[i],
d2681 2
d2685 3
d2749 15
d2851 1
a2851 1
   link_assign_uniform_locations(prog);
@


