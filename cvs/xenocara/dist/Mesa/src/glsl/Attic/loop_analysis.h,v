head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/* -*- c++ -*- */
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once
#ifndef LOOP_ANALYSIS_H
#define LOOP_ANALYSIS_H

#include "ir.h"
#include "program/hash_table.h"

/**
 * Analyze and classify all variables used in all loops in the instruction list
 */
extern class loop_state *
analyze_loop_variables(exec_list *instructions);


/**
 * Fill in loop control fields
 *
 * Based on analysis of loop variables, this function tries to remove
 * redundant sequences in the loop of the form
 *
 *  (if (expression bool ...) (break))
 *
 * For example, if it is provable that one loop exit condition will
 * always be satisfied before another, the unnecessary exit condition will be
 * removed.
 */
extern bool
set_loop_controls(exec_list *instructions, loop_state *ls);


extern bool
unroll_loops(exec_list *instructions, loop_state *ls,
             const struct gl_shader_compiler_options *options);

ir_rvalue *
find_initial_value(ir_loop *loop, ir_variable *var);

int
calculate_iterations(ir_rvalue *from, ir_rvalue *to, ir_rvalue *increment,
		     enum ir_expression_operation op);


/**
 * Tracking for all variables used in a loop
 */
class loop_variable_state : public exec_node {
public:
   class loop_variable *get(const ir_variable *);
   class loop_variable *insert(ir_variable *);
   class loop_variable *get_or_insert(ir_variable *, bool in_assignee);
   class loop_terminator *insert(ir_if *);


   /**
    * Variables that have not yet been classified
    */
   exec_list variables;

   /**
    * Variables whose values are constant within the body of the loop
    *
    * This list contains \c loop_variable objects.
    */
   exec_list constants;

   /**
    * Induction variables for this loop
    *
    * This list contains \c loop_variable objects.
    */
   exec_list induction_variables;

   /**
    * Simple if-statements that lead to the termination of the loop
    *
    * This list contains \c loop_terminator objects.
    *
    * \sa is_loop_terminator
    */
   exec_list terminators;

   /**
    * If any of the terminators in \c terminators leads to termination of the
    * loop after a constant number of iterations, this is the terminator that
    * leads to termination after the smallest number of iterations.  Otherwise
    * NULL.
    */
   loop_terminator *limiting_terminator;

   /**
    * Hash table containing all variables accessed in this loop
    */
   hash_table *var_hash;

   /**
    * Number of ir_loop_jump instructions that operate on this loop
    */
   unsigned num_loop_jumps;

   /**
    * Whether this loop contains any function calls.
    */
   bool contains_calls;

   loop_variable_state()
   {
      this->num_loop_jumps = 0;
      this->contains_calls = false;
      this->var_hash = hash_table_ctor(0, hash_table_pointer_hash,
				       hash_table_pointer_compare);
      this->limiting_terminator = NULL;
   }

   ~loop_variable_state()
   {
      hash_table_dtor(this->var_hash);
   }

   static void* operator new(size_t size, void *ctx)
   {
      void *lvs = ralloc_size(ctx, size);
      assert(lvs != NULL);

      ralloc_set_destructor(lvs, (void (*)(void*)) destructor);

      return lvs;
   }

private:
   static void
   destructor(loop_variable_state *lvs)
   {
      lvs->~loop_variable_state();
   }
};


class loop_variable : public exec_node {
public:
   /** The variable in question. */
   ir_variable *var;

   /** Is the variable read in the loop before it is written? */
   bool read_before_write;

   /** Are all variables in the RHS of the assignment loop constants? */
   bool rhs_clean;

   /**
    * Is there an assignment to the variable that is conditional, or inside a
    * nested loop?
    */
   bool conditional_or_nested_assignment;

   /** Reference to the first assignment to the variable in the loop body. */
   ir_assignment *first_assignment;

   /** Number of assignments to the variable in the loop body. */
   unsigned num_assignments;

   /**
    * Increment value for a loop induction variable
    *
    * If this is a loop induction variable, the amount by which the variable
    * is incremented on each iteration through the loop.
    *
    * If this is not a loop induction variable, NULL.
    */
   ir_rvalue *increment;


   inline bool is_induction_var() const
   {
      /* Induction variables always have a non-null increment, and vice
       * versa.
       */
      return this->increment != NULL;
   }


   inline bool is_loop_constant() const
   {
      const bool is_const = (this->num_assignments == 0)
	 || ((this->num_assignments == 1)
	     && !this->conditional_or_nested_assignment
	     && !this->read_before_write
	     && this->rhs_clean);

      /* If the RHS of *the* assignment is clean, then there must be exactly
       * one assignment of the variable.
       */
      assert((this->rhs_clean && (this->num_assignments == 1))
	     || !this->rhs_clean);

      /* Variables that are marked read-only *MUST* be loop constant.
       */
      assert(!this->var->data.read_only
            || (this->var->data.read_only && is_const));

      return is_const;
   }

   void record_reference(bool in_assignee,
                         bool in_conditional_code_or_nested_loop,
                         ir_assignment *current_assignment);
};


class loop_terminator : public exec_node {
public:
   loop_terminator()
      : ir(NULL), iterations(-1)
   {
   }

   /**
    * Statement which terminates the loop.
    */
   ir_if *ir;

   /**
    * The number of iterations after which the terminator is known to
    * terminate the loop (if that is a fixed value).  Otherwise -1.
    */
   int iterations;
};


class loop_state {
public:
   ~loop_state();

   /**
    * Get the loop variable state data for a particular loop
    */
   loop_variable_state *get(const ir_loop *);

   loop_variable_state *insert(ir_loop *ir);

   bool loop_found;

private:
   loop_state();

   /**
    * Hash table containing all loops that have been analyzed.
    */
   hash_table *ht;

   void *mem_ctx;

   friend loop_state *analyze_loop_variables(exec_list *instructions);
};

#endif /* LOOP_ANALYSIS_H */
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d143 16
a158 1
   DECLARE_RALLOC_CXX_OPERATORS(loop_variable_state)
d208 1
a208 1
         || (((this->num_assignments == 1)
d211 1
a211 1
             && this->rhs_clean) || this->var->data.read_only);
d218 5
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d143 1
a143 16
   static void* operator new(size_t size, void *ctx)
   {
      void *lvs = ralloc_size(ctx, size);
      assert(lvs != NULL);

      ralloc_set_destructor(lvs, (void (*)(void*)) destructor);

      return lvs;
   }

private:
   static void
   destructor(loop_variable_state *lvs)
   {
      lvs->~loop_variable_state();
   }
d193 1
a193 1
	 || ((this->num_assignments == 1)
d196 1
a196 1
	     && this->rhs_clean);
a202 5

      /* Variables that are marked read-only *MUST* be loop constant.
       */
      assert(!this->var->data.read_only
            || (this->var->data.read_only && is_const));
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d42 2
a43 2
 * Based on analysis of loop variables, this function tries to remove sequences
 * in the loop of the form
d47 1
a47 5
 * and fill in the \c ir_loop::from, \c ir_loop::to, and \c ir_loop::counter
 * fields of the \c ir_loop.
 *
 * In this process, some conditional break-statements may be eliminated
 * altogether.  For example, if it is provable that one loop exit condition will
d56 9
a64 1
unroll_loops(exec_list *instructions, loop_state *ls, unsigned max_iterations);
d74 1
a78 5
    * Loop whose variable state is being tracked by this structure
    */
   ir_loop *loop;

   /**
d107 4
a110 1
    * Hash table containing all variables accessed in this loop
d112 1
a112 1
   hash_table *var_hash;
d115 1
a115 5
    * Maximum number of loop iterations.
    *
    * If this value is negative, then the loop may be infinite.  This actually
    * means that analysis was unable to determine an upper bound on the number
    * of loop iterations.
d117 1
a117 1
   int max_iterations;
a130 1
      this->max_iterations = -1;
d135 1
d173 5
a177 2
   /** Is there an assignment to the variable that is conditional? */
   bool conditional_assignment;
d186 4
a189 1
    * Increment values for loop induction variables
d191 2
a192 10
    * Loop induction variables have a single increment of the form
    * \c b * \c biv + \c c, where \c b and \c c are loop constants and \c i
    * is a basic loop induction variable.
    *
    * If \c iv_scale is \c NULL, 1 is used.  If \c biv is the same as \c var,
    * then \c var is a basic loop induction variable.
    */
   /*@@{*/
   ir_rvalue *iv_scale;
   ir_variable *biv;
d194 9
a202 1
   /*@@}*/
d209 1
a209 1
	     && !this->conditional_assignment
d221 2
a222 1
      assert(!this->var->read_only || (this->var->read_only && is_const));
d226 4
d235 8
d244 6
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d125 5
d134 1
d143 17
d252 1
a252 1
   friend class loop_analysis;
@


1.1
log
@Initial revision
@
text
@d217 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a124 5
   /**
    * Whether this loop contains any function calls.
    */
   bool contains_calls;

a128 1
      this->contains_calls = false;
a136 17

   static void* operator new(size_t size, void *ctx)
   {
      void *lvs = ralloc_size(ctx, size);
      assert(lvs != NULL);

      ralloc_set_destructor(lvs, (void (*)(void*)) destructor);

      return lvs;
   }

private:
   static void
   destructor(loop_variable_state *lvs)
   {
      lvs->~loop_variable_state();
   }
a216 2
   bool loop_found;

d227 1
a227 1
   friend loop_state *analyze_loop_variables(exec_list *instructions);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d42 2
a43 2
 * Based on analysis of loop variables, this function tries to remove
 * redundant sequences in the loop of the form
d47 5
a51 1
 * For example, if it is provable that one loop exit condition will
d60 1
a60 9
unroll_loops(exec_list *instructions, loop_state *ls,
             const struct gl_shader_compiler_options *options);

ir_rvalue *
find_initial_value(ir_loop *loop, ir_variable *var);

int
calculate_iterations(ir_rvalue *from, ir_rvalue *to, ir_rvalue *increment,
		     enum ir_expression_operation op);
a69 1
   class loop_variable *get_or_insert(ir_variable *, bool in_assignee);
d74 5
d107 1
a107 4
    * If any of the terminators in \c terminators leads to termination of the
    * loop after a constant number of iterations, this is the terminator that
    * leads to termination after the smallest number of iterations.  Otherwise
    * NULL.
d109 1
a109 1
   loop_terminator *limiting_terminator;
d112 5
a116 1
    * Hash table containing all variables accessed in this loop
d118 1
a118 1
   hash_table *var_hash;
d132 1
a136 1
      this->limiting_terminator = NULL;
d174 2
a175 5
   /**
    * Is there an assignment to the variable that is conditional, or inside a
    * nested loop?
    */
   bool conditional_or_nested_assignment;
d184 1
a184 4
    * Increment value for a loop induction variable
    *
    * If this is a loop induction variable, the amount by which the variable
    * is incremented on each iteration through the loop.
d186 10
a195 2
    * If this is not a loop induction variable, NULL.
    */
d197 1
a197 9


   inline bool is_induction_var() const
   {
      /* Induction variables always have a non-null increment, and vice
       * versa.
       */
      return this->increment != NULL;
   }
d204 1
a204 1
	     && !this->conditional_or_nested_assignment
d216 1
a216 2
      assert(!this->var->data.read_only
            || (this->var->data.read_only && is_const));
a219 4

   void record_reference(bool in_assignee,
                         bool in_conditional_code_or_nested_loop,
                         ir_assignment *current_assignment);
a224 8
   loop_terminator()
      : ir(NULL), iterations(-1)
   {
   }

   /**
    * Statement which terminates the loop.
    */
a225 6

   /**
    * The number of iterations after which the terminator is known to
    * terminate the loop (if that is a fixed value).  Otherwise -1.
    */
   int iterations;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d143 16
a158 1
   DECLARE_RALLOC_CXX_OPERATORS(loop_variable_state)
d208 1
a208 1
         || (((this->num_assignments == 1)
d211 1
a211 1
             && this->rhs_clean) || this->var->data.read_only);
d218 5
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d143 1
a143 16
   static void* operator new(size_t size, void *ctx)
   {
      void *lvs = ralloc_size(ctx, size);
      assert(lvs != NULL);

      ralloc_set_destructor(lvs, (void (*)(void*)) destructor);

      return lvs;
   }

private:
   static void
   destructor(loop_variable_state *lvs)
   {
      lvs->~loop_variable_state();
   }
d193 1
a193 1
	 || ((this->num_assignments == 1)
d196 1
a196 1
	     && this->rhs_clean);
a202 5

      /* Variables that are marked read-only *MUST* be loop constant.
       */
      assert(!this->var->data.read_only
            || (this->var->data.read_only && is_const));
@


