head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.20;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.37;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.44;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.49;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */



#include "main/mtypes.h"
#include "main/macros.h"
#include "main/fbobject.h"
#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "brw_sf.h"

static void upload_sf_vp(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   const GLfloat depth_scale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   struct brw_sf_viewport *sfv;
   GLfloat y_scale, y_bias;
   const bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;

   sfv = brw_state_batch(brw, AUB_TRACE_SF_VP_STATE,
			 sizeof(*sfv), 32, &brw->sf.vp_offset);
   memset(sfv, 0, sizeof(*sfv));

   if (render_to_fbo) {
      y_scale = 1.0;
      y_bias = 0;
   }
   else {
      y_scale = -1.0;
      y_bias = ctx->DrawBuffer->Height;
   }

   /* _NEW_VIEWPORT */

   sfv->viewport.m00 = v[MAT_SX];
   sfv->viewport.m11 = v[MAT_SY] * y_scale;
   sfv->viewport.m22 = v[MAT_SZ] * depth_scale;
   sfv->viewport.m30 = v[MAT_TX];
   sfv->viewport.m31 = v[MAT_TY] * y_scale + y_bias;
   sfv->viewport.m32 = v[MAT_TZ] * depth_scale;

   /* _NEW_SCISSOR | _NEW_BUFFERS | _NEW_VIEWPORT
    * for DrawBuffer->_[XY]{min,max}
    */

   /* The scissor only needs to handle the intersection of drawable
    * and scissor rect, since there are no longer cliprects for shared
    * buffers with DRI2.
    *
    * Note that the hardware's coordinates are inclusive, while Mesa's min is
    * inclusive but max is exclusive.
    */

   if (ctx->DrawBuffer->_Xmin == ctx->DrawBuffer->_Xmax ||
       ctx->DrawBuffer->_Ymin == ctx->DrawBuffer->_Ymax) {
      /* If the scissor was out of bounds and got clamped to 0
       * width/height at the bounds, the subtraction of 1 from
       * maximums could produce a negative number and thus not clip
       * anything.  Instead, just provide a min > max scissor inside
       * the bounds, which produces the expected no rendering.
       */
      sfv->scissor.xmin = 1;
      sfv->scissor.xmax = 0;
      sfv->scissor.ymin = 1;
      sfv->scissor.ymax = 0;
   } else if (render_to_fbo) {
      /* texmemory: Y=0=bottom */
      sfv->scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv->scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv->scissor.ymin = ctx->DrawBuffer->_Ymin;
      sfv->scissor.ymax = ctx->DrawBuffer->_Ymax - 1;
   }
   else {
      /* memory: Y=0=top */
      sfv->scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv->scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv->scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
      sfv->scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
   }

   brw->state.dirty.cache |= CACHE_NEW_SF_VP;
}

const struct brw_tracked_state brw_sf_vp = {
   .dirty = {
      .mesa  = (_NEW_VIEWPORT |
		_NEW_SCISSOR |
		_NEW_BUFFERS),
      .brw   = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = upload_sf_vp
};

static void upload_sf_unit( struct brw_context *brw )
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_sf_unit_state *sf;
   drm_intel_bo *bo = brw->batch.bo;
   int chipset_max_threads;
   bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);

   sf = brw_state_batch(brw, AUB_TRACE_SF_STATE,
			sizeof(*sf), 64, &brw->sf.state_offset);

   memset(sf, 0, sizeof(*sf));

   /* BRW_NEW_PROGRAM_CACHE | CACHE_NEW_SF_PROG */
   sf->thread0.grf_reg_count = ALIGN(brw->sf.prog_data->total_grf, 16) / 16 - 1;
   sf->thread0.kernel_start_pointer =
      brw_program_reloc(brw,
			brw->sf.state_offset +
			offsetof(struct brw_sf_unit_state, thread0),
			brw->sf.prog_offset +
			(sf->thread0.grf_reg_count << 1)) >> 6;

   sf->thread1.floating_point_mode = BRW_FLOATING_POINT_NON_IEEE_754;

   sf->thread3.dispatch_grf_start_reg = 3;
   sf->thread3.urb_entry_read_offset = BRW_SF_URB_ENTRY_READ_OFFSET;

   /* CACHE_NEW_SF_PROG */
   sf->thread3.urb_entry_read_length = brw->sf.prog_data->urb_read_length;

   /* BRW_NEW_URB_FENCE */
   sf->thread4.nr_urb_entries = brw->urb.nr_sf_entries;
   sf->thread4.urb_entry_allocation_size = brw->urb.sfsize - 1;

   /* Each SF thread produces 1 PUE, and there can be up to 24 (Pre-Ironlake) or
    * 48 (Ironlake) threads.
    */
   if (brw->gen == 5)
      chipset_max_threads = 48;
   else
      chipset_max_threads = 24;

   /* BRW_NEW_URB_FENCE */
   sf->thread4.max_threads = MIN2(chipset_max_threads,
				  brw->urb.nr_sf_entries) - 1;

   if (unlikely(INTEL_DEBUG & DEBUG_STATS))
      sf->thread4.stats_enable = 1;

   /* CACHE_NEW_SF_VP */
   sf->sf5.sf_viewport_state_offset = (brw->batch.bo->offset64 +
				       brw->sf.vp_offset) >> 5; /* reloc */

   sf->sf5.viewport_transform = 1;

   /* _NEW_SCISSOR */
   if (ctx->Scissor.EnableFlags)
      sf->sf6.scissor = 1;

   /* _NEW_POLYGON */
   if (ctx->Polygon.FrontFace == GL_CCW)
      sf->sf5.front_winding = BRW_FRONTWINDING_CCW;
   else
      sf->sf5.front_winding = BRW_FRONTWINDING_CW;

   /* _NEW_BUFFERS
    * The viewport is inverted for rendering to a FBO, and that inverts
    * polygon front/back orientation.
    */
   sf->sf5.front_winding ^= render_to_fbo;

   /* _NEW_POLYGON */
   switch (ctx->Polygon.CullFlag ? ctx->Polygon.CullFaceMode : GL_NONE) {
   case GL_FRONT:
      sf->sf6.cull_mode = BRW_CULLMODE_FRONT;
      break;
   case GL_BACK:
      sf->sf6.cull_mode = BRW_CULLMODE_BACK;
      break;
   case GL_FRONT_AND_BACK:
      sf->sf6.cull_mode = BRW_CULLMODE_BOTH;
      break;
   case GL_NONE:
      sf->sf6.cull_mode = BRW_CULLMODE_NONE;
      break;
   default:
      assert(0);
      break;
   }

   /* _NEW_LINE */
   /* XXX use ctx->Const.Min/MaxLineWidth here */
   sf->sf6.line_width = CLAMP(ctx->Line.Width, 1.0, 5.0) * (1<<1);

   sf->sf6.line_endcap_aa_region_width = 1;
   if (ctx->Line.SmoothFlag)
      sf->sf6.aa_enable = 1;
   else if (sf->sf6.line_width <= 0x2)
       sf->sf6.line_width = 0;

   /* _NEW_BUFFERS */
   if (!render_to_fbo) {
      /* Rendering to an OpenGL window */
      sf->sf6.point_rast_rule = BRW_RASTRULE_UPPER_RIGHT;
   }
   else {
      /* If rendering to an FBO, the pixel coordinate system is
       * inverted with respect to the normal OpenGL coordinate
       * system, so BRW_RASTRULE_LOWER_RIGHT is correct.
       * But this value is listed as "Reserved, but not seen as useful"
       * in Intel documentation (page 212, "Point Rasterization Rule",
       * section 7.4 "SF Pipeline State Summary", of document
       * "Intel速 965 Express Chipset Family and Intel速 G35 Express
       * Chipset Graphics Controller Programmer's Reference Manual,
       * Volume 2: 3D/Media", Revision 1.0b as of January 2008,
       * available at
       *     http://intellinuxgraphics.org/documentation.html
       * at the time of this writing).
       *
       * It does work on at least some devices, if not all;
       * if devices that don't support it can be identified,
       * the likely failure case is that points are rasterized
       * incorrectly, which is no worse than occurs without
       * the value, so we're using it here.
       */
      sf->sf6.point_rast_rule = BRW_RASTRULE_LOWER_RIGHT;
   }
   /* XXX clamp max depends on AA vs. non-AA */

   /* _NEW_POINT */
   sf->sf7.sprite_point = ctx->Point.PointSprite;
   sf->sf7.point_size = CLAMP(rint(CLAMP(ctx->Point.Size,
					 ctx->Point.MinSize,
					 ctx->Point.MaxSize)), 1, 255) * (1<<3);
   /* _NEW_PROGRAM | _NEW_POINT */
   sf->sf7.use_point_size_state = !(ctx->VertexProgram.PointSizeEnabled ||
				    ctx->Point._Attenuated);
   sf->sf7.aa_line_distance_mode = 0;

   /* might be BRW_NEW_PRIMITIVE if we have to adjust pv for polygons:
    * _NEW_LIGHT
    */
   if (ctx->Light.ProvokingVertex != GL_FIRST_VERTEX_CONVENTION) {
      sf->sf7.trifan_pv = 2;
      sf->sf7.linestrip_pv = 1;
      sf->sf7.tristrip_pv = 2;
   } else {
      sf->sf7.trifan_pv = 1;
      sf->sf7.linestrip_pv = 0;
      sf->sf7.tristrip_pv = 0;
   }
   sf->sf7.line_last_pixel_enable = 0;

   /* Set bias for OpenGL rasterization rules:
    */
   sf->sf6.dest_org_vbias = 0x8;
   sf->sf6.dest_org_hbias = 0x8;

   /* STATE_PREFETCH command description describes this state as being
    * something loaded through the GPE (L2 ISC), so it's INSTRUCTION domain.
    */

   /* Emit SF viewport relocation */
   drm_intel_bo_emit_reloc(bo, (brw->sf.state_offset +
				offsetof(struct brw_sf_unit_state, sf5)),
			   brw->batch.bo, (brw->sf.vp_offset |
					     sf->sf5.front_winding |
					     (sf->sf5.viewport_transform << 1)),
			   I915_GEM_DOMAIN_INSTRUCTION, 0);

   brw->state.dirty.cache |= CACHE_NEW_SF_UNIT;
}

const struct brw_tracked_state brw_sf_unit = {
   .dirty = {
      .mesa  = (_NEW_POLYGON |
		_NEW_PROGRAM |
		_NEW_LIGHT |
		_NEW_LINE |
		_NEW_POINT |
		_NEW_SCISSOR |
		_NEW_BUFFERS),
      .brw   = (BRW_NEW_BATCH |
		BRW_NEW_PROGRAM_CACHE |
		BRW_NEW_URB_FENCE),
      .cache = (CACHE_NEW_SF_VP |
		CACHE_NEW_SF_PROG)
   },
   .emit = upload_sf_unit,
};
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d212 2
a213 1
      unreachable("not reached");
d217 2
a218 2
   sf->sf6.line_width =
      CLAMP(ctx->Line.Width, 1.0, ctx->Const.MaxLineWidth) * (1<<1);
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d212 1
a212 2
      assert(0);
      break;
d216 2
a217 2
   /* XXX use ctx->Const.Min/MaxLineWidth here */
   sf->sf6.line_width = CLAMP(ctx->Line.Width, 1.0, 5.0) * (1<<1);
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
   
d49 1
a49 1
   const GLfloat *v = ctx->Viewport._WindowMap.m;
d117 1
a117 1
      .mesa  = (_NEW_VIEWPORT | 
d176 1
a176 1
   sf->sf5.sf_viewport_state_offset = (brw->batch.bo->offset +
d182 1
a182 1
   if (ctx->Scissor.Enabled)
d241 1
a241 1
       * available at 
d301 1
a301 1
      .mesa  = (_NEW_POLYGON | 
d304 2
a305 2
		_NEW_LINE | 
		_NEW_POINT | 
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 3
d40 1
a40 1
#include "main/macros.h"
d44 1
a44 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d48 1
a48 1
   const GLboolean render_to_fbo = (ctx->DrawBuffer->Name != 0);
d51 2
a52 1
   sfv = brw_state_batch(brw, sizeof(*sfv), 32, &brw->sf.vp_offset);
d123 1
a123 1
   .prepare = upload_sf_vp
d128 1
a128 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d130 1
a130 1
   drm_intel_bo *bo = intel->batch.bo;
d132 1
a132 1
   bool render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
d134 2
a135 1
   sf = brw_state_batch(brw, sizeof(*sf), 64, &brw->sf.state_offset);
d151 1
a151 5

   if (intel->gen == 5)
       sf->thread3.urb_entry_read_offset = 3;
   else
       sf->thread3.urb_entry_read_offset = 1;
d163 1
a163 1
   if (intel->gen == 5)
a171 3
   if (unlikely(INTEL_DEBUG & DEBUG_SINGLE_THREAD))
      sf->thread4.max_threads = 0;

d176 1
a176 1
   sf->sf5.sf_viewport_state_offset = (intel->batch.bo->offset +
d260 1
d291 1
a291 1
			   intel->batch.bo, (brw->sf.vp_offset |
d302 1
d314 1
a314 1
   .prepare = upload_sf_unit,
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d41 2
a42 1
   struct gl_context *ctx = &brw->intel.ctx;
d44 1
a44 1
   struct brw_sf_viewport sfv;
d49 2
a50 1
   memset(&sfv, 0, sizeof(sfv));
d63 6
a68 6
   sfv.viewport.m00 = v[MAT_SX];
   sfv.viewport.m11 = v[MAT_SY] * y_scale;
   sfv.viewport.m22 = v[MAT_SZ] * depth_scale;
   sfv.viewport.m30 = v[MAT_TX];
   sfv.viewport.m31 = v[MAT_TY] * y_scale + y_bias;
   sfv.viewport.m32 = v[MAT_TZ] * depth_scale;
d90 4
a93 4
      sfv.scissor.xmin = 1;
      sfv.scissor.xmax = 0;
      sfv.scissor.ymin = 1;
      sfv.scissor.ymax = 0;
d96 4
a99 4
      sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv.scissor.ymin = ctx->DrawBuffer->_Ymin;
      sfv.scissor.ymax = ctx->DrawBuffer->_Ymax - 1;
d103 4
a106 4
      sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv.scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
      sfv.scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
d109 1
a109 2
   drm_intel_bo_unreference(brw->sf.vp_bo);
   brw->sf.vp_bo = brw_cache_data(&brw->cache, BRW_SF_VP, &sfv, sizeof(sfv));
d117 1
a117 1
      .brw   = 0,
d123 1
a123 19
struct brw_sf_unit_key {
   unsigned int total_grf;
   unsigned int urb_entry_read_length;

   unsigned int nr_urb_entries, urb_size, sfsize;

   GLenum front_face, cull_face;
   unsigned pv_first:1;
   unsigned scissor:1;
   unsigned line_smooth:1;
   unsigned point_sprite:1;
   unsigned use_vs_point_size:1;
   unsigned render_to_fbo:1;
   float line_width;
   float point_size;
};

static void
sf_unit_populate_key(struct brw_context *brw, struct brw_sf_unit_key *key)
d125 6
a130 6
   struct gl_context *ctx = &brw->intel.ctx;
   memset(key, 0, sizeof(*key));

   /* CACHE_NEW_SF_PROG */
   key->total_grf = brw->sf.prog_data->total_grf;
   key->urb_entry_read_length = brw->sf.prog_data->urb_read_length;
d132 1
a132 26
   /* BRW_NEW_URB_FENCE */
   key->nr_urb_entries = brw->urb.nr_sf_entries;
   key->urb_size = brw->urb.vsize;
   key->sfsize = brw->urb.sfsize;

   key->scissor = ctx->Scissor.Enabled;
   key->front_face = ctx->Polygon.FrontFace;

   if (ctx->Polygon.CullFlag)
      key->cull_face = ctx->Polygon.CullFaceMode;
   else
      key->cull_face = GL_NONE;

   key->line_width = ctx->Line.Width;
   key->line_smooth = ctx->Line.SmoothFlag;

   key->point_sprite = ctx->Point.PointSprite;
   key->point_size = CLAMP(ctx->Point.Size, ctx->Point.MinSize, ctx->Point.MaxSize);
   key->use_vs_point_size = (ctx->VertexProgram.PointSizeEnabled ||
			     ctx->Point._Attenuated);

   /* _NEW_LIGHT */
   key->pv_first = (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION);

   key->render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
}
d134 1
a134 9
static drm_intel_bo *
sf_unit_create_from_key(struct brw_context *brw, struct brw_sf_unit_key *key,
			drm_intel_bo **reloc_bufs)
{
   struct intel_context *intel = &brw->intel;
   struct brw_sf_unit_state sf;
   drm_intel_bo *bo;
   int chipset_max_threads;
   memset(&sf, 0, sizeof(sf));
d136 8
a143 2
   sf.thread0.grf_reg_count = ALIGN(key->total_grf, 16) / 16 - 1;
   sf.thread0.kernel_start_pointer = brw->sf.prog_bo->offset >> 6; /* reloc */
d145 1
a145 1
   sf.thread1.floating_point_mode = BRW_FLOATING_POINT_NON_IEEE_754;
d147 1
a147 1
   sf.thread3.dispatch_grf_start_reg = 3;
d150 1
a150 1
       sf.thread3.urb_entry_read_offset = 3;
d152 1
a152 1
       sf.thread3.urb_entry_read_offset = 1;
d154 2
a155 1
   sf.thread3.urb_entry_read_length = key->urb_entry_read_length;
d157 3
a159 2
   sf.thread4.nr_urb_entries = key->nr_urb_entries;
   sf.thread4.urb_entry_allocation_size = key->sfsize - 1;
d169 3
a171 1
   sf.thread4.max_threads = MIN2(chipset_max_threads, key->nr_urb_entries) - 1;
d174 1
a174 1
      sf.thread4.max_threads = 0;
d177 1
a177 1
      sf.thread4.stats_enable = 1;
d180 2
a181 1
   sf.sf5.sf_viewport_state_offset = brw->sf.vp_bo->offset >> 5; /* reloc */
d183 1
a183 1
   sf.sf5.viewport_transform = 1;
d186 2
a187 2
   if (key->scissor)
      sf.sf6.scissor = 1;
d190 2
a191 2
   if (key->front_face == GL_CCW)
      sf.sf5.front_winding = BRW_FRONTWINDING_CCW;
d193 1
a193 1
      sf.sf5.front_winding = BRW_FRONTWINDING_CW;
d195 2
a196 1
   /* The viewport is inverted for rendering to a FBO, and that inverts
d199 1
a199 1
   sf.sf5.front_winding ^= key->render_to_fbo;
d201 2
a202 1
   switch (key->cull_face) {
d204 1
a204 1
      sf.sf6.cull_mode = BRW_CULLMODE_FRONT;
d207 1
a207 1
      sf.sf6.cull_mode = BRW_CULLMODE_BACK;
d210 1
a210 1
      sf.sf6.cull_mode = BRW_CULLMODE_BOTH;
d213 1
a213 1
      sf.sf6.cull_mode = BRW_CULLMODE_NONE;
d222 1
a222 1
   sf.sf6.line_width = CLAMP(key->line_width, 1.0, 5.0) * (1<<1);
d224 5
a228 5
   sf.sf6.line_endcap_aa_region_width = 1;
   if (key->line_smooth)
      sf.sf6.aa_enable = 1;
   else if (sf.sf6.line_width <= 0x2)
       sf.sf6.line_width = 0;
d231 1
a231 2
   key->render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
   if (!key->render_to_fbo) {
d233 1
a233 1
      sf.sf6.point_rast_rule = BRW_RASTRULE_UPPER_RIGHT;
d255 1
a255 1
      sf.sf6.point_rast_rule = BRW_RASTRULE_LOWER_RIGHT;
d260 7
a266 4
   sf.sf7.sprite_point = key->point_sprite;
   sf.sf7.point_size = CLAMP(rint(key->point_size), 1, 255) * (1<<3);
   sf.sf7.use_point_size_state = !key->use_vs_point_size;
   sf.sf7.aa_line_distance_mode = 0;
d269 1
d271 4
a274 4
   if (!key->pv_first) {
      sf.sf7.trifan_pv = 2;
      sf.sf7.linestrip_pv = 1;
      sf.sf7.tristrip_pv = 2;
d276 3
a278 3
      sf.sf7.trifan_pv = 1;
      sf.sf7.linestrip_pv = 0;
      sf.sf7.tristrip_pv = 0;
d280 1
a280 1
   sf.sf7.line_last_pixel_enable = 0;
d284 2
a285 7
   sf.sf6.dest_org_vbias = 0x8;
   sf.sf6.dest_org_hbias = 0x8;

   bo = brw_upload_cache(&brw->cache, BRW_SF_UNIT,
			 key, sizeof(*key),
			 reloc_bufs, 2,
			 &sf, sizeof(sf));
a289 4
   /* Emit SF program relocation */
   drm_intel_bo_emit_reloc(bo, offsetof(struct brw_sf_unit_state, thread0),
			   brw->sf.prog_bo, sf.thread0.grf_reg_count << 1,
			   I915_GEM_DOMAIN_INSTRUCTION, 0);
d292 5
a296 3
   drm_intel_bo_emit_reloc(bo, offsetof(struct brw_sf_unit_state, sf5),
			   brw->sf.vp_bo, (sf.sf5.front_winding |
					   (sf.sf5.viewport_transform << 1)),
d299 1
a299 21
   return bo;
}

static void upload_sf_unit( struct brw_context *brw )
{
   struct brw_sf_unit_key key;
   drm_intel_bo *reloc_bufs[2];

   sf_unit_populate_key(brw, &key);

   reloc_bufs[0] = brw->sf.prog_bo;
   reloc_bufs[1] = brw->sf.vp_bo;

   drm_intel_bo_unreference(brw->sf.state_bo);
   brw->sf.state_bo = brw_search_cache(&brw->cache, BRW_SF_UNIT,
				       &key, sizeof(key),
				       reloc_bufs, 2,
				       NULL);
   if (brw->sf.state_bo == NULL) {
      brw->sf.state_bo = sf_unit_create_from_key(brw, &key, reloc_bufs);
   }
d310 3
a312 1
      .brw   = BRW_NEW_URB_FENCE,
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d41 1
a41 1
   GLcontext *ctx = &brw->intel.ctx;
d107 2
a108 3
   dri_bo_unreference(brw->sf.vp_bo);
   brw->sf.vp_bo = brw_cache_data(&brw->cache, BRW_SF_VP, &sfv, sizeof(sfv),
				  NULL, 0);
d133 1
a133 1
   unsigned point_attenuated:1;
d142 1
a142 1
   GLcontext *ctx = &brw->intel.ctx;
d167 2
a168 1
   key->point_attenuated = ctx->Point._Attenuated;
d176 1
a176 1
static dri_bo *
d178 1
a178 1
			dri_bo **reloc_bufs)
d182 1
a182 1
   dri_bo *bo;
d213 1
a213 1
   if (INTEL_DEBUG & DEBUG_SINGLE_THREAD)
d216 1
a216 1
   if (INTEL_DEBUG & DEBUG_STATS)
d300 1
a300 1
   sf.sf7.use_point_size_state = !key->point_attenuated;
d330 3
a332 5
   dri_bo_emit_reloc(bo,
		     I915_GEM_DOMAIN_INSTRUCTION, 0,
		     sf.thread0.grf_reg_count << 1,
		     offsetof(struct brw_sf_unit_state, thread0),
		     brw->sf.prog_bo);
d335 4
a338 5
   dri_bo_emit_reloc(bo,
		     I915_GEM_DOMAIN_INSTRUCTION, 0,
		     sf.sf5.front_winding | (sf.sf5.viewport_transform << 1),
		     offsetof(struct brw_sf_unit_state, sf5),
		     brw->sf.vp_bo);
d346 1
a346 1
   dri_bo *reloc_bufs[2];
d353 1
a353 1
   dri_bo_unreference(brw->sf.state_bo);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a37 1
#include "intel_fbo.h"
d45 2
d50 1
a50 1
   if (intel_rendering_to_texture(ctx)) {
a60 2
   const GLfloat *v = ctx->Viewport._WindowMap.m;

d68 3
a70 1
   /* _NEW_SCISSOR */
d72 3
a74 3
   /* The scissor only needs to handle the intersection of drawable and
    * scissor rect.  Clipping to the boundaries of static shared buffers
    * for front/back/depth is covered by looping over cliprects in brw_draw.c.
d79 14
a92 1
   if (intel_rendering_to_texture(ctx)) {
d108 2
a109 1
   brw->sf.vp_bo = brw_cache_data( &brw->cache, BRW_SF_VP, &sfv, NULL, 0 );
d115 2
a116 1
		_NEW_SCISSOR),
d130 6
a135 1
   GLboolean scissor, line_smooth, point_sprite, point_attenuated;
a137 1
   GLboolean render_to_texture;
d167 1
a167 1
   key->point_size = ctx->Point.Size;
d170 4
a173 1
   key->render_to_texture = intel_rendering_to_texture(&brw->intel.ctx);
d180 1
d183 1
a183 1

d192 6
a197 1
   sf.thread3.urb_entry_read_offset = 1;
d202 10
a211 2
   /* Each SF thread produces 1 PUE, and there can be up to 24 threads */
   sf.thread4.max_threads = MIN2(24, key->nr_urb_entries) - 1;
d234 1
a234 1
   /* The viewport is inverted for rendering to texture, and that inverts
d237 1
a237 1
   sf.sf5.front_winding ^= key->render_to_texture;
d267 28
a294 2
   /* _NEW_POINT */
   sf.sf6.point_rast_rule = BRW_RASTRULE_UPPER_RIGHT;	/* opengl conventions */
d297 1
d305 9
a313 3
   sf.sf7.trifan_pv = 2;
   sf.sf7.linestrip_pv = 1;
   sf.sf7.tristrip_pv = 2;
d324 1
a324 2
			 &sf, sizeof(sf),
			 NULL, NULL);
d326 3
d369 1
d372 2
a373 1
		_NEW_SCISSOR),
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d37 1
a37 1
#include "macros.h"
d40 1
a40 1
static int upload_sf_vp(struct brw_context *brw)
a44 2
   struct intel_renderbuffer *irb =
      intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);
d49 5
a53 10
   if (ctx->DrawBuffer->Name) {
      /* User-created FBO */
      if (irb && !irb->RenderToTexture) {
	 y_scale = -1.0;
	 y_bias = ctx->DrawBuffer->Height;
      } else {
	 y_scale = 1.0;
	 y_bias = 0;
      }
   } else {
d58 1
a58 1
   /* _NEW_VIEWPORT, BRW_NEW_METAOPS */
d60 1
a60 2
   if (!brw->metaops.active) {
      const GLfloat *v = ctx->Viewport._WindowMap.m;
d62 6
a67 14
      sfv.viewport.m00 = v[MAT_SX];
      sfv.viewport.m11 = v[MAT_SY] * y_scale;
      sfv.viewport.m22 = v[MAT_SZ] * depth_scale;
      sfv.viewport.m30 = v[MAT_TX];
      sfv.viewport.m31 = v[MAT_TY] * y_scale + y_bias;
      sfv.viewport.m32 = v[MAT_TZ] * depth_scale;
   } else {
      sfv.viewport.m00 =   1;
      sfv.viewport.m11 = - 1;
      sfv.viewport.m22 =   1;
      sfv.viewport.m30 =   0;
      sfv.viewport.m31 =   ctx->DrawBuffer->Height;
      sfv.viewport.m32 =   0;
   }
d78 14
a91 4
   sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
   sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
   sfv.scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
   sfv.scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
a94 2

   return dri_bufmgr_check_aperture_space(brw->sf.vp_bo);
d101 1
a101 1
      .brw   = BRW_NEW_METAOPS,
d117 1
d123 1
d135 2
a136 2
   key->scissor = brw->attribs.Scissor->Enabled;
   key->front_face = brw->attribs.Polygon->FrontFace;
d138 2
a139 2
   if (brw->attribs.Polygon->CullFlag)
      key->cull_face = brw->attribs.Polygon->CullFaceMode;
d143 2
a144 2
   key->line_width = brw->attribs.Line->Width;
   key->line_smooth = brw->attribs.Line->SmoothFlag;
d146 5
a150 3
   key->point_sprite = brw->attribs.Point->PointSprite;
   key->point_size = brw->attribs.Point->Size;
   key->point_attenuated = brw->attribs.Point->_Attenuated;
d173 2
a174 1
   sf.thread4.max_threads = MIN2(12, key->nr_urb_entries / 2) - 1;
d197 5
d258 5
a262 5
   dri_emit_reloc(bo,
		  DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
		  sf.thread0.grf_reg_count << 1,
		  offsetof(struct brw_sf_unit_state, thread0),
		  brw->sf.prog_bo);
d265 5
a269 5
   dri_emit_reloc(bo,
		  DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
		  sf.sf5.front_winding | (sf.sf5.viewport_transform << 1),
		  offsetof(struct brw_sf_unit_state, sf5),
		  brw->sf.vp_bo);
d274 1
a274 1
static int upload_sf_unit( struct brw_context *brw )
a277 1
   int ret = 0;
a291 9

   if (reloc_bufs[0])
     ret |= dri_bufmgr_check_aperture_space(reloc_bufs[0]);

   if (reloc_bufs[1])
     ret |= dri_bufmgr_check_aperture_space(reloc_bufs[1]);

   ret |= dri_bufmgr_check_aperture_space(brw->sf.state_bo);
   return ret;
d300 1
a300 2
      .brw   = (BRW_NEW_URB_FENCE |
		BRW_NEW_METAOPS),
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d38 1
d40 1
a40 1
static void upload_sf_vp(struct brw_context *brw)
d42 2
d45 3
d50 9
a58 22
   
   if (brw->intel.driDrawable) 
   {
      /* _NEW_VIEWPORT, BRW_NEW_METAOPS */

      if (!brw->metaops.active) {
	 const GLfloat *v = brw->intel.ctx.Viewport._WindowMap.m;
	 
	 sfv.viewport.m00 =   v[MAT_SX];
	 sfv.viewport.m11 = - v[MAT_SY];
	 sfv.viewport.m22 =   v[MAT_SZ] * brw->intel.depth_scale;
	 sfv.viewport.m30 =   v[MAT_TX];
	 sfv.viewport.m31 = - v[MAT_TY] + brw->intel.driDrawable->h;
	 sfv.viewport.m32 =   v[MAT_TZ] * brw->intel.depth_scale;
      }
      else {
	 sfv.viewport.m00 =   1;
	 sfv.viewport.m11 = - 1;
	 sfv.viewport.m22 =   1;
	 sfv.viewport.m30 =   0;
	 sfv.viewport.m31 =   brw->intel.driDrawable->h;
	 sfv.viewport.m32 =   0;
d60 3
d65 18
a82 29
   /* XXX: what state for this? */
   if (brw->intel.driDrawable)
   {
      intelScreenPrivate *screen = brw->intel.intelScreen;
      /* _NEW_SCISSOR */
      GLint x = brw->attribs.Scissor->X;
      GLint y = brw->attribs.Scissor->Y;
      GLuint w = brw->attribs.Scissor->Width;
      GLuint h = brw->attribs.Scissor->Height;

      GLint x1 = x;
      GLint y1 = brw->intel.driDrawable->h - (y + h);
      GLint x2 = x + w - 1;
      GLint y2 = y1 + h - 1;

      if (x1 < 0) x1 = 0;
      if (y1 < 0) y1 = 0;
      if (x2 < 0) x2 = 0;
      if (y2 < 0) y2 = 0;

      if (x2 >= screen->width) x2 = screen->width-1;
      if (y2 >= screen->height) y2 = screen->height-1;
      if (x1 >= screen->width) x1 = screen->width-1;
      if (y1 >= screen->height) y1 = screen->height-1;
      
      sfv.scissor.xmin = x1;
      sfv.scissor.xmax = x2;
      sfv.scissor.ymin = y1;
      sfv.scissor.ymax = y2;
d85 18
a102 1
   brw->sf.vp_gs_offset = brw_cache_data( &brw->cache[BRW_SF_VP], &sfv );
d112 1
a112 1
   .update = upload_sf_vp
d115 11
d127 29
d157 3
a159 1
static void upload_sf_unit( struct brw_context *brw )
d162 2
d166 2
a167 4
   /* CACHE_NEW_SF_PROG */
   sf.thread0.grf_reg_count = ((brw->sf.prog_data->total_grf-1) & ~15) / 16;
   sf.thread0.kernel_start_pointer = brw->sf.prog_gs_offset >> 6;
   sf.thread3.urb_entry_read_length = brw->sf.prog_data->urb_read_length;
d170 1
d173 1
d175 3
a177 4
   /* BRW_NEW_URB_FENCE */
   sf.thread4.nr_urb_entries = brw->urb.nr_sf_entries;
   sf.thread4.urb_entry_allocation_size = brw->urb.sfsize - 1;
   sf.thread4.max_threads = MIN2(12, brw->urb.nr_sf_entries / 2) - 1;
d180 1
a180 1
      sf.thread4.max_threads = 0; 
d183 1
a183 1
      sf.thread4.stats_enable = 1; 
d186 2
a187 2
   sf.sf5.sf_viewport_state_offset = brw->sf.vp_gs_offset >> 5;
   
d189 1
a189 1
   
d191 2
a192 2
   if (brw->attribs.Scissor->Enabled) 
      sf.sf6.scissor = 1;  
d195 1
a195 1
   if (brw->attribs.Polygon->FrontFace == GL_CCW)
d200 16
a215 15
   if (brw->attribs.Polygon->CullFlag) {
      switch (brw->attribs.Polygon->CullFaceMode) {
      case GL_FRONT:
	 sf.sf6.cull_mode = BRW_CULLMODE_FRONT;
	 break;
      case GL_BACK:
	 sf.sf6.cull_mode = BRW_CULLMODE_BACK;
	 break;
      case GL_FRONT_AND_BACK:
	 sf.sf6.cull_mode = BRW_CULLMODE_BOTH;
	 break;
      default:
	 assert(0);
	 break;
      }
a216 3
   else
      sf.sf6.cull_mode = BRW_CULLMODE_NONE;
      
d219 2
a220 1
   sf.sf6.line_width = brw->attribs.Line->_Width * (1<<1);
d223 1
a223 1
   if (brw->attribs.Line->SmoothFlag)
d225 2
a226 2
   else if (sf.sf6.line_width <= 0x2) 
       sf.sf6.line_width = 0; 
d229 6
a234 3
   sf.sf6.point_rast_rule = 1;	/* opengl conventions */
   sf.sf7.point_size = brw->attribs.Point->_Size * (1<<3);
   sf.sf7.use_point_size_state = !brw->attribs.Point->_Attenuated;
d249 21
a269 1
   brw->sf.state_gs_offset = brw_cache_data( &brw->cache[BRW_SF_UNIT], &sf );
d272 29
d313 1
a313 1
   .update = upload_sf_unit
a314 2


@


1.1
log
@Initial revision
@
text
@d188 2
a189 1
      
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d37 1
a37 1
#include "main/macros.h"
a40 2
   struct gl_context *ctx = &brw->intel.ctx;
   const GLfloat depth_scale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
a41 3
   GLfloat y_scale, y_bias;
   const GLboolean render_to_fbo = (ctx->DrawBuffer->Name != 0);
   const GLfloat *v = ctx->Viewport._WindowMap.m;
d44 54
a97 8

   if (render_to_fbo) {
      y_scale = 1.0;
      y_bias = 0;
   }
   else {
      y_scale = -1.0;
      y_bias = ctx->DrawBuffer->Height;
d100 1
a100 50
   /* _NEW_VIEWPORT */

   sfv.viewport.m00 = v[MAT_SX];
   sfv.viewport.m11 = v[MAT_SY] * y_scale;
   sfv.viewport.m22 = v[MAT_SZ] * depth_scale;
   sfv.viewport.m30 = v[MAT_TX];
   sfv.viewport.m31 = v[MAT_TY] * y_scale + y_bias;
   sfv.viewport.m32 = v[MAT_TZ] * depth_scale;

   /* _NEW_SCISSOR | _NEW_BUFFERS | _NEW_VIEWPORT
    * for DrawBuffer->_[XY]{min,max}
    */

   /* The scissor only needs to handle the intersection of drawable
    * and scissor rect, since there are no longer cliprects for shared
    * buffers with DRI2.
    *
    * Note that the hardware's coordinates are inclusive, while Mesa's min is
    * inclusive but max is exclusive.
    */

   if (ctx->DrawBuffer->_Xmin == ctx->DrawBuffer->_Xmax ||
       ctx->DrawBuffer->_Ymin == ctx->DrawBuffer->_Ymax) {
      /* If the scissor was out of bounds and got clamped to 0
       * width/height at the bounds, the subtraction of 1 from
       * maximums could produce a negative number and thus not clip
       * anything.  Instead, just provide a min > max scissor inside
       * the bounds, which produces the expected no rendering.
       */
      sfv.scissor.xmin = 1;
      sfv.scissor.xmax = 0;
      sfv.scissor.ymin = 1;
      sfv.scissor.ymax = 0;
   } else if (render_to_fbo) {
      /* texmemory: Y=0=bottom */
      sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv.scissor.ymin = ctx->DrawBuffer->_Ymin;
      sfv.scissor.ymax = ctx->DrawBuffer->_Ymax - 1;
   }
   else {
      /* memory: Y=0=top */
      sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv.scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
      sfv.scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
   }

   drm_intel_bo_unreference(brw->sf.vp_bo);
   brw->sf.vp_bo = brw_cache_data(&brw->cache, BRW_SF_VP, &sfv, sizeof(sfv));
d106 2
a107 3
		_NEW_SCISSOR |
		_NEW_BUFFERS),
      .brw   = 0,
d110 1
a110 1
   .prepare = upload_sf_vp
a112 16
struct brw_sf_unit_key {
   unsigned int total_grf;
   unsigned int urb_entry_read_length;

   unsigned int nr_urb_entries, urb_size, sfsize;

   GLenum front_face, cull_face;
   unsigned pv_first:1;
   unsigned scissor:1;
   unsigned line_smooth:1;
   unsigned point_sprite:1;
   unsigned use_vs_point_size:1;
   unsigned render_to_fbo:1;
   float line_width;
   float point_size;
};
a113 5
static void
sf_unit_populate_key(struct brw_context *brw, struct brw_sf_unit_key *key)
{
   struct gl_context *ctx = &brw->intel.ctx;
   memset(key, 0, sizeof(*key));
d115 1
a115 34
   /* CACHE_NEW_SF_PROG */
   key->total_grf = brw->sf.prog_data->total_grf;
   key->urb_entry_read_length = brw->sf.prog_data->urb_read_length;

   /* BRW_NEW_URB_FENCE */
   key->nr_urb_entries = brw->urb.nr_sf_entries;
   key->urb_size = brw->urb.vsize;
   key->sfsize = brw->urb.sfsize;

   key->scissor = ctx->Scissor.Enabled;
   key->front_face = ctx->Polygon.FrontFace;

   if (ctx->Polygon.CullFlag)
      key->cull_face = ctx->Polygon.CullFaceMode;
   else
      key->cull_face = GL_NONE;

   key->line_width = ctx->Line.Width;
   key->line_smooth = ctx->Line.SmoothFlag;

   key->point_sprite = ctx->Point.PointSprite;
   key->point_size = CLAMP(ctx->Point.Size, ctx->Point.MinSize, ctx->Point.MaxSize);
   key->use_vs_point_size = (ctx->VertexProgram.PointSizeEnabled ||
			     ctx->Point._Attenuated);

   /* _NEW_LIGHT */
   key->pv_first = (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION);

   key->render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
}

static drm_intel_bo *
sf_unit_create_from_key(struct brw_context *brw, struct brw_sf_unit_key *key,
			drm_intel_bo **reloc_bufs)
a116 1
   struct intel_context *intel = &brw->intel;
a117 2
   drm_intel_bo *bo;
   int chipset_max_threads;
d120 4
a123 2
   sf.thread0.grf_reg_count = ALIGN(key->total_grf, 16) / 16 - 1;
   sf.thread0.kernel_start_pointer = brw->sf.prog_bo->offset >> 6; /* reloc */
a125 1

d127 1
d129 4
a132 4
   if (intel->gen == 5)
       sf.thread3.urb_entry_read_offset = 3;
   else
       sf.thread3.urb_entry_read_offset = 1;
d134 2
a135 1
   sf.thread3.urb_entry_read_length = key->urb_entry_read_length;
d137 2
a138 18
   sf.thread4.nr_urb_entries = key->nr_urb_entries;
   sf.thread4.urb_entry_allocation_size = key->sfsize - 1;

   /* Each SF thread produces 1 PUE, and there can be up to 24 (Pre-Ironlake) or
    * 48 (Ironlake) threads.
    */
   if (intel->gen == 5)
      chipset_max_threads = 48;
   else
      chipset_max_threads = 24;

   sf.thread4.max_threads = MIN2(chipset_max_threads, key->nr_urb_entries) - 1;

   if (unlikely(INTEL_DEBUG & DEBUG_SINGLE_THREAD))
      sf.thread4.max_threads = 0;

   if (unlikely(INTEL_DEBUG & DEBUG_STATS))
      sf.thread4.stats_enable = 1;
d141 2
a142 2
   sf.sf5.sf_viewport_state_offset = brw->sf.vp_bo->offset >> 5; /* reloc */

d144 1
a144 1

d146 2
a147 2
   if (key->scissor)
      sf.sf6.scissor = 1;
d150 1
a150 1
   if (key->front_face == GL_CCW)
d155 17
a171 16
   /* The viewport is inverted for rendering to a FBO, and that inverts
    * polygon front/back orientation.
    */
   sf.sf5.front_winding ^= key->render_to_fbo;

   switch (key->cull_face) {
   case GL_FRONT:
      sf.sf6.cull_mode = BRW_CULLMODE_FRONT;
      break;
   case GL_BACK:
      sf.sf6.cull_mode = BRW_CULLMODE_BACK;
      break;
   case GL_FRONT_AND_BACK:
      sf.sf6.cull_mode = BRW_CULLMODE_BOTH;
      break;
   case GL_NONE:
d173 1
a173 5
      break;
   default:
      assert(0);
      break;
   }
d176 1
a176 2
   /* XXX use ctx->Const.Min/MaxLineWidth here */
   sf.sf6.line_width = CLAMP(key->line_width, 1.0, 5.0) * (1<<1);
d179 1
a179 1
   if (key->line_smooth)
d181 2
a182 32
   else if (sf.sf6.line_width <= 0x2)
       sf.sf6.line_width = 0;

   /* _NEW_BUFFERS */
   key->render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
   if (!key->render_to_fbo) {
      /* Rendering to an OpenGL window */
      sf.sf6.point_rast_rule = BRW_RASTRULE_UPPER_RIGHT;
   }
   else {
      /* If rendering to an FBO, the pixel coordinate system is
       * inverted with respect to the normal OpenGL coordinate
       * system, so BRW_RASTRULE_LOWER_RIGHT is correct.
       * But this value is listed as "Reserved, but not seen as useful"
       * in Intel documentation (page 212, "Point Rasterization Rule",
       * section 7.4 "SF Pipeline State Summary", of document
       * "Intel速 965 Express Chipset Family and Intel速 G35 Express
       * Chipset Graphics Controller Programmer's Reference Manual,
       * Volume 2: 3D/Media", Revision 1.0b as of January 2008,
       * available at 
       *     http://intellinuxgraphics.org/documentation.html
       * at the time of this writing).
       *
       * It does work on at least some devices, if not all;
       * if devices that don't support it can be identified,
       * the likely failure case is that points are rasterized
       * incorrectly, which is no worse than occurs without
       * the value, so we're using it here.
       */
      sf.sf6.point_rast_rule = BRW_RASTRULE_LOWER_RIGHT;
   }
   /* XXX clamp max depends on AA vs. non-AA */
d185 4
a188 5
   sf.sf7.sprite_point = key->point_sprite;
   sf.sf7.point_size = CLAMP(rint(key->point_size), 1, 255) * (1<<3);
   sf.sf7.use_point_size_state = !key->use_vs_point_size;
   sf.sf7.aa_line_distance_mode = 0;

d191 3
a193 9
   if (!key->pv_first) {
      sf.sf7.trifan_pv = 2;
      sf.sf7.linestrip_pv = 1;
      sf.sf7.tristrip_pv = 2;
   } else {
      sf.sf7.trifan_pv = 1;
      sf.sf7.linestrip_pv = 0;
      sf.sf7.tristrip_pv = 0;
   }
d201 1
a201 20
   bo = brw_upload_cache(&brw->cache, BRW_SF_UNIT,
			 key, sizeof(*key),
			 reloc_bufs, 2,
			 &sf, sizeof(sf));

   /* STATE_PREFETCH command description describes this state as being
    * something loaded through the GPE (L2 ISC), so it's INSTRUCTION domain.
    */
   /* Emit SF program relocation */
   drm_intel_bo_emit_reloc(bo, offsetof(struct brw_sf_unit_state, thread0),
			   brw->sf.prog_bo, sf.thread0.grf_reg_count << 1,
			   I915_GEM_DOMAIN_INSTRUCTION, 0);

   /* Emit SF viewport relocation */
   drm_intel_bo_emit_reloc(bo, offsetof(struct brw_sf_unit_state, sf5),
			   brw->sf.vp_bo, (sf.sf5.front_winding |
					   (sf.sf5.viewport_transform << 1)),
			   I915_GEM_DOMAIN_INSTRUCTION, 0);

   return bo;
a203 19
static void upload_sf_unit( struct brw_context *brw )
{
   struct brw_sf_unit_key key;
   drm_intel_bo *reloc_bufs[2];

   sf_unit_populate_key(brw, &key);

   reloc_bufs[0] = brw->sf.prog_bo;
   reloc_bufs[1] = brw->sf.vp_bo;

   drm_intel_bo_unreference(brw->sf.state_bo);
   brw->sf.state_bo = brw_search_cache(&brw->cache, BRW_SF_UNIT,
				       &key, sizeof(key),
				       reloc_bufs, 2,
				       NULL);
   if (brw->sf.state_bo == NULL) {
      brw->sf.state_bo = sf_unit_create_from_key(brw, &key, reloc_bufs);
   }
}
a207 1
		_NEW_LIGHT |
d210 3
a212 3
		_NEW_SCISSOR |
		_NEW_BUFFERS),
      .brw   = BRW_NEW_URB_FENCE,
d216 1
a216 1
   .prepare = upload_sf_unit,
d218 2
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@a33 3
#include "main/mtypes.h"
#include "main/macros.h"
#include "main/fbobject.h"
d37 1
a37 1
#include "brw_sf.h"
d41 1
a41 1
   struct gl_context *ctx = &brw->ctx;
d43 1
a43 1
   struct brw_sf_viewport *sfv;
d45 1
a45 1
   const bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
d48 1
a48 3
   sfv = brw_state_batch(brw, AUB_TRACE_SF_VP_STATE,
			 sizeof(*sfv), 32, &brw->sf.vp_offset);
   memset(sfv, 0, sizeof(*sfv));
d61 6
a66 6
   sfv->viewport.m00 = v[MAT_SX];
   sfv->viewport.m11 = v[MAT_SY] * y_scale;
   sfv->viewport.m22 = v[MAT_SZ] * depth_scale;
   sfv->viewport.m30 = v[MAT_TX];
   sfv->viewport.m31 = v[MAT_TY] * y_scale + y_bias;
   sfv->viewport.m32 = v[MAT_TZ] * depth_scale;
d88 4
a91 4
      sfv->scissor.xmin = 1;
      sfv->scissor.xmax = 0;
      sfv->scissor.ymin = 1;
      sfv->scissor.ymax = 0;
d94 4
a97 4
      sfv->scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv->scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv->scissor.ymin = ctx->DrawBuffer->_Ymin;
      sfv->scissor.ymax = ctx->DrawBuffer->_Ymax - 1;
d101 4
a104 4
      sfv->scissor.xmin = ctx->DrawBuffer->_Xmin;
      sfv->scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
      sfv->scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
      sfv->scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
d107 2
a108 1
   brw->state.dirty.cache |= CACHE_NEW_SF_VP;
d116 1
a116 1
      .brw   = BRW_NEW_BATCH,
d119 1
a119 1
   .emit = upload_sf_vp
d122 57
a178 1
static void upload_sf_unit( struct brw_context *brw )
d180 3
a182 3
   struct gl_context *ctx = &brw->ctx;
   struct brw_sf_unit_state *sf;
   drm_intel_bo *bo = brw->batch.bo;
d184 1
a184 1
   bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
d186 2
a187 2
   sf = brw_state_batch(brw, AUB_TRACE_SF_STATE,
			sizeof(*sf), 64, &brw->sf.state_offset);
d189 1
a189 1
   memset(sf, 0, sizeof(*sf));
d191 1
a191 8
   /* BRW_NEW_PROGRAM_CACHE | CACHE_NEW_SF_PROG */
   sf->thread0.grf_reg_count = ALIGN(brw->sf.prog_data->total_grf, 16) / 16 - 1;
   sf->thread0.kernel_start_pointer =
      brw_program_reloc(brw,
			brw->sf.state_offset +
			offsetof(struct brw_sf_unit_state, thread0),
			brw->sf.prog_offset +
			(sf->thread0.grf_reg_count << 1)) >> 6;
d193 4
a196 1
   sf->thread1.floating_point_mode = BRW_FLOATING_POINT_NON_IEEE_754;
d198 1
a198 2
   sf->thread3.dispatch_grf_start_reg = 3;
   sf->thread3.urb_entry_read_offset = BRW_SF_URB_ENTRY_READ_OFFSET;
d200 2
a201 6
   /* CACHE_NEW_SF_PROG */
   sf->thread3.urb_entry_read_length = brw->sf.prog_data->urb_read_length;

   /* BRW_NEW_URB_FENCE */
   sf->thread4.nr_urb_entries = brw->urb.nr_sf_entries;
   sf->thread4.urb_entry_allocation_size = brw->urb.sfsize - 1;
d206 1
a206 1
   if (brw->gen == 5)
d211 4
a214 3
   /* BRW_NEW_URB_FENCE */
   sf->thread4.max_threads = MIN2(chipset_max_threads,
				  brw->urb.nr_sf_entries) - 1;
d217 1
a217 1
      sf->thread4.stats_enable = 1;
d220 1
a220 2
   sf->sf5.sf_viewport_state_offset = (brw->batch.bo->offset +
				       brw->sf.vp_offset) >> 5; /* reloc */
d222 1
a222 1
   sf->sf5.viewport_transform = 1;
d225 2
a226 2
   if (ctx->Scissor.Enabled)
      sf->sf6.scissor = 1;
d229 2
a230 2
   if (ctx->Polygon.FrontFace == GL_CCW)
      sf->sf5.front_winding = BRW_FRONTWINDING_CCW;
d232 1
a232 1
      sf->sf5.front_winding = BRW_FRONTWINDING_CW;
d234 1
a234 2
   /* _NEW_BUFFERS
    * The viewport is inverted for rendering to a FBO, and that inverts
d237 1
a237 1
   sf->sf5.front_winding ^= render_to_fbo;
d239 1
a239 2
   /* _NEW_POLYGON */
   switch (ctx->Polygon.CullFlag ? ctx->Polygon.CullFaceMode : GL_NONE) {
d241 1
a241 1
      sf->sf6.cull_mode = BRW_CULLMODE_FRONT;
d244 1
a244 1
      sf->sf6.cull_mode = BRW_CULLMODE_BACK;
d247 1
a247 1
      sf->sf6.cull_mode = BRW_CULLMODE_BOTH;
d250 1
a250 1
      sf->sf6.cull_mode = BRW_CULLMODE_NONE;
d259 1
a259 1
   sf->sf6.line_width = CLAMP(ctx->Line.Width, 1.0, 5.0) * (1<<1);
d261 5
a265 5
   sf->sf6.line_endcap_aa_region_width = 1;
   if (ctx->Line.SmoothFlag)
      sf->sf6.aa_enable = 1;
   else if (sf->sf6.line_width <= 0x2)
       sf->sf6.line_width = 0;
d268 2
a269 1
   if (!render_to_fbo) {
d271 1
a271 1
      sf->sf6.point_rast_rule = BRW_RASTRULE_UPPER_RIGHT;
d293 1
a293 1
      sf->sf6.point_rast_rule = BRW_RASTRULE_LOWER_RIGHT;
d298 4
a301 8
   sf->sf7.sprite_point = ctx->Point.PointSprite;
   sf->sf7.point_size = CLAMP(rint(CLAMP(ctx->Point.Size,
					 ctx->Point.MinSize,
					 ctx->Point.MaxSize)), 1, 255) * (1<<3);
   /* _NEW_PROGRAM | _NEW_POINT */
   sf->sf7.use_point_size_state = !(ctx->VertexProgram.PointSizeEnabled ||
				    ctx->Point._Attenuated);
   sf->sf7.aa_line_distance_mode = 0;
a303 1
    * _NEW_LIGHT
d305 4
a308 4
   if (ctx->Light.ProvokingVertex != GL_FIRST_VERTEX_CONVENTION) {
      sf->sf7.trifan_pv = 2;
      sf->sf7.linestrip_pv = 1;
      sf->sf7.tristrip_pv = 2;
d310 3
a312 3
      sf->sf7.trifan_pv = 1;
      sf->sf7.linestrip_pv = 0;
      sf->sf7.tristrip_pv = 0;
d314 1
a314 1
   sf->sf7.line_last_pixel_enable = 0;
d318 7
a324 2
   sf->sf6.dest_org_vbias = 0x8;
   sf->sf6.dest_org_hbias = 0x8;
d329 4
d335 3
a337 5
   drm_intel_bo_emit_reloc(bo, (brw->sf.state_offset +
				offsetof(struct brw_sf_unit_state, sf5)),
			   brw->batch.bo, (brw->sf.vp_offset |
					     sf->sf5.front_winding |
					     (sf->sf5.viewport_transform << 1)),
d340 21
a360 1
   brw->state.dirty.cache |= CACHE_NEW_SF_UNIT;
a365 1
		_NEW_PROGRAM |
d371 1
a371 3
      .brw   = (BRW_NEW_BATCH |
		BRW_NEW_PROGRAM_CACHE |
		BRW_NEW_URB_FENCE),
d375 1
a375 1
   .emit = upload_sf_unit,
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

d49 1
a49 1
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;
d117 1
a117 1
      .mesa  = (_NEW_VIEWPORT |
d176 1
a176 1
   sf->sf5.sf_viewport_state_offset = (brw->batch.bo->offset64 +
d182 1
a182 1
   if (ctx->Scissor.EnableFlags)
d241 1
a241 1
       * available at
d301 1
a301 1
      .mesa  = (_NEW_POLYGON |
d304 2
a305 2
		_NEW_LINE |
		_NEW_POINT |
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d212 2
a213 1
      unreachable("not reached");
d217 2
a218 2
   sf->sf6.line_width =
      CLAMP(ctx->Line.Width, 1.0, ctx->Const.MaxLineWidth) * (1<<1);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d212 1
a212 2
      assert(0);
      break;
d216 2
a217 2
   /* XXX use ctx->Const.Min/MaxLineWidth here */
   sf->sf6.line_width = CLAMP(ctx->Line.Width, 1.0, 5.0) * (1<<1);
@


