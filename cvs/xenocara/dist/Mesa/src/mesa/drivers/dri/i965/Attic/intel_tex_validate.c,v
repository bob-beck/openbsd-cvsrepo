head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.28;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.16;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.53;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.53;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.18;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.49;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.58;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.49.04;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2013 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "main/mtypes.h"
#include "main/macros.h"
#include "main/samplerobj.h"
#include "main/texobj.h"

#include "brw_context.h"
#include "intel_mipmap_tree.h"
#include "intel_blit.h"
#include "intel_tex.h"

#define FILE_DEBUG_FLAG DEBUG_TEXTURE

/**
 * Sets our driver-specific variant of tObj->_MaxLevel for later surface state
 * upload.
 *
 * If we're only ensuring that there is storage for the first miplevel of a
 * texture, then in texture setup we're going to have to make sure we don't
 * allow sampling beyond level 0.
 */
static void
intel_update_max_level(struct intel_texture_object *intelObj,
		       struct gl_sampler_object *sampler)
{
   struct gl_texture_object *tObj = &intelObj->base;

   if (sampler->MinFilter == GL_NEAREST ||
       sampler->MinFilter == GL_LINEAR) {
      intelObj->_MaxLevel = tObj->BaseLevel;
   } else {
      intelObj->_MaxLevel = tObj->_MaxLevel;
   }
}

/**
 * At rendering-from-a-texture time, make sure that the texture object has a
 * miptree that can hold the entire texture based on
 * BaseLevel/MaxLevel/filtering, and copy in any texture images that are
 * stored in other miptrees.
 */
GLuint
intel_finalize_mipmap_tree(struct brw_context *brw, GLuint unit)
{
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   GLuint face, i;
   GLuint nr_faces = 0;
   struct intel_texture_image *firstImage;
   int width, height, depth;

   /* TBOs require no validation -- they always just point to their BO. */
   if (tObj->Target == GL_TEXTURE_BUFFER)
      return true;

   /* We know that this is true by now, and if it wasn't, we might have
    * mismatched level sizes and the copies would fail.
    */
   assert(intelObj->base._BaseComplete);

   intel_update_max_level(intelObj, sampler);

   /* What levels does this validated texture image require? */
   int validate_first_level = tObj->BaseLevel;
   int validate_last_level = intelObj->_MaxLevel;

   /* Skip the loop over images in the common case of no images having
    * changed.  But if the GL_BASE_LEVEL or GL_MAX_LEVEL change to something we
    * haven't looked at, then we do need to look at those new images.
    */
   if (!intelObj->needs_validate &&
       validate_first_level >= intelObj->validated_first_level &&
       validate_last_level <= intelObj->validated_last_level) {
      return true;
   }

   /* Immutable textures should not get this far -- they should have been
    * created in a validated state, and nothing can invalidate them.
    */
   assert(!tObj->Immutable);

   firstImage = intel_texture_image(tObj->Image[0][tObj->BaseLevel]);

   /* Check tree can hold all active levels.  Check tree matches
    * target, imageFormat, etc.
    *
    * For pre-gen4, we have to match first_level == tObj->BaseLevel,
    * because we don't have the control that gen4 does to make min/mag
    * determination happen at a nonzero (hardware) baselevel.  Because
    * of that, we just always relayout on baselevel change.
    */
   if (intelObj->mt &&
       (!intel_miptree_match_image(intelObj->mt, &firstImage->base.Base) ||
	validate_first_level < intelObj->mt->first_level ||
	validate_last_level > intelObj->mt->last_level)) {
      intel_miptree_release(&intelObj->mt);
   }


   /* May need to create a new tree:
    */
   if (!intelObj->mt) {
      intel_miptree_get_dimensions_for_image(&firstImage->base.Base,
					     &width, &height, &depth);

      perf_debug("Creating new %s %dx%dx%d %d-level miptree to handle "
                 "finalized texture miptree.\n",
                 _mesa_get_format_name(firstImage->base.Base.TexFormat),
                 width, height, depth, validate_last_level + 1);

      intelObj->mt = intel_miptree_create(brw,
                                          intelObj->base.Target,
					  firstImage->base.Base.TexFormat,
                                          0, /* first_level */
                                          validate_last_level,
                                          width,
                                          height,
                                          depth,
					  true,
                                          0 /* num_samples */,
                                          INTEL_MIPTREE_TILING_ANY);
      if (!intelObj->mt)
         return false;
   }

   /* Pull in any images not in the object's tree:
    */
   nr_faces = _mesa_num_tex_faces(intelObj->base.Target);
   for (face = 0; face < nr_faces; face++) {
      for (i = validate_first_level; i <= validate_last_level; i++) {
         struct intel_texture_image *intelImage =
            intel_texture_image(intelObj->base.Image[face][i]);
	 /* skip too small size mipmap */
 	 if (intelImage == NULL)
		 break;

         if (intelObj->mt != intelImage->mt) {
            intel_miptree_copy_teximage(brw, intelImage, intelObj->mt,
                                        false /* invalidate */);
         }

         /* After we're done, we'd better agree that our layout is
          * appropriate, or we'll end up hitting this function again on the
          * next draw
          */
         assert(intel_miptree_match_image(intelObj->mt, &intelImage->base.Base));
      }
   }

   intelObj->validated_first_level = validate_first_level;
   intelObj->validated_last_level = validate_last_level;
   intelObj->_Format = intelObj->mt->format;
   intelObj->needs_validate = false;

   return true;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d110 5
d145 1
a145 2
                                          INTEL_MIPTREE_TILING_ANY,
                                          false);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a109 5
    *
    * For pre-gen4, we have to match first_level == tObj->BaseLevel,
    * because we don't have the control that gen4 does to make min/mag
    * determination happen at a nonzero (hardware) baselevel.  Because
    * of that, we just always relayout on baselevel change.
d140 2
a141 1
                                          INTEL_MIPTREE_TILING_ANY);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d1 23
d37 6
a42 3
 * When validating, we only care about the texture images that could
 * be seen, so for non-mipmapped modes we want to ignore everything
 * but BaseLevel.
a48 1
   int maxlevel;
d52 1
a52 1
      maxlevel = tObj->BaseLevel;
d54 1
a54 6
      maxlevel = tObj->_MaxLevel;
   }

   if (intelObj->_MaxLevel != maxlevel) {
      intelObj->_MaxLevel = maxlevel;
      intelObj->needs_validate = true;
d58 5
a62 1
/*  
d80 2
a81 1
   /* We know/require this is true by now: 
a84 2
   /* What levels must the tree include at a minimum?
    */
a85 2
   if (intelObj->mt && intelObj->mt->first_level != tObj->BaseLevel)
      intelObj->needs_validate = true;
d87 11
a97 1
   if (!intelObj->needs_validate)
d99 6
d118 2
a119 2
	intelObj->mt->first_level != tObj->BaseLevel ||
	intelObj->mt->last_level < intelObj->_MaxLevel)) {
d130 2
a131 2
      perf_debug("Creating new %s %dx%dx%d %d..%d miptree to handle finalized "
                 "texture miptree.\n",
d133 1
a133 1
                 width, height, depth, tObj->BaseLevel, intelObj->_MaxLevel);
d138 2
a139 2
                                          tObj->BaseLevel,
                                          intelObj->_MaxLevel,
d154 1
a154 1
      for (i = tObj->BaseLevel; i <= intelObj->_MaxLevel; i++) {
d174 3
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d1 4
a4 26
/**************************************************************************
 * 
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/
d6 1
a6 4
#include "mtypes.h"
#include "macros.h"

#include "intel_context.h"
d8 1
d10 2
a11 1
#include "bufmgr.h"
d14 3
a16 3
 * Compute which mipmap levels that really need to be sent to the hardware.
 * This depends on the base image size, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, and GL_TEXTURE_MAX_LEVEL.
d18 3
a20 1
static void intel_calculate_first_last_level( struct intel_texture_object *intelObj )
d23 1
a23 2
   const struct gl_texture_image * const baseImage =
       tObj->Image[0][tObj->BaseLevel];
d25 6
a30 6
   /* These must be signed values.  MinLod and MaxLod can be negative numbers,
    * and having firstLevel and lastLevel as signed prevents the need for
    * extra sign checks.
    */
   int   firstLevel;
   int   lastLevel;
d32 3
a34 31
   /* Yes, this looks overly complicated, but it's all needed.
    */
   switch (tObj->Target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP:
      if (tObj->MinFilter == GL_NEAREST || tObj->MinFilter == GL_LINEAR) {
         /* GL_NEAREST and GL_LINEAR only care about GL_TEXTURE_BASE_LEVEL.
          */
         firstLevel = lastLevel = tObj->BaseLevel;
      }
      else {
	 /* Currently not taking min/max lod into account here, those
	  * values are programmed as sampler state elsewhere and we
	  * upload the same mipmap levels regardless.  Not sure if
	  * this makes sense as it means it isn't possible for the app
	  * to use min/max lod to reduce texture memory pressure:
	  */
	 firstLevel = tObj->BaseLevel;
	 lastLevel = MIN2(tObj->BaseLevel + baseImage->MaxLog2, 
			  tObj->MaxLevel);
	 lastLevel = MAX2(firstLevel, lastLevel); /* need at least one level */
      }
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_4D_SGIS:
      firstLevel = lastLevel = 0;
      break;
   default:
      return;
a35 37

   /* save these values */
   intelObj->firstLevel = firstLevel;
   intelObj->lastLevel = lastLevel;
}

static GLboolean copy_image_data_to_tree( struct intel_context *intel,
					  struct intel_texture_object *intelObj,
					  struct gl_texture_image *texImage,
					  GLuint face,
					  GLuint level)
{
   return intel_miptree_image_data(intel,
				   intelObj->mt,
				   face,
				   level,
				   texImage->Data,
				   texImage->RowStride,
				   (texImage->RowStride * 
				    texImage->Height * 
				    texImage->TexFormat->TexelBytes));
}

static void intel_texture_invalidate( struct intel_texture_object *intelObj )
{
   GLint nr_faces, face;
   intelObj->dirty = ~0;

   nr_faces = (intelObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
   for (face = 0; face < nr_faces; face++) 
      intelObj->dirty_images[face] = ~0;
}

static void intel_texture_invalidate_cb( struct intel_context *intel,
					 void *ptr )
{
   intel_texture_invalidate( (struct intel_texture_object *) ptr );
a37 1

d40 2
a41 2
GLuint intel_finalize_mipmap_tree( struct intel_context *intel,
				   struct gl_texture_object *tObj )
d43 2
d46 1
d49 6
a54 1
   struct gl_texture_image *firstImage;
d58 1
a58 1
   assert(intelObj->base.Complete);
d62 3
a64 20
   if (intelObj->dirty) {
      intel_calculate_first_last_level( intelObj );
/*       intel_miptree_destroy(intel, intelObj->mt); */
/*       intelObj->mt = NULL; */
   }

   firstImage = intelObj->base.Image[0][intelObj->firstLevel];

   /* Fallback case:
    */
   if (firstImage->Border) {
      if (intelObj->mt) {
	 intel_miptree_destroy(intel, intelObj->mt);
	 intelObj->mt = NULL;
	 /* Set all images dirty:
	  */
	 intel_texture_invalidate(intelObj);
      }
      return GL_FALSE;
   }
d66 2
d69 1
d73 5
d80 4
a83 13
       (intelObj->mt->first_level != intelObj->firstLevel ||
	intelObj->mt->last_level != intelObj->lastLevel ||
	intelObj->mt->internal_format != firstImage->InternalFormat ||
	intelObj->mt->width0 != firstImage->Width ||
	intelObj->mt->height0 != firstImage->Height ||
	intelObj->mt->depth0 != firstImage->Depth)) 
   {
      intel_miptree_destroy(intel, intelObj->mt);
      intelObj->mt = NULL;
      
      /* Set all images dirty:
       */
      intel_texture_invalidate(intelObj);
d85 1
a85 1
      
d90 21
a110 19
      intelObj->mt = intel_miptree_create(intel,
					  intelObj->base.Target,
					  firstImage->InternalFormat,
					  intelObj->firstLevel,
					  intelObj->lastLevel,
					  firstImage->Width,
					  firstImage->Height,
					  firstImage->Depth,
					  firstImage->TexFormat->TexelBytes,
					  firstImage->IsCompressed);

      /* Tell the buffer manager that we will manage the backing
       * store, but we still want it to do fencing for us.
       */
      bmBufferSetInvalidateCB(intel, 
			      intelObj->mt->region->buffer,
			      intel_texture_invalidate_cb,
			      intelObj,
			      GL_FALSE);
d115 19
a133 33
   if (intelObj->dirty) {
      nr_faces = (intelObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
      for (face = 0; face < nr_faces; face++) {
	 if (intelObj->dirty_images[face]) {
	    for (i = intelObj->firstLevel; i <= intelObj->lastLevel; i++) {
	       struct gl_texture_image *texImage = intelObj->base.Image[face][i];

	       /* Need to import images in main memory or held in other trees.
		*/
	       if (intelObj->dirty_images[face] & (1<<i) &&
		   texImage) {

		  if (INTEL_DEBUG & DEBUG_TEXTURE)
		     _mesa_printf("copy data from image %d (%p) into object miptree\n",
				  i,
				  texImage->Data);

		  if (!copy_image_data_to_tree(intel,
					       intelObj,
					       texImage,
					       face,
					       i))
		     return GL_FALSE;

	       }
	    }
	 }
      }

      /* Only clear the dirty flags if everything went ok:
       */
      for (face = 0; face < nr_faces; face++) {
	 intelObj->dirty_images[face] = 0;
d135 1
d137 1
a137 2
      intelObj->dirty = 0;
   }
d139 1
a139 1
   return GL_TRUE;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a135 3
   if( tObj == intel->frame_buffer_texobj )
      return GL_FALSE;
   
d169 2
a170 1
       (intelObj->mt->target != intelObj->base.Target ||
a171 2
	intelObj->mt->first_level != intelObj->firstLevel ||
	intelObj->mt->last_level != intelObj->lastLevel ||
d174 1
a174 3
	intelObj->mt->depth0 != firstImage->Depth ||
	intelObj->mt->cpp != firstImage->TexFormat->TexelBytes ||
	intelObj->mt->compressed != firstImage->IsCompressed)) 
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d1 26
a26 4
#include "main/mtypes.h"
#include "main/macros.h"
#include "main/samplerobj.h"
#include "main/texobj.h"
d28 4
a31 1
#include "brw_context.h"
a32 1
#include "intel_blit.h"
d34 1
a34 2

#define FILE_DEBUG_FLAG DEBUG_TEXTURE
d37 3
a39 3
 * When validating, we only care about the texture images that could
 * be seen, so for non-mipmapped modes we want to ignore everything
 * but BaseLevel.
d41 1
a41 3
static void
intel_update_max_level(struct intel_texture_object *intelObj,
		       struct gl_sampler_object *sampler)
d44 2
a45 1
   int maxlevel;
d47 38
a84 5
   if (sampler->MinFilter == GL_NEAREST ||
       sampler->MinFilter == GL_LINEAR) {
      maxlevel = tObj->BaseLevel;
   } else {
      maxlevel = tObj->_MaxLevel;
d87 36
a122 4
   if (intelObj->_MaxLevel != maxlevel) {
      intelObj->_MaxLevel = maxlevel;
      intelObj->needs_validate = true;
   }
d125 1
d128 2
a129 2
GLuint
intel_finalize_mipmap_tree(struct brw_context *brw, GLuint unit)
a130 2
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
a131 1
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
d134 1
a134 6
   struct intel_texture_image *firstImage;
   int width, height, depth;

   /* TBOs require no validation -- they always just point to their BO. */
   if (tObj->Target == GL_TEXTURE_BUFFER)
      return true;
d136 3
d141 1
a141 1
   assert(intelObj->base._BaseComplete);
d145 20
a164 3
   intel_update_max_level(intelObj, sampler);
   if (intelObj->mt && intelObj->mt->first_level != tObj->BaseLevel)
      intelObj->needs_validate = true;
a165 2
   if (!intelObj->needs_validate)
      return true;
a166 1
   firstImage = intel_texture_image(tObj->Image[0][tObj->BaseLevel]);
a169 5
    *
    * For pre-gen4, we have to match first_level == tObj->BaseLevel,
    * because we don't have the control that gen4 does to make min/mag
    * determination happen at a nonzero (hardware) baselevel.  Because
    * of that, we just always relayout on baselevel change.
d172 16
a187 4
       (!intel_miptree_match_image(intelObj->mt, &firstImage->base.Base) ||
	intelObj->mt->first_level != tObj->BaseLevel ||
	intelObj->mt->last_level < intelObj->_MaxLevel)) {
      intel_miptree_release(&intelObj->mt);
d189 1
a189 1

d194 19
a212 21
      intel_miptree_get_dimensions_for_image(&firstImage->base.Base,
					     &width, &height, &depth);

      perf_debug("Creating new %s %dx%dx%d %d..%d miptree to handle finalized "
                 "texture miptree.\n",
                 _mesa_get_format_name(firstImage->base.Base.TexFormat),
                 width, height, depth, tObj->BaseLevel, intelObj->_MaxLevel);

      intelObj->mt = intel_miptree_create(brw,
                                          intelObj->base.Target,
					  firstImage->base.Base.TexFormat,
                                          tObj->BaseLevel,
                                          intelObj->_MaxLevel,
                                          width,
                                          height,
                                          depth,
					  true,
                                          0 /* num_samples */,
                                          INTEL_MIPTREE_TILING_ANY);
      if (!intelObj->mt)
         return false;
d217 33
a249 19
   nr_faces = _mesa_num_tex_faces(intelObj->base.Target);
   for (face = 0; face < nr_faces; face++) {
      for (i = tObj->BaseLevel; i <= intelObj->_MaxLevel; i++) {
         struct intel_texture_image *intelImage =
            intel_texture_image(intelObj->base.Image[face][i]);
	 /* skip too small size mipmap */
 	 if (intelImage == NULL)
		 break;

         if (intelObj->mt != intelImage->mt) {
            intel_miptree_copy_teximage(brw, intelImage, intelObj->mt,
                                        false /* invalidate */);
         }

         /* After we're done, we'd better agree that our layout is
          * appropriate, or we'll end up hitting this function again on the
          * next draw
          */
         assert(intel_miptree_match_image(intelObj->mt, &intelImage->base.Base));
d251 2
d255 1
a255 3
   intelObj->needs_validate = false;

   return true;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a0 23
/*
 * Copyright © 2013 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

d14 3
a16 6
 * Sets our driver-specific variant of tObj->_MaxLevel for later surface state
 * upload.
 *
 * If we're only ensuring that there is storage for the first miplevel of a
 * texture, then in texture setup we're going to have to make sure we don't
 * allow sampling beyond level 0.
d23 1
d27 1
a27 1
      intelObj->_MaxLevel = tObj->BaseLevel;
d29 6
a34 1
      intelObj->_MaxLevel = tObj->_MaxLevel;
d38 1
a38 5
/**
 * At rendering-from-a-texture time, make sure that the texture object has a
 * miptree that can hold the entire texture based on
 * BaseLevel/MaxLevel/filtering, and copy in any texture images that are
 * stored in other miptrees.
d56 1
a56 2
   /* We know that this is true by now, and if it wasn't, we might have
    * mismatched level sizes and the copies would fail.
d60 2
d63 2
d66 1
a66 11
   /* What levels does this validated texture image require? */
   int validate_first_level = tObj->BaseLevel;
   int validate_last_level = intelObj->_MaxLevel;

   /* Skip the loop over images in the common case of no images having
    * changed.  But if the GL_BASE_LEVEL or GL_MAX_LEVEL change to something we
    * haven't looked at, then we do need to look at those new images.
    */
   if (!intelObj->needs_validate &&
       validate_first_level >= intelObj->validated_first_level &&
       validate_last_level <= intelObj->validated_last_level) {
a67 6
   }

   /* Immutable textures should not get this far -- they should have been
    * created in a validated state, and nothing can invalidate them.
    */
   assert(!tObj->Immutable);
d81 2
a82 2
	validate_first_level < intelObj->mt->first_level ||
	validate_last_level > intelObj->mt->last_level)) {
d93 2
a94 2
      perf_debug("Creating new %s %dx%dx%d %d-level miptree to handle "
                 "finalized texture miptree.\n",
d96 1
a96 1
                 width, height, depth, validate_last_level + 1);
d101 2
a102 2
                                          0, /* first_level */
                                          validate_last_level,
d117 1
a117 1
      for (i = validate_first_level; i <= validate_last_level; i++) {
a136 3
   intelObj->validated_first_level = validate_first_level;
   intelObj->validated_last_level = validate_last_level;
   intelObj->_Format = intelObj->mt->format;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d110 5
d145 1
a145 2
                                          INTEL_MIPTREE_TILING_ANY,
                                          false);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a109 5
    *
    * For pre-gen4, we have to match first_level == tObj->BaseLevel,
    * because we don't have the control that gen4 does to make min/mag
    * determination happen at a nonzero (hardware) baselevel.  Because
    * of that, we just always relayout on baselevel change.
d140 2
a141 1
                                          INTEL_MIPTREE_TILING_ANY);
@


