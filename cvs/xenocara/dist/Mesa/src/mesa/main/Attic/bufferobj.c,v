head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.16;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.24;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.28;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.35;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file bufferobj.c
 * \brief Functions for the GL_ARB_vertex/pixel_buffer_object extensions.
 * \author Brian Paul, Ian Romanick
 */

#include <stdbool.h>
#include "glheader.h"
#include "enums.h"
#include "hash.h"
#include "imports.h"
#include "image.h"
#include "context.h"
#include "bufferobj.h"
#include "fbobject.h"
#include "mtypes.h"
#include "texobj.h"
#include "teximage.h"
#include "glformats.h"
#include "texstore.h"
#include "transformfeedback.h"
#include "dispatch.h"


/* Debug flags */
/*#define VBO_DEBUG*/
/*#define BOUNDS_CHECK*/


/**
 * Used as a placeholder for buffer objects between glGenBuffers() and
 * glBindBuffer() so that glIsBuffer() can work correctly.
 */
static struct gl_buffer_object DummyBufferObject;


/**
 * Return pointer to address of a buffer object target.
 * \param ctx  the GL context
 * \param target  the buffer object target to be retrieved.
 * \return   pointer to pointer to the buffer object bound to \c target in the
 *           specified context or \c NULL if \c target is invalid.
 */
static inline struct gl_buffer_object **
get_buffer_target(struct gl_context *ctx, GLenum target)
{
   /* Other targets are only supported in desktop OpenGL and OpenGL ES 3.0.
    */
   if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx)
       && target != GL_ARRAY_BUFFER && target != GL_ELEMENT_ARRAY_BUFFER)
      return NULL;

   switch (target) {
   case GL_ARRAY_BUFFER_ARB:
      return &ctx->Array.ArrayBufferObj;
   case GL_ELEMENT_ARRAY_BUFFER_ARB:
      return &ctx->Array.VAO->IndexBufferObj;
   case GL_PIXEL_PACK_BUFFER_EXT:
      return &ctx->Pack.BufferObj;
   case GL_PIXEL_UNPACK_BUFFER_EXT:
      return &ctx->Unpack.BufferObj;
   case GL_COPY_READ_BUFFER:
      return &ctx->CopyReadBuffer;
   case GL_COPY_WRITE_BUFFER:
      return &ctx->CopyWriteBuffer;
   case GL_DRAW_INDIRECT_BUFFER:
      if (ctx->API == API_OPENGL_CORE &&
          ctx->Extensions.ARB_draw_indirect) {
         return &ctx->DrawIndirectBuffer;
      }
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      if (ctx->Extensions.EXT_transform_feedback) {
         return &ctx->TransformFeedback.CurrentBuffer;
      }
      break;
   case GL_TEXTURE_BUFFER:
      if (ctx->API == API_OPENGL_CORE &&
          ctx->Extensions.ARB_texture_buffer_object) {
         return &ctx->Texture.BufferObject;
      }
      break;
   case GL_UNIFORM_BUFFER:
      if (ctx->Extensions.ARB_uniform_buffer_object) {
         return &ctx->UniformBuffer;
      }
      break;
   case GL_ATOMIC_COUNTER_BUFFER:
      if (ctx->Extensions.ARB_shader_atomic_counters) {
         return &ctx->AtomicBuffer;
      }
      break;
   default:
      return NULL;
   }
   return NULL;
}


/**
 * Get the buffer object bound to the specified target in a GL context.
 * \param ctx  the GL context
 * \param target  the buffer object target to be retrieved.
 * \param error  the GL error to record if target is illegal.
 * \return   pointer to the buffer object bound to \c target in the
 *           specified context or \c NULL if \c target is invalid.
 */
static inline struct gl_buffer_object *
get_buffer(struct gl_context *ctx, const char *func, GLenum target,
           GLenum error)
{
   struct gl_buffer_object **bufObj = get_buffer_target(ctx, target);

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", func);
      return NULL;
   }

   if (!_mesa_is_bufferobj(*bufObj)) {
      _mesa_error(ctx, error, "%s(no buffer bound)", func);
      return NULL;
   }

   return *bufObj;
}


/**
 * Convert a GLbitfield describing the mapped buffer access flags
 * into one of GL_READ_WRITE, GL_READ_ONLY, or GL_WRITE_ONLY.
 */
static GLenum
simplified_access_mode(struct gl_context *ctx, GLbitfield access)
{
   const GLbitfield rwFlags = GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
   if ((access & rwFlags) == rwFlags)
      return GL_READ_WRITE;
   if ((access & GL_MAP_READ_BIT) == GL_MAP_READ_BIT)
      return GL_READ_ONLY;
   if ((access & GL_MAP_WRITE_BIT) == GL_MAP_WRITE_BIT)
      return GL_WRITE_ONLY;

   /* Otherwise, AccessFlags is zero (the default state).
    *
    * Table 2.6 on page 31 (page 44 of the PDF) of the OpenGL 1.5 spec says:
    *
    * Name           Type  Initial Value  Legal Values
    * ...            ...   ...            ...
    * BUFFER_ACCESS  enum  READ_WRITE     READ_ONLY, WRITE_ONLY
    *                                     READ_WRITE
    *
    * However, table 6.8 in the GL_OES_mapbuffer extension says:
    *
    * Get Value         Type Get Command          Value          Description
    * ---------         ---- -----------          -----          -----------
    * BUFFER_ACCESS_OES Z1   GetBufferParameteriv WRITE_ONLY_OES buffer map flag
    *
    * The difference is because GL_OES_mapbuffer only supports mapping buffers
    * write-only.
    */
   assert(access == 0);

   return _mesa_is_gles(ctx) ? GL_WRITE_ONLY : GL_READ_WRITE;
}


/**
 * Test if the buffer is mapped, and if so, if the mapped range overlaps the
 * given range.
 * The regions do not overlap if and only if the end of the given
 * region is before the mapped region or the start of the given region
 * is after the mapped region.
 *
 * \param obj     Buffer object target on which to operate.
 * \param offset  Offset of the first byte of the subdata range.
 * \param size    Size, in bytes, of the subdata range.
 * \return   true if ranges overlap, false otherwise
 *
 */
static bool
bufferobj_range_mapped(const struct gl_buffer_object *obj,
                       GLintptr offset, GLsizeiptr size)
{
   if (_mesa_bufferobj_mapped(obj, MAP_USER)) {
      const GLintptr end = offset + size;
      const GLintptr mapEnd = obj->Mappings[MAP_USER].Offset +
                              obj->Mappings[MAP_USER].Length;

      if (!(end <= obj->Mappings[MAP_USER].Offset || offset >= mapEnd)) {
         return true;
      }
   }
   return false;
}


/**
 * Tests the subdata range parameters and sets the GL error code for
 * \c glBufferSubDataARB, \c glGetBufferSubDataARB and
 * \c glClearBufferSubData.
 *
 * \param ctx     GL context.
 * \param target  Buffer object target on which to operate.
 * \param offset  Offset of the first byte of the subdata range.
 * \param size    Size, in bytes, of the subdata range.
 * \param mappedRange  If true, checks if an overlapping range is mapped.
 *                     If false, checks if buffer is mapped.
 * \param errorNoBuffer  Error code if no buffer is bound to target.
 * \param caller  Name of calling function for recording errors.
 * \return   A pointer to the buffer object bound to \c target in the
 *           specified context or \c NULL if any of the parameter or state
 *           conditions are invalid.
 *
 * \sa glBufferSubDataARB, glGetBufferSubDataARB, glClearBufferSubData
 */
static struct gl_buffer_object *
buffer_object_subdata_range_good(struct gl_context * ctx, GLenum target,
                                 GLintptrARB offset, GLsizeiptrARB size,
                                 bool mappedRange, GLenum errorNoBuffer,
                                 const char *caller)
{
   struct gl_buffer_object *bufObj;

   if (size < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(size < 0)", caller);
      return NULL;
   }

   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(offset < 0)", caller);
      return NULL;
   }

   bufObj = get_buffer(ctx, caller, target, errorNoBuffer);
   if (!bufObj)
      return NULL;

   if (offset + size > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(offset %lu + size %lu > buffer size %lu)", caller,
                  (unsigned long) offset,
                  (unsigned long) size,
                  (unsigned long) bufObj->Size);
      return NULL;
   }

   if (bufObj->Mappings[MAP_USER].AccessFlags & GL_MAP_PERSISTENT_BIT)
      return bufObj;

   if (mappedRange) {
      if (bufferobj_range_mapped(bufObj, offset, size)) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
   }
   else {
      if (_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
   }

   return bufObj;
}


/**
 * Test the format and type parameters and set the GL error code for
 * \c glClearBufferData and \c glClearBufferSubData.
 *
 * \param ctx             GL context.
 * \param internalformat  Format to which the data is to be converted.
 * \param format          Format of the supplied data.
 * \param type            Type of the supplied data.
 * \param caller          Name of calling function for recording errors.
 * \return   If internalformat, format and type are legal the mesa_format
 *           corresponding to internalformat, otherwise MESA_FORMAT_NONE.
 *
 * \sa glClearBufferData and glClearBufferSubData
 */
static mesa_format
validate_clear_buffer_format(struct gl_context *ctx,
                             GLenum internalformat,
                             GLenum format, GLenum type,
                             const char *caller)
{
   mesa_format mesaFormat;
   GLenum errorFormatType;

   mesaFormat = _mesa_validate_texbuffer_format(ctx, internalformat);
   if (mesaFormat == MESA_FORMAT_NONE) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(invalid internalformat)", caller);
      return MESA_FORMAT_NONE;
   }

   /* NOTE: not mentioned in ARB_clear_buffer_object but according to
    * EXT_texture_integer there is no conversion between integer and
    * non-integer formats
   */
   if (_mesa_is_enum_format_signed_int(format) !=
       _mesa_is_format_integer_color(mesaFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(integer vs non-integer)", caller);
      return MESA_FORMAT_NONE;
   }

   if (!_mesa_is_color_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(format is not a color format)", caller);
      return MESA_FORMAT_NONE;
   }

   errorFormatType = _mesa_error_check_format_and_type(ctx, format, type);
   if (errorFormatType != GL_NO_ERROR) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(invalid format or type)", caller);
      return MESA_FORMAT_NONE;
   }

   return mesaFormat;
}


/**
 * Convert user-specified clear value to the specified internal format.
 *
 * \param ctx             GL context.
 * \param internalformat  Format to which the data is converted.
 * \param clearValue      Points to the converted clear value.
 * \param format          Format of the supplied data.
 * \param type            Type of the supplied data.
 * \param data            Data which is to be converted to internalformat.
 * \param caller          Name of calling function for recording errors.
 * \return   true if data could be converted, false otherwise.
 *
 * \sa glClearBufferData, glClearBufferSubData
 */
static bool
convert_clear_buffer_data(struct gl_context *ctx,
                          mesa_format internalformat,
                          GLubyte *clearValue, GLenum format, GLenum type,
                          const GLvoid *data, const char *caller)
{
   GLenum internalformatBase = _mesa_get_format_base_format(internalformat);

   if (_mesa_texstore(ctx, 1, internalformatBase, internalformat,
                      0, &clearValue, 1, 1, 1,
                      format, type, data, &ctx->Unpack)) {
      return true;
   }
   else {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
      return false;
   }
}


/**
 * Allocate and initialize a new buffer object.
 * 
 * Default callback for the \c dd_function_table::NewBufferObject() hook.
 */
static struct gl_buffer_object *
_mesa_new_buffer_object( struct gl_context *ctx, GLuint name, GLenum target )
{
   struct gl_buffer_object *obj;

   (void) ctx;

   obj = MALLOC_STRUCT(gl_buffer_object);
   _mesa_initialize_buffer_object(ctx, obj, name, target);
   return obj;
}


/**
 * Delete a buffer object.
 * 
 * Default callback for the \c dd_function_table::DeleteBuffer() hook.
 */
static void
_mesa_delete_buffer_object(struct gl_context *ctx,
                           struct gl_buffer_object *bufObj)
{
   (void) ctx;

   _mesa_align_free(bufObj->Data);

   /* assign strange values here to help w/ debugging */
   bufObj->RefCount = -1000;
   bufObj->Name = ~0;

   mtx_destroy(&bufObj->Mutex);
   free(bufObj->Label);
   free(bufObj);
}



/**
 * Set ptr to bufObj w/ reference counting.
 * This is normally only called from the _mesa_reference_buffer_object() macro
 * when there's a real pointer change.
 */
void
_mesa_reference_buffer_object_(struct gl_context *ctx,
                               struct gl_buffer_object **ptr,
                               struct gl_buffer_object *bufObj)
{
   if (*ptr) {
      /* Unreference the old buffer */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_buffer_object *oldObj = *ptr;

      mtx_lock(&oldObj->Mutex);
      ASSERT(oldObj->RefCount > 0);
      oldObj->RefCount--;
#if 0
      printf("BufferObj %p %d DECR to %d\n",
             (void *) oldObj, oldObj->Name, oldObj->RefCount);
#endif
      deleteFlag = (oldObj->RefCount == 0);
      mtx_unlock(&oldObj->Mutex);

      if (deleteFlag) {

         /* some sanity checking: don't delete a buffer still in use */
#if 0
         /* unfortunately, these tests are invalid during context tear-down */
	 ASSERT(ctx->Array.ArrayBufferObj != bufObj);
	 ASSERT(ctx->Array.VAO->IndexBufferObj != bufObj);
	 ASSERT(ctx->Array.VAO->Vertex.BufferObj != bufObj);
#endif

	 ASSERT(ctx->Driver.DeleteBuffer);
         ctx->Driver.DeleteBuffer(ctx, oldObj);
      }

      *ptr = NULL;
   }
   ASSERT(!*ptr);

   if (bufObj) {
      /* reference new buffer */
      mtx_lock(&bufObj->Mutex);
      if (bufObj->RefCount == 0) {
         /* this buffer's being deleted (look just above) */
         /* Not sure this can every really happen.  Warn if it does. */
         _mesa_problem(NULL, "referencing deleted buffer object");
         *ptr = NULL;
      }
      else {
         bufObj->RefCount++;
#if 0
         printf("BufferObj %p %d INCR to %d\n",
                (void *) bufObj, bufObj->Name, bufObj->RefCount);
#endif
         *ptr = bufObj;
      }
      mtx_unlock(&bufObj->Mutex);
   }
}


/**
 * Initialize a buffer object to default values.
 */
void
_mesa_initialize_buffer_object( struct gl_context *ctx,
				struct gl_buffer_object *obj,
				GLuint name, GLenum target )
{
   (void) target;

   memset(obj, 0, sizeof(struct gl_buffer_object));
   mtx_init(&obj->Mutex, mtx_plain);
   obj->RefCount = 1;
   obj->Name = name;
   obj->Usage = GL_STATIC_DRAW_ARB;
}



/**
 * Callback called from _mesa_HashWalk()
 */
static void
count_buffer_size(GLuint key, void *data, void *userData)
{
   const struct gl_buffer_object *bufObj =
      (const struct gl_buffer_object *) data;
   GLuint *total = (GLuint *) userData;

   *total = *total + bufObj->Size;
}


/**
 * Compute total size (in bytes) of all buffer objects for the given context.
 * For debugging purposes.
 */
GLuint
_mesa_total_buffer_object_memory(struct gl_context *ctx)
{
   GLuint total = 0;

   _mesa_HashWalk(ctx->Shared->BufferObjects, count_buffer_size, &total);

   return total;
}


/**
 * Allocate space for and store data in a buffer object.  Any data that was
 * previously stored in the buffer object is lost.  If \c data is \c NULL,
 * memory will be allocated, but no copy will occur.
 *
 * This is the default callback for \c dd_function_table::BufferData()
 * Note that all GL error checking will have been done already.
 *
 * \param ctx     GL context.
 * \param target  Buffer object target on which to operate.
 * \param size    Size, in bytes, of the new data store.
 * \param data    Pointer to the data to store in the buffer object.  This
 *                pointer may be \c NULL.
 * \param usage   Hints about how the data will be used.
 * \param bufObj  Object to be used.
 *
 * \return GL_TRUE for success, GL_FALSE for failure
 * \sa glBufferDataARB, dd_function_table::BufferData.
 */
static GLboolean
_mesa_buffer_data( struct gl_context *ctx, GLenum target, GLsizeiptrARB size,
		   const GLvoid * data, GLenum usage, GLenum storageFlags,
		   struct gl_buffer_object * bufObj )
{
   void * new_data;

   (void) target;

   _mesa_align_free( bufObj->Data );

   new_data = _mesa_align_malloc( size, ctx->Const.MinMapBufferAlignment );
   if (new_data) {
      bufObj->Data = (GLubyte *) new_data;
      bufObj->Size = size;
      bufObj->Usage = usage;
      bufObj->StorageFlags = storageFlags;

      if (data) {
	 memcpy( bufObj->Data, data, size );
      }

      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}


/**
 * Replace data in a subrange of buffer object.  If the data range
 * specified by \c size + \c offset extends beyond the end of the buffer or
 * if \c data is \c NULL, no copy is performed.
 *
 * This is the default callback for \c dd_function_table::BufferSubData()
 * Note that all GL error checking will have been done already.
 *
 * \param ctx     GL context.
 * \param offset  Offset of the first byte to be modified.
 * \param size    Size, in bytes, of the data range.
 * \param data    Pointer to the data to store in the buffer object.
 * \param bufObj  Object to be used.
 *
 * \sa glBufferSubDataARB, dd_function_table::BufferSubData.
 */
static void
_mesa_buffer_subdata( struct gl_context *ctx, GLintptrARB offset,
		      GLsizeiptrARB size, const GLvoid * data,
		      struct gl_buffer_object * bufObj )
{
   (void) ctx;

   /* this should have been caught in _mesa_BufferSubData() */
   ASSERT(size + offset <= bufObj->Size);

   if (bufObj->Data) {
      memcpy( (GLubyte *) bufObj->Data + offset, data, size );
   }
}


/**
 * Retrieve data from a subrange of buffer object.  If the data range
 * specified by \c size + \c offset extends beyond the end of the buffer or
 * if \c data is \c NULL, no copy is performed.
 *
 * This is the default callback for \c dd_function_table::GetBufferSubData()
 * Note that all GL error checking will have been done already.
 *
 * \param ctx     GL context.
 * \param target  Buffer object target on which to operate.
 * \param offset  Offset of the first byte to be fetched.
 * \param size    Size, in bytes, of the data range.
 * \param data    Destination for data
 * \param bufObj  Object to be used.
 *
 * \sa glBufferGetSubDataARB, dd_function_table::GetBufferSubData.
 */
static void
_mesa_buffer_get_subdata( struct gl_context *ctx, GLintptrARB offset,
			  GLsizeiptrARB size, GLvoid * data,
			  struct gl_buffer_object * bufObj )
{
   (void) ctx;

   if (bufObj->Data && ((GLsizeiptrARB) (size + offset) <= bufObj->Size)) {
      memcpy( data, (GLubyte *) bufObj->Data + offset, size );
   }
}


/**
 * Clear a subrange of the buffer object with copies of the supplied data.
 * If data is NULL the buffer is filled with zeros.
 *
 * This is the default callback for \c dd_function_table::ClearBufferSubData()
 * Note that all GL error checking will have been done already.
 *
 * \param ctx             GL context.
 * \param offset          Offset of the first byte to be cleared.
 * \param size            Size, in bytes, of the to be cleared range.
 * \param clearValue      Source of the data.
 * \param clearValueSize  Size, in bytes, of the supplied data.
 * \param bufObj          Object to be cleared.
 *
 * \sa glClearBufferSubData, glClearBufferData and
 * dd_function_table::ClearBufferSubData.
 */
void
_mesa_buffer_clear_subdata(struct gl_context *ctx,
                           GLintptr offset, GLsizeiptr size,
                           const GLvoid *clearValue,
                           GLsizeiptr clearValueSize,
                           struct gl_buffer_object *bufObj)
{
   GLsizeiptr i;
   GLubyte *dest;

   ASSERT(ctx->Driver.MapBufferRange);
   dest = ctx->Driver.MapBufferRange(ctx, offset, size,
                                     GL_MAP_WRITE_BIT |
                                     GL_MAP_INVALIDATE_RANGE_BIT,
                                     bufObj, MAP_INTERNAL);

   if (!dest) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glClearBuffer[Sub]Data");
      return;
   }

   if (clearValue == NULL) {
      /* Clear with zeros, per the spec */
      memset(dest, 0, size);
      ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_INTERNAL);
      return;
   }

   for (i = 0; i < size/clearValueSize; ++i) {
      memcpy(dest, clearValue, clearValueSize);
      dest += clearValueSize;
   }

   ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_INTERNAL);
}


/**
 * Default fallback for \c dd_function_table::MapBufferRange().
 * Called via glMapBufferRange().
 */
static void *
_mesa_buffer_map_range( struct gl_context *ctx, GLintptr offset,
                        GLsizeiptr length, GLbitfield access,
                        struct gl_buffer_object *bufObj,
                        gl_map_buffer_index index)
{
   (void) ctx;
   assert(!_mesa_bufferobj_mapped(bufObj, index));
   /* Just return a direct pointer to the data */
   bufObj->Mappings[index].Pointer = bufObj->Data + offset;
   bufObj->Mappings[index].Length = length;
   bufObj->Mappings[index].Offset = offset;
   bufObj->Mappings[index].AccessFlags = access;
   return bufObj->Mappings[index].Pointer;
}


/**
 * Default fallback for \c dd_function_table::FlushMappedBufferRange().
 * Called via glFlushMappedBufferRange().
 */
static void
_mesa_buffer_flush_mapped_range( struct gl_context *ctx,
                                 GLintptr offset, GLsizeiptr length,
                                 struct gl_buffer_object *obj,
                                 gl_map_buffer_index index)
{
   (void) ctx;
   (void) offset;
   (void) length;
   (void) obj;
   /* no-op */
}


/**
 * Default callback for \c dd_function_table::MapBuffer().
 *
 * The input parameters will have been already tested for errors.
 *
 * \sa glUnmapBufferARB, dd_function_table::UnmapBuffer
 */
static GLboolean
_mesa_buffer_unmap(struct gl_context *ctx, struct gl_buffer_object *bufObj,
                   gl_map_buffer_index index)
{
   (void) ctx;
   /* XXX we might assert here that bufObj->Pointer is non-null */
   bufObj->Mappings[index].Pointer = NULL;
   bufObj->Mappings[index].Length = 0;
   bufObj->Mappings[index].Offset = 0;
   bufObj->Mappings[index].AccessFlags = 0x0;
   return GL_TRUE;
}


/**
 * Default fallback for \c dd_function_table::CopyBufferSubData().
 * Called via glCopyBufferSubData().
 */
static void
_mesa_copy_buffer_subdata(struct gl_context *ctx,
                          struct gl_buffer_object *src,
                          struct gl_buffer_object *dst,
                          GLintptr readOffset, GLintptr writeOffset,
                          GLsizeiptr size)
{
   GLubyte *srcPtr, *dstPtr;

   if (src == dst) {
      srcPtr = dstPtr = ctx->Driver.MapBufferRange(ctx, 0, src->Size,
						   GL_MAP_READ_BIT |
						   GL_MAP_WRITE_BIT, src,
                                                   MAP_INTERNAL);

      if (!srcPtr)
	 return;

      srcPtr += readOffset;
      dstPtr += writeOffset;
   } else {
      srcPtr = ctx->Driver.MapBufferRange(ctx, readOffset, size,
					  GL_MAP_READ_BIT, src,
                                          MAP_INTERNAL);
      dstPtr = ctx->Driver.MapBufferRange(ctx, writeOffset, size,
					  (GL_MAP_WRITE_BIT |
					   GL_MAP_INVALIDATE_RANGE_BIT), dst,
                                          MAP_INTERNAL);
   }

   /* Note: the src and dst regions will never overlap.  Trying to do so
    * would generate GL_INVALID_VALUE earlier.
    */
   if (srcPtr && dstPtr)
      memcpy(dstPtr, srcPtr, size);

   ctx->Driver.UnmapBuffer(ctx, src, MAP_INTERNAL);
   if (dst != src)
      ctx->Driver.UnmapBuffer(ctx, dst, MAP_INTERNAL);
}



/**
 * Initialize the state associated with buffer objects
 */
void
_mesa_init_buffer_objects( struct gl_context *ctx )
{
   GLuint i;

   memset(&DummyBufferObject, 0, sizeof(DummyBufferObject));
   mtx_init(&DummyBufferObject.Mutex, mtx_plain);
   DummyBufferObject.RefCount = 1000*1000*1000; /* never delete */

   _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj,
                                 ctx->Shared->NullBufferObj);

   _mesa_reference_buffer_object(ctx, &ctx->CopyReadBuffer,
                                 ctx->Shared->NullBufferObj);
   _mesa_reference_buffer_object(ctx, &ctx->CopyWriteBuffer,
                                 ctx->Shared->NullBufferObj);

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer,
				 ctx->Shared->NullBufferObj);

   _mesa_reference_buffer_object(ctx, &ctx->DrawIndirectBuffer,
				 ctx->Shared->NullBufferObj);

   for (i = 0; i < MAX_COMBINED_UNIFORM_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->UniformBufferBindings[i].BufferObject,
				    ctx->Shared->NullBufferObj);
      ctx->UniformBufferBindings[i].Offset = -1;
      ctx->UniformBufferBindings[i].Size = -1;
   }
}


void
_mesa_free_buffer_objects( struct gl_context *ctx )
{
   GLuint i;

   _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj, NULL);

   _mesa_reference_buffer_object(ctx, &ctx->CopyReadBuffer, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->CopyWriteBuffer, NULL);

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer, NULL);

   _mesa_reference_buffer_object(ctx, &ctx->DrawIndirectBuffer, NULL);

   for (i = 0; i < MAX_COMBINED_UNIFORM_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->UniformBufferBindings[i].BufferObject,
				    NULL);
   }
}

bool
_mesa_handle_bind_buffer_gen(struct gl_context *ctx,
                             GLenum target,
                             GLuint buffer,
                             struct gl_buffer_object **buf_handle,
                             const char *caller)
{
   struct gl_buffer_object *buf = *buf_handle;

   if (!buf && ctx->API == API_OPENGL_CORE) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-gen name)", caller);
      return false;
   }

   if (!buf || buf == &DummyBufferObject) {
      /* If this is a new buffer object id, or one which was generated but
       * never used before, allocate a buffer object now.
       */
      ASSERT(ctx->Driver.NewBufferObject);
      buf = ctx->Driver.NewBufferObject(ctx, buffer, target);
      if (!buf) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
	 return false;
      }
      _mesa_HashInsert(ctx->Shared->BufferObjects, buffer, buf);
      *buf_handle = buf;
   }

   return true;
}

/**
 * Bind the specified target to buffer for the specified context.
 * Called by glBindBuffer() and other functions.
 */
static void
bind_buffer_object(struct gl_context *ctx, GLenum target, GLuint buffer)
{
   struct gl_buffer_object *oldBufObj;
   struct gl_buffer_object *newBufObj = NULL;
   struct gl_buffer_object **bindTarget = NULL;

   bindTarget = get_buffer_target(ctx, target);
   if (!bindTarget) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferARB(target 0x%x)", target);
      return;
   }

   /* Get pointer to old buffer object (to be unbound) */
   oldBufObj = *bindTarget;
   if (oldBufObj && oldBufObj->Name == buffer && !oldBufObj->DeletePending)
      return;   /* rebinding the same buffer object- no change */

   /*
    * Get pointer to new buffer object (newBufObj)
    */
   if (buffer == 0) {
      /* The spec says there's not a buffer object named 0, but we use
       * one internally because it simplifies things.
       */
      newBufObj = ctx->Shared->NullBufferObj;
   }
   else {
      /* non-default buffer object */
      newBufObj = _mesa_lookup_bufferobj(ctx, buffer);
      if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
                                        &newBufObj, "glBindBuffer"))
         return;
   }
   
   /* bind new buffer */
   _mesa_reference_buffer_object(ctx, bindTarget, newBufObj);
}


/**
 * Update the default buffer objects in the given context to reference those
 * specified in the shared state and release those referencing the old 
 * shared state.
 */
void
_mesa_update_default_objects_buffer_objects(struct gl_context *ctx)
{
   /* Bind the NullBufferObj to remove references to those
    * in the shared context hash table.
    */
   bind_buffer_object( ctx, GL_ARRAY_BUFFER_ARB, 0);
   bind_buffer_object( ctx, GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
   bind_buffer_object( ctx, GL_PIXEL_PACK_BUFFER_ARB, 0);
   bind_buffer_object( ctx, GL_PIXEL_UNPACK_BUFFER_ARB, 0);
}



/**
 * Return the gl_buffer_object for the given ID.
 * Always return NULL for ID 0.
 */
struct gl_buffer_object *
_mesa_lookup_bufferobj(struct gl_context *ctx, GLuint buffer)
{
   if (buffer == 0)
      return NULL;
   else
      return (struct gl_buffer_object *)
         _mesa_HashLookup(ctx->Shared->BufferObjects, buffer);
}


struct gl_buffer_object *
_mesa_lookup_bufferobj_locked(struct gl_context *ctx, GLuint buffer)
{
   return (struct gl_buffer_object *)
      _mesa_HashLookupLocked(ctx->Shared->BufferObjects, buffer);
}


void
_mesa_begin_bufferobj_lookups(struct gl_context *ctx)
{
   _mesa_HashLockMutex(ctx->Shared->BufferObjects);
}


void
_mesa_end_bufferobj_lookups(struct gl_context *ctx)
{
   _mesa_HashUnlockMutex(ctx->Shared->BufferObjects);
}


/**
 * Look up a buffer object for a multi-bind function.
 *
 * Unlike _mesa_lookup_bufferobj(), this function also takes care
 * of generating an error if the buffer ID is not zero or the name
 * of an existing buffer object.
 *
 * If the buffer ID refers to an existing buffer object, a pointer
 * to the buffer object is returned.  If the ID is zero, a pointer
 * to the shared NullBufferObj is returned.  If the ID is not zero
 * and does not refer to a valid buffer object, this function
 * returns NULL.
 *
 * This function assumes that the caller has already locked the
 * hash table mutex by calling _mesa_begin_bufferobj_lookups().
 */
struct gl_buffer_object *
_mesa_multi_bind_lookup_bufferobj(struct gl_context *ctx,
                                  const GLuint *buffers,
                                  GLuint index, const char *caller)
{
   struct gl_buffer_object *bufObj;

   if (buffers[index] != 0) {
      bufObj = _mesa_lookup_bufferobj_locked(ctx, buffers[index]);

      /* The multi-bind functions don't create the buffer objects
         when they don't exist. */
      if (bufObj == &DummyBufferObject)
         bufObj = NULL;
   } else
      bufObj = ctx->Shared->NullBufferObj;

   if (!bufObj) {
      /* The ARB_multi_bind spec says:
       *
       *    "An INVALID_OPERATION error is generated if any value
       *     in <buffers> is not zero or the name of an existing
       *     buffer object (per binding)."
       */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(buffers[%u]=%u is not zero or the name "
                  "of an existing buffer object)",
                  caller, index, buffers[index]);
   }

   return bufObj;
}


/**
 * If *ptr points to obj, set ptr = the Null/default buffer object.
 * This is a helper for buffer object deletion.
 * The GL spec says that deleting a buffer object causes it to get
 * unbound from all arrays in the current context.
 */
static void
unbind(struct gl_context *ctx,
       struct gl_buffer_object **ptr,
       struct gl_buffer_object *obj)
{
   if (*ptr == obj) {
      _mesa_reference_buffer_object(ctx, ptr, ctx->Shared->NullBufferObj);
   }
}


/**
 * Plug default/fallback buffer object functions into the device
 * driver hooks.
 */
void
_mesa_init_buffer_object_functions(struct dd_function_table *driver)
{
   /* GL_ARB_vertex/pixel_buffer_object */
   driver->NewBufferObject = _mesa_new_buffer_object;
   driver->DeleteBuffer = _mesa_delete_buffer_object;
   driver->BufferData = _mesa_buffer_data;
   driver->BufferSubData = _mesa_buffer_subdata;
   driver->GetBufferSubData = _mesa_buffer_get_subdata;
   driver->UnmapBuffer = _mesa_buffer_unmap;

   /* GL_ARB_clear_buffer_object */
   driver->ClearBufferSubData = _mesa_buffer_clear_subdata;

   /* GL_ARB_map_buffer_range */
   driver->MapBufferRange = _mesa_buffer_map_range;
   driver->FlushMappedBufferRange = _mesa_buffer_flush_mapped_range;

   /* GL_ARB_copy_buffer */
   driver->CopyBufferSubData = _mesa_copy_buffer_subdata;
}


void
_mesa_buffer_unmap_all_mappings(struct gl_context *ctx,
                                struct gl_buffer_object *bufObj)
{
   int i;

   for (i = 0; i < MAP_COUNT; i++) {
      if (_mesa_bufferobj_mapped(bufObj, i)) {
         ctx->Driver.UnmapBuffer(ctx, bufObj, i);
         ASSERT(bufObj->Mappings[i].Pointer == NULL);
         bufObj->Mappings[i].AccessFlags = 0;
      }
   }
}


/**********************************************************************/
/* API Functions                                                      */
/**********************************************************************/

void GLAPIENTRY
_mesa_BindBuffer(GLenum target, GLuint buffer)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBindBuffer(%s, %u)\n",
                  _mesa_lookup_enum_by_nr(target), buffer);

   bind_buffer_object(ctx, target, buffer);
}


/**
 * Delete a set of buffer objects.
 * 
 * \param n      Number of buffer objects to delete.
 * \param ids    Array of \c n buffer object IDs.
 */
void GLAPIENTRY
_mesa_DeleteBuffers(GLsizei n, const GLuint *ids)
{
   GET_CURRENT_CONTEXT(ctx);
   GLsizei i;
   FLUSH_VERTICES(ctx, 0);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteBuffersARB(n)");
      return;
   }

   mtx_lock(&ctx->Shared->Mutex);

   for (i = 0; i < n; i++) {
      struct gl_buffer_object *bufObj = _mesa_lookup_bufferobj(ctx, ids[i]);
      if (bufObj) {
         struct gl_vertex_array_object *vao = ctx->Array.VAO;
         GLuint j;

         ASSERT(bufObj->Name == ids[i] || bufObj == &DummyBufferObject);

         _mesa_buffer_unmap_all_mappings(ctx, bufObj);

         /* unbind any vertex pointers bound to this buffer */
         for (j = 0; j < Elements(vao->VertexBinding); j++) {
            unbind(ctx, &vao->VertexBinding[j].BufferObj, bufObj);
         }

         if (ctx->Array.ArrayBufferObj == bufObj) {
            _mesa_BindBuffer( GL_ARRAY_BUFFER_ARB, 0 );
         }
         if (vao->IndexBufferObj == bufObj) {
            _mesa_BindBuffer( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );
         }

         /* unbind ARB_draw_indirect binding point */
         if (ctx->DrawIndirectBuffer == bufObj) {
            _mesa_BindBuffer( GL_DRAW_INDIRECT_BUFFER, 0 );
         }

         /* unbind ARB_copy_buffer binding points */
         if (ctx->CopyReadBuffer == bufObj) {
            _mesa_BindBuffer( GL_COPY_READ_BUFFER, 0 );
         }
         if (ctx->CopyWriteBuffer == bufObj) {
            _mesa_BindBuffer( GL_COPY_WRITE_BUFFER, 0 );
         }

         /* unbind transform feedback binding points */
         if (ctx->TransformFeedback.CurrentBuffer == bufObj) {
            _mesa_BindBuffer( GL_TRANSFORM_FEEDBACK_BUFFER, 0 );
         }
         for (j = 0; j < MAX_FEEDBACK_BUFFERS; j++) {
            if (ctx->TransformFeedback.CurrentObject->Buffers[j] == bufObj) {
               _mesa_BindBufferBase( GL_TRANSFORM_FEEDBACK_BUFFER, j, 0 );
            }
         }

         /* unbind UBO binding points */
         for (j = 0; j < ctx->Const.MaxUniformBufferBindings; j++) {
            if (ctx->UniformBufferBindings[j].BufferObject == bufObj) {
               _mesa_BindBufferBase( GL_UNIFORM_BUFFER, j, 0 );
            }
         }

         if (ctx->UniformBuffer == bufObj) {
            _mesa_BindBuffer( GL_UNIFORM_BUFFER, 0 );
         }

         /* unbind any pixel pack/unpack pointers bound to this buffer */
         if (ctx->Pack.BufferObj == bufObj) {
            _mesa_BindBuffer( GL_PIXEL_PACK_BUFFER_EXT, 0 );
         }
         if (ctx->Unpack.BufferObj == bufObj) {
            _mesa_BindBuffer( GL_PIXEL_UNPACK_BUFFER_EXT, 0 );
         }

         if (ctx->Texture.BufferObject == bufObj) {
            _mesa_BindBuffer( GL_TEXTURE_BUFFER, 0 );
         }

         /* The ID is immediately freed for re-use */
         _mesa_HashRemove(ctx->Shared->BufferObjects, ids[i]);
         /* Make sure we do not run into the classic ABA problem on bind.
          * We don't want to allow re-binding a buffer object that's been
          * "deleted" by glDeleteBuffers().
          *
          * The explicit rebinding to the default object in the current context
          * prevents the above in the current context, but another context
          * sharing the same objects might suffer from this problem.
          * The alternative would be to do the hash lookup in any case on bind
          * which would introduce more runtime overhead than this.
          */
         bufObj->DeletePending = GL_TRUE;
         _mesa_reference_buffer_object(ctx, &bufObj, NULL);
      }
   }

   mtx_unlock(&ctx->Shared->Mutex);
}


/**
 * Generate a set of unique buffer object IDs and store them in \c buffer.
 * 
 * \param n       Number of IDs to generate.
 * \param buffer  Array of \c n locations to store the IDs.
 */
void GLAPIENTRY
_mesa_GenBuffers(GLsizei n, GLuint *buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint first;
   GLint i;

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGenBuffers(%d)\n", n);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenBuffersARB");
      return;
   }

   if (!buffer) {
      return;
   }

   /*
    * This must be atomic (generation and allocation of buffer object IDs)
    */
   mtx_lock(&ctx->Shared->Mutex);

   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->BufferObjects, n);

   /* Insert the ID and pointer to dummy buffer object into hash table */
   for (i = 0; i < n; i++) {
      _mesa_HashInsert(ctx->Shared->BufferObjects, first + i,
                       &DummyBufferObject);
      buffer[i] = first + i;
   }

   mtx_unlock(&ctx->Shared->Mutex);
}


/**
 * Determine if ID is the name of a buffer object.
 * 
 * \param id  ID of the potential buffer object.
 * \return  \c GL_TRUE if \c id is the name of a buffer object, 
 *          \c GL_FALSE otherwise.
 */
GLboolean GLAPIENTRY
_mesa_IsBuffer(GLuint id)
{
   struct gl_buffer_object *bufObj;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   mtx_lock(&ctx->Shared->Mutex);
   bufObj = _mesa_lookup_bufferobj(ctx, id);
   mtx_unlock(&ctx->Shared->Mutex);

   return bufObj && bufObj != &DummyBufferObject;
}


void GLAPIENTRY
_mesa_BufferStorage(GLenum target, GLsizeiptr size, const GLvoid *data,
                    GLbitfield flags)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (size <= 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(size <= 0)");
      return;
   }

   if (flags & ~(GL_MAP_READ_BIT |
                 GL_MAP_WRITE_BIT |
                 GL_MAP_PERSISTENT_BIT |
                 GL_MAP_COHERENT_BIT |
                 GL_DYNAMIC_STORAGE_BIT |
                 GL_CLIENT_STORAGE_BIT)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(flags)");
      return;
   }

   if (flags & GL_MAP_PERSISTENT_BIT &&
       !(flags & (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT))) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(flags!=READ/WRITE)");
      return;
   }

   if (flags & GL_MAP_COHERENT_BIT && !(flags & GL_MAP_PERSISTENT_BIT)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(flags!=PERSISTENT)");
      return;
   }

   bufObj = get_buffer(ctx, "glBufferStorage", target, GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   if (bufObj->Immutable) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferStorage(immutable)");
      return;
   }

   /* Unmap the existing buffer.  We'll replace it now.  Not an error. */
   _mesa_buffer_unmap_all_mappings(ctx, bufObj);

   FLUSH_VERTICES(ctx, _NEW_BUFFER_OBJECT);

   bufObj->Written = GL_TRUE;
   bufObj->Immutable = GL_TRUE;

   ASSERT(ctx->Driver.BufferData);
   if (!ctx->Driver.BufferData(ctx, target, size, data, GL_DYNAMIC_DRAW,
                               flags, bufObj)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBufferStorage()");
   }
}


void GLAPIENTRY
_mesa_BufferData(GLenum target, GLsizeiptrARB size,
                    const GLvoid * data, GLenum usage)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   bool valid_usage;

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBufferData(%s, %ld, %p, %s)\n",
                  _mesa_lookup_enum_by_nr(target),
                  (long int) size, data,
                  _mesa_lookup_enum_by_nr(usage));

   if (size < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferDataARB(size < 0)");
      return;
   }

   switch (usage) {
   case GL_STREAM_DRAW_ARB:
      valid_usage = (ctx->API != API_OPENGLES);
      break;

   case GL_STATIC_DRAW_ARB:
   case GL_DYNAMIC_DRAW_ARB:
      valid_usage = true;
      break;

   case GL_STREAM_READ_ARB:
   case GL_STREAM_COPY_ARB:
   case GL_STATIC_READ_ARB:
   case GL_STATIC_COPY_ARB:
   case GL_DYNAMIC_READ_ARB:
   case GL_DYNAMIC_COPY_ARB:
      valid_usage = _mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx);
      break;

   default:
      valid_usage = false;
      break;
   }

   if (!valid_usage) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferData(usage)");
      return;
   }

   bufObj = get_buffer(ctx, "glBufferDataARB", target, GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   if (bufObj->Immutable) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferData(immutable)");
      return;
   }

   /* Unmap the existing buffer.  We'll replace it now.  Not an error. */
   _mesa_buffer_unmap_all_mappings(ctx, bufObj);

   FLUSH_VERTICES(ctx, _NEW_BUFFER_OBJECT);

   bufObj->Written = GL_TRUE;

#ifdef VBO_DEBUG
   printf("glBufferDataARB(%u, sz %ld, from %p, usage 0x%x)\n",
                bufObj->Name, size, data, usage);
#endif

#ifdef BOUNDS_CHECK
   size += 100;
#endif

   ASSERT(ctx->Driver.BufferData);
   if (!ctx->Driver.BufferData(ctx, target, size, data, usage,
                               GL_MAP_READ_BIT |
                               GL_MAP_WRITE_BIT |
                               GL_DYNAMIC_STORAGE_BIT,
                               bufObj)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBufferDataARB()");
   }
}


void GLAPIENTRY
_mesa_BufferSubData(GLenum target, GLintptrARB offset,
                       GLsizeiptrARB size, const GLvoid * data)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   bufObj = buffer_object_subdata_range_good( ctx, target, offset, size,
                                              false, GL_INVALID_OPERATION,
                                              "glBufferSubDataARB" );
   if (!bufObj) {
      /* error already recorded */
      return;
   }

   if (bufObj->Immutable &&
       !(bufObj->StorageFlags & GL_DYNAMIC_STORAGE_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferSubData");
      return;
   }

   if (size == 0)
      return;

   bufObj->Written = GL_TRUE;

   ASSERT(ctx->Driver.BufferSubData);
   ctx->Driver.BufferSubData( ctx, offset, size, data, bufObj );
}


void GLAPIENTRY
_mesa_GetBufferSubData(GLenum target, GLintptrARB offset,
                          GLsizeiptrARB size, void * data)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   bufObj = buffer_object_subdata_range_good(ctx, target, offset, size,
                                             false, GL_INVALID_OPERATION,
                                             "glGetBufferSubDataARB");
   if (!bufObj) {
      /* error already recorded */
      return;
   }

   ASSERT(ctx->Driver.GetBufferSubData);
   ctx->Driver.GetBufferSubData( ctx, offset, size, data, bufObj );
}


void GLAPIENTRY
_mesa_ClearBufferData(GLenum target, GLenum internalformat, GLenum format,
                      GLenum type, const GLvoid* data)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object* bufObj;
   mesa_format mesaFormat;
   GLubyte clearValue[MAX_PIXEL_BYTES];
   GLsizeiptr clearValueSize;

   bufObj = get_buffer(ctx, "glClearBufferData", target, GL_INVALID_VALUE);
   if (!bufObj) {
      return;
   }

   if (_mesa_check_disallowed_mapping(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glClearBufferData(buffer currently mapped)");
      return;
   }

   mesaFormat = validate_clear_buffer_format(ctx, internalformat,
                                             format, type,
                                             "glClearBufferData");
   if (mesaFormat == MESA_FORMAT_NONE) {
      return;
   }

   clearValueSize = _mesa_get_format_bytes(mesaFormat);
   if (bufObj->Size % clearValueSize != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glClearBufferData(size is not a multiple of "
                  "internalformat size)");
      return;
   }

   if (data == NULL) {
      /* clear to zeros, per the spec */
      ctx->Driver.ClearBufferSubData(ctx, 0, bufObj->Size,
                                     NULL, clearValueSize, bufObj);
      return;
   }

   if (!convert_clear_buffer_data(ctx, mesaFormat, clearValue,
                                  format, type, data, "glClearBufferData")) {
      return;
   }

   ctx->Driver.ClearBufferSubData(ctx, 0, bufObj->Size,
                                  clearValue, clearValueSize, bufObj);
}


void GLAPIENTRY
_mesa_ClearBufferSubData(GLenum target, GLenum internalformat,
                         GLintptr offset, GLsizeiptr size,
                         GLenum format, GLenum type,
                         const GLvoid* data)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object* bufObj;
   mesa_format mesaFormat;
   GLubyte clearValue[MAX_PIXEL_BYTES];
   GLsizeiptr clearValueSize;

   bufObj = buffer_object_subdata_range_good(ctx, target, offset, size,
                                             true, GL_INVALID_VALUE,
                                             "glClearBufferSubData");
   if (!bufObj) {
      return;
   }

   mesaFormat = validate_clear_buffer_format(ctx, internalformat,
                                             format, type,
                                             "glClearBufferSubData");
   if (mesaFormat == MESA_FORMAT_NONE) {
      return;
   }

   clearValueSize = _mesa_get_format_bytes(mesaFormat);
   if (offset % clearValueSize != 0 || size % clearValueSize != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glClearBufferSubData(offset or size is not a multiple of "
                  "internalformat size)");
      return;
   }

   if (data == NULL) {
      /* clear to zeros, per the spec */
      if (size > 0) {
         ctx->Driver.ClearBufferSubData(ctx, offset, size,
                                        NULL, clearValueSize, bufObj);
      }
      return;
   }

   if (!convert_clear_buffer_data(ctx, mesaFormat, clearValue,
                                  format, type, data,
                                  "glClearBufferSubData")) {
      return;
   }

   if (size > 0) {
      ctx->Driver.ClearBufferSubData(ctx, offset, size,
                                     clearValue, clearValueSize, bufObj);
   }
}


void * GLAPIENTRY
_mesa_MapBuffer(GLenum target, GLenum access)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object * bufObj;
   GLbitfield accessFlags;
   void *map;
   bool valid_access;

   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, NULL);

   switch (access) {
   case GL_READ_ONLY_ARB:
      accessFlags = GL_MAP_READ_BIT;
      valid_access = _mesa_is_desktop_gl(ctx);
      break;
   case GL_WRITE_ONLY_ARB:
      accessFlags = GL_MAP_WRITE_BIT;
      valid_access = true;
      break;
   case GL_READ_WRITE_ARB:
      accessFlags = GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
      valid_access = _mesa_is_desktop_gl(ctx);
      break;
   default:
      valid_access = false;
      break;
   }

   if (!valid_access) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glMapBufferARB(access)");
      return NULL;
   }

   bufObj = get_buffer(ctx, "glMapBufferARB", target, GL_INVALID_OPERATION);
   if (!bufObj)
      return NULL;

   if (accessFlags & GL_MAP_READ_BIT &&
       !(bufObj->StorageFlags & GL_MAP_READ_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBuffer(invalid read flag)");
      return NULL;
   }

   if (accessFlags & GL_MAP_WRITE_BIT &&
       !(bufObj->StorageFlags & GL_MAP_WRITE_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBuffer(invalid write flag)");
      return NULL;
   }

   if (_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMapBufferARB(already mapped)");
      return NULL;
   }

   if (!bufObj->Size) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glMapBuffer(buffer size = 0)");
      return NULL;
   }

   ASSERT(ctx->Driver.MapBufferRange);
   map = ctx->Driver.MapBufferRange(ctx, 0, bufObj->Size, accessFlags, bufObj,
                                    MAP_USER);
   if (!map) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMapBufferARB(map failed)");
      return NULL;
   }
   else {
      /* The driver callback should have set these fields.
       * This is important because other modules (like VBO) might call
       * the driver function directly.
       */
      ASSERT(bufObj->Mappings[MAP_USER].Pointer == map);
      ASSERT(bufObj->Mappings[MAP_USER].Length == bufObj->Size);
      ASSERT(bufObj->Mappings[MAP_USER].Offset == 0);
      bufObj->Mappings[MAP_USER].AccessFlags = accessFlags;
   }

   if (access == GL_WRITE_ONLY_ARB || access == GL_READ_WRITE_ARB)
      bufObj->Written = GL_TRUE;

#ifdef VBO_DEBUG
   printf("glMapBufferARB(%u, sz %ld, access 0x%x)\n",
	  bufObj->Name, bufObj->Size, access);
   if (access == GL_WRITE_ONLY_ARB) {
      GLuint i;
      GLubyte *b = (GLubyte *) bufObj->Pointer;
      for (i = 0; i < bufObj->Size; i++)
         b[i] = i & 0xff;
   }
#endif

#ifdef BOUNDS_CHECK
   {
      GLubyte *buf = (GLubyte *) bufObj->Pointer;
      GLuint i;
      /* buffer is 100 bytes larger than requested, fill with magic value */
      for (i = 0; i < 100; i++) {
         buf[bufObj->Size - i - 1] = 123;
      }
   }
#endif

   return bufObj->Mappings[MAP_USER].Pointer;
}


GLboolean GLAPIENTRY
_mesa_UnmapBuffer(GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   GLboolean status = GL_TRUE;
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   bufObj = get_buffer(ctx, "glUnmapBufferARB", target, GL_INVALID_OPERATION);
   if (!bufObj)
      return GL_FALSE;

   if (!_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUnmapBufferARB");
      return GL_FALSE;
   }

#ifdef BOUNDS_CHECK
   if (bufObj->Access != GL_READ_ONLY_ARB) {
      GLubyte *buf = (GLubyte *) bufObj->Pointer;
      GLuint i;
      /* check that last 100 bytes are still = magic value */
      for (i = 0; i < 100; i++) {
         GLuint pos = bufObj->Size - i - 1;
         if (buf[pos] != 123) {
            _mesa_warning(ctx, "Out of bounds buffer object write detected"
                          " at position %d (value = %u)\n",
                          pos, buf[pos]);
         }
      }
   }
#endif

#ifdef VBO_DEBUG
   if (bufObj->AccessFlags & GL_MAP_WRITE_BIT) {
      GLuint i, unchanged = 0;
      GLubyte *b = (GLubyte *) bufObj->Pointer;
      GLint pos = -1;
      /* check which bytes changed */
      for (i = 0; i < bufObj->Size - 1; i++) {
         if (b[i] == (i & 0xff) && b[i+1] == ((i+1) & 0xff)) {
            unchanged++;
            if (pos == -1)
               pos = i;
         }
      }
      if (unchanged) {
         printf("glUnmapBufferARB(%u): %u of %ld unchanged, starting at %d\n",
                      bufObj->Name, unchanged, bufObj->Size, pos);
      }
   }
#endif

   status = ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_USER);
   bufObj->Mappings[MAP_USER].AccessFlags = 0;
   ASSERT(bufObj->Mappings[MAP_USER].Pointer == NULL);
   ASSERT(bufObj->Mappings[MAP_USER].Offset == 0);
   ASSERT(bufObj->Mappings[MAP_USER].Length == 0);

   return status;
}


void GLAPIENTRY
_mesa_GetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   bufObj = get_buffer(ctx, "glGetBufferParameterivARB", target,
                       GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   switch (pname) {
   case GL_BUFFER_SIZE_ARB:
      *params = (GLint) bufObj->Size;
      return;
   case GL_BUFFER_USAGE_ARB:
      *params = bufObj->Usage;
      return;
   case GL_BUFFER_ACCESS_ARB:
      *params = simplified_access_mode(ctx,
                            bufObj->Mappings[MAP_USER].AccessFlags);
      return;
   case GL_BUFFER_MAPPED_ARB:
      *params = _mesa_bufferobj_mapped(bufObj, MAP_USER);
      return;
   case GL_BUFFER_ACCESS_FLAGS:
      if (!ctx->Extensions.ARB_map_buffer_range)
         goto invalid_pname;
      *params = bufObj->Mappings[MAP_USER].AccessFlags;
      return;
   case GL_BUFFER_MAP_OFFSET:
      if (!ctx->Extensions.ARB_map_buffer_range)
         goto invalid_pname;
      *params = (GLint) bufObj->Mappings[MAP_USER].Offset;
      return;
   case GL_BUFFER_MAP_LENGTH:
      if (!ctx->Extensions.ARB_map_buffer_range)
         goto invalid_pname;
      *params = (GLint) bufObj->Mappings[MAP_USER].Length;
      return;
   case GL_BUFFER_IMMUTABLE_STORAGE:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->Immutable;
      return;
   case GL_BUFFER_STORAGE_FLAGS:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->StorageFlags;
      return;
   default:
      ; /* fall-through */
   }

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameterivARB(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
}


/**
 * New in GL 3.2
 * This is pretty much a duplicate of GetBufferParameteriv() but the
 * GL_BUFFER_SIZE_ARB attribute will be 64-bits on a 64-bit system.
 */
void GLAPIENTRY
_mesa_GetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   bufObj = get_buffer(ctx, "glGetBufferParameteri64v", target,
                       GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   switch (pname) {
   case GL_BUFFER_SIZE_ARB:
      *params = bufObj->Size;
      return;
   case GL_BUFFER_USAGE_ARB:
      *params = bufObj->Usage;
      return;
   case GL_BUFFER_ACCESS_ARB:
      *params = simplified_access_mode(ctx,
                             bufObj->Mappings[MAP_USER].AccessFlags);
      return;
   case GL_BUFFER_ACCESS_FLAGS:
      if (!ctx->Extensions.ARB_map_buffer_range)
         goto invalid_pname;
      *params = bufObj->Mappings[MAP_USER].AccessFlags;
      return;
   case GL_BUFFER_MAPPED_ARB:
      *params = _mesa_bufferobj_mapped(bufObj, MAP_USER);
      return;
   case GL_BUFFER_MAP_OFFSET:
      if (!ctx->Extensions.ARB_map_buffer_range)
         goto invalid_pname;
      *params = bufObj->Mappings[MAP_USER].Offset;
      return;
   case GL_BUFFER_MAP_LENGTH:
      if (!ctx->Extensions.ARB_map_buffer_range)
         goto invalid_pname;
      *params = bufObj->Mappings[MAP_USER].Length;
      return;
   case GL_BUFFER_IMMUTABLE_STORAGE:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->Immutable;
      return;
   case GL_BUFFER_STORAGE_FLAGS:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->StorageFlags;
      return;
   default:
      ; /* fall-through */
   }

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameteri64v(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
}


void GLAPIENTRY
_mesa_GetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object * bufObj;

   if (pname != GL_BUFFER_MAP_POINTER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferPointervARB(pname)");
      return;
   }

   bufObj = get_buffer(ctx, "glGetBufferPointervARB", target,
                       GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   *params = bufObj->Mappings[MAP_USER].Pointer;
}


void GLAPIENTRY
_mesa_CopyBufferSubData(GLenum readTarget, GLenum writeTarget,
                        GLintptr readOffset, GLintptr writeOffset,
                        GLsizeiptr size)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *src, *dst;

   src = get_buffer(ctx, "glCopyBufferSubData", readTarget,
                    GL_INVALID_OPERATION);
   if (!src)
      return;

   dst = get_buffer(ctx, "glCopyBufferSubData", writeTarget,
                    GL_INVALID_OPERATION);
   if (!dst)
      return;

   if (_mesa_check_disallowed_mapping(src)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyBufferSubData(readBuffer is mapped)");
      return;
   }

   if (_mesa_check_disallowed_mapping(dst)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyBufferSubData(writeBuffer is mapped)");
      return;
   }

   if (readOffset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBufferSubData(readOffset = %d)", (int) readOffset);
      return;
   }

   if (writeOffset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBufferSubData(writeOffset = %d)", (int) writeOffset);
      return;
   }

   if (size < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBufferSubData(writeOffset = %d)", (int) size);
      return;
   }

   if (readOffset + size > src->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBufferSubData(readOffset + size = %d)",
                  (int) (readOffset + size));
      return;
   }

   if (writeOffset + size > dst->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBufferSubData(writeOffset + size = %d)",
                  (int) (writeOffset + size));
      return;
   }

   if (src == dst) {
      if (readOffset + size <= writeOffset) {
         /* OK */
      }
      else if (writeOffset + size <= readOffset) {
         /* OK */
      }
      else {
         /* overlapping src/dst is illegal */
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyBufferSubData(overlapping src/dst)");
         return;
      }
   }

   ctx->Driver.CopyBufferSubData(ctx, src, dst, readOffset, writeOffset, size);
}


/**
 * See GL_ARB_map_buffer_range spec
 */
void * GLAPIENTRY
_mesa_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length,
                     GLbitfield access)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   void *map;
   GLbitfield allowed_access;

   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, NULL);

   if (!ctx->Extensions.ARB_map_buffer_range) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(extension not supported)");
      return NULL;
   }

   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset = %ld)", (long)offset);
      return NULL;
   }

   if (length < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(length = %ld)", (long)length);
      return NULL;
   }

   /* Page 38 of the PDF of the OpenGL ES 3.0 spec says:
    *
    *     "An INVALID_OPERATION error is generated for any of the following
    *     conditions:
    *
    *     * <length> is zero."
    */
   if (_mesa_is_gles(ctx) && length == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(length = 0)");
      return NULL;
   }

   allowed_access = GL_MAP_READ_BIT |
                    GL_MAP_WRITE_BIT |
                    GL_MAP_INVALIDATE_RANGE_BIT |
                    GL_MAP_INVALIDATE_BUFFER_BIT |
                    GL_MAP_FLUSH_EXPLICIT_BIT |
                    GL_MAP_UNSYNCHRONIZED_BIT;

   if (ctx->Extensions.ARB_buffer_storage) {
         allowed_access |= GL_MAP_PERSISTENT_BIT |
                           GL_MAP_COHERENT_BIT;
   }

   if (access & ~allowed_access) {
      /* generate an error if any other than allowed bit is set */
      _mesa_error(ctx, GL_INVALID_VALUE, "glMapBufferRange(access)");
      return NULL;
   }

   if ((access & (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT)) == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(access indicates neither read or write)");
      return NULL;
   }

   if ((access & GL_MAP_READ_BIT) &&
       (access & (GL_MAP_INVALIDATE_RANGE_BIT |
                  GL_MAP_INVALIDATE_BUFFER_BIT |
                  GL_MAP_UNSYNCHRONIZED_BIT))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid access flags)");
      return NULL;
   }

   if ((access & GL_MAP_FLUSH_EXPLICIT_BIT) &&
       ((access & GL_MAP_WRITE_BIT) == 0)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid access flags)");
      return NULL;
   }

   bufObj = get_buffer(ctx, "glMapBufferRange", target, GL_INVALID_OPERATION);
   if (!bufObj)
      return NULL;

   if (access & GL_MAP_READ_BIT &&
       !(bufObj->StorageFlags & GL_MAP_READ_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid read flag)");
      return NULL;
   }

   if (access & GL_MAP_WRITE_BIT &&
       !(bufObj->StorageFlags & GL_MAP_WRITE_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid write flag)");
      return NULL;
   }

   if (access & GL_MAP_COHERENT_BIT &&
       !(bufObj->StorageFlags & GL_MAP_COHERENT_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid coherent flag)");
      return NULL;
   }

   if (access & GL_MAP_PERSISTENT_BIT &&
       !(bufObj->StorageFlags & GL_MAP_PERSISTENT_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid persistent flag)");
      return NULL;
   }

   if (offset + length > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset + length > size)");
      return NULL;
   }

   if (_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(buffer already mapped)");
      return NULL;
   }

   if (!bufObj->Size) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glMapBufferRange(buffer size = 0)");
      return NULL;
   }

   /* Mapping zero bytes should return a non-null pointer. */
   if (!length) {
      static long dummy = 0;
      bufObj->Mappings[MAP_USER].Pointer = &dummy;
      bufObj->Mappings[MAP_USER].Length = length;
      bufObj->Mappings[MAP_USER].Offset = offset;
      bufObj->Mappings[MAP_USER].AccessFlags = access;
      return bufObj->Mappings[MAP_USER].Pointer;
   }

   ASSERT(ctx->Driver.MapBufferRange);
   map = ctx->Driver.MapBufferRange(ctx, offset, length, access, bufObj,
                                    MAP_USER);
   if (!map) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMapBufferARB(map failed)");
   }
   else {
      /* The driver callback should have set all these fields.
       * This is important because other modules (like VBO) might call
       * the driver function directly.
       */
      ASSERT(bufObj->Mappings[MAP_USER].Pointer == map);
      ASSERT(bufObj->Mappings[MAP_USER].Length == length);
      ASSERT(bufObj->Mappings[MAP_USER].Offset == offset);
      ASSERT(bufObj->Mappings[MAP_USER].AccessFlags == access);
   }

   return map;
}


/**
 * See GL_ARB_map_buffer_range spec
 */
void GLAPIENTRY
_mesa_FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (!ctx->Extensions.ARB_map_buffer_range) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFlushMappedBufferRange(extension not supported)");
      return;
   }

   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glFlushMappedBufferRange(offset = %ld)", (long)offset);
      return;
   }

   if (length < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glFlushMappedBufferRange(length = %ld)", (long)length);
      return;
   }

   bufObj = get_buffer(ctx, "glFlushMappedBufferRange", target,
                       GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   if (!_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
      /* buffer is not mapped */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFlushMappedBufferRange(buffer is not mapped)");
      return;
   }

   if ((bufObj->Mappings[MAP_USER].AccessFlags &
        GL_MAP_FLUSH_EXPLICIT_BIT) == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFlushMappedBufferRange(GL_MAP_FLUSH_EXPLICIT_BIT not set)");
      return;
   }

   if (offset + length > bufObj->Mappings[MAP_USER].Length) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glFlushMappedBufferRange(offset %ld + length %ld > mapped length %ld)",
		  (long)offset, (long)length,
                  (long)bufObj->Mappings[MAP_USER].Length);
      return;
   }

   ASSERT(bufObj->Mappings[MAP_USER].AccessFlags & GL_MAP_WRITE_BIT);

   if (ctx->Driver.FlushMappedBufferRange)
      ctx->Driver.FlushMappedBufferRange(ctx, offset, length, bufObj,
                                         MAP_USER);
}


static GLenum
buffer_object_purgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_buffer_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_bufferobj(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectPurgeable(name = 0x%x)", name);
      return 0;
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glObjectPurgeable(buffer 0)" );
      return 0;
   }

   if (bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectPurgeable(name = 0x%x) is already purgeable", name);
      return GL_VOLATILE_APPLE;
   }

   bufObj->Purgeable = GL_TRUE;

   retval = GL_VOLATILE_APPLE;
   if (ctx->Driver.BufferObjectPurgeable)
      retval = ctx->Driver.BufferObjectPurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
renderbuffer_purgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_renderbuffer *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_renderbuffer(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectPurgeable(name = 0x%x) is already purgeable", name);
      return GL_VOLATILE_APPLE;
   }

   bufObj->Purgeable = GL_TRUE;

   retval = GL_VOLATILE_APPLE;
   if (ctx->Driver.RenderObjectPurgeable)
      retval = ctx->Driver.RenderObjectPurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
texture_object_purgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_texture_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_texture(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectPurgeable(name = 0x%x)", name);
      return 0;
   }

   if (bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectPurgeable(name = 0x%x) is already purgeable", name);
      return GL_VOLATILE_APPLE;
   }

   bufObj->Purgeable = GL_TRUE;

   retval = GL_VOLATILE_APPLE;
   if (ctx->Driver.TextureObjectPurgeable)
      retval = ctx->Driver.TextureObjectPurgeable(ctx, bufObj, option);

   return retval;
}


GLenum GLAPIENTRY
_mesa_ObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   GLenum retval;

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectPurgeable(name = 0x%x)", name);
      return 0;
   }

   switch (option) {
   case GL_VOLATILE_APPLE:
   case GL_RELEASED_APPLE:
      /* legal */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectPurgeable(name = 0x%x) invalid option: %d",
                  name, option);
      return 0;
   }

   switch (objectType) {
   case GL_TEXTURE:
      retval = texture_object_purgeable(ctx, name, option);
      break;
   case GL_RENDERBUFFER_EXT:
      retval = renderbuffer_purgeable(ctx, name, option);
      break;
   case GL_BUFFER_OBJECT_APPLE:
      retval = buffer_object_purgeable(ctx, name, option);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectPurgeable(name = 0x%x) invalid type: %d",
                  name, objectType);
      return 0;
   }

   /* In strict conformance to the spec, we must only return VOLATILE when
    * when passed the VOLATILE option. Madness.
    *
    * XXX First fix the spec, then fix me.
    */
   return option == GL_VOLATILE_APPLE ? GL_VOLATILE_APPLE : retval;
}


static GLenum
buffer_object_unpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_buffer_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_bufferobj(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (! bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectUnpurgeable(name = 0x%x) object is "
                  " already \"unpurged\"", name);
      return 0;
   }

   bufObj->Purgeable = GL_FALSE;

   retval = option;
   if (ctx->Driver.BufferObjectUnpurgeable)
      retval = ctx->Driver.BufferObjectUnpurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
renderbuffer_unpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_renderbuffer *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_renderbuffer(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (! bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectUnpurgeable(name = 0x%x) object is "
                  " already \"unpurged\"", name);
      return 0;
   }

   bufObj->Purgeable = GL_FALSE;

   retval = option;
   if (ctx->Driver.RenderObjectUnpurgeable)
      retval = ctx->Driver.RenderObjectUnpurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
texture_object_unpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_texture_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_texture(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (! bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectUnpurgeable(name = 0x%x) object is"
                  " already \"unpurged\"", name);
      return 0;
   }

   bufObj->Purgeable = GL_FALSE;

   retval = option;
   if (ctx->Driver.TextureObjectUnpurgeable)
      retval = ctx->Driver.TextureObjectUnpurgeable(ctx, bufObj, option);

   return retval;
}


GLenum GLAPIENTRY
_mesa_ObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   switch (option) {
   case GL_RETAINED_APPLE:
   case GL_UNDEFINED_APPLE:
      /* legal */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectUnpurgeable(name = 0x%x) invalid option: %d",
                  name, option);
      return 0;
   }

   switch (objectType) {
   case GL_BUFFER_OBJECT_APPLE:
      return buffer_object_unpurgeable(ctx, name, option);
   case GL_TEXTURE:
      return texture_object_unpurgeable(ctx, name, option);
   case GL_RENDERBUFFER_EXT:
      return renderbuffer_unpurgeable(ctx, name, option);
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectUnpurgeable(name = 0x%x) invalid type: %d",
                  name, objectType);
      return 0;
   }
}


static void
get_buffer_object_parameteriv(struct gl_context *ctx, GLuint name,
                              GLenum pname, GLint *params)
{
   struct gl_buffer_object *bufObj = _mesa_lookup_bufferobj(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glGetObjectParameteriv(name = 0x%x) invalid object", name);
      return;
   }

   switch (pname) {
   case GL_PURGEABLE_APPLE:
      *params = bufObj->Purgeable;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid enum: %d",
                  name, pname);
      break;
   }
}


static void
get_renderbuffer_parameteriv(struct gl_context *ctx, GLuint name,
                             GLenum pname, GLint *params)
{
   struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, name);
   if (!rb) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return;
   }

   switch (pname) {
   case GL_PURGEABLE_APPLE:
      *params = rb->Purgeable;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid enum: %d",
                  name, pname);
      break;
   }
}


static void
get_texture_object_parameteriv(struct gl_context *ctx, GLuint name,
                               GLenum pname, GLint *params)
{
   struct gl_texture_object *texObj = _mesa_lookup_texture(ctx, name);
   if (!texObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return;
   }

   switch (pname) {
   case GL_PURGEABLE_APPLE:
      *params = texObj->Purgeable;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid enum: %d",
                  name, pname);
      break;
   }
}


void GLAPIENTRY
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname,
                                GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glGetObjectParameteriv(name = 0x%x)", name);
      return;
   }

   switch (objectType) {
   case GL_TEXTURE:
      get_texture_object_parameteriv(ctx, name, pname, params);
      break;
   case GL_BUFFER_OBJECT_APPLE:
      get_buffer_object_parameteriv(ctx, name, pname, params);
      break;
   case GL_RENDERBUFFER_EXT:
      get_renderbuffer_parameteriv(ctx, name, pname, params);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid type: %d",
                  name, objectType);
   }
}

/**
 * Binds a buffer object to a uniform buffer binding point.
 *
 * The caller is responsible for flushing vertices and updating
 * NewDriverState.
 */
static void
set_ubo_binding(struct gl_context *ctx,
                struct gl_uniform_buffer_binding *binding,
                struct gl_buffer_object *bufObj,
                GLintptr offset,
                GLsizeiptr size,
                GLboolean autoSize)
{
   _mesa_reference_buffer_object(ctx, &binding->BufferObject, bufObj);

   binding->Offset = offset;
   binding->Size = size;
   binding->AutomaticSize = autoSize;
}

/**
 * Binds a buffer object to a uniform buffer binding point.
 *
 * Unlike set_ubo_binding(), this function also flushes vertices
 * and updates NewDriverState.  It also checks if the binding
 * has actually changed before updating it.
 */
static void
bind_uniform_buffer(struct gl_context *ctx,
                    GLuint index,
                    struct gl_buffer_object *bufObj,
                    GLintptr offset,
                    GLsizeiptr size,
                    GLboolean autoSize)
{
   struct gl_uniform_buffer_binding *binding =
      &ctx->UniformBufferBindings[index];

   if (binding->BufferObject == bufObj &&
       binding->Offset == offset &&
       binding->Size == size &&
       binding->AutomaticSize == autoSize) {
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

   set_ubo_binding(ctx, binding, bufObj, offset, size, autoSize);
}

/**
 * Bind a region of a buffer object to a uniform block binding point.
 * \param index  the uniform buffer binding point index
 * \param bufObj  the buffer object
 * \param offset  offset to the start of buffer object region
 * \param size  size of the buffer object region
 */
static void
bind_buffer_range_uniform_buffer(struct gl_context *ctx,
				 GLuint index,
				 struct gl_buffer_object *bufObj,
				 GLintptr offset,
				 GLsizeiptr size)
{
   if (index >= ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(index=%d)", index);
      return;
   }

   if (offset & (ctx->Const.UniformBufferOffsetAlignment - 1)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferRange(offset misalgned %d/%d)", (int) offset,
		  ctx->Const.UniformBufferOffsetAlignment);
      return;
   }

   if (bufObj == ctx->Shared->NullBufferObj) {
      offset = -1;
      size = -1;
   }

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer, bufObj);
   bind_uniform_buffer(ctx, index, bufObj, offset, size, GL_FALSE);
}


/**
 * Bind a buffer object to a uniform block binding point.
 * As above, but offset = 0.
 */
static void
bind_buffer_base_uniform_buffer(struct gl_context *ctx,
				GLuint index,
				struct gl_buffer_object *bufObj)
{
   if (index >= ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferBase(index=%d)", index);
      return;
   }

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer, bufObj);

   if (bufObj == ctx->Shared->NullBufferObj)
      bind_uniform_buffer(ctx, index, bufObj, -1, -1, GL_TRUE);
   else
      bind_uniform_buffer(ctx, index, bufObj, 0, 0, GL_TRUE);
}

/**
 * Binds a buffer object to an atomic buffer binding point.
 *
 * The caller is responsible for validating the offset,
 * flushing the vertices and updating NewDriverState.
 */
static void
set_atomic_buffer_binding(struct gl_context *ctx,
                          struct gl_atomic_buffer_binding *binding,
                          struct gl_buffer_object *bufObj,
                          GLintptr offset,
                          GLsizeiptr size)
{
   _mesa_reference_buffer_object(ctx, &binding->BufferObject, bufObj);

   if (bufObj == ctx->Shared->NullBufferObj) {
      binding->Offset = -1;
      binding->Size = -1;
   } else {
      binding->Offset = offset;
      binding->Size = size;
   }
}

/**
 * Binds a buffer object to an atomic buffer binding point.
 *
 * Unlike set_atomic_buffer_binding(), this function also validates the
 * index and offset, flushes vertices, and updates NewDriverState.
 * It also checks if the binding has actually changing before
 * updating it.
 */
static void
bind_atomic_buffer(struct gl_context *ctx,
                   unsigned index,
                   struct gl_buffer_object *bufObj,
                   GLintptr offset,
                   GLsizeiptr size,
                   const char *name)
{
   struct gl_atomic_buffer_binding *binding;

   if (index >= ctx->Const.MaxAtomicBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%d)", name, index);
      return;
   }

   if (offset & (ATOMIC_COUNTER_SIZE - 1)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(offset misalgned %d/%d)", name, (int) offset,
                  ATOMIC_COUNTER_SIZE);
      return;
   }

   _mesa_reference_buffer_object(ctx, &ctx->AtomicBuffer, bufObj);

   binding = &ctx->AtomicBufferBindings[index];
   if (binding->BufferObject == bufObj &&
       binding->Offset == offset &&
       binding->Size == size) {
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewAtomicBuffer;

   set_atomic_buffer_binding(ctx, binding, bufObj, offset, size);
}

static inline bool
bind_buffers_check_offset_and_size(struct gl_context *ctx,
                                   GLuint index,
                                   const GLintptr *offsets,
                                   const GLsizeiptr *sizes)
{
   if (offsets[index] < 0) {
     /* The ARB_multi_bind spec says:
      *
      *    "An INVALID_VALUE error is generated by BindBuffersRange if any
      *     value in <offsets> is less than zero (per binding)."
      */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBuffersRange(offsets[%u]=%lld < 0)",
                  index, (long long int) offsets[index]);
      return false;
   }

   if (sizes[index] <= 0) {
     /* The ARB_multi_bind spec says:
      *
      *     "An INVALID_VALUE error is generated by BindBuffersRange if any
      *      value in <sizes> is less than or equal to zero (per binding)."
      */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBuffersRange(sizes[%u]=%lld <= 0)",
                  index, (long long int) sizes[index]);
      return false;
   }

   return true;
}

static bool
error_check_bind_uniform_buffers(struct gl_context *ctx,
                                 GLuint first, GLsizei count,
                                 const char *caller)
{
   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(target=GL_UNIFORM_BUFFER)", caller);
      return false;
   }

   /* The ARB_multi_bind_spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count> is
    *      greater than the number of target-specific indexed binding points,
    *      as described in section 6.7.1."
    */
   if (first + count > ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(first=%u + count=%d > the value of "
                  "GL_MAX_UNIFORM_BUFFER_BINDINGS=%u)",
                  caller, first, count,
                  ctx->Const.MaxUniformBufferBindings);
      return false;
   }

   return true;
}

/**
 * Unbind all uniform buffers in the range
 * <first> through <first>+<count>-1
 */
static void
unbind_uniform_buffers(struct gl_context *ctx, GLuint first, GLsizei count)
{
   struct gl_buffer_object *bufObj = ctx->Shared->NullBufferObj;
   GLuint i;

   for (i = 0; i < count; i++)
      set_ubo_binding(ctx, &ctx->UniformBufferBindings[first + i],
                      bufObj, -1, -1, GL_TRUE);
}

static void
bind_uniform_buffers_base(struct gl_context *ctx, GLuint first, GLsizei count,
                          const GLuint *buffers)
{
   GLuint i;

   if (!error_check_bind_uniform_buffers(ctx, first, count, "glBindBuffersBase"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *   "If <buffers> is NULL, all bindings from <first> through
       *    <first>+<count>-1 are reset to their unbound (zero) state."
       */
      unbind_uniform_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_uniform_buffer_binding *binding =
          &ctx->UniformBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersBase");

      if (bufObj) {
         if (bufObj == ctx->Shared->NullBufferObj)
            set_ubo_binding(ctx, binding, bufObj, -1, -1, GL_TRUE);
         else
            set_ubo_binding(ctx, binding, bufObj, 0, 0, GL_TRUE);
      }
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static void
bind_uniform_buffers_range(struct gl_context *ctx, GLuint first, GLsizei count,
                           const GLuint *buffers,
                           const GLintptr *offsets, const GLsizeiptr *sizes)
{
   GLuint i;

   if (!error_check_bind_uniform_buffers(ctx, first, count,
                                         "glBindBuffersRange"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, all bindings from <first> through
       *     <first>+<count>-1 are reset to their unbound (zero) state.
       *     In this case, the offsets and sizes associated with the
       *     binding points are set to default values, ignoring
       *     <offsets> and <sizes>."
       */
      unbind_uniform_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_uniform_buffer_binding *binding =
         &ctx->UniformBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (!bind_buffers_check_offset_and_size(ctx, i, offsets, sizes))
         continue;

      /* The ARB_multi_bind spec says:
       *
       *     "An INVALID_VALUE error is generated by BindBuffersRange if any
       *      pair of values in <offsets> and <sizes> does not respectively
       *      satisfy the constraints described for those parameters for the
       *      specified target, as described in section 6.7.1 (per binding)."
       *
       * Section 6.7.1 refers to table 6.5, which says:
       *
       *     "
       *       Uniform buffer array bindings (see sec. 7.6)                  
       *      
       *        ...                  ...                                    
       *        offset restriction   multiple of value of UNIFORM_BUFFER_-  
       *                             OFFSET_ALIGNMENT                       
       *        ...                  ...                                    
       *        size restriction     none                                   
       *      "
       */
      if (offsets[i] & (ctx->Const.UniformBufferOffsetAlignment - 1)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of the value of "
                     "GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT=%u when "
                     "target=GL_UNIFORM_BUFFER)",
                     i, (long long int) offsets[i],
                     ctx->Const.UniformBufferOffsetAlignment);
         continue;
      }

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersRange");

      if (bufObj) {
         if (bufObj == ctx->Shared->NullBufferObj)
            set_ubo_binding(ctx, binding, bufObj, -1, -1, GL_FALSE);
         else
            set_ubo_binding(ctx, binding, bufObj,
                            offsets[i], sizes[i], GL_FALSE);
      }
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static bool
error_check_bind_xfb_buffers(struct gl_context *ctx,
                             struct gl_transform_feedback_object *tfObj,
                             GLuint first, GLsizei count, const char *caller)
{
   if (!ctx->Extensions.EXT_transform_feedback) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(target=GL_TRANSFORM_FEEDBACK_BUFFER)", caller);
      return false;
   }

   /* Page 398 of the PDF of the OpenGL 4.4 (Core Profile) spec says:
    *
    *     "An INVALID_OPERATION error is generated :
    *
    *     ...
    *      by BindBufferRange or BindBufferBase if target is TRANSFORM_-
    *       FEEDBACK_BUFFER and transform feedback is currently active."
    *
    * We assume that this is also meant to apply to BindBuffersRange
    * and BindBuffersBase.
    */
   if (tfObj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(Changing transform feedback buffers while "
                  "transform feedback is active)", caller);
      return false;
   }

   /* The ARB_multi_bind_spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count> is
    *      greater than the number of target-specific indexed binding points,
    *      as described in section 6.7.1."
    */
   if (first + count > ctx->Const.MaxTransformFeedbackBuffers) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(first=%u + count=%d > the value of "
                  "GL_MAX_TRANSFORM_FEEDBACK_BUFFERS=%u)",
                  caller, first, count,
                  ctx->Const.MaxTransformFeedbackBuffers);
      return false;
   }

   return true;
}

/**
 * Unbind all transform feedback buffers in the range
 * <first> through <first>+<count>-1
 */
static void
unbind_xfb_buffers(struct gl_context *ctx,
                   struct gl_transform_feedback_object *tfObj,
                   GLuint first, GLsizei count)
{
   struct gl_buffer_object * const bufObj = ctx->Shared->NullBufferObj;
   GLuint i;

   for (i = 0; i < count; i++)
      _mesa_set_transform_feedback_binding(ctx, tfObj, first + i,
                                           bufObj, 0, 0);
}

static void
bind_xfb_buffers_base(struct gl_context *ctx,
                      GLuint first, GLsizei count,
                      const GLuint *buffers)
{
   struct gl_transform_feedback_object *tfObj =
      ctx->TransformFeedback.CurrentObject;
   GLuint i;

   if (!error_check_bind_xfb_buffers(ctx, tfObj, first, count,
                                     "glBindBuffersBase"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *   "If <buffers> is NULL, all bindings from <first> through
       *    <first>+<count>-1 are reset to their unbound (zero) state."
       */
      unbind_xfb_buffers(ctx, tfObj, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_buffer_object * const boundBufObj = tfObj->Buffers[first + i];
      struct gl_buffer_object *bufObj;

      if (boundBufObj && boundBufObj->Name == buffers[i])
         bufObj = boundBufObj;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersBase");

      if (bufObj)
         _mesa_set_transform_feedback_binding(ctx, tfObj, first + i,
                                              bufObj, 0, 0);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static void
bind_xfb_buffers_range(struct gl_context *ctx,
                       GLuint first, GLsizei count,
                       const GLuint *buffers,
                       const GLintptr *offsets,
                       const GLsizeiptr *sizes)
{
   struct gl_transform_feedback_object *tfObj =
       ctx->TransformFeedback.CurrentObject;
   GLuint i;

   if (!error_check_bind_xfb_buffers(ctx, tfObj, first, count,
                                     "glBindBuffersRange"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, all bindings from <first> through
       *     <first>+<count>-1 are reset to their unbound (zero) state.
       *     In this case, the offsets and sizes associated with the
       *     binding points are set to default values, ignoring
       *     <offsets> and <sizes>."
       */
      unbind_xfb_buffers(ctx, tfObj, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      const GLuint index = first + i;
      struct gl_buffer_object * const boundBufObj = tfObj->Buffers[index];
      struct gl_buffer_object *bufObj;

      if (!bind_buffers_check_offset_and_size(ctx, i, offsets, sizes))
         continue;

      /* The ARB_multi_bind spec says:
       *
       *     "An INVALID_VALUE error is generated by BindBuffersRange if any
       *      pair of values in <offsets> and <sizes> does not respectively
       *      satisfy the constraints described for those parameters for the
       *      specified target, as described in section 6.7.1 (per binding)."
       *
       * Section 6.7.1 refers to table 6.5, which says:
       *
       *     "
       *       Transform feedback array bindings (see sec. 13.2.2)           
       *      
       *          ...                    ...                                
       *          offset restriction     multiple of 4                      
       *          ...                    ...                                
       *          size restriction       multiple of 4                      
       *      "
       */
      if (offsets[i] & 0x3) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
                     "target=GL_TRANSFORM_FEEDBACK_BUFFER)",
                     i, (long long int) offsets[i]);
         continue;
      }

      if (sizes[i] & 0x3) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(sizes[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
                     "target=GL_TRANSFORM_FEEDBACK_BUFFER)",
                     i, (long long int) sizes[i]);
         continue;
      }

      if (boundBufObj && boundBufObj->Name == buffers[i])
         bufObj = boundBufObj;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersRange");

      if (bufObj)
         _mesa_set_transform_feedback_binding(ctx, tfObj, index, bufObj,
                                              offsets[i], sizes[i]);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static bool
error_check_bind_atomic_buffers(struct gl_context *ctx,
                                GLuint first, GLsizei count,
                                const char *caller)
{
   if (!ctx->Extensions.ARB_shader_atomic_counters) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(target=GL_ATOMIC_COUNTER_BUFFER)", caller);
      return false;
   }

   /* The ARB_multi_bind_spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count> is
    *      greater than the number of target-specific indexed binding points,
    *      as described in section 6.7.1."
    */
   if (first + count > ctx->Const.MaxAtomicBufferBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(first=%u + count=%d > the value of "
                  "GL_MAX_ATOMIC_BUFFER_BINDINGS=%u)",
                  caller, first, count, ctx->Const.MaxAtomicBufferBindings);
      return false;
   }

   return true;
}

/**
 * Unbind all atomic counter buffers in the range
 * <first> through <first>+<count>-1
 */
static void
unbind_atomic_buffers(struct gl_context *ctx, GLuint first, GLsizei count)
{
   struct gl_buffer_object * const bufObj = ctx->Shared->NullBufferObj;
   GLuint i;

   for (i = 0; i < count; i++)
      set_atomic_buffer_binding(ctx, &ctx->AtomicBufferBindings[first + i],
                                bufObj, -1, -1);
}

static void
bind_atomic_buffers_base(struct gl_context *ctx,
                         GLuint first,
                         GLsizei count,
                         const GLuint *buffers)
{
   GLuint i;

   if (!error_check_bind_atomic_buffers(ctx, first, count,
                                        "glBindBuffersBase"))
     return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewAtomicBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *   "If <buffers> is NULL, all bindings from <first> through
       *    <first>+<count>-1 are reset to their unbound (zero) state."
       */
      unbind_atomic_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_atomic_buffer_binding *binding =
         &ctx->AtomicBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersBase");

      if (bufObj)
         set_atomic_buffer_binding(ctx, binding, bufObj, 0, 0);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static void
bind_atomic_buffers_range(struct gl_context *ctx,
                          GLuint first,
                          GLsizei count,
                          const GLuint *buffers,
                          const GLintptr *offsets,
                          const GLsizeiptr *sizes)
{
   GLuint i;

   if (!error_check_bind_atomic_buffers(ctx, first, count,
                                        "glBindBuffersRange"))
     return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewAtomicBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, all bindings from <first> through
       *     <first>+<count>-1 are reset to their unbound (zero) state.
       *     In this case, the offsets and sizes associated with the
       *     binding points are set to default values, ignoring
       *     <offsets> and <sizes>."
       */
      unbind_atomic_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_atomic_buffer_binding *binding =
         &ctx->AtomicBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (!bind_buffers_check_offset_and_size(ctx, i, offsets, sizes))
         continue;

      /* The ARB_multi_bind spec says:
       *
       *     "An INVALID_VALUE error is generated by BindBuffersRange if any
       *      pair of values in <offsets> and <sizes> does not respectively
       *      satisfy the constraints described for those parameters for the
       *      specified target, as described in section 6.7.1 (per binding)."
       *
       * Section 6.7.1 refers to table 6.5, which says:
       *
       *     "
       *       Atomic counter array bindings (see sec. 7.7.2)                
       *      
       *          ...                    ...                                
       *          offset restriction     multiple of 4                      
       *          ...                    ...                                
       *          size restriction       none                               
       *      "
       */
      if (offsets[i] & (ATOMIC_COUNTER_SIZE - 1)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of %d when "
                     "target=GL_ATOMIC_COUNTER_BUFFER)",
                     i, (long long int) offsets[i], ATOMIC_COUNTER_SIZE);
         continue;
      }

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersRange");

      if (bufObj)
         set_atomic_buffer_binding(ctx, binding, bufObj, offsets[i], sizes[i]);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

void GLAPIENTRY
_mesa_BindBufferRange(GLenum target, GLuint index,
                      GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (buffer == 0) {
      bufObj = ctx->Shared->NullBufferObj;
   } else {
      bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   }
   if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
                                     &bufObj, "glBindBufferRange"))
      return;

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferRange(invalid buffer=%u)", buffer);
      return;
   }

   if (buffer != 0) {
      if (size <= 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(size=%d)",
                     (int) size);
         return;
      }
   }

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      _mesa_bind_buffer_range_transform_feedback(ctx, index, bufObj,
						 offset, size);
      return;
   case GL_UNIFORM_BUFFER:
      bind_buffer_range_uniform_buffer(ctx, index, bufObj, offset, size);
      return;
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffer(ctx, index, bufObj, offset, size,
                         "glBindBufferRange");
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferRange(target)");
      return;
   }
}

void GLAPIENTRY
_mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (buffer == 0) {
      bufObj = ctx->Shared->NullBufferObj;
   } else {
      bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   }
   if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
                                     &bufObj, "glBindBufferBase"))
      return;

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferBase(invalid buffer=%u)", buffer);
      return;
   }

   /* Note that there's some oddness in the GL 3.1-GL 3.3 specifications with
    * regards to BindBufferBase.  It says (GL 3.1 core spec, page 63):
    *
    *     "BindBufferBase is equivalent to calling BindBufferRange with offset
    *      zero and size equal to the size of buffer."
    *
    * but it says for glGetIntegeri_v (GL 3.1 core spec, page 230):
    *
    *     "If the parameter (starting offset or size) was not specified when the
    *      buffer object was bound, zero is returned."
    *
    * What happens if the size of the buffer changes?  Does the size of the
    * buffer at the moment glBindBufferBase was called still play a role, like
    * the first quote would imply, or is the size meaningless in the
    * glBindBufferBase case like the second quote would suggest?  The GL 4.1
    * core spec page 45 says:
    *
    *     "It is equivalent to calling BindBufferRange with offset zero, while
    *      size is determined by the size of the bound buffer at the time the
    *      binding is used."
    *
    * My interpretation is that the GL 4.1 spec was a clarification of the
    * behavior, not a change.  In particular, this choice will only make
    * rendering work in cases where it would have had undefined results.
    */

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      _mesa_bind_buffer_base_transform_feedback(ctx, index, bufObj);
      return;
   case GL_UNIFORM_BUFFER:
      bind_buffer_base_uniform_buffer(ctx, index, bufObj);
      return;
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffer(ctx, index, bufObj, 0, 0,
                         "glBindBufferBase");
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferBase(target)");
      return;
   }
}

void GLAPIENTRY
_mesa_BindBuffersRange(GLenum target, GLuint first, GLsizei count,
                       const GLuint *buffers,
                       const GLintptr *offsets, const GLsizeiptr *sizes)
{
   GET_CURRENT_CONTEXT(ctx);

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      bind_xfb_buffers_range(ctx, first, count, buffers, offsets, sizes);
      return;
   case GL_UNIFORM_BUFFER:
      bind_uniform_buffers_range(ctx, first, count, buffers, offsets, sizes);
      return;
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffers_range(ctx, first, count, buffers,
                                offsets, sizes);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBuffersRange(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
      break;
   }
}

void GLAPIENTRY
_mesa_BindBuffersBase(GLenum target, GLuint first, GLsizei count,
                      const GLuint *buffers)
{
   GET_CURRENT_CONTEXT(ctx);

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      bind_xfb_buffers_base(ctx, first, count, buffers);
      return;
   case GL_UNIFORM_BUFFER:
      bind_uniform_buffers_base(ctx, first, count, buffers);
      return;
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffers_base(ctx, first, count, buffers);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBuffersBase(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
      break;
   }
}

void GLAPIENTRY
_mesa_InvalidateBufferSubData(GLuint buffer, GLintptr offset,
                              GLsizeiptr length)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   const GLintptr end = offset + length;

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glInvalidateBufferSubData(name = 0x%x) invalid object",
                  buffer);
      return;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "An INVALID_VALUE error is generated if <offset> or <length> is
    *     negative, or if <offset> + <length> is greater than the value of
    *     BUFFER_SIZE."
    */
   if (end < 0 || end > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glInvalidateBufferSubData(invalid offset or length)");
      return;
   }

   /* The OpenGL 4.4 (Core Profile) spec says:
    *
    *     "An INVALID_OPERATION error is generated if buffer is currently
    *     mapped by MapBuffer or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange, unless it was mapped
    *     with MAP_PERSISTENT_BIT set in the MapBufferRange access flags."
    */
   if (!(bufObj->Mappings[MAP_USER].AccessFlags & GL_MAP_PERSISTENT_BIT) &&
       bufferobj_range_mapped(bufObj, offset, length)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glInvalidateBufferSubData(intersection with mapped "
                  "range)");
      return;
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}

void GLAPIENTRY
_mesa_InvalidateBufferData(GLuint buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glInvalidateBufferData(name = 0x%x) invalid object",
                  buffer);
      return;
   }

   /* The OpenGL 4.4 (Core Profile) spec says:
    *
    *     "An INVALID_OPERATION error is generated if buffer is currently
    *     mapped by MapBuffer or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange, unless it was mapped
    *     with MAP_PERSISTENT_BIT set in the MapBufferRange access flags."
    */
   if (_mesa_check_disallowed_mapping(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glInvalidateBufferData(intersection with mapped "
                  "range)");
      return;
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a33 1
#include <inttypes.h>  /* for PRId64 macro */
d391 1
a391 1
_mesa_new_buffer_object(struct gl_context *ctx, GLuint name)
d398 1
a398 1
   _mesa_initialize_buffer_object(ctx, obj, name);
d496 3
a498 3
_mesa_initialize_buffer_object(struct gl_context *ctx,
                               struct gl_buffer_object *obj,
                               GLuint name)
d500 2
a834 3
   _mesa_reference_buffer_object(ctx, &ctx->AtomicBuffer,
				 ctx->Shared->NullBufferObj);

a844 8

   for (i = 0; i < MAX_COMBINED_ATOMIC_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->AtomicBufferBindings[i].BufferObject,
				    ctx->Shared->NullBufferObj);
      ctx->AtomicBufferBindings[i].Offset = -1;
      ctx->AtomicBufferBindings[i].Size = -1;
   }
a859 2
   _mesa_reference_buffer_object(ctx, &ctx->AtomicBuffer, NULL);

a866 7

   for (i = 0; i < MAX_COMBINED_ATOMIC_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->AtomicBufferBindings[i].BufferObject,
				    NULL);
   }

d888 1
a888 1
      buf = ctx->Driver.NewBufferObject(ctx, buffer);
a1202 11
         /* unbind Atomci Buffer binding points */
         for (j = 0; j < ctx->Const.MaxAtomicBufferBindings; j++) {
            if (ctx->AtomicBufferBindings[j].BufferObject == bufObj) {
               _mesa_BindBufferBase( GL_ATOMIC_COUNTER_BUFFER, j, 0 );
            }
         }

         if (ctx->UniformBuffer == bufObj) {
            _mesa_BindBuffer( GL_ATOMIC_COUNTER_BUFFER, 0 );
         }

a2622 6

   /* If this is a real buffer object, mark it has having been used
    * at some point as a UBO.
    */
   if (size >= 0)
      bufObj->UsageHistory |= USAGE_UNIFORM_BUFFER;
d2677 1
a2677 1
                  "glBindBufferRange(offset misaligned %d/%d)", (int) offset,
a2734 1
      bufObj->UsageHistory |= USAGE_ATOMIC_COUNTER_BUFFER;
d2763 1
a2763 1
                  "%s(offset misaligned %d/%d)", name, (int) offset,
d2796 2
a2797 2
                  "glBindBuffersRange(offsets[%u]=%" PRId64 " < 0)",
                  index, (int64_t) offsets[index]);
d2808 2
a2809 2
                  "glBindBuffersRange(sizes[%u]=%" PRId64 " <= 0)",
                  index, (int64_t) sizes[index]);
d3004 2
a3005 2
                     "glBindBuffersRange(offsets[%u]=%" PRId64
                     " is misaligned; it must be a multiple of the value of "
d3008 1
a3008 1
                     i, (int64_t) offsets[i],
d3242 2
a3243 2
                     "glBindBuffersRange(offsets[%u]=%" PRId64
                     " is misaligned; it must be a multiple of 4 when "
d3245 1
a3245 1
                     i, (int64_t) offsets[i]);
d3251 2
a3252 2
                     "glBindBuffersRange(sizes[%u]=%" PRId64
                     " is misaligned; it must be a multiple of 4 when "
d3254 1
a3254 1
                     i, (int64_t) sizes[i]);
d3460 2
a3461 2
                     "glBindBuffersRange(offsets[%u]=%" PRId64
                     " is misaligned; it must be a multiple of %d when "
d3463 1
a3463 1
                     i, (int64_t) offsets[i], ATOMIC_COUNTER_SIZE);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d34 1
d392 1
a392 1
_mesa_new_buffer_object( struct gl_context *ctx, GLuint name, GLenum target )
d399 1
a399 1
   _mesa_initialize_buffer_object(ctx, obj, name, target);
d497 3
a499 3
_mesa_initialize_buffer_object( struct gl_context *ctx,
				struct gl_buffer_object *obj,
				GLuint name, GLenum target )
a500 2
   (void) target;

d834 3
d847 8
d870 2
d879 7
d907 1
a907 1
      buf = ctx->Driver.NewBufferObject(ctx, buffer, target);
d1222 11
d2653 6
d2713 1
a2713 1
                  "glBindBufferRange(offset misalgned %d/%d)", (int) offset,
d2771 1
d2800 1
a2800 1
                  "%s(offset misalgned %d/%d)", name, (int) offset,
d2833 2
a2834 2
                  "glBindBuffersRange(offsets[%u]=%lld < 0)",
                  index, (long long int) offsets[index]);
d2845 2
a2846 2
                  "glBindBuffersRange(sizes[%u]=%lld <= 0)",
                  index, (long long int) sizes[index]);
d3041 2
a3042 2
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of the value of "
d3045 1
a3045 1
                     i, (long long int) offsets[i],
d3279 2
a3280 2
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
d3282 1
a3282 1
                     i, (long long int) offsets[i]);
d3288 2
a3289 2
                     "glBindBuffersRange(sizes[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
d3291 1
a3291 1
                     i, (long long int) sizes[i]);
d3497 2
a3498 2
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of %d when "
d3500 1
a3500 1
                     i, (long long int) offsets[i], ATOMIC_COUNTER_SIZE);
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d44 3
d83 1
a83 1
      return &ctx->Array.ArrayObj->ElementArrayBufferObj;
d92 6
d114 5
d130 1
d135 2
a136 1
get_buffer(struct gl_context *ctx, const char *func, GLenum target)
d146 1
a146 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(buffer 0)", func);
d194 30
d225 2
a226 1
 * \c glBufferSubDataARB and \c glGetBufferSubDataARB.
d232 3
d238 1
a238 2
 *           conditions for \c glBufferSubDataARB or \c glGetBufferSubDataARB
 *           are invalid.
d240 1
a240 1
 * \sa glBufferSubDataARB, glGetBufferSubDataARB
d243 4
a246 3
buffer_object_subdata_range_good( struct gl_context * ctx, GLenum target, 
                                  GLintptrARB offset, GLsizeiptrARB size,
                                  const char *caller )
d260 1
a260 1
   bufObj = get_buffer(ctx, caller, target);
d266 1
a266 1
		  "%s(offset %lu + size %lu > buffer size %lu)", caller,
d272 15
a286 4
   if (_mesa_bufferobj_mapped(bufObj)) {
      /* Buffer is currently mapped */
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
      return NULL;
d294 92
d414 1
a414 1
   free(bufObj->Data);
d420 2
a421 1
   _glthread_DESTROY_MUTEX(bufObj->Mutex);
d442 1
a442 1
      _glthread_LOCK_MUTEX(oldObj->Mutex);
d450 1
a450 1
      _glthread_UNLOCK_MUTEX(oldObj->Mutex);
d458 2
a459 2
	 ASSERT(ctx->Array.ArrayObj->ElementArrayBufferObj != bufObj);
	 ASSERT(ctx->Array.ArrayObj->Vertex.BufferObj != bufObj);
d472 1
a472 1
      _glthread_LOCK_MUTEX(bufObj->Mutex);
d487 1
a487 1
      _glthread_UNLOCK_MUTEX(bufObj->Mutex);
d503 1
a503 1
   _glthread_INIT_MUTEX(obj->Mutex);
a506 1
   obj->AccessFlags = 0;
d561 1
a561 1
		   const GLvoid * data, GLenum usage,
d566 3
a568 1
   (void) ctx; (void) target;
d570 1
a570 1
   new_data = _mesa_realloc( bufObj->Data, bufObj->Size, size );
d575 1
a597 1
 * \param target  Buffer object target on which to operate.
d652 54
d712 2
a713 1
                        struct gl_buffer_object *bufObj )
d716 1
a716 1
   assert(!_mesa_bufferobj_mapped(bufObj));
d718 5
a722 5
   bufObj->Pointer = bufObj->Data + offset;
   bufObj->Length = length;
   bufObj->Offset = offset;
   bufObj->AccessFlags = access;
   return bufObj->Pointer;
d733 2
a734 1
                                 struct gl_buffer_object *obj )
d752 2
a753 1
_mesa_buffer_unmap( struct gl_context *ctx, struct gl_buffer_object *bufObj )
d757 4
a760 4
   bufObj->Pointer = NULL;
   bufObj->Length = 0;
   bufObj->Offset = 0;
   bufObj->AccessFlags = 0x0;
a777 4
   /* the buffers should not be mapped */
   assert(!_mesa_bufferobj_mapped(src));
   assert(!_mesa_bufferobj_mapped(dst));

d781 2
a782 1
						   GL_MAP_WRITE_BIT, src);
d791 2
a792 1
					  GL_MAP_READ_BIT, src);
d795 2
a796 1
					   GL_MAP_INVALIDATE_RANGE_BIT), dst);
d805 1
a805 1
   ctx->Driver.UnmapBuffer(ctx, src);
d807 1
a807 1
      ctx->Driver.UnmapBuffer(ctx, dst);
d821 1
a821 1
   _glthread_INIT_MUTEX(DummyBufferObject.Mutex);
d835 3
d860 2
d869 6
a874 5
static bool
handle_bind_buffer_gen(struct gl_context *ctx,
		       GLenum target,
		       GLuint buffer,
		       struct gl_buffer_object **buf_handle)
d879 1
a879 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBindBuffer(non-gen name)");
d890 1
a890 1
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindBufferARB");
d934 2
a935 1
      if (!handle_bind_buffer_gen(ctx, target, buffer, &newBufObj))
a940 4

   /* Pass BindBuffer call to device driver */
   if (ctx->Driver.BindBuffer)
      ctx->Driver.BindBuffer( ctx, target, newBufObj );
d978 72
a1076 1
   driver->BindBuffer = NULL;
d1082 3
d1094 15
d1145 1
a1145 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1150 1
a1150 1
         struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d1155 1
a1155 6
         if (_mesa_bufferobj_mapped(bufObj)) {
            /* if mapped, unmap it now */
            ctx->Driver.UnmapBuffer(ctx, bufObj);
            bufObj->AccessFlags = 0;
            bufObj->Pointer = NULL;
         }
d1158 2
a1159 2
         for (j = 0; j < Elements(arrayObj->VertexAttrib); j++) {
            unbind(ctx, &arrayObj->VertexAttrib[j].BufferObj, bufObj);
d1165 1
a1165 1
         if (arrayObj->ElementArrayBufferObj == bufObj) {
d1169 5
d1232 1
a1232 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1264 1
a1264 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1275 1
a1275 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1293 1
a1293 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1295 1
a1295 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1302 58
d1407 1
a1407 1
   bufObj = get_buffer(ctx, "glBufferDataARB", target);
d1411 7
a1417 6
   if (_mesa_bufferobj_mapped(bufObj)) {
      /* Unmap the existing buffer.  We'll replace it now.  Not an error. */
      ctx->Driver.UnmapBuffer(ctx, bufObj);
      bufObj->AccessFlags = 0;
      ASSERT(bufObj->Pointer == NULL);
   }  
d1433 5
a1437 1
   if (!ctx->Driver.BufferData( ctx, target, size, data, usage, bufObj )) {
d1451 1
d1458 6
d1481 3
a1483 2
   bufObj = buffer_object_subdata_range_good( ctx, target, offset, size,
                                              "glGetBufferSubDataARB" );
d1494 109
d1637 1
a1637 1
   bufObj = get_buffer(ctx, "glMapBufferARB", target);
d1641 15
a1655 1
   if (_mesa_bufferobj_mapped(bufObj)) {
d1667 2
a1668 1
   map = ctx->Driver.MapBufferRange(ctx, 0, bufObj->Size, accessFlags, bufObj);
d1678 4
a1681 4
      ASSERT(bufObj->Pointer == map);
      ASSERT(bufObj->Length == bufObj->Size);
      ASSERT(bufObj->Offset == 0);
      bufObj->AccessFlags = accessFlags;
d1709 1
a1709 1
   return bufObj->Pointer;
d1721 1
a1721 1
   bufObj = get_buffer(ctx, "glUnmapBufferARB", target);
d1725 1
a1725 1
   if (!_mesa_bufferobj_mapped(bufObj)) {
d1766 5
a1770 5
   status = ctx->Driver.UnmapBuffer( ctx, bufObj );
   bufObj->AccessFlags = 0;
   ASSERT(bufObj->Pointer == NULL);
   ASSERT(bufObj->Offset == 0);
   ASSERT(bufObj->Length == 0);
d1782 2
a1783 1
   bufObj = get_buffer(ctx, "glGetBufferParameterivARB", target);
d1795 2
a1796 1
      *params = simplified_access_mode(ctx, bufObj->AccessFlags);
d1799 1
a1799 1
      *params = _mesa_bufferobj_mapped(bufObj);
d1804 1
a1804 1
      *params = bufObj->AccessFlags;
d1809 1
a1809 1
      *params = (GLint) bufObj->Offset;
d1814 11
a1824 1
      *params = (GLint) bufObj->Length;
d1847 2
a1848 1
   bufObj = get_buffer(ctx, "glGetBufferParameteri64v", target);
d1860 2
a1861 1
      *params = simplified_access_mode(ctx, bufObj->AccessFlags);
d1866 1
a1866 1
      *params = bufObj->AccessFlags;
d1869 1
a1869 1
      *params = _mesa_bufferobj_mapped(bufObj);
d1874 1
a1874 1
      *params = bufObj->Offset;
d1879 11
a1889 1
      *params = bufObj->Length;
d1912 2
a1913 1
   bufObj = get_buffer(ctx, "glGetBufferPointervARB", target);
d1917 1
a1917 1
   *params = bufObj->Pointer;
d1929 2
a1930 1
   src = get_buffer(ctx, "glCopyBufferSubData", readTarget);
d1934 2
a1935 1
   dst = get_buffer(ctx, "glCopyBufferSubData", writeTarget);
d1939 1
a1939 1
   if (_mesa_bufferobj_mapped(src)) {
d1945 1
a1945 1
   if (_mesa_bufferobj_mapped(dst)) {
d2012 1
d2047 14
a2060 7
   if (access & ~(GL_MAP_READ_BIT |
                  GL_MAP_WRITE_BIT |
                  GL_MAP_INVALIDATE_RANGE_BIT |
                  GL_MAP_INVALIDATE_BUFFER_BIT |
                  GL_MAP_FLUSH_EXPLICIT_BIT |
                  GL_MAP_UNSYNCHRONIZED_BIT)) {
      /* generate an error if any undefind bit is set */
d2087 1
a2087 1
   bufObj = get_buffer(ctx, "glMapBufferRange", target);
d2091 4
a2094 3
   if (offset + length > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset + length > size)");
d2098 2
a2099 1
   if (_mesa_bufferobj_mapped(bufObj)) {
d2101 27
a2127 1
                  "glMapBufferRange(buffer already mapped)");
d2140 5
a2144 5
      bufObj->Pointer = &dummy;
      bufObj->Length = length;
      bufObj->Offset = offset;
      bufObj->AccessFlags = access;
      return bufObj->Pointer;
d2148 2
a2149 1
   map = ctx->Driver.MapBufferRange(ctx, offset, length, access, bufObj);
d2158 4
a2161 4
      ASSERT(bufObj->Pointer == map);
      ASSERT(bufObj->Length == length);
      ASSERT(bufObj->Offset == offset);
      ASSERT(bufObj->AccessFlags == access);
d2195 2
a2196 1
   bufObj = get_buffer(ctx, "glFlushMappedBufferRange", target);
d2200 1
a2200 1
   if (!_mesa_bufferobj_mapped(bufObj)) {
d2207 2
a2208 1
   if ((bufObj->AccessFlags & GL_MAP_FLUSH_EXPLICIT_BIT) == 0) {
d2214 1
a2214 1
   if (offset + length > bufObj->Length) {
d2217 2
a2218 1
		  (long)offset, (long)length, (long)bufObj->Length);
d2222 1
a2222 1
   ASSERT(bufObj->AccessFlags & GL_MAP_WRITE_BIT);
d2225 2
a2226 1
      ctx->Driver.FlushMappedBufferRange(ctx, offset, length, bufObj);
d2604 6
d2612 27
a2638 5
		int index,
		struct gl_buffer_object *bufObj,
		GLintptr offset,
		GLsizeiptr size,
		GLboolean autoSize)
d2640 2
a2641 1
   struct gl_uniform_buffer_binding *binding;
a2642 1
   binding = &ctx->UniformBufferBindings[index];
d2653 1
a2653 4
   _mesa_reference_buffer_object(ctx, &binding->BufferObject, bufObj);
   binding->Offset = offset;
   binding->Size = size;
   binding->AutomaticSize = autoSize;
d2688 1
a2688 1
   set_ubo_binding(ctx, index, bufObj, offset, size, GL_FALSE);
d2707 1
d2709 1
a2709 1
      set_ubo_binding(ctx, index, bufObj, -1, -1, GL_TRUE);
d2711 767
a3477 1
      set_ubo_binding(ctx, index, bufObj, 0, 0, GL_TRUE);
d3492 2
a3493 1
   if (!handle_bind_buffer_gen(ctx, target, buffer, &bufObj))
d3518 4
d3539 2
a3540 1
   if (!handle_bind_buffer_gen(ctx, target, buffer, &bufObj))
d3582 4
d3593 48
d3668 1
a3668 1
   /* The GL_ARB_invalidate_subdata spec says:
d3670 11
a3680 21
    *     "An INVALID_OPERATION error is generated if the buffer is currently
    *     mapped by MapBuffer, or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange."
    */
   if (_mesa_bufferobj_mapped(bufObj)) {
      const GLintptr mapEnd = bufObj->Offset + bufObj->Length;

      /* The regions do not overlap if and only if the end of the discard
       * region is before the mapped region or the start of the discard region
       * is after the mapped region.
       *
       * Note that 'end' and 'mapEnd' are the first byte *after* the discard
       * region and the mapped region, repsectively.  It is okay for that byte
       * to be mapped (for 'end') or discarded (for 'mapEnd').
       */
      if (!(end <= bufObj->Offset || offset >= mapEnd)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glInvalidateBufferSubData(intersection with mapped "
                     "range)");
         return;
      }
d3703 1
a3703 1
   /* The GL_ARB_invalidate_subdata spec says:
d3705 4
a3708 3
    *     "An INVALID_OPERATION error is generated if the buffer is currently
    *     mapped by MapBuffer, or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange."
d3710 1
a3710 1
   if (_mesa_bufferobj_mapped(bufObj)) {
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d33 1
a33 1

a41 1
#include "mfeatures.h"
d44 2
a52 7
#if FEATURE_OES_mapbuffer
#define DEFAULT_ACCESS GL_MAP_WRITE_BIT
#else
#define DEFAULT_ACCESS (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT)
#endif


d67 1
a67 1
static INLINE struct gl_buffer_object **
d70 6
d80 1
a80 1
      return &ctx->Array.ElementArrayBufferObj;
a88 1
#if FEATURE_EXT_transform_feedback
a93 1
#endif
d95 2
a96 1
      if (ctx->Extensions.ARB_texture_buffer_object) {
d100 5
d119 2
a120 2
static INLINE struct gl_buffer_object *
get_buffer(struct gl_context *ctx, GLenum target)
d123 12
a134 3
   if (bufObj)
      return *bufObj;
   return NULL;
d143 1
a143 1
simplified_access_mode(GLbitfield access)
d152 22
a173 1
   return GL_READ_WRITE; /* this should never happen, but no big deal */
d210 2
a211 3
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", caller);
d213 1
a213 5
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
      return NULL;
   }
d216 4
a219 1
		  "%s(size + offset > buffer size)", caller);
d245 1
a245 1
   _mesa_initialize_buffer_object(obj, name, target);
d261 1
a261 2
   if (bufObj->Data)
      free(bufObj->Data);
d275 2
d279 3
a281 3
_mesa_reference_buffer_object(struct gl_context *ctx,
                              struct gl_buffer_object **ptr,
                              struct gl_buffer_object *bufObj)
a282 3
   if (*ptr == bufObj)
      return;

d304 1
a304 1
	 ASSERT(ctx->Array.ElementArrayBufferObj != bufObj);
d342 2
a343 1
_mesa_initialize_buffer_object( struct gl_buffer_object *obj,
d353 31
a383 1
   obj->AccessFlags = DEFAULT_ACCESS;
d451 1
a451 1
_mesa_buffer_subdata( struct gl_context *ctx, GLenum target, GLintptrARB offset,
d455 1
a455 1
   (void) ctx; (void) target;
d484 1
a484 2
_mesa_buffer_get_subdata( struct gl_context *ctx,
                          GLenum target, GLintptrARB offset,
d488 1
a488 1
   (void) ctx; (void) target;
a496 33
 * Default callback for \c dd_function_tabel::MapBuffer().
 *
 * The function parameters will have been already tested for errors.
 *
 * \param ctx     GL context.
 * \param target  Buffer object target on which to operate.
 * \param access  Information about how the buffer will be accessed.
 * \param bufObj  Object to be mapped.
 * \return  A pointer to the object's internal data store that can be accessed
 *          by the processor
 *
 * \sa glMapBufferARB, dd_function_table::MapBuffer
 */
static void *
_mesa_buffer_map( struct gl_context *ctx, GLenum target, GLenum access,
		  struct gl_buffer_object *bufObj )
{
   (void) ctx;
   (void) target;
   (void) access;
   /* Just return a direct pointer to the data */
   if (_mesa_bufferobj_mapped(bufObj)) {
      /* already mapped! */
      return NULL;
   }
   bufObj->Pointer = bufObj->Data;
   bufObj->Length = bufObj->Size;
   bufObj->Offset = 0;
   return bufObj->Pointer;
}


/**
d501 1
a501 1
_mesa_buffer_map_range( struct gl_context *ctx, GLenum target, GLintptr offset,
a505 1
   (void) target;
d521 1
a521 1
_mesa_buffer_flush_mapped_range( struct gl_context *ctx, GLenum target, 
a525 1
   (void) target;
d541 1
a541 2
_mesa_buffer_unmap( struct gl_context *ctx, GLenum target,
                    struct gl_buffer_object *bufObj )
a543 1
   (void) target;
d555 1
a555 1
 * Called via glCopyBuffserSubData().
d566 1
a566 1
   /* buffer should not already be mapped */
d570 17
a586 4
   srcPtr = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_COPY_READ_BUFFER,
                                              GL_READ_ONLY, src);
   dstPtr = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_COPY_WRITE_BUFFER,
                                              GL_WRITE_ONLY, dst);
d588 3
d592 1
a592 1
      memcpy(dstPtr + writeOffset, srcPtr + readOffset, size);
d594 3
a596 2
   ctx->Driver.UnmapBuffer(ctx, GL_COPY_READ_BUFFER, src);
   ctx->Driver.UnmapBuffer(ctx, GL_COPY_WRITE_BUFFER, dst);
d607 2
a614 2
   _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj,
                                 ctx->Shared->NullBufferObj);
d620 11
d637 2
a639 1
   _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj, NULL);
d643 8
d653 29
d702 1
a702 1
   if (oldBufObj && oldBufObj->Name == buffer)
d717 2
a718 12
      if (!newBufObj || newBufObj == &DummyBufferObject) {
         /* If this is a new buffer object id, or one which was generated but
          * never used before, allocate a buffer object now.
          */
         ASSERT(ctx->Driver.NewBufferObject);
         newBufObj = ctx->Driver.NewBufferObject(ctx, buffer, target);
         if (!newBufObj) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindBufferARB");
            return;
         }
         _mesa_HashInsert(ctx->Shared->BufferObjects, buffer, newBufObj);
      }
a794 1
   driver->MapBuffer = _mesa_buffer_map;
d812 1
a812 1
_mesa_BindBufferARB(GLenum target, GLuint buffer)
a814 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d831 1
a831 1
_mesa_DeleteBuffersARB(GLsizei n, const GLuint *ids)
a834 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d854 2
a855 2
            ctx->Driver.UnmapBuffer(ctx, 0, bufObj);
            bufObj->AccessFlags = DEFAULT_ACCESS;
a859 11
         unbind(ctx, &arrayObj->Vertex.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Weight.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Normal.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Color.BufferObj, bufObj);
         unbind(ctx, &arrayObj->SecondaryColor.BufferObj, bufObj);
         unbind(ctx, &arrayObj->FogCoord.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Index.BufferObj, bufObj);
         unbind(ctx, &arrayObj->EdgeFlag.BufferObj, bufObj);
         for (j = 0; j < Elements(arrayObj->TexCoord); j++) {
            unbind(ctx, &arrayObj->TexCoord[j].BufferObj, bufObj);
         }
d865 1
a865 1
            _mesa_BindBufferARB( GL_ARRAY_BUFFER_ARB, 0 );
d867 31
a897 2
         if (ctx->Array.ElementArrayBufferObj == bufObj) {
            _mesa_BindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );
d902 1
a902 1
            _mesa_BindBufferARB( GL_PIXEL_PACK_BUFFER_EXT, 0 );
d905 5
a909 1
            _mesa_BindBufferARB( GL_PIXEL_UNPACK_BUFFER_EXT, 0 );
d914 11
d940 1
a940 1
_mesa_GenBuffersARB(GLsizei n, GLuint *buffer)
a944 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d984 1
a984 1
_mesa_IsBufferARB(GLuint id)
d999 1
a999 1
_mesa_BufferDataARB(GLenum target, GLsizeiptrARB size,
d1004 1
a1004 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1019 8
a1028 1
   case GL_STATIC_DRAW_ARB:
a1030 1
   case GL_DYNAMIC_DRAW_ARB:
d1033 1
a1033 1
      /* OK */
d1035 1
d1037 2
a1038 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferDataARB(usage)");
      return;
d1041 2
a1042 3
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferDataARB(target)" );
d1045 3
a1047 2
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferDataARB(buffer 0)" );
d1049 1
a1049 2
   }
   
d1052 2
a1053 2
      ctx->Driver.UnmapBuffer(ctx, target, bufObj);
      bufObj->AccessFlags = DEFAULT_ACCESS;
d1078 1
a1078 1
_mesa_BufferSubDataARB(GLenum target, GLintptrARB offset,
a1082 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1097 1
a1097 1
   ctx->Driver.BufferSubData( ctx, target, offset, size, data, bufObj );
d1102 1
a1102 1
_mesa_GetBufferSubDataARB(GLenum target, GLintptrARB offset,
a1106 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1116 1
a1116 1
   ctx->Driver.GetBufferSubData( ctx, target, offset, size, data, bufObj );
d1121 1
a1121 1
_mesa_MapBufferARB(GLenum target, GLenum access)
d1127 1
d1134 1
d1138 1
d1142 1
d1145 5
d1154 2
a1155 3
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glMapBufferARB(target)" );
d1157 3
a1159 3
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMapBufferARB(buffer 0)" );
d1162 4
a1165 2
   if (_mesa_bufferobj_mapped(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMapBufferARB(already mapped)");
d1169 2
a1170 2
   ASSERT(ctx->Driver.MapBuffer);
   map = ctx->Driver.MapBuffer( ctx, target, access, bufObj );
d1216 1
a1216 1
_mesa_UnmapBufferARB(GLenum target)
d1223 2
a1224 3
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glUnmapBufferARB(target)" );
d1226 1
a1226 5
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUnmapBufferARB" );
      return GL_FALSE;
   }
d1268 2
a1269 2
   status = ctx->Driver.UnmapBuffer( ctx, target, bufObj );
   bufObj->AccessFlags = DEFAULT_ACCESS;
d1279 1
a1279 1
_mesa_GetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
a1282 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1284 2
a1285 3
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameterivARB(target)" );
a1286 5
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetBufferParameterivARB" );
      return;
   }
d1296 1
a1296 1
      *params = simplified_access_mode(bufObj->AccessFlags);
d1302 1
a1302 1
      if (ctx->VersionMajor < 3)
d1307 1
a1307 1
      if (ctx->VersionMajor < 3)
d1312 1
a1312 1
      if (ctx->VersionMajor < 3)
a1335 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1337 2
a1338 3
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameteri64v(target)" );
a1339 5
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetBufferParameteri64v" );
      return;
   }
d1349 1
a1349 1
      *params = simplified_access_mode(bufObj->AccessFlags);
d1352 1
a1352 1
      if (ctx->VersionMajor < 3)
d1360 1
a1360 1
      if (ctx->VersionMajor < 3)
d1365 1
a1365 1
      if (ctx->VersionMajor < 3)
d1380 1
a1380 1
_mesa_GetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
a1383 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1390 2
a1391 7
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferPointervARB(target)" );
      return;
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetBufferPointervARB" );
a1392 1
   }
a1404 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1406 2
a1407 4
   src = get_buffer(ctx, readTarget);
   if (!src || !_mesa_is_bufferobj(src)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glCopyBuffserSubData(readTarget = 0x%x)", readTarget);
a1408 1
   }
d1410 2
a1411 4
   dst = get_buffer(ctx, writeTarget);
   if (!dst || !_mesa_is_bufferobj(dst)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glCopyBuffserSubData(writeTarget = 0x%x)", writeTarget);
a1412 1
   }
d1416 1
a1416 1
                  "glCopyBuffserSubData(readBuffer is mapped)");
d1422 1
a1422 1
                  "glCopyBuffserSubData(writeBuffer is mapped)");
d1428 1
a1428 1
                  "glCopyBuffserSubData(readOffset = %d)", (int) readOffset);
d1434 7
a1440 1
                  "glCopyBuffserSubData(writeOffset = %d)", (int) writeOffset);
d1446 1
a1446 1
                  "glCopyBuffserSubData(readOffset + size = %d)",
d1453 1
a1453 1
                  "glCopyBuffserSubData(writeOffset + size = %d)",
d1468 1
a1468 1
                     "glCopyBuffserSubData(overlapping src/dst)");
d1508 13
d1554 2
a1555 4
   bufObj = get_buffer(ctx, target);
   if (!bufObj || !_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glMapBufferRange(target = 0x%x)", target);
a1556 1
   }
d1569 17
a1585 1
      
d1587 1
a1587 2
   map = ctx->Driver.MapBufferRange(ctx, target, offset, length,
                                    access, bufObj);
a1613 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1617 1
a1617 1
                  "glMapBufferRange(extension not supported)");
d1623 1
a1623 1
                  "glMapBufferRange(offset = %ld)", (long)offset);
d1629 1
a1629 1
                  "glMapBufferRange(length = %ld)", (long)length);
d1633 2
a1634 4
   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glMapBufferRange(target = 0x%x)", target);
a1635 7
   }

   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(current buffer is 0)");
      return;
   }
d1640 1
a1640 1
                  "glMapBufferRange(buffer is not mapped)");
d1646 1
a1646 1
                  "glMapBufferRange(GL_MAP_FLUSH_EXPLICIT_BIT not set)");
d1652 1
a1652 1
		  "glMapBufferRange(offset %ld + length %ld > mapped length %ld)",
d1660 1
a1660 1
      ctx->Driver.FlushMappedBufferRange(ctx, target, offset, length, bufObj);
a1663 1
#if FEATURE_APPLE_object_purgeable
d2038 277
a2314 1
#endif /* FEATURE_APPLE_object_purgeable */
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d42 2
d96 5
d224 2
a225 1
_mesa_delete_buffer_object( struct gl_context *ctx, struct gl_buffer_object *bufObj )
d423 2
a424 1
_mesa_buffer_get_subdata( struct gl_context *ctx, GLenum target, GLintptrARB offset,
d568 1
a668 242
/**
 * When we're about to read pixel data out of a PBO (via glDrawPixels,
 * glTexImage, etc) or write data into a PBO (via glReadPixels,
 * glGetTexImage, etc) we call this function to check that we're not
 * going to read out of bounds.
 *
 * XXX This would also be a convenient time to check that the PBO isn't
 * currently mapped.  Whoever calls this function should check for that.
 * Remember, we can't use a PBO when it's mapped!
 *
 * If we're not using a PBO, this is a no-op.
 *
 * \param width  width of image to read/write
 * \param height  height of image to read/write
 * \param depth  depth of image to read/write
 * \param format  format of image to read/write
 * \param type  datatype of image to read/write
 * \param ptr  the user-provided pointer/offset
 * \return GL_TRUE if the PBO access is OK, GL_FALSE if the access would
 *         go out of bounds.
 */
GLboolean
_mesa_validate_pbo_access(GLuint dimensions,
                          const struct gl_pixelstore_attrib *pack,
                          GLsizei width, GLsizei height, GLsizei depth,
                          GLenum format, GLenum type, const GLvoid *ptr)
{
   GLvoid *start, *end;
   const GLubyte *sizeAddr; /* buffer size, cast to a pointer */

   if (!_mesa_is_bufferobj(pack->BufferObj))
      return GL_TRUE;  /* no PBO, OK */

   if (pack->BufferObj->Size == 0)
      /* no buffer! */
      return GL_FALSE;

   /* get address of first pixel we'll read */
   start = _mesa_image_address(dimensions, pack, ptr, width, height,
                               format, type, 0, 0, 0);

   /* get address just past the last pixel we'll read */
   end =  _mesa_image_address(dimensions, pack, ptr, width, height,
                              format, type, depth-1, height-1, width);


   sizeAddr = ((const GLubyte *) 0) + pack->BufferObj->Size;

   if ((const GLubyte *) start > sizeAddr) {
      /* This will catch negative values / wrap-around */
      return GL_FALSE;
   }
   if ((const GLubyte *) end > sizeAddr) {
      /* Image read goes beyond end of buffer */
      return GL_FALSE;
   }

   /* OK! */
   return GL_TRUE;
}


/**
 * For commands that read from a PBO (glDrawPixels, glTexImage,
 * glPolygonStipple, etc), if we're reading from a PBO, map it read-only
 * and return the pointer into the PBO.  If we're not reading from a
 * PBO, return \p src as-is.
 * If non-null return, must call _mesa_unmap_pbo_source() when done.
 *
 * \return NULL if error, else pointer to start of data
 */
const GLvoid *
_mesa_map_pbo_source(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *unpack,
                     const GLvoid *src)
{
   const GLubyte *buf;

   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      /* unpack from PBO */
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              unpack->BufferObj);
      if (!buf)
         return NULL;

      buf = ADD_POINTERS(buf, src);
   }
   else {
      /* unpack from normal memory */
      buf = src;
   }

   return buf;
}


/**
 * Combine PBO-read validation and mapping.
 * If any GL errors are detected, they'll be recorded and NULL returned.
 * \sa _mesa_validate_pbo_access
 * \sa _mesa_map_pbo_source
 * A call to this function should have a matching call to
 * _mesa_unmap_pbo_source().
 */
const GLvoid *
_mesa_map_validate_pbo_source(struct gl_context *ctx,
                              GLuint dimensions,
                              const struct gl_pixelstore_attrib *unpack,
                              GLsizei width, GLsizei height, GLsizei depth,
                              GLenum format, GLenum type, const GLvoid *ptr,
                              const char *where)
{
   ASSERT(dimensions == 1 || dimensions == 2 || dimensions == 3);

   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
      /* non-PBO access: no validation to be done */
      return ptr;
   }

   if (!_mesa_validate_pbo_access(dimensions, unpack,
                                  width, height, depth, format, type, ptr)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(out of bounds PBO access)", where);
      return NULL;
   }

   if (_mesa_bufferobj_mapped(unpack->BufferObj)) {
      /* buffer is already mapped - that's an error */
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(PBO is mapped)", where);
      return NULL;
   }

   ptr = _mesa_map_pbo_source(ctx, unpack, ptr);
   return ptr;
}


/**
 * Counterpart to _mesa_map_pbo_source()
 */
void
_mesa_unmap_pbo_source(struct gl_context *ctx,
                       const struct gl_pixelstore_attrib *unpack)
{
   ASSERT(unpack != &ctx->Pack); /* catch pack/unpack mismatch */
   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
   }
}


/**
 * For commands that write to a PBO (glReadPixels, glGetColorTable, etc),
 * if we're writing to a PBO, map it write-only and return the pointer
 * into the PBO.  If we're not writing to a PBO, return \p dst as-is.
 * If non-null return, must call _mesa_unmap_pbo_dest() when done.
 *
 * \return NULL if error, else pointer to start of data
 */
void *
_mesa_map_pbo_dest(struct gl_context *ctx,
                   const struct gl_pixelstore_attrib *pack,
                   GLvoid *dest)
{
   void *buf;

   if (_mesa_is_bufferobj(pack->BufferObj)) {
      /* pack into PBO */
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              pack->BufferObj);
      if (!buf)
         return NULL;

      buf = ADD_POINTERS(buf, dest);
   }
   else {
      /* pack to normal memory */
      buf = dest;
   }

   return buf;
}


/**
 * Combine PBO-write validation and mapping.
 * If any GL errors are detected, they'll be recorded and NULL returned.
 * \sa _mesa_validate_pbo_access
 * \sa _mesa_map_pbo_dest
 * A call to this function should have a matching call to
 * _mesa_unmap_pbo_dest().
 */
GLvoid *
_mesa_map_validate_pbo_dest(struct gl_context *ctx,
                            GLuint dimensions,
                            const struct gl_pixelstore_attrib *unpack,
                            GLsizei width, GLsizei height, GLsizei depth,
                            GLenum format, GLenum type, GLvoid *ptr,
                            const char *where)
{
   ASSERT(dimensions == 1 || dimensions == 2 || dimensions == 3);

   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
      /* non-PBO access: no validation to be done */
      return ptr;
   }

   if (!_mesa_validate_pbo_access(dimensions, unpack,
                                  width, height, depth, format, type, ptr)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(out of bounds PBO access)", where);
      return NULL;
   }

   if (_mesa_bufferobj_mapped(unpack->BufferObj)) {
      /* buffer is already mapped - that's an error */
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(PBO is mapped)", where);
      return NULL;
   }

   ptr = _mesa_map_pbo_dest(ctx, unpack, ptr);
   return ptr;
}


/**
 * Counterpart to _mesa_map_pbo_dest()
 */
void
_mesa_unmap_pbo_dest(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *pack)
{
   ASSERT(pack != &ctx->Unpack); /* catch pack/unpack mismatch */
   if (_mesa_is_bufferobj(pack->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT, pack->BufferObj);
   }
}


d739 4
d759 1
d838 3
d898 6
d1413 11
d1430 7
a1436 8
   if (access & GL_MAP_READ_BIT) {
      if ((access & GL_MAP_INVALIDATE_RANGE_BIT) ||
          (access & GL_MAP_INVALIDATE_BUFFER_BIT) ||
          (access & GL_MAP_UNSYNCHRONIZED_BIT)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glMapBufferRange(invalid access flags)");
         return NULL;
      }
d1556 1
a1556 1
_mesa_BufferObjectPurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1589 1
a1589 1
_mesa_RenderObjectPurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1618 1
a1618 1
_mesa_TextureObjectPurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1674 1
a1674 1
      retval = _mesa_TextureObjectPurgeable (ctx, name, option);
d1677 1
a1677 1
      retval = _mesa_RenderObjectPurgeable (ctx, name, option);
d1680 1
a1680 1
      retval = _mesa_BufferObjectPurgeable (ctx, name, option);
d1699 1
a1699 1
_mesa_BufferObjectUnpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1729 1
a1729 1
_mesa_RenderObjectUnpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1759 1
a1759 1
_mesa_TextureObjectUnpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1814 1
a1814 1
      return _mesa_BufferObjectUnpurgeable(ctx, name, option);
d1816 1
a1816 1
      return _mesa_TextureObjectUnpurgeable(ctx, name, option);
d1818 1
a1818 1
      return _mesa_RenderObjectUnpurgeable(ctx, name, option);
d1829 2
a1830 2
_mesa_GetBufferObjectParameterivAPPLE(struct gl_context *ctx, GLuint name,
                                      GLenum pname, GLint* params)
d1832 1
a1832 3
   struct gl_buffer_object *bufObj;

   bufObj = _mesa_lookup_bufferobj(ctx, name);
d1853 2
a1854 2
_mesa_GetRenderObjectParameterivAPPLE(struct gl_context *ctx, GLuint name,
                                      GLenum pname, GLint* params)
d1856 2
a1857 4
   struct gl_renderbuffer *bufObj;

   bufObj = _mesa_lookup_renderbuffer(ctx, name);
   if (!bufObj) {
d1865 1
a1865 1
      *params = bufObj->Purgeable;
d1877 2
a1878 2
_mesa_GetTextureObjectParameterivAPPLE(struct gl_context *ctx, GLuint name,
                                       GLenum pname, GLint* params)
d1880 2
a1881 4
   struct gl_texture_object *bufObj;

   bufObj = _mesa_lookup_texture(ctx, name);
   if (!bufObj) {
d1889 1
a1889 1
      *params = bufObj->Purgeable;
d1902 1
a1902 1
                                GLint* params)
d1914 1
a1914 1
      _mesa_GetTextureObjectParameterivAPPLE (ctx, name, pname, params);
d1917 1
a1917 1
      _mesa_GetBufferObjectParameterivAPPLE (ctx, name, pname, params);
d1920 1
a1920 1
      _mesa_GetRenderObjectParameterivAPPLE (ctx, name, pname, params);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 1
d50 1
a50 1
#ifdef FEATURE_OES_mapbuffer
d58 7
d72 1
a72 1
get_buffer_target(GLcontext *ctx, GLenum target)
d84 1
a84 4
      if (ctx->Extensions.ARB_copy_buffer) {
         return &ctx->CopyReadBuffer;
      }
      break;
d86 5
a90 2
      if (ctx->Extensions.ARB_copy_buffer) {
         return &ctx->CopyWriteBuffer;
d93 1
d109 1
a109 1
get_buffer(GLcontext *ctx, GLenum target)
d153 1
a153 1
buffer_object_subdata_range_good( GLcontext * ctx, GLenum target, 
d199 1
a199 1
_mesa_new_buffer_object( GLcontext *ctx, GLuint name, GLenum target )
d217 1
a217 1
_mesa_delete_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj )
d238 1
a238 1
_mesa_reference_buffer_object(GLcontext *ctx,
d338 1
a338 1
_mesa_buffer_data( GLcontext *ctx, GLenum target, GLsizeiptrARB size,
d382 1
a382 1
_mesa_buffer_subdata( GLcontext *ctx, GLenum target, GLintptrARB offset,
d415 1
a415 1
_mesa_buffer_get_subdata( GLcontext *ctx, GLenum target, GLintptrARB offset,
d442 1
a442 1
_mesa_buffer_map( GLcontext *ctx, GLenum target, GLenum access,
d465 1
a465 1
_mesa_buffer_map_range( GLcontext *ctx, GLenum target, GLintptr offset,
d486 1
a486 1
_mesa_buffer_flush_mapped_range( GLcontext *ctx, GLenum target, 
d507 1
a507 1
_mesa_buffer_unmap( GLcontext *ctx, GLenum target,
d526 1
a526 1
_mesa_copy_buffer_subdata(GLcontext *ctx,
d556 1
a556 1
_mesa_init_buffer_objects( GLcontext *ctx )
d558 3
d574 1
a574 1
_mesa_free_buffer_objects( GLcontext *ctx )
d589 1
a589 1
bind_buffer_object(GLcontext *ctx, GLenum target, GLuint buffer)
d597 1
a597 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferARB(target 0x%x)");
d618 4
a621 2
      if (!newBufObj) {
         /* if this is a new buffer object id, allocate a buffer object now */
d647 1
a647 1
_mesa_update_default_objects_buffer_objects(GLcontext *ctx)
d731 1
a731 1
_mesa_map_pbo_source(GLcontext *ctx,
d765 1
a765 1
_mesa_map_validate_pbo_source(GLcontext *ctx,
d801 1
a801 1
_mesa_unmap_pbo_source(GLcontext *ctx,
d821 1
a821 1
_mesa_map_pbo_dest(GLcontext *ctx,
d855 1
a855 1
_mesa_map_validate_pbo_dest(GLcontext *ctx,
d891 1
a891 1
_mesa_unmap_pbo_dest(GLcontext *ctx,
d907 1
a907 1
_mesa_lookup_bufferobj(GLcontext *ctx, GLuint buffer)
d924 1
a924 1
unbind(GLcontext *ctx,
d1001 1
a1001 1
         ASSERT(bufObj->Name == ids[i]);
d1042 1
a1042 1
         _mesa_HashRemove(ctx->Shared->BufferObjects, bufObj->Name);
d1081 1
a1081 1
   /* Allocate new, empty buffer objects and return identifiers */
d1083 2
a1084 10
      struct gl_buffer_object *bufObj;
      GLuint name = first + i;
      GLenum target = 0;
      bufObj = ctx->Driver.NewBufferObject( ctx, name, target );
      if (!bufObj) {
         _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenBuffersARB");
         return;
      }
      _mesa_HashInsert(ctx->Shared->BufferObjects, first + i, bufObj);
d1110 1
a1110 1
   return bufObj ? GL_TRUE : GL_FALSE;
d1196 3
d1388 1
a1388 1
      _mesa_error(ctx, GL_INVALID_ENUM, "GetBufferParameterivARB(target)" );
d1392 1
a1392 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "GetBufferParameterivARB" );
d1399 1
a1399 1
      break;
d1402 1
a1402 1
      break;
d1405 1
a1405 1
      break;
d1408 16
a1423 1
      break;
d1425 1
a1425 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameterivARB(pname)");
      return;
d1427 4
d1448 1
a1448 1
      _mesa_error(ctx, GL_INVALID_ENUM, "GetBufferParameteri64v(target)" );
d1452 1
a1452 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "GetBufferParameteri64v" );
d1459 1
a1459 1
      break;
d1462 1
a1462 1
      break;
d1465 6
a1470 1
      break;
d1473 11
a1483 1
      break;
d1485 1
a1485 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameteri64v(pname)");
      return;
d1487 4
d1557 1
a1557 1
                  "glCopyBuffserSubData(readOffset = %d)", readOffset);
d1563 1
a1563 1
                  "glCopyBuffserSubData(writeOffset = %d)", writeOffset);
d1570 1
a1570 1
                  readOffset, size);
d1577 1
a1577 1
                  writeOffset, size);
d1621 1
a1621 1
                  "glMapBufferRange(offset = %ld)", offset);
d1627 1
a1627 1
                  "glMapBufferRange(length = %ld)", length);
d1712 1
a1712 1
                  "glMapBufferRange(offset = %ld)", offset);
d1718 1
a1718 1
                  "glMapBufferRange(length = %ld)", length);
d1750 2
a1751 2
             "glMapBufferRange(offset %ld + length %ld > mapped length %ld)",
             offset, length, bufObj->Length);
d1764 1
a1764 1
_mesa_BufferObjectPurgeable(GLcontext *ctx, GLuint name, GLenum option)
d1797 1
a1797 1
_mesa_RenderObjectPurgeable(GLcontext *ctx, GLuint name, GLenum option)
d1826 1
a1826 1
_mesa_TextureObjectPurgeable(GLcontext *ctx, GLuint name, GLenum option)
d1907 1
a1907 1
_mesa_BufferObjectUnpurgeable(GLcontext *ctx, GLuint name, GLenum option)
d1928 1
a1928 1
   retval = GL_RETAINED_APPLE;
d1937 1
a1937 1
_mesa_RenderObjectUnpurgeable(GLcontext *ctx, GLuint name, GLenum option)
d1958 1
a1958 1
   retval = GL_RETAINED_APPLE;
d1962 1
a1962 1
   return option;
d1967 1
a1967 1
_mesa_TextureObjectUnpurgeable(GLcontext *ctx, GLuint name, GLenum option)
d1988 1
a1988 1
   retval = GL_RETAINED_APPLE;
d2037 1
a2037 1
_mesa_GetBufferObjectParameterivAPPLE(GLcontext *ctx, GLuint name,
d2063 1
a2063 1
_mesa_GetRenderObjectParameterivAPPLE(GLcontext *ctx, GLuint name,
d2089 1
a2089 1
_mesa_GetTextureObjectParameterivAPPLE(GLcontext *ctx, GLuint name,
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.2
d6 1
d29 1
a29 1
 * \brief Functions for the GL_ARB_vertex_buffer_object extension.
d40 50
d94 3
a96 5
 *
 * \param ctx     GL context
 * \param target  Buffer object target to be retrieved.  Currently this must
 *                be either \c GL_ARRAY_BUFFER or \c GL_ELEMENT_ARRAY_BUFFER.
 * \return   A pointer to the buffer object bound to \c target in the
d102 5
a106 1
   struct gl_buffer_object * bufObj = NULL;
a107 17
   switch (target) {
      case GL_ARRAY_BUFFER_ARB:
         bufObj = ctx->Array.ArrayBufferObj;
         break;
      case GL_ELEMENT_ARRAY_BUFFER_ARB:
         bufObj = ctx->Array.ElementArrayBufferObj;
         break;
      case GL_PIXEL_PACK_BUFFER_EXT:
         bufObj = ctx->Pack.BufferObj;
         break;
      case GL_PIXEL_UNPACK_BUFFER_EXT:
         bufObj = ctx->Unpack.BufferObj;
         break;
      default:
         /* error must be recorded by caller */
         return NULL;
   }
d109 15
a123 4
   /* bufObj should point to NullBufferObj or a user-created buffer object */
   ASSERT(bufObj);

   return bufObj;
d165 1
a165 1
   if (bufObj->Name == 0) {
d174 1
a174 1
   if (bufObj->Pointer) {
d187 1
a187 2
 * This function is intended to be called via
 * \c dd_function_table::NewBufferObject.
d189 1
a189 1
struct gl_buffer_object *
d205 1
a205 2
 * This function is intended to be called via
 * \c dd_function_table::DeleteBuffer.
d207 1
a207 1
void
d213 1
a213 1
      _mesa_free(bufObj->Data);
d219 2
a220 1
   _mesa_free(bufObj);
d237 1
a237 1
      /* Unreference the old texture */
d241 1
a241 1
      /*_glthread_LOCK_MUTEX(oldObj->Mutex);*/
d249 1
a249 1
      /*_glthread_UNLOCK_MUTEX(oldObj->Mutex);*/
d270 2
a271 2
      /* reference new texture */
      /*_glthread_LOCK_MUTEX(tex->Mutex);*/
d286 1
a286 1
      /*_glthread_UNLOCK_MUTEX(tex->Mutex);*/
d300 2
a301 1
   _mesa_bzero(obj, sizeof(struct gl_buffer_object));
d305 1
a305 1
   obj->Access = GL_READ_WRITE_ARB;
d314 2
a315 3
 * This function is intended to be called via
 * \c dd_function_table::BufferData.  This function need not set GL error
 * codes.  The input parameters will have been tested before calling.
d325 1
d328 1
a328 1
void
d344 1
a344 1
	 _mesa_memcpy( bufObj->Data, data, size );
d346 5
d360 2
a361 3
 * This function is intended to be called by
 * \c dd_function_table::BufferSubData.  This function need not set GL error
 * codes.  The input parameters will have been tested before calling.
d372 1
a372 1
void
d383 1
a383 1
      _mesa_memcpy( (GLubyte *) bufObj->Data + offset, data, size );
d393 2
a394 3
 * This function is intended to be called by
 * \c dd_function_table::BufferGetSubData.  This function need not set GL error
 * codes.  The input parameters will have been tested before calling.
d398 1
a398 1
 * \param offset  Offset of the first byte to be modified.
d400 1
a400 1
 * \param data    Pointer to the data to store in the buffer object.
d405 1
a405 1
void
d413 1
a413 1
      _mesa_memcpy( data, (GLubyte *) bufObj->Data + offset, size );
d419 1
a419 3
 * Fallback function called via ctx->Driver.MapBuffer().
 * Hardware drivers that really implement buffer objects should never use
 * this function.
d432 1
a432 1
void *
a438 1
   ASSERT(!bufObj->OnCard);
d440 1
a440 1
   if (bufObj->Pointer) {
d445 23
d473 19
a491 3
 * Fallback function called via ctx->Driver.MapBuffer().
 * Hardware drivers that really implement buffer objects should never use
 * function.
d497 1
a497 1
GLboolean
a502 1
   ASSERT(!bufObj->OnCard);
d505 3
d513 31
d549 17
a565 7
   /* Allocate the default buffer object and set refcount so high that
    * it never gets deleted.
    * XXX with recent/improved refcounting this may not longer be needed.
    */
   ctx->Array.NullBufferObj = _mesa_new_buffer_object(ctx, 0, 0);
   if (ctx->Array.NullBufferObj)
      ctx->Array.NullBufferObj->RefCount = 1000;
d567 2
a568 2
   ctx->Array.ArrayBufferObj = ctx->Array.NullBufferObj;
   ctx->Array.ElementArrayBufferObj = ctx->Array.NullBufferObj;
d571 1
d574 1
d583 3
a585 15
   switch (target) {
   case GL_ARRAY_BUFFER_ARB:
      bindTarget = &ctx->Array.ArrayBufferObj;
      break;
   case GL_ELEMENT_ARRAY_BUFFER_ARB:
      bindTarget = &ctx->Array.ElementArrayBufferObj;
      break;
   case GL_PIXEL_PACK_BUFFER_EXT:
      bindTarget = &ctx->Pack.BufferObj;
      break;
   case GL_PIXEL_UNPACK_BUFFER_EXT:
      bindTarget = &ctx->Unpack.BufferObj;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferARB(target)");
d590 1
a590 1
   oldBufObj = get_buffer(ctx, target);
d601 1
a601 1
      newBufObj = ctx->Array.NullBufferObj;
d622 1
a622 1
   if (ctx->Driver.BindBuffer && newBufObj)
d655 2
d675 2
a676 1
   ASSERT(pack->BufferObj->Name != 0);
d708 7
a714 6
 * If the source of glBitmap data is a PBO, check that we won't read out
 * of buffer bounds, then map the buffer.
 * If not sourcing from a PBO, just return the bitmap pointer.
 * This is a helper function for (some) drivers.
 * Return NULL if error.
 * If non-null return, must call _mesa_unmap_bitmap_pbo() when done.
d716 2
a717 2
const GLubyte *
_mesa_map_bitmap_pbo(GLcontext *ctx,
d719 1
a719 1
                     const GLubyte *bitmap)
d723 1
a723 1
   if (unpack->BufferObj->Name) {
d731 1
a731 1
      buf = ADD_POINTERS(buf, bitmap);
d735 1
a735 1
      buf = bitmap;
d743 6
a748 2
 * Counterpart to _mesa_map_bitmap_pbo()
 * This is a helper function for (some) drivers.
d750 20
a769 7
void
_mesa_unmap_bitmap_pbo(GLcontext *ctx,
                       const struct gl_pixelstore_attrib *unpack)
{
   if (unpack->BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
a770 1
}
d772 4
a775 24

/**
 * \sa _mesa_map_bitmap_pbo
 */
const GLvoid *
_mesa_map_drawpix_pbo(GLcontext *ctx,
                      const struct gl_pixelstore_attrib *unpack,
                      const GLvoid *pixels)
{
   const GLvoid *buf;

   if (unpack->BufferObj->Name) {
      /* unpack from PBO */
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              unpack->BufferObj);
      if (!buf)
         return NULL;

      buf = ADD_POINTERS(buf, pixels);
   }
   else {
      /* unpack from normal memory */
      buf = pixels;
d778 2
a779 1
   return buf;
d784 1
a784 1
 * \sa _mesa_unmap_bitmap_pbo
d787 1
a787 1
_mesa_unmap_drapix_pbo(GLcontext *ctx,
d790 2
a791 1
   if (unpack->BufferObj->Name) {
d799 6
a804 3
 * If PBO is bound, map the buffer, return dest pointer in mapped buffer.
 * Call _mesa_unmap_readpix_pbo() when finished
 * \return NULL if error
d807 3
a809 3
_mesa_map_readpix_pbo(GLcontext *ctx,
                      const struct gl_pixelstore_attrib *pack,
                      GLvoid *dest)
d813 1
a813 1
   if (pack->BufferObj->Name) {
d833 42
a874 1
 * Counterpart to _mesa_map_readpix_pbo()
d877 2
a878 2
_mesa_unmap_readpix_pbo(GLcontext *ctx,
                        const struct gl_pixelstore_attrib *pack)
d880 2
a881 1
   if (pack->BufferObj->Name) {
d915 1
a915 1
      _mesa_reference_buffer_object(ctx, ptr, ctx->Array.NullBufferObj);
d920 26
d984 1
a984 1
         /* unbind any vertex pointers bound to this buffer */
d989 1
a989 1
         if (bufObj->Pointer) {
d992 1
a992 1
            bufObj->Access = GL_READ_WRITE_ARB;
d996 11
a1006 9
         unbind(ctx, &ctx->Array.ArrayObj->Vertex.BufferObj, bufObj);
         unbind(ctx, &ctx->Array.ArrayObj->Normal.BufferObj, bufObj);
         unbind(ctx, &ctx->Array.ArrayObj->Color.BufferObj, bufObj);
         unbind(ctx, &ctx->Array.ArrayObj->SecondaryColor.BufferObj, bufObj);
         unbind(ctx, &ctx->Array.ArrayObj->FogCoord.BufferObj, bufObj);
         unbind(ctx, &ctx->Array.ArrayObj->Index.BufferObj, bufObj);
         unbind(ctx, &ctx->Array.ArrayObj->EdgeFlag.BufferObj, bufObj);
         for (j = 0; j < MAX_TEXTURE_COORD_UNITS; j++) {
            unbind(ctx, &ctx->Array.ArrayObj->TexCoord[j].BufferObj, bufObj);
d1008 2
a1009 2
         for (j = 0; j < VERT_ATTRIB_MAX; j++) {
            unbind(ctx, &ctx->Array.ArrayObj->VertexAttrib[j].BufferObj, bufObj);
d1019 1
d1122 14
a1135 14
      case GL_STREAM_DRAW_ARB:
      case GL_STREAM_READ_ARB:
      case GL_STREAM_COPY_ARB:
      case GL_STATIC_DRAW_ARB:
      case GL_STATIC_READ_ARB:
      case GL_STATIC_COPY_ARB:
      case GL_DYNAMIC_DRAW_ARB:
      case GL_DYNAMIC_READ_ARB:
      case GL_DYNAMIC_COPY_ARB:
         /* OK */
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glBufferDataARB(usage)");
         return;
d1143 2
a1144 2
   if (bufObj->Name == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferDataARB" );
d1148 1
a1148 1
   if (bufObj->Pointer) {
d1151 2
a1152 2
      bufObj->Access = GL_READ_WRITE_ARB;
      bufObj->Pointer = NULL;
d1155 13
d1169 3
a1171 3

   /* Give the buffer object to the driver!  <data> may be null! */
   ctx->Driver.BufferData( ctx, target, size, data, usage, bufObj );
d1190 2
d1222 3
d1228 12
a1239 8
      case GL_READ_ONLY_ARB:
      case GL_WRITE_ONLY_ARB:
      case GL_READ_WRITE_ARB:
         /* OK */
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glMapBufferARB(access)");
         return NULL;
d1247 2
a1248 2
   if (bufObj->Name == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMapBufferARB" );
d1251 1
a1251 1
   if (bufObj->Pointer) {
d1257 27
a1283 3
   bufObj->Pointer = ctx->Driver.MapBuffer( ctx, target, access, bufObj );
   if (!bufObj->Pointer) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMapBufferARB(access)");
d1285 1
d1287 10
a1296 1
   bufObj->Access = access;
d1315 1
a1315 1
   if (bufObj->Name == 0) {
d1319 1
a1319 1
   if (!bufObj->Pointer) {
d1324 36
d1361 4
a1364 2
   bufObj->Access = GL_READ_WRITE_ARB;
   bufObj->Pointer = NULL;
d1382 1
a1382 1
   if (bufObj->Name == 0) {
d1388 57
a1444 15
      case GL_BUFFER_SIZE_ARB:
         *params = (GLint) bufObj->Size;
         break;
      case GL_BUFFER_USAGE_ARB:
         *params = bufObj->Usage;
         break;
      case GL_BUFFER_ACCESS_ARB:
         *params = bufObj->Access;
         break;
      case GL_BUFFER_MAPPED_ARB:
         *params = (bufObj->Pointer != NULL);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameterivARB(pname)");
         return;
d1466 1
a1466 1
   if (bufObj->Name == 0) {
d1473 626
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d797 7
d811 1
a811 1
         for (j = 0; j < MAX_TEXTURE_UNITS; j++) {
d954 4
a957 2
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferDataARB(buffer is mapped)" );
      return;
d1073 2
a1074 5
   if (ctx->Driver.UnmapBuffer) {
      status = ctx->Driver.UnmapBuffer( ctx, target, bufObj );
   }

   bufObj->Access = GL_READ_WRITE_ARB; /* initial value, OK? */
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d122 1
a122 1
   if ((GLuint) (offset + size) > bufObj->Size) {
d169 5
d178 4
d183 3
a185 1
_mesa_unbind_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj )
d187 23
a209 3
   if (bufObj != ctx->Array.NullBufferObj) {
      bufObj->RefCount--;
      if (bufObj->RefCount <= 0) {
d213 2
d216 23
a238 1
	 ctx->Driver.DeleteBuffer(ctx, bufObj);
d240 1
a262 27
 * Add the given buffer object to the buffer object pool.
 */
void
_mesa_save_buffer_object( GLcontext *ctx, struct gl_buffer_object *obj )
{
   if (obj->Name > 0) {
      /* insert into hash table */
      _mesa_HashInsert(ctx->Shared->BufferObjects, obj->Name, obj);
   }
}


/**
 * Remove the given buffer object from the buffer object pool.
 * Do not deallocate the buffer object though.
 */
void
_mesa_remove_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj )
{
   if (bufObj->Name > 0) {
      /* remove from hash table */
      _mesa_HashRemove(ctx->Shared->BufferObjects, bufObj->Name);
   }
}


/**
d328 4
a331 1
   if (bufObj->Data && ((GLuint) (size + offset) <= bufObj->Size)) {
d371 1
a371 1
 * function.
d373 1
a373 1
 * The input parameters will have been already tested for errors.
d432 1
d442 83
d586 137
d737 17
a762 3
   struct gl_buffer_object *oldBufObj;
   struct gl_buffer_object *newBufObj = NULL;
   struct gl_buffer_object **bindTarget = NULL;
d765 1
a765 65
   switch (target) {
      case GL_ARRAY_BUFFER_ARB:
         bindTarget = &ctx->Array.ArrayBufferObj;
         break;
      case GL_ELEMENT_ARRAY_BUFFER_ARB:
         bindTarget = &ctx->Array.ElementArrayBufferObj;
         break;
      case GL_PIXEL_PACK_BUFFER_EXT:
         bindTarget = &ctx->Pack.BufferObj;
         break;
      case GL_PIXEL_UNPACK_BUFFER_EXT:
         bindTarget = &ctx->Unpack.BufferObj;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferARB(target)");
         return;
   }

   /* Get pointer to old buffer object (to be unbound) */
   oldBufObj = get_buffer(ctx, target);
   if (oldBufObj && oldBufObj->Name == buffer)
      return;   /* rebinding the same buffer object- no change */

   /*
    * Get pointer to new buffer object (newBufObj)
    */
   if (buffer == 0) {
      /* The spec says there's not a buffer object named 0, but we use
       * one internally because it simplifies things.
       */
      newBufObj = ctx->Array.NullBufferObj;
   }
   else {
      /* non-default buffer object */
      newBufObj = _mesa_lookup_bufferobj(ctx, buffer);
      if (!newBufObj) {
         /* if this is a new buffer object id, allocate a buffer object now */
         ASSERT(ctx->Driver.NewBufferObject);
	 newBufObj = ctx->Driver.NewBufferObject(ctx, buffer, target);
         if (!newBufObj) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindBufferARB");
            return;
         }
         _mesa_save_buffer_object(ctx, newBufObj);
      }
   }
   
   /* Make new binding */
   *bindTarget = newBufObj;
   newBufObj->RefCount++;

   /* Pass BindBuffer call to device driver */
   if (ctx->Driver.BindBuffer && newBufObj)
      ctx->Driver.BindBuffer( ctx, target, newBufObj );

   /* decr ref count on old buffer obj, delete if needed */
   if (oldBufObj) {
      oldBufObj->RefCount--;
      assert(oldBufObj->RefCount >= 0);
      if (oldBufObj->RefCount == 0) {
	 assert(oldBufObj->Name != 0);
	 ASSERT(ctx->Driver.DeleteBuffer);
	 ctx->Driver.DeleteBuffer( ctx, oldBufObj );
      }
   }
d797 7
a803 35
         if (ctx->Array.ArrayObj->Vertex.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->Vertex.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
         if (ctx->Array.ArrayObj->Normal.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->Normal.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
         if (ctx->Array.ArrayObj->Color.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->Color.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
         if (ctx->Array.ArrayObj->SecondaryColor.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->SecondaryColor.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
         if (ctx->Array.ArrayObj->FogCoord.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->FogCoord.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
         if (ctx->Array.ArrayObj->Index.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->Index.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
         if (ctx->Array.ArrayObj->EdgeFlag.BufferObj == bufObj) {
            bufObj->RefCount--;
            ctx->Array.ArrayObj->EdgeFlag.BufferObj = ctx->Array.NullBufferObj;
            ctx->Array.NullBufferObj->RefCount++;
         }
d805 1
a805 5
            if (ctx->Array.ArrayObj->TexCoord[j].BufferObj == bufObj) {
               bufObj->RefCount--;
               ctx->Array.ArrayObj->TexCoord[j].BufferObj = ctx->Array.NullBufferObj;
               ctx->Array.NullBufferObj->RefCount++;
            }
d808 1
a808 5
            if (ctx->Array.ArrayObj->VertexAttrib[j].BufferObj == bufObj) {
               bufObj->RefCount--;
               ctx->Array.ArrayObj->VertexAttrib[j].BufferObj = ctx->Array.NullBufferObj;
               ctx->Array.NullBufferObj->RefCount++;
            }
d825 3
a827 3
	 /* The ID is immediately freed for re-use */
	 _mesa_remove_buffer_object(ctx, bufObj);
	 _mesa_unbind_buffer_object(ctx, bufObj);
d876 1
a876 1
      _mesa_save_buffer_object(ctx, bufObj);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d299 1
a299 4
   /* this should have been caught in _mesa_BufferSubData() */
   ASSERT((GLuint) (size + offset) <= bufObj->Size);

   if (bufObj->Data) {
d339 1
a339 1
 * this function.
d341 1
a341 1
 * The function parameters will have been already tested for errors.
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d122 1
a122 1
   if (offset + size > bufObj->Size) {
d300 1
a300 1
   ASSERT(size + offset <= bufObj->Size);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.6
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d28 1
a28 1
 * \brief Functions for the GL_ARB_vertex/pixel_buffer_object extensions.
a33 1
#include "enums.h"
a38 14
#include "fbobject.h"
#include "texobj.h"


/* Debug flags */
/*#define VBO_DEBUG*/
/*#define BOUNDS_CHECK*/


#if FEATURE_OES_mapbuffer
#define DEFAULT_ACCESS GL_MAP_WRITE_BIT
#else
#define DEFAULT_ACCESS (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT)
#endif
d42 6
a47 11
 * Used as a placeholder for buffer objects between glGenBuffers() and
 * glBindBuffer() so that glIsBuffer() can work correctly.
 */
static struct gl_buffer_object DummyBufferObject;


/**
 * Return pointer to address of a buffer object target.
 * \param ctx  the GL context
 * \param target  the buffer object target to be retrieved.
 * \return   pointer to pointer to the buffer object bound to \c target in the
d50 2
a51 2
static INLINE struct gl_buffer_object **
get_buffer_target(struct gl_context *ctx, GLenum target)
d53 2
d56 15
a70 21
   case GL_ARRAY_BUFFER_ARB:
      return &ctx->Array.ArrayBufferObj;
   case GL_ELEMENT_ARRAY_BUFFER_ARB:
      return &ctx->Array.ElementArrayBufferObj;
   case GL_PIXEL_PACK_BUFFER_EXT:
      return &ctx->Pack.BufferObj;
   case GL_PIXEL_UNPACK_BUFFER_EXT:
      return &ctx->Unpack.BufferObj;
   case GL_COPY_READ_BUFFER:
      return &ctx->CopyReadBuffer;
   case GL_COPY_WRITE_BUFFER:
      return &ctx->CopyWriteBuffer;
#if FEATURE_EXT_transform_feedback
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      if (ctx->Extensions.EXT_transform_feedback) {
         return &ctx->TransformFeedback.CurrentBuffer;
      }
      break;
#endif
   default:
      return NULL;
a71 2
   return NULL;
}
d73 2
d76 1
a76 32
/**
 * Get the buffer object bound to the specified target in a GL context.
 * \param ctx  the GL context
 * \param target  the buffer object target to be retrieved.
 * \return   pointer to the buffer object bound to \c target in the
 *           specified context or \c NULL if \c target is invalid.
 */
static INLINE struct gl_buffer_object *
get_buffer(struct gl_context *ctx, GLenum target)
{
   struct gl_buffer_object **bufObj = get_buffer_target(ctx, target);
   if (bufObj)
      return *bufObj;
   return NULL;
}


/**
 * Convert a GLbitfield describing the mapped buffer access flags
 * into one of GL_READ_WRITE, GL_READ_ONLY, or GL_WRITE_ONLY.
 */
static GLenum
simplified_access_mode(GLbitfield access)
{
   const GLbitfield rwFlags = GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
   if ((access & rwFlags) == rwFlags)
      return GL_READ_WRITE;
   if ((access & GL_MAP_READ_BIT) == GL_MAP_READ_BIT)
      return GL_READ_ONLY;
   if ((access & GL_MAP_WRITE_BIT) == GL_MAP_WRITE_BIT)
      return GL_WRITE_ONLY;
   return GL_READ_WRITE; /* this should never happen, but no big deal */
d97 1
a97 1
buffer_object_subdata_range_good( struct gl_context * ctx, GLenum target, 
d118 1
a118 1
   if (!_mesa_is_bufferobj(bufObj)) {
d127 1
a127 1
   if (_mesa_bufferobj_mapped(bufObj)) {
d140 2
a141 1
 * Default callback for the \c dd_function_table::NewBufferObject() hook.
d143 2
a144 2
static struct gl_buffer_object *
_mesa_new_buffer_object( struct gl_context *ctx, GLuint name, GLenum target )
d159 2
a160 1
 * Default callback for the \c dd_function_table::DeleteBuffer() hook.
d162 2
a163 2
static void
_mesa_delete_buffer_object( struct gl_context *ctx, struct gl_buffer_object *bufObj )
d168 2
a169 8
      free(bufObj->Data);

   /* assign strange values here to help w/ debugging */
   bufObj->RefCount = -1000;
   bufObj->Name = ~0;

   _glthread_DESTROY_MUTEX(bufObj->Mutex);
   free(bufObj);
a172 4

/**
 * Set ptr to bufObj w/ reference counting.
 */
d174 1
a174 3
_mesa_reference_buffer_object(struct gl_context *ctx,
                              struct gl_buffer_object **ptr,
                              struct gl_buffer_object *bufObj)
d176 3
a178 23
   if (*ptr == bufObj)
      return;

   if (*ptr) {
      /* Unreference the old buffer */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_buffer_object *oldObj = *ptr;

      _glthread_LOCK_MUTEX(oldObj->Mutex);
      ASSERT(oldObj->RefCount > 0);
      oldObj->RefCount--;
#if 0
      printf("BufferObj %p %d DECR to %d\n",
             (void *) oldObj, oldObj->Name, oldObj->RefCount);
#endif
      deleteFlag = (oldObj->RefCount == 0);
      _glthread_UNLOCK_MUTEX(oldObj->Mutex);

      if (deleteFlag) {

         /* some sanity checking: don't delete a buffer still in use */
#if 0
         /* unfortunately, these tests are invalid during context tear-down */
a181 2
#endif

d183 1
a183 23
         ctx->Driver.DeleteBuffer(ctx, oldObj);
      }

      *ptr = NULL;
   }
   ASSERT(!*ptr);

   if (bufObj) {
      /* reference new buffer */
      _glthread_LOCK_MUTEX(bufObj->Mutex);
      if (bufObj->RefCount == 0) {
         /* this buffer's being deleted (look just above) */
         /* Not sure this can every really happen.  Warn if it does. */
         _mesa_problem(NULL, "referencing deleted buffer object");
         *ptr = NULL;
      }
      else {
         bufObj->RefCount++;
#if 0
         printf("BufferObj %p %d INCR to %d\n",
                (void *) bufObj, bufObj->Name, bufObj->RefCount);
#endif
         *ptr = bufObj;
a184 1
      _glthread_UNLOCK_MUTEX(bufObj->Mutex);
d198 1
a198 2
   memset(obj, 0, sizeof(struct gl_buffer_object));
   _glthread_INIT_MUTEX(obj->Mutex);
d202 28
a229 1
   obj->AccessFlags = DEFAULT_ACCESS;
d238 3
a240 2
 * This is the default callback for \c dd_function_table::BufferData()
 * Note that all GL error checking will have been done already.
a249 1
 * \return GL_TRUE for success, GL_FALSE for failure
d252 2
a253 2
static GLboolean
_mesa_buffer_data( struct gl_context *ctx, GLenum target, GLsizeiptrARB size,
d268 1
a268 1
	 memcpy( bufObj->Data, data, size );
a269 5

      return GL_TRUE;
   }
   else {
      return GL_FALSE;
d279 3
a281 2
 * This is the default callback for \c dd_function_table::BufferSubData()
 * Note that all GL error checking will have been done already.
d292 2
a293 2
static void
_mesa_buffer_subdata( struct gl_context *ctx, GLenum target, GLintptrARB offset,
d303 1
a303 1
      memcpy( (GLubyte *) bufObj->Data + offset, data, size );
d313 3
a315 2
 * This is the default callback for \c dd_function_table::GetBufferSubData()
 * Note that all GL error checking will have been done already.
d319 1
a319 1
 * \param offset  Offset of the first byte to be fetched.
d321 1
a321 1
 * \param data    Destination for data
d326 2
a327 2
static void
_mesa_buffer_get_subdata( struct gl_context *ctx, GLenum target, GLintptrARB offset,
d334 1
a334 1
      memcpy( data, (GLubyte *) bufObj->Data + offset, size );
d340 3
a342 1
 * Default callback for \c dd_function_tabel::MapBuffer().
d355 2
a356 2
static void *
_mesa_buffer_map( struct gl_context *ctx, GLenum target, GLenum access,
d362 1
d364 1
a364 1
   if (_mesa_bufferobj_mapped(bufObj)) {
a368 23
   bufObj->Length = bufObj->Size;
   bufObj->Offset = 0;
   return bufObj->Pointer;
}


/**
 * Default fallback for \c dd_function_table::MapBufferRange().
 * Called via glMapBufferRange().
 */
static void *
_mesa_buffer_map_range( struct gl_context *ctx, GLenum target, GLintptr offset,
                        GLsizeiptr length, GLbitfield access,
                        struct gl_buffer_object *bufObj )
{
   (void) ctx;
   (void) target;
   assert(!_mesa_bufferobj_mapped(bufObj));
   /* Just return a direct pointer to the data */
   bufObj->Pointer = bufObj->Data + offset;
   bufObj->Length = length;
   bufObj->Offset = offset;
   bufObj->AccessFlags = access;
d374 3
a376 19
 * Default fallback for \c dd_function_table::FlushMappedBufferRange().
 * Called via glFlushMappedBufferRange().
 */
static void
_mesa_buffer_flush_mapped_range( struct gl_context *ctx, GLenum target, 
                                 GLintptr offset, GLsizeiptr length,
                                 struct gl_buffer_object *obj )
{
   (void) ctx;
   (void) target;
   (void) offset;
   (void) length;
   (void) obj;
   /* no-op */
}


/**
 * Default callback for \c dd_function_table::MapBuffer().
d382 2
a383 2
static GLboolean
_mesa_buffer_unmap( struct gl_context *ctx, GLenum target,
d388 1
a390 3
   bufObj->Length = 0;
   bufObj->Offset = 0;
   bufObj->AccessFlags = 0x0;
a395 31
 * Default fallback for \c dd_function_table::CopyBufferSubData().
 * Called via glCopyBuffserSubData().
 */
static void
_mesa_copy_buffer_subdata(struct gl_context *ctx,
                          struct gl_buffer_object *src,
                          struct gl_buffer_object *dst,
                          GLintptr readOffset, GLintptr writeOffset,
                          GLsizeiptr size)
{
   GLubyte *srcPtr, *dstPtr;

   /* buffer should not already be mapped */
   assert(!_mesa_bufferobj_mapped(src));
   assert(!_mesa_bufferobj_mapped(dst));

   srcPtr = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_COPY_READ_BUFFER,
                                              GL_READ_ONLY, src);
   dstPtr = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_COPY_WRITE_BUFFER,
                                              GL_WRITE_ONLY, dst);

   if (srcPtr && dstPtr)
      memcpy(dstPtr + writeOffset, srcPtr + readOffset, size);

   ctx->Driver.UnmapBuffer(ctx, GL_COPY_READ_BUFFER, src);
   ctx->Driver.UnmapBuffer(ctx, GL_COPY_WRITE_BUFFER, dst);
}



/**
d399 1
a399 34
_mesa_init_buffer_objects( struct gl_context *ctx )
{
   memset(&DummyBufferObject, 0, sizeof(DummyBufferObject));
   DummyBufferObject.RefCount = 1000*1000*1000; /* never delete */

   _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj,
                                 ctx->Shared->NullBufferObj);
   _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj,
                                 ctx->Shared->NullBufferObj);

   _mesa_reference_buffer_object(ctx, &ctx->CopyReadBuffer,
                                 ctx->Shared->NullBufferObj);
   _mesa_reference_buffer_object(ctx, &ctx->CopyWriteBuffer,
                                 ctx->Shared->NullBufferObj);
}


void
_mesa_free_buffer_objects( struct gl_context *ctx )
{
   _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj, NULL);

   _mesa_reference_buffer_object(ctx, &ctx->CopyReadBuffer, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->CopyWriteBuffer, NULL);
}


/**
 * Bind the specified target to buffer for the specified context.
 * Called by glBindBuffer() and other functions.
 */
static void
bind_buffer_object(struct gl_context *ctx, GLenum target, GLuint buffer)
d401 2
a402 17
   struct gl_buffer_object *oldBufObj;
   struct gl_buffer_object *newBufObj = NULL;
   struct gl_buffer_object **bindTarget = NULL;

   bindTarget = get_buffer_target(ctx, target);
   if (!bindTarget) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferARB(target 0x%x)", target);
      return;
   }

   /* Get pointer to old buffer object (to be unbound) */
   oldBufObj = *bindTarget;
   if (oldBufObj && oldBufObj->Name == buffer)
      return;   /* rebinding the same buffer object- no change */

   /*
    * Get pointer to new buffer object (newBufObj)
d404 3
a406 31
   if (buffer == 0) {
      /* The spec says there's not a buffer object named 0, but we use
       * one internally because it simplifies things.
       */
      newBufObj = ctx->Shared->NullBufferObj;
   }
   else {
      /* non-default buffer object */
      newBufObj = _mesa_lookup_bufferobj(ctx, buffer);
      if (!newBufObj || newBufObj == &DummyBufferObject) {
         /* If this is a new buffer object id, or one which was generated but
          * never used before, allocate a buffer object now.
          */
         ASSERT(ctx->Driver.NewBufferObject);
         newBufObj = ctx->Driver.NewBufferObject(ctx, buffer, target);
         if (!newBufObj) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindBufferARB");
            return;
         }
         _mesa_HashInsert(ctx->Shared->BufferObjects, buffer, newBufObj);
      }
   }
   
   /* bind new buffer */
   _mesa_reference_buffer_object(ctx, bindTarget, newBufObj);

   /* Pass BindBuffer call to device driver */
   if (ctx->Driver.BindBuffer)
      ctx->Driver.BindBuffer( ctx, target, newBufObj );
}

d408 2
a409 15
/**
 * Update the default buffer objects in the given context to reference those
 * specified in the shared state and release those referencing the old 
 * shared state.
 */
void
_mesa_update_default_objects_buffer_objects(struct gl_context *ctx)
{
   /* Bind the NullBufferObj to remove references to those
    * in the shared context hash table.
    */
   bind_buffer_object( ctx, GL_ARRAY_BUFFER_ARB, 0);
   bind_buffer_object( ctx, GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
   bind_buffer_object( ctx, GL_PIXEL_PACK_BUFFER_ARB, 0);
   bind_buffer_object( ctx, GL_PIXEL_UNPACK_BUFFER_ARB, 0);
a422 2
 * If we're not using a PBO, this is a no-op.
 *
d441 1
a441 2
   if (!_mesa_is_bufferobj(pack->BufferObj))
      return GL_TRUE;  /* no PBO, OK */
d473 2
a474 7
 * For commands that read from a PBO (glDrawPixels, glTexImage,
 * glPolygonStipple, etc), if we're reading from a PBO, map it read-only
 * and return the pointer into the PBO.  If we're not reading from a
 * PBO, return \p src as-is.
 * If non-null return, must call _mesa_unmap_pbo_source() when done.
 *
 * \return NULL if error, else pointer to start of data
d476 8
a483 23
const GLvoid *
_mesa_map_pbo_source(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *unpack,
                     const GLvoid *src)
{
   const GLubyte *buf;

   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      /* unpack from PBO */
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              unpack->BufferObj);
      if (!buf)
         return NULL;

      buf = ADD_POINTERS(buf, src);
   }
   else {
      /* unpack from normal memory */
      buf = src;
   }

   return buf;
a486 29
/**
 * Combine PBO-read validation and mapping.
 * If any GL errors are detected, they'll be recorded and NULL returned.
 * \sa _mesa_validate_pbo_access
 * \sa _mesa_map_pbo_source
 * A call to this function should have a matching call to
 * _mesa_unmap_pbo_source().
 */
const GLvoid *
_mesa_map_validate_pbo_source(struct gl_context *ctx,
                              GLuint dimensions,
                              const struct gl_pixelstore_attrib *unpack,
                              GLsizei width, GLsizei height, GLsizei depth,
                              GLenum format, GLenum type, const GLvoid *ptr,
                              const char *where)
{
   ASSERT(dimensions == 1 || dimensions == 2 || dimensions == 3);

   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
      /* non-PBO access: no validation to be done */
      return ptr;
   }

   if (!_mesa_validate_pbo_access(dimensions, unpack,
                                  width, height, depth, format, type, ptr)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(out of bounds PBO access)", where);
      return NULL;
   }
d488 3
a490 5
   if (_mesa_bufferobj_mapped(unpack->BufferObj)) {
      /* buffer is already mapped - that's an error */
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(PBO is mapped)", where);
      return NULL;
   }
d492 8
a499 3
   ptr = _mesa_map_pbo_source(ctx, unpack, ptr);
   return ptr;
}
d501 16
a516 12

/**
 * Counterpart to _mesa_map_pbo_source()
 */
void
_mesa_unmap_pbo_source(struct gl_context *ctx,
                       const struct gl_pixelstore_attrib *unpack)
{
   ASSERT(unpack != &ctx->Pack); /* catch pack/unpack mismatch */
   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
a517 1
}
d519 4
d524 8
a531 24
/**
 * For commands that write to a PBO (glReadPixels, glGetColorTable, etc),
 * if we're writing to a PBO, map it write-only and return the pointer
 * into the PBO.  If we're not writing to a PBO, return \p dst as-is.
 * If non-null return, must call _mesa_unmap_pbo_dest() when done.
 *
 * \return NULL if error, else pointer to start of data
 */
void *
_mesa_map_pbo_dest(struct gl_context *ctx,
                   const struct gl_pixelstore_attrib *pack,
                   GLvoid *dest)
{
   void *buf;

   if (_mesa_is_bufferobj(pack->BufferObj)) {
      /* pack into PBO */
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              pack->BufferObj);
      if (!buf)
         return NULL;

      buf = ADD_POINTERS(buf, dest);
d534 12
a545 2
      /* pack to normal memory */
      buf = dest;
d547 4
d552 3
a554 2
   return buf;
}
d556 9
a564 29

/**
 * Combine PBO-write validation and mapping.
 * If any GL errors are detected, they'll be recorded and NULL returned.
 * \sa _mesa_validate_pbo_access
 * \sa _mesa_map_pbo_dest
 * A call to this function should have a matching call to
 * _mesa_unmap_pbo_dest().
 */
GLvoid *
_mesa_map_validate_pbo_dest(struct gl_context *ctx,
                            GLuint dimensions,
                            const struct gl_pixelstore_attrib *unpack,
                            GLsizei width, GLsizei height, GLsizei depth,
                            GLenum format, GLenum type, GLvoid *ptr,
                            const char *where)
{
   ASSERT(dimensions == 1 || dimensions == 2 || dimensions == 3);

   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
      /* non-PBO access: no validation to be done */
      return ptr;
   }

   if (!_mesa_validate_pbo_access(dimensions, unpack,
                                  width, height, depth, format, type, ptr)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(out of bounds PBO access)", where);
      return NULL;
a565 9

   if (_mesa_bufferobj_mapped(unpack->BufferObj)) {
      /* buffer is already mapped - that's an error */
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(PBO is mapped)", where);
      return NULL;
   }

   ptr = _mesa_map_pbo_dest(ctx, unpack, ptr);
   return ptr;
d570 4
a573 1
 * Counterpart to _mesa_map_pbo_dest()
d575 2
a576 3
void
_mesa_unmap_pbo_dest(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *pack)
d578 7
a584 3
   ASSERT(pack != &ctx->Unpack); /* catch pack/unpack mismatch */
   if (_mesa_is_bufferobj(pack->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT, pack->BufferObj);
a585 1
}
d587 7
d595 1
d597 34
a630 106
/**
 * Return the gl_buffer_object for the given ID.
 * Always return NULL for ID 0.
 */
struct gl_buffer_object *
_mesa_lookup_bufferobj(struct gl_context *ctx, GLuint buffer)
{
   if (buffer == 0)
      return NULL;
   else
      return (struct gl_buffer_object *)
         _mesa_HashLookup(ctx->Shared->BufferObjects, buffer);
}


/**
 * If *ptr points to obj, set ptr = the Null/default buffer object.
 * This is a helper for buffer object deletion.
 * The GL spec says that deleting a buffer object causes it to get
 * unbound from all arrays in the current context.
 */
static void
unbind(struct gl_context *ctx,
       struct gl_buffer_object **ptr,
       struct gl_buffer_object *obj)
{
   if (*ptr == obj) {
      _mesa_reference_buffer_object(ctx, ptr, ctx->Shared->NullBufferObj);
   }
}


/**
 * Plug default/fallback buffer object functions into the device
 * driver hooks.
 */
void
_mesa_init_buffer_object_functions(struct dd_function_table *driver)
{
   /* GL_ARB_vertex/pixel_buffer_object */
   driver->NewBufferObject = _mesa_new_buffer_object;
   driver->DeleteBuffer = _mesa_delete_buffer_object;
   driver->BindBuffer = NULL;
   driver->BufferData = _mesa_buffer_data;
   driver->BufferSubData = _mesa_buffer_subdata;
   driver->GetBufferSubData = _mesa_buffer_get_subdata;
   driver->MapBuffer = _mesa_buffer_map;
   driver->UnmapBuffer = _mesa_buffer_unmap;

   /* GL_ARB_map_buffer_range */
   driver->MapBufferRange = _mesa_buffer_map_range;
   driver->FlushMappedBufferRange = _mesa_buffer_flush_mapped_range;

   /* GL_ARB_copy_buffer */
   driver->CopyBufferSubData = _mesa_copy_buffer_subdata;
}



/**********************************************************************/
/* API Functions                                                      */
/**********************************************************************/

void GLAPIENTRY
_mesa_BindBufferARB(GLenum target, GLuint buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   bind_buffer_object(ctx, target, buffer);
}


/**
 * Delete a set of buffer objects.
 * 
 * \param n      Number of buffer objects to delete.
 * \param ids    Array of \c n buffer object IDs.
 */
void GLAPIENTRY
_mesa_DeleteBuffersARB(GLsizei n, const GLuint *ids)
{
   GET_CURRENT_CONTEXT(ctx);
   GLsizei i;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteBuffersARB(n)");
      return;
   }

   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);

   for (i = 0; i < n; i++) {
      struct gl_buffer_object *bufObj = _mesa_lookup_bufferobj(ctx, ids[i]);
      if (bufObj) {
         struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
         GLuint j;

         ASSERT(bufObj->Name == ids[i] || bufObj == &DummyBufferObject);

         if (_mesa_bufferobj_mapped(bufObj)) {
            /* if mapped, unmap it now */
            ctx->Driver.UnmapBuffer(ctx, 0, bufObj);
            bufObj->AccessFlags = DEFAULT_ACCESS;
            bufObj->Pointer = NULL;
d632 6
a637 12

         /* unbind any vertex pointers bound to this buffer */
         unbind(ctx, &arrayObj->Vertex.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Weight.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Normal.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Color.BufferObj, bufObj);
         unbind(ctx, &arrayObj->SecondaryColor.BufferObj, bufObj);
         unbind(ctx, &arrayObj->FogCoord.BufferObj, bufObj);
         unbind(ctx, &arrayObj->Index.BufferObj, bufObj);
         unbind(ctx, &arrayObj->EdgeFlag.BufferObj, bufObj);
         for (j = 0; j < Elements(arrayObj->TexCoord); j++) {
            unbind(ctx, &arrayObj->TexCoord[j].BufferObj, bufObj);
d639 6
a644 2
         for (j = 0; j < Elements(arrayObj->VertexAttrib); j++) {
            unbind(ctx, &arrayObj->VertexAttrib[j].BufferObj, bufObj);
a653 1
         /* unbind any pixel pack/unpack pointers bound to this buffer */
d661 3
a663 3
         /* The ID is immediately freed for re-use */
         _mesa_HashRemove(ctx->Shared->BufferObjects, ids[i]);
         _mesa_reference_buffer_object(ctx, &bufObj, NULL);
d701 1
a701 1
   /* Insert the ID and pointer to dummy buffer object into hash table */
d703 10
a712 2
      _mesa_HashInsert(ctx->Shared->BufferObjects, first + i,
                       &DummyBufferObject);
d738 1
a738 1
   return bufObj && bufObj != &DummyBufferObject;
d756 14
a769 14
   case GL_STREAM_DRAW_ARB:
   case GL_STREAM_READ_ARB:
   case GL_STREAM_COPY_ARB:
   case GL_STATIC_DRAW_ARB:
   case GL_STATIC_READ_ARB:
   case GL_STATIC_COPY_ARB:
   case GL_DYNAMIC_DRAW_ARB:
   case GL_DYNAMIC_READ_ARB:
   case GL_DYNAMIC_COPY_ARB:
      /* OK */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferDataARB(usage)");
      return;
d777 2
a778 2
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferDataARB(buffer 0)" );
d782 3
a784 5
   if (_mesa_bufferobj_mapped(bufObj)) {
      /* Unmap the existing buffer.  We'll replace it now.  Not an error. */
      ctx->Driver.UnmapBuffer(ctx, target, bufObj);
      bufObj->AccessFlags = DEFAULT_ACCESS;
      ASSERT(bufObj->Pointer == NULL);
d787 1
a787 3
   FLUSH_VERTICES(ctx, _NEW_BUFFER_OBJECT);

   bufObj->Written = GL_TRUE;
d789 2
a790 13
#ifdef VBO_DEBUG
   printf("glBufferDataARB(%u, sz %ld, from %p, usage 0x%x)\n",
                bufObj->Name, size, data, usage);
#endif

#ifdef BOUNDS_CHECK
   size += 100;
#endif

   ASSERT(ctx->Driver.BufferData);
   if (!ctx->Driver.BufferData( ctx, target, size, data, usage, bufObj )) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBufferDataARB()");
   }
a808 5
   if (size == 0)
      return;

   bufObj->Written = GL_TRUE;

a838 3
   GLbitfield accessFlags;
   void *map;

d842 8
a849 12
   case GL_READ_ONLY_ARB:
      accessFlags = GL_MAP_READ_BIT;
      break;
   case GL_WRITE_ONLY_ARB:
      accessFlags = GL_MAP_WRITE_BIT;
      break;
   case GL_READ_WRITE_ARB:
      accessFlags = GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glMapBufferARB(access)");
      return NULL;
d857 2
a858 2
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMapBufferARB(buffer 0)" );
d861 1
a861 1
   if (_mesa_bufferobj_mapped(bufObj)) {
d867 3
a869 4
   map = ctx->Driver.MapBuffer( ctx, target, access, bufObj );
   if (!map) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMapBufferARB(map failed)");
      return NULL;
d871 2
a872 35
   else {
      /* The driver callback should have set these fields.
       * This is important because other modules (like VBO) might call
       * the driver function directly.
       */
      ASSERT(bufObj->Pointer == map);
      ASSERT(bufObj->Length == bufObj->Size);
      ASSERT(bufObj->Offset == 0);
      bufObj->AccessFlags = accessFlags;
   }

   if (access == GL_WRITE_ONLY_ARB || access == GL_READ_WRITE_ARB)
      bufObj->Written = GL_TRUE;

#ifdef VBO_DEBUG
   printf("glMapBufferARB(%u, sz %ld, access 0x%x)\n",
	  bufObj->Name, bufObj->Size, access);
   if (access == GL_WRITE_ONLY_ARB) {
      GLuint i;
      GLubyte *b = (GLubyte *) bufObj->Pointer;
      for (i = 0; i < bufObj->Size; i++)
         b[i] = i & 0xff;
   }
#endif

#ifdef BOUNDS_CHECK
   {
      GLubyte *buf = (GLubyte *) bufObj->Pointer;
      GLuint i;
      /* buffer is 100 bytes larger than requested, fill with magic value */
      for (i = 0; i < 100; i++) {
         buf[bufObj->Size - i - 1] = 123;
      }
   }
#endif
d891 1
a891 1
   if (!_mesa_is_bufferobj(bufObj)) {
d895 1
a895 1
   if (!_mesa_bufferobj_mapped(bufObj)) {
d900 2
a901 13
#ifdef BOUNDS_CHECK
   if (bufObj->Access != GL_READ_ONLY_ARB) {
      GLubyte *buf = (GLubyte *) bufObj->Pointer;
      GLuint i;
      /* check that last 100 bytes are still = magic value */
      for (i = 0; i < 100; i++) {
         GLuint pos = bufObj->Size - i - 1;
         if (buf[pos] != 123) {
            _mesa_warning(ctx, "Out of bounds buffer object write detected"
                          " at position %d (value = %u)\n",
                          pos, buf[pos]);
         }
      }
a902 1
#endif
d904 2
a905 25
#ifdef VBO_DEBUG
   if (bufObj->AccessFlags & GL_MAP_WRITE_BIT) {
      GLuint i, unchanged = 0;
      GLubyte *b = (GLubyte *) bufObj->Pointer;
      GLint pos = -1;
      /* check which bytes changed */
      for (i = 0; i < bufObj->Size - 1; i++) {
         if (b[i] == (i & 0xff) && b[i+1] == ((i+1) & 0xff)) {
            unchanged++;
            if (pos == -1)
               pos = i;
         }
      }
      if (unchanged) {
         printf("glUnmapBufferARB(%u): %u of %ld unchanged, starting at %d\n",
                      bufObj->Name, unchanged, bufObj->Size, pos);
      }
   }
#endif

   status = ctx->Driver.UnmapBuffer( ctx, target, bufObj );
   bufObj->AccessFlags = DEFAULT_ACCESS;
   ASSERT(bufObj->Pointer == NULL);
   ASSERT(bufObj->Offset == 0);
   ASSERT(bufObj->Length == 0);
d920 1
a920 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameterivARB(target)" );
d923 2
a924 2
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetBufferParameterivARB" );
d929 15
a943 89
   case GL_BUFFER_SIZE_ARB:
      *params = (GLint) bufObj->Size;
      return;
   case GL_BUFFER_USAGE_ARB:
      *params = bufObj->Usage;
      return;
   case GL_BUFFER_ACCESS_ARB:
      *params = simplified_access_mode(bufObj->AccessFlags);
      return;
   case GL_BUFFER_MAPPED_ARB:
      *params = _mesa_bufferobj_mapped(bufObj);
      return;
   case GL_BUFFER_ACCESS_FLAGS:
      if (ctx->VersionMajor < 3)
         goto invalid_pname;
      *params = bufObj->AccessFlags;
      return;
   case GL_BUFFER_MAP_OFFSET:
      if (ctx->VersionMajor < 3)
         goto invalid_pname;
      *params = (GLint) bufObj->Offset;
      return;
   case GL_BUFFER_MAP_LENGTH:
      if (ctx->VersionMajor < 3)
         goto invalid_pname;
      *params = (GLint) bufObj->Length;
      return;
   default:
      ; /* fall-through */
   }

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameterivARB(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
}


/**
 * New in GL 3.2
 * This is pretty much a duplicate of GetBufferParameteriv() but the
 * GL_BUFFER_SIZE_ARB attribute will be 64-bits on a 64-bit system.
 */
void GLAPIENTRY
_mesa_GetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameteri64v(target)" );
      return;
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetBufferParameteri64v" );
      return;
   }

   switch (pname) {
   case GL_BUFFER_SIZE_ARB:
      *params = bufObj->Size;
      return;
   case GL_BUFFER_USAGE_ARB:
      *params = bufObj->Usage;
      return;
   case GL_BUFFER_ACCESS_ARB:
      *params = simplified_access_mode(bufObj->AccessFlags);
      return;
   case GL_BUFFER_ACCESS_FLAGS:
      if (ctx->VersionMajor < 3)
         goto invalid_pname;
      *params = bufObj->AccessFlags;
      return;
   case GL_BUFFER_MAPPED_ARB:
      *params = _mesa_bufferobj_mapped(bufObj);
      return;
   case GL_BUFFER_MAP_OFFSET:
      if (ctx->VersionMajor < 3)
         goto invalid_pname;
      *params = bufObj->Offset;
      return;
   case GL_BUFFER_MAP_LENGTH:
      if (ctx->VersionMajor < 3)
         goto invalid_pname;
      *params = bufObj->Length;
      return;
   default:
      ; /* fall-through */
a944 4

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetBufferParameteri64v(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
d965 1
a965 1
   if (!_mesa_is_bufferobj(bufObj)) {
a971 626


void GLAPIENTRY
_mesa_CopyBufferSubData(GLenum readTarget, GLenum writeTarget,
                        GLintptr readOffset, GLintptr writeOffset,
                        GLsizeiptr size)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *src, *dst;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   src = get_buffer(ctx, readTarget);
   if (!src || !_mesa_is_bufferobj(src)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glCopyBuffserSubData(readTarget = 0x%x)", readTarget);
      return;
   }

   dst = get_buffer(ctx, writeTarget);
   if (!dst || !_mesa_is_bufferobj(dst)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glCopyBuffserSubData(writeTarget = 0x%x)", writeTarget);
      return;
   }

   if (_mesa_bufferobj_mapped(src)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyBuffserSubData(readBuffer is mapped)");
      return;
   }

   if (_mesa_bufferobj_mapped(dst)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyBuffserSubData(writeBuffer is mapped)");
      return;
   }

   if (readOffset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBuffserSubData(readOffset = %d)", (int) readOffset);
      return;
   }

   if (writeOffset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBuffserSubData(writeOffset = %d)", (int) writeOffset);
      return;
   }

   if (readOffset + size > src->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBuffserSubData(readOffset + size = %d)",
                  (int) (readOffset + size));
      return;
   }

   if (writeOffset + size > dst->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBuffserSubData(writeOffset + size = %d)",
                  (int) (writeOffset + size));
      return;
   }

   if (src == dst) {
      if (readOffset + size <= writeOffset) {
         /* OK */
      }
      else if (writeOffset + size <= readOffset) {
         /* OK */
      }
      else {
         /* overlapping src/dst is illegal */
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyBuffserSubData(overlapping src/dst)");
         return;
      }
   }

   ctx->Driver.CopyBufferSubData(ctx, src, dst, readOffset, writeOffset, size);
}


/**
 * See GL_ARB_map_buffer_range spec
 */
void * GLAPIENTRY
_mesa_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length,
                     GLbitfield access)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   void *map;

   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, NULL);

   if (!ctx->Extensions.ARB_map_buffer_range) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(extension not supported)");
      return NULL;
   }

   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset = %ld)", (long)offset);
      return NULL;
   }

   if (length < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(length = %ld)", (long)length);
      return NULL;
   }

   if ((access & (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT)) == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(access indicates neither read or write)");
      return NULL;
   }

   if (access & GL_MAP_READ_BIT) {
      if ((access & GL_MAP_INVALIDATE_RANGE_BIT) ||
          (access & GL_MAP_INVALIDATE_BUFFER_BIT) ||
          (access & GL_MAP_UNSYNCHRONIZED_BIT)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glMapBufferRange(invalid access flags)");
         return NULL;
      }
   }

   if ((access & GL_MAP_FLUSH_EXPLICIT_BIT) &&
       ((access & GL_MAP_WRITE_BIT) == 0)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid access flags)");
      return NULL;
   }

   bufObj = get_buffer(ctx, target);
   if (!bufObj || !_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glMapBufferRange(target = 0x%x)", target);
      return NULL;
   }

   if (offset + length > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset + length > size)");
      return NULL;
   }

   if (_mesa_bufferobj_mapped(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(buffer already mapped)");
      return NULL;
   }
      
   ASSERT(ctx->Driver.MapBufferRange);
   map = ctx->Driver.MapBufferRange(ctx, target, offset, length,
                                    access, bufObj);
   if (!map) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMapBufferARB(map failed)");
   }
   else {
      /* The driver callback should have set all these fields.
       * This is important because other modules (like VBO) might call
       * the driver function directly.
       */
      ASSERT(bufObj->Pointer == map);
      ASSERT(bufObj->Length == length);
      ASSERT(bufObj->Offset == offset);
      ASSERT(bufObj->AccessFlags == access);
   }

   return map;
}


/**
 * See GL_ARB_map_buffer_range spec
 */
void GLAPIENTRY
_mesa_FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ARB_map_buffer_range) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(extension not supported)");
      return;
   }

   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset = %ld)", (long)offset);
      return;
   }

   if (length < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(length = %ld)", (long)length);
      return;
   }

   bufObj = get_buffer(ctx, target);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glMapBufferRange(target = 0x%x)", target);
      return;
   }

   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(current buffer is 0)");
      return;
   }

   if (!_mesa_bufferobj_mapped(bufObj)) {
      /* buffer is not mapped */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(buffer is not mapped)");
      return;
   }

   if ((bufObj->AccessFlags & GL_MAP_FLUSH_EXPLICIT_BIT) == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(GL_MAP_FLUSH_EXPLICIT_BIT not set)");
      return;
   }

   if (offset + length > bufObj->Length) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glMapBufferRange(offset %ld + length %ld > mapped length %ld)",
		  (long)offset, (long)length, (long)bufObj->Length);
      return;
   }

   ASSERT(bufObj->AccessFlags & GL_MAP_WRITE_BIT);

   if (ctx->Driver.FlushMappedBufferRange)
      ctx->Driver.FlushMappedBufferRange(ctx, target, offset, length, bufObj);
}


#if FEATURE_APPLE_object_purgeable
static GLenum
_mesa_BufferObjectPurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_buffer_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_bufferobj(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectPurgeable(name = 0x%x)", name);
      return 0;
   }
   if (!_mesa_is_bufferobj(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glObjectPurgeable(buffer 0)" );
      return 0;
   }

   if (bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectPurgeable(name = 0x%x) is already purgeable", name);
      return GL_VOLATILE_APPLE;
   }

   bufObj->Purgeable = GL_TRUE;

   retval = GL_VOLATILE_APPLE;
   if (ctx->Driver.BufferObjectPurgeable)
      retval = ctx->Driver.BufferObjectPurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
_mesa_RenderObjectPurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_renderbuffer *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_renderbuffer(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectPurgeable(name = 0x%x) is already purgeable", name);
      return GL_VOLATILE_APPLE;
   }

   bufObj->Purgeable = GL_TRUE;

   retval = GL_VOLATILE_APPLE;
   if (ctx->Driver.RenderObjectPurgeable)
      retval = ctx->Driver.RenderObjectPurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
_mesa_TextureObjectPurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_texture_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_texture(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectPurgeable(name = 0x%x)", name);
      return 0;
   }

   if (bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectPurgeable(name = 0x%x) is already purgeable", name);
      return GL_VOLATILE_APPLE;
   }

   bufObj->Purgeable = GL_TRUE;

   retval = GL_VOLATILE_APPLE;
   if (ctx->Driver.TextureObjectPurgeable)
      retval = ctx->Driver.TextureObjectPurgeable(ctx, bufObj, option);

   return retval;
}


GLenum GLAPIENTRY
_mesa_ObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   GLenum retval;

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectPurgeable(name = 0x%x)", name);
      return 0;
   }

   switch (option) {
   case GL_VOLATILE_APPLE:
   case GL_RELEASED_APPLE:
      /* legal */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectPurgeable(name = 0x%x) invalid option: %d",
                  name, option);
      return 0;
   }

   switch (objectType) {
   case GL_TEXTURE:
      retval = _mesa_TextureObjectPurgeable (ctx, name, option);
      break;
   case GL_RENDERBUFFER_EXT:
      retval = _mesa_RenderObjectPurgeable (ctx, name, option);
      break;
   case GL_BUFFER_OBJECT_APPLE:
      retval = _mesa_BufferObjectPurgeable (ctx, name, option);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectPurgeable(name = 0x%x) invalid type: %d",
                  name, objectType);
      return 0;
   }

   /* In strict conformance to the spec, we must only return VOLATILE when
    * when passed the VOLATILE option. Madness.
    *
    * XXX First fix the spec, then fix me.
    */
   return option == GL_VOLATILE_APPLE ? GL_VOLATILE_APPLE : retval;
}


static GLenum
_mesa_BufferObjectUnpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_buffer_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_bufferobj(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (! bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectUnpurgeable(name = 0x%x) object is "
                  " already \"unpurged\"", name);
      return 0;
   }

   bufObj->Purgeable = GL_FALSE;

   retval = option;
   if (ctx->Driver.BufferObjectUnpurgeable)
      retval = ctx->Driver.BufferObjectUnpurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
_mesa_RenderObjectUnpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_renderbuffer *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_renderbuffer(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (! bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectUnpurgeable(name = 0x%x) object is "
                  " already \"unpurged\"", name);
      return 0;
   }

   bufObj->Purgeable = GL_FALSE;

   retval = option;
   if (ctx->Driver.RenderObjectUnpurgeable)
      retval = ctx->Driver.RenderObjectUnpurgeable(ctx, bufObj, option);

   return retval;
}


static GLenum
_mesa_TextureObjectUnpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
{
   struct gl_texture_object *bufObj;
   GLenum retval;

   bufObj = _mesa_lookup_texture(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   if (! bufObj->Purgeable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glObjectUnpurgeable(name = 0x%x) object is"
                  " already \"unpurged\"", name);
      return 0;
   }

   bufObj->Purgeable = GL_FALSE;

   retval = option;
   if (ctx->Driver.TextureObjectUnpurgeable)
      retval = ctx->Driver.TextureObjectUnpurgeable(ctx, bufObj, option);

   return retval;
}


GLenum GLAPIENTRY
_mesa_ObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return 0;
   }

   switch (option) {
   case GL_RETAINED_APPLE:
   case GL_UNDEFINED_APPLE:
      /* legal */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectUnpurgeable(name = 0x%x) invalid option: %d",
                  name, option);
      return 0;
   }

   switch (objectType) {
   case GL_BUFFER_OBJECT_APPLE:
      return _mesa_BufferObjectUnpurgeable(ctx, name, option);
   case GL_TEXTURE:
      return _mesa_TextureObjectUnpurgeable(ctx, name, option);
   case GL_RENDERBUFFER_EXT:
      return _mesa_RenderObjectUnpurgeable(ctx, name, option);
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glObjectUnpurgeable(name = 0x%x) invalid type: %d",
                  name, objectType);
      return 0;
   }
}


static void
_mesa_GetBufferObjectParameterivAPPLE(struct gl_context *ctx, GLuint name,
                                      GLenum pname, GLint* params)
{
   struct gl_buffer_object *bufObj;

   bufObj = _mesa_lookup_bufferobj(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glGetObjectParameteriv(name = 0x%x) invalid object", name);
      return;
   }

   switch (pname) {
   case GL_PURGEABLE_APPLE:
      *params = bufObj->Purgeable;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid enum: %d",
                  name, pname);
      break;
   }
}


static void
_mesa_GetRenderObjectParameterivAPPLE(struct gl_context *ctx, GLuint name,
                                      GLenum pname, GLint* params)
{
   struct gl_renderbuffer *bufObj;

   bufObj = _mesa_lookup_renderbuffer(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return;
   }

   switch (pname) {
   case GL_PURGEABLE_APPLE:
      *params = bufObj->Purgeable;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid enum: %d",
                  name, pname);
      break;
   }
}


static void
_mesa_GetTextureObjectParameterivAPPLE(struct gl_context *ctx, GLuint name,
                                       GLenum pname, GLint* params)
{
   struct gl_texture_object *bufObj;

   bufObj = _mesa_lookup_texture(ctx, name);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glObjectUnpurgeable(name = 0x%x)", name);
      return;
   }

   switch (pname) {
   case GL_PURGEABLE_APPLE:
      *params = bufObj->Purgeable;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid enum: %d",
                  name, pname);
      break;
   }
}


void GLAPIENTRY
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname,
                                GLint* params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glGetObjectParameteriv(name = 0x%x)", name);
      return;
   }

   switch (objectType) {
   case GL_TEXTURE:
      _mesa_GetTextureObjectParameterivAPPLE (ctx, name, pname, params);
      break;
   case GL_BUFFER_OBJECT_APPLE:
      _mesa_GetBufferObjectParameterivAPPLE (ctx, name, pname, params);
      break;
   case GL_RENDERBUFFER_EXT:
      _mesa_GetRenderObjectParameterivAPPLE (ctx, name, pname, params);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetObjectParameteriv(name = 0x%x) invalid type: %d",
                  name, objectType);
   }
}

#endif /* FEATURE_APPLE_object_purgeable */
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d33 1
a33 1
#include <stdbool.h>
a41 1
#include "mtypes.h"
a42 2
#include "transformfeedback.h"
#include "dispatch.h"
d50 7
d71 1
a71 1
static inline struct gl_buffer_object **
a73 6
   /* Other targets are only supported in desktop OpenGL and OpenGL ES 3.0.
    */
   if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx)
       && target != GL_ARRAY_BUFFER && target != GL_ELEMENT_ARRAY_BUFFER)
      return NULL;

d78 1
a78 1
      return &ctx->Array.ArrayObj->ElementArrayBufferObj;
d87 1
d93 1
a93 11
   case GL_TEXTURE_BUFFER:
      if (ctx->API == API_OPENGL_CORE &&
          ctx->Extensions.ARB_texture_buffer_object) {
         return &ctx->Texture.BufferObject;
      }
      break;
   case GL_UNIFORM_BUFFER:
      if (ctx->Extensions.ARB_uniform_buffer_object) {
         return &ctx->UniformBuffer;
      }
      break;
d108 2
a109 2
static inline struct gl_buffer_object *
get_buffer(struct gl_context *ctx, const char *func, GLenum target)
d112 3
a114 12

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", func);
      return NULL;
   }

   if (!_mesa_is_bufferobj(*bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(buffer 0)", func);
      return NULL;
   }

   return *bufObj;
d123 1
a123 1
simplified_access_mode(struct gl_context *ctx, GLbitfield access)
d132 1
a132 22

   /* Otherwise, AccessFlags is zero (the default state).
    *
    * Table 2.6 on page 31 (page 44 of the PDF) of the OpenGL 1.5 spec says:
    *
    * Name           Type  Initial Value  Legal Values
    * ...            ...   ...            ...
    * BUFFER_ACCESS  enum  READ_WRITE     READ_ONLY, WRITE_ONLY
    *                                     READ_WRITE
    *
    * However, table 6.8 in the GL_OES_mapbuffer extension says:
    *
    * Get Value         Type Get Command          Value          Description
    * ---------         ---- -----------          -----          -----------
    * BUFFER_ACCESS_OES Z1   GetBufferParameteriv WRITE_ONLY_OES buffer map flag
    *
    * The difference is because GL_OES_mapbuffer only supports mapping buffers
    * write-only.
    */
   assert(access == 0);

   return _mesa_is_gles(ctx) ? GL_WRITE_ONLY : GL_READ_WRITE;
d169 7
a175 2
   bufObj = get_buffer(ctx, caller, target);
   if (!bufObj)
d177 1
a177 1

d180 1
a180 4
		  "%s(offset %lu + size %lu > buffer size %lu)", caller,
                  (unsigned long) offset,
                  (unsigned long) size,
                  (unsigned long) bufObj->Size);
d206 1
a206 1
   _mesa_initialize_buffer_object(ctx, obj, name, target);
d217 1
a217 2
_mesa_delete_buffer_object(struct gl_context *ctx,
                           struct gl_buffer_object *bufObj)
d221 2
a222 1
   free(bufObj->Data);
a235 2
 * This is normally only called from the _mesa_reference_buffer_object() macro
 * when there's a real pointer change.
d238 3
a240 3
_mesa_reference_buffer_object_(struct gl_context *ctx,
                               struct gl_buffer_object **ptr,
                               struct gl_buffer_object *bufObj)
d242 3
d266 1
a266 1
	 ASSERT(ctx->Array.ArrayObj->ElementArrayBufferObj != bufObj);
d304 1
a304 2
_mesa_initialize_buffer_object( struct gl_context *ctx,
				struct gl_buffer_object *obj,
d314 1
a314 31
   obj->AccessFlags = 0;
}



/**
 * Callback called from _mesa_HashWalk()
 */
static void
count_buffer_size(GLuint key, void *data, void *userData)
{
   const struct gl_buffer_object *bufObj =
      (const struct gl_buffer_object *) data;
   GLuint *total = (GLuint *) userData;

   *total = *total + bufObj->Size;
}


/**
 * Compute total size (in bytes) of all buffer objects for the given context.
 * For debugging purposes.
 */
GLuint
_mesa_total_buffer_object_memory(struct gl_context *ctx)
{
   GLuint total = 0;

   _mesa_HashWalk(ctx->Shared->BufferObjects, count_buffer_size, &total);

   return total;
d382 1
a382 1
_mesa_buffer_subdata( struct gl_context *ctx, GLintptrARB offset,
d386 1
a386 1
   (void) ctx;
d415 1
a415 1
_mesa_buffer_get_subdata( struct gl_context *ctx, GLintptrARB offset,
d419 1
a419 1
   (void) ctx;
d428 33
d465 1
a465 1
_mesa_buffer_map_range( struct gl_context *ctx, GLintptr offset,
d470 1
d486 1
a486 1
_mesa_buffer_flush_mapped_range( struct gl_context *ctx,
d491 1
d507 2
a508 1
_mesa_buffer_unmap( struct gl_context *ctx, struct gl_buffer_object *bufObj )
d511 1
d523 1
a523 1
 * Called via glCopyBufferSubData().
d534 1
a534 1
   /* the buffers should not be mapped */
d538 4
a541 17
   if (src == dst) {
      srcPtr = dstPtr = ctx->Driver.MapBufferRange(ctx, 0, src->Size,
						   GL_MAP_READ_BIT |
						   GL_MAP_WRITE_BIT, src);

      if (!srcPtr)
	 return;

      srcPtr += readOffset;
      dstPtr += writeOffset;
   } else {
      srcPtr = ctx->Driver.MapBufferRange(ctx, readOffset, size,
					  GL_MAP_READ_BIT, src);
      dstPtr = ctx->Driver.MapBufferRange(ctx, writeOffset, size,
					  (GL_MAP_WRITE_BIT |
					   GL_MAP_INVALIDATE_RANGE_BIT), dst);
   }
a542 3
   /* Note: the src and dst regions will never overlap.  Trying to do so
    * would generate GL_INVALID_VALUE earlier.
    */
d544 1
a544 1
      memcpy(dstPtr, srcPtr, size);
d546 2
a547 3
   ctx->Driver.UnmapBuffer(ctx, src);
   if (dst != src)
      ctx->Driver.UnmapBuffer(ctx, dst);
a557 2
   GLuint i;

a558 1
   _glthread_INIT_MUTEX(DummyBufferObject.Mutex);
d563 2
a569 11

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer,
				 ctx->Shared->NullBufferObj);

   for (i = 0; i < MAX_COMBINED_UNIFORM_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->UniformBufferBindings[i].BufferObject,
				    ctx->Shared->NullBufferObj);
      ctx->UniformBufferBindings[i].Offset = -1;
      ctx->UniformBufferBindings[i].Size = -1;
   }
a575 2
   GLuint i;

d577 1
a580 8

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer, NULL);

   for (i = 0; i < MAX_COMBINED_UNIFORM_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->UniformBufferBindings[i].BufferObject,
				    NULL);
   }
a582 29
static bool
handle_bind_buffer_gen(struct gl_context *ctx,
		       GLenum target,
		       GLuint buffer,
		       struct gl_buffer_object **buf_handle)
{
   struct gl_buffer_object *buf = *buf_handle;

   if (!buf && ctx->API == API_OPENGL_CORE) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBindBuffer(non-gen name)");
      return false;
   }

   if (!buf || buf == &DummyBufferObject) {
      /* If this is a new buffer object id, or one which was generated but
       * never used before, allocate a buffer object now.
       */
      ASSERT(ctx->Driver.NewBufferObject);
      buf = ctx->Driver.NewBufferObject(ctx, buffer, target);
      if (!buf) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindBufferARB");
	 return false;
      }
      _mesa_HashInsert(ctx->Shared->BufferObjects, buffer, buf);
      *buf_handle = buf;
   }

   return true;
}
d603 1
a603 1
   if (oldBufObj && oldBufObj->Name == buffer && !oldBufObj->DeletePending)
d618 12
a629 2
      if (!handle_bind_buffer_gen(ctx, target, buffer, &newBufObj))
         return;
d659 242
d948 1
d966 1
a966 1
_mesa_BindBuffer(GLenum target, GLuint buffer)
d969 1
a969 4

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBindBuffer(%s, %u)\n",
                  _mesa_lookup_enum_by_nr(target), buffer);
d982 1
a982 1
_mesa_DeleteBuffers(GLsizei n, const GLuint *ids)
d986 1
a986 1
   FLUSH_VERTICES(ctx, 0);
d1005 2
a1006 2
            ctx->Driver.UnmapBuffer(ctx, bufObj);
            bufObj->AccessFlags = 0;
d1011 11
d1027 1
a1027 17
            _mesa_BindBuffer( GL_ARRAY_BUFFER_ARB, 0 );
         }
         if (arrayObj->ElementArrayBufferObj == bufObj) {
            _mesa_BindBuffer( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );
         }

         /* unbind ARB_copy_buffer binding points */
         if (ctx->CopyReadBuffer == bufObj) {
            _mesa_BindBuffer( GL_COPY_READ_BUFFER, 0 );
         }
         if (ctx->CopyWriteBuffer == bufObj) {
            _mesa_BindBuffer( GL_COPY_WRITE_BUFFER, 0 );
         }

         /* unbind transform feedback binding points */
         if (ctx->TransformFeedback.CurrentBuffer == bufObj) {
            _mesa_BindBuffer( GL_TRANSFORM_FEEDBACK_BUFFER, 0 );
d1029 2
a1030 15
         for (j = 0; j < MAX_FEEDBACK_BUFFERS; j++) {
            if (ctx->TransformFeedback.CurrentObject->Buffers[j] == bufObj) {
               _mesa_BindBufferBase( GL_TRANSFORM_FEEDBACK_BUFFER, j, 0 );
            }
         }

         /* unbind UBO binding points */
         for (j = 0; j < ctx->Const.MaxUniformBufferBindings; j++) {
            if (ctx->UniformBufferBindings[j].BufferObject == bufObj) {
               _mesa_BindBufferBase( GL_UNIFORM_BUFFER, j, 0 );
            }
         }

         if (ctx->UniformBuffer == bufObj) {
            _mesa_BindBuffer( GL_UNIFORM_BUFFER, 0 );
d1035 1
a1035 1
            _mesa_BindBuffer( GL_PIXEL_PACK_BUFFER_EXT, 0 );
d1038 1
a1038 5
            _mesa_BindBuffer( GL_PIXEL_UNPACK_BUFFER_EXT, 0 );
         }

         if (ctx->Texture.BufferObject == bufObj) {
            _mesa_BindBuffer( GL_TEXTURE_BUFFER, 0 );
a1042 11
         /* Make sure we do not run into the classic ABA problem on bind.
          * We don't want to allow re-binding a buffer object that's been
          * "deleted" by glDeleteBuffers().
          *
          * The explicit rebinding to the default object in the current context
          * prevents the above in the current context, but another context
          * sharing the same objects might suffer from this problem.
          * The alternative would be to do the hash lookup in any case on bind
          * which would introduce more runtime overhead than this.
          */
         bufObj->DeletePending = GL_TRUE;
d1058 1
a1058 1
_mesa_GenBuffers(GLsizei n, GLuint *buffer)
d1063 1
a1063 3

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGenBuffers(%d)\n", n);
d1100 1
a1100 1
_mesa_IsBuffer(GLuint id)
d1115 1
a1115 1
_mesa_BufferData(GLenum target, GLsizeiptrARB size,
d1120 1
a1120 7
   bool valid_usage;

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBufferData(%s, %ld, %p, %s)\n",
                  _mesa_lookup_enum_by_nr(target),
                  (long int) size, data,
                  _mesa_lookup_enum_by_nr(usage));
a1128 8
      valid_usage = (ctx->API != API_OPENGLES);
      break;

   case GL_STATIC_DRAW_ARB:
   case GL_DYNAMIC_DRAW_ARB:
      valid_usage = true;
      break;

d1131 1
d1134 1
d1137 1
a1137 1
      valid_usage = _mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx);
a1138 1

d1140 2
a1141 2
      valid_usage = false;
      break;
d1144 3
a1146 2
   if (!valid_usage) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBufferData(usage)");
d1149 2
a1150 3

   bufObj = get_buffer(ctx, "glBufferDataARB", target);
   if (!bufObj)
d1152 2
a1153 1

d1156 2
a1157 2
      ctx->Driver.UnmapBuffer(ctx, bufObj);
      bufObj->AccessFlags = 0;
d1182 1
a1182 1
_mesa_BufferSubData(GLenum target, GLintptrARB offset,
d1187 1
d1202 1
a1202 1
   ctx->Driver.BufferSubData( ctx, offset, size, data, bufObj );
d1207 1
a1207 1
_mesa_GetBufferSubData(GLenum target, GLintptrARB offset,
d1212 1
d1222 1
a1222 1
   ctx->Driver.GetBufferSubData( ctx, offset, size, data, bufObj );
d1227 1
a1227 1
_mesa_MapBuffer(GLenum target, GLenum access)
a1232 1
   bool valid_access;
a1238 1
      valid_access = _mesa_is_desktop_gl(ctx);
a1241 1
      valid_access = true;
a1244 1
      valid_access = _mesa_is_desktop_gl(ctx);
d1247 2
a1248 2
      valid_access = false;
      break;
d1251 3
a1253 2
   if (!valid_access) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glMapBufferARB(access)");
d1256 2
a1257 3

   bufObj = get_buffer(ctx, "glMapBufferARB", target);
   if (!bufObj)
d1259 1
a1259 1

d1265 2
a1266 8
   if (!bufObj->Size) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glMapBuffer(buffer size = 0)");
      return NULL;
   }

   ASSERT(ctx->Driver.MapBufferRange);
   map = ctx->Driver.MapBufferRange(ctx, 0, bufObj->Size, accessFlags, bufObj);
d1312 1
a1312 1
_mesa_UnmapBuffer(GLenum target)
d1319 3
a1321 2
   bufObj = get_buffer(ctx, "glUnmapBufferARB", target);
   if (!bufObj)
d1323 5
a1327 1

d1369 2
a1370 2
   status = ctx->Driver.UnmapBuffer( ctx, bufObj );
   bufObj->AccessFlags = 0;
d1380 1
a1380 1
_mesa_GetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
d1384 1
d1386 7
a1392 2
   bufObj = get_buffer(ctx, "glGetBufferParameterivARB", target);
   if (!bufObj)
d1394 1
d1404 1
a1404 1
      *params = simplified_access_mode(ctx, bufObj->AccessFlags);
d1410 1
a1410 1
      if (!ctx->Extensions.ARB_map_buffer_range)
d1415 1
a1415 1
      if (!ctx->Extensions.ARB_map_buffer_range)
d1420 1
a1420 1
      if (!ctx->Extensions.ARB_map_buffer_range)
d1444 1
d1446 7
a1452 2
   bufObj = get_buffer(ctx, "glGetBufferParameteri64v", target);
   if (!bufObj)
d1454 1
d1464 1
a1464 1
      *params = simplified_access_mode(ctx, bufObj->AccessFlags);
d1467 1
a1467 1
      if (!ctx->Extensions.ARB_map_buffer_range)
d1475 1
a1475 1
      if (!ctx->Extensions.ARB_map_buffer_range)
d1480 1
a1480 1
      if (!ctx->Extensions.ARB_map_buffer_range)
d1495 1
a1495 1
_mesa_GetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
d1499 1
d1506 7
a1512 2
   bufObj = get_buffer(ctx, "glGetBufferPointervARB", target);
   if (!bufObj)
d1514 1
d1527 1
d1529 4
a1532 2
   src = get_buffer(ctx, "glCopyBufferSubData", readTarget);
   if (!src)
d1534 1
d1536 4
a1539 2
   dst = get_buffer(ctx, "glCopyBufferSubData", writeTarget);
   if (!dst)
d1541 1
d1545 1
a1545 1
                  "glCopyBufferSubData(readBuffer is mapped)");
d1551 1
a1551 1
                  "glCopyBufferSubData(writeBuffer is mapped)");
d1557 1
a1557 1
                  "glCopyBufferSubData(readOffset = %d)", (int) readOffset);
d1563 1
a1563 7
                  "glCopyBufferSubData(writeOffset = %d)", (int) writeOffset);
      return;
   }

   if (size < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyBufferSubData(writeOffset = %d)", (int) size);
d1569 1
a1569 1
                  "glCopyBufferSubData(readOffset + size = %d)",
d1576 1
a1576 1
                  "glCopyBufferSubData(writeOffset + size = %d)",
d1591 1
a1591 1
                     "glCopyBufferSubData(overlapping src/dst)");
a1630 24
   /* Page 38 of the PDF of the OpenGL ES 3.0 spec says:
    *
    *     "An INVALID_OPERATION error is generated for any of the following
    *     conditions:
    *
    *     * <length> is zero."
    */
   if (_mesa_is_gles(ctx) && length == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(length = 0)");
      return NULL;
   }

   if (access & ~(GL_MAP_READ_BIT |
                  GL_MAP_WRITE_BIT |
                  GL_MAP_INVALIDATE_RANGE_BIT |
                  GL_MAP_INVALIDATE_BUFFER_BIT |
                  GL_MAP_FLUSH_EXPLICIT_BIT |
                  GL_MAP_UNSYNCHRONIZED_BIT)) {
      /* generate an error if any undefind bit is set */
      _mesa_error(ctx, GL_INVALID_VALUE, "glMapBufferRange(access)");
      return NULL;
   }

d1637 8
a1644 7
   if ((access & GL_MAP_READ_BIT) &&
       (access & (GL_MAP_INVALIDATE_RANGE_BIT |
                  GL_MAP_INVALIDATE_BUFFER_BIT |
                  GL_MAP_UNSYNCHRONIZED_BIT))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid access flags)");
      return NULL;
d1654 4
a1657 2
   bufObj = get_buffer(ctx, "glMapBufferRange", target);
   if (!bufObj)
d1659 1
d1672 1
a1672 17

   if (!bufObj->Size) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glMapBufferRange(buffer size = 0)");
      return NULL;
   }

   /* Mapping zero bytes should return a non-null pointer. */
   if (!length) {
      static long dummy = 0;
      bufObj->Pointer = &dummy;
      bufObj->Length = length;
      bufObj->Offset = offset;
      bufObj->AccessFlags = access;
      return bufObj->Pointer;
   }

d1674 2
a1675 1
   map = ctx->Driver.MapBufferRange(ctx, offset, length, access, bufObj);
d1702 1
d1706 1
a1706 1
                  "glFlushMappedBufferRange(extension not supported)");
d1712 1
a1712 1
                  "glFlushMappedBufferRange(offset = %ld)", (long)offset);
d1718 1
a1718 1
                  "glFlushMappedBufferRange(length = %ld)", (long)length);
d1722 4
a1725 2
   bufObj = get_buffer(ctx, "glFlushMappedBufferRange", target);
   if (!bufObj)
d1727 7
d1738 1
a1738 1
                  "glFlushMappedBufferRange(buffer is not mapped)");
d1744 1
a1744 1
                  "glFlushMappedBufferRange(GL_MAP_FLUSH_EXPLICIT_BIT not set)");
d1750 1
a1750 1
		  "glFlushMappedBufferRange(offset %ld + length %ld > mapped length %ld)",
d1758 1
a1758 1
      ctx->Driver.FlushMappedBufferRange(ctx, offset, length, bufObj);
d1762 1
d1764 1
a1764 1
buffer_object_purgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1797 1
a1797 1
renderbuffer_purgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1826 1
a1826 1
texture_object_purgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1882 1
a1882 1
      retval = texture_object_purgeable(ctx, name, option);
d1885 1
a1885 1
      retval = renderbuffer_purgeable(ctx, name, option);
d1888 1
a1888 1
      retval = buffer_object_purgeable(ctx, name, option);
d1907 1
a1907 1
buffer_object_unpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1937 1
a1937 1
renderbuffer_unpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d1967 1
a1967 1
texture_object_unpurgeable(struct gl_context *ctx, GLuint name, GLenum option)
d2022 1
a2022 1
      return buffer_object_unpurgeable(ctx, name, option);
d2024 1
a2024 1
      return texture_object_unpurgeable(ctx, name, option);
d2026 1
a2026 1
      return renderbuffer_unpurgeable(ctx, name, option);
d2037 2
a2038 2
get_buffer_object_parameteriv(struct gl_context *ctx, GLuint name,
                              GLenum pname, GLint *params)
d2040 3
a2042 1
   struct gl_buffer_object *bufObj = _mesa_lookup_bufferobj(ctx, name);
d2063 2
a2064 2
get_renderbuffer_parameteriv(struct gl_context *ctx, GLuint name,
                             GLenum pname, GLint *params)
d2066 4
a2069 2
   struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, name);
   if (!rb) {
d2077 1
a2077 1
      *params = rb->Purgeable;
d2089 2
a2090 2
get_texture_object_parameteriv(struct gl_context *ctx, GLuint name,
                               GLenum pname, GLint *params)
d2092 4
a2095 2
   struct gl_texture_object *texObj = _mesa_lookup_texture(ctx, name);
   if (!texObj) {
d2103 1
a2103 1
      *params = texObj->Purgeable;
d2116 1
a2116 1
                                GLint *params)
d2128 1
a2128 1
      get_texture_object_parameteriv(ctx, name, pname, params);
d2131 1
a2131 1
      get_buffer_object_parameteriv(ctx, name, pname, params);
d2134 1
a2134 1
      get_renderbuffer_parameteriv(ctx, name, pname, params);
d2143 1
a2143 277
static void
set_ubo_binding(struct gl_context *ctx,
		int index,
		struct gl_buffer_object *bufObj,
		GLintptr offset,
		GLsizeiptr size,
		GLboolean autoSize)
{
   struct gl_uniform_buffer_binding *binding;

   binding = &ctx->UniformBufferBindings[index];
   if (binding->BufferObject == bufObj &&
       binding->Offset == offset &&
       binding->Size == size &&
       binding->AutomaticSize == autoSize) {
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

   _mesa_reference_buffer_object(ctx, &binding->BufferObject, bufObj);
   binding->Offset = offset;
   binding->Size = size;
   binding->AutomaticSize = autoSize;
}

/**
 * Bind a region of a buffer object to a uniform block binding point.
 * \param index  the uniform buffer binding point index
 * \param bufObj  the buffer object
 * \param offset  offset to the start of buffer object region
 * \param size  size of the buffer object region
 */
static void
bind_buffer_range_uniform_buffer(struct gl_context *ctx,
				 GLuint index,
				 struct gl_buffer_object *bufObj,
				 GLintptr offset,
				 GLsizeiptr size)
{
   if (index >= ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(index=%d)", index);
      return;
   }

   if (offset & (ctx->Const.UniformBufferOffsetAlignment - 1)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferRange(offset misalgned %d/%d)", (int) offset,
		  ctx->Const.UniformBufferOffsetAlignment);
      return;
   }

   if (bufObj == ctx->Shared->NullBufferObj) {
      offset = -1;
      size = -1;
   }

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer, bufObj);
   set_ubo_binding(ctx, index, bufObj, offset, size, GL_FALSE);
}


/**
 * Bind a buffer object to a uniform block binding point.
 * As above, but offset = 0.
 */
static void
bind_buffer_base_uniform_buffer(struct gl_context *ctx,
				GLuint index,
				struct gl_buffer_object *bufObj)
{
   if (index >= ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferBase(index=%d)", index);
      return;
   }

   _mesa_reference_buffer_object(ctx, &ctx->UniformBuffer, bufObj);
   if (bufObj == ctx->Shared->NullBufferObj)
      set_ubo_binding(ctx, index, bufObj, -1, -1, GL_TRUE);
   else
      set_ubo_binding(ctx, index, bufObj, 0, 0, GL_TRUE);
}

void GLAPIENTRY
_mesa_BindBufferRange(GLenum target, GLuint index,
                      GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (buffer == 0) {
      bufObj = ctx->Shared->NullBufferObj;
   } else {
      bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   }
   if (!handle_bind_buffer_gen(ctx, target, buffer, &bufObj))
      return;

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferRange(invalid buffer=%u)", buffer);
      return;
   }

   if (buffer != 0) {
      if (size <= 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(size=%d)",
                     (int) size);
         return;
      }
   }

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      _mesa_bind_buffer_range_transform_feedback(ctx, index, bufObj,
						 offset, size);
      return;
   case GL_UNIFORM_BUFFER:
      bind_buffer_range_uniform_buffer(ctx, index, bufObj, offset, size);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferRange(target)");
      return;
   }
}

void GLAPIENTRY
_mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (buffer == 0) {
      bufObj = ctx->Shared->NullBufferObj;
   } else {
      bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   }
   if (!handle_bind_buffer_gen(ctx, target, buffer, &bufObj))
      return;

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferBase(invalid buffer=%u)", buffer);
      return;
   }

   /* Note that there's some oddness in the GL 3.1-GL 3.3 specifications with
    * regards to BindBufferBase.  It says (GL 3.1 core spec, page 63):
    *
    *     "BindBufferBase is equivalent to calling BindBufferRange with offset
    *      zero and size equal to the size of buffer."
    *
    * but it says for glGetIntegeri_v (GL 3.1 core spec, page 230):
    *
    *     "If the parameter (starting offset or size) was not specified when the
    *      buffer object was bound, zero is returned."
    *
    * What happens if the size of the buffer changes?  Does the size of the
    * buffer at the moment glBindBufferBase was called still play a role, like
    * the first quote would imply, or is the size meaningless in the
    * glBindBufferBase case like the second quote would suggest?  The GL 4.1
    * core spec page 45 says:
    *
    *     "It is equivalent to calling BindBufferRange with offset zero, while
    *      size is determined by the size of the bound buffer at the time the
    *      binding is used."
    *
    * My interpretation is that the GL 4.1 spec was a clarification of the
    * behavior, not a change.  In particular, this choice will only make
    * rendering work in cases where it would have had undefined results.
    */

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      _mesa_bind_buffer_base_transform_feedback(ctx, index, bufObj);
      return;
   case GL_UNIFORM_BUFFER:
      bind_buffer_base_uniform_buffer(ctx, index, bufObj);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferBase(target)");
      return;
   }
}

void GLAPIENTRY
_mesa_InvalidateBufferSubData(GLuint buffer, GLintptr offset,
                              GLsizeiptr length)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;
   const GLintptr end = offset + length;

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glInvalidateBufferSubData(name = 0x%x) invalid object",
                  buffer);
      return;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "An INVALID_VALUE error is generated if <offset> or <length> is
    *     negative, or if <offset> + <length> is greater than the value of
    *     BUFFER_SIZE."
    */
   if (end < 0 || end > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glInvalidateBufferSubData(invalid offset or length)");
      return;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "An INVALID_OPERATION error is generated if the buffer is currently
    *     mapped by MapBuffer, or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange."
    */
   if (_mesa_bufferobj_mapped(bufObj)) {
      const GLintptr mapEnd = bufObj->Offset + bufObj->Length;

      /* The regions do not overlap if and only if the end of the discard
       * region is before the mapped region or the start of the discard region
       * is after the mapped region.
       *
       * Note that 'end' and 'mapEnd' are the first byte *after* the discard
       * region and the mapped region, repsectively.  It is okay for that byte
       * to be mapped (for 'end') or discarded (for 'mapEnd').
       */
      if (!(end <= bufObj->Offset || offset >= mapEnd)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glInvalidateBufferSubData(intersection with mapped "
                     "range)");
         return;
      }
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}

void GLAPIENTRY
_mesa_InvalidateBufferData(GLuint buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glInvalidateBufferData(name = 0x%x) invalid object",
                  buffer);
      return;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "An INVALID_OPERATION error is generated if the buffer is currently
    *     mapped by MapBuffer, or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange."
    */
   if (_mesa_bufferobj_mapped(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glInvalidateBufferData(intersection with mapped "
                  "range)");
      return;
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a43 3
#include "teximage.h"
#include "glformats.h"
#include "texstore.h"
d80 1
a80 1
      return &ctx->Array.VAO->IndexBufferObj;
a88 6
   case GL_DRAW_INDIRECT_BUFFER:
      if (ctx->API == API_OPENGL_CORE &&
          ctx->Extensions.ARB_draw_indirect) {
         return &ctx->DrawIndirectBuffer;
      }
      break;
a104 5
   case GL_ATOMIC_COUNTER_BUFFER:
      if (ctx->Extensions.ARB_shader_atomic_counters) {
         return &ctx->AtomicBuffer;
      }
      break;
a115 1
 * \param error  the GL error to record if target is illegal.
d120 1
a120 2
get_buffer(struct gl_context *ctx, const char *func, GLenum target,
           GLenum error)
d130 1
a130 1
      _mesa_error(ctx, error, "%s(no buffer bound)", func);
a177 30
 * Test if the buffer is mapped, and if so, if the mapped range overlaps the
 * given range.
 * The regions do not overlap if and only if the end of the given
 * region is before the mapped region or the start of the given region
 * is after the mapped region.
 *
 * \param obj     Buffer object target on which to operate.
 * \param offset  Offset of the first byte of the subdata range.
 * \param size    Size, in bytes, of the subdata range.
 * \return   true if ranges overlap, false otherwise
 *
 */
static bool
bufferobj_range_mapped(const struct gl_buffer_object *obj,
                       GLintptr offset, GLsizeiptr size)
{
   if (_mesa_bufferobj_mapped(obj, MAP_USER)) {
      const GLintptr end = offset + size;
      const GLintptr mapEnd = obj->Mappings[MAP_USER].Offset +
                              obj->Mappings[MAP_USER].Length;

      if (!(end <= obj->Mappings[MAP_USER].Offset || offset >= mapEnd)) {
         return true;
      }
   }
   return false;
}


/**
d179 1
a179 2
 * \c glBufferSubDataARB, \c glGetBufferSubDataARB and
 * \c glClearBufferSubData.
a184 3
 * \param mappedRange  If true, checks if an overlapping range is mapped.
 *                     If false, checks if buffer is mapped.
 * \param errorNoBuffer  Error code if no buffer is bound to target.
d188 2
a189 1
 *           conditions are invalid.
d191 1
a191 1
 * \sa glBufferSubDataARB, glGetBufferSubDataARB, glClearBufferSubData
d194 3
a196 4
buffer_object_subdata_range_good(struct gl_context * ctx, GLenum target,
                                 GLintptrARB offset, GLsizeiptrARB size,
                                 bool mappedRange, GLenum errorNoBuffer,
                                 const char *caller)
d210 1
a210 1
   bufObj = get_buffer(ctx, caller, target, errorNoBuffer);
d216 1
a216 1
                  "%s(offset %lu + size %lu > buffer size %lu)", caller,
d222 4
a225 15

   if (bufObj->Mappings[MAP_USER].AccessFlags & GL_MAP_PERSISTENT_BIT)
      return bufObj;

   if (mappedRange) {
      if (bufferobj_range_mapped(bufObj, offset, size)) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
   }
   else {
      if (_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
a232 92
 * Test the format and type parameters and set the GL error code for
 * \c glClearBufferData and \c glClearBufferSubData.
 *
 * \param ctx             GL context.
 * \param internalformat  Format to which the data is to be converted.
 * \param format          Format of the supplied data.
 * \param type            Type of the supplied data.
 * \param caller          Name of calling function for recording errors.
 * \return   If internalformat, format and type are legal the mesa_format
 *           corresponding to internalformat, otherwise MESA_FORMAT_NONE.
 *
 * \sa glClearBufferData and glClearBufferSubData
 */
static mesa_format
validate_clear_buffer_format(struct gl_context *ctx,
                             GLenum internalformat,
                             GLenum format, GLenum type,
                             const char *caller)
{
   mesa_format mesaFormat;
   GLenum errorFormatType;

   mesaFormat = _mesa_validate_texbuffer_format(ctx, internalformat);
   if (mesaFormat == MESA_FORMAT_NONE) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(invalid internalformat)", caller);
      return MESA_FORMAT_NONE;
   }

   /* NOTE: not mentioned in ARB_clear_buffer_object but according to
    * EXT_texture_integer there is no conversion between integer and
    * non-integer formats
   */
   if (_mesa_is_enum_format_signed_int(format) !=
       _mesa_is_format_integer_color(mesaFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(integer vs non-integer)", caller);
      return MESA_FORMAT_NONE;
   }

   if (!_mesa_is_color_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(format is not a color format)", caller);
      return MESA_FORMAT_NONE;
   }

   errorFormatType = _mesa_error_check_format_and_type(ctx, format, type);
   if (errorFormatType != GL_NO_ERROR) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(invalid format or type)", caller);
      return MESA_FORMAT_NONE;
   }

   return mesaFormat;
}


/**
 * Convert user-specified clear value to the specified internal format.
 *
 * \param ctx             GL context.
 * \param internalformat  Format to which the data is converted.
 * \param clearValue      Points to the converted clear value.
 * \param format          Format of the supplied data.
 * \param type            Type of the supplied data.
 * \param data            Data which is to be converted to internalformat.
 * \param caller          Name of calling function for recording errors.
 * \return   true if data could be converted, false otherwise.
 *
 * \sa glClearBufferData, glClearBufferSubData
 */
static bool
convert_clear_buffer_data(struct gl_context *ctx,
                          mesa_format internalformat,
                          GLubyte *clearValue, GLenum format, GLenum type,
                          const GLvoid *data, const char *caller)
{
   GLenum internalformatBase = _mesa_get_format_base_format(internalformat);

   if (_mesa_texstore(ctx, 1, internalformatBase, internalformat,
                      0, &clearValue, 1, 1, 1,
                      format, type, data, &ctx->Unpack)) {
      return true;
   }
   else {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
      return false;
   }
}


/**
d261 1
a261 1
   _mesa_align_free(bufObj->Data);
d267 1
a267 2
   mtx_destroy(&bufObj->Mutex);
   free(bufObj->Label);
d288 1
a288 1
      mtx_lock(&oldObj->Mutex);
d296 1
a296 1
      mtx_unlock(&oldObj->Mutex);
d304 2
a305 2
	 ASSERT(ctx->Array.VAO->IndexBufferObj != bufObj);
	 ASSERT(ctx->Array.VAO->Vertex.BufferObj != bufObj);
d318 1
a318 1
      mtx_lock(&bufObj->Mutex);
d333 1
a333 1
      mtx_unlock(&bufObj->Mutex);
d349 1
a349 1
   mtx_init(&obj->Mutex, mtx_plain);
d353 1
d408 1
a408 1
		   const GLvoid * data, GLenum usage, GLenum storageFlags,
d413 1
a413 3
   (void) target;

   _mesa_align_free( bufObj->Data );
d415 1
a415 1
   new_data = _mesa_align_malloc( size, ctx->Const.MinMapBufferAlignment );
a419 1
      bufObj->StorageFlags = storageFlags;
d442 1
a496 54
 * Clear a subrange of the buffer object with copies of the supplied data.
 * If data is NULL the buffer is filled with zeros.
 *
 * This is the default callback for \c dd_function_table::ClearBufferSubData()
 * Note that all GL error checking will have been done already.
 *
 * \param ctx             GL context.
 * \param offset          Offset of the first byte to be cleared.
 * \param size            Size, in bytes, of the to be cleared range.
 * \param clearValue      Source of the data.
 * \param clearValueSize  Size, in bytes, of the supplied data.
 * \param bufObj          Object to be cleared.
 *
 * \sa glClearBufferSubData, glClearBufferData and
 * dd_function_table::ClearBufferSubData.
 */
void
_mesa_buffer_clear_subdata(struct gl_context *ctx,
                           GLintptr offset, GLsizeiptr size,
                           const GLvoid *clearValue,
                           GLsizeiptr clearValueSize,
                           struct gl_buffer_object *bufObj)
{
   GLsizeiptr i;
   GLubyte *dest;

   ASSERT(ctx->Driver.MapBufferRange);
   dest = ctx->Driver.MapBufferRange(ctx, offset, size,
                                     GL_MAP_WRITE_BIT |
                                     GL_MAP_INVALIDATE_RANGE_BIT,
                                     bufObj, MAP_INTERNAL);

   if (!dest) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glClearBuffer[Sub]Data");
      return;
   }

   if (clearValue == NULL) {
      /* Clear with zeros, per the spec */
      memset(dest, 0, size);
      ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_INTERNAL);
      return;
   }

   for (i = 0; i < size/clearValueSize; ++i) {
      memcpy(dest, clearValue, clearValueSize);
      dest += clearValueSize;
   }

   ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_INTERNAL);
}


/**
d503 1
a503 2
                        struct gl_buffer_object *bufObj,
                        gl_map_buffer_index index)
d506 1
a506 1
   assert(!_mesa_bufferobj_mapped(bufObj, index));
d508 5
a512 5
   bufObj->Mappings[index].Pointer = bufObj->Data + offset;
   bufObj->Mappings[index].Length = length;
   bufObj->Mappings[index].Offset = offset;
   bufObj->Mappings[index].AccessFlags = access;
   return bufObj->Mappings[index].Pointer;
d523 1
a523 2
                                 struct gl_buffer_object *obj,
                                 gl_map_buffer_index index)
d541 1
a541 2
_mesa_buffer_unmap(struct gl_context *ctx, struct gl_buffer_object *bufObj,
                   gl_map_buffer_index index)
d545 4
a548 4
   bufObj->Mappings[index].Pointer = NULL;
   bufObj->Mappings[index].Length = 0;
   bufObj->Mappings[index].Offset = 0;
   bufObj->Mappings[index].AccessFlags = 0x0;
d566 4
d573 1
a573 2
						   GL_MAP_WRITE_BIT, src,
                                                   MAP_INTERNAL);
d582 1
a582 2
					  GL_MAP_READ_BIT, src,
                                          MAP_INTERNAL);
d585 1
a585 2
					   GL_MAP_INVALIDATE_RANGE_BIT), dst,
                                          MAP_INTERNAL);
d594 1
a594 1
   ctx->Driver.UnmapBuffer(ctx, src, MAP_INTERNAL);
d596 1
a596 1
      ctx->Driver.UnmapBuffer(ctx, dst, MAP_INTERNAL);
d610 1
a610 1
   mtx_init(&DummyBufferObject.Mutex, mtx_plain);
a623 3
   _mesa_reference_buffer_object(ctx, &ctx->DrawIndirectBuffer,
				 ctx->Shared->NullBufferObj);

a645 2
   _mesa_reference_buffer_object(ctx, &ctx->DrawIndirectBuffer, NULL);

d653 5
a657 6
bool
_mesa_handle_bind_buffer_gen(struct gl_context *ctx,
                             GLenum target,
                             GLuint buffer,
                             struct gl_buffer_object **buf_handle,
                             const char *caller)
d662 1
a662 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-gen name)", caller);
d673 1
a673 1
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
d717 1
a717 2
      if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
                                        &newBufObj, "glBindBuffer"))
d723 4
a763 72
struct gl_buffer_object *
_mesa_lookup_bufferobj_locked(struct gl_context *ctx, GLuint buffer)
{
   return (struct gl_buffer_object *)
      _mesa_HashLookupLocked(ctx->Shared->BufferObjects, buffer);
}


void
_mesa_begin_bufferobj_lookups(struct gl_context *ctx)
{
   _mesa_HashLockMutex(ctx->Shared->BufferObjects);
}


void
_mesa_end_bufferobj_lookups(struct gl_context *ctx)
{
   _mesa_HashUnlockMutex(ctx->Shared->BufferObjects);
}


/**
 * Look up a buffer object for a multi-bind function.
 *
 * Unlike _mesa_lookup_bufferobj(), this function also takes care
 * of generating an error if the buffer ID is not zero or the name
 * of an existing buffer object.
 *
 * If the buffer ID refers to an existing buffer object, a pointer
 * to the buffer object is returned.  If the ID is zero, a pointer
 * to the shared NullBufferObj is returned.  If the ID is not zero
 * and does not refer to a valid buffer object, this function
 * returns NULL.
 *
 * This function assumes that the caller has already locked the
 * hash table mutex by calling _mesa_begin_bufferobj_lookups().
 */
struct gl_buffer_object *
_mesa_multi_bind_lookup_bufferobj(struct gl_context *ctx,
                                  const GLuint *buffers,
                                  GLuint index, const char *caller)
{
   struct gl_buffer_object *bufObj;

   if (buffers[index] != 0) {
      bufObj = _mesa_lookup_bufferobj_locked(ctx, buffers[index]);

      /* The multi-bind functions don't create the buffer objects
         when they don't exist. */
      if (bufObj == &DummyBufferObject)
         bufObj = NULL;
   } else
      bufObj = ctx->Shared->NullBufferObj;

   if (!bufObj) {
      /* The ARB_multi_bind spec says:
       *
       *    "An INVALID_OPERATION error is generated if any value
       *     in <buffers> is not zero or the name of an existing
       *     buffer object (per binding)."
       */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(buffers[%u]=%u is not zero or the name "
                  "of an existing buffer object)",
                  caller, index, buffers[index]);
   }

   return bufObj;
}


d791 1
a796 3
   /* GL_ARB_clear_buffer_object */
   driver->ClearBufferSubData = _mesa_buffer_clear_subdata;

a805 15
void
_mesa_buffer_unmap_all_mappings(struct gl_context *ctx,
                                struct gl_buffer_object *bufObj)
{
   int i;

   for (i = 0; i < MAP_COUNT; i++) {
      if (_mesa_bufferobj_mapped(bufObj, i)) {
         ctx->Driver.UnmapBuffer(ctx, bufObj, i);
         ASSERT(bufObj->Mappings[i].Pointer == NULL);
         bufObj->Mappings[i].AccessFlags = 0;
      }
   }
}

d842 1
a842 1
   mtx_lock(&ctx->Shared->Mutex);
d847 1
a847 1
         struct gl_vertex_array_object *vao = ctx->Array.VAO;
d852 6
a857 1
         _mesa_buffer_unmap_all_mappings(ctx, bufObj);
d860 2
a861 2
         for (j = 0; j < Elements(vao->VertexBinding); j++) {
            unbind(ctx, &vao->VertexBinding[j].BufferObj, bufObj);
d867 1
a867 1
         if (vao->IndexBufferObj == bufObj) {
a870 5
         /* unbind ARB_draw_indirect binding point */
         if (ctx->DrawIndirectBuffer == bufObj) {
            _mesa_BindBuffer( GL_DRAW_INDIRECT_BUFFER, 0 );
         }

d929 1
a929 1
   mtx_unlock(&ctx->Shared->Mutex);
d961 1
a961 1
   mtx_lock(&ctx->Shared->Mutex);
d972 1
a972 1
   mtx_unlock(&ctx->Shared->Mutex);
d990 1
a990 1
   mtx_lock(&ctx->Shared->Mutex);
d992 1
a992 1
   mtx_unlock(&ctx->Shared->Mutex);
a998 58
_mesa_BufferStorage(GLenum target, GLsizeiptr size, const GLvoid *data,
                    GLbitfield flags)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object *bufObj;

   if (size <= 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(size <= 0)");
      return;
   }

   if (flags & ~(GL_MAP_READ_BIT |
                 GL_MAP_WRITE_BIT |
                 GL_MAP_PERSISTENT_BIT |
                 GL_MAP_COHERENT_BIT |
                 GL_DYNAMIC_STORAGE_BIT |
                 GL_CLIENT_STORAGE_BIT)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(flags)");
      return;
   }

   if (flags & GL_MAP_PERSISTENT_BIT &&
       !(flags & (GL_MAP_READ_BIT | GL_MAP_WRITE_BIT))) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(flags!=READ/WRITE)");
      return;
   }

   if (flags & GL_MAP_COHERENT_BIT && !(flags & GL_MAP_PERSISTENT_BIT)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBufferStorage(flags!=PERSISTENT)");
      return;
   }

   bufObj = get_buffer(ctx, "glBufferStorage", target, GL_INVALID_OPERATION);
   if (!bufObj)
      return;

   if (bufObj->Immutable) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferStorage(immutable)");
      return;
   }

   /* Unmap the existing buffer.  We'll replace it now.  Not an error. */
   _mesa_buffer_unmap_all_mappings(ctx, bufObj);

   FLUSH_VERTICES(ctx, _NEW_BUFFER_OBJECT);

   bufObj->Written = GL_TRUE;
   bufObj->Immutable = GL_TRUE;

   ASSERT(ctx->Driver.BufferData);
   if (!ctx->Driver.BufferData(ctx, target, size, data, GL_DYNAMIC_DRAW,
                               flags, bufObj)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBufferStorage()");
   }
}


void GLAPIENTRY
d1046 1
a1046 1
   bufObj = get_buffer(ctx, "glBufferDataARB", target, GL_INVALID_OPERATION);
d1050 6
a1055 7
   if (bufObj->Immutable) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferData(immutable)");
      return;
   }

   /* Unmap the existing buffer.  We'll replace it now.  Not an error. */
   _mesa_buffer_unmap_all_mappings(ctx, bufObj);
d1071 1
a1071 5
   if (!ctx->Driver.BufferData(ctx, target, size, data, usage,
                               GL_MAP_READ_BIT |
                               GL_MAP_WRITE_BIT |
                               GL_DYNAMIC_STORAGE_BIT,
                               bufObj)) {
a1084 1
                                              false, GL_INVALID_OPERATION,
a1090 6
   if (bufObj->Immutable &&
       !(bufObj->StorageFlags & GL_DYNAMIC_STORAGE_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBufferSubData");
      return;
   }

d1108 2
a1109 3
   bufObj = buffer_object_subdata_range_good(ctx, target, offset, size,
                                             false, GL_INVALID_OPERATION,
                                             "glGetBufferSubDataARB");
a1119 109
void GLAPIENTRY
_mesa_ClearBufferData(GLenum target, GLenum internalformat, GLenum format,
                      GLenum type, const GLvoid* data)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object* bufObj;
   mesa_format mesaFormat;
   GLubyte clearValue[MAX_PIXEL_BYTES];
   GLsizeiptr clearValueSize;

   bufObj = get_buffer(ctx, "glClearBufferData", target, GL_INVALID_VALUE);
   if (!bufObj) {
      return;
   }

   if (_mesa_check_disallowed_mapping(bufObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glClearBufferData(buffer currently mapped)");
      return;
   }

   mesaFormat = validate_clear_buffer_format(ctx, internalformat,
                                             format, type,
                                             "glClearBufferData");
   if (mesaFormat == MESA_FORMAT_NONE) {
      return;
   }

   clearValueSize = _mesa_get_format_bytes(mesaFormat);
   if (bufObj->Size % clearValueSize != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glClearBufferData(size is not a multiple of "
                  "internalformat size)");
      return;
   }

   if (data == NULL) {
      /* clear to zeros, per the spec */
      ctx->Driver.ClearBufferSubData(ctx, 0, bufObj->Size,
                                     NULL, clearValueSize, bufObj);
      return;
   }

   if (!convert_clear_buffer_data(ctx, mesaFormat, clearValue,
                                  format, type, data, "glClearBufferData")) {
      return;
   }

   ctx->Driver.ClearBufferSubData(ctx, 0, bufObj->Size,
                                  clearValue, clearValueSize, bufObj);
}


void GLAPIENTRY
_mesa_ClearBufferSubData(GLenum target, GLenum internalformat,
                         GLintptr offset, GLsizeiptr size,
                         GLenum format, GLenum type,
                         const GLvoid* data)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_buffer_object* bufObj;
   mesa_format mesaFormat;
   GLubyte clearValue[MAX_PIXEL_BYTES];
   GLsizeiptr clearValueSize;

   bufObj = buffer_object_subdata_range_good(ctx, target, offset, size,
                                             true, GL_INVALID_VALUE,
                                             "glClearBufferSubData");
   if (!bufObj) {
      return;
   }

   mesaFormat = validate_clear_buffer_format(ctx, internalformat,
                                             format, type,
                                             "glClearBufferSubData");
   if (mesaFormat == MESA_FORMAT_NONE) {
      return;
   }

   clearValueSize = _mesa_get_format_bytes(mesaFormat);
   if (offset % clearValueSize != 0 || size % clearValueSize != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glClearBufferSubData(offset or size is not a multiple of "
                  "internalformat size)");
      return;
   }

   if (data == NULL) {
      /* clear to zeros, per the spec */
      if (size > 0) {
         ctx->Driver.ClearBufferSubData(ctx, offset, size,
                                        NULL, clearValueSize, bufObj);
      }
      return;
   }

   if (!convert_clear_buffer_data(ctx, mesaFormat, clearValue,
                                  format, type, data,
                                  "glClearBufferSubData")) {
      return;
   }

   if (size > 0) {
      ctx->Driver.ClearBufferSubData(ctx, offset, size,
                                     clearValue, clearValueSize, bufObj);
   }
}


d1154 1
a1154 1
   bufObj = get_buffer(ctx, "glMapBufferARB", target, GL_INVALID_OPERATION);
d1158 1
a1158 15
   if (accessFlags & GL_MAP_READ_BIT &&
       !(bufObj->StorageFlags & GL_MAP_READ_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBuffer(invalid read flag)");
      return NULL;
   }

   if (accessFlags & GL_MAP_WRITE_BIT &&
       !(bufObj->StorageFlags & GL_MAP_WRITE_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBuffer(invalid write flag)");
      return NULL;
   }

   if (_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
d1170 1
a1170 2
   map = ctx->Driver.MapBufferRange(ctx, 0, bufObj->Size, accessFlags, bufObj,
                                    MAP_USER);
d1180 4
a1183 4
      ASSERT(bufObj->Mappings[MAP_USER].Pointer == map);
      ASSERT(bufObj->Mappings[MAP_USER].Length == bufObj->Size);
      ASSERT(bufObj->Mappings[MAP_USER].Offset == 0);
      bufObj->Mappings[MAP_USER].AccessFlags = accessFlags;
d1211 1
a1211 1
   return bufObj->Mappings[MAP_USER].Pointer;
d1223 1
a1223 1
   bufObj = get_buffer(ctx, "glUnmapBufferARB", target, GL_INVALID_OPERATION);
d1227 1
a1227 1
   if (!_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
d1268 5
a1272 5
   status = ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_USER);
   bufObj->Mappings[MAP_USER].AccessFlags = 0;
   ASSERT(bufObj->Mappings[MAP_USER].Pointer == NULL);
   ASSERT(bufObj->Mappings[MAP_USER].Offset == 0);
   ASSERT(bufObj->Mappings[MAP_USER].Length == 0);
d1284 1
a1284 2
   bufObj = get_buffer(ctx, "glGetBufferParameterivARB", target,
                       GL_INVALID_OPERATION);
d1296 1
a1296 2
      *params = simplified_access_mode(ctx,
                            bufObj->Mappings[MAP_USER].AccessFlags);
d1299 1
a1299 1
      *params = _mesa_bufferobj_mapped(bufObj, MAP_USER);
d1304 1
a1304 1
      *params = bufObj->Mappings[MAP_USER].AccessFlags;
d1309 1
a1309 1
      *params = (GLint) bufObj->Mappings[MAP_USER].Offset;
d1314 1
a1314 11
      *params = (GLint) bufObj->Mappings[MAP_USER].Length;
      return;
   case GL_BUFFER_IMMUTABLE_STORAGE:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->Immutable;
      return;
   case GL_BUFFER_STORAGE_FLAGS:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->StorageFlags;
d1337 1
a1337 2
   bufObj = get_buffer(ctx, "glGetBufferParameteri64v", target,
                       GL_INVALID_OPERATION);
d1349 1
a1349 2
      *params = simplified_access_mode(ctx,
                             bufObj->Mappings[MAP_USER].AccessFlags);
d1354 1
a1354 1
      *params = bufObj->Mappings[MAP_USER].AccessFlags;
d1357 1
a1357 1
      *params = _mesa_bufferobj_mapped(bufObj, MAP_USER);
d1362 1
a1362 1
      *params = bufObj->Mappings[MAP_USER].Offset;
d1367 1
a1367 11
      *params = bufObj->Mappings[MAP_USER].Length;
      return;
   case GL_BUFFER_IMMUTABLE_STORAGE:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->Immutable;
      return;
   case GL_BUFFER_STORAGE_FLAGS:
      if (!ctx->Extensions.ARB_buffer_storage)
         goto invalid_pname;
      *params = bufObj->StorageFlags;
d1390 1
a1390 2
   bufObj = get_buffer(ctx, "glGetBufferPointervARB", target,
                       GL_INVALID_OPERATION);
d1394 1
a1394 1
   *params = bufObj->Mappings[MAP_USER].Pointer;
d1406 1
a1406 2
   src = get_buffer(ctx, "glCopyBufferSubData", readTarget,
                    GL_INVALID_OPERATION);
d1410 1
a1410 2
   dst = get_buffer(ctx, "glCopyBufferSubData", writeTarget,
                    GL_INVALID_OPERATION);
d1414 1
a1414 1
   if (_mesa_check_disallowed_mapping(src)) {
d1420 1
a1420 1
   if (_mesa_check_disallowed_mapping(dst)) {
a1486 1
   GLbitfield allowed_access;
d1521 7
a1527 14
   allowed_access = GL_MAP_READ_BIT |
                    GL_MAP_WRITE_BIT |
                    GL_MAP_INVALIDATE_RANGE_BIT |
                    GL_MAP_INVALIDATE_BUFFER_BIT |
                    GL_MAP_FLUSH_EXPLICIT_BIT |
                    GL_MAP_UNSYNCHRONIZED_BIT;

   if (ctx->Extensions.ARB_buffer_storage) {
         allowed_access |= GL_MAP_PERSISTENT_BIT |
                           GL_MAP_COHERENT_BIT;
   }

   if (access & ~allowed_access) {
      /* generate an error if any other than allowed bit is set */
d1554 1
a1554 1
   bufObj = get_buffer(ctx, "glMapBufferRange", target, GL_INVALID_OPERATION);
d1558 3
a1560 4
   if (access & GL_MAP_READ_BIT &&
       !(bufObj->StorageFlags & GL_MAP_READ_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid read flag)");
d1564 1
a1564 2
   if (access & GL_MAP_WRITE_BIT &&
       !(bufObj->StorageFlags & GL_MAP_WRITE_BIT)) {
d1566 1
a1566 27
                  "glMapBufferRange(invalid write flag)");
      return NULL;
   }

   if (access & GL_MAP_COHERENT_BIT &&
       !(bufObj->StorageFlags & GL_MAP_COHERENT_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid coherent flag)");
      return NULL;
   }

   if (access & GL_MAP_PERSISTENT_BIT &&
       !(bufObj->StorageFlags & GL_MAP_PERSISTENT_BIT)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(invalid persistent flag)");
      return NULL;
   }

   if (offset + length > bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glMapBufferRange(offset + length > size)");
      return NULL;
   }

   if (_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glMapBufferRange(buffer already mapped)");
d1579 5
a1583 5
      bufObj->Mappings[MAP_USER].Pointer = &dummy;
      bufObj->Mappings[MAP_USER].Length = length;
      bufObj->Mappings[MAP_USER].Offset = offset;
      bufObj->Mappings[MAP_USER].AccessFlags = access;
      return bufObj->Mappings[MAP_USER].Pointer;
d1587 1
a1587 2
   map = ctx->Driver.MapBufferRange(ctx, offset, length, access, bufObj,
                                    MAP_USER);
d1596 4
a1599 4
      ASSERT(bufObj->Mappings[MAP_USER].Pointer == map);
      ASSERT(bufObj->Mappings[MAP_USER].Length == length);
      ASSERT(bufObj->Mappings[MAP_USER].Offset == offset);
      ASSERT(bufObj->Mappings[MAP_USER].AccessFlags == access);
d1633 1
a1633 2
   bufObj = get_buffer(ctx, "glFlushMappedBufferRange", target,
                       GL_INVALID_OPERATION);
d1637 1
a1637 1
   if (!_mesa_bufferobj_mapped(bufObj, MAP_USER)) {
d1644 1
a1644 2
   if ((bufObj->Mappings[MAP_USER].AccessFlags &
        GL_MAP_FLUSH_EXPLICIT_BIT) == 0) {
d1650 1
a1650 1
   if (offset + length > bufObj->Mappings[MAP_USER].Length) {
d1653 1
a1653 2
		  (long)offset, (long)length,
                  (long)bufObj->Mappings[MAP_USER].Length);
d1657 1
a1657 1
   ASSERT(bufObj->Mappings[MAP_USER].AccessFlags & GL_MAP_WRITE_BIT);
d1660 1
a1660 2
      ctx->Driver.FlushMappedBufferRange(ctx, offset, length, bufObj,
                                         MAP_USER);
a2037 6
/**
 * Binds a buffer object to a uniform buffer binding point.
 *
 * The caller is responsible for flushing vertices and updating
 * NewDriverState.
 */
d2040 5
a2044 27
                struct gl_uniform_buffer_binding *binding,
                struct gl_buffer_object *bufObj,
                GLintptr offset,
                GLsizeiptr size,
                GLboolean autoSize)
{
   _mesa_reference_buffer_object(ctx, &binding->BufferObject, bufObj);

   binding->Offset = offset;
   binding->Size = size;
   binding->AutomaticSize = autoSize;
}

/**
 * Binds a buffer object to a uniform buffer binding point.
 *
 * Unlike set_ubo_binding(), this function also flushes vertices
 * and updates NewDriverState.  It also checks if the binding
 * has actually changed before updating it.
 */
static void
bind_uniform_buffer(struct gl_context *ctx,
                    GLuint index,
                    struct gl_buffer_object *bufObj,
                    GLintptr offset,
                    GLsizeiptr size,
                    GLboolean autoSize)
d2046 1
a2046 2
   struct gl_uniform_buffer_binding *binding =
      &ctx->UniformBufferBindings[index];
d2048 1
d2059 4
a2062 1
   set_ubo_binding(ctx, binding, bufObj, offset, size, autoSize);
d2097 1
a2097 1
   bind_uniform_buffer(ctx, index, bufObj, offset, size, GL_FALSE);
a2115 1

d2117 1
a2117 1
      bind_uniform_buffer(ctx, index, bufObj, -1, -1, GL_TRUE);
d2119 1
a2119 767
      bind_uniform_buffer(ctx, index, bufObj, 0, 0, GL_TRUE);
}

/**
 * Binds a buffer object to an atomic buffer binding point.
 *
 * The caller is responsible for validating the offset,
 * flushing the vertices and updating NewDriverState.
 */
static void
set_atomic_buffer_binding(struct gl_context *ctx,
                          struct gl_atomic_buffer_binding *binding,
                          struct gl_buffer_object *bufObj,
                          GLintptr offset,
                          GLsizeiptr size)
{
   _mesa_reference_buffer_object(ctx, &binding->BufferObject, bufObj);

   if (bufObj == ctx->Shared->NullBufferObj) {
      binding->Offset = -1;
      binding->Size = -1;
   } else {
      binding->Offset = offset;
      binding->Size = size;
   }
}

/**
 * Binds a buffer object to an atomic buffer binding point.
 *
 * Unlike set_atomic_buffer_binding(), this function also validates the
 * index and offset, flushes vertices, and updates NewDriverState.
 * It also checks if the binding has actually changing before
 * updating it.
 */
static void
bind_atomic_buffer(struct gl_context *ctx,
                   unsigned index,
                   struct gl_buffer_object *bufObj,
                   GLintptr offset,
                   GLsizeiptr size,
                   const char *name)
{
   struct gl_atomic_buffer_binding *binding;

   if (index >= ctx->Const.MaxAtomicBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%d)", name, index);
      return;
   }

   if (offset & (ATOMIC_COUNTER_SIZE - 1)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(offset misalgned %d/%d)", name, (int) offset,
                  ATOMIC_COUNTER_SIZE);
      return;
   }

   _mesa_reference_buffer_object(ctx, &ctx->AtomicBuffer, bufObj);

   binding = &ctx->AtomicBufferBindings[index];
   if (binding->BufferObject == bufObj &&
       binding->Offset == offset &&
       binding->Size == size) {
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewAtomicBuffer;

   set_atomic_buffer_binding(ctx, binding, bufObj, offset, size);
}

static inline bool
bind_buffers_check_offset_and_size(struct gl_context *ctx,
                                   GLuint index,
                                   const GLintptr *offsets,
                                   const GLsizeiptr *sizes)
{
   if (offsets[index] < 0) {
     /* The ARB_multi_bind spec says:
      *
      *    "An INVALID_VALUE error is generated by BindBuffersRange if any
      *     value in <offsets> is less than zero (per binding)."
      */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBuffersRange(offsets[%u]=%lld < 0)",
                  index, (long long int) offsets[index]);
      return false;
   }

   if (sizes[index] <= 0) {
     /* The ARB_multi_bind spec says:
      *
      *     "An INVALID_VALUE error is generated by BindBuffersRange if any
      *      value in <sizes> is less than or equal to zero (per binding)."
      */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBuffersRange(sizes[%u]=%lld <= 0)",
                  index, (long long int) sizes[index]);
      return false;
   }

   return true;
}

static bool
error_check_bind_uniform_buffers(struct gl_context *ctx,
                                 GLuint first, GLsizei count,
                                 const char *caller)
{
   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(target=GL_UNIFORM_BUFFER)", caller);
      return false;
   }

   /* The ARB_multi_bind_spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count> is
    *      greater than the number of target-specific indexed binding points,
    *      as described in section 6.7.1."
    */
   if (first + count > ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(first=%u + count=%d > the value of "
                  "GL_MAX_UNIFORM_BUFFER_BINDINGS=%u)",
                  caller, first, count,
                  ctx->Const.MaxUniformBufferBindings);
      return false;
   }

   return true;
}

/**
 * Unbind all uniform buffers in the range
 * <first> through <first>+<count>-1
 */
static void
unbind_uniform_buffers(struct gl_context *ctx, GLuint first, GLsizei count)
{
   struct gl_buffer_object *bufObj = ctx->Shared->NullBufferObj;
   GLuint i;

   for (i = 0; i < count; i++)
      set_ubo_binding(ctx, &ctx->UniformBufferBindings[first + i],
                      bufObj, -1, -1, GL_TRUE);
}

static void
bind_uniform_buffers_base(struct gl_context *ctx, GLuint first, GLsizei count,
                          const GLuint *buffers)
{
   GLuint i;

   if (!error_check_bind_uniform_buffers(ctx, first, count, "glBindBuffersBase"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *   "If <buffers> is NULL, all bindings from <first> through
       *    <first>+<count>-1 are reset to their unbound (zero) state."
       */
      unbind_uniform_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_uniform_buffer_binding *binding =
          &ctx->UniformBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersBase");

      if (bufObj) {
         if (bufObj == ctx->Shared->NullBufferObj)
            set_ubo_binding(ctx, binding, bufObj, -1, -1, GL_TRUE);
         else
            set_ubo_binding(ctx, binding, bufObj, 0, 0, GL_TRUE);
      }
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static void
bind_uniform_buffers_range(struct gl_context *ctx, GLuint first, GLsizei count,
                           const GLuint *buffers,
                           const GLintptr *offsets, const GLsizeiptr *sizes)
{
   GLuint i;

   if (!error_check_bind_uniform_buffers(ctx, first, count,
                                         "glBindBuffersRange"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, all bindings from <first> through
       *     <first>+<count>-1 are reset to their unbound (zero) state.
       *     In this case, the offsets and sizes associated with the
       *     binding points are set to default values, ignoring
       *     <offsets> and <sizes>."
       */
      unbind_uniform_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_uniform_buffer_binding *binding =
         &ctx->UniformBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (!bind_buffers_check_offset_and_size(ctx, i, offsets, sizes))
         continue;

      /* The ARB_multi_bind spec says:
       *
       *     "An INVALID_VALUE error is generated by BindBuffersRange if any
       *      pair of values in <offsets> and <sizes> does not respectively
       *      satisfy the constraints described for those parameters for the
       *      specified target, as described in section 6.7.1 (per binding)."
       *
       * Section 6.7.1 refers to table 6.5, which says:
       *
       *     "
       *       Uniform buffer array bindings (see sec. 7.6)                  
       *      
       *        ...                  ...                                    
       *        offset restriction   multiple of value of UNIFORM_BUFFER_-  
       *                             OFFSET_ALIGNMENT                       
       *        ...                  ...                                    
       *        size restriction     none                                   
       *      "
       */
      if (offsets[i] & (ctx->Const.UniformBufferOffsetAlignment - 1)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of the value of "
                     "GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT=%u when "
                     "target=GL_UNIFORM_BUFFER)",
                     i, (long long int) offsets[i],
                     ctx->Const.UniformBufferOffsetAlignment);
         continue;
      }

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersRange");

      if (bufObj) {
         if (bufObj == ctx->Shared->NullBufferObj)
            set_ubo_binding(ctx, binding, bufObj, -1, -1, GL_FALSE);
         else
            set_ubo_binding(ctx, binding, bufObj,
                            offsets[i], sizes[i], GL_FALSE);
      }
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static bool
error_check_bind_xfb_buffers(struct gl_context *ctx,
                             struct gl_transform_feedback_object *tfObj,
                             GLuint first, GLsizei count, const char *caller)
{
   if (!ctx->Extensions.EXT_transform_feedback) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(target=GL_TRANSFORM_FEEDBACK_BUFFER)", caller);
      return false;
   }

   /* Page 398 of the PDF of the OpenGL 4.4 (Core Profile) spec says:
    *
    *     "An INVALID_OPERATION error is generated :
    *
    *     ...
    *      by BindBufferRange or BindBufferBase if target is TRANSFORM_-
    *       FEEDBACK_BUFFER and transform feedback is currently active."
    *
    * We assume that this is also meant to apply to BindBuffersRange
    * and BindBuffersBase.
    */
   if (tfObj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(Changing transform feedback buffers while "
                  "transform feedback is active)", caller);
      return false;
   }

   /* The ARB_multi_bind_spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count> is
    *      greater than the number of target-specific indexed binding points,
    *      as described in section 6.7.1."
    */
   if (first + count > ctx->Const.MaxTransformFeedbackBuffers) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(first=%u + count=%d > the value of "
                  "GL_MAX_TRANSFORM_FEEDBACK_BUFFERS=%u)",
                  caller, first, count,
                  ctx->Const.MaxTransformFeedbackBuffers);
      return false;
   }

   return true;
}

/**
 * Unbind all transform feedback buffers in the range
 * <first> through <first>+<count>-1
 */
static void
unbind_xfb_buffers(struct gl_context *ctx,
                   struct gl_transform_feedback_object *tfObj,
                   GLuint first, GLsizei count)
{
   struct gl_buffer_object * const bufObj = ctx->Shared->NullBufferObj;
   GLuint i;

   for (i = 0; i < count; i++)
      _mesa_set_transform_feedback_binding(ctx, tfObj, first + i,
                                           bufObj, 0, 0);
}

static void
bind_xfb_buffers_base(struct gl_context *ctx,
                      GLuint first, GLsizei count,
                      const GLuint *buffers)
{
   struct gl_transform_feedback_object *tfObj =
      ctx->TransformFeedback.CurrentObject;
   GLuint i;

   if (!error_check_bind_xfb_buffers(ctx, tfObj, first, count,
                                     "glBindBuffersBase"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *   "If <buffers> is NULL, all bindings from <first> through
       *    <first>+<count>-1 are reset to their unbound (zero) state."
       */
      unbind_xfb_buffers(ctx, tfObj, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_buffer_object * const boundBufObj = tfObj->Buffers[first + i];
      struct gl_buffer_object *bufObj;

      if (boundBufObj && boundBufObj->Name == buffers[i])
         bufObj = boundBufObj;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersBase");

      if (bufObj)
         _mesa_set_transform_feedback_binding(ctx, tfObj, first + i,
                                              bufObj, 0, 0);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static void
bind_xfb_buffers_range(struct gl_context *ctx,
                       GLuint first, GLsizei count,
                       const GLuint *buffers,
                       const GLintptr *offsets,
                       const GLsizeiptr *sizes)
{
   struct gl_transform_feedback_object *tfObj =
       ctx->TransformFeedback.CurrentObject;
   GLuint i;

   if (!error_check_bind_xfb_buffers(ctx, tfObj, first, count,
                                     "glBindBuffersRange"))
      return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, all bindings from <first> through
       *     <first>+<count>-1 are reset to their unbound (zero) state.
       *     In this case, the offsets and sizes associated with the
       *     binding points are set to default values, ignoring
       *     <offsets> and <sizes>."
       */
      unbind_xfb_buffers(ctx, tfObj, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      const GLuint index = first + i;
      struct gl_buffer_object * const boundBufObj = tfObj->Buffers[index];
      struct gl_buffer_object *bufObj;

      if (!bind_buffers_check_offset_and_size(ctx, i, offsets, sizes))
         continue;

      /* The ARB_multi_bind spec says:
       *
       *     "An INVALID_VALUE error is generated by BindBuffersRange if any
       *      pair of values in <offsets> and <sizes> does not respectively
       *      satisfy the constraints described for those parameters for the
       *      specified target, as described in section 6.7.1 (per binding)."
       *
       * Section 6.7.1 refers to table 6.5, which says:
       *
       *     "
       *       Transform feedback array bindings (see sec. 13.2.2)           
       *      
       *          ...                    ...                                
       *          offset restriction     multiple of 4                      
       *          ...                    ...                                
       *          size restriction       multiple of 4                      
       *      "
       */
      if (offsets[i] & 0x3) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
                     "target=GL_TRANSFORM_FEEDBACK_BUFFER)",
                     i, (long long int) offsets[i]);
         continue;
      }

      if (sizes[i] & 0x3) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(sizes[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
                     "target=GL_TRANSFORM_FEEDBACK_BUFFER)",
                     i, (long long int) sizes[i]);
         continue;
      }

      if (boundBufObj && boundBufObj->Name == buffers[i])
         bufObj = boundBufObj;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersRange");

      if (bufObj)
         _mesa_set_transform_feedback_binding(ctx, tfObj, index, bufObj,
                                              offsets[i], sizes[i]);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static bool
error_check_bind_atomic_buffers(struct gl_context *ctx,
                                GLuint first, GLsizei count,
                                const char *caller)
{
   if (!ctx->Extensions.ARB_shader_atomic_counters) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(target=GL_ATOMIC_COUNTER_BUFFER)", caller);
      return false;
   }

   /* The ARB_multi_bind_spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count> is
    *      greater than the number of target-specific indexed binding points,
    *      as described in section 6.7.1."
    */
   if (first + count > ctx->Const.MaxAtomicBufferBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(first=%u + count=%d > the value of "
                  "GL_MAX_ATOMIC_BUFFER_BINDINGS=%u)",
                  caller, first, count, ctx->Const.MaxAtomicBufferBindings);
      return false;
   }

   return true;
}

/**
 * Unbind all atomic counter buffers in the range
 * <first> through <first>+<count>-1
 */
static void
unbind_atomic_buffers(struct gl_context *ctx, GLuint first, GLsizei count)
{
   struct gl_buffer_object * const bufObj = ctx->Shared->NullBufferObj;
   GLuint i;

   for (i = 0; i < count; i++)
      set_atomic_buffer_binding(ctx, &ctx->AtomicBufferBindings[first + i],
                                bufObj, -1, -1);
}

static void
bind_atomic_buffers_base(struct gl_context *ctx,
                         GLuint first,
                         GLsizei count,
                         const GLuint *buffers)
{
   GLuint i;

   if (!error_check_bind_atomic_buffers(ctx, first, count,
                                        "glBindBuffersBase"))
     return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewAtomicBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *   "If <buffers> is NULL, all bindings from <first> through
       *    <first>+<count>-1 are reset to their unbound (zero) state."
       */
      unbind_atomic_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_atomic_buffer_binding *binding =
         &ctx->AtomicBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersBase");

      if (bufObj)
         set_atomic_buffer_binding(ctx, binding, bufObj, 0, 0);
   }

   _mesa_end_bufferobj_lookups(ctx);
}

static void
bind_atomic_buffers_range(struct gl_context *ctx,
                          GLuint first,
                          GLsizei count,
                          const GLuint *buffers,
                          const GLintptr *offsets,
                          const GLsizeiptr *sizes)
{
   GLuint i;

   if (!error_check_bind_atomic_buffers(ctx, first, count,
                                        "glBindBuffersRange"))
     return;

   /* Assume that at least one binding will be changed */
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewAtomicBuffer;

   if (!buffers) {
      /* The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, all bindings from <first> through
       *     <first>+<count>-1 are reset to their unbound (zero) state.
       *     In this case, the offsets and sizes associated with the
       *     binding points are set to default values, ignoring
       *     <offsets> and <sizes>."
       */
      unbind_atomic_buffers(ctx, first, count);
      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by a
    *          command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require a
    *          first pass to scan the entire list of bound objects for errors
    *          and then a second pass to actually perform the bindings.
    *          Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding point
    *       is not updated and an error will be generated.  However, other
    *       binding points in the same command will be updated if their
    *       parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_atomic_buffer_binding *binding =
         &ctx->AtomicBufferBindings[first + i];
      struct gl_buffer_object *bufObj;

      if (!bind_buffers_check_offset_and_size(ctx, i, offsets, sizes))
         continue;

      /* The ARB_multi_bind spec says:
       *
       *     "An INVALID_VALUE error is generated by BindBuffersRange if any
       *      pair of values in <offsets> and <sizes> does not respectively
       *      satisfy the constraints described for those parameters for the
       *      specified target, as described in section 6.7.1 (per binding)."
       *
       * Section 6.7.1 refers to table 6.5, which says:
       *
       *     "
       *       Atomic counter array bindings (see sec. 7.7.2)                
       *      
       *          ...                    ...                                
       *          offset restriction     multiple of 4                      
       *          ...                    ...                                
       *          size restriction       none                               
       *      "
       */
      if (offsets[i] & (ATOMIC_COUNTER_SIZE - 1)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of %d when "
                     "target=GL_ATOMIC_COUNTER_BUFFER)",
                     i, (long long int) offsets[i], ATOMIC_COUNTER_SIZE);
         continue;
      }

      if (binding->BufferObject && binding->BufferObject->Name == buffers[i])
         bufObj = binding->BufferObject;
      else
         bufObj = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindBuffersRange");

      if (bufObj)
         set_atomic_buffer_binding(ctx, binding, bufObj, offsets[i], sizes[i]);
   }

   _mesa_end_bufferobj_lookups(ctx);
d2134 1
a2134 2
   if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
                                     &bufObj, "glBindBufferRange"))
a2158 4
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffer(ctx, index, bufObj, offset, size,
                         "glBindBufferRange");
      return;
d2176 1
a2176 2
   if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
                                     &bufObj, "glBindBufferBase"))
a2217 4
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffer(ctx, index, bufObj, 0, 0,
                         "glBindBufferBase");
      return;
a2224 48
_mesa_BindBuffersRange(GLenum target, GLuint first, GLsizei count,
                       const GLuint *buffers,
                       const GLintptr *offsets, const GLsizeiptr *sizes)
{
   GET_CURRENT_CONTEXT(ctx);

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      bind_xfb_buffers_range(ctx, first, count, buffers, offsets, sizes);
      return;
   case GL_UNIFORM_BUFFER:
      bind_uniform_buffers_range(ctx, first, count, buffers, offsets, sizes);
      return;
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffers_range(ctx, first, count, buffers,
                                offsets, sizes);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBuffersRange(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
      break;
   }
}

void GLAPIENTRY
_mesa_BindBuffersBase(GLenum target, GLuint first, GLsizei count,
                      const GLuint *buffers)
{
   GET_CURRENT_CONTEXT(ctx);

   switch (target) {
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      bind_xfb_buffers_base(ctx, first, count, buffers);
      return;
   case GL_UNIFORM_BUFFER:
      bind_uniform_buffers_base(ctx, first, count, buffers);
      return;
   case GL_ATOMIC_COUNTER_BUFFER:
      bind_atomic_buffers_base(ctx, first, count, buffers);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBuffersBase(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
      break;
   }
}

void GLAPIENTRY
d2252 1
a2252 1
   /* The OpenGL 4.4 (Core Profile) spec says:
d2254 21
a2274 11
    *     "An INVALID_OPERATION error is generated if buffer is currently
    *     mapped by MapBuffer or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange, unless it was mapped
    *     with MAP_PERSISTENT_BIT set in the MapBufferRange access flags."
    */
   if (!(bufObj->Mappings[MAP_USER].AccessFlags & GL_MAP_PERSISTENT_BIT) &&
       bufferobj_range_mapped(bufObj, offset, length)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glInvalidateBufferSubData(intersection with mapped "
                  "range)");
      return;
d2297 1
a2297 1
   /* The OpenGL 4.4 (Core Profile) spec says:
d2299 3
a2301 4
    *     "An INVALID_OPERATION error is generated if buffer is currently
    *     mapped by MapBuffer or if the invalidate range intersects the range
    *     currently mapped by MapBufferRange, unless it was mapped
    *     with MAP_PERSISTENT_BIT set in the MapBufferRange access flags."
d2303 1
a2303 1
   if (_mesa_check_disallowed_mapping(bufObj)) {
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a33 1
#include <inttypes.h>  /* for PRId64 macro */
d391 1
a391 1
_mesa_new_buffer_object(struct gl_context *ctx, GLuint name)
d398 1
a398 1
   _mesa_initialize_buffer_object(ctx, obj, name);
d496 3
a498 3
_mesa_initialize_buffer_object(struct gl_context *ctx,
                               struct gl_buffer_object *obj,
                               GLuint name)
d500 2
a834 3
   _mesa_reference_buffer_object(ctx, &ctx->AtomicBuffer,
				 ctx->Shared->NullBufferObj);

a844 8

   for (i = 0; i < MAX_COMBINED_ATOMIC_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->AtomicBufferBindings[i].BufferObject,
				    ctx->Shared->NullBufferObj);
      ctx->AtomicBufferBindings[i].Offset = -1;
      ctx->AtomicBufferBindings[i].Size = -1;
   }
a859 2
   _mesa_reference_buffer_object(ctx, &ctx->AtomicBuffer, NULL);

a866 7

   for (i = 0; i < MAX_COMBINED_ATOMIC_BUFFERS; i++) {
      _mesa_reference_buffer_object(ctx,
				    &ctx->AtomicBufferBindings[i].BufferObject,
				    NULL);
   }

d888 1
a888 1
      buf = ctx->Driver.NewBufferObject(ctx, buffer);
a1202 11
         /* unbind Atomci Buffer binding points */
         for (j = 0; j < ctx->Const.MaxAtomicBufferBindings; j++) {
            if (ctx->AtomicBufferBindings[j].BufferObject == bufObj) {
               _mesa_BindBufferBase( GL_ATOMIC_COUNTER_BUFFER, j, 0 );
            }
         }

         if (ctx->UniformBuffer == bufObj) {
            _mesa_BindBuffer( GL_ATOMIC_COUNTER_BUFFER, 0 );
         }

a2622 6

   /* If this is a real buffer object, mark it has having been used
    * at some point as a UBO.
    */
   if (size >= 0)
      bufObj->UsageHistory |= USAGE_UNIFORM_BUFFER;
d2677 1
a2677 1
                  "glBindBufferRange(offset misaligned %d/%d)", (int) offset,
a2734 1
      bufObj->UsageHistory |= USAGE_ATOMIC_COUNTER_BUFFER;
d2763 1
a2763 1
                  "%s(offset misaligned %d/%d)", name, (int) offset,
d2796 2
a2797 2
                  "glBindBuffersRange(offsets[%u]=%" PRId64 " < 0)",
                  index, (int64_t) offsets[index]);
d2808 2
a2809 2
                  "glBindBuffersRange(sizes[%u]=%" PRId64 " <= 0)",
                  index, (int64_t) sizes[index]);
d3004 2
a3005 2
                     "glBindBuffersRange(offsets[%u]=%" PRId64
                     " is misaligned; it must be a multiple of the value of "
d3008 1
a3008 1
                     i, (int64_t) offsets[i],
d3242 2
a3243 2
                     "glBindBuffersRange(offsets[%u]=%" PRId64
                     " is misaligned; it must be a multiple of 4 when "
d3245 1
a3245 1
                     i, (int64_t) offsets[i]);
d3251 2
a3252 2
                     "glBindBuffersRange(sizes[%u]=%" PRId64
                     " is misaligned; it must be a multiple of 4 when "
d3254 1
a3254 1
                     i, (int64_t) sizes[i]);
d3460 2
a3461 2
                     "glBindBuffersRange(offsets[%u]=%" PRId64
                     " is misaligned; it must be a multiple of %d when "
d3463 1
a3463 1
                     i, (int64_t) offsets[i], ATOMIC_COUNTER_SIZE);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d34 1
d392 1
a392 1
_mesa_new_buffer_object( struct gl_context *ctx, GLuint name, GLenum target )
d399 1
a399 1
   _mesa_initialize_buffer_object(ctx, obj, name, target);
d497 3
a499 3
_mesa_initialize_buffer_object( struct gl_context *ctx,
				struct gl_buffer_object *obj,
				GLuint name, GLenum target )
a500 2
   (void) target;

d834 3
d847 8
d870 2
d879 7
d907 1
a907 1
      buf = ctx->Driver.NewBufferObject(ctx, buffer, target);
d1222 11
d2653 6
d2713 1
a2713 1
                  "glBindBufferRange(offset misalgned %d/%d)", (int) offset,
d2771 1
d2800 1
a2800 1
                  "%s(offset misalgned %d/%d)", name, (int) offset,
d2833 2
a2834 2
                  "glBindBuffersRange(offsets[%u]=%lld < 0)",
                  index, (long long int) offsets[index]);
d2845 2
a2846 2
                  "glBindBuffersRange(sizes[%u]=%lld <= 0)",
                  index, (long long int) sizes[index]);
d3041 2
a3042 2
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of the value of "
d3045 1
a3045 1
                     i, (long long int) offsets[i],
d3279 2
a3280 2
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
d3282 1
a3282 1
                     i, (long long int) offsets[i]);
d3288 2
a3289 2
                     "glBindBuffersRange(sizes[%u]=%lld is misaligned; "
                     "it must be a multiple of 4 when "
d3291 1
a3291 1
                     i, (long long int) sizes[i]);
d3497 2
a3498 2
                     "glBindBuffersRange(offsets[%u]=%lld is misaligned; "
                     "it must be a multiple of %d when "
d3500 1
a3500 1
                     i, (long long int) offsets[i], ATOMIC_COUNTER_SIZE);
@


