head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.1.1.0.2
	OPENBSD_5_0_BASE:1.1.1.1
	shadchin_2011/home/xenocara/driver/xf86-input-synaptics04:1.1.1.1
	shadchin:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2017.01.22.09.54.53;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	CjjEXS1IfivpYe4R;

1.8
date	2014.05.17.17.18.21;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2014.05.09.20.05.46;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.02.18.17.24;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.30.13.31.04;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.12.18.59.42;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.01.12.18.45;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.23.16.53.49;	author shadchin;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-input-synaptics 1.9.0
@
text
@/*
 * Copyright © 2008-2012 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Red Hat
 * not be used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.  Red
 * Hat makes no representations about the suitability of this software
 * for any purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors: Peter Hutterer
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include "xf86Module.h"

#include <X11/Xatom.h>
#include <xf86.h>
#include <xf86Xinput.h>
#include <exevents.h>

#include "synapticsstr.h"
#include "synaptics-properties.h"

#ifndef XATOM_FLOAT
#define XATOM_FLOAT "FLOAT"
#endif

#ifndef XI_PROP_PRODUCT_ID
#define XI_PROP_PRODUCT_ID "Device Product ID"
#endif

#ifndef XI_PROP_DEVICE_NODE
#define XI_PROP_DEVICE_NODE "Device Node"
#endif

static Atom float_type;

Atom prop_edges = 0;
Atom prop_finger = 0;
Atom prop_tap_time = 0;
Atom prop_tap_move = 0;
Atom prop_tap_durations = 0;
Atom prop_clickpad = 0;
Atom prop_middle_timeout = 0;
Atom prop_twofinger_pressure = 0;
Atom prop_twofinger_width = 0;
Atom prop_scrolldist = 0;
Atom prop_scrolledge = 0;
Atom prop_scrolltwofinger = 0;
Atom prop_speed = 0;
Atom prop_edgemotion_pressure = 0;
Atom prop_edgemotion_speed = 0;
Atom prop_edgemotion_always = 0;
Atom prop_buttonscroll = 0;
Atom prop_buttonscroll_repeat = 0;
Atom prop_buttonscroll_time = 0;
Atom prop_off = 0;
Atom prop_lockdrags = 0;
Atom prop_lockdrags_time = 0;
Atom prop_tapaction = 0;
Atom prop_clickaction = 0;
Atom prop_circscroll = 0;
Atom prop_circscroll_dist = 0;
Atom prop_circscroll_trigger = 0;
Atom prop_circpad = 0;
Atom prop_palm = 0;
Atom prop_palm_dim = 0;
Atom prop_coastspeed = 0;
Atom prop_pressuremotion = 0;
Atom prop_pressuremotion_factor = 0;
Atom prop_grab = 0;
Atom prop_gestures = 0;
Atom prop_capabilities = 0;
Atom prop_resolution = 0;
Atom prop_area = 0;
Atom prop_softbutton_areas = 0;
Atom prop_secondary_softbutton_areas = 0;
Atom prop_noise_cancellation = 0;
Atom prop_product_id = 0;
Atom prop_device_node = 0;

static Atom
InitTypedAtom(DeviceIntPtr dev, char *name, Atom type, int format, int nvalues,
              int *values)
{
    int i;
    Atom atom;
    uint8_t val_8[9];           /* we never have more than 9 values in an atom */
    uint16_t val_16[9];
    uint32_t val_32[9];
    pointer converted;

    for (i = 0; i < nvalues; i++) {
        switch (format) {
        case 8:
            val_8[i] = values[i];
            break;
        case 16:
            val_16[i] = values[i];
            break;
        case 32:
            val_32[i] = values[i];
            break;
        }
    }

    switch (format) {
    case 8:
        converted = val_8;
        break;
    case 16:
        converted = val_16;
        break;
    case 32:
    default:
        converted = val_32;
        break;
    }

    atom = MakeAtom(name, strlen(name), TRUE);
    XIChangeDeviceProperty(dev, atom, type, format, PropModeReplace, nvalues,
                           converted, FALSE);
    XISetDevicePropertyDeletable(dev, atom, FALSE);
    return atom;
}

static Atom
InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
{
    return InitTypedAtom(dev, name, XA_INTEGER, format, nvalues, values);
}

static Atom
InitFloatAtom(DeviceIntPtr dev, char *name, int nvalues, float *values)
{
    Atom atom;

    atom = MakeAtom(name, strlen(name), TRUE);
    XIChangeDeviceProperty(dev, atom, float_type, 32, PropModeReplace,
                           nvalues, values, FALSE);
    XISetDevicePropertyDeletable(dev, atom, FALSE);
    return atom;
}

static void
InitSoftButtonProperty(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    SynapticsParameters *para = &priv->synpara;
    int values[8];

    values[0] = para->softbutton_areas[BOTTOM_RIGHT_BUTTON_AREA][LEFT];
    values[1] = para->softbutton_areas[BOTTOM_RIGHT_BUTTON_AREA][RIGHT];
    values[2] = para->softbutton_areas[BOTTOM_RIGHT_BUTTON_AREA][TOP];
    values[3] = para->softbutton_areas[BOTTOM_RIGHT_BUTTON_AREA][BOTTOM];
    values[4] = para->softbutton_areas[BOTTOM_MIDDLE_BUTTON_AREA][LEFT];
    values[5] = para->softbutton_areas[BOTTOM_MIDDLE_BUTTON_AREA][RIGHT];
    values[6] = para->softbutton_areas[BOTTOM_MIDDLE_BUTTON_AREA][TOP];
    values[7] = para->softbutton_areas[BOTTOM_MIDDLE_BUTTON_AREA][BOTTOM];
    prop_softbutton_areas =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_SOFTBUTTON_AREAS, 32, 8, values);

    if (!para->has_secondary_buttons)
        return;

    values[0] = para->softbutton_areas[TOP_RIGHT_BUTTON_AREA][LEFT];
    values[1] = para->softbutton_areas[TOP_RIGHT_BUTTON_AREA][RIGHT];
    values[2] = para->softbutton_areas[TOP_RIGHT_BUTTON_AREA][TOP];
    values[3] = para->softbutton_areas[TOP_RIGHT_BUTTON_AREA][BOTTOM];
    values[4] = para->softbutton_areas[TOP_MIDDLE_BUTTON_AREA][LEFT];
    values[5] = para->softbutton_areas[TOP_MIDDLE_BUTTON_AREA][RIGHT];
    values[6] = para->softbutton_areas[TOP_MIDDLE_BUTTON_AREA][TOP];
    values[7] = para->softbutton_areas[TOP_MIDDLE_BUTTON_AREA][BOTTOM];

    if (values[0] || values[1] || values[2] || values[4] ||
        values[5] || values[6] || values[7])
        prop_secondary_softbutton_areas =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_SECONDARY_SOFTBUTTON_AREAS, 32, 8, values);
}

void
InitDeviceProperties(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    SynapticsParameters *para = &priv->synpara;
    int values[9];              /* we never have more than 9 values in an atom */
    float fvalues[4];           /* never have more than 4 float values */

    float_type = XIGetKnownProperty(XATOM_FLOAT);
    if (!float_type) {
        float_type = MakeAtom(XATOM_FLOAT, strlen(XATOM_FLOAT), TRUE);
        if (!float_type) {
            xf86IDrvMsg(pInfo, X_ERROR, "Failed to init float atom. "
                        "Disabling property support.\n");
            return;
        }
    }

    values[0] = para->left_edge;
    values[1] = para->right_edge;
    values[2] = para->top_edge;
    values[3] = para->bottom_edge;

    prop_edges = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGES, 32, 4, values);

    values[0] = para->finger_low;
    values[1] = para->finger_high;
    values[2] = 0;

    prop_finger = InitAtom(pInfo->dev, SYNAPTICS_PROP_FINGER, 32, 3, values);
    prop_tap_time =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_TIME, 32, 1, &para->tap_time);
    prop_tap_move =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_MOVE, 32, 1, &para->tap_move);

    values[0] = para->single_tap_timeout;
    values[1] = para->tap_time_2;
    values[2] = para->click_time;

    prop_tap_durations =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_DURATIONS, 32, 3, values);
    prop_clickpad =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICKPAD, 8, 1, &para->clickpad);
    prop_middle_timeout =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_MIDDLE_TIMEOUT, 32, 1,
                 &para->emulate_mid_button_time);
    prop_twofinger_pressure =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_PRESSURE, 32, 1,
                 &para->emulate_twofinger_z);
    prop_twofinger_width =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_WIDTH, 32, 1,
                 &para->emulate_twofinger_w);

    values[0] = para->scroll_dist_vert;
    values[1] = para->scroll_dist_horiz;
    prop_scrolldist =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_DISTANCE, 32, 2, values);

    values[0] = para->scroll_edge_vert;
    values[1] = para->scroll_edge_horiz;
    values[2] = para->scroll_edge_corner;
    prop_scrolledge =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_EDGE, 8, 3, values);
    values[0] = para->scroll_twofinger_vert;
    values[1] = para->scroll_twofinger_horiz;
    prop_scrolltwofinger =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_TWOFINGER, 8, 2, values);

    fvalues[0] = para->min_speed;
    fvalues[1] = para->max_speed;
    fvalues[2] = para->accl;
    fvalues[3] = 0;
    prop_speed = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_SPEED, 4, fvalues);

    if (priv->has_scrollbuttons) {
        values[0] = para->updown_button_scrolling;
        values[1] = para->leftright_button_scrolling;
        prop_buttonscroll =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING, 8, 2, values);

        values[0] = para->updown_button_repeat;
        values[1] = para->leftright_button_repeat;
        prop_buttonscroll_repeat =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT, 8, 2,
                     values);
        prop_buttonscroll_time =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_TIME, 32, 1,
                     &para->scroll_button_repeat);
    }

    prop_off =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_OFF, 8, 1, &para->touchpad_off);
    prop_lockdrags =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS, 8, 1,
                 &para->locked_drags);
    prop_lockdrags_time =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS_TIMEOUT, 32, 1,
                 &para->locked_drag_time);

    memcpy(values, para->tap_action, MAX_TAP * sizeof(int));
    prop_tapaction =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_ACTION, 8, MAX_TAP, values);

    memcpy(values, para->click_action, MAX_CLICK * sizeof(int));
    prop_clickaction =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICK_ACTION, 8, MAX_CLICK, values);

    prop_circscroll =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING, 8, 1,
                 &para->circular_scrolling);

    fvalues[0] = para->scroll_dist_circ;
    prop_circscroll_dist =
        InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_DIST, 1,
                      fvalues);

    prop_circscroll_trigger =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_TRIGGER, 8, 1,
                 &para->circular_trigger);
    prop_circpad =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_PAD, 8, 1,
                 &para->circular_pad);
    prop_palm =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DETECT, 8, 1,
                 &para->palm_detect);

    values[0] = para->palm_min_width;
    values[1] = para->palm_min_z;

    prop_palm_dim =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DIMENSIONS, 32, 2, values);

    fvalues[0] = para->coasting_speed;
    fvalues[1] = para->coasting_friction;
    prop_coastspeed =
        InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_COASTING_SPEED, 2, fvalues);

    values[0] = para->press_motion_min_z;
    values[1] = para->press_motion_max_z;
    prop_pressuremotion =
        InitTypedAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION, XA_CARDINAL,
                      32, 2, values);

    fvalues[0] = para->press_motion_min_factor;
    fvalues[1] = para->press_motion_max_factor;

    prop_pressuremotion_factor =
        InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR, 2,
                      fvalues);

    prop_grab =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_GRAB, 8, 1,
                 &para->grab_event_device);

    values[0] = para->tap_and_drag_gesture;
    prop_gestures = InitAtom(pInfo->dev, SYNAPTICS_PROP_GESTURES, 8, 1, values);

    values[0] = priv->has_left;
    values[1] = priv->has_middle;
    values[2] = priv->has_right;
    values[3] = priv->has_double;
    values[4] = priv->has_triple;
    values[5] = priv->has_pressure;
    values[6] = priv->has_width;
    prop_capabilities =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CAPABILITIES, 8, 7, values);

    values[0] = para->resolution_vert;
    values[1] = para->resolution_horiz;
    prop_resolution =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_RESOLUTION, 32, 2, values);

    values[0] = para->area_left_edge;
    values[1] = para->area_right_edge;
    values[2] = para->area_top_edge;
    values[3] = para->area_bottom_edge;
    prop_area = InitAtom(pInfo->dev, SYNAPTICS_PROP_AREA, 32, 4, values);

    if (para->clickpad)
        InitSoftButtonProperty(pInfo);

    values[0] = para->hyst_x;
    values[1] = para->hyst_y;
    prop_noise_cancellation = InitAtom(pInfo->dev,
                                       SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2,
                                       values);

    /* only init product_id property if we actually know them */
    if (priv->id_vendor || priv->id_product) {
        values[0] = priv->id_vendor;
        values[1] = priv->id_product;
        prop_product_id =
            InitAtom(pInfo->dev, XI_PROP_PRODUCT_ID, 32, 2, values);
    }

    if (priv->device) {
        prop_device_node =
            MakeAtom(XI_PROP_DEVICE_NODE, strlen(XI_PROP_DEVICE_NODE), TRUE);
        XIChangeDeviceProperty(pInfo->dev, prop_device_node, XA_STRING, 8,
                               PropModeReplace, strlen(priv->device),
                               (pointer) priv->device, FALSE);
        XISetDevicePropertyDeletable(pInfo->dev, prop_device_node, FALSE);
    }

}

int
SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
            BOOL checkonly)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    SynapticsParameters *para = &priv->synpara;
    SynapticsParameters tmp;

    /* If checkonly is set, no parameters may be changed. So just let the code
     * change temporary variables and forget about it. */
    if (checkonly) {
        tmp = *para;
        para = &tmp;
    }

    if (property == prop_edges) {
        INT32 *edges;

        if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        edges = (INT32 *) prop->data;
        if (edges[0] > edges[1] || edges[2] > edges[3])
            return BadValue;

        para->left_edge = edges[0];
        para->right_edge = edges[1];
        para->top_edge = edges[2];
        para->bottom_edge = edges[3];

    }
    else if (property == prop_finger) {
        INT32 *finger;

        if (prop->size != 3 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        finger = (INT32 *) prop->data;
        if (finger[0] > finger[1])
            return BadValue;

        para->finger_low = finger[0];
        para->finger_high = finger[1];
    }
    else if (property == prop_tap_time) {
        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->tap_time = *(INT32 *) prop->data;

    }
    else if (property == prop_tap_move) {
        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->tap_move = *(INT32 *) prop->data;
    }
    else if (property == prop_tap_durations) {
        INT32 *timeouts;

        if (prop->size != 3 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        timeouts = (INT32 *) prop->data;

        para->single_tap_timeout = timeouts[0];
        para->tap_time_2 = timeouts[1];
        para->click_time = timeouts[2];
    }
    else if (property == prop_clickpad) {
        BOOL value;

        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        value = *(BOOL *) prop->data;
        if (!para->clickpad && value && !prop_softbutton_areas)
            InitSoftButtonProperty(pInfo);
        else if (para->clickpad && !value && prop_softbutton_areas) {
            XIDeleteDeviceProperty(dev, prop_softbutton_areas, FALSE);
            prop_softbutton_areas = 0;
        }

        para->clickpad = *(BOOL *) prop->data;
    }
    else if (property == prop_middle_timeout) {
        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->emulate_mid_button_time = *(INT32 *) prop->data;
    }
    else if (property == prop_twofinger_pressure) {
        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->emulate_twofinger_z = *(INT32 *) prop->data;
    }
    else if (property == prop_twofinger_width) {
        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->emulate_twofinger_w = *(INT32 *) prop->data;
    }
    else if (property == prop_scrolldist) {
        INT32 *dist;

        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        dist = (INT32 *) prop->data;
        if (dist[0] == 0 || dist[1] == 0)
            return BadValue;

        if (para->scroll_dist_vert != dist[0]) {
            para->scroll_dist_vert = dist[0];
            SetScrollValuator(dev, priv->scroll_axis_vert, SCROLL_TYPE_VERTICAL,
                              para->scroll_dist_vert, 0);
        }
        if (para->scroll_dist_horiz != dist[1]) {
            para->scroll_dist_horiz = dist[1];
            SetScrollValuator(dev, priv->scroll_axis_horiz,
                              SCROLL_TYPE_HORIZONTAL, para->scroll_dist_horiz,
                              0);
        }
    }
    else if (property == prop_scrolledge) {
        CARD8 *edge;

        if (prop->size != 3 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        edge = (BOOL *) prop->data;
        para->scroll_edge_vert = edge[0];
        para->scroll_edge_horiz = edge[1];
        para->scroll_edge_corner = edge[2];
    }
    else if (property == prop_scrolltwofinger) {
        CARD8 *twofinger;

        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        twofinger = (BOOL *) prop->data;
        para->scroll_twofinger_vert = twofinger[0];
        para->scroll_twofinger_horiz = twofinger[1];
    }
    else if (property == prop_speed) {
        float *speed;

        if (prop->size != 4 || prop->format != 32 || prop->type != float_type)
            return BadMatch;

        speed = (float *) prop->data;
        para->min_speed = speed[0];
        para->max_speed = speed[1];
        para->accl = speed[2];
    }
    else if (property == prop_buttonscroll) {
        BOOL *scroll;

        if (!priv->has_scrollbuttons)
            return BadMatch;

        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        scroll = (BOOL *) prop->data;
        para->updown_button_scrolling = scroll[0];
        para->leftright_button_scrolling = scroll[1];

    }
    else if (property == prop_buttonscroll_repeat) {
        BOOL *repeat;

        if (!priv->has_scrollbuttons)
            return BadMatch;

        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        repeat = (BOOL *) prop->data;
        para->updown_button_repeat = repeat[0];
        para->leftright_button_repeat = repeat[1];
    }
    else if (property == prop_buttonscroll_time) {
        if (!priv->has_scrollbuttons)
            return BadMatch;

        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->scroll_button_repeat = *(INT32 *) prop->data;

    }
    else if (property == prop_off) {
        CARD8 off;

        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        off = *(CARD8 *) prop->data;

        if (off > 2)
            return BadValue;

        para->touchpad_off = off;
    }
    else if (property == prop_gestures) {
        BOOL *gestures;

        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        gestures = (BOOL *) prop->data;
        para->tap_and_drag_gesture = gestures[0];
    }
    else if (property == prop_lockdrags) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->locked_drags = *(BOOL *) prop->data;
    }
    else if (property == prop_lockdrags_time) {
        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->locked_drag_time = *(INT32 *) prop->data;
    }
    else if (property == prop_tapaction) {
        int i;
        CARD8 *action;

        if (prop->size > MAX_TAP || prop->format != 8 ||
            prop->type != XA_INTEGER)
            return BadMatch;

        action = (CARD8 *) prop->data;

        for (i = 0; i < MAX_TAP; i++)
            para->tap_action[i] = action[i];
    }
    else if (property == prop_clickaction) {
        int i;
        CARD8 *action;

        if (prop->size > MAX_CLICK || prop->format != 8 ||
            prop->type != XA_INTEGER)
            return BadMatch;

        action = (CARD8 *) prop->data;

        for (i = 0; i < MAX_CLICK; i++)
            para->click_action[i] = action[i];
    }
    else if (property == prop_circscroll) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->circular_scrolling = *(BOOL *) prop->data;

    }
    else if (property == prop_circscroll_dist) {
        float circdist;

        if (prop->size != 1 || prop->format != 32 || prop->type != float_type)
            return BadMatch;

        circdist = *(float *) prop->data;
        if (circdist == 0)
            return BadValue;

        para->scroll_dist_circ = circdist;
    }
    else if (property == prop_circscroll_trigger) {
        int trigger;

        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        trigger = *(CARD8 *) prop->data;
        if (trigger > 8)
            return BadValue;

        para->circular_trigger = trigger;

    }
    else if (property == prop_circpad) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->circular_pad = *(BOOL *) prop->data;
    }
    else if (property == prop_palm) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->palm_detect = *(BOOL *) prop->data;
    }
    else if (property == prop_palm_dim) {
        INT32 *dim;

        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        dim = (INT32 *) prop->data;

        para->palm_min_width = dim[0];
        para->palm_min_z = dim[1];
    }
    else if (property == prop_coastspeed) {
        float *coast_speeds;

        if (prop->size != 2 || prop->format != 32 || prop->type != float_type)
            return BadMatch;

        coast_speeds = (float *) prop->data;
        para->coasting_speed = coast_speeds[0];
        para->coasting_friction = coast_speeds[1];
    }
    else if (property == prop_pressuremotion) {
        CARD32 *press;

        if (prop->size != 2 || prop->format != 32 || prop->type != XA_CARDINAL)
            return BadMatch;

        press = (CARD32 *) prop->data;
        if (press[0] > press[1])
            return BadValue;

        para->press_motion_min_z = press[0];
        para->press_motion_max_z = press[1];
    }
    else if (property == prop_pressuremotion_factor) {
        float *press;

        if (prop->size != 2 || prop->format != 32 || prop->type != float_type)
            return BadMatch;

        press = (float *) prop->data;
        if (press[0] > press[1])
            return BadValue;

        para->press_motion_min_factor = press[0];
        para->press_motion_max_factor = press[1];
    }
    else if (property == prop_grab) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->grab_event_device = *(BOOL *) prop->data;
    }
    else if (property == prop_capabilities) {
        /* read-only */
        return BadValue;
    }
    else if (property == prop_resolution) {
        /* read-only */
        return BadValue;
    }
    else if (property == prop_area) {
        INT32 *area;

        if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        area = (INT32 *) prop->data;
        if ((((area[0] != 0) && (area[1] != 0)) && (area[0] > area[1])) ||
            (((area[2] != 0) && (area[3] != 0)) && (area[2] > area[3])))
            return BadValue;

        para->area_left_edge = area[0];
        para->area_right_edge = area[1];
        para->area_top_edge = area[2];
        para->area_bottom_edge = area[3];
    }
    else if (property == prop_softbutton_areas) {
        int *areas;

        if (prop->size != 8 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        areas = (int *) prop->data;
        if (!SynapticsIsSoftButtonAreasValid(areas))
            return BadValue;

        memcpy(para->softbutton_areas[BOTTOM_RIGHT_BUTTON_AREA], areas, 4 * sizeof(int));
        memcpy(para->softbutton_areas[BOTTOM_MIDDLE_BUTTON_AREA], areas + 4, 4 * sizeof(int));
    }
    else if (property == prop_secondary_softbutton_areas) {
        int *areas;

        if (prop->size != 8 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        areas = (int *) prop->data;
        if (!SynapticsIsSoftButtonAreasValid(areas))
            return BadValue;

        memcpy(para->softbutton_areas[TOP_RIGHT_BUTTON_AREA], areas, 4 * sizeof(int));
        memcpy(para->softbutton_areas[TOP_MIDDLE_BUTTON_AREA], areas + 4, 4 * sizeof(int));
    }
    else if (property == prop_noise_cancellation) {
        INT32 *hyst;

        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        hyst = (INT32 *) prop->data;
        if (hyst[0] < 0 || hyst[1] < 0)
            return BadValue;
        para->hyst_x = hyst[0];
        para->hyst_y = hyst[1];
    }
    else if (property == prop_product_id || property == prop_device_node)
        return BadValue;        /* read-only */
    else { /* unknown property */
        if (strcmp(SYNAPTICS_PROP_SOFTBUTTON_AREAS, NameForAtom(property)) == 0)
        {
            prop_softbutton_areas = property;
            if (SetProperty(dev, property, prop, checkonly) != Success)
                prop_softbutton_areas = 0;
            else if (!checkonly)
                XISetDevicePropertyDeletable(dev, property, FALSE);
        }
    }

    return Success;
}
@


1.8
log
@Update to xf86-input-synaptics 1.8.0.

ok matthieu@@, tested claudio@@
@
text
@d132 1
@


1.7
log
@Update to xf86-input-synaptics 1.7.5.

ok matthieu@@
@
text
@d94 1
d168 8
a175 8
    values[0] = para->softbutton_areas[0][0];
    values[1] = para->softbutton_areas[0][1];
    values[2] = para->softbutton_areas[0][2];
    values[3] = para->softbutton_areas[0][3];
    values[4] = para->softbutton_areas[1][0];
    values[5] = para->softbutton_areas[1][1];
    values[6] = para->softbutton_areas[1][2];
    values[7] = para->softbutton_areas[1][3];
d178 17
d789 15
a803 2
        memcpy(para->softbutton_areas[0], areas, 4 * sizeof(int));
        memcpy(para->softbutton_areas[1], areas + 4, 4 * sizeof(int));
@


1.6
log
@Update to xf86-input-synaptics 1.7.1.

ok mpi@@ jcs@@ matthieu@@
@
text
@d71 3
d253 16
d298 3
d543 37
d672 6
d717 13
@


1.5
log
@Update to xf86-input-synaptics 1.6.2

ok matthieu@@, mpi@@
@
text
@d2 1
a2 1
 * Copyright © 2008 Red Hat, Inc.
a37 1
#include "synaptics.h"
a60 1
Atom prop_tap_fast = 0;
a70 3
Atom prop_buttonscroll = 0;
Atom prop_buttonscroll_repeat = 0;
Atom prop_buttonscroll_time = 0;
d203 1
a203 1
    values[2] = para->finger_press;
a218 2
    prop_tap_fast =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_FAST, 8, 1, &para->fast_taps);
d247 1
a247 1
    fvalues[3] = para->trackstick_speed;
a249 29
    values[0] = para->edge_motion_min_z;
    values[1] = para->edge_motion_max_z;
    prop_edgemotion_pressure =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION_PRESSURE, 32, 2, values);

    values[0] = para->edge_motion_min_speed;
    values[1] = para->edge_motion_max_speed;
    prop_edgemotion_speed =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION_SPEED, 32, 2, values);
    prop_edgemotion_always =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION, 8, 1,
                 &para->edge_motion_use_always);

    if (priv->has_scrollbuttons) {
        values[0] = para->updown_button_scrolling;
        values[1] = para->leftright_button_scrolling;
        prop_buttonscroll =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING, 8, 2, values);

        values[0] = para->updown_button_repeat;
        values[1] = para->leftright_button_repeat;
        prop_buttonscroll_repeat =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT, 8, 2,
                     values);
        prop_buttonscroll_time =
            InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_TIME, 32, 1,
                     &para->scroll_button_repeat);
    }

a278 3
    prop_circpad =
        InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_PAD, 8, 1,
                 &para->circular_pad);
a406 2
        para->finger_press = finger[2];

a448 7
    else if (property == prop_tap_fast) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->fast_taps = *(BOOL *) prop->data;

    }
a478 1
#ifdef HAVE_SMOOTH_SCROLL
a480 1
#endif
a483 1
#ifdef HAVE_SMOOTH_SCROLL
a486 1
#endif
a519 74
        para->trackstick_speed = speed[3];

    }
    else if (property == prop_edgemotion_pressure) {
        CARD32 *pressure;

        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        pressure = (CARD32 *) prop->data;
        if (pressure[0] > pressure[1])
            return BadValue;

        para->edge_motion_min_z = pressure[0];
        para->edge_motion_max_z = pressure[1];

    }
    else if (property == prop_edgemotion_speed) {
        CARD32 *speed;

        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        speed = (CARD32 *) prop->data;
        if (speed[0] > speed[1])
            return BadValue;

        para->edge_motion_min_speed = speed[0];
        para->edge_motion_max_speed = speed[1];

    }
    else if (property == prop_edgemotion_always) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->edge_motion_use_always = *(BOOL *) prop->data;

    }
    else if (property == prop_buttonscroll) {
        BOOL *scroll;

        if (!priv->has_scrollbuttons)
            return BadMatch;

        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        scroll = (BOOL *) prop->data;
        para->updown_button_scrolling = scroll[0];
        para->leftright_button_scrolling = scroll[1];

    }
    else if (property == prop_buttonscroll_repeat) {
        BOOL *repeat;

        if (!priv->has_scrollbuttons)
            return BadMatch;

        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        repeat = (BOOL *) prop->data;
        para->updown_button_repeat = repeat[0];
        para->leftright_button_repeat = repeat[1];
    }
    else if (property == prop_buttonscroll_time) {
        if (!priv->has_scrollbuttons)
            return BadMatch;

        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
            return BadMatch;

        para->scroll_button_repeat = *(INT32 *) prop->data;

a612 6
    else if (property == prop_circpad) {
        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
            return BadMatch;

        para->circular_pad = *(BOOL *) prop->data;
    }
d710 10
@


1.4
log
@Update to xf86-input-synaptics 1.6.1

ok matthieu@@
@
text
@d522 3
d721 3
@


1.3
log
@Update to xf86-input-synaptics 1.5.2.

ok matthieu@@
@
text
@d56 33
a88 32
Atom prop_edges                 = 0;
Atom prop_finger                = 0;
Atom prop_tap_time              = 0;
Atom prop_tap_move              = 0;
Atom prop_tap_durations         = 0;
Atom prop_tap_fast              = 0;
Atom prop_middle_timeout        = 0;
Atom prop_twofinger_pressure    = 0;
Atom prop_twofinger_width       = 0;
Atom prop_scrolldist            = 0;
Atom prop_scrolledge            = 0;
Atom prop_scrolltwofinger       = 0;
Atom prop_speed                 = 0;
Atom prop_edgemotion_pressure   = 0;
Atom prop_edgemotion_speed      = 0;
Atom prop_edgemotion_always     = 0;
Atom prop_buttonscroll          = 0;
Atom prop_buttonscroll_repeat   = 0;
Atom prop_buttonscroll_time     = 0;
Atom prop_off                   = 0;
Atom prop_lockdrags             = 0;
Atom prop_lockdrags_time        = 0;
Atom prop_tapaction             = 0;
Atom prop_clickaction           = 0;
Atom prop_circscroll            = 0;
Atom prop_circscroll_dist       = 0;
Atom prop_circscroll_trigger    = 0;
Atom prop_circpad               = 0;
Atom prop_palm                  = 0;
Atom prop_palm_dim              = 0;
Atom prop_coastspeed            = 0;
Atom prop_pressuremotion        = 0;
d90 9
a98 8
Atom prop_grab                  = 0;
Atom prop_gestures              = 0;
Atom prop_capabilities          = 0;
Atom prop_resolution            = 0;
Atom prop_area                  = 0;
Atom prop_noise_cancellation    = 0;
Atom prop_product_id            = 0;
Atom prop_device_node           = 0;
d106 1
a106 1
    uint8_t val_8[9]; /* we never have more than 9 values in an atom */
d111 11
a121 8

    for (i = 0; i < nvalues; i++)
    {
        switch(format)
        {
            case 8:  val_8[i]  = values[i]; break;
            case 16: val_16[i] = values[i]; break;
            case 32: val_32[i] = values[i]; break;
d125 10
a134 5
    switch(format)
    {
        case 8: converted = val_8; break;
        case 16: converted = val_16; break;
        case 32: converted = val_32; break;
d162 19
d186 2
a187 2
    int values[9]; /* we never have more than 9 values in an atom */
    float fvalues[4]; /* never have more than 4 float values */
d190 1
a190 2
    if (!float_type)
    {
d192 1
a192 2
        if (!float_type)
        {
d211 4
a214 2
    prop_tap_time = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_TIME, 32, 1, &para->tap_time);
    prop_tap_move = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_MOVE, 32, 1, &para->tap_move);
d220 15
a234 8
    prop_tap_durations = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_DURATIONS, 32, 3, values);
    prop_tap_fast = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_FAST, 8, 1, &para->fast_taps);
    prop_middle_timeout = InitAtom(pInfo->dev, SYNAPTICS_PROP_MIDDLE_TIMEOUT,
                                   32, 1, &para->emulate_mid_button_time);
    prop_twofinger_pressure = InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_PRESSURE,
                                       32, 1, &para->emulate_twofinger_z);
    prop_twofinger_width = InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_WIDTH,
                                       32, 1, &para->emulate_twofinger_w);
d238 2
a239 1
    prop_scrolldist = InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_DISTANCE, 32, 2, values);
d244 2
a245 1
    prop_scrolledge = InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_EDGE,8, 3, values);
d248 2
a249 1
    prop_scrolltwofinger = InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_TWOFINGER,8, 2, values);
d259 2
a260 1
    prop_edgemotion_pressure = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION_PRESSURE, 32, 2, values);
d264 5
a268 2
    prop_edgemotion_speed = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION_SPEED, 32, 2, values);
    prop_edgemotion_always = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION, 8, 1, &para->edge_motion_use_always);
d270 1
a270 2
    if (priv->has_scrollbuttons)
    {
d273 2
a274 1
        prop_buttonscroll = InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING, 8, 2, values);
d278 6
a283 2
        prop_buttonscroll_repeat = InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT, 8, 2, values);
        prop_buttonscroll_time = InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_TIME, 32, 1, &para->scroll_button_repeat);
d286 8
a293 3
    prop_off = InitAtom(pInfo->dev, SYNAPTICS_PROP_OFF, 8, 1, &para->touchpad_off);
    prop_lockdrags = InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS, 8, 1, &para->locked_drags);
    prop_lockdrags_time = InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS_TIMEOUT, 32, 1, &para->locked_drag_time);
d296 2
a297 1
    prop_tapaction = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_ACTION, 8, MAX_TAP, values);
d300 2
a301 1
    prop_clickaction = InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICK_ACTION, 8, MAX_CLICK, values);
d303 3
a305 1
    prop_circscroll = InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING, 8, 1, &para->circular_scrolling);
d308 13
a320 5
    prop_circscroll_dist = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_DIST, 1, fvalues);

    prop_circscroll_trigger = InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_TRIGGER, 8, 1, &para->circular_trigger);
    prop_circpad = InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_PAD, 8, 1, &para->circular_pad);
    prop_palm = InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DETECT, 8, 1, &para->palm_detect);
d325 2
a326 1
    prop_palm_dim = InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DIMENSIONS, 32, 2, values);
d330 2
a331 1
    prop_coastspeed = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_COASTING_SPEED, 2, fvalues);
d335 3
a337 1
    prop_pressuremotion = InitTypedAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION, XA_CARDINAL, 32, 2, values);
d342 7
a348 3
    prop_pressuremotion_factor = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR, 2, fvalues);

    prop_grab = InitAtom(pInfo->dev, SYNAPTICS_PROP_GRAB, 8, 1, &para->grab_event_device);
d360 2
a361 1
    prop_capabilities = InitAtom(pInfo->dev, SYNAPTICS_PROP_CAPABILITIES, 8, 7, values);
d365 2
a366 1
    prop_resolution = InitAtom(pInfo->dev, SYNAPTICS_PROP_RESOLUTION, 32, 2, values);
d374 3
d380 2
a381 1
            SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2, values);
d384 1
a384 2
    if (priv->id_vendor || priv->id_product)
    {
d387 2
a388 1
        prop_product_id = InitAtom(pInfo->dev, XI_PROP_PRODUCT_ID, 32, 2, values);
d391 3
a393 3
    if (priv->device)
    {
        prop_device_node = MakeAtom(XI_PROP_DEVICE_NODE, strlen(XI_PROP_DEVICE_NODE), TRUE);
d396 1
a396 1
                               priv->device, FALSE);
d413 1
a413 2
    if (checkonly)
    {
d418 1
a418 2
    if (property == prop_edges)
    {
d420 1
d424 1
a424 1
        edges = (INT32*)prop->data;
d428 3
a430 3
        para->left_edge   = edges[0];
        para->right_edge  = edges[1];
        para->top_edge    = edges[2];
d433 2
a434 2
    } else if (property == prop_finger)
    {
d436 1
d440 1
a440 1
        finger = (INT32*)prop->data;
d444 2
a445 2
        para->finger_low   = finger[0];
        para->finger_high  = finger[1];
d448 2
a449 2
    } else if (property == prop_tap_time)
    {
d453 1
a453 1
        para->tap_time = *(INT32*)prop->data;
d455 2
a456 2
    } else if (property == prop_tap_move)
    {
d460 3
a462 3
        para->tap_move = *(INT32*)prop->data;
    } else if (property == prop_tap_durations)
    {
d468 1
a468 1
        timeouts = (INT32*)prop->data;
d471 8
a478 2
        para->tap_time_2         = timeouts[1];
        para->click_time         = timeouts[2];
d480 11
a490 2
    } else if (property == prop_tap_fast)
    {
d494 1
a494 1
        para->fast_taps = *(BOOL*)prop->data;
d496 2
a497 2
    } else if (property == prop_middle_timeout)
    {
d501 3
a503 3
        para->emulate_mid_button_time = *(INT32*)prop->data;
    } else if (property == prop_twofinger_pressure)
    {
d507 3
a509 3
        para->emulate_twofinger_z = *(INT32*)prop->data;
    } else if (property == prop_twofinger_width)
    {
d513 3
a515 3
        para->emulate_twofinger_w = *(INT32*)prop->data;
    } else if (property == prop_scrolldist)
    {
d517 1
d521 18
a538 5
        dist = (INT32*)prop->data;
        para->scroll_dist_vert = dist[0];
        para->scroll_dist_horiz = dist[1];
    } else if (property == prop_scrolledge)
    {
d540 1
d544 3
a546 3
        edge = (BOOL*)prop->data;
        para->scroll_edge_vert   = edge[0];
        para->scroll_edge_horiz  = edge[1];
d548 2
a549 2
    } else if (property == prop_scrolltwofinger)
    {
d555 2
a556 2
        twofinger = (BOOL*)prop->data;
        para->scroll_twofinger_vert  = twofinger[0];
d558 2
a559 2
    } else if (property == prop_speed)
    {
d565 1
a565 1
        speed = (float*)prop->data;
d571 2
a572 2
    } else if (property == prop_edgemotion_pressure)
    {
d578 1
a578 1
        pressure = (CARD32*)prop->data;
d585 2
a586 2
    } else if (property == prop_edgemotion_speed)
    {
d592 1
a592 1
        speed = (CARD32*)prop->data;
d599 2
a600 2
    } else if (property == prop_edgemotion_always)
    {
d604 1
a604 1
        para->edge_motion_use_always = *(BOOL*)prop->data;
d606 2
a607 2
    } else if (property == prop_buttonscroll)
    {
d616 2
a617 2
        scroll = (BOOL*)prop->data;
        para->updown_button_scrolling    = scroll[0];
d620 2
a621 2
    } else if (property == prop_buttonscroll_repeat)
    {
d630 2
a631 2
        repeat = (BOOL*)prop->data;
        para->updown_button_repeat    = repeat[0];
d633 2
a634 2
    } else if (property == prop_buttonscroll_time)
    {
d641 1
a641 1
        para->scroll_button_repeat = *(INT32*)prop->data;
d643 2
a644 2
    } else if (property == prop_off)
    {
d646 1
d650 1
a650 1
        off = *(CARD8*)prop->data;
d656 2
a657 2
    } else if (property == prop_gestures)
    {
d663 1
a663 1
        gestures = (BOOL*)prop->data;
d665 2
a666 2
    } else if (property == prop_lockdrags)
    {
d670 3
a672 3
        para->locked_drags = *(BOOL*)prop->data;
    } else if (property == prop_lockdrags_time)
    {
d676 3
a678 3
        para->locked_drag_time = *(INT32*)prop->data;
    } else if (property == prop_tapaction)
    {
d682 2
a683 1
        if (prop->size > MAX_TAP || prop->format != 8 || prop->type != XA_INTEGER)
d686 1
a686 1
        action = (CARD8*)prop->data;
d690 2
a691 2
    } else if (property == prop_clickaction)
    {
d695 2
a696 1
        if (prop->size > MAX_CLICK || prop->format != 8 || prop->type != XA_INTEGER)
d699 1
a699 1
        action = (CARD8*)prop->data;
d703 2
a704 2
    } else if (property == prop_circscroll)
    {
d708 1
a708 1
        para->circular_scrolling = *(BOOL*)prop->data;
d710 2
a711 2
    } else if (property == prop_circscroll_dist)
    {
d717 1
a717 1
        circdist = *(float*)prop->data;
d719 2
a720 2
    } else if (property == prop_circscroll_trigger)
    {
d722 1
d726 1
a726 1
        trigger = *(CARD8*)prop->data;
d732 2
a733 2
    } else if (property == prop_circpad)
    {
d737 3
a739 3
        para->circular_pad = *(BOOL*)prop->data;
    } else if (property == prop_palm)
    {
d743 3
a745 3
        para->palm_detect = *(BOOL*)prop->data;
    } else if (property == prop_palm_dim)
    {
d751 1
a751 1
        dim = (INT32*)prop->data;
d754 3
a756 3
        para->palm_min_z     = dim[1];
    } else if (property == prop_coastspeed)
    {
d762 1
a762 1
        coast_speeds = (float*)prop->data;
d765 2
a766 2
    } else if (property == prop_pressuremotion)
    {
d768 1
d772 1
a772 1
        press = (CARD32*)prop->data;
d778 2
a779 2
    } else if (property == prop_grab)
    {
d783 3
a785 3
        para->grab_event_device = *(BOOL*)prop->data;
    } else if (property == prop_capabilities)
    {
d788 2
a789 2
    } else if (property == prop_resolution)
    {
d792 2
a793 2
    } else if (property == prop_area)
    {
d795 1
d799 3
a801 2
        area = (INT32*)prop->data;
        if ((((area[0] != 0) && (area[1] != 0)) && (area[0] > area[1]) ) || (((area[2] != 0) && (area[3] != 0)) && (area[2] > area[3])))
d804 3
a806 3
        para->area_left_edge   = area[0];
        para->area_right_edge  = area[1];
        para->area_top_edge    = area[2];
d808 15
a822 1
    } else if (property == prop_noise_cancellation) {
d824 1
d828 1
a828 1
        hyst = (INT32*)prop->data;
d833 3
a835 2
    } else if (property == prop_product_id || property == prop_device_node)
        return BadValue; /* read-only */
a838 1

@


1.2
log
@Update to xf86-input-synaptics 1.5.0.
ok mpi@@, matthieu@@
@
text
@d99 2
a100 1
InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
d128 1
a128 2
    XIChangeDeviceProperty(dev, atom, XA_INTEGER, format,
                           PropModeReplace, nvalues,
d135 6
d269 1
a269 1
    prop_pressuremotion = InitAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION, 32, 2, values);
d655 2
a656 2
        float *press;
        if (prop->size != 2 || prop->format != 32 || prop->type != float_type)
d659 1
a659 1
        press = (float*)prop->data;
@


1.1
log
@Initial revision
@
text
@d45 9
d95 2
d160 2
a161 2
            xf86Msg(X_ERROR, "%s: Failed to init float atom. "
                             "Disabling property support.\n", pInfo->name);
d299 17
d697 2
a698 1
    }
@


1.1.1.1
log
@Import xf86-input-synaptics 1.4.0

ok matthieu@@
@
text
@@
