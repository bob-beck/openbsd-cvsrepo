head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.14
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.12
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.10
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.6
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v6_6_3:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2013.08.16.17.04.11;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.18.09.48.06;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.28.10.03.36;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.02.06.22.53.13;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.17.10.31.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.27.00.04.55;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.01.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.01.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@/*
 * Copyright 2005 Eric Anholt
 * Copyright 2005 Benjamin Herrenschmidt
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <anholt@@FreeBSD.org>
 *    Zack Rusin <zrusin@@trolltech.com>
 *    Benjamin Herrenschmidt <benh@@kernel.crashing.org>
 *    Alex Deucher <alexander.deucher@@amd.com>
 *
 */

struct blendinfo {
    Bool dst_alpha;
    Bool src_alpha;
    uint32_t blend_cntl;
};

static struct blendinfo RadeonBlendOp[] = {
    /* Clear */
    {0, 0, RADEON_SRC_BLEND_GL_ZERO	      | RADEON_DST_BLEND_GL_ZERO},
    /* Src */
    {0, 0, RADEON_SRC_BLEND_GL_ONE	      | RADEON_DST_BLEND_GL_ZERO},
    /* Dst */
    {0, 0, RADEON_SRC_BLEND_GL_ZERO	      | RADEON_DST_BLEND_GL_ONE},
    /* Over */
    {0, 1, RADEON_SRC_BLEND_GL_ONE	      | RADEON_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA},
    /* OverReverse */
    {1, 0, RADEON_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA | RADEON_DST_BLEND_GL_ONE},
    /* In */
    {1, 0, RADEON_SRC_BLEND_GL_DST_ALPHA     | RADEON_DST_BLEND_GL_ZERO},
    /* InReverse */
    {0, 1, RADEON_SRC_BLEND_GL_ZERO	      | RADEON_DST_BLEND_GL_SRC_ALPHA},
    /* Out */
    {1, 0, RADEON_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA | RADEON_DST_BLEND_GL_ZERO},
    /* OutReverse */
    {0, 1, RADEON_SRC_BLEND_GL_ZERO	      | RADEON_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA},
    /* Atop */
    {1, 1, RADEON_SRC_BLEND_GL_DST_ALPHA     | RADEON_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA},
    /* AtopReverse */
    {1, 1, RADEON_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA | RADEON_DST_BLEND_GL_SRC_ALPHA},
    /* Xor */
    {1, 1, RADEON_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA | RADEON_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA},
    /* Add */
    {0, 0, RADEON_SRC_BLEND_GL_ONE	      | RADEON_DST_BLEND_GL_ONE},
};

struct formatinfo {
    int fmt;
    uint32_t card_fmt;
};

/* Note on texture formats:
 * TXFORMAT_Y8 expands to (Y,Y,Y,1).  TXFORMAT_I8 expands to (I,I,I,I)
 */
static struct formatinfo R100TexFormats[] = {
	{PICT_a8r8g8b8,	RADEON_TXFORMAT_ARGB8888 | RADEON_TXFORMAT_ALPHA_IN_MAP},
	{PICT_x8r8g8b8,	RADEON_TXFORMAT_ARGB8888},
	{PICT_r5g6b5,	RADEON_TXFORMAT_RGB565},
	{PICT_a1r5g5b5,	RADEON_TXFORMAT_ARGB1555 | RADEON_TXFORMAT_ALPHA_IN_MAP},
	{PICT_x1r5g5b5,	RADEON_TXFORMAT_ARGB1555},
	{PICT_a8,	RADEON_TXFORMAT_I8 | RADEON_TXFORMAT_ALPHA_IN_MAP},
};

static struct formatinfo R200TexFormats[] = {
    {PICT_a8r8g8b8,	R200_TXFORMAT_ARGB8888 | R200_TXFORMAT_ALPHA_IN_MAP},
    {PICT_x8r8g8b8,	R200_TXFORMAT_ARGB8888},
    {PICT_a8b8g8r8,	R200_TXFORMAT_ABGR8888 | R200_TXFORMAT_ALPHA_IN_MAP},
    {PICT_x8b8g8r8,	R200_TXFORMAT_ABGR8888},
    {PICT_r5g6b5,	R200_TXFORMAT_RGB565},
    {PICT_a1r5g5b5,	R200_TXFORMAT_ARGB1555 | R200_TXFORMAT_ALPHA_IN_MAP},
    {PICT_x1r5g5b5,	R200_TXFORMAT_ARGB1555},
    {PICT_a8,		R200_TXFORMAT_I8 | R200_TXFORMAT_ALPHA_IN_MAP},
};

static struct formatinfo R300TexFormats[] = {
    {PICT_a8r8g8b8,	R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)},
    {PICT_x8r8g8b8,	R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8)},
    {PICT_a8b8g8r8,	R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)},
    {PICT_x8b8g8r8,	R300_EASY_TX_FORMAT(Z, Y, X, ONE, W8Z8Y8X8)},
    {PICT_b8g8r8a8,	R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)},
    {PICT_b8g8r8x8,	R300_EASY_TX_FORMAT(W, Z, Y, ONE, W8Z8Y8X8)},
    {PICT_r5g6b5,	R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)},
    {PICT_a1r5g5b5,	R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)},
    {PICT_x1r5g5b5,	R300_EASY_TX_FORMAT(X, Y, Z, ONE, W1Z5Y5X5)},
    {PICT_a8,		R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8)},
};

/* Common Radeon setup code */

static Bool RADEONGetDestFormat(PicturePtr pDstPicture, uint32_t *dst_format)
{
    switch (pDstPicture->format) {
    case PICT_a8r8g8b8:
    case PICT_x8r8g8b8:
	*dst_format = RADEON_COLOR_FORMAT_ARGB8888;
	break;
    case PICT_r5g6b5:
	*dst_format = RADEON_COLOR_FORMAT_RGB565;
	break;
    case PICT_a1r5g5b5:
    case PICT_x1r5g5b5:
	*dst_format = RADEON_COLOR_FORMAT_ARGB1555;
	break;
    case PICT_a8:
	*dst_format = RADEON_COLOR_FORMAT_RGB8;
	break;
    default:
	RADEON_FALLBACK(("Unsupported dest format 0x%x\n",
			(int)pDstPicture->format));
    }

    return TRUE;
}

static Bool R300GetDestFormat(PicturePtr pDstPicture, uint32_t *dst_format)
{
    switch (pDstPicture->format) {
    case PICT_a8r8g8b8:
    case PICT_x8r8g8b8:
    case PICT_a8b8g8r8:
    case PICT_x8b8g8r8:
    case PICT_b8g8r8a8:
    case PICT_b8g8r8x8:
	*dst_format = R300_COLORFORMAT_ARGB8888;
	break;
    case PICT_r5g6b5:
	*dst_format = R300_COLORFORMAT_RGB565;
	break;
    case PICT_a1r5g5b5:
    case PICT_x1r5g5b5:
	*dst_format = R300_COLORFORMAT_ARGB1555;
	break;
    case PICT_a8:
	*dst_format = R300_COLORFORMAT_I8;
	break;
    default:
	RADEON_FALLBACK(("Unsupported dest format 0x%x\n",
	       (int)pDstPicture->format));
    }
    return TRUE;
}

static uint32_t RADEONGetBlendCntl(int op, PicturePtr pMask, uint32_t dst_format)
{
    uint32_t sblend, dblend;

    sblend = RadeonBlendOp[op].blend_cntl & RADEON_SRC_BLEND_MASK;
    dblend = RadeonBlendOp[op].blend_cntl & RADEON_DST_BLEND_MASK;

    /* If there's no dst alpha channel, adjust the blend op so that we'll treat
     * it as always 1.
     */
    if (PICT_FORMAT_A(dst_format) == 0 && RadeonBlendOp[op].dst_alpha) {
	if (sblend == RADEON_SRC_BLEND_GL_DST_ALPHA)
	    sblend = RADEON_SRC_BLEND_GL_ONE;
	else if (sblend == RADEON_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA)
	    sblend = RADEON_SRC_BLEND_GL_ZERO;
    }

    /* If the source alpha is being used, then we should only be in a case where
     * the source blend factor is 0, and the source blend value is the mask
     * channels multiplied by the source picture's alpha.
     */
    if (pMask && pMask->componentAlpha && RadeonBlendOp[op].src_alpha) {
	if (dblend == RADEON_DST_BLEND_GL_SRC_ALPHA) {
	    dblend = RADEON_DST_BLEND_GL_SRC_COLOR;
	} else if (dblend == RADEON_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA) {
	    dblend = RADEON_DST_BLEND_GL_ONE_MINUS_SRC_COLOR;
	}
    }

    return sblend | dblend;
}

union intfloat {
    float f;
    uint32_t i;
};

/* Check if we need a software-fallback because of a repeating
 *   non-power-of-two texture.
 *
 * canTile: whether we can emulate a repeat by drawing in tiles:
 *   possible for the source, but not for the mask. (Actually
 *   we could do tiling for the mask too, but dealing with the
 *   combination of a tiled mask and a tiled source would be
 *   a lot of complexity, so we handle only the most common
 *   case of a repeating mask.)
 */
static Bool RADEONCheckTexturePOT(PicturePtr pPict, Bool canTile)
{
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;

    if ((repeatType == RepeatNormal || repeatType == RepeatReflect) &&
	((w & (w - 1)) != 0 || (h & (h - 1)) != 0) &&
	!(repeatType == RepeatNormal && !pPict->transform && canTile))
	RADEON_FALLBACK(("NPOT repeating %s unsupported (%dx%d), transform=%d\n",
			 canTile ? "source" : "mask", w, h, pPict->transform != 0));

    return TRUE;
}

/* Determine if the pitch of the pixmap meets the criteria for being
 * used as a repeating texture: no padding or only a single line texture.
 */
static Bool RADEONPitchMatches(PixmapPtr pPix)
{
    int w = pPix->drawable.width;
    int h = pPix->drawable.height;
    uint32_t txpitch = exaGetPixmapPitch(pPix);

    if (h > 1 && (RADEON_ALIGN(w * pPix->drawable.bitsPerPixel / 8, 32)) != txpitch)
	return FALSE;

    return TRUE;
}

/* We can't turn on repeats normally for a non-power-of-two dimension,
 * but if the source isn't transformed, we can get the same effect
 * by drawing the image in multiple tiles. (A common case that it's
 * important to get right is drawing a strip of a NPOTxPOT texture
 * repeating in the POT direction. With tiling, this ends up as a
 * a single tile on R300 and newer, which is perfect.)
 *
 * canTile1d: On R300 and newer, we can repeat a texture that is NPOT in
 *   one direction and POT in the other in the POT direction; on
 *   older chips we can only repeat at all if the texture is POT in
 *   both directions.
 *
 * needMatchingPitch: On R100/R200, we can only repeat horizontally if
 *   there is no padding in the texture. Textures with small POT widths
 *   (1,2,4,8) thus can't be tiled.
 */
static Bool RADEONSetupSourceTile(PicturePtr pPict,
				  PixmapPtr pPix,
				  Bool canTile1d,
				  Bool needMatchingPitch)
{
    RINFO_FROM_SCREEN(pPix->drawable.pScreen);
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;

    info->accel_state->need_src_tile_x = info->accel_state->need_src_tile_y = FALSE;
    info->accel_state->src_tile_width = info->accel_state->src_tile_height = 65536; /* "infinite" */
	    
    if (repeatType == RepeatNormal || repeatType == RepeatReflect) {
	Bool badPitch = needMatchingPitch && !RADEONPitchMatches(pPix);
	
	int w = pPict->pDrawable ? pPict->pDrawable->width : 1;
	int h = pPict->pDrawable ? pPict->pDrawable->height : 1;
	
	if (pPict->transform) {
	    if (badPitch)
		RADEON_FALLBACK(("Width %d and pitch %u not compatible for repeat\n",
				 w, (unsigned)exaGetPixmapPitch(pPix)));
	} else {
	    info->accel_state->need_src_tile_x = (w & (w - 1)) != 0 || badPitch;
	    info->accel_state->need_src_tile_y = (h & (h - 1)) != 0;

	    if ((info->accel_state->need_src_tile_x ||
		 info->accel_state->need_src_tile_y) &&
		repeatType != RepeatNormal)
		RADEON_FALLBACK(("Can only tile RepeatNormal at this time\n"));

	    if (!canTile1d)
		info->accel_state->need_src_tile_x =
		    info->accel_state->need_src_tile_y =
		    info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y;
	}

	if (info->accel_state->need_src_tile_x)
	    info->accel_state->src_tile_width = w;
	if (info->accel_state->need_src_tile_y)
	    info->accel_state->src_tile_height = h;
    }

    return TRUE;
}

/* R100-specific code */

static Bool R100CheckCompositeTexture(PicturePtr pPict,
				      PicturePtr pDstPict,
				      int op,
				      int unit)
{
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    int i;

    for (i = 0; i < sizeof(R100TexFormats) / sizeof(R100TexFormats[0]); i++) {
	if (R100TexFormats[i].fmt == pPict->format)
	    break;
    }
    if (i == sizeof(R100TexFormats) / sizeof(R100TexFormats[0]))
	RADEON_FALLBACK(("Unsupported picture format 0x%x\n",
			(int)pPict->format));

    if (pPict->pDrawable && !RADEONCheckTexturePOT(pPict, unit == 0))
	return FALSE;

    if (pPict->filter != PictFilterNearest &&
	pPict->filter != PictFilterBilinear)
    {
	RADEON_FALLBACK(("Unsupported filter 0x%x\n", pPict->filter));
    }

    /* for REPEAT_NONE, Render semantics are that sampling outside the source
     * picture results in alpha=0 pixels. We can implement this with a border color
     * *if* our source texture has an alpha channel, otherwise we need to fall
     * back. If we're not transformed then we hope that upper layers have clipped
     * rendering to the bounds of the source drawable, in which case it doesn't
     * matter. I have not, however, verified that the X server always does such
     * clipping.
     */
    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
    }

    if (!radeon_transform_is_affine_or_scaled(pPict->transform))
	RADEON_FALLBACK(("non-affine transforms not supported\n"));

    return TRUE;
}

static Bool R100TextureSetup(PicturePtr pPict, PixmapPtr pPix,
					int unit)
{
    RINFO_FROM_SCREEN(pPix->drawable.pScreen);
    uint32_t txfilter, txformat, txoffset, txpitch;
    unsigned int repeatType;
    Bool repeat;
    int i, w, h;
    struct radeon_exa_pixmap_priv *driver_priv;

    if (pPict->pDrawable) {
	w = pPict->pDrawable->width;
	h = pPict->pDrawable->height;
	repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    } else {
	w = h = 1;
	repeatType = RepeatNormal;
    }

    repeat = (repeatType == RepeatNormal || repeatType == RepeatReflect) &&
	!(unit == 0 && (info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y));

    txpitch = exaGetPixmapPitch(pPix);
    txoffset = 0;

    if ((txpitch & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));

    for (i = 0; i < sizeof(R100TexFormats) / sizeof(R100TexFormats[0]); i++)
    {
	if (R100TexFormats[i].fmt == pPict->format)
	    break;
    }
    txformat = R100TexFormats[i].card_fmt;
    if (RADEONPixmapIsColortiled(pPix))
	txoffset |= RADEON_TXO_MACRO_TILE;

    if (repeat) {
	if (!RADEONPitchMatches(pPix))
	    RADEON_FALLBACK(("Width %d and pitch %u not compatible for repeat\n",
			     w, (unsigned)txpitch));

	txformat |= RADEONLog2(w) << RADEON_TXFORMAT_WIDTH_SHIFT;
	txformat |= RADEONLog2(h) << RADEON_TXFORMAT_HEIGHT_SHIFT;
    } else
	txformat |= RADEON_TXFORMAT_NON_POWER2;
    txformat |= unit << 24; /* RADEON_TXFORMAT_ST_ROUTE_STQX */

    info->accel_state->texW[unit] = w;
    info->accel_state->texH[unit] = h;

    switch (pPict->filter) {
    case PictFilterNearest:
	txfilter = (RADEON_MAG_FILTER_NEAREST | RADEON_MIN_FILTER_NEAREST);
	break;
    case PictFilterBilinear:
	txfilter = (RADEON_MAG_FILTER_LINEAR | RADEON_MIN_FILTER_LINEAR);
	break;
    default:
	RADEON_FALLBACK(("Bad filter 0x%x\n", pPict->filter));
    }

    switch (repeatType) {
	case RepeatNormal:
	    if (txformat & RADEON_TXFORMAT_NON_POWER2)
		txfilter |= RADEON_CLAMP_S_CLAMP_LAST | RADEON_CLAMP_T_CLAMP_LAST;
	    else
	        txfilter |= RADEON_CLAMP_S_WRAP | RADEON_CLAMP_T_WRAP;
	    break;
	case RepeatPad:
	    txfilter |= RADEON_CLAMP_S_CLAMP_LAST | RADEON_CLAMP_T_CLAMP_LAST;
	    break;
	case RepeatReflect:
	    txfilter |= RADEON_CLAMP_S_MIRROR | RADEON_CLAMP_T_MIRROR;
	    break;
	case RepeatNone:
	    /* don't set an illegal clamp mode for rects */
	    if (txformat & RADEON_TXFORMAT_NON_POWER2)
		txfilter |= RADEON_CLAMP_S_CLAMP_LAST | RADEON_CLAMP_T_CLAMP_LAST;
	    break;
    }

    BEGIN_ACCEL_RELOC(5, 1);
    if (unit == 0) {
	OUT_RING_REG(RADEON_PP_TXFILTER_0, txfilter);
	OUT_RING_REG(RADEON_PP_TXFORMAT_0, txformat);
	OUT_RING_REG(RADEON_PP_TEX_SIZE_0,
	    (pPix->drawable.width - 1) |
	    ((pPix->drawable.height - 1) << RADEON_TEX_VSIZE_SHIFT));
	OUT_RING_REG(RADEON_PP_TEX_PITCH_0, txpitch - 32);

	EMIT_READ_OFFSET(RADEON_PP_TXOFFSET_0, txoffset, pPix);
	/* emit a texture relocation */
    } else {
	OUT_RING_REG(RADEON_PP_TXFILTER_1, txfilter);
	OUT_RING_REG(RADEON_PP_TXFORMAT_1, txformat);

	OUT_RING_REG(RADEON_PP_TEX_SIZE_1,
	    (pPix->drawable.width - 1) |
	    ((pPix->drawable.height - 1) << RADEON_TEX_VSIZE_SHIFT));
	OUT_RING_REG(RADEON_PP_TEX_PITCH_1, txpitch - 32);
	EMIT_READ_OFFSET(RADEON_PP_TXOFFSET_1, txoffset, pPix);
	/* emit a texture relocation */
    }
    ADVANCE_RING();

    if (pPict->transform != 0) {
	info->accel_state->is_transform[unit] = TRUE;
	info->accel_state->transform[unit] = pPict->transform;
    } else {
	info->accel_state->is_transform[unit] = FALSE;
    }

    return TRUE;
}

static Bool R100CheckComposite(int op, PicturePtr pSrcPicture,
			       PicturePtr pMaskPicture, PicturePtr pDstPicture)
{
    PixmapPtr pSrcPixmap, pDstPixmap;
    uint32_t tmp1;

    /* Check for unsupported compositing operations. */
    if (op >= sizeof(RadeonBlendOp) / sizeof(RadeonBlendOp[0]))
	RADEON_FALLBACK(("Unsupported Composite op 0x%x\n", op));

    pDstPixmap = RADEONGetDrawablePixmap(pDstPicture->pDrawable);

    if (pDstPixmap->drawable.width > 2048 ||
	pDstPixmap->drawable.height > 2048) {
	RADEON_FALLBACK(("Dest w/h too large (%d,%d).\n",
			 pDstPixmap->drawable.width,
			 pDstPixmap->drawable.height));
    }

    if (pSrcPicture->pDrawable) {
	/* r100 limit should be 2048, there are issues with 2048
	 * see 197a62704742a4a19736c2637ac92d1dc5ab34ed
	 */
	pSrcPixmap = RADEONGetDrawablePixmap(pSrcPicture->pDrawable);

	if (pSrcPixmap->drawable.width > 2048 ||
	    pSrcPixmap->drawable.height > 2048) {
	    RADEON_FALLBACK(("Source w/h too large (%d,%d).\n",
			     pSrcPixmap->drawable.width,
			     pSrcPixmap->drawable.height));
	}
    } else if (pSrcPicture->pSourcePict->type != SourcePictTypeSolidFill)
	RADEON_FALLBACK(("Gradient pictures not supported yet\n"));

    if (pMaskPicture) {
	PixmapPtr pMaskPixmap;

	if (pMaskPicture->pDrawable) {
	    pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);

	    if (pMaskPixmap->drawable.width > 2048 ||
		pMaskPixmap->drawable.height > 2048) {
		RADEON_FALLBACK(("Mask w/h too large (%d,%d).\n",
				 pMaskPixmap->drawable.width,
				 pMaskPixmap->drawable.height));
	    }
	} else if (pMaskPicture->pSourcePict->type != SourcePictTypeSolidFill)
	    RADEON_FALLBACK(("Gradient pictures not supported yet\n"));

	if (pMaskPicture->componentAlpha) {
	    /* Check if it's component alpha that relies on a source alpha and
	     * on the source value.  We can only get one of those into the
	     * single source value that we get to blend with.
	     */
	    if (RadeonBlendOp[op].src_alpha &&
		(RadeonBlendOp[op].blend_cntl & RADEON_SRC_BLEND_MASK) !=
		RADEON_SRC_BLEND_GL_ZERO) {
		RADEON_FALLBACK(("Component alpha not supported with source "
				 "alpha and source value blending.\n"));
	    }
	}

	if (!R100CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1))
	    return FALSE;
    }

    if (!R100CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0))
	return FALSE;

    if (!RADEONGetDestFormat(pDstPicture, &tmp1))
	return FALSE;

    return TRUE;
}

static Bool
RADEONPrepareCompositeCS(int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
			    PicturePtr pDstPicture, PixmapPtr pSrc, PixmapPtr pMask,
			    PixmapPtr pDst)
{
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
    int ret;

    info->accel_state->composite_op = op;
    info->accel_state->dst_pic = pDstPicture;
    info->accel_state->msk_pic = pMaskPicture;
    info->accel_state->src_pic = pSrcPicture;
    info->accel_state->dst_pix = pDst;
    info->accel_state->msk_pix = pMask;
    info->accel_state->src_pix = pSrc;

    radeon_cs_space_reset_bos(info->cs);

    radeon_add_pixmap(info->cs, pSrc,
		      RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);

    if (pMask)
	radeon_add_pixmap(info->cs, pMask, RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);

    radeon_add_pixmap(info->cs, pDst, 0, RADEON_GEM_DOMAIN_VRAM);

    ret = radeon_cs_space_check(info->cs);
    if (ret)
	RADEON_FALLBACK(("Not enough RAM to hw accel composite operation\n"));

    return TRUE;
}

static Bool R100PrepareComposite(int op,
					    PicturePtr pSrcPicture,
					    PicturePtr pMaskPicture,
					    PicturePtr pDstPicture,
					    PixmapPtr pSrc,
					    PixmapPtr pMask,
					    PixmapPtr pDst)
{
    ScreenPtr pScreen = pDst->drawable.pScreen;
    RINFO_FROM_SCREEN(pScreen);
    uint32_t dst_format, dst_pitch, colorpitch;
    uint32_t pp_cntl, blendcntl, cblend, ablend;
    int pixel_shift;
    struct radeon_exa_pixmap_priv *driver_priv;

    TRACE;

    if (!RADEONGetDestFormat(pDstPicture, &dst_format))
	return FALSE;

    if (pDstPicture->format == PICT_a8 && RadeonBlendOp[op].dst_alpha)
	RADEON_FALLBACK(("Can't dst alpha blend A8\n"));

    pixel_shift = pDst->drawable.bitsPerPixel >> 4;

    dst_pitch = exaGetPixmapPitch(pDst);
    colorpitch = dst_pitch >> pixel_shift;
    if (RADEONPixmapIsColortiled(pDst))
	colorpitch |= RADEON_COLOR_TILE_ENABLE;

    if (!pSrc) {
	pSrc = RADEONSolidPixmap(pScreen, cpu_to_le32(pSrcPicture->pSourcePict->solidFill.color));
	if (!pSrc)
	    RADEON_FALLBACK(("Failed to create solid scratch pixmap\n"));
    }

    if (((dst_pitch >> pixel_shift) & 0x7) != 0)
	RADEON_FALLBACK(("Bad destination pitch 0x%x\n", (int)dst_pitch));

    if (!RADEONSetupSourceTile(pSrcPicture, pSrc, FALSE, TRUE))
	return FALSE;

    if (pMaskPicture && !pMask) {
	pMask = RADEONSolidPixmap(pScreen, cpu_to_le32(pMaskPicture->pSourcePict->solidFill.color));
	if (!pMask) {
	    if (!pSrcPicture->pDrawable)
		pScreen->DestroyPixmap(pSrc);
	    RADEON_FALLBACK(("Failed to create solid scratch pixmap\n"));
	}
    }

    RADEONPrepareCompositeCS(op, pSrcPicture, pMaskPicture, pDstPicture,
			     pSrc, pMask, pDst);

    /* switch to 3D after doing buffer space checks as the latter may flush */
    RADEON_SWITCH_TO_3D();

    if (!R100TextureSetup(pSrcPicture, pSrc, 0))
	return FALSE;
    pp_cntl = RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE;

    if (pMask != NULL) {
	if (!R100TextureSetup(pMaskPicture, pMask, 1))
	    return FALSE;
	pp_cntl |= RADEON_TEX_1_ENABLE;
    } else {
	info->accel_state->is_transform[1] = FALSE;
    }

    BEGIN_ACCEL_RELOC(10, 2);
    OUT_RING_REG(RADEON_PP_CNTL, pp_cntl);
    OUT_RING_REG(RADEON_RB3D_CNTL, dst_format | RADEON_ALPHA_BLEND_ENABLE);
    EMIT_WRITE_OFFSET(RADEON_RB3D_COLOROFFSET, 0, pDst);
    EMIT_COLORPITCH(RADEON_RB3D_COLORPITCH, colorpitch, pDst);

    /* IN operator: Multiply src by mask components or mask alpha.
     * BLEND_CTL_ADD is A * B + C.
     * If a source is a8, we have to explicitly zero its color values.
     * If the destination is a8, we have to route the alpha to red, I think.
     * If we're doing component alpha where the source for blending is going to
     * be the source alpha (and there's no source value used), we have to zero
     * the source's color values.
     */
    cblend = RADEON_BLEND_CTL_ADD | RADEON_CLAMP_TX | RADEON_COLOR_ARG_C_ZERO;
    ablend = RADEON_BLEND_CTL_ADD | RADEON_CLAMP_TX | RADEON_ALPHA_ARG_C_ZERO;

    if (pDstPicture->format == PICT_a8 ||
	(pMask && pMaskPicture->componentAlpha && RadeonBlendOp[op].src_alpha))
    {
	cblend |= RADEON_COLOR_ARG_A_T0_ALPHA;
    } else if (pSrcPicture->format == PICT_a8)
	cblend |= RADEON_COLOR_ARG_A_ZERO;
    else
	cblend |= RADEON_COLOR_ARG_A_T0_COLOR;
    ablend |= RADEON_ALPHA_ARG_A_T0_ALPHA;

    if (pMask) {
	if (pMaskPicture->componentAlpha &&
	    pDstPicture->format != PICT_a8)
	    cblend |= RADEON_COLOR_ARG_B_T1_COLOR;
	else
	    cblend |= RADEON_COLOR_ARG_B_T1_ALPHA;
	ablend |= RADEON_ALPHA_ARG_B_T1_ALPHA;
    } else {
	cblend |= RADEON_COLOR_ARG_B_ZERO | RADEON_COMP_ARG_B;
	ablend |= RADEON_ALPHA_ARG_B_ZERO | RADEON_COMP_ARG_B;
    }

    OUT_RING_REG(RADEON_PP_TXCBLEND_0, cblend);
    OUT_RING_REG(RADEON_PP_TXABLEND_0, ablend);
    if (pMask)
	OUT_RING_REG(RADEON_SE_VTX_FMT, (RADEON_SE_VTX_FMT_XY |
					  RADEON_SE_VTX_FMT_ST0 |
					  RADEON_SE_VTX_FMT_ST1));
    else
	OUT_RING_REG(RADEON_SE_VTX_FMT, (RADEON_SE_VTX_FMT_XY |
					  RADEON_SE_VTX_FMT_ST0));
    /* Op operator. */
    blendcntl = RADEONGetBlendCntl(op, pMaskPicture, pDstPicture->format);

    OUT_RING_REG(RADEON_RB3D_BLENDCNTL, blendcntl);

    OUT_RING_REG(RADEON_RE_TOP_LEFT, 0);
    OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, (((pDst->drawable.width - 1) << RADEON_RE_WIDTH_SHIFT) |
					   ((pDst->drawable.height - 1) << RADEON_RE_HEIGHT_SHIFT)));
    ADVANCE_RING();

    return TRUE;
}

static Bool R200CheckCompositeTexture(PicturePtr pPict,
				      PicturePtr pDstPict,
				      int op,
				      int unit)
{
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    int i;

    for (i = 0; i < sizeof(R200TexFormats) / sizeof(R200TexFormats[0]); i++)
    {
	if (R200TexFormats[i].fmt == pPict->format)
	    break;
    }
    if (i == sizeof(R200TexFormats) / sizeof(R200TexFormats[0]))
	RADEON_FALLBACK(("Unsupported picture format 0x%x\n",
			 (int)pPict->format));

    if (pPict->pDrawable && !RADEONCheckTexturePOT(pPict, unit == 0))
	return FALSE;

    if (pPict->filter != PictFilterNearest &&
	pPict->filter != PictFilterBilinear)
	RADEON_FALLBACK(("Unsupported filter 0x%x\n", pPict->filter));

    /* for REPEAT_NONE, Render semantics are that sampling outside the source
     * picture results in alpha=0 pixels. We can implement this with a border color
     * *if* our source texture has an alpha channel, otherwise we need to fall
     * back. If we're not transformed then we hope that upper layers have clipped
     * rendering to the bounds of the source drawable, in which case it doesn't
     * matter. I have not, however, verified that the X server always does such
     * clipping.
     */
    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
    }

    if (!radeon_transform_is_affine_or_scaled(pPict->transform))
	RADEON_FALLBACK(("non-affine transforms not supported\n"));

    return TRUE;
}

static Bool R200TextureSetup(PicturePtr pPict, PixmapPtr pPix,
					int unit)
{
    RINFO_FROM_SCREEN(pPix->drawable.pScreen);
    uint32_t txfilter, txformat, txoffset, txpitch;
    unsigned int repeatType;
    Bool repeat;
    int i, w, h;
    struct radeon_exa_pixmap_priv *driver_priv;

    if (pPict->pDrawable) {
	w = pPict->pDrawable->width;
	h = pPict->pDrawable->height;
	repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    } else {
	w = h = 1;
	repeatType = RepeatNormal;
    }

    repeat = (repeatType == RepeatNormal || repeatType == RepeatReflect) &&
	!(unit == 0 && (info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y));

    txpitch = exaGetPixmapPitch(pPix);

    txoffset = 0;

    if ((txpitch & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));

    for (i = 0; i < sizeof(R200TexFormats) / sizeof(R200TexFormats[0]); i++)
    {
	if (R200TexFormats[i].fmt == pPict->format)
	    break;
    }
    txformat = R200TexFormats[i].card_fmt;
    if (RADEONPixmapIsColortiled(pPix))
	txoffset |= R200_TXO_MACRO_TILE;

    if (repeat) {
	if (!RADEONPitchMatches(pPix))
	    RADEON_FALLBACK(("Width %d and pitch %u not compatible for repeat\n",
			     w, (unsigned)txpitch));

	txformat |= RADEONLog2(w) << R200_TXFORMAT_WIDTH_SHIFT;
	txformat |= RADEONLog2(h) << R200_TXFORMAT_HEIGHT_SHIFT;
    } else
	txformat |= R200_TXFORMAT_NON_POWER2;
    txformat |= unit << R200_TXFORMAT_ST_ROUTE_SHIFT;

    info->accel_state->texW[unit] = w;
    info->accel_state->texH[unit] = h;

    switch (pPict->filter) {
    case PictFilterNearest:
	txfilter = (R200_MAG_FILTER_NEAREST |
		    R200_MIN_FILTER_NEAREST);
	break;
    case PictFilterBilinear:
	txfilter = (R200_MAG_FILTER_LINEAR |
		    R200_MIN_FILTER_LINEAR);
	break;
    default:
	RADEON_FALLBACK(("Bad filter 0x%x\n", pPict->filter));
    }

    switch (repeatType) {
	case RepeatNormal:
	    if (txformat & R200_TXFORMAT_NON_POWER2)
		txfilter |= R200_CLAMP_S_CLAMP_LAST | R200_CLAMP_T_CLAMP_LAST;
	    else
	        txfilter |= R200_CLAMP_S_WRAP | R200_CLAMP_T_WRAP;
	    break;
	case RepeatPad:
	    txfilter |= R200_CLAMP_S_CLAMP_LAST | R200_CLAMP_T_CLAMP_LAST;
	    break;
	case RepeatReflect:
	    txfilter |= R200_CLAMP_S_MIRROR | R200_CLAMP_T_MIRROR;
	    break;
	case RepeatNone:
	    /* don't set an illegal clamp mode for rect textures */
	    if (txformat & R200_TXFORMAT_NON_POWER2)
		txfilter |= R200_CLAMP_S_CLAMP_LAST | R200_CLAMP_T_CLAMP_LAST;
	    break;
    }

    BEGIN_ACCEL_RELOC(6, 1);
    if (unit == 0) {
	OUT_RING_REG(R200_PP_TXFILTER_0, txfilter);
	OUT_RING_REG(R200_PP_TXFORMAT_0, txformat);
	OUT_RING_REG(R200_PP_TXFORMAT_X_0, 0);
	OUT_RING_REG(R200_PP_TXSIZE_0, (pPix->drawable.width - 1) |
		      ((pPix->drawable.height - 1) << RADEON_TEX_VSIZE_SHIFT));
	OUT_RING_REG(R200_PP_TXPITCH_0, txpitch - 32);
	EMIT_READ_OFFSET(R200_PP_TXOFFSET_0, txoffset, pPix);
    } else {
	OUT_RING_REG(R200_PP_TXFILTER_1, txfilter);
	OUT_RING_REG(R200_PP_TXFORMAT_1, txformat);
	OUT_RING_REG(R200_PP_TXFORMAT_X_1, 0);
	OUT_RING_REG(R200_PP_TXSIZE_1, (pPix->drawable.width - 1) |
		      ((pPix->drawable.height - 1) << RADEON_TEX_VSIZE_SHIFT));
	OUT_RING_REG(R200_PP_TXPITCH_1, txpitch - 32);
	EMIT_READ_OFFSET(R200_PP_TXOFFSET_1, txoffset, pPix);
	/* emit a texture relocation */
    }
    ADVANCE_RING();

    if (pPict->transform != 0) {
	info->accel_state->is_transform[unit] = TRUE;
	info->accel_state->transform[unit] = pPict->transform;
    } else {
	info->accel_state->is_transform[unit] = FALSE;
    }

    return TRUE;
}

static Bool R200CheckComposite(int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
			       PicturePtr pDstPicture)
{
    PixmapPtr pSrcPixmap, pDstPixmap;
    uint32_t tmp1;

    TRACE;

    /* Check for unsupported compositing operations. */
    if (op >= sizeof(RadeonBlendOp) / sizeof(RadeonBlendOp[0]))
	RADEON_FALLBACK(("Unsupported Composite op 0x%x\n", op));

    pDstPixmap = RADEONGetDrawablePixmap(pDstPicture->pDrawable);

    if (pDstPixmap->drawable.width > 2048 ||
	pDstPixmap->drawable.height > 2048) {
	RADEON_FALLBACK(("Dest w/h too large (%d,%d).\n",
			 pDstPixmap->drawable.width,
			 pDstPixmap->drawable.height));
    }

    if (pSrcPicture->pDrawable) {
	/* r200 limit should be 2048, there are issues with 2048
	 * see 197a62704742a4a19736c2637ac92d1dc5ab34ed
	 */
	pSrcPixmap = RADEONGetDrawablePixmap(pSrcPicture->pDrawable);

	if (pSrcPixmap->drawable.width > 2048 ||
	    pSrcPixmap->drawable.height > 2048) {
	    RADEON_FALLBACK(("Source w/h too large (%d,%d).\n",
			     pSrcPixmap->drawable.width,
			     pSrcPixmap->drawable.height));
	}
    } else if (pSrcPicture->pSourcePict->type != SourcePictTypeSolidFill)
	RADEON_FALLBACK(("Gradient pictures not supported yet\n"));

    if (pMaskPicture) {
	PixmapPtr pMaskPixmap;

	if (pMaskPicture->pDrawable) {
	    pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);

	    if (pMaskPixmap->drawable.width > 2048 ||
		pMaskPixmap->drawable.height > 2048) {
		RADEON_FALLBACK(("Mask w/h too large (%d,%d).\n",
				 pMaskPixmap->drawable.width,
				 pMaskPixmap->drawable.height));
	    }
	} else if (pMaskPicture->pSourcePict->type != SourcePictTypeSolidFill)
	    RADEON_FALLBACK(("Gradient pictures not supported yet\n"));

	if (pMaskPicture->componentAlpha) {
	    /* Check if it's component alpha that relies on a source alpha and
	     * on the source value.  We can only get one of those into the
	     * single source value that we get to blend with.
	     */
	    if (RadeonBlendOp[op].src_alpha &&
		(RadeonBlendOp[op].blend_cntl & RADEON_SRC_BLEND_MASK) !=
		RADEON_SRC_BLEND_GL_ZERO) {
		RADEON_FALLBACK(("Component alpha not supported with source "
				 "alpha and source value blending.\n"));
	    }
	}

	if (!R200CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1))
	    return FALSE;
    }

    if (!R200CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0))
	return FALSE;

    if (!RADEONGetDestFormat(pDstPicture, &tmp1))
	return FALSE;

    return TRUE;
}

static Bool R200PrepareComposite(int op, PicturePtr pSrcPicture,
				PicturePtr pMaskPicture, PicturePtr pDstPicture,
				PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst)
{
    ScreenPtr pScreen = pDst->drawable.pScreen;
    RINFO_FROM_SCREEN(pScreen);
    uint32_t dst_format, dst_pitch;
    uint32_t pp_cntl, blendcntl, cblend, ablend, colorpitch;
    int pixel_shift;
    struct radeon_exa_pixmap_priv *driver_priv;

    TRACE;

    if (!RADEONGetDestFormat(pDstPicture, &dst_format))
	return FALSE;

    if (pDstPicture->format == PICT_a8 && RadeonBlendOp[op].dst_alpha)
	RADEON_FALLBACK(("Can't dst alpha blend A8\n"));

    pixel_shift = pDst->drawable.bitsPerPixel >> 4;

    dst_pitch = exaGetPixmapPitch(pDst);
    colorpitch = dst_pitch >> pixel_shift;
    if (RADEONPixmapIsColortiled(pDst))
	colorpitch |= RADEON_COLOR_TILE_ENABLE;

    if (((dst_pitch >> pixel_shift) & 0x7) != 0)
	RADEON_FALLBACK(("Bad destination pitch 0x%x\n", (int)dst_pitch));

    if (!pSrc) {
	pSrc = RADEONSolidPixmap(pScreen, cpu_to_le32(pSrcPicture->pSourcePict->solidFill.color));
	if (!pSrc)
	    RADEON_FALLBACK(("Failed to create solid scratch pixmap\n"));
    }

    if (!RADEONSetupSourceTile(pSrcPicture, pSrc, FALSE, TRUE))
	return FALSE;

    if (pMaskPicture && !pMask) {
	pMask = RADEONSolidPixmap(pScreen, cpu_to_le32(pMaskPicture->pSourcePict->solidFill.color));
	if (!pMask) {
	    if (!pSrcPicture->pDrawable)
		pScreen->DestroyPixmap(pSrc);
	    RADEON_FALLBACK(("Failed to create solid scratch pixmap\n"));
	}
    }

    RADEONPrepareCompositeCS(op, pSrcPicture, pMaskPicture, pDstPicture,
			     pSrc, pMask, pDst);

    /* switch to 3D after doing buffer space checks as it may flush */
    RADEON_SWITCH_TO_3D();

    if (!R200TextureSetup(pSrcPicture, pSrc, 0))
	return FALSE;
    pp_cntl = RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE;

    if (pMask != NULL) {
	if (!R200TextureSetup(pMaskPicture, pMask, 1))
	    return FALSE;
	pp_cntl |= RADEON_TEX_1_ENABLE;
    } else {
	info->accel_state->is_transform[1] = FALSE;
    }

    BEGIN_ACCEL_RELOC(12, 2);

    OUT_RING_REG(RADEON_PP_CNTL, pp_cntl);
    OUT_RING_REG(RADEON_RB3D_CNTL, dst_format | RADEON_ALPHA_BLEND_ENABLE);

    EMIT_WRITE_OFFSET(RADEON_RB3D_COLOROFFSET, 0, pDst);
    EMIT_COLORPITCH(RADEON_RB3D_COLORPITCH, colorpitch, pDst);

    OUT_RING_REG(R200_SE_VTX_FMT_0, R200_VTX_XY);
    if (pMask)
	OUT_RING_REG(R200_SE_VTX_FMT_1,
		      (2 << R200_VTX_TEX0_COMP_CNT_SHIFT) |
		      (2 << R200_VTX_TEX1_COMP_CNT_SHIFT));
    else
	OUT_RING_REG(R200_SE_VTX_FMT_1,
		      (2 << R200_VTX_TEX0_COMP_CNT_SHIFT));



    /* IN operator: Multiply src by mask components or mask alpha.
     * BLEND_CTL_ADD is A * B + C.
     * If a picture is a8, we have to explicitly zero its color values.
     * If the destination is a8, we have to route the alpha to red, I think.
     * If we're doing component alpha where the source for blending is going to
     * be the source alpha (and there's no source value used), we have to zero
     * the source's color values.
     */
    cblend = R200_TXC_OP_MADD | R200_TXC_ARG_C_ZERO;
    ablend = R200_TXA_OP_MADD | R200_TXA_ARG_C_ZERO;

    if (pDstPicture->format == PICT_a8 ||
	(pMask && pMaskPicture->componentAlpha && RadeonBlendOp[op].src_alpha))
    {
	cblend |= R200_TXC_ARG_A_R0_ALPHA;
    } else if (pSrcPicture->format == PICT_a8)
	cblend |= R200_TXC_ARG_A_ZERO;
    else
	cblend |= R200_TXC_ARG_A_R0_COLOR;
    ablend |= R200_TXA_ARG_A_R0_ALPHA;

    if (pMask) {
	if (pMaskPicture->componentAlpha &&
	    pDstPicture->format != PICT_a8)
	    cblend |= R200_TXC_ARG_B_R1_COLOR;
	else
	    cblend |= R200_TXC_ARG_B_R1_ALPHA;
	ablend |= R200_TXA_ARG_B_R1_ALPHA;
    } else {
	cblend |= R200_TXC_ARG_B_ZERO | R200_TXC_COMP_ARG_B;
	ablend |= R200_TXA_ARG_B_ZERO | R200_TXA_COMP_ARG_B;
    }

    OUT_RING_REG(R200_PP_TXCBLEND_0, cblend);
    OUT_RING_REG(R200_PP_TXCBLEND2_0,
	R200_TXC_CLAMP_0_1 | R200_TXC_OUTPUT_REG_R0);
    OUT_RING_REG(R200_PP_TXABLEND_0, ablend);
    OUT_RING_REG(R200_PP_TXABLEND2_0,
	R200_TXA_CLAMP_0_1 | R200_TXA_OUTPUT_REG_R0);

    /* Op operator. */
    blendcntl = RADEONGetBlendCntl(op, pMaskPicture, pDstPicture->format);
    OUT_RING_REG(RADEON_RB3D_BLENDCNTL, blendcntl);

    OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, (((pDst->drawable.width - 1) << RADEON_RE_WIDTH_SHIFT) |
					   ((pDst->drawable.height - 1) << RADEON_RE_HEIGHT_SHIFT)));

    ADVANCE_RING();

    return TRUE;
}

static Bool R300CheckCompositeTexture(PicturePtr pPict,
				      PicturePtr pDstPict,
				      int op,
				      int unit,
				      Bool is_r500)
{
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    int i;

    for (i = 0; i < sizeof(R300TexFormats) / sizeof(R300TexFormats[0]); i++)
    {
	if (R300TexFormats[i].fmt == pPict->format)
	    break;
    }
    if (i == sizeof(R300TexFormats) / sizeof(R300TexFormats[0]))
	RADEON_FALLBACK(("Unsupported picture format 0x%x\n",
			 (int)pPict->format));

    if (pPict->pDrawable && !RADEONCheckTexturePOT(pPict, unit == 0)) {
#if 0
	      		struct radeon_exa_pixmap_priv *driver_priv;
		PixmapPtr pPix;

    		pPix = RADEONGetDrawablePixmap(pPict->pDrawable);
		driver_priv = exaGetPixmapDriverPrivate(pPix);
		//TODOradeon_bufmgr_gem_force_gtt(driver_priv->bo);
#endif
	return FALSE;
    }

    if (pPict->filter != PictFilterNearest &&
	pPict->filter != PictFilterBilinear)
	RADEON_FALLBACK(("Unsupported filter 0x%x\n", pPict->filter));

    /* for REPEAT_NONE, Render semantics are that sampling outside the source
     * picture results in alpha=0 pixels. We can implement this with a border color
     * *if* our source texture has an alpha channel, otherwise we need to fall
     * back. If we're not transformed then we hope that upper layers have clipped
     * rendering to the bounds of the source drawable, in which case it doesn't
     * matter. I have not, however, verified that the X server always does such
     * clipping.
     */
    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
    }

    if (!radeon_transform_is_affine_or_scaled(pPict->transform))
	RADEON_FALLBACK(("non-affine transforms not supported\n"));

    return TRUE;
}

static Bool R300TextureSetup(PicturePtr pPict, PixmapPtr pPix,
					int unit)
{
    RINFO_FROM_SCREEN(pPix->drawable.pScreen);
    uint32_t txfilter, txformat0, txformat1, txoffset, txpitch, us_format = 0;
    int w, h;
    int i, pixel_shift, out_size = 6;
    unsigned int repeatType;
    struct radeon_exa_pixmap_priv *driver_priv;

    TRACE;

    if (pPict->pDrawable) {
	w = pPict->pDrawable->width;
	h = pPict->pDrawable->height;
	repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    } else {
	w = h = 1;
	repeatType = RepeatNormal;
    }

    txpitch = exaGetPixmapPitch(pPix);
    txoffset = 0;

    if ((txpitch & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));

    /* TXPITCH = pixels (texels) per line - 1 */
    pixel_shift = pPix->drawable.bitsPerPixel >> 4;
    txpitch >>= pixel_shift;
    txpitch -= 1;

    if (RADEONPixmapIsColortiled(pPix))
	txoffset |= R300_MACRO_TILE;

    for (i = 0; i < sizeof(R300TexFormats) / sizeof(R300TexFormats[0]); i++)
    {
	if (R300TexFormats[i].fmt == pPict->format)
	    break;
    }

    txformat1 = R300TexFormats[i].card_fmt;

    if (IS_R300_3D) {
	if ((unit == 0) && info->accel_state->msk_pic)
	    txformat1 |= R300_TX_FORMAT_CACHE_HALF_REGION_0;
	else if (unit == 1)
	    txformat1 |= R300_TX_FORMAT_CACHE_HALF_REGION_1;
    }

    txformat0 = ((((w - 1) & 0x7ff) << R300_TXWIDTH_SHIFT) |
		 (((h - 1) & 0x7ff) << R300_TXHEIGHT_SHIFT));

    if (IS_R500_3D && ((w - 1) & 0x800))
	txpitch |= R500_TXWIDTH_11;

    if (IS_R500_3D && ((h - 1) & 0x800))
	txpitch |= R500_TXHEIGHT_11;

    if (info->ChipFamily == CHIP_FAMILY_R520) {
	unsigned us_width = (w - 1) & 0x7ff;
	unsigned us_height = (h - 1) & 0x7ff;
	unsigned us_depth = 0;

	if (w > 2048) {
	    us_width = (0x7ff + us_width) >> 1;
	    us_depth |= 0x0d;
	}
	if (h > 2048) {
	    us_height = (0x7ff + us_height) >> 1;
	    us_depth |= 0x0e;
	}

	us_format = (us_width << R300_TXWIDTH_SHIFT) |
		    (us_height << R300_TXHEIGHT_SHIFT) |
		    (us_depth << R300_TXDEPTH_SHIFT);
	out_size++;
    }

    /* Use TXPITCH instead of TXWIDTH for address computations: we could
     * omit this if there is no padding, but there is no apparent advantage
     * in doing so.
     */
    txformat0 |= R300_TXPITCH_EN;

    txfilter = (unit << R300_TX_ID_SHIFT);

    switch (repeatType) {
    case RepeatNormal:
	if (unit != 0 || !info->accel_state->need_src_tile_x)
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP);
	else
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL);
	
	if (unit != 0 || !info->accel_state->need_src_tile_y)
	    txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP);
	else
	    txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);

	break;
    case RepeatPad:
	txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_LAST) |
	    R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_LAST);
	break;
    case RepeatReflect:
	txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_MIRROR) |
	    R300_TX_CLAMP_T(R300_TX_CLAMP_MIRROR);
	break;
    case RepeatNone:
	txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL) |
	    R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
	break;
    }

    switch (pPict->filter) {
    case PictFilterNearest:
	txfilter |= (R300_TX_MAG_FILTER_NEAREST | R300_TX_MIN_FILTER_NEAREST);
	break;
    case PictFilterBilinear:
	txfilter |= (R300_TX_MAG_FILTER_LINEAR | R300_TX_MIN_FILTER_LINEAR);
	break;
    default:
	RADEON_FALLBACK(("Bad filter 0x%x\n", pPict->filter));
    }

    if (repeatType == RepeatNone)
	out_size++;
    BEGIN_ACCEL_RELOC(out_size, 1);
    OUT_RING_REG(R300_TX_FILTER0_0 + (unit * 4), txfilter);
    OUT_RING_REG(R300_TX_FILTER1_0 + (unit * 4), 0);
    OUT_RING_REG(R300_TX_FORMAT0_0 + (unit * 4), txformat0);
    OUT_RING_REG(R300_TX_FORMAT1_0 + (unit * 4), txformat1);
    OUT_RING_REG(R300_TX_FORMAT2_0 + (unit * 4), txpitch);

    EMIT_READ_OFFSET((R300_TX_OFFSET_0 + (unit * 4)), txoffset, pPix);

    if (repeatType == RepeatNone)
	OUT_RING_REG(R300_TX_BORDER_COLOR_0 + (unit * 4), 0);
    if (info->ChipFamily == CHIP_FAMILY_R520)
	OUT_RING_REG(R500_US_FORMAT0_0 + (unit * 4), us_format);
    ADVANCE_RING();

    if (pPict->transform != 0) {
	info->accel_state->is_transform[unit] = TRUE;
	info->accel_state->transform[unit] = pPict->transform;

	/* setup the PVS consts */
	if (info->accel_state->has_tcl) {
	    info->accel_state->texW[unit] = 1;
	    info->accel_state->texH[unit] = 1;
	    BEGIN_RING(2*9);
	    if (IS_R300_3D)
		OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_CONST_INDEX(unit * 2));
	    else
		OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R500_PVS_VECTOR_CONST_INDEX(unit * 2));

	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][0])));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][1])));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][2])));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/w));

	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][0])));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][1])));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][2])));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/h));

	    ADVANCE_RING();
	} else {
	    info->accel_state->texW[unit] = w;
	    info->accel_state->texH[unit] = h;
	}
    } else {
	info->accel_state->is_transform[unit] = FALSE;

	/* setup the PVS consts */
	if (info->accel_state->has_tcl) {
	    info->accel_state->texW[unit] = 1;
	    info->accel_state->texH[unit] = 1;

	    BEGIN_RING(2*9);
	    if (IS_R300_3D)
		OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_CONST_INDEX(unit * 2));
	    else
		OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R500_PVS_VECTOR_CONST_INDEX(unit * 2));

	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/w));

	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/h));

	    ADVANCE_RING();
	} else {
	    info->accel_state->texW[unit] = w;
	    info->accel_state->texH[unit] = h;
	}
    }

    return TRUE;
}

static Bool R300CheckComposite(int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
			       PicturePtr pDstPicture)
{
    uint32_t tmp1;
    ScreenPtr pScreen = pDstPicture->pDrawable->pScreen;
    PixmapPtr pSrcPixmap, pDstPixmap;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);
    int max_tex_w, max_tex_h, max_dst_w, max_dst_h;

    TRACE;

    /* Check for unsupported compositing operations. */
    if (op >= sizeof(RadeonBlendOp) / sizeof(RadeonBlendOp[0]))
	RADEON_FALLBACK(("Unsupported Composite op 0x%x\n", op));

    if (IS_R500_3D) {
	max_tex_w = 4096;
	max_tex_h = 4096;
	max_dst_w = 4096;
	max_dst_h = 4096;
    } else {
	max_tex_w = 2048;
	max_tex_h = 2048;
	if (IS_R400_3D) {
	    max_dst_w = 4021;
	    max_dst_h = 4021;
	} else {
	    max_dst_w = 2560;
	    max_dst_h = 2560;
	}
    }

    pDstPixmap = RADEONGetDrawablePixmap(pDstPicture->pDrawable);

    if (pDstPixmap->drawable.width > max_dst_w ||
	pDstPixmap->drawable.height > max_dst_h) {
	RADEON_FALLBACK(("Dest w/h too large (%d,%d).\n",
			 pDstPixmap->drawable.width,
			 pDstPixmap->drawable.height));
    }

    if (pSrcPicture->pDrawable) {
	pSrcPixmap = RADEONGetDrawablePixmap(pSrcPicture->pDrawable);

	if (pSrcPixmap->drawable.width > max_tex_w ||
	    pSrcPixmap->drawable.height > max_tex_h) {
	    RADEON_FALLBACK(("Source w/h too large (%d,%d).\n",
			     pSrcPixmap->drawable.width,
			     pSrcPixmap->drawable.height));
	}
    } else if (pSrcPicture->pSourcePict->type != SourcePictTypeSolidFill)
	RADEON_FALLBACK(("Gradient pictures not supported yet\n"));

    if (pMaskPicture) {
	PixmapPtr pMaskPixmap;

	if (pMaskPicture->pDrawable) {
	    pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);

	    if (pMaskPixmap->drawable.width > max_tex_w ||
		pMaskPixmap->drawable.height > max_tex_h) {
	      RADEON_FALLBACK(("Mask w/h too large (%d,%d).\n",
			       pMaskPixmap->drawable.width,
			       pMaskPixmap->drawable.height));
	    }
	} else if (pMaskPicture->pSourcePict->type != SourcePictTypeSolidFill)
	    RADEON_FALLBACK(("Gradient pictures not supported yet\n"));

	if (pMaskPicture->componentAlpha) {
	    /* Check if it's component alpha that relies on a source alpha and
	     * on the source value.  We can only get one of those into the
	     * single source value that we get to blend with.
	     */
	    if (RadeonBlendOp[op].src_alpha &&
		(RadeonBlendOp[op].blend_cntl & RADEON_SRC_BLEND_MASK) !=
		RADEON_SRC_BLEND_GL_ZERO) {
		RADEON_FALLBACK(("Component alpha not supported with source "
				 "alpha and source value blending.\n"));
	    }
	}

	if (!R300CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1, IS_R500_3D))
	    return FALSE;
    }

    if (!R300CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0, IS_R500_3D))
	return FALSE;

    if (!R300GetDestFormat(pDstPicture, &tmp1))
	return FALSE;

    return TRUE;

}

static Bool R300PrepareComposite(int op, PicturePtr pSrcPicture,
				PicturePtr pMaskPicture, PicturePtr pDstPicture,
				PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst)
{
    ScreenPtr pScreen = pDst->drawable.pScreen;
    RINFO_FROM_SCREEN(pScreen);
    uint32_t dst_format, dst_pitch;
    uint32_t txenable, colorpitch;
    uint32_t blendcntl, output_fmt;
    uint32_t src_color, src_alpha;
    uint32_t mask_color, mask_alpha;
    int pixel_shift;
    struct radeon_exa_pixmap_priv *driver_priv;
    TRACE;

    if (!R300GetDestFormat(pDstPicture, &dst_format))
	return FALSE;

    pixel_shift = pDst->drawable.bitsPerPixel >> 4;

    dst_pitch = exaGetPixmapPitch(pDst);
    colorpitch = dst_pitch >> pixel_shift;

    if (RADEONPixmapIsColortiled(pDst))
	colorpitch |= R300_COLORTILE;

    colorpitch |= dst_format;

    if (((dst_pitch >> pixel_shift) & 0x7) != 0)
	RADEON_FALLBACK(("Bad destination pitch 0x%x\n", (int)dst_pitch));

    if (!pSrc) {
	pSrc = RADEONSolidPixmap(pScreen, cpu_to_le32(pSrcPicture->pSourcePict->solidFill.color));
	if (!pSrc)
	    RADEON_FALLBACK(("Failed to create solid scratch pixmap\n"));
    }

    if (!RADEONSetupSourceTile(pSrcPicture, pSrc, TRUE, FALSE))
	return FALSE;

    if (pMaskPicture && !pMask) {
	pMask = RADEONSolidPixmap(pScreen, cpu_to_le32(pMaskPicture->pSourcePict->solidFill.color));
	if (!pMask) {
	    if (!pSrcPicture->pDrawable)
		pScreen->DestroyPixmap(pSrc);
	    RADEON_FALLBACK(("Failed to create solid scratch pixmap\n"));
	}
    }

    RADEONPrepareCompositeCS(op, pSrcPicture, pMaskPicture, pDstPicture,
			     pSrc, pMask, pDst);

    /* have to execute switch after doing buffer sizing check as the latter flushes */
    RADEON_SWITCH_TO_3D();

    if (!R300TextureSetup(pSrcPicture, pSrc, 0))
	return FALSE;
    txenable = R300_TEX_0_ENABLE;

    if (pMask != NULL) {
	if (!R300TextureSetup(pMaskPicture, pMask, 1))
	    return FALSE;
	txenable |= R300_TEX_1_ENABLE;
    } else {
	info->accel_state->is_transform[1] = FALSE;
    }

    /* setup the VAP */
    if (info->accel_state->has_tcl) {
	if (pMask)
	    BEGIN_RING(2*10);
	else
	    BEGIN_RING(2*9);
	OUT_RING_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0);
    } else {
	if (pMask)
	    BEGIN_RING(2*6);
	else
	    BEGIN_RING(2*5);
    }

    /* These registers define the number, type, and location of data submitted
     * to the PVS unit of GA input (when PVS is disabled)
     * DST_VEC_LOC is the slot in the PVS input vector memory when PVS/TCL is
     * enabled.  This memory provides the imputs to the vertex shader program
     * and ordering is not important.  When PVS/TCL is disabled, this field maps
     * directly to the GA input memory and the order is signifigant.  In
     * PVS_BYPASS mode the order is as follows:
     * Position
     * Point Size
     * Color 0-3
     * Textures 0-7
     * Fog
     */
    if (pMask) {
	OUT_RING_REG(R300_VAP_PROG_STREAM_CNTL_0,
		      ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_0_SHIFT) |
		       (0 << R300_SKIP_DWORDS_0_SHIFT) |
		       (0 << R300_DST_VEC_LOC_0_SHIFT) |
		       R300_SIGNED_0 |
		       (R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_1_SHIFT) |
		       (0 << R300_SKIP_DWORDS_1_SHIFT) |
		       (6 << R300_DST_VEC_LOC_1_SHIFT) |
		       R300_SIGNED_1));
	OUT_RING_REG(R300_VAP_PROG_STREAM_CNTL_1,
		      ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_2_SHIFT) |
		       (0 << R300_SKIP_DWORDS_2_SHIFT) |
		       (7 << R300_DST_VEC_LOC_2_SHIFT) |
		       R300_LAST_VEC_2 |
		       R300_SIGNED_2));
    } else
	OUT_RING_REG(R300_VAP_PROG_STREAM_CNTL_0,
		      ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_0_SHIFT) |
		       (0 << R300_SKIP_DWORDS_0_SHIFT) |
		       (0 << R300_DST_VEC_LOC_0_SHIFT) |
		       R300_SIGNED_0 |
		       (R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_1_SHIFT) |
		       (0 << R300_SKIP_DWORDS_1_SHIFT) |
		       (6 << R300_DST_VEC_LOC_1_SHIFT) |
		       R300_LAST_VEC_1 |
		       R300_SIGNED_1));

    /* load the vertex shader
     * We pre-load vertex programs in RADEONInit3DEngine():
     * - exa
     * - Xv
     * - Xv bicubic
     * Here we select the offset of the vertex program we want to use
     */
    if (info->accel_state->has_tcl) {
	if (pMask) {
	    /* consts used by vertex shaders */
	    OUT_RING_REG(R300_VAP_PVS_CONST_CNTL, (R300_PVS_CONST_BASE_OFFSET(0) |
						    R300_PVS_MAX_CONST_ADDR(3)));
	    OUT_RING_REG(R300_VAP_PVS_CODE_CNTL_0,
			  ((0 << R300_PVS_FIRST_INST_SHIFT) |
			   (8 << R300_PVS_XYZW_VALID_INST_SHIFT) |
			   (8 << R300_PVS_LAST_INST_SHIFT)));
	    OUT_RING_REG(R300_VAP_PVS_CODE_CNTL_1,
			  (8 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
	} else {
	    /* consts used by vertex shaders */
	    OUT_RING_REG(R300_VAP_PVS_CONST_CNTL, (R300_PVS_CONST_BASE_OFFSET(0) |
						    R300_PVS_MAX_CONST_ADDR(3)));
	    OUT_RING_REG(R300_VAP_PVS_CODE_CNTL_0,
			  ((0 << R300_PVS_FIRST_INST_SHIFT) |
			   (4 << R300_PVS_XYZW_VALID_INST_SHIFT) |
			   (4 << R300_PVS_LAST_INST_SHIFT)));
	    OUT_RING_REG(R300_VAP_PVS_CODE_CNTL_1,
			  (4 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
	}
    }

    /* Position and one or two sets of 2 texture coordinates */
    OUT_RING_REG(R300_VAP_OUT_VTX_FMT_0, R300_VTX_POS_PRESENT);
    if (pMask)
	OUT_RING_REG(R300_VAP_OUT_VTX_FMT_1,
		      ((2 << R300_TEX_0_COMP_CNT_SHIFT) |
		       (2 << R300_TEX_1_COMP_CNT_SHIFT)));
    else
	OUT_RING_REG(R300_VAP_OUT_VTX_FMT_1,
		      (2 << R300_TEX_0_COMP_CNT_SHIFT));

    OUT_RING_REG(R300_TX_INVALTAGS, 0x0);
    OUT_RING_REG(R300_TX_ENABLE, txenable);
    ADVANCE_RING();

    /* shader output swizzling */
    switch (pDstPicture->format) {
    case PICT_a8r8g8b8:
    case PICT_x8r8g8b8:
    default:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_BLUE |
		      R300_OUT_FMT_C1_SEL_GREEN |
		      R300_OUT_FMT_C2_SEL_RED |
		      R300_OUT_FMT_C3_SEL_ALPHA);
	break;
    case PICT_a8b8g8r8:
    case PICT_x8b8g8r8:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_RED |
		      R300_OUT_FMT_C1_SEL_GREEN |
		      R300_OUT_FMT_C2_SEL_BLUE |
		      R300_OUT_FMT_C3_SEL_ALPHA);
	break;
    case PICT_b8g8r8a8:
    case PICT_b8g8r8x8:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_ALPHA |
		      R300_OUT_FMT_C1_SEL_RED |
		      R300_OUT_FMT_C2_SEL_GREEN |
		      R300_OUT_FMT_C3_SEL_BLUE);
	break;
    case PICT_a8:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_ALPHA);
	break;
    }

    /* setup pixel shader */
    if (IS_R300_3D) {
	if (PICT_FORMAT_RGB(pSrcPicture->format) == 0)
	    src_color = R300_ALU_RGB_0_0;
	else
	    src_color = R300_ALU_RGB_SRC0_RGB;

	if (PICT_FORMAT_A(pSrcPicture->format) == 0)
	    src_alpha = R300_ALU_ALPHA_1_0;
	else
	    src_alpha = R300_ALU_ALPHA_SRC0_A;

	if (pMask) {
	    if (pMaskPicture->componentAlpha) {
		if (RadeonBlendOp[op].src_alpha) {
		    if (PICT_FORMAT_A(pSrcPicture->format) == 0)
			src_color = R300_ALU_RGB_1_0;
		    else
			src_color = R300_ALU_RGB_SRC0_AAA;
		} else
		    src_color = R300_ALU_RGB_SRC0_RGB;
		mask_color = R300_ALU_RGB_SRC1_RGB;
	    } else {
		if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		    mask_color = R300_ALU_RGB_1_0;
		else
		    mask_color = R300_ALU_RGB_SRC1_AAA;
	    }
	    if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		mask_alpha = R300_ALU_ALPHA_1_0;
	    else
		mask_alpha = R300_ALU_ALPHA_SRC1_A;
	} else {
	    mask_color = R300_ALU_RGB_1_0;
	    mask_alpha = R300_ALU_ALPHA_1_0;
	}

	/* setup the rasterizer, load FS */
	if (pMask) {
	    BEGIN_RING(2*16);
	    /* 4 components: 2 for tex0, 2 for tex1 */
	    OUT_RING_REG(R300_RS_COUNT,
			  ((4 << R300_RS_COUNT_IT_COUNT_SHIFT) |
			   R300_RS_COUNT_HIRES_EN));

	    /* R300_INST_COUNT_RS - highest RS instruction used */
	    OUT_RING_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1));

	    OUT_RING_REG(R300_US_CODE_OFFSET, (R300_ALU_CODE_OFFSET(0) |
						R300_ALU_CODE_SIZE(0) |
						R300_TEX_CODE_OFFSET(0) |
						R300_TEX_CODE_SIZE(1)));

	    OUT_RING_REG(R300_US_CODE_ADDR_3,
			  (R300_ALU_START(0) |
			   R300_ALU_SIZE(0) |
			   R300_TEX_START(0) |
			   R300_TEX_SIZE(1) |
			   R300_RGBA_OUT));


	} else {
	    BEGIN_RING(2*15);
	    /* 2 components: 2 for tex0 */
	    OUT_RING_REG(R300_RS_COUNT,
			  ((2 << R300_RS_COUNT_IT_COUNT_SHIFT) |
			   R300_RS_COUNT_HIRES_EN));

	    OUT_RING_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0));

	    OUT_RING_REG(R300_US_CODE_OFFSET, (R300_ALU_CODE_OFFSET(0) |
						R300_ALU_CODE_SIZE(0) |
						R300_TEX_CODE_OFFSET(0) |
						R300_TEX_CODE_SIZE(0)));

	    OUT_RING_REG(R300_US_CODE_ADDR_3,
			  (R300_ALU_START(0) |
			   R300_ALU_SIZE(0) |
			   R300_TEX_START(0) |
			   R300_TEX_SIZE(0) |
			   R300_RGBA_OUT));

	}

	OUT_RING_REG(R300_US_CONFIG, (0 << R300_NLEVEL_SHIFT) | R300_FIRST_TEX);
	OUT_RING_REG(R300_US_CODE_ADDR_0,
		      (R300_ALU_START(0) |
		       R300_ALU_SIZE(0) |
		       R300_TEX_START(0) |
		       R300_TEX_SIZE(0)));
	OUT_RING_REG(R300_US_CODE_ADDR_1,
		      (R300_ALU_START(0) |
		       R300_ALU_SIZE(0) |
		       R300_TEX_START(0) |
		       R300_TEX_SIZE(0)));
	OUT_RING_REG(R300_US_CODE_ADDR_2,
		      (R300_ALU_START(0) |
		       R300_ALU_SIZE(0) |
		       R300_TEX_START(0) |
		       R300_TEX_SIZE(0)));

	OUT_RING_REG(R300_US_PIXSIZE, 1); /* highest temp used */
	/* shader output swizzling */
	OUT_RING_REG(R300_US_OUT_FMT_0, output_fmt);

	/* tex inst for src texture */
	OUT_RING_REG(R300_US_TEX_INST(0),
		      (R300_TEX_SRC_ADDR(0) |
		       R300_TEX_DST_ADDR(0) |
		       R300_TEX_ID(0) |
		       R300_TEX_INST(R300_TEX_INST_LD)));

	if (pMask) {
	    /* tex inst for mask texture */
	    OUT_RING_REG(R300_US_TEX_INST(1),
			  (R300_TEX_SRC_ADDR(1) |
			   R300_TEX_DST_ADDR(1) |
			   R300_TEX_ID(1) |
			   R300_TEX_INST(R300_TEX_INST_LD)));
	}

	/* RGB inst
	 * temp addresses for texture inputs
	 * ALU_RGB_ADDR0 is src tex (temp 0)
	 * ALU_RGB_ADDR1 is mask tex (temp 1)
	 * R300_ALU_RGB_OMASK - output components to write
	 * R300_ALU_RGB_TARGET_A - render target
	 */
	OUT_RING_REG(R300_US_ALU_RGB_ADDR(0),
		      (R300_ALU_RGB_ADDR0(0) |
		       R300_ALU_RGB_ADDR1(1) |
		       R300_ALU_RGB_ADDR2(0) |
		       R300_ALU_RGB_ADDRD(0) |
		       R300_ALU_RGB_OMASK((R300_ALU_RGB_MASK_R |
					   R300_ALU_RGB_MASK_G |
					   R300_ALU_RGB_MASK_B)) |
		       R300_ALU_RGB_TARGET_A));
	/* RGB inst
	 * ALU operation
	 */
	OUT_RING_REG(R300_US_ALU_RGB_INST(0),
		      (R300_ALU_RGB_SEL_A(src_color) |
		       R300_ALU_RGB_MOD_A(R300_ALU_RGB_MOD_NOP) |
		       R300_ALU_RGB_SEL_B(mask_color) |
		       R300_ALU_RGB_MOD_B(R300_ALU_RGB_MOD_NOP) |
		       R300_ALU_RGB_SEL_C(R300_ALU_RGB_0_0) |
		       R300_ALU_RGB_MOD_C(R300_ALU_RGB_MOD_NOP) |
		       R300_ALU_RGB_OP(R300_ALU_RGB_OP_MAD) |
		       R300_ALU_RGB_OMOD(R300_ALU_RGB_OMOD_NONE) |
		       R300_ALU_RGB_CLAMP));
	/* Alpha inst
	 * temp addresses for texture inputs
	 * ALU_ALPHA_ADDR0 is src tex (0)
	 * ALU_ALPHA_ADDR1 is mask tex (1)
	 * R300_ALU_ALPHA_OMASK - output components to write
	 * R300_ALU_ALPHA_TARGET_A - render target
	 */
	OUT_RING_REG(R300_US_ALU_ALPHA_ADDR(0),
		      (R300_ALU_ALPHA_ADDR0(0) |
		       R300_ALU_ALPHA_ADDR1(1) |
		       R300_ALU_ALPHA_ADDR2(0) |
		       R300_ALU_ALPHA_ADDRD(0) |
		       R300_ALU_ALPHA_OMASK(R300_ALU_ALPHA_MASK_A) |
		       R300_ALU_ALPHA_TARGET_A |
		       R300_ALU_ALPHA_OMASK_W(R300_ALU_ALPHA_MASK_NONE)));
	/* Alpha inst
	 * ALU operation
	 */
	OUT_RING_REG(R300_US_ALU_ALPHA_INST(0),
		      (R300_ALU_ALPHA_SEL_A(src_alpha) |
		       R300_ALU_ALPHA_MOD_A(R300_ALU_ALPHA_MOD_NOP) |
		       R300_ALU_ALPHA_SEL_B(mask_alpha) |
		       R300_ALU_ALPHA_MOD_B(R300_ALU_ALPHA_MOD_NOP) |
		       R300_ALU_ALPHA_SEL_C(R300_ALU_ALPHA_0_0) |
		       R300_ALU_ALPHA_MOD_C(R300_ALU_ALPHA_MOD_NOP) |
		       R300_ALU_ALPHA_OP(R300_ALU_ALPHA_OP_MAD) |
		       R300_ALU_ALPHA_OMOD(R300_ALU_ALPHA_OMOD_NONE) |
		       R300_ALU_ALPHA_CLAMP));
	ADVANCE_RING();
    } else {
	if (PICT_FORMAT_RGB(pSrcPicture->format) == 0)
	    src_color = (R500_ALU_RGB_R_SWIZ_A_0 |
			 R500_ALU_RGB_G_SWIZ_A_0 |
			 R500_ALU_RGB_B_SWIZ_A_0);
	else
	    src_color = (R500_ALU_RGB_R_SWIZ_A_R |
			 R500_ALU_RGB_G_SWIZ_A_G |
			 R500_ALU_RGB_B_SWIZ_A_B);

	if (PICT_FORMAT_A(pSrcPicture->format) == 0)
	    src_alpha = R500_ALPHA_SWIZ_A_1;
	else
	    src_alpha = R500_ALPHA_SWIZ_A_A;

	if (pMask) {
	    if (pMaskPicture->componentAlpha) {
		if (RadeonBlendOp[op].src_alpha) {
		    if (PICT_FORMAT_A(pSrcPicture->format) == 0)
			src_color = (R500_ALU_RGB_R_SWIZ_A_1 |
				     R500_ALU_RGB_G_SWIZ_A_1 |
				     R500_ALU_RGB_B_SWIZ_A_1);
		    else
			src_color = (R500_ALU_RGB_R_SWIZ_A_A |
				     R500_ALU_RGB_G_SWIZ_A_A |
				     R500_ALU_RGB_B_SWIZ_A_A);
		} else
		    src_color = (R500_ALU_RGB_R_SWIZ_A_R |
				 R500_ALU_RGB_G_SWIZ_A_G |
				 R500_ALU_RGB_B_SWIZ_A_B);

		mask_color = (R500_ALU_RGB_R_SWIZ_B_R |
			      R500_ALU_RGB_G_SWIZ_B_G |
			      R500_ALU_RGB_B_SWIZ_B_B);
	    } else {
		if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		    mask_color = (R500_ALU_RGB_R_SWIZ_B_1 |
				  R500_ALU_RGB_G_SWIZ_B_1 |
				  R500_ALU_RGB_B_SWIZ_B_1);
		else
		    mask_color = (R500_ALU_RGB_R_SWIZ_B_A |
				  R500_ALU_RGB_G_SWIZ_B_A |
				  R500_ALU_RGB_B_SWIZ_B_A);
	    }
	    if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		mask_alpha = R500_ALPHA_SWIZ_B_1;
	    else
		mask_alpha = R500_ALPHA_SWIZ_B_A;
	} else {
	    mask_color = (R500_ALU_RGB_R_SWIZ_B_1 |
			  R500_ALU_RGB_G_SWIZ_B_1 |
			  R500_ALU_RGB_B_SWIZ_B_1);
	    mask_alpha = R500_ALPHA_SWIZ_B_1;
	}

	BEGIN_RING(2*7);
	if (pMask) {
	    /* 4 components: 2 for tex0, 2 for tex1 */
	    OUT_RING_REG(R300_RS_COUNT,
			  ((4 << R300_RS_COUNT_IT_COUNT_SHIFT) |
			   R300_RS_COUNT_HIRES_EN));

	    /* 2 RS instructions: 1 for tex0 (src), 1 for tex1 (mask) */
	    OUT_RING_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1));

	    OUT_RING_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
					      R500_US_CODE_END_ADDR(2)));
	    OUT_RING_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
					       R500_US_CODE_RANGE_SIZE(2)));
	    OUT_RING_REG(R500_US_CODE_OFFSET, 0);
	} else {
	    OUT_RING_REG(R300_RS_COUNT,
			  ((2 << R300_RS_COUNT_IT_COUNT_SHIFT) |
			   R300_RS_COUNT_HIRES_EN));

	    OUT_RING_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0));

	    OUT_RING_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
					      R500_US_CODE_END_ADDR(1)));
	    OUT_RING_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
					       R500_US_CODE_RANGE_SIZE(1)));
	    OUT_RING_REG(R500_US_CODE_OFFSET, 0);
	}

	OUT_RING_REG(R300_US_PIXSIZE, 1); /* highest temp used */
	OUT_RING_REG(R300_US_OUT_FMT_0, output_fmt);
	ADVANCE_RING();

	if (pMask) {
	    BEGIN_RING(2*19);
	    OUT_RING_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
	    /* tex inst for src texture */
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
						   R500_INST_RGB_WMASK_R |
						   R500_INST_RGB_WMASK_G |
						   R500_INST_RGB_WMASK_B |
						   R500_INST_ALPHA_WMASK |
						   R500_INST_RGB_CLAMP |
						   R500_INST_ALPHA_CLAMP));

	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
						   R500_TEX_INST_LD |
						   R500_TEX_IGNORE_UNCOVERED));

	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
						   R500_TEX_SRC_S_SWIZ_R |
						   R500_TEX_SRC_T_SWIZ_G |
						   R500_TEX_DST_ADDR(0) |
						   R500_TEX_DST_R_SWIZ_R |
						   R500_TEX_DST_G_SWIZ_G |
						   R500_TEX_DST_B_SWIZ_B |
						   R500_TEX_DST_A_SWIZ_A));
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(0) |
						   R500_DX_S_SWIZ_R |
						   R500_DX_T_SWIZ_R |
						   R500_DX_R_SWIZ_R |
						   R500_DX_Q_SWIZ_R |
						   R500_DY_ADDR(0) |
						   R500_DY_S_SWIZ_R |
						   R500_DY_T_SWIZ_R |
						   R500_DY_R_SWIZ_R |
						   R500_DY_Q_SWIZ_R));
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, 0x00000000);

	    /* tex inst for mask texture */
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
						   R500_INST_TEX_SEM_WAIT |
						   R500_INST_RGB_WMASK_R |
						   R500_INST_RGB_WMASK_G |
						   R500_INST_RGB_WMASK_B |
						   R500_INST_ALPHA_WMASK |
						   R500_INST_RGB_CLAMP |
						   R500_INST_ALPHA_CLAMP));

	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(1) |
						   R500_TEX_INST_LD |
						   R500_TEX_SEM_ACQUIRE |
						   R500_TEX_IGNORE_UNCOVERED));

	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(1) |
						   R500_TEX_SRC_S_SWIZ_R |
						   R500_TEX_SRC_T_SWIZ_G |
						   R500_TEX_DST_ADDR(1) |
						   R500_TEX_DST_R_SWIZ_R |
						   R500_TEX_DST_G_SWIZ_G |
						   R500_TEX_DST_B_SWIZ_B |
						   R500_TEX_DST_A_SWIZ_A));
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(1) |
						   R500_DX_S_SWIZ_R |
						   R500_DX_T_SWIZ_R |
						   R500_DX_R_SWIZ_R |
						   R500_DX_Q_SWIZ_R |
						   R500_DY_ADDR(1) |
						   R500_DY_S_SWIZ_R |
						   R500_DY_T_SWIZ_R |
						   R500_DY_R_SWIZ_R |
						   R500_DY_Q_SWIZ_R));
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	} else {
	    BEGIN_RING(2*13);
	    OUT_RING_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
	    /* tex inst for src texture */
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
						   R500_INST_TEX_SEM_WAIT |
						   R500_INST_RGB_WMASK_R |
						   R500_INST_RGB_WMASK_G |
						   R500_INST_RGB_WMASK_B |
						   R500_INST_ALPHA_WMASK |
						   R500_INST_RGB_CLAMP |
						   R500_INST_ALPHA_CLAMP));

	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
						   R500_TEX_INST_LD |
						   R500_TEX_SEM_ACQUIRE |
						   R500_TEX_IGNORE_UNCOVERED));

	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
						   R500_TEX_SRC_S_SWIZ_R |
						   R500_TEX_SRC_T_SWIZ_G |
						   R500_TEX_DST_ADDR(0) |
						   R500_TEX_DST_R_SWIZ_R |
						   R500_TEX_DST_G_SWIZ_G |
						   R500_TEX_DST_B_SWIZ_B |
						   R500_TEX_DST_A_SWIZ_A));
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(0) |
						   R500_DX_S_SWIZ_R |
						   R500_DX_T_SWIZ_R |
						   R500_DX_R_SWIZ_R |
						   R500_DX_Q_SWIZ_R |
						   R500_DY_ADDR(0) |
						   R500_DY_S_SWIZ_R |
						   R500_DY_T_SWIZ_R |
						   R500_DY_R_SWIZ_R |
						   R500_DY_Q_SWIZ_R));
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	    OUT_RING_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	}

	/* ALU inst */
	/* *_OMASK* - output component write mask */
	OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_OUT |
					       R500_INST_TEX_SEM_WAIT |
					       R500_INST_LAST |
					       R500_INST_RGB_OMASK_R |
					       R500_INST_RGB_OMASK_G |
					       R500_INST_RGB_OMASK_B |
					       R500_INST_ALPHA_OMASK |
					       R500_INST_RGB_CLAMP |
					       R500_INST_ALPHA_CLAMP));
	/* ALU inst
	 * temp addresses for texture inputs
	 * RGB_ADDR0 is src tex (temp 0)
	 * RGB_ADDR1 is mask tex (temp 1)
	 */
	OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
					       R500_RGB_ADDR1(1) |
					       R500_RGB_ADDR2(0)));
	/* ALU inst
	 * temp addresses for texture inputs
	 * ALPHA_ADDR0 is src tex (temp 0)
	 * ALPHA_ADDR1 is mask tex (temp 1)
	 */
	OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
					       R500_ALPHA_ADDR1(1) |
					       R500_ALPHA_ADDR2(0)));

	/* R500_ALU_RGB_TARGET - RGB render target */
	OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
					       src_color |
					       R500_ALU_RGB_SEL_B_SRC1 |
					       mask_color |
					       R500_ALU_RGB_TARGET(0)));

	/* R500_ALPHA_RGB_TARGET - alpha render target */
	OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_OP_MAD |
					       R500_ALPHA_ADDRD(0) |
					       R500_ALPHA_SEL_A_SRC0 |
					       src_alpha |
					       R500_ALPHA_SEL_B_SRC1 |
					       mask_alpha |
					       R500_ALPHA_TARGET(0)));

	OUT_RING_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_OP_MAD |
					       R500_ALU_RGBA_ADDRD(0) |
					       R500_ALU_RGBA_R_SWIZ_0 |
					       R500_ALU_RGBA_G_SWIZ_0 |
					       R500_ALU_RGBA_B_SWIZ_0 |
					       R500_ALU_RGBA_A_SWIZ_0));
	ADVANCE_RING();
    }

    /* Clear out scissoring */
    BEGIN_RING(2*2);
    if (IS_R300_3D) {
	OUT_RING_REG(R300_SC_SCISSOR0, ((1440 << R300_SCISSOR_X_SHIFT) |
					 (1440 << R300_SCISSOR_Y_SHIFT)));
	OUT_RING_REG(R300_SC_SCISSOR1, (((pDst->drawable.width + 1440 - 1) << R300_SCISSOR_X_SHIFT) |
					 ((pDst->drawable.height + 1440 - 1) << R300_SCISSOR_Y_SHIFT)));

    } else {
	OUT_RING_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
					 (0 << R300_SCISSOR_Y_SHIFT)));
	OUT_RING_REG(R300_SC_SCISSOR1, (((pDst->drawable.width - 1) << R300_SCISSOR_X_SHIFT) |
					 ((pDst->drawable.height - 1) << R300_SCISSOR_Y_SHIFT)));
    }
    ADVANCE_RING();

    
    BEGIN_ACCEL_RELOC(3, 2);
    EMIT_WRITE_OFFSET(R300_RB3D_COLOROFFSET0, 0, pDst);
    EMIT_COLORPITCH(R300_RB3D_COLORPITCH0, colorpitch, pDst);

    blendcntl = RADEONGetBlendCntl(op, pMaskPicture, pDstPicture->format);
    OUT_RING_REG(R300_RB3D_BLENDCNTL, blendcntl | R300_ALPHA_BLEND_ENABLE | R300_READ_ENABLE);

    ADVANCE_RING();

    BEGIN_RING(2*1);
    if (pMask)
	OUT_RING_REG(R300_VAP_VTX_SIZE, 6);
    else
	OUT_RING_REG(R300_VAP_VTX_SIZE, 4);
    ADVANCE_RING();

    return TRUE;
}

static void RadeonFinishComposite(PixmapPtr pDst)
{
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);

    ENTER_DRAW(0);

    if (info->accel_state->draw_header) {
	if (info->ChipFamily < CHIP_FAMILY_R200) {
	    info->accel_state->draw_header[0] = CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
							   info->accel_state->num_vtx *
							   info->accel_state->vtx_count + 1);
	    info->accel_state->draw_header[2] = (RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
						 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
						 RADEON_CP_VC_CNTL_MAOS_ENABLE |
						 RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
						 (info->accel_state->num_vtx << RADEON_CP_VC_CNTL_NUM_SHIFT));
	} else if (IS_R300_3D || IS_R500_3D) {
	    info->accel_state->draw_header[0] = CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
							   info->accel_state->num_vtx *
							   info->accel_state->vtx_count);
	    info->accel_state->draw_header[1] = (RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
						 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
						 (info->accel_state->num_vtx << RADEON_CP_VC_CNTL_NUM_SHIFT));
	} else {
	    info->accel_state->draw_header[0] = CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
							   info->accel_state->num_vtx *
							   info->accel_state->vtx_count);
	    info->accel_state->draw_header[1] = (RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
						 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
						 (info->accel_state->num_vtx << RADEON_CP_VC_CNTL_NUM_SHIFT));
	}
	info->accel_state->draw_header = NULL;
    }

    if (IS_R300_3D || IS_R500_3D) {
	BEGIN_RING(2*3);
	OUT_RING_REG(R300_SC_CLIP_RULE, 0xAAAA);
	OUT_RING_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
    } else
	BEGIN_RING(2*1);
    OUT_RING_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
    ADVANCE_RING();

    LEAVE_DRAW(0);
}

static void RadeonDoneComposite(PixmapPtr pDst)
{
    ScreenPtr pScreen = pDst->drawable.pScreen;
    RINFO_FROM_SCREEN(pScreen);
    struct radeon_accel_state *accel_state = info->accel_state;

    RadeonFinishComposite(pDst);

    if (!accel_state->src_pic->pDrawable)
	pScreen->DestroyPixmap(accel_state->src_pix);

    if (accel_state->msk_pic && !accel_state->msk_pic->pDrawable)
	pScreen->DestroyPixmap(accel_state->msk_pix);
}

#define VTX_OUT_MASK(_dstX, _dstY, _srcX, _srcY, _maskX, _maskY)	\
do {								\
    OUT_RING(F_TO_DW(_dstX));						\
    OUT_RING(F_TO_DW(_dstY));						\
    OUT_RING(F_TO_DW(_srcX));						\
    OUT_RING(F_TO_DW(_srcY));						\
    OUT_RING(F_TO_DW(_maskX));						\
    OUT_RING(F_TO_DW(_maskY));						\
} while (0)

#define VTX_OUT(_dstX, _dstY, _srcX, _srcY)	\
do {								\
    OUT_RING(F_TO_DW(_dstX));						\
    OUT_RING(F_TO_DW(_dstY));						\
    OUT_RING(F_TO_DW(_srcX));						\
    OUT_RING(F_TO_DW(_srcY));						\
} while (0)

static inline void transformPoint(PictTransform *transform, xPointFixed *point)
{
    PictVector v;
    v.vector[0] = point->x;
    v.vector[1] = point->y;
    v.vector[2] = xFixed1;
    PictureTransformPoint(transform, &v);
    point->x = v.vector[0];
    point->y = v.vector[1];
}

static void RadeonCompositeTile(ScrnInfoPtr pScrn,
					   RADEONInfoPtr info,
					   PixmapPtr pDst,
					   int srcX, int srcY,
					   int maskX, int maskY,
					   int dstX, int dstY,
					   int w, int h)
{
    int vtx_count;
    xPointFixed srcTopLeft, srcTopRight, srcBottomLeft, srcBottomRight;
    static xPointFixed maskTopLeft, maskTopRight, maskBottomLeft, maskBottomRight;

    ENTER_DRAW(0);

    /* ErrorF("RadeonComposite (%d,%d) (%d,%d) (%d,%d) (%d,%d)\n",
       srcX, srcY, maskX, maskY,dstX, dstY, w, h); */

    if (CS_FULL(info->cs)) {
	RadeonFinishComposite(info->accel_state->dst_pix);
	radeon_cs_flush_indirect(pScrn);
	info->accel_state->exa->PrepareComposite(info->accel_state->composite_op,
						 info->accel_state->src_pic,
						 info->accel_state->msk_pic,
						 info->accel_state->dst_pic,
						 info->accel_state->src_pix,
						 info->accel_state->msk_pix,
						 info->accel_state->dst_pix);
    }

    srcTopLeft.x     = IntToxFixed(srcX);
    srcTopLeft.y     = IntToxFixed(srcY);
    srcTopRight.x    = IntToxFixed(srcX + w);
    srcTopRight.y    = IntToxFixed(srcY);
    srcBottomLeft.x  = IntToxFixed(srcX);
    srcBottomLeft.y  = IntToxFixed(srcY + h);
    srcBottomRight.x = IntToxFixed(srcX + w);
    srcBottomRight.y = IntToxFixed(srcY + h);

    if (info->accel_state->is_transform[0]) {
	if ((info->ChipFamily < CHIP_FAMILY_R300) || !info->accel_state->has_tcl) {
	    transformPoint(info->accel_state->transform[0], &srcTopLeft);
	    transformPoint(info->accel_state->transform[0], &srcTopRight);
	    transformPoint(info->accel_state->transform[0], &srcBottomLeft);
	    transformPoint(info->accel_state->transform[0], &srcBottomRight);
	}
    }

    if (info->accel_state->msk_pic) {
	maskTopLeft.x     = IntToxFixed(maskX);
	maskTopLeft.y     = IntToxFixed(maskY);
	maskTopRight.x    = IntToxFixed(maskX + w);
	maskTopRight.y    = IntToxFixed(maskY);
	maskBottomLeft.x  = IntToxFixed(maskX);
	maskBottomLeft.y  = IntToxFixed(maskY + h);
	maskBottomRight.x = IntToxFixed(maskX + w);
	maskBottomRight.y = IntToxFixed(maskY + h);

	if (info->accel_state->is_transform[1]) {
	    if ((info->ChipFamily < CHIP_FAMILY_R300) || !info->accel_state->has_tcl) {
		transformPoint(info->accel_state->transform[1], &maskTopLeft);
		transformPoint(info->accel_state->transform[1], &maskTopRight);
		transformPoint(info->accel_state->transform[1], &maskBottomLeft);
		transformPoint(info->accel_state->transform[1], &maskBottomRight);
	    }
	}

	vtx_count = 6;
    } else
	vtx_count = 4;

    if (info->accel_state->vsync)
        RADEONWaitForVLine(pScrn, pDst,
			   radeon_pick_best_crtc(pScrn, FALSE, dstX, dstX + w, dstY, dstY + h),
			   dstY, dstY + h);

    if (info->ChipFamily < CHIP_FAMILY_R200) {
	if (!info->accel_state->draw_header) {
	    BEGIN_RING(3);

	    info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    info->accel_state->num_vtx = 0;
	    info->accel_state->vtx_count = vtx_count;

	    OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
				3 * vtx_count + 1));
	    if (info->accel_state->msk_pic)
		OUT_RING(RADEON_CP_VC_FRMT_XY |
			 RADEON_CP_VC_FRMT_ST0 |
			 RADEON_CP_VC_FRMT_ST1);
	    else
		OUT_RING(RADEON_CP_VC_FRMT_XY |
			 RADEON_CP_VC_FRMT_ST0);
	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		     RADEON_CP_VC_CNTL_MAOS_ENABLE |
		     RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
		     (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
	    ADVANCE_RING();
	}

	info->accel_state->num_vtx += 3;
	BEGIN_RING(3 * vtx_count);
    } else if (IS_R300_3D || IS_R500_3D) {
	if (!info->accel_state->draw_header) {
	    BEGIN_RING(2);

	    info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    info->accel_state->num_vtx = 0;
	    info->accel_state->vtx_count = vtx_count;

	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
				4 * vtx_count));
	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		     (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
	    ADVANCE_RING();
	}

	info->accel_state->num_vtx += 4;
	BEGIN_RING(4 * vtx_count);
    } else {
	if (!info->accel_state->draw_header) {
	    BEGIN_RING(2);

	    info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    info->accel_state->num_vtx = 0;
	    info->accel_state->vtx_count = vtx_count;

	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
				3 * vtx_count));
	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		     (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
	    ADVANCE_RING();
	}

	info->accel_state->num_vtx += 3;
	BEGIN_RING(3 * vtx_count);
    }

    if (info->accel_state->msk_pic) {
	if (IS_R300_3D || IS_R500_3D) {
	    VTX_OUT_MASK((float)dstX,                                      (float)dstY,
			 xFixedToFloat(srcTopLeft.x) / info->accel_state->texW[0],      xFixedToFloat(srcTopLeft.y) / info->accel_state->texH[0],
			 xFixedToFloat(maskTopLeft.x) / info->accel_state->texW[1],     xFixedToFloat(maskTopLeft.y) / info->accel_state->texH[1]);
	}
	VTX_OUT_MASK((float)dstX,                                      (float)(dstY + h),
		xFixedToFloat(srcBottomLeft.x) / info->accel_state->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->accel_state->texH[0],
		xFixedToFloat(maskBottomLeft.x) / info->accel_state->texW[1],  xFixedToFloat(maskBottomLeft.y) / info->accel_state->texH[1]);
	VTX_OUT_MASK((float)(dstX + w),                                (float)(dstY + h),
		xFixedToFloat(srcBottomRight.x) / info->accel_state->texW[0],  xFixedToFloat(srcBottomRight.y) / info->accel_state->texH[0],
		xFixedToFloat(maskBottomRight.x) / info->accel_state->texW[1], xFixedToFloat(maskBottomRight.y) / info->accel_state->texH[1]);
	VTX_OUT_MASK((float)(dstX + w),                                (float)dstY,
		xFixedToFloat(srcTopRight.x) / info->accel_state->texW[0],     xFixedToFloat(srcTopRight.y) / info->accel_state->texH[0],
		xFixedToFloat(maskTopRight.x) / info->accel_state->texW[1],    xFixedToFloat(maskTopRight.y) / info->accel_state->texH[1]);
    } else {
	if (IS_R300_3D || IS_R500_3D) {
	    VTX_OUT((float)dstX,                                      (float)dstY,
		    xFixedToFloat(srcTopLeft.x) / info->accel_state->texW[0],      xFixedToFloat(srcTopLeft.y) / info->accel_state->texH[0]);
	}
	VTX_OUT((float)dstX,                                      (float)(dstY + h),
		xFixedToFloat(srcBottomLeft.x) / info->accel_state->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->accel_state->texH[0]);
	VTX_OUT((float)(dstX + w),                                (float)(dstY + h),
		xFixedToFloat(srcBottomRight.x) / info->accel_state->texW[0],  xFixedToFloat(srcBottomRight.y) / info->accel_state->texH[0]);
	VTX_OUT((float)(dstX + w),                                (float)dstY,
		xFixedToFloat(srcTopRight.x) / info->accel_state->texW[0],     xFixedToFloat(srcTopRight.y) / info->accel_state->texH[0]);
    }

    ADVANCE_RING();

    LEAVE_DRAW(0);
}
#undef VTX_OUT
#undef VTX_OUT_MASK

static void RadeonComposite(PixmapPtr pDst,
				       int srcX, int srcY,
				       int maskX, int maskY,
				       int dstX, int dstY,
				       int width, int height)
{
    int tileSrcY, tileMaskY, tileDstY;
    int remainingHeight;
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);

    if (!info->accel_state->need_src_tile_x && !info->accel_state->need_src_tile_y) {
	RadeonCompositeTile(pScrn,
				       info,
				       pDst,
				       srcX, srcY,
				       maskX, maskY,
				       dstX, dstY,
				       width, height);
	return;
    }

    /* Tiling logic borrowed from exaFillRegionTiled */

    modulus(srcY, info->accel_state->src_tile_height, tileSrcY);
    tileMaskY = maskY;
    tileDstY = dstY;

    remainingHeight = height;
    while (remainingHeight > 0) {
	int remainingWidth = width;
	int tileSrcX, tileMaskX, tileDstX;
	int h = info->accel_state->src_tile_height - tileSrcY;
	
	if (h > remainingHeight)
	    h = remainingHeight;
	remainingHeight -= h;

	modulus(srcX, info->accel_state->src_tile_width, tileSrcX);
	tileMaskX = maskX;
	tileDstX = dstX;
	
	while (remainingWidth > 0) {
	    int w = info->accel_state->src_tile_width - tileSrcX;
	    if (w > remainingWidth)
		w = remainingWidth;
	    remainingWidth -= w;
	    
	    RadeonCompositeTile(pScrn,
					   info,
					   pDst,
					   tileSrcX, tileSrcY,
					   tileMaskX, tileMaskY,
					   tileDstX, tileDstY,
					   w, h);
	    
	    tileSrcX = 0;
	    tileMaskX += w;
	    tileDstX += w;
	}
	tileSrcY = 0;
	tileMaskY += h;
	tileDstY += h;
    }
}

@


1.11
log
@Backout my workaround for broken accelerated solid pictures using XAA on
big endian an apply the correct fix, working at depth 16 and 24, kindly
provided by Michel Dnzer who already committed it upstream.

No objection from the usual macppc users.
@
text
@a32 27
#if defined(ACCEL_MMIO) && defined(ACCEL_CP)
#error Cannot define both MMIO and CP acceleration!
#endif

#if !defined(UNIXCPP) || defined(ANSICPP)
#define FUNC_NAME_CAT(prefix,suffix) prefix##suffix
#else
#define FUNC_NAME_CAT(prefix,suffix) prefix/**/suffix
#endif

#ifdef ACCEL_MMIO
#define FUNC_NAME(prefix) FUNC_NAME_CAT(prefix,MMIO)
#else
#ifdef ACCEL_CP
#define FUNC_NAME(prefix) FUNC_NAME_CAT(prefix,CP)
#else
#error No accel type defined!
#endif
#endif

#ifndef ACCEL_CP
#define ONLY_ONCE
#endif

/* Only include the following (generic) bits once. */
#ifdef ONLY_ONCE

a100 1
#ifdef PICT_TYPE_BGRA
a102 1
#endif
a142 1
#ifdef PICT_TYPE_BGRA
a144 1
#endif
d348 1
a348 3
#endif /* ONLY_ONCE */

static Bool FUNC_NAME(R100TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
a356 1
    ACCEL_PREAMBLE();
a372 2
    CHECK_OFFSET(pPix, 0x1f, "texture");

d432 3
a434 3
	OUT_ACCEL_REG(RADEON_PP_TXFILTER_0, txfilter);
	OUT_ACCEL_REG(RADEON_PP_TXFORMAT_0, txformat);
	OUT_ACCEL_REG(RADEON_PP_TEX_SIZE_0,
d437 1
a437 1
	OUT_ACCEL_REG(RADEON_PP_TEX_PITCH_0, txpitch - 32);
d442 2
a443 2
	OUT_ACCEL_REG(RADEON_PP_TXFILTER_1, txfilter);
	OUT_ACCEL_REG(RADEON_PP_TXFORMAT_1, txformat);
d445 1
a445 1
	OUT_ACCEL_REG(RADEON_PP_TEX_SIZE_1,
d448 1
a448 1
	OUT_ACCEL_REG(RADEON_PP_TEX_PITCH_1, txpitch - 32);
d452 1
a452 1
    FINISH_ACCEL();
a463 3
#ifdef ONLY_ONCE


d476 2
a477 2
    if (pDstPixmap->drawable.width > 2047 ||
	pDstPixmap->drawable.height > 2047) {
d489 2
a490 2
	if (pSrcPixmap->drawable.width > 2047 ||
	    pSrcPixmap->drawable.height > 2047) {
d504 2
a505 2
	    if (pMaskPixmap->drawable.width > 2047 ||
		pMaskPixmap->drawable.height > 2047) {
d545 1
d555 1
a555 3
#ifdef XF86DRM_MODE
    if (info->cs) {
	int ret;
d557 2
a558 1
	radeon_cs_space_reset_bos(info->cs);
d560 2
a561 2
	radeon_add_pixmap(info->cs, pSrc,
			  RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
d563 1
a563 2
	if (pMask)
	    radeon_add_pixmap(info->cs, pMask, RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
d565 3
a567 7
	radeon_add_pixmap(info->cs, pDst, 0, RADEON_GEM_DOMAIN_VRAM);

	ret = radeon_cs_space_check(info->cs);
	if (ret)
	    RADEON_FALLBACK(("Not enough RAM to hw accel composite operation\n"));
    }
#endif
d572 1
a572 3
#endif /* ONLY_ONCE */

static Bool FUNC_NAME(R100PrepareComposite)(int op,
a585 1
    ACCEL_PREAMBLE();
a601 2
    CHECK_OFFSET(pDst, 0x0f, "destination");

d605 1
a605 1
	    RADEON_FALLBACK("Failed to create solid scratch pixmap\n");
d619 1
a619 1
	    RADEON_FALLBACK("Failed to create solid scratch pixmap\n");
d629 1
a629 1
    if (!FUNC_NAME(R100TextureSetup)(pSrcPicture, pSrc, 0))
d634 1
a634 1
	if (!FUNC_NAME(R100TextureSetup)(pMaskPicture, pMask, 1))
d642 2
a643 2
    OUT_ACCEL_REG(RADEON_PP_CNTL, pp_cntl);
    OUT_ACCEL_REG(RADEON_RB3D_CNTL, dst_format | RADEON_ALPHA_BLEND_ENABLE);
d680 2
a681 2
    OUT_ACCEL_REG(RADEON_PP_TXCBLEND_0, cblend);
    OUT_ACCEL_REG(RADEON_PP_TXABLEND_0, ablend);
d683 1
a683 1
	OUT_ACCEL_REG(RADEON_SE_VTX_FMT, (RADEON_SE_VTX_FMT_XY |
d687 1
a687 1
	OUT_ACCEL_REG(RADEON_SE_VTX_FMT, (RADEON_SE_VTX_FMT_XY |
d692 1
a692 1
    OUT_ACCEL_REG(RADEON_RB3D_BLENDCNTL, blendcntl);
d694 4
a697 4
    OUT_ACCEL_REG(RADEON_RE_TOP_LEFT, 0);
    OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, (((pDst->drawable.width) << RADEON_RE_WIDTH_SHIFT) |
					   ((pDst->drawable.height) << RADEON_RE_HEIGHT_SHIFT)));
    FINISH_ACCEL();
a701 2
#ifdef ONLY_ONCE

d745 1
a745 3
#endif /* ONLY_ONCE */

static Bool FUNC_NAME(R200TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
a753 1
    ACCEL_PREAMBLE();
a769 1
    CHECK_OFFSET(pPix, 0x1f, "texture");
d832 4
a835 4
	OUT_ACCEL_REG(R200_PP_TXFILTER_0, txfilter);
	OUT_ACCEL_REG(R200_PP_TXFORMAT_0, txformat);
	OUT_ACCEL_REG(R200_PP_TXFORMAT_X_0, 0);
	OUT_ACCEL_REG(R200_PP_TXSIZE_0, (pPix->drawable.width - 1) |
d837 1
a837 1
	OUT_ACCEL_REG(R200_PP_TXPITCH_0, txpitch - 32);
d840 4
a843 4
	OUT_ACCEL_REG(R200_PP_TXFILTER_1, txfilter);
	OUT_ACCEL_REG(R200_PP_TXFORMAT_1, txformat);
	OUT_ACCEL_REG(R200_PP_TXFORMAT_X_1, 0);
	OUT_ACCEL_REG(R200_PP_TXSIZE_1, (pPix->drawable.width - 1) |
d845 1
a845 1
	OUT_ACCEL_REG(R200_PP_TXPITCH_1, txpitch - 32);
d849 1
a849 1
    FINISH_ACCEL();
a860 1
#ifdef ONLY_ONCE
d875 2
a876 2
    if (pDstPixmap->drawable.width > 2047 ||
	pDstPixmap->drawable.height > 2047) {
d888 2
a889 2
	if (pSrcPixmap->drawable.width > 2047 ||
	    pSrcPixmap->drawable.height > 2047) {
d903 2
a904 2
	    if (pMaskPixmap->drawable.width > 2047 ||
		pMaskPixmap->drawable.height > 2047) {
a936 1
#endif /* ONLY_ONCE */
d938 1
a938 1
static Bool FUNC_NAME(R200PrepareComposite)(int op, PicturePtr pSrcPicture,
a947 1
    ACCEL_PREAMBLE();
a963 2
    CHECK_OFFSET(pDst, 0xf, "destination");

d970 1
a970 1
	    RADEON_FALLBACK("Failed to create solid scratch pixmap\n");
d981 1
a981 1
	    RADEON_FALLBACK("Failed to create solid scratch pixmap\n");
d991 1
a991 1
    if (!FUNC_NAME(R200TextureSetup)(pSrcPicture, pSrc, 0))
d996 1
a996 1
	if (!FUNC_NAME(R200TextureSetup)(pMaskPicture, pMask, 1))
d1005 2
a1006 2
    OUT_ACCEL_REG(RADEON_PP_CNTL, pp_cntl);
    OUT_ACCEL_REG(RADEON_RB3D_CNTL, dst_format | RADEON_ALPHA_BLEND_ENABLE);
d1011 1
a1011 1
    OUT_ACCEL_REG(R200_SE_VTX_FMT_0, R200_VTX_XY);
d1013 1
a1013 1
	OUT_ACCEL_REG(R200_SE_VTX_FMT_1,
d1017 1
a1017 1
	OUT_ACCEL_REG(R200_SE_VTX_FMT_1,
d1055 2
a1056 2
    OUT_ACCEL_REG(R200_PP_TXCBLEND_0, cblend);
    OUT_ACCEL_REG(R200_PP_TXCBLEND2_0,
d1058 2
a1059 2
    OUT_ACCEL_REG(R200_PP_TXABLEND_0, ablend);
    OUT_ACCEL_REG(R200_PP_TXABLEND2_0,
d1064 1
a1064 1
    OUT_ACCEL_REG(RADEON_RB3D_BLENDCNTL, blendcntl);
d1066 2
a1067 2
    OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, (((pDst->drawable.width) << RADEON_RE_WIDTH_SHIFT) |
					   ((pDst->drawable.height) << RADEON_RE_HEIGHT_SHIFT)));
d1069 1
a1069 1
    FINISH_ACCEL();
a1073 2
#ifdef ONLY_ONCE

a1079 3
    ScreenPtr pScreen = pDstPict->pDrawable->pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);
d1093 2
a1094 2
	if (info->cs) {
    		struct radeon_exa_pixmap_priv *driver_priv;
d1100 1
a1100 1
	}
d1127 1
a1127 3
#endif /* ONLY_ONCE */

static Bool FUNC_NAME(R300TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
a1135 1
    ACCEL_PREAMBLE();
a1150 2
    CHECK_OFFSET(pPix, 0x1f, "texture");

d1255 5
a1259 5
    OUT_ACCEL_REG(R300_TX_FILTER0_0 + (unit * 4), txfilter);
    OUT_ACCEL_REG(R300_TX_FILTER1_0 + (unit * 4), 0);
    OUT_ACCEL_REG(R300_TX_FORMAT0_0 + (unit * 4), txformat0);
    OUT_ACCEL_REG(R300_TX_FORMAT1_0 + (unit * 4), txformat1);
    OUT_ACCEL_REG(R300_TX_FORMAT2_0 + (unit * 4), txpitch);
d1264 1
a1264 1
	OUT_ACCEL_REG(R300_TX_BORDER_COLOR_0 + (unit * 4), 0);
d1266 2
a1267 2
	OUT_ACCEL_REG(R500_US_FORMAT0_0 + (unit * 4), us_format);
    FINISH_ACCEL();
d1277 1
a1277 1
	    BEGIN_ACCEL(9);
d1279 1
a1279 1
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_CONST_INDEX(unit * 2));
d1281 1
a1281 1
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R500_PVS_VECTOR_CONST_INDEX(unit * 2));
d1283 9
a1291 9
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][0])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][1])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][2])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/w));

	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][0])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][1])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][2])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/h));
d1293 1
a1293 1
	    FINISH_ACCEL();
d1306 1
a1306 1
	    BEGIN_ACCEL(9);
d1308 1
a1308 1
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_CONST_INDEX(unit * 2));
d1310 1
a1310 1
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R500_PVS_VECTOR_CONST_INDEX(unit * 2));
d1312 9
a1320 9
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/w));

	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/h));
d1322 1
a1322 1
	    FINISH_ACCEL();
a1331 2
#ifdef ONLY_ONCE

a1426 1
#endif /* ONLY_ONCE */
d1428 1
a1428 1
static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
a1440 1
    ACCEL_PREAMBLE();
a1455 2
    CHECK_OFFSET(pDst, 0x0f, "destination");

d1462 1
a1462 1
	    RADEON_FALLBACK("Failed to create solid scratch pixmap\n");
d1473 1
a1473 1
	    RADEON_FALLBACK("Failed to create solid scratch pixmap\n");
d1483 1
a1483 1
    if (!FUNC_NAME(R300TextureSetup)(pSrcPicture, pSrc, 0))
d1488 1
a1488 1
	if (!FUNC_NAME(R300TextureSetup)(pMaskPicture, pMask, 1))
d1498 1
a1498 1
	    BEGIN_ACCEL(10);
d1500 2
a1501 2
	    BEGIN_ACCEL(9);
	OUT_ACCEL_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0);
d1504 1
a1504 1
	    BEGIN_ACCEL(6);
d1506 1
a1506 1
	    BEGIN_ACCEL(5);
d1523 1
a1523 1
	OUT_ACCEL_REG(R300_VAP_PROG_STREAM_CNTL_0,
d1532 1
a1532 1
	OUT_ACCEL_REG(R300_VAP_PROG_STREAM_CNTL_1,
d1539 1
a1539 1
	OUT_ACCEL_REG(R300_VAP_PROG_STREAM_CNTL_0,
d1560 1
a1560 1
	    OUT_ACCEL_REG(R300_VAP_PVS_CONST_CNTL, (R300_PVS_CONST_BASE_OFFSET(0) |
d1562 1
a1562 1
	    OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_0,
d1566 1
a1566 1
	    OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_1,
d1570 1
a1570 1
	    OUT_ACCEL_REG(R300_VAP_PVS_CONST_CNTL, (R300_PVS_CONST_BASE_OFFSET(0) |
d1572 1
a1572 1
	    OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_0,
d1576 1
a1576 1
	    OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_1,
d1582 1
a1582 1
    OUT_ACCEL_REG(R300_VAP_OUT_VTX_FMT_0, R300_VTX_POS_PRESENT);
d1584 1
a1584 1
	OUT_ACCEL_REG(R300_VAP_OUT_VTX_FMT_1,
d1588 1
a1588 1
	OUT_ACCEL_REG(R300_VAP_OUT_VTX_FMT_1,
d1591 3
a1593 3
    OUT_ACCEL_REG(R300_TX_INVALTAGS, 0x0);
    OUT_ACCEL_REG(R300_TX_ENABLE, txenable);
    FINISH_ACCEL();
a1613 1
#ifdef PICT_TYPE_BGRA
a1621 1
#endif
d1667 1
a1667 1
	    BEGIN_ACCEL(16);
d1669 1
a1669 1
	    OUT_ACCEL_REG(R300_RS_COUNT,
d1674 1
a1674 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1));
d1676 1
a1676 1
	    OUT_ACCEL_REG(R300_US_CODE_OFFSET, (R300_ALU_CODE_OFFSET(0) |
d1681 1
a1681 1
	    OUT_ACCEL_REG(R300_US_CODE_ADDR_3,
d1690 1
a1690 1
	    BEGIN_ACCEL(15);
d1692 1
a1692 1
	    OUT_ACCEL_REG(R300_RS_COUNT,
d1696 1
a1696 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0));
d1698 1
a1698 1
	    OUT_ACCEL_REG(R300_US_CODE_OFFSET, (R300_ALU_CODE_OFFSET(0) |
d1703 1
a1703 1
	    OUT_ACCEL_REG(R300_US_CODE_ADDR_3,
d1712 2
a1713 2
	OUT_ACCEL_REG(R300_US_CONFIG, (0 << R300_NLEVEL_SHIFT) | R300_FIRST_TEX);
	OUT_ACCEL_REG(R300_US_CODE_ADDR_0,
d1718 1
a1718 1
	OUT_ACCEL_REG(R300_US_CODE_ADDR_1,
d1723 1
a1723 1
	OUT_ACCEL_REG(R300_US_CODE_ADDR_2,
d1729 1
a1729 1
	OUT_ACCEL_REG(R300_US_PIXSIZE, 1); /* highest temp used */
d1731 1
a1731 1
	OUT_ACCEL_REG(R300_US_OUT_FMT_0, output_fmt);
d1734 1
a1734 1
	OUT_ACCEL_REG(R300_US_TEX_INST(0),
d1742 1
a1742 1
	    OUT_ACCEL_REG(R300_US_TEX_INST(1),
d1756 1
a1756 1
	OUT_ACCEL_REG(R300_US_ALU_RGB_ADDR(0),
d1768 1
a1768 1
	OUT_ACCEL_REG(R300_US_ALU_RGB_INST(0),
d1785 1
a1785 1
	OUT_ACCEL_REG(R300_US_ALU_ALPHA_ADDR(0),
d1796 1
a1796 1
	OUT_ACCEL_REG(R300_US_ALU_ALPHA_INST(0),
d1806 1
a1806 1
	FINISH_ACCEL();
d1862 1
a1862 1
	BEGIN_ACCEL(7);
d1865 1
a1865 1
	    OUT_ACCEL_REG(R300_RS_COUNT,
d1870 1
a1870 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1));
d1872 1
a1872 1
	    OUT_ACCEL_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
d1874 1
a1874 1
	    OUT_ACCEL_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
d1876 1
a1876 1
	    OUT_ACCEL_REG(R500_US_CODE_OFFSET, 0);
d1878 1
a1878 1
	    OUT_ACCEL_REG(R300_RS_COUNT,
d1882 1
a1882 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0));
d1884 1
a1884 1
	    OUT_ACCEL_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
d1886 1
a1886 1
	    OUT_ACCEL_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
d1888 1
a1888 1
	    OUT_ACCEL_REG(R500_US_CODE_OFFSET, 0);
d1891 3
a1893 3
	OUT_ACCEL_REG(R300_US_PIXSIZE, 1); /* highest temp used */
	OUT_ACCEL_REG(R300_US_OUT_FMT_0, output_fmt);
	FINISH_ACCEL();
d1896 2
a1897 2
	    BEGIN_ACCEL(19);
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
d1899 1
a1899 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
d1907 1
a1907 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
d1911 1
a1911 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
d1919 1
a1919 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(0) |
d1929 2
a1930 2
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
d1933 1
a1933 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
d1942 1
a1942 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(1) |
d1947 1
a1947 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(1) |
d1955 1
a1955 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(1) |
d1965 2
a1966 2
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
d1968 2
a1969 2
	    BEGIN_ACCEL(13);
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
d1971 1
a1971 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
d1980 1
a1980 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
d1985 1
a1985 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
d1993 1
a1993 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(0) |
d2003 2
a2004 2
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
d2009 1
a2009 1
	OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_OUT |
d2023 1
a2023 1
	OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
d2031 1
a2031 1
	OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
d2036 1
a2036 1
	OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
d2043 1
a2043 1
	OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_OP_MAD |
d2051 1
a2051 1
	OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_OP_MAD |
d2057 1
a2057 1
	FINISH_ACCEL();
d2061 1
a2061 1
    BEGIN_ACCEL(2);
d2063 1
a2063 1
	OUT_ACCEL_REG(R300_SC_SCISSOR0, ((1440 << R300_SCISSOR_X_SHIFT) |
d2065 1
a2065 1
	OUT_ACCEL_REG(R300_SC_SCISSOR1, (((pDst->drawable.width + 1440 - 1) << R300_SCISSOR_X_SHIFT) |
d2069 1
a2069 1
	OUT_ACCEL_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
d2071 1
a2071 1
	OUT_ACCEL_REG(R300_SC_SCISSOR1, (((pDst->drawable.width - 1) << R300_SCISSOR_X_SHIFT) |
d2074 1
a2074 1
    FINISH_ACCEL();
d2082 1
a2082 1
    OUT_ACCEL_REG(R300_RB3D_BLENDCNTL, blendcntl | R300_ALPHA_BLEND_ENABLE | R300_READ_ENABLE);
d2084 1
a2084 1
    FINISH_ACCEL();
d2086 1
a2086 1
    BEGIN_ACCEL(1);
d2088 1
a2088 1
	OUT_ACCEL_REG(R300_VAP_VTX_SIZE, 6);
d2090 2
a2091 2
	OUT_ACCEL_REG(R300_VAP_VTX_SIZE, 4);
    FINISH_ACCEL();
d2096 1
a2096 1
static void FUNC_NAME(RadeonFinishComposite)(PixmapPtr pDst)
a2098 1
    ACCEL_PREAMBLE();
d2131 3
a2133 3
	BEGIN_ACCEL(3);
	OUT_ACCEL_REG(R300_SC_CLIP_RULE, 0xAAAA);
	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
d2135 3
a2137 3
	BEGIN_ACCEL(1);
    OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
    FINISH_ACCEL();
d2142 1
a2142 1
static void FUNC_NAME(RadeonDoneComposite)(PixmapPtr pDst)
d2148 1
a2148 1
    FUNC_NAME(RadeonFinishComposite)(pDst);
a2156 2
#ifdef ACCEL_CP

d2159 6
a2164 6
    OUT_RING_F(_dstX);						\
    OUT_RING_F(_dstY);						\
    OUT_RING_F(_srcX);						\
    OUT_RING_F(_srcY);						\
    OUT_RING_F(_maskX);						\
    OUT_RING_F(_maskY);						\
d2169 4
a2172 4
    OUT_RING_F(_dstX);						\
    OUT_RING_F(_dstY);						\
    OUT_RING_F(_srcX);						\
    OUT_RING_F(_srcY);						\
a2174 23
#else /* ACCEL_CP */

#define VTX_OUT_MASK(_dstX, _dstY, _srcX, _srcY, _maskX, _maskY)	\
do {								\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstX);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstY);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcX);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcY);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _maskX);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _maskY);		\
} while (0)

#define VTX_OUT(_dstX, _dstY, _srcX, _srcY)	\
do {								\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstX);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstY);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcX);		\
    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcY);		\
} while (0)

#endif /* !ACCEL_CP */

#ifdef ONLY_ONCE
a2184 1
#endif
d2186 1
a2186 1
static void FUNC_NAME(RadeonCompositeTile)(ScrnInfoPtr pScrn,
a2196 1
    ACCEL_PREAMBLE();
d2203 3
a2205 9
#if defined(ACCEL_CP)
    if ((info->cs && CS_FULL(info->cs)) ||
	(!info->cs && (info->cp->indirectBuffer->used + 4 * 32) >
	 info->cp->indirectBuffer->total)) {
	FUNC_NAME(RadeonFinishComposite)(info->accel_state->dst_pix);
	if (info->cs)
	    radeon_cs_flush_indirect(pScrn);
	else
	    RADEONCPFlushIndirect(pScrn, 1);
a2213 1
#endif
d2257 3
a2259 3
	FUNC_NAME(RADEONWaitForVLine)(pScrn, pDst,
				      radeon_pick_best_crtc(pScrn, dstX, dstX + w, dstY, dstY + h),
				      dstY, dstY + h);
a2260 1
#ifdef ACCEL_CP
d2265 1
a2265 6
#ifdef XF86DRM_MODE
	    if (info->cs)
		info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    else
#endif
		info->accel_state->draw_header = __head;
d2292 1
a2292 6
#ifdef XF86DRM_MODE
	    if (info->cs)
		info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    else
#endif
		info->accel_state->draw_header = __head;
d2310 1
a2310 6
#ifdef XF86DRM_MODE
	    if (info->cs)
		info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    else
#endif
		info->accel_state->draw_header = __head;
a2325 22
#else /* ACCEL_CP */
    if (IS_R300_3D || IS_R500_3D)
	BEGIN_ACCEL(2 + vtx_count * 4);
    else
	BEGIN_ACCEL(1 + vtx_count * 3);

    if (info->ChipFamily < CHIP_FAMILY_R200)
	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
					  RADEON_VF_PRIM_WALK_DATA |
					  RADEON_VF_RADEON_MODE |
					  (3 << RADEON_VF_NUM_VERTICES_SHIFT)));
    else if (IS_R300_3D || IS_R500_3D)
	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_QUAD_LIST |
					  RADEON_VF_PRIM_WALK_DATA |
					  (4 << RADEON_VF_NUM_VERTICES_SHIFT)));
    else
	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
					  RADEON_VF_PRIM_WALK_DATA |
					  (3 << RADEON_VF_NUM_VERTICES_SHIFT)));

#endif

a2353 1
#ifdef ACCEL_CP
a2354 3
#else
    FINISH_ACCEL();
#endif /* !ACCEL_CP */
d2361 1
a2361 1
static void FUNC_NAME(RadeonComposite)(PixmapPtr pDst,
d2372 1
a2372 1
	FUNC_NAME(RadeonCompositeTile)(pScrn,
d2408 1
a2408 1
	    FUNC_NAME(RadeonCompositeTile)(pScrn,
a2425 2
#undef ONLY_ONCE
#undef FUNC_NAME
@


1.10
log
@Fix an EXA-related big endian issue, introduced in 6.14.5 with the support
of accelerated solid pictures on r1xx, r2xx and r3xx.

Problem reported by landry@@, ok matthieu@@
@
text
@d652 1
a652 1
	pSrc = RADEONSolidPixmap(pScreen, pSrcPicture->pSourcePict->solidFill.color);
d664 1
a664 1
	pMask = RADEONSolidPixmap(pScreen, pMaskPicture->pSourcePict->solidFill.color);
d1028 1
a1028 1
	pSrc = RADEONSolidPixmap(pScreen, pSrcPicture->pSourcePict->solidFill.color);
d1037 1
a1037 1
	pMask = RADEONSolidPixmap(pScreen, pMaskPicture->pSourcePict->solidFill.color);
d1536 1
a1536 1
	pSrc = RADEONSolidPixmap(pScreen, pSrcPicture->pSourcePict->solidFill.color);
d1545 1
a1545 1
	pMask = RADEONSolidPixmap(pScreen, pMaskPicture->pSourcePict->solidFill.color);
@


1.9
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@d652 1
a652 1
	pSrc = RADEONSolidPixmap(pScreen, cpu_to_le32(pSrcPicture->pSourcePict->solidFill.color));
d664 1
a664 1
	pMask = RADEONSolidPixmap(pScreen, cpu_to_le32(pMaskPicture->pSourcePict->solidFill.color));
d1028 1
a1028 1
	pSrc = RADEONSolidPixmap(pScreen, cpu_to_le32(pSrcPicture->pSourcePict->solidFill.color));
d1037 1
a1037 1
	pMask = RADEONSolidPixmap(pScreen, cpu_to_le32(pMaskPicture->pSourcePict->solidFill.color));
d1536 1
a1536 1
	pSrc = RADEONSolidPixmap(pScreen, cpu_to_le32(pSrcPicture->pSourcePict->solidFill.color));
d1545 1
a1545 1
	pMask = RADEONSolidPixmap(pScreen, cpu_to_le32(pMaskPicture->pSourcePict->solidFill.color));
@


1.8
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d302 2
a303 2
	int w = pPict->pDrawable->width;
	int h = pPict->pDrawable->height;
a340 2
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
a342 7
    /* r100 limit should be 2048, there are issues with 2048
     * see 197a62704742a4a19736c2637ac92d1dc5ab34ed
     */

    if ((w > 2047) || (h > 2047))
	RADEON_FALLBACK(("Picture w/h too large (%dx%d)\n", w, h));

d351 1
a351 1
    if (!RADEONCheckTexturePOT(pPict, unit == 0))
d386 3
a388 6
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    Bool repeat = (repeatType == RepeatNormal || repeatType == RepeatReflect) &&
	!(unit == 0 && (info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y));
    int i;
d392 12
a512 16
    if (!pSrcPicture->pDrawable)
	RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));

    /* r100 limit should be 2048, there are issues with 2048
     * see 197a62704742a4a19736c2637ac92d1dc5ab34ed
     */

    pSrcPixmap = RADEONGetDrawablePixmap(pSrcPicture->pDrawable);

    if (pSrcPixmap->drawable.width > 2047 ||
	pSrcPixmap->drawable.height > 2047) {
	RADEON_FALLBACK(("Source w/h too large (%d,%d).\n",
			 pSrcPixmap->drawable.width,
			 pSrcPixmap->drawable.height));
    }

d522 15
d540 2
a541 2
	if (!pMaskPicture->pDrawable)
	    RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));
d543 8
a550 8
	pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);

	if (pMaskPixmap->drawable.width > 2047 ||
	    pMaskPixmap->drawable.height > 2047) {
	    RADEON_FALLBACK(("Mask w/h too large (%d,%d).\n",
			     pMaskPixmap->drawable.width,
			     pMaskPixmap->drawable.height));
	}
d626 2
a627 1
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
d651 6
d663 9
a758 2
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
a760 7
    /* r200 limit should be 2048, there are issues with 2048
     * see bug 19269
     */

    if ((w > 2047) || (h > 2047))
	RADEON_FALLBACK(("Picture w/h too large (%dx%d)\n", w, h));

d770 1
a770 1
    if (!RADEONCheckTexturePOT(pPict, unit == 0))
d803 3
a805 6
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    Bool repeat = (repeatType == RepeatNormal || repeatType == RepeatReflect) &&
	!(unit == 0 && (info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y));
    int i;
d809 12
a928 16
    if (!pSrcPicture->pDrawable)
	RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));

    /* r200 limit should be 2048, there are issues with 2048
     * see bug 19269
     */

    pSrcPixmap = RADEONGetDrawablePixmap(pSrcPicture->pDrawable);

    if (pSrcPixmap->drawable.width > 2047 ||
	pSrcPixmap->drawable.height > 2047) {
	RADEON_FALLBACK(("Source w/h too large (%d,%d).\n",
			 pSrcPixmap->drawable.width,
			 pSrcPixmap->drawable.height));
    }

d938 15
d956 2
a957 2
	if (!pMaskPicture->pDrawable)
	    RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));
d959 8
a966 8
	pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);

	if (pMaskPixmap->drawable.width > 2047 ||
	    pMaskPixmap->drawable.height > 2047) {
	    RADEON_FALLBACK(("Mask w/h too large (%d,%d).\n",
			     pMaskPixmap->drawable.width,
			     pMaskPixmap->drawable.height));
	}
d999 2
a1000 1
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
d1027 6
d1036 9
d1143 1
a1143 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
a1144 1

a1145 2
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
a1146 12
    int max_tex_w, max_tex_h;

    if (is_r500) {
	max_tex_w = 4096;
	max_tex_h = 4096;
    } else {
	max_tex_w = 2048;
	max_tex_h = 2048;
    }

    if ((w > max_tex_w) || (h > max_tex_h))
	RADEON_FALLBACK(("Picture w/h too large (%dx%d)\n", w, h));
d1157 1
a1157 1
    if (!RADEONCheckTexturePOT(pPict, unit == 0)) {
d1199 1
a1199 2
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
d1201 1
a1201 1
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
d1207 9
d1410 1
a1410 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
a1419 5
    if (!pSrcPicture->pDrawable)
	RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));

    pSrcPixmap = RADEONGetDrawablePixmap(pSrcPicture->pDrawable);

a1436 7
    if (pSrcPixmap->drawable.width > max_tex_w ||
	pSrcPixmap->drawable.height > max_tex_h) {
	RADEON_FALLBACK(("Source w/h too large (%d,%d).\n",
			 pSrcPixmap->drawable.width,
			 pSrcPixmap->drawable.height));
    }

d1446 12
d1461 2
a1462 2
	if (!pMaskPicture->pDrawable)
	    RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));
d1464 8
a1471 8
	pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);

	if (pMaskPixmap->drawable.width > max_tex_w ||
	    pMaskPixmap->drawable.height > max_tex_h) {
	    RADEON_FALLBACK(("Mask w/h too large (%d,%d).\n",
			     pMaskPixmap->drawable.width,
			     pMaskPixmap->drawable.height));
	}
d1505 2
a1506 1
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
d1535 6
d1544 9
d2174 1
a2174 1
static void FUNC_NAME(RadeonDoneComposite)(PixmapPtr pDst)
d2221 14
d2313 1
a2313 1
	FUNC_NAME(RadeonDoneComposite)(info->accel_state->dst_pix);
@


1.7
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d128 4
d170 6
d246 1
d248 1
a248 1
    if (pPict->repeat && pPict->repeatType != RepeatPad &&
d250 1
a250 1
	!(pPict->repeatType == RepeatNormal && !pPict->transform && canTile))
d266 1
a266 1
    if (h > 1 && ((w * pPix->drawable.bitsPerPixel / 8 + 31) & ~31) != txpitch)
d294 1
d299 1
a299 1
    if (pPict->repeat && pPict->repeatType != RepeatPad) {
d315 1
a315 1
		pPict->repeatType != RepeatNormal)
d335 4
a338 1
static Bool R100CheckCompositeTexture(PicturePtr pPict, int unit)
d340 1
d369 16
d397 2
a398 1
    Bool repeat = pPict->repeat && pPict->repeatType != RepeatPad &&
d401 1
d405 3
a407 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation + pScrn->fbOffset;
a408 2
    if ((txoffset & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
d432 2
a433 2
    info->accel_state->texW[unit] = 1;
    info->accel_state->texH[unit] = 1;
d446 1
a446 2
    if (repeat) {
	switch (pPict->repeatType) {
d448 4
a451 1
	    txfilter |= RADEON_CLAMP_S_WRAP | RADEON_CLAMP_T_WRAP;
d460 3
a462 1
	    /* Nothing to do */
a463 1
	}
d466 1
a466 1
    BEGIN_ACCEL(5);
a469 1
	OUT_ACCEL_REG(RADEON_PP_TXOFFSET_0, txoffset);
d474 3
d480 1
a480 1
	OUT_ACCEL_REG(RADEON_PP_TXOFFSET_1, txoffset);
d485 2
a501 8
PixmapPtr
RADEONGetDrawablePixmap(DrawablePtr pDrawable)
{
    if (pDrawable->type == DRAWABLE_WINDOW)
	return pDrawable->pScreen->GetWindowPixmap((WindowPtr)pDrawable);
    else
	return (PixmapPtr)pDrawable;
}
d566 1
a566 1
	if (!R100CheckCompositeTexture(pMaskPicture, 1))
d570 1
a570 1
    if (!R100CheckCompositeTexture(pSrcPicture, 0))
d578 39
d628 1
a628 1
    uint32_t dst_format, dst_offset, dst_pitch, colorpitch;
d631 1
a641 5
    if (pMask)
	info->accel_state->has_mask = TRUE;
    else
	info->accel_state->has_mask = FALSE;

a643 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
d649 2
a650 4
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
    dst_pitch = exaGetPixmapPitch(pDst);
    if ((dst_offset & 0x0f) != 0)
	RADEON_FALLBACK(("Bad destination offset 0x%x\n", (int)dst_offset));
d657 4
d675 1
a675 1
    BEGIN_ACCEL(8);
d678 2
a679 2
    OUT_ACCEL_REG(RADEON_RB3D_COLOROFFSET, dst_offset);
    OUT_ACCEL_REG(RADEON_RB3D_COLORPITCH, colorpitch);
d727 4
d738 4
a741 1
static Bool R200CheckCompositeTexture(PicturePtr pPict, int unit)
d743 1
d771 16
d799 2
a800 1
    Bool repeat = pPict->repeat && pPict->repeatType != RepeatPad &&
d803 1
a806 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation + pScrn->fbOffset;
d808 3
a810 2
    if ((txoffset & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
d850 1
a850 2
    if (repeat) {
	switch (pPict->repeatType) {
d852 4
a855 1
	    txfilter |= R200_CLAMP_S_WRAP | R200_CLAMP_T_WRAP;
d864 3
a866 1
	    /* Nothing to do */
a867 1
	}
d870 1
a870 1
    BEGIN_ACCEL(6);
d878 1
a878 1
	OUT_ACCEL_REG(R200_PP_TXOFFSET_0, txoffset);
d886 2
a887 1
	OUT_ACCEL_REG(R200_PP_TXOFFSET_1, txoffset);
d910 4
d967 1
a967 1
	if (!R200CheckCompositeTexture(pMaskPicture, 1))
d971 1
a971 1
    if (!R200CheckCompositeTexture(pSrcPicture, 0))
d986 1
a986 1
    uint32_t dst_format, dst_offset, dst_pitch;
d989 1
a999 5
    if (pMask)
	info->accel_state->has_mask = TRUE;
    else
	info->accel_state->has_mask = FALSE;

a1001 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
d1007 2
a1008 2
    if ((dst_offset & 0x0f) != 0)
	RADEON_FALLBACK(("Bad destination offset 0x%x\n", (int)dst_offset));
d1015 4
d1033 1
a1033 1
    BEGIN_ACCEL(11);
d1037 3
a1039 1
    OUT_ACCEL_REG(RADEON_RB3D_COLOROFFSET, dst_offset);
d1050 1
a1050 1
    OUT_ACCEL_REG(RADEON_RB3D_COLORPITCH, colorpitch);
d1095 4
d1112 5
d1142 9
a1150 1
    if (!RADEONCheckTexturePOT(pPict, unit == 0))
d1152 1
d1166 1
a1166 1
    if (pPict->transform != 0 && !pPict->repeat && PICT_FORMAT_A(pPict->format) == 0) {
d1171 3
d1183 1
a1183 1
    uint32_t txfilter, txformat0, txformat1, txoffset, txpitch;
d1186 3
a1188 1
    int i, pixel_shift;
d1194 3
a1196 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation + pScrn->fbOffset;
a1197 2
    if ((txoffset & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
d1217 7
d1233 20
a1258 3
    info->accel_state->texW[unit] = w;
    info->accel_state->texH[unit] = h;

d1261 11
a1271 7
    if (pPict->repeat) {
	switch (pPict->repeatType) {
	case RepeatNormal:
	    if (unit != 0 || !info->accel_state->need_src_tile_x)
		txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP);
	    else
		txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL);
d1273 10
a1282 20
	    if (unit != 0 || !info->accel_state->need_src_tile_y)
		txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP);
	    else
		txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);

	    break;
	case RepeatPad:
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_LAST) |
		        R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_LAST);
	    break;
	case RepeatReflect:
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_MIRROR) |
		        R300_TX_CLAMP_T(R300_TX_CLAMP_MIRROR);
	    break;
	case RepeatNone:
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL) |
		        R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
	    break;
	}
    } else
d1284 3
a1286 1
	            R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
d1299 3
a1301 1
    BEGIN_ACCEL(pPict->repeat ? 6 : 7);
d1307 4
a1310 2
    OUT_ACCEL_REG(R300_TX_OFFSET_0 + (unit * 4), txoffset);
    if (!pPict->repeat)
d1312 2
d1319 26
d1347 27
d1410 7
a1416 2
	max_dst_w = 2560;
	max_dst_h = 2560;
d1483 1
a1483 1
    uint32_t dst_format, dst_offset, dst_pitch;
d1485 3
a1487 1
    uint32_t blendcntl;
d1489 1
a1490 1

a1495 5
    if (pMask)
	info->accel_state->has_mask = TRUE;
    else
	info->accel_state->has_mask = FALSE;

a1497 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
d1506 2
a1507 2
    if ((dst_offset & 0x0f) != 0)
	RADEON_FALLBACK(("Bad destination offset 0x%x\n", (int)dst_offset));
d1514 4
d1535 1
a1535 1
	    BEGIN_ACCEL(8);
d1537 2
a1538 1
	    BEGIN_ACCEL(7);
d1589 1
a1589 2
     * - exa no mask
     * - exa mask
d1591 1
d1596 3
d1601 2
a1602 2
			   (2 << R300_PVS_XYZW_VALID_INST_SHIFT) |
			   (2 << R300_PVS_LAST_INST_SHIFT)));
d1604 1
a1604 1
			  (2 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
d1606 3
d1610 1
a1610 1
			  ((3 << R300_PVS_FIRST_INST_SHIFT) |
d1632 35
a1668 4
	uint32_t output_fmt;
	int src_color, src_alpha;
	int mask_color, mask_alpha;

d1679 9
a1687 10
	if (pMask && pMaskPicture->componentAlpha) {
	    if (RadeonBlendOp[op].src_alpha) {
		if (PICT_FORMAT_A(pSrcPicture->format) == 0) {
		    src_color = R300_ALU_RGB_1_0;
		    src_alpha = R300_ALU_ALPHA_1_0;
		} else {
		    src_color = R300_ALU_RGB_SRC0_AAA;
		    src_alpha = R300_ALU_ALPHA_SRC0_A;
		}

a1688 6

		if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		    mask_alpha = R300_ALU_ALPHA_1_0;
		else
		    mask_alpha = R300_ALU_ALPHA_SRC1_A;

a1689 9
		src_color = R300_ALU_RGB_SRC0_RGB;

		if (PICT_FORMAT_A(pSrcPicture->format) == 0)
		    src_alpha = R300_ALU_ALPHA_1_0;
		else
		    src_alpha = R300_ALU_ALPHA_SRC0_A;

		mask_color = R300_ALU_RGB_SRC1_RGB;

d1691 1
a1691 1
		    mask_alpha = R300_ALU_ALPHA_1_0;
d1693 1
a1693 2
		    mask_alpha = R300_ALU_ALPHA_SRC1_A;

a1694 6
	} else if (pMask) {
	    if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		mask_color = R300_ALU_RGB_1_0;
	    else
		mask_color = R300_ALU_RGB_SRC1_AAA;

a1703 26
	/* shader output swizzling */
	switch (pDstPicture->format) {
	case PICT_a8r8g8b8:
	case PICT_x8r8g8b8:
	default:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_BLUE |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_RED |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8b8g8r8:
	case PICT_x8b8g8r8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_RED |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_BLUE |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_ALPHA);
	    break;
	}


d1713 1
a1713 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1) | R300_TX_OFFSET_RS(6));
d1735 1
a1735 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
a1846 4
	uint32_t output_fmt;
	uint32_t src_color, src_alpha;
	uint32_t mask_color, mask_alpha;

d1861 15
a1875 13
	if (pMask && pMaskPicture->componentAlpha) {
	    if (RadeonBlendOp[op].src_alpha) {
		if (PICT_FORMAT_A(pSrcPicture->format) == 0) {
		    src_color = (R500_ALU_RGB_R_SWIZ_A_1 |
				 R500_ALU_RGB_G_SWIZ_A_1 |
				 R500_ALU_RGB_B_SWIZ_A_1);
		    src_alpha = R500_ALPHA_SWIZ_A_1;
		} else {
		    src_color = (R500_ALU_RGB_R_SWIZ_A_A |
				 R500_ALU_RGB_G_SWIZ_A_A |
				 R500_ALU_RGB_B_SWIZ_A_A);
		    src_alpha = R500_ALPHA_SWIZ_A_A;
		}
a1879 6

		if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		    mask_alpha = R500_ALPHA_SWIZ_B_1;
		else
		    mask_alpha = R500_ALPHA_SWIZ_B_A;

a1880 13
		src_color = (R500_ALU_RGB_R_SWIZ_A_R |
			     R500_ALU_RGB_G_SWIZ_A_G |
			     R500_ALU_RGB_B_SWIZ_A_B);

		if (PICT_FORMAT_A(pSrcPicture->format) == 0)
		    src_alpha = R500_ALPHA_SWIZ_A_1;
		else
		    src_alpha = R500_ALPHA_SWIZ_A_A;

		mask_color = (R500_ALU_RGB_R_SWIZ_B_R |
			      R500_ALU_RGB_G_SWIZ_B_G |
			      R500_ALU_RGB_B_SWIZ_B_B);

d1882 3
a1884 1
		    mask_alpha = R500_ALPHA_SWIZ_B_1;
d1886 3
a1888 2
		    mask_alpha = R500_ALPHA_SWIZ_B_A;

a1889 10
	} else if (pMask) {
	    if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		mask_color = (R500_ALU_RGB_R_SWIZ_B_1 |
			      R500_ALU_RGB_G_SWIZ_B_1 |
			      R500_ALU_RGB_B_SWIZ_B_1);
	    else
		mask_color = (R500_ALU_RGB_R_SWIZ_B_A |
			      R500_ALU_RGB_G_SWIZ_B_A |
			      R500_ALU_RGB_B_SWIZ_B_A);

a1900 25
	/* shader output swizzling */
	switch (pDstPicture->format) {
	case PICT_a8r8g8b8:
	case PICT_x8r8g8b8:
	default:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_BLUE |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_RED |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8b8g8r8:
	case PICT_x8b8g8r8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_RED |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_BLUE |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_ALPHA);
	    break;
	}

d1909 1
a1909 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1) | R300_TX_OFFSET_RS(6));
d1921 1
a1921 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
d2101 12
a2112 4
    OUT_ACCEL_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
				     (0 << R300_SCISSOR_Y_SHIFT)));
    OUT_ACCEL_REG(R300_SC_SCISSOR1, ((8191 << R300_SCISSOR_X_SHIFT) |
				     (8191 << R300_SCISSOR_Y_SHIFT)));
d2115 4
a2118 4
    BEGIN_ACCEL(3);

    OUT_ACCEL_REG(R300_RB3D_COLOROFFSET0, dst_offset);
    OUT_ACCEL_REG(R300_RB3D_COLORPITCH0, colorpitch);
d2126 1
a2126 1
    if (info->accel_state->has_mask)
d2135 47
d2256 19
d2285 6
a2290 4
	transformPoint(info->accel_state->transform[0], &srcTopLeft);
	transformPoint(info->accel_state->transform[0], &srcTopRight);
	transformPoint(info->accel_state->transform[0], &srcBottomLeft);
	transformPoint(info->accel_state->transform[0], &srcBottomRight);
d2293 1
a2293 1
    if (info->accel_state->has_mask) {
d2304 6
a2309 4
	    transformPoint(info->accel_state->transform[1], &maskTopLeft);
	    transformPoint(info->accel_state->transform[1], &maskTopRight);
	    transformPoint(info->accel_state->transform[1], &maskBottomLeft);
	    transformPoint(info->accel_state->transform[1], &maskBottomRight);
d2317 3
a2319 1
	FUNC_NAME(RADEONWaitForVLine)(pScrn, pDst, RADEONBiggerCrtcArea(pDst), dstY, dstY + h);
d2323 31
a2353 15
	BEGIN_RING(3 * vtx_count + 3);
	OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
			    3 * vtx_count + 1));
	if (info->accel_state->has_mask)
	    OUT_RING(RADEON_CP_VC_FRMT_XY |
		     RADEON_CP_VC_FRMT_ST0 |
		     RADEON_CP_VC_FRMT_ST1);
	else
	    OUT_RING(RADEON_CP_VC_FRMT_XY |
		     RADEON_CP_VC_FRMT_ST0);
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		 RADEON_CP_VC_CNTL_MAOS_ENABLE |
		 RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
		 (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2355 22
a2376 6
	BEGIN_RING(4 * vtx_count + 4);
	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
			    4 * vtx_count));
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		 (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2378 22
a2399 6
	BEGIN_RING(3 * vtx_count + 2);
	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
			    3 * vtx_count));
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		 (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2424 1
a2424 1
    if (info->accel_state->has_mask) {
a2451 4
    if (IS_R300_3D || IS_R500_3D)
	/* flushing is pipelined, free/finish is not */
	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D);

a2525 19
}

static void FUNC_NAME(RadeonDoneComposite)(PixmapPtr pDst)
{
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
    ACCEL_PREAMBLE();

    ENTER_DRAW(0);

    if (IS_R300_3D || IS_R500_3D) {
	BEGIN_ACCEL(3);
	OUT_ACCEL_REG(R300_SC_CLIP_RULE, 0xAAAA);
	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
    } else
	BEGIN_ACCEL(1);
    OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
    FINISH_ACCEL();

    LEAVE_DRAW(0);
@


1.6
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@a127 4
#ifdef PICT_TYPE_BGRA
    {PICT_b8g8r8a8,	R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)},
    {PICT_b8g8r8x8,	R300_EASY_TX_FORMAT(W, Z, Y, ONE, W8Z8Y8X8)},
#endif
a165 6
    case PICT_a8b8g8r8:
    case PICT_x8b8g8r8:
#ifdef PICT_TYPE_BGRA
    case PICT_b8g8r8a8:
    case PICT_b8g8r8x8:
#endif
a235 1
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
d237 1
a237 1
    if ((repeatType == RepeatNormal || repeatType == RepeatReflect) &&
d239 1
a239 1
	!(repeatType == RepeatNormal && !pPict->transform && canTile))
d255 1
a255 1
    if (h > 1 && (RADEON_ALIGN(w * pPix->drawable.bitsPerPixel / 8, 32)) != txpitch)
a282 1
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
d287 1
a287 1
    if (repeatType == RepeatNormal || repeatType == RepeatReflect) {
d303 1
a303 1
		repeatType != RepeatNormal)
d323 1
a323 4
static Bool R100CheckCompositeTexture(PicturePtr pPict,
				      PicturePtr pDstPict,
				      int op,
				      int unit)
a324 1
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
a352 16
    /* for REPEAT_NONE, Render semantics are that sampling outside the source
     * picture results in alpha=0 pixels. We can implement this with a border color
     * *if* our source texture has an alpha channel, otherwise we need to fall
     * back. If we're not transformed then we hope that upper layers have clipped
     * rendering to the bounds of the source drawable, in which case it doesn't
     * matter. I have not, however, verified that the X server always does such
     * clipping.
     */
    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
    }

    if (!radeon_transform_is_affine_or_scaled(pPict->transform))
	RADEON_FALLBACK(("non-affine transforms not supported\n"));

d365 1
a365 2
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    Bool repeat = (repeatType == RepeatNormal || repeatType == RepeatReflect) &&
a367 1
    struct radeon_exa_pixmap_priv *driver_priv;
d371 1
a371 3
    txoffset = 0;

    CHECK_OFFSET(pPix, 0x1f, "texture");
d373 2
d398 2
a399 2
    info->accel_state->texW[unit] = w;
    info->accel_state->texH[unit] = h;
d412 2
a413 1
    switch (repeatType) {
d415 1
a415 4
	    if (txformat & RADEON_TXFORMAT_NON_POWER2)
		txfilter |= RADEON_CLAMP_S_CLAMP_LAST | RADEON_CLAMP_T_CLAMP_LAST;
	    else
	        txfilter |= RADEON_CLAMP_S_WRAP | RADEON_CLAMP_T_WRAP;
d424 1
a424 3
	    /* don't set an illegal clamp mode for rects */
	    if (txformat & RADEON_TXFORMAT_NON_POWER2)
		txfilter |= RADEON_CLAMP_S_CLAMP_LAST | RADEON_CLAMP_T_CLAMP_LAST;
d426 1
d429 1
a429 1
    BEGIN_ACCEL_RELOC(5, 1);
d433 1
a437 3

	EMIT_READ_OFFSET(RADEON_PP_TXOFFSET_0, txoffset, pPix);
	/* emit a texture relocation */
d441 1
a441 1

a445 2
	EMIT_READ_OFFSET(RADEON_PP_TXOFFSET_1, txoffset, pPix);
	/* emit a texture relocation */
d461 8
d533 1
a533 1
	if (!R100CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1))
d537 1
a537 1
    if (!R100CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0))
a544 39

static Bool
RADEONPrepareCompositeCS(int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
			    PicturePtr pDstPicture, PixmapPtr pSrc, PixmapPtr pMask,
			    PixmapPtr pDst)
{
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);

    info->accel_state->composite_op = op;
    info->accel_state->dst_pic = pDstPicture;
    info->accel_state->msk_pic = pMaskPicture;
    info->accel_state->src_pic = pSrcPicture;
    info->accel_state->dst_pix = pDst;
    info->accel_state->msk_pix = pMask;
    info->accel_state->src_pix = pSrc;

#ifdef XF86DRM_MODE
    if (info->cs) {
	int ret;

	radeon_cs_space_reset_bos(info->cs);

	radeon_add_pixmap(info->cs, pSrc,
			  RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);

	if (pMask)
	    radeon_add_pixmap(info->cs, pMask, RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);

	radeon_add_pixmap(info->cs, pDst, 0, RADEON_GEM_DOMAIN_VRAM);

	ret = radeon_cs_space_check(info->cs);
	if (ret)
	    RADEON_FALLBACK(("Not enough RAM to hw accel composite operation\n"));
    }
#endif

    return TRUE;
}

d556 1
a556 1
    uint32_t dst_format, dst_pitch, colorpitch;
a558 1
    struct radeon_exa_pixmap_priv *driver_priv;
d569 5
d576 1
d582 4
a585 2
    CHECK_OFFSET(pDst, 0x0f, "destination");

a591 4
    RADEONPrepareCompositeCS(op, pSrcPicture, pMaskPicture, pDstPicture,
			     pSrc, pMask, pDst);

    /* switch to 3D after doing buffer space checks as the latter may flush */
d606 1
a606 1
    BEGIN_ACCEL_RELOC(10, 2);
d609 2
a610 2
    EMIT_WRITE_OFFSET(RADEON_RB3D_COLOROFFSET, 0, pDst);
    EMIT_COLORPITCH(RADEON_RB3D_COLORPITCH, colorpitch, pDst);
a657 4

    OUT_ACCEL_REG(RADEON_RE_TOP_LEFT, 0);
    OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, (((pDst->drawable.width) << RADEON_RE_WIDTH_SHIFT) |
					   ((pDst->drawable.height) << RADEON_RE_HEIGHT_SHIFT)));
d665 1
a665 4
static Bool R200CheckCompositeTexture(PicturePtr pPict,
				      PicturePtr pDstPict,
				      int op,
				      int unit)
a666 1
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
a693 16
    /* for REPEAT_NONE, Render semantics are that sampling outside the source
     * picture results in alpha=0 pixels. We can implement this with a border color
     * *if* our source texture has an alpha channel, otherwise we need to fall
     * back. If we're not transformed then we hope that upper layers have clipped
     * rendering to the bounds of the source drawable, in which case it doesn't
     * matter. I have not, however, verified that the X server always does such
     * clipping.
     */
    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
    }

    if (!radeon_transform_is_affine_or_scaled(pPict->transform))
	RADEON_FALLBACK(("non-affine transforms not supported\n"));

d706 1
a706 2
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    Bool repeat = (repeatType == RepeatNormal || repeatType == RepeatReflect) &&
a708 1
    struct radeon_exa_pixmap_priv *driver_priv;
d712 1
d714 2
a715 3
    txoffset = 0;
    CHECK_OFFSET(pPix, 0x1f, "texture");

d755 2
a756 1
    switch (repeatType) {
d758 1
a758 4
	    if (txformat & R200_TXFORMAT_NON_POWER2)
		txfilter |= R200_CLAMP_S_CLAMP_LAST | R200_CLAMP_T_CLAMP_LAST;
	    else
	        txfilter |= R200_CLAMP_S_WRAP | R200_CLAMP_T_WRAP;
d767 1
a767 3
	    /* don't set an illegal clamp mode for rect textures */
	    if (txformat & R200_TXFORMAT_NON_POWER2)
		txfilter |= R200_CLAMP_S_CLAMP_LAST | R200_CLAMP_T_CLAMP_LAST;
d769 1
d772 1
a772 1
    BEGIN_ACCEL_RELOC(6, 1);
d780 1
a780 1
	EMIT_READ_OFFSET(R200_PP_TXOFFSET_0, txoffset, pPix);
d788 1
a788 2
	EMIT_READ_OFFSET(R200_PP_TXOFFSET_1, txoffset, pPix);
	/* emit a texture relocation */
a810 4
    /* Check for unsupported compositing operations. */
    if (op >= sizeof(RadeonBlendOp) / sizeof(RadeonBlendOp[0]))
	RADEON_FALLBACK(("Unsupported Composite op 0x%x\n", op));

d864 1
a864 1
	if (!R200CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1))
d868 1
a868 1
    if (!R200CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0))
d883 1
a883 1
    uint32_t dst_format, dst_pitch;
a885 1
    struct radeon_exa_pixmap_priv *driver_priv;
d896 5
d903 1
d909 2
a910 2
    CHECK_OFFSET(pDst, 0xf, "destination");

a916 4
    RADEONPrepareCompositeCS(op, pSrcPicture, pMaskPicture, pDstPicture,
			     pSrc, pMask, pDst);

    /* switch to 3D after doing buffer space checks as it may flush */
d931 1
a931 1
    BEGIN_ACCEL_RELOC(12, 2);
d935 1
a935 3

    EMIT_WRITE_OFFSET(RADEON_RB3D_COLOROFFSET, 0, pDst);
    EMIT_COLORPITCH(RADEON_RB3D_COLORPITCH, colorpitch, pDst);
d946 1
a946 1

a990 4

    OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, (((pDst->drawable.width) << RADEON_RE_WIDTH_SHIFT) |
					   ((pDst->drawable.height) << RADEON_RE_HEIGHT_SHIFT)));

a1003 5
    ScreenPtr pScreen = pDstPict->pDrawable->pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr info = RADEONPTR(pScrn);

    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
d1029 1
a1029 9
    if (!RADEONCheckTexturePOT(pPict, unit == 0)) {
	if (info->cs) {
    		struct radeon_exa_pixmap_priv *driver_priv;
		PixmapPtr pPix;

    		pPix = RADEONGetDrawablePixmap(pPict->pDrawable);
		driver_priv = exaGetPixmapDriverPrivate(pPix);
		//TODOradeon_bufmgr_gem_force_gtt(driver_priv->bo);
	}
a1030 1
    }
d1044 1
a1044 1
    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
a1048 3
    if (!radeon_transform_is_affine_or_scaled(pPict->transform))
	RADEON_FALLBACK(("non-affine transforms not supported\n"));

d1058 1
a1058 1
    uint32_t txfilter, txformat0, txformat1, txoffset, txpitch, us_format = 0;
d1061 1
a1061 3
    int i, pixel_shift, out_size = 6;
    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
    struct radeon_exa_pixmap_priv *driver_priv;
d1067 1
a1067 3
    txoffset = 0;

    CHECK_OFFSET(pPix, 0x1f, "texture");
d1069 2
a1089 7
    if (IS_R300_3D) {
	if ((unit == 0) && info->accel_state->msk_pic)
	    txformat1 |= R300_TX_FORMAT_CACHE_HALF_REGION_0;
	else if (unit == 1)
	    txformat1 |= R300_TX_FORMAT_CACHE_HALF_REGION_1;
    }

a1098 20
    if (info->ChipFamily == CHIP_FAMILY_R520) {
	unsigned us_width = (w - 1) & 0x7ff;
	unsigned us_height = (h - 1) & 0x7ff;
	unsigned us_depth = 0;

	if (w > 2048) {
	    us_width = (0x7ff + us_width) >> 1;
	    us_depth |= 0x0d;
	}
	if (h > 2048) {
	    us_height = (0x7ff + us_height) >> 1;
	    us_depth |= 0x0e;
	}

	us_format = (us_width << R300_TXWIDTH_SHIFT) |
		    (us_height << R300_TXHEIGHT_SHIFT) |
		    (us_depth << R300_TXDEPTH_SHIFT);
	out_size++;
    }

d1105 3
d1110 12
a1121 11
    switch (repeatType) {
    case RepeatNormal:
	if (unit != 0 || !info->accel_state->need_src_tile_x)
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP);
	else
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL);
	
	if (unit != 0 || !info->accel_state->need_src_tile_y)
	    txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP);
	else
	    txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
d1123 15
a1137 10
	break;
    case RepeatPad:
	txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_LAST) |
	    R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_LAST);
	break;
    case RepeatReflect:
	txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_MIRROR) |
	    R300_TX_CLAMP_T(R300_TX_CLAMP_MIRROR);
	break;
    case RepeatNone:
d1139 1
a1139 3
	    R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
	break;
    }
d1152 1
a1152 3
    if (repeatType == RepeatNone)
	out_size++;
    BEGIN_ACCEL_RELOC(out_size, 1);
d1158 2
a1159 4

    EMIT_READ_OFFSET((R300_TX_OFFSET_0 + (unit * 4)), txoffset, pPix);

    if (repeatType == RepeatNone)
a1160 2
    if (info->ChipFamily == CHIP_FAMILY_R520)
	OUT_ACCEL_REG(R500_US_FORMAT0_0 + (unit * 4), us_format);
a1165 26

	/* setup the PVS consts */
	if (info->accel_state->has_tcl) {
	    info->accel_state->texW[unit] = 1;
	    info->accel_state->texH[unit] = 1;
	    BEGIN_ACCEL(9);
	    if (IS_R300_3D)
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_CONST_INDEX(unit * 2));
	    else
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R500_PVS_VECTOR_CONST_INDEX(unit * 2));

	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][0])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][1])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[0][2])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/w));

	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][0])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][1])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(xFixedToFloat(pPict->transform->matrix[1][2])));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/h));

	    FINISH_ACCEL();
	} else {
	    info->accel_state->texW[unit] = w;
	    info->accel_state->texH[unit] = h;
	}
a1167 27

	/* setup the PVS consts */
	if (info->accel_state->has_tcl) {
	    info->accel_state->texW[unit] = 1;
	    info->accel_state->texH[unit] = 1;

	    BEGIN_ACCEL(9);
	    if (IS_R300_3D)
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_CONST_INDEX(unit * 2));
	    else
		OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, R500_PVS_VECTOR_CONST_INDEX(unit * 2));

	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/w));

	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(0.0));
	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_DATA_REG, F_TO_DW(1.0/h));

	    FINISH_ACCEL();
	} else {
	    info->accel_state->texW[unit] = w;
	    info->accel_state->texH[unit] = h;
	}
a1193 3
    if (!pSrcPicture->pDrawable)
	RADEON_FALLBACK(("Solid or gradient pictures not supported yet\n"));

d1204 2
a1205 7
	if (IS_R400_3D) {
	    max_dst_w = 4021;
	    max_dst_h = 4021;
	} else {
	    max_dst_w = 2560;
	    max_dst_h = 2560;
	}
d1272 1
a1272 1
    uint32_t dst_format, dst_pitch;
d1274 1
a1274 3
    uint32_t blendcntl, output_fmt;
    uint32_t src_color, src_alpha;
    uint32_t mask_color, mask_alpha;
a1275 1
    struct radeon_exa_pixmap_priv *driver_priv;
d1277 1
d1283 5
d1290 1
d1299 2
a1300 2
    CHECK_OFFSET(pDst, 0x0f, "destination");

a1306 4
    RADEONPrepareCompositeCS(op, pSrcPicture, pMaskPicture, pDstPicture,
			     pSrc, pMask, pDst);

    /* have to execute switch after doing buffer sizing check as the latter flushes */
d1324 1
a1324 1
	    BEGIN_ACCEL(10);
d1326 1
a1326 2
	    BEGIN_ACCEL(9);
	OUT_ACCEL_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0);
d1377 2
a1378 1
     * - exa
a1379 1
     * - Xv bicubic
a1383 3
	    /* consts used by vertex shaders */
	    OUT_ACCEL_REG(R300_VAP_PVS_CONST_CNTL, (R300_PVS_CONST_BASE_OFFSET(0) |
						    R300_PVS_MAX_CONST_ADDR(3)));
d1386 2
a1387 2
			   (8 << R300_PVS_XYZW_VALID_INST_SHIFT) |
			   (8 << R300_PVS_LAST_INST_SHIFT)));
d1389 1
a1389 1
			  (8 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
a1390 3
	    /* consts used by vertex shaders */
	    OUT_ACCEL_REG(R300_VAP_PVS_CONST_CNTL, (R300_PVS_CONST_BASE_OFFSET(0) |
						    R300_PVS_MAX_CONST_ADDR(3)));
d1392 1
a1392 1
			  ((0 << R300_PVS_FIRST_INST_SHIFT) |
a1413 35
    /* shader output swizzling */
    switch (pDstPicture->format) {
    case PICT_a8r8g8b8:
    case PICT_x8r8g8b8:
    default:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_BLUE |
		      R300_OUT_FMT_C1_SEL_GREEN |
		      R300_OUT_FMT_C2_SEL_RED |
		      R300_OUT_FMT_C3_SEL_ALPHA);
	break;
    case PICT_a8b8g8r8:
    case PICT_x8b8g8r8:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_RED |
		      R300_OUT_FMT_C1_SEL_GREEN |
		      R300_OUT_FMT_C2_SEL_BLUE |
		      R300_OUT_FMT_C3_SEL_ALPHA);
	break;
#ifdef PICT_TYPE_BGRA
    case PICT_b8g8r8a8:
    case PICT_b8g8r8x8:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_ALPHA |
		      R300_OUT_FMT_C1_SEL_RED |
		      R300_OUT_FMT_C2_SEL_GREEN |
		      R300_OUT_FMT_C3_SEL_BLUE);
	break;
#endif
    case PICT_a8:
	output_fmt = (R300_OUT_FMT_C4_8 |
		      R300_OUT_FMT_C0_SEL_ALPHA);
	break;
    }

d1416 4
d1430 10
a1439 9
	if (pMask) {
	    if (pMaskPicture->componentAlpha) {
		if (RadeonBlendOp[op].src_alpha) {
		    if (PICT_FORMAT_A(pSrcPicture->format) == 0)
			src_color = R300_ALU_RGB_1_0;
		    else
			src_color = R300_ALU_RGB_SRC0_AAA;
		} else
		    src_color = R300_ALU_RGB_SRC0_RGB;
d1441 6
d1448 9
d1458 1
a1458 1
		    mask_color = R300_ALU_RGB_1_0;
d1460 2
a1461 1
		    mask_color = R300_ALU_RGB_SRC1_AAA;
d1463 6
d1478 26
d1513 1
a1513 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1));
d1535 1
a1535 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0));
d1647 4
d1665 13
a1677 15
	if (pMask) {
	    if (pMaskPicture->componentAlpha) {
		if (RadeonBlendOp[op].src_alpha) {
		    if (PICT_FORMAT_A(pSrcPicture->format) == 0)
			src_color = (R500_ALU_RGB_R_SWIZ_A_1 |
				     R500_ALU_RGB_G_SWIZ_A_1 |
				     R500_ALU_RGB_B_SWIZ_A_1);
		    else
			src_color = (R500_ALU_RGB_R_SWIZ_A_A |
				     R500_ALU_RGB_G_SWIZ_A_A |
				     R500_ALU_RGB_B_SWIZ_A_A);
		} else
		    src_color = (R500_ALU_RGB_R_SWIZ_A_R |
				 R500_ALU_RGB_G_SWIZ_A_G |
				 R500_ALU_RGB_B_SWIZ_A_B);
d1682 6
d1689 13
d1703 1
a1703 3
		    mask_color = (R500_ALU_RGB_R_SWIZ_B_1 |
				  R500_ALU_RGB_G_SWIZ_B_1 |
				  R500_ALU_RGB_B_SWIZ_B_1);
d1705 2
a1706 3
		    mask_color = (R500_ALU_RGB_R_SWIZ_B_A |
				  R500_ALU_RGB_G_SWIZ_B_A |
				  R500_ALU_RGB_B_SWIZ_B_A);
d1708 10
d1729 25
d1762 1
a1762 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1));
d1774 1
a1774 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0));
d1954 5
a1958 5
    if (IS_R300_3D) {
	OUT_ACCEL_REG(R300_SC_SCISSOR0, ((1440 << R300_SCISSOR_X_SHIFT) |
					 (1440 << R300_SCISSOR_Y_SHIFT)));
	OUT_ACCEL_REG(R300_SC_SCISSOR1, (((pDst->drawable.width + 1440 - 1) << R300_SCISSOR_X_SHIFT) |
					 ((pDst->drawable.height + 1440 - 1) << R300_SCISSOR_Y_SHIFT)));
d1960 1
a1960 7
    } else {
	OUT_ACCEL_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
					 (0 << R300_SCISSOR_Y_SHIFT)));
	OUT_ACCEL_REG(R300_SC_SCISSOR1, (((pDst->drawable.width - 1) << R300_SCISSOR_X_SHIFT) |
					 ((pDst->drawable.height - 1) << R300_SCISSOR_Y_SHIFT)));
    }
    FINISH_ACCEL();
d1962 2
a1963 4
    
    BEGIN_ACCEL_RELOC(3, 2);
    EMIT_WRITE_OFFSET(R300_RB3D_COLOROFFSET0, 0, pDst);
    EMIT_COLORPITCH(R300_RB3D_COLORPITCH0, colorpitch, pDst);
d1971 1
a1971 1
    if (pMask)
a1979 47
static void FUNC_NAME(RadeonDoneComposite)(PixmapPtr pDst)
{
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
    ACCEL_PREAMBLE();

    ENTER_DRAW(0);

    if (info->accel_state->draw_header) {
	if (info->ChipFamily < CHIP_FAMILY_R200) {
	    info->accel_state->draw_header[0] = CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
							   info->accel_state->num_vtx *
							   info->accel_state->vtx_count + 1);
	    info->accel_state->draw_header[2] = (RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
						 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
						 RADEON_CP_VC_CNTL_MAOS_ENABLE |
						 RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
						 (info->accel_state->num_vtx << RADEON_CP_VC_CNTL_NUM_SHIFT));
	} else if (IS_R300_3D || IS_R500_3D) {
	    info->accel_state->draw_header[0] = CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
							   info->accel_state->num_vtx *
							   info->accel_state->vtx_count);
	    info->accel_state->draw_header[1] = (RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
						 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
						 (info->accel_state->num_vtx << RADEON_CP_VC_CNTL_NUM_SHIFT));
	} else {
	    info->accel_state->draw_header[0] = CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
							   info->accel_state->num_vtx *
							   info->accel_state->vtx_count);
	    info->accel_state->draw_header[1] = (RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
						 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
						 (info->accel_state->num_vtx << RADEON_CP_VC_CNTL_NUM_SHIFT));
	}
	info->accel_state->draw_header = NULL;
    }

    if (IS_R300_3D || IS_R500_3D) {
	BEGIN_ACCEL(3);
	OUT_ACCEL_REG(R300_SC_CLIP_RULE, 0xAAAA);
	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
    } else
	BEGIN_ACCEL(1);
    OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
    FINISH_ACCEL();

    LEAVE_DRAW(0);
}

a2053 19
#if defined(ACCEL_CP)
    if ((info->cs && CS_FULL(info->cs)) ||
	(!info->cs && (info->cp->indirectBuffer->used + 4 * 32) >
	 info->cp->indirectBuffer->total)) {
	FUNC_NAME(RadeonDoneComposite)(info->accel_state->dst_pix);
	if (info->cs)
	    radeon_cs_flush_indirect(pScrn);
	else
	    RADEONCPFlushIndirect(pScrn, 1);
	info->accel_state->exa->PrepareComposite(info->accel_state->composite_op,
						 info->accel_state->src_pic,
						 info->accel_state->msk_pic,
						 info->accel_state->dst_pic,
						 info->accel_state->src_pix,
						 info->accel_state->msk_pix,
						 info->accel_state->dst_pix);
    }
#endif

d2064 4
a2067 6
	if ((info->ChipFamily < CHIP_FAMILY_R300) || !info->accel_state->has_tcl) {
	    transformPoint(info->accel_state->transform[0], &srcTopLeft);
	    transformPoint(info->accel_state->transform[0], &srcTopRight);
	    transformPoint(info->accel_state->transform[0], &srcBottomLeft);
	    transformPoint(info->accel_state->transform[0], &srcBottomRight);
	}
d2070 1
a2070 1
    if (info->accel_state->msk_pic) {
d2081 4
a2084 6
	    if ((info->ChipFamily < CHIP_FAMILY_R300) || !info->accel_state->has_tcl) {
		transformPoint(info->accel_state->transform[1], &maskTopLeft);
		transformPoint(info->accel_state->transform[1], &maskTopRight);
		transformPoint(info->accel_state->transform[1], &maskBottomLeft);
		transformPoint(info->accel_state->transform[1], &maskBottomRight);
	    }
d2092 1
a2092 3
	FUNC_NAME(RADEONWaitForVLine)(pScrn, pDst,
				      radeon_pick_best_crtc(pScrn, dstX, dstX + w, dstY, dstY + h),
				      dstY, dstY + h);
d2096 15
a2110 31
	if (!info->accel_state->draw_header) {
	    BEGIN_RING(3);

#ifdef XF86DRM_MODE
	    if (info->cs)
		info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    else
#endif
		info->accel_state->draw_header = __head;
	    info->accel_state->num_vtx = 0;
	    info->accel_state->vtx_count = vtx_count;

	    OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
				3 * vtx_count + 1));
	    if (info->accel_state->msk_pic)
		OUT_RING(RADEON_CP_VC_FRMT_XY |
			 RADEON_CP_VC_FRMT_ST0 |
			 RADEON_CP_VC_FRMT_ST1);
	    else
		OUT_RING(RADEON_CP_VC_FRMT_XY |
			 RADEON_CP_VC_FRMT_ST0);
	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		     RADEON_CP_VC_CNTL_MAOS_ENABLE |
		     RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
		     (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
	    ADVANCE_RING();
	}

	info->accel_state->num_vtx += 3;
	BEGIN_RING(3 * vtx_count);
d2112 6
a2117 22
	if (!info->accel_state->draw_header) {
	    BEGIN_RING(2);

#ifdef XF86DRM_MODE
	    if (info->cs)
		info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    else
#endif
		info->accel_state->draw_header = __head;
	    info->accel_state->num_vtx = 0;
	    info->accel_state->vtx_count = vtx_count;

	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
				4 * vtx_count));
	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		     (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
	    ADVANCE_RING();
	}

	info->accel_state->num_vtx += 4;
	BEGIN_RING(4 * vtx_count);
d2119 6
a2124 22
	if (!info->accel_state->draw_header) {
	    BEGIN_RING(2);

#ifdef XF86DRM_MODE
	    if (info->cs)
		info->accel_state->draw_header = info->cs->packets + info->cs->cdw;
	    else
#endif
		info->accel_state->draw_header = __head;
	    info->accel_state->num_vtx = 0;
	    info->accel_state->vtx_count = vtx_count;

	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
				3 * vtx_count));
	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		     (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
	    ADVANCE_RING();
	}

	info->accel_state->num_vtx += 3;
	BEGIN_RING(3 * vtx_count);
d2149 1
a2149 1
    if (info->accel_state->msk_pic) {
d2177 4
d2255 19
@


1.5
log
@MFC: fixes crashes on r600 with cairo 0.10.
Tested by espie@@ and brad@@

commit 78fcbf577ad6eba6399cc39f74b7ce5f9c8e265e
Author: Michel Daenzer <daenzer@@vmware.com>
Date:   Thu Sep 3 14:55:05 2009 +0200

    EXA: Check for solid/gradient pictures the same way for all generations.

    In particular, also catch them for >= R300.

commit 87d7235790866f9c19ef08972d5237f09d940cd9
Author: Alex Deucher <alexdeucher@@gmail.com>
Date:   Thu Nov 5 10:23:03 2009 -0500

    EXA: fallback if no pMaskPicture->pDrawable

    A solid or gradient mask could be used for blending
    the source picture onto the destination picture.

    Fixes fdo bug 24838
@
text
@d128 4
d170 6
d246 1
d248 1
a248 1
    if (pPict->repeat && pPict->repeatType != RepeatPad &&
d250 1
a250 1
	!(pPict->repeatType == RepeatNormal && !pPict->transform && canTile))
d266 1
a266 1
    if (h > 1 && ((w * pPix->drawable.bitsPerPixel / 8 + 31) & ~31) != txpitch)
d294 1
d299 1
a299 1
    if (pPict->repeat && pPict->repeatType != RepeatPad) {
d315 1
a315 1
		pPict->repeatType != RepeatNormal)
d335 4
a338 1
static Bool R100CheckCompositeTexture(PicturePtr pPict, int unit)
d340 1
d369 16
d397 2
a398 1
    Bool repeat = pPict->repeat && pPict->repeatType != RepeatPad &&
d401 1
d405 3
a407 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation + pScrn->fbOffset;
a408 2
    if ((txoffset & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
d432 2
a433 2
    info->accel_state->texW[unit] = 1;
    info->accel_state->texH[unit] = 1;
d446 1
a446 2
    if (repeat) {
	switch (pPict->repeatType) {
d448 4
a451 1
	    txfilter |= RADEON_CLAMP_S_WRAP | RADEON_CLAMP_T_WRAP;
d460 3
a462 1
	    /* Nothing to do */
a463 1
	}
d466 1
a466 1
    BEGIN_ACCEL(5);
a469 1
	OUT_ACCEL_REG(RADEON_PP_TXOFFSET_0, txoffset);
d474 3
d480 1
a480 1
	OUT_ACCEL_REG(RADEON_PP_TXOFFSET_1, txoffset);
d485 2
a501 8
PixmapPtr
RADEONGetDrawablePixmap(DrawablePtr pDrawable)
{
    if (pDrawable->type == DRAWABLE_WINDOW)
	return pDrawable->pScreen->GetWindowPixmap((WindowPtr)pDrawable);
    else
	return (PixmapPtr)pDrawable;
}
d566 1
a566 1
	if (!R100CheckCompositeTexture(pMaskPicture, 1))
d570 1
a570 1
    if (!R100CheckCompositeTexture(pSrcPicture, 0))
d578 39
d628 1
a628 1
    uint32_t dst_format, dst_offset, dst_pitch, colorpitch;
d631 1
a641 5
    if (pMask)
	info->accel_state->has_mask = TRUE;
    else
	info->accel_state->has_mask = FALSE;

a643 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
d649 2
a650 4
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
    dst_pitch = exaGetPixmapPitch(pDst);
    if ((dst_offset & 0x0f) != 0)
	RADEON_FALLBACK(("Bad destination offset 0x%x\n", (int)dst_offset));
d657 4
d675 1
a675 1
    BEGIN_ACCEL(8);
d678 2
a679 2
    OUT_ACCEL_REG(RADEON_RB3D_COLOROFFSET, dst_offset);
    OUT_ACCEL_REG(RADEON_RB3D_COLORPITCH, colorpitch);
d727 4
d738 4
a741 1
static Bool R200CheckCompositeTexture(PicturePtr pPict, int unit)
d743 1
d771 16
d799 2
a800 1
    Bool repeat = pPict->repeat && pPict->repeatType != RepeatPad &&
d803 1
a806 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation + pScrn->fbOffset;
d808 3
a810 2
    if ((txoffset & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
d850 1
a850 2
    if (repeat) {
	switch (pPict->repeatType) {
d852 4
a855 1
	    txfilter |= R200_CLAMP_S_WRAP | R200_CLAMP_T_WRAP;
d864 3
a866 1
	    /* Nothing to do */
a867 1
	}
d870 1
a870 1
    BEGIN_ACCEL(6);
d878 1
a878 1
	OUT_ACCEL_REG(R200_PP_TXOFFSET_0, txoffset);
d886 2
a887 1
	OUT_ACCEL_REG(R200_PP_TXOFFSET_1, txoffset);
d910 4
d967 1
a967 1
	if (!R200CheckCompositeTexture(pMaskPicture, 1))
d971 1
a971 1
    if (!R200CheckCompositeTexture(pSrcPicture, 0))
d986 1
a986 1
    uint32_t dst_format, dst_offset, dst_pitch;
d989 1
a999 5
    if (pMask)
	info->accel_state->has_mask = TRUE;
    else
	info->accel_state->has_mask = FALSE;

a1001 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
d1007 2
a1008 2
    if ((dst_offset & 0x0f) != 0)
	RADEON_FALLBACK(("Bad destination offset 0x%x\n", (int)dst_offset));
d1015 4
d1033 1
a1033 1
    BEGIN_ACCEL(11);
d1037 3
a1039 1
    OUT_ACCEL_REG(RADEON_RB3D_COLOROFFSET, dst_offset);
d1050 1
a1050 1
    OUT_ACCEL_REG(RADEON_RB3D_COLORPITCH, colorpitch);
d1095 4
d1112 5
d1142 9
a1150 1
    if (!RADEONCheckTexturePOT(pPict, unit == 0))
d1152 1
d1166 1
a1166 1
    if (pPict->transform != 0 && !pPict->repeat && PICT_FORMAT_A(pPict->format) == 0) {
d1171 3
d1183 1
a1183 1
    uint32_t txfilter, txformat0, txformat1, txoffset, txpitch;
d1186 3
a1188 1
    int i, pixel_shift;
d1194 3
a1196 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation + pScrn->fbOffset;
a1197 2
    if ((txoffset & 0x1f) != 0)
	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
d1217 7
d1233 20
a1258 3
    info->accel_state->texW[unit] = w;
    info->accel_state->texH[unit] = h;

d1261 11
a1271 7
    if (pPict->repeat) {
	switch (pPict->repeatType) {
	case RepeatNormal:
	    if (unit != 0 || !info->accel_state->need_src_tile_x)
		txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP);
	    else
		txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL);
d1273 10
a1282 20
	    if (unit != 0 || !info->accel_state->need_src_tile_y)
		txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP);
	    else
		txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);

	    break;
	case RepeatPad:
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_LAST) |
		        R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_LAST);
	    break;
	case RepeatReflect:
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_MIRROR) |
		        R300_TX_CLAMP_T(R300_TX_CLAMP_MIRROR);
	    break;
	case RepeatNone:
	    txfilter |= R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL) |
		        R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
	    break;
	}
    } else
d1284 3
a1286 1
	            R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
d1299 3
a1301 1
    BEGIN_ACCEL(pPict->repeat ? 6 : 7);
d1307 4
a1310 2
    OUT_ACCEL_REG(R300_TX_OFFSET_0 + (unit * 4), txoffset);
    if (!pPict->repeat)
d1312 2
d1319 26
d1347 27
d1400 3
d1413 7
a1419 2
	max_dst_w = 2560;
	max_dst_h = 2560;
d1486 1
a1486 1
    uint32_t dst_format, dst_offset, dst_pitch;
d1488 3
a1490 1
    uint32_t blendcntl;
d1492 1
a1493 1

a1498 5
    if (pMask)
	info->accel_state->has_mask = TRUE;
    else
	info->accel_state->has_mask = FALSE;

a1500 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation + pScrn->fbOffset;
d1509 2
a1510 2
    if ((dst_offset & 0x0f) != 0)
	RADEON_FALLBACK(("Bad destination offset 0x%x\n", (int)dst_offset));
d1517 4
d1538 1
a1538 1
	    BEGIN_ACCEL(8);
d1540 2
a1541 1
	    BEGIN_ACCEL(7);
d1592 1
a1592 2
     * - exa no mask
     * - exa mask
d1594 1
d1599 3
d1604 2
a1605 2
			   (2 << R300_PVS_XYZW_VALID_INST_SHIFT) |
			   (2 << R300_PVS_LAST_INST_SHIFT)));
d1607 1
a1607 1
			  (2 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
d1609 3
d1613 1
a1613 1
			  ((3 << R300_PVS_FIRST_INST_SHIFT) |
d1635 35
a1671 4
	uint32_t output_fmt;
	int src_color, src_alpha;
	int mask_color, mask_alpha;

d1682 9
a1690 10
	if (pMask && pMaskPicture->componentAlpha) {
	    if (RadeonBlendOp[op].src_alpha) {
		if (PICT_FORMAT_A(pSrcPicture->format) == 0) {
		    src_color = R300_ALU_RGB_1_0;
		    src_alpha = R300_ALU_ALPHA_1_0;
		} else {
		    src_color = R300_ALU_RGB_SRC0_AAA;
		    src_alpha = R300_ALU_ALPHA_SRC0_A;
		}

a1691 6

		if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		    mask_alpha = R300_ALU_ALPHA_1_0;
		else
		    mask_alpha = R300_ALU_ALPHA_SRC1_A;

a1692 9
		src_color = R300_ALU_RGB_SRC0_RGB;

		if (PICT_FORMAT_A(pSrcPicture->format) == 0)
		    src_alpha = R300_ALU_ALPHA_1_0;
		else
		    src_alpha = R300_ALU_ALPHA_SRC0_A;

		mask_color = R300_ALU_RGB_SRC1_RGB;

d1694 1
a1694 1
		    mask_alpha = R300_ALU_ALPHA_1_0;
d1696 1
a1696 2
		    mask_alpha = R300_ALU_ALPHA_SRC1_A;

a1697 6
	} else if (pMask) {
	    if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		mask_color = R300_ALU_RGB_1_0;
	    else
		mask_color = R300_ALU_RGB_SRC1_AAA;

a1706 26
	/* shader output swizzling */
	switch (pDstPicture->format) {
	case PICT_a8r8g8b8:
	case PICT_x8r8g8b8:
	default:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_BLUE |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_RED |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8b8g8r8:
	case PICT_x8b8g8r8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_RED |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_BLUE |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_ALPHA);
	    break;
	}


d1716 1
a1716 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1) | R300_TX_OFFSET_RS(6));
d1738 1
a1738 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
a1849 4
	uint32_t output_fmt;
	uint32_t src_color, src_alpha;
	uint32_t mask_color, mask_alpha;

d1864 15
a1878 13
	if (pMask && pMaskPicture->componentAlpha) {
	    if (RadeonBlendOp[op].src_alpha) {
		if (PICT_FORMAT_A(pSrcPicture->format) == 0) {
		    src_color = (R500_ALU_RGB_R_SWIZ_A_1 |
				 R500_ALU_RGB_G_SWIZ_A_1 |
				 R500_ALU_RGB_B_SWIZ_A_1);
		    src_alpha = R500_ALPHA_SWIZ_A_1;
		} else {
		    src_color = (R500_ALU_RGB_R_SWIZ_A_A |
				 R500_ALU_RGB_G_SWIZ_A_A |
				 R500_ALU_RGB_B_SWIZ_A_A);
		    src_alpha = R500_ALPHA_SWIZ_A_A;
		}
a1882 6

		if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		    mask_alpha = R500_ALPHA_SWIZ_B_1;
		else
		    mask_alpha = R500_ALPHA_SWIZ_B_A;

a1883 13
		src_color = (R500_ALU_RGB_R_SWIZ_A_R |
			     R500_ALU_RGB_G_SWIZ_A_G |
			     R500_ALU_RGB_B_SWIZ_A_B);

		if (PICT_FORMAT_A(pSrcPicture->format) == 0)
		    src_alpha = R500_ALPHA_SWIZ_A_1;
		else
		    src_alpha = R500_ALPHA_SWIZ_A_A;

		mask_color = (R500_ALU_RGB_R_SWIZ_B_R |
			      R500_ALU_RGB_G_SWIZ_B_G |
			      R500_ALU_RGB_B_SWIZ_B_B);

d1885 3
a1887 1
		    mask_alpha = R500_ALPHA_SWIZ_B_1;
d1889 3
a1891 2
		    mask_alpha = R500_ALPHA_SWIZ_B_A;

a1892 10
	} else if (pMask) {
	    if (PICT_FORMAT_A(pMaskPicture->format) == 0)
		mask_color = (R500_ALU_RGB_R_SWIZ_B_1 |
			      R500_ALU_RGB_G_SWIZ_B_1 |
			      R500_ALU_RGB_B_SWIZ_B_1);
	    else
		mask_color = (R500_ALU_RGB_R_SWIZ_B_A |
			      R500_ALU_RGB_G_SWIZ_B_A |
			      R500_ALU_RGB_B_SWIZ_B_A);

a1903 25
	/* shader output swizzling */
	switch (pDstPicture->format) {
	case PICT_a8r8g8b8:
	case PICT_x8r8g8b8:
	default:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_BLUE |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_RED |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8b8g8r8:
	case PICT_x8b8g8r8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_RED |
			  R300_OUT_FMT_C1_SEL_GREEN |
			  R300_OUT_FMT_C2_SEL_BLUE |
			  R300_OUT_FMT_C3_SEL_ALPHA);
	    break;
	case PICT_a8:
	    output_fmt = (R300_OUT_FMT_C4_8 |
			  R300_OUT_FMT_C0_SEL_ALPHA);
	    break;
	}

d1912 1
a1912 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1) | R300_TX_OFFSET_RS(6));
d1924 1
a1924 1
	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
d2104 12
a2115 4
    OUT_ACCEL_REG(R300_SC_SCISSOR0, ((0 << R300_SCISSOR_X_SHIFT) |
				     (0 << R300_SCISSOR_Y_SHIFT)));
    OUT_ACCEL_REG(R300_SC_SCISSOR1, ((8191 << R300_SCISSOR_X_SHIFT) |
				     (8191 << R300_SCISSOR_Y_SHIFT)));
d2118 4
a2121 4
    BEGIN_ACCEL(3);

    OUT_ACCEL_REG(R300_RB3D_COLOROFFSET0, dst_offset);
    OUT_ACCEL_REG(R300_RB3D_COLORPITCH0, colorpitch);
d2129 1
a2129 1
    if (info->accel_state->has_mask)
d2138 47
d2259 19
d2288 6
a2293 4
	transformPoint(info->accel_state->transform[0], &srcTopLeft);
	transformPoint(info->accel_state->transform[0], &srcTopRight);
	transformPoint(info->accel_state->transform[0], &srcBottomLeft);
	transformPoint(info->accel_state->transform[0], &srcBottomRight);
d2296 1
a2296 1
    if (info->accel_state->has_mask) {
d2307 6
a2312 4
	    transformPoint(info->accel_state->transform[1], &maskTopLeft);
	    transformPoint(info->accel_state->transform[1], &maskTopRight);
	    transformPoint(info->accel_state->transform[1], &maskBottomLeft);
	    transformPoint(info->accel_state->transform[1], &maskBottomRight);
d2320 3
a2322 1
	FUNC_NAME(RADEONWaitForVLine)(pScrn, pDst, RADEONBiggerCrtcArea(pDst), dstY, dstY + h);
d2326 31
a2356 15
	BEGIN_RING(3 * vtx_count + 3);
	OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
			    3 * vtx_count + 1));
	if (info->accel_state->has_mask)
	    OUT_RING(RADEON_CP_VC_FRMT_XY |
		     RADEON_CP_VC_FRMT_ST0 |
		     RADEON_CP_VC_FRMT_ST1);
	else
	    OUT_RING(RADEON_CP_VC_FRMT_XY |
		     RADEON_CP_VC_FRMT_ST0);
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		 RADEON_CP_VC_CNTL_MAOS_ENABLE |
		 RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
		 (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2358 22
a2379 6
	BEGIN_RING(4 * vtx_count + 4);
	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
			    4 * vtx_count));
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		 (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2381 22
a2402 6
	BEGIN_RING(3 * vtx_count + 2);
	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
			    3 * vtx_count));
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
		 (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2427 1
a2427 1
    if (info->accel_state->has_mask) {
a2454 4
    if (IS_R300_3D || IS_R500_3D)
	/* flushing is pipelined, free/finish is not */
	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D);

a2528 19
}

static void FUNC_NAME(RadeonDoneComposite)(PixmapPtr pDst)
{
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
    ACCEL_PREAMBLE();

    ENTER_DRAW(0);

    if (IS_R300_3D || IS_R500_3D) {
	BEGIN_ACCEL(3);
	OUT_ACCEL_REG(R300_SC_CLIP_RULE, 0xAAAA);
	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
    } else
	BEGIN_ACCEL(1);
    OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
    FINISH_ACCEL();

    LEAVE_DRAW(0);
@


1.4
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d481 1
a481 1
	return FALSE;
d506 6
a511 1
	PixmapPtr pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);
d812 1
a812 1
	return FALSE;
d837 6
a842 1
	PixmapPtr pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);
d1191 3
d1225 6
a1230 1
	PixmapPtr pMaskPixmap = RADEONGetDrawablePixmap(pMaskPicture->pDrawable);
@


1.3
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@a58 9
static Bool is_transform[2];
static PictTransform *transform[2];
static Bool has_mask;
/* Whether we are tiling horizontally and vertically */
static Bool need_src_tile_x;
static Bool need_src_tile_y;
/* Size of tiles ... set to 65536x65536 if not tiling in that direction */
static Bool src_tile_width;
static Bool src_tile_height;
d237 3
a239 2
    if (pPict->repeat && ((w & (w - 1)) != 0 || (h & (h - 1)) != 0) &&
	!(!pPict->transform && canTile))
d282 4
a285 2
    need_src_tile_x = need_src_tile_y = FALSE;
    src_tile_width = src_tile_height = 65536; /* "infinite" */
d287 1
a287 1
    if (pPict->repeat) {
d298 8
a305 3
	    need_src_tile_x = (w & (w - 1)) != 0 || badPitch;
	    need_src_tile_y = (h & (h - 1)) != 0;
	    
d307 3
a309 1
		need_src_tile_x = need_src_tile_y = need_src_tile_x || need_src_tile_y;
d312 4
a315 4
	if (need_src_tile_x)
	  src_tile_width = w;
	if (need_src_tile_y)
	  src_tile_height = h;
d329 5
a333 1
    if ((w > 0x7ff) || (h > 0x7ff))
d365 2
a366 1
    Bool repeat = pPict->repeat && !(unit == 0 && (need_src_tile_x || need_src_tile_y));
d377 1
a377 1
    
d398 2
a399 2
    info->texW[unit] = 1;
    info->texH[unit] = 1;
d412 16
a427 2
    if (repeat)
      txfilter |= RADEON_CLAMP_S_WRAP | RADEON_CLAMP_T_WRAP;
d450 2
a451 2
	is_transform[unit] = TRUE;
	transform[unit] = pPict->transform;
d453 1
a453 1
	is_transform[unit] = FALSE;
d461 1
a461 1
static PixmapPtr
d483 4
d489 2
a490 2
    if (pSrcPixmap->drawable.width >= 2048 ||
	pSrcPixmap->drawable.height >= 2048) {
d498 2
a499 2
    if (pDstPixmap->drawable.width >= 2048 ||
	pDstPixmap->drawable.height >= 2048) {
d508 2
a509 2
	if (pMaskPixmap->drawable.width >= 2048 ||
	    pMaskPixmap->drawable.height >= 2048) {
a557 3
    if (!info->XInited3D)
	RADEONInit3DEngine(pScrn);

d561 3
d565 1
a565 1
	has_mask = TRUE;
d567 1
a567 1
	has_mask = FALSE;
d587 2
d598 1
a598 1
	is_transform[1] = FALSE;
a600 2
    RADEON_SWITCH_TO_3D();

d666 5
a670 1
    if ((w > 0x7ff) || (h > 0x7ff))
d701 2
a702 1
    Bool repeat = pPict->repeat && !(unit == 0 && (need_src_tile_x || need_src_tile_y));
d734 2
a735 2
    info->texW[unit] = w;
    info->texH[unit] = h;
d750 16
a765 2
    if (repeat)
      txfilter |= R200_CLAMP_S_WRAP | R200_CLAMP_T_WRAP;
d788 2
a789 2
	is_transform[unit] = TRUE;
	transform[unit] = pPict->transform;
d791 1
a791 1
	is_transform[unit] = FALSE;
d809 4
d815 2
a816 2
    if (pSrcPixmap->drawable.width >= 2048 ||
	pSrcPixmap->drawable.height >= 2048) {
d824 2
a825 2
    if (pDstPixmap->drawable.width >= 2048 ||
	pDstPixmap->drawable.height >= 2048) {
d834 2
a835 2
	if (pMaskPixmap->drawable.width >= 2048 ||
	    pMaskPixmap->drawable.height >= 2048) {
a879 3
    if (!info->XInited3D)
	RADEONInit3DEngine(pScrn);

d883 3
d887 1
a887 1
	has_mask = TRUE;
d889 1
a889 1
	has_mask = FALSE;
d907 2
d918 1
a918 1
	is_transform[1] = FALSE;
a920 2
    RADEON_SWITCH_TO_3D();

d1095 12
a1106 2
    info->texW[unit] = w;
    info->texH[unit] = h;
d1108 4
a1111 4
    if (pPict->repeat && !(unit == 0 && need_src_tile_x))
      txfilter = R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP);
    else
      txfilter = R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL);
d1113 17
a1129 6
    if (pPict->repeat && !(unit == 0 && need_src_tile_y))
      txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP);
    else
      txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
		   
    txfilter |= (unit << R300_TX_ID_SHIFT);
d1154 2
a1155 2
	is_transform[unit] = TRUE;
	transform[unit] = pPict->transform;
d1157 1
a1157 1
	is_transform[unit] = FALSE;
d1195 2
a1196 2
    if (pSrcPixmap->drawable.width >= max_tex_w ||
	pSrcPixmap->drawable.height >= max_tex_h) {
d1204 2
a1205 2
    if (pDstPixmap->drawable.width >= max_dst_w ||
	pDstPixmap->drawable.height >= max_dst_h) {
d1214 2
a1215 2
	if (pMaskPixmap->drawable.width >= max_tex_w ||
	    pMaskPixmap->drawable.height >= max_tex_h) {
a1261 3
    if (!info->XInited3D)
	RADEONInit3DEngine(pScrn);

d1266 1
a1266 1
	has_mask = TRUE;
d1268 1
a1268 1
	has_mask = FALSE;
d1289 2
d1300 1
a1300 1
	is_transform[1] = FALSE;
a1302 2
    RADEON_SWITCH_TO_3D();

d1304 1
a1304 1
    if (info->has_tcl) {
d1364 1
a1364 1
    if (info->has_tcl) {
a1486 1
	BEGIN_ACCEL(9);
d1488 1
d1508 2
d1511 1
d1530 1
d1533 18
d1554 15
a1568 2
	/* tex inst for src texture is pre-loaded in RADEONInit3DEngine() */
	/* tex inst for mask texture is pre-loaded in RADEONInit3DEngine() */
d1577 1
a1577 1
	OUT_ACCEL_REG(R300_US_ALU_RGB_ADDR_0,
d1589 1
a1589 1
	OUT_ACCEL_REG(R300_US_ALU_RGB_INST_0,
d1606 1
a1606 1
	OUT_ACCEL_REG(R300_US_ALU_ALPHA_ADDR_0,
d1617 1
a1617 1
	OUT_ACCEL_REG(R300_US_ALU_ALPHA_INST_0,
d1736 1
a1736 1
	BEGIN_ACCEL(6);
d1765 1
d1771 1
a1771 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, 0);
d1843 1
a1843 1
	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, 0);
d1934 8
d1952 7
a1961 2
#define VTX_COUNT_MASK 6
#define VTX_COUNT 4
d2018 3
a2020 1
static void FUNC_NAME(RadeonCompositeTile)(PixmapPtr pDst,
a2025 1
    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
d2028 1
a2028 1
    xPointFixed maskTopLeft, maskTopRight, maskBottomLeft, maskBottomRight;
d2045 23
a2067 21
    maskTopLeft.x     = IntToxFixed(maskX);
    maskTopLeft.y     = IntToxFixed(maskY);
    maskTopRight.x    = IntToxFixed(maskX + w);
    maskTopRight.y    = IntToxFixed(maskY);
    maskBottomLeft.x  = IntToxFixed(maskX);
    maskBottomLeft.y  = IntToxFixed(maskY + h);
    maskBottomRight.x = IntToxFixed(maskX + w);
    maskBottomRight.y = IntToxFixed(maskY + h);

    if (is_transform[0]) {
	transformPoint(transform[0], &srcTopLeft);
	transformPoint(transform[0], &srcTopRight);
	transformPoint(transform[0], &srcBottomLeft);
	transformPoint(transform[0], &srcBottomRight);
    }
    if (is_transform[1]) {
	transformPoint(transform[1], &maskTopLeft);
	transformPoint(transform[1], &maskTopRight);
	transformPoint(transform[1], &maskBottomLeft);
	transformPoint(transform[1], &maskBottomRight);
    }
d2069 3
a2071 4
    if (has_mask)
	vtx_count = VTX_COUNT_MASK;
    else
	vtx_count = VTX_COUNT;
d2073 2
a2074 5
    if (IS_R300_3D || IS_R500_3D) {
	BEGIN_ACCEL(1);
	OUT_ACCEL_REG(R300_VAP_VTX_SIZE, vtx_count);
	FINISH_ACCEL();
    }
d2078 1
a2078 1
	BEGIN_RING(4 * vtx_count + 3);
d2080 2
a2081 2
			    4 * vtx_count + 1));
	if (has_mask)
d2088 1
a2088 1
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_FAN |
d2092 7
d2101 1
a2101 5
	if (IS_R300_3D || IS_R500_3D)
	    BEGIN_RING(4 * vtx_count + 4);
	else
	    BEGIN_RING(4 * vtx_count + 2);

d2103 2
a2104 2
			    4 * vtx_count));
	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_FAN |
d2106 1
a2106 1
		 (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
d2113 1
a2113 1
	BEGIN_ACCEL(1 + vtx_count * 4);
d2115 2
a2116 2
    if (info->ChipFamily < CHIP_FAMILY_R200) {
	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_TRIANGLE_FAN |
d2119 2
a2120 2
					  4 << RADEON_VF_NUM_VERTICES_SHIFT));
    } else {
d2123 6
a2128 2
					  4 << RADEON_VF_NUM_VERTICES_SHIFT));
    }
d2131 6
a2136 4
    if (has_mask) {
	VTX_OUT_MASK((float)dstX,                                      (float)dstY,
		xFixedToFloat(srcTopLeft.x) / info->texW[0],      xFixedToFloat(srcTopLeft.y) / info->texH[0],
		xFixedToFloat(maskTopLeft.x) / info->texW[1],     xFixedToFloat(maskTopLeft.y) / info->texH[1]);
d2138 2
a2139 2
		xFixedToFloat(srcBottomLeft.x) / info->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->texH[0],
		xFixedToFloat(maskBottomLeft.x) / info->texW[1],  xFixedToFloat(maskBottomLeft.y) / info->texH[1]);
d2141 2
a2142 2
		xFixedToFloat(srcBottomRight.x) / info->texW[0],  xFixedToFloat(srcBottomRight.y) / info->texH[0],
		xFixedToFloat(maskBottomRight.x) / info->texW[1], xFixedToFloat(maskBottomRight.y) / info->texH[1]);
d2144 2
a2145 2
		xFixedToFloat(srcTopRight.x) / info->texW[0],     xFixedToFloat(srcTopRight.y) / info->texH[0],
		xFixedToFloat(maskTopRight.x) / info->texW[1],    xFixedToFloat(maskTopRight.y) / info->texH[1]);
d2147 4
a2150 2
	VTX_OUT((float)dstX,                                      (float)dstY,
		xFixedToFloat(srcTopLeft.x) / info->texW[0],      xFixedToFloat(srcTopLeft.y) / info->texH[0]);
d2152 1
a2152 1
		xFixedToFloat(srcBottomLeft.x) / info->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->texH[0]);
d2154 1
a2154 1
		xFixedToFloat(srcBottomRight.x) / info->texW[0],  xFixedToFloat(srcBottomRight.y) / info->texH[0]);
d2156 1
a2156 1
		xFixedToFloat(srcTopRight.x) / info->texW[0],     xFixedToFloat(srcTopRight.y) / info->texH[0]);
d2182 6
a2187 3
    
    if (!need_src_tile_x && !need_src_tile_y) {
	FUNC_NAME(RadeonCompositeTile)(pDst,
d2197 1
a2197 1
    modulus(srcY, src_tile_height, tileSrcY);
d2205 1
a2205 1
	int h = src_tile_height - tileSrcY;
d2211 1
a2211 1
	modulus(srcX, src_tile_width, tileSrcX);
d2216 1
a2216 1
	    int w = src_tile_width - tileSrcX;
d2221 3
a2223 1
	    FUNC_NAME(RadeonCompositeTile)(pDst,
d2247 2
a2248 1
	BEGIN_ACCEL(2);
@


1.2
log
@Bug fixes from X.Org ati-6.6-branch head.
@
text
@d29 1
d61 7
d72 1
a72 1
    CARD32 blend_cntl;
d106 1
a106 1
    CARD32 card_fmt;
d132 11
d145 1
a145 1
static Bool RADEONGetDestFormat(PicturePtr pDstPicture, CARD32 *dst_format)
d170 25
a194 1
static CARD32 RADEONGetBlendCntl(int op, PicturePtr pMask, CARD32 dst_format)
d196 1
a196 1
    CARD32 sblend, dblend;
d228 1
a228 1
    CARD32 i;
d231 89
d339 2
a340 2
    if (pPict->repeat && ((w != 1) || (h != 1)))
	RADEON_FALLBACK(("Repeat unsupported (%dx%d)\n", w, h));
d357 1
a357 1
    CARD32 txfilter, txformat, txoffset, txpitch;
d360 1
d365 1
a365 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation;
d381 5
a385 1
    if (pPict->repeat) {
d388 1
a388 1
    } else 
d391 4
a394 1
 
d406 3
d440 10
d453 2
a454 1
    CARD32 tmp1;
d460 10
a469 12
    if (pMaskPicture != NULL && pMaskPicture->componentAlpha) {
	/* Check if it's component alpha that relies on a source alpha and on
	 * the source value.  We can only get one of those into the single
	 * source value that we get to blend with.
	 */
	if (RadeonBlendOp[op].src_alpha &&
	    (RadeonBlendOp[op].blend_cntl & RADEON_SRC_BLEND_MASK) !=
	     RADEON_SRC_BLEND_GL_ZERO)
	{
	    RADEON_FALLBACK(("Component alpha not supported with source "
			    "alpha and source value blending.\n"));
	}
d472 4
a475 3
    if (pDstPicture->pDrawable->width >= (1 << 11) ||
	pDstPicture->pDrawable->height >= (1 << 11))
    {
d477 29
a505 2
			pDstPicture->pDrawable->width,
			pDstPicture->pDrawable->height));
a509 2
    if (pMaskPicture != NULL && !R100CheckCompositeTexture(pMaskPicture, 1))
	return FALSE;
d527 2
a528 2
    CARD32 dst_format, dst_offset, dst_pitch, colorpitch;
    CARD32 pp_cntl, blendcntl, cblend, ablend;
d537 8
a544 1
    RADEONGetDestFormat(pDstPicture, &dst_format);
d547 1
a547 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation;
d553 1
a553 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation;
d560 3
d618 7
a624 3
    OUT_ACCEL_REG(RADEON_SE_VTX_FMT, RADEON_SE_VTX_FMT_XY |
				     RADEON_SE_VTX_FMT_ST0 |
				     RADEON_SE_VTX_FMT_ST1);
d654 2
a655 2
    if (pPict->repeat && ((w != 1) || (h != 1)))
	RADEON_FALLBACK(("Repeat unsupported (%dx%d)\n", w, h));
d670 1
a670 1
    CARD32 txfilter, txformat, txoffset, txpitch;
d673 1
d678 1
a678 1
    txoffset = exaGetPixmapOffset(pPix) + info->fbLocation;
d684 1
a684 1
    
d694 5
a698 1
    if (pPict->repeat) {
d705 3
d721 3
d758 2
a759 1
    CARD32 tmp1;
d763 30
a792 3
    /* Check for unsupported compositing operations. */
    if (op >= sizeof(RadeonBlendOp) / sizeof(RadeonBlendOp[0]))
	RADEON_FALLBACK(("Unsupported Composite op 0x%x\n", op));
d794 11
a804 11
    if (pMaskPicture != NULL && pMaskPicture->componentAlpha) {
	/* Check if it's component alpha that relies on a source alpha and on
	 * the source value.  We can only get one of those into the single
	 * source value that we get to blend with.
	 */
	if (RadeonBlendOp[op].src_alpha &&
	    (RadeonBlendOp[op].blend_cntl & RADEON_SRC_BLEND_MASK) !=
	     RADEON_SRC_BLEND_GL_ZERO)
	{
	    RADEON_FALLBACK(("Component alpha not supported with source "
			    "alpha and source value blending.\n"));
d806 3
a812 2
    if (pMaskPicture != NULL && !R200CheckCompositeTexture(pMaskPicture, 1))
	return FALSE;
d826 2
a827 2
    CARD32 dst_format, dst_offset, dst_pitch;
    CARD32 pp_cntl, blendcntl, cblend, ablend, colorpitch;
d836 8
a843 1
    RADEONGetDestFormat(pDstPicture, &dst_format);
d846 1
a846 1
    dst_offset = exaGetPixmapOffset(pDst) + info->fbLocation;
d857 3
d881 7
a887 3
    OUT_ACCEL_REG(R200_SE_VTX_FMT_1,
		 (2 << R200_VTX_TEX0_COMP_CNT_SHIFT) |
		 (2 << R200_VTX_TEX1_COMP_CNT_SHIFT));
d939 910
d1851 1
a1851 3
#define VTX_DWORD_COUNT 6

#define VTX_OUT(_dstX, _dstY, _srcX, _srcY, _maskX, _maskY)	\
d1861 8
d1871 1
a1871 3
#define VTX_REG_COUNT 6

#define VTX_OUT(_dstX, _dstY, _srcX, _srcY, _maskX, _maskY)	\
d1881 8
d1891 18
a1908 5
static void FUNC_NAME(RadeonComposite)(PixmapPtr pDst,
				     int srcX, int srcY,
				     int maskX, int maskY,
				     int dstX, int dstY,
				     int w, int h)
d1911 3
a1913 2
    int srcXend, srcYend, maskXend, maskYend;
    PictVector v;
d1918 20
a1937 2
    /*ErrorF("RadeonComposite (%d,%d) (%d,%d) (%d,%d) (%d,%d)\n",
	   srcX, srcY, maskX, maskY,dstX, dstY, w, h);*/
a1938 4
    srcXend = srcX + w;
    srcYend = srcY + h;
    maskXend = maskX + w;
    maskYend = maskY + h;
d1940 4
a1943 12
	v.vector[0] = IntToxFixed(srcX);
	v.vector[1] = IntToxFixed(srcY);
	v.vector[2] = xFixed1;
	PictureTransformPoint(transform[0], &v);
	srcX = xFixedToInt(v.vector[0]);
	srcY = xFixedToInt(v.vector[1]);
	v.vector[0] = IntToxFixed(srcXend);
	v.vector[1] = IntToxFixed(srcYend);
	v.vector[2] = xFixed1;
	PictureTransformPoint(transform[0], &v);
	srcXend = xFixedToInt(v.vector[0]);
	srcYend = xFixedToInt(v.vector[1]);
d1946 15
a1960 12
	v.vector[0] = IntToxFixed(maskX);
	v.vector[1] = IntToxFixed(maskY);
	v.vector[2] = xFixed1;
	PictureTransformPoint(transform[1], &v);
	maskX = xFixedToInt(v.vector[0]);
	maskY = xFixedToInt(v.vector[1]);
	v.vector[0] = IntToxFixed(maskXend);
	v.vector[1] = IntToxFixed(maskYend);
	v.vector[2] = xFixed1;
	PictureTransformPoint(transform[1], &v);
	maskXend = xFixedToInt(v.vector[0]);
	maskYend = xFixedToInt(v.vector[1]);
d1965 1
a1965 1
	BEGIN_RING(4 * VTX_DWORD_COUNT + 3);
d1967 8
a1974 4
			    4 * VTX_DWORD_COUNT + 1));
	OUT_RING(RADEON_CP_VC_FRMT_XY |
		 RADEON_CP_VC_FRMT_ST0 |
		 RADEON_CP_VC_FRMT_ST1);
d1981 5
a1985 1
	BEGIN_RING(4 * VTX_DWORD_COUNT + 2);
d1987 1
a1987 1
			    4 * VTX_DWORD_COUNT));
a1992 5
    VTX_OUT(dstX,     dstY,     srcX,    srcY,    maskX,    maskY);
    VTX_OUT(dstX,     dstY + h, srcX,    srcYend, maskX,    maskYend);
    VTX_OUT(dstX + w, dstY + h, srcXend, srcYend, maskXend, maskYend);
    VTX_OUT(dstX + w, dstY,     srcXend, srcY,    maskXend, maskY);
    ADVANCE_RING();
d1994 5
a1998 1
    BEGIN_ACCEL(1 + VTX_REG_COUNT * 4);
d2009 1
d2011 31
a2041 4
    VTX_OUT(dstX,     dstY,     srcX,    srcY,    maskX,    maskY);
    VTX_OUT(dstX,     dstY + h, srcX,    srcYend, maskX,    maskYend);
    VTX_OUT(dstX + w, dstY + h, srcXend, srcYend, maskXend, maskYend);
    VTX_OUT(dstX + w, dstY,     srcXend, srcY,    maskXend, maskY);
d2048 1
d2050 61
a2110 2
#ifdef ONLY_ONCE
static void RadeonDoneComposite(PixmapPtr pDst)
d2112 3
d2116 9
a2126 1
#endif /* ONLY_ONCE */
d2129 1
@


1.1
log
@Initial revision
@
text
@d207 2
a208 2
    if (pPict->repeat && ((w & (w - 1)) != 0 || (h & (h - 1)) != 0))
	RADEON_FALLBACK(("NPOT repeat unsupported (%dx%d)\n", w, h));
d462 2
a463 2
    if (pPict->repeat && ((w & (w - 1)) != 0 || (h & (h - 1)) != 0))
	RADEON_FALLBACK(("NPOT repeat unsupported (%dx%d)\n", w, h));
@


1.1.1.1
log
@Importing xf86-video-ati 6.6.3
@
text
@@
