head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.02.03.15.54.54;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2013.03.18.18.38.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.18.14.47.48;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.10.22.32.30;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.25.20.16.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@
/*
 * Copyright ® 2001 Keith Packard
 *
 * Partly based on code that is Copyright ® The XFree86 Project Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *    Michel Dänzer <michel@@tungstengraphics.com>
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include "uxa-priv.h"
#include "uxa-glamor.h"
#include <X11/fonts/fontstruct.h>
#include "dixfontstr.h"
#include "uxa.h"
#include "mipict.h"

static void
uxa_fill_spans(DrawablePtr pDrawable, GCPtr pGC, int n,
	       DDXPointPtr ppt, int *pwidth, int fSorted)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	RegionPtr pClip = fbGetCompositeClip(pGC);
	PixmapPtr dst_pixmap;
	BoxPtr pbox;
	int nbox;
	int x1, x2, y;
	int off_x, off_y;

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_fill_spans_nf(pDrawable,
						  pGC, n, ppt, pwidth, fSorted);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (!ok)
			goto fallback;

		return;
	}

	if (uxa_screen->force_fallback)
		goto fallback;

	if (pGC->fillStyle != FillSolid)
		goto fallback;

	dst_pixmap = uxa_get_offscreen_pixmap(pDrawable, &off_x, &off_y);
	if (!dst_pixmap)
		goto fallback;

	if (uxa_screen->info->check_solid &&
	    !uxa_screen->info->check_solid(pDrawable, pGC->alu, pGC->planemask))
		goto fallback;

	if (!(*uxa_screen->info->prepare_solid) (dst_pixmap,
						 pGC->alu,
						 pGC->planemask,
						 pGC->fgPixel))
		goto fallback;

	while (n--) {
		x1 = ppt->x;
		y = ppt->y;
		x2 = x1 + (int)*pwidth;
		ppt++;
		pwidth++;

		nbox = REGION_NUM_RECTS(pClip);
		pbox = REGION_RECTS(pClip);
		while (nbox--) {
			int X1 = x1, X2 = x2;
			if (X1 < pbox->x1)
				X1 = pbox->x1;

			if (X2 > pbox->x2)
				X2 = pbox->x2;

			if (X2 > X1 && pbox->y1 <= y && pbox->y2 > y)
				(*uxa_screen->info->solid) (dst_pixmap,
							    X1 + off_x, y + off_y,
							    X2 + off_x, y + 1 + off_y);
			pbox++;
		}
	}
	(*uxa_screen->info->done_solid) (dst_pixmap);

	return;

fallback:
	uxa_check_fill_spans(pDrawable, pGC, n, ppt, pwidth, fSorted);
}

static Bool
uxa_do_put_image(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
		 int w, int h, int format, char *bits, int src_stride)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);
	PixmapPtr pPix;
	RegionPtr pClip;
	BoxPtr pbox;
	int nbox;
	int xoff, yoff;
	int bpp = pDrawable->bitsPerPixel;

	/* Don't bother with under 8bpp, XYPixmaps. */
	if (format != ZPixmap || bpp < 8)
		return FALSE;

	if (uxa_screen->force_fallback)
		return FALSE;

	if (!uxa_screen->info->put_image)
		return FALSE;

	/* Only accelerate copies: no rop or planemask. */
	if (!UXA_PM_IS_SOLID(pDrawable, pGC->planemask) || pGC->alu != GXcopy)
		return FALSE;

	pPix = uxa_get_offscreen_pixmap(pDrawable, &xoff, &yoff);
	if (!pPix)
		return FALSE;

	x += pDrawable->x;
	y += pDrawable->y;

	pClip = fbGetCompositeClip(pGC);
	for (nbox = REGION_NUM_RECTS(pClip),
	     pbox = REGION_RECTS(pClip); nbox--; pbox++) {
		int x1 = x;
		int y1 = y;
		int x2 = x + w;
		int y2 = y + h;
		char *src;
		Bool ok;

		if (x1 < pbox->x1)
			x1 = pbox->x1;
		if (y1 < pbox->y1)
			y1 = pbox->y1;
		if (x2 > pbox->x2)
			x2 = pbox->x2;
		if (y2 > pbox->y2)
			y2 = pbox->y2;
		if (x1 >= x2 || y1 >= y2)
			continue;

		src = bits + (y1 - y) * src_stride + (x1 - x) * (bpp / 8);
		ok = uxa_screen->info->put_image(pPix, x1 + xoff, y1 + yoff,
						 x2 - x1, y2 - y1, src,
						 src_stride);
		/* If we fail to accelerate the upload, fall back to using
		 * unaccelerated fb calls.
		 */
		if (!ok) {
			FbStip *dst;
			FbStride dst_stride;
			int dstBpp;
			int dstXoff, dstYoff;

			if (!uxa_prepare_access(pDrawable, UXA_ACCESS_RW))
				return FALSE;

			fbGetStipDrawable(pDrawable, dst, dst_stride, dstBpp,
					  dstXoff, dstYoff);

			fbBltStip((FbStip *) bits +
				  (y1 - y) * (src_stride / sizeof(FbStip)),
				  src_stride / sizeof(FbStip),
				  (x1 - x) * dstBpp,
				  dst + (y1 + dstYoff) * dst_stride, dst_stride,
				  (x1 + dstXoff) * dstBpp, (x2 - x1) * dstBpp,
				  y2 - y1, GXcopy, FB_ALLONES, dstBpp);

			uxa_finish_access(pDrawable, UXA_ACCESS_RW);
		}
	}


	return TRUE;
}

static void
uxa_put_image(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
	      int w, int h, int leftPad, int format, char *bits)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_put_image_nf(pDrawable,
						 pGC, depth, x, y, w, h,
						 leftPad, format, bits);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}
		if (!ok)
			goto fallback;

		return;
	}

	if (!uxa_do_put_image(pDrawable, pGC, depth, x, y, w, h, format, bits,
			      PixmapBytePad(w, pDrawable->depth))) {
fallback:
		uxa_check_put_image(pDrawable, pGC, depth, x, y, w, h, leftPad,
				    format, bits);
	}
}

static Bool inline
uxa_copy_n_to_n_two_dir(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
			GCPtr pGC, BoxPtr pbox, int nbox, int dx, int dy)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pDstDrawable->pScreen);
	PixmapPtr pSrcPixmap, pDstPixmap;
	int src_off_x, src_off_y, dst_off_x, dst_off_y;
	int dirsetup;

	/* Need to get both pixmaps to call the driver routines */
	pSrcPixmap =
	    uxa_get_offscreen_pixmap(pSrcDrawable, &src_off_x, &src_off_y);
	pDstPixmap =
	    uxa_get_offscreen_pixmap(pDstDrawable, &dst_off_x, &dst_off_y);
	if (!pSrcPixmap || !pDstPixmap)
		return FALSE;

	/*
	 * Now the case of a chip that only supports xdir = ydir = 1 or
	 * xdir = ydir = -1, but we have xdir != ydir.
	 */
	dirsetup = 0;		/* No direction set up yet. */
	for (; nbox; pbox++, nbox--) {
		if (dx >= 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
			/* Do a xdir = ydir = -1 blit instead. */
			if (dirsetup != -1) {
				if (dirsetup != 0)
					uxa_screen->info->done_copy(pDstPixmap);
				dirsetup = -1;
				if (!(*uxa_screen->info->prepare_copy)
				    (pSrcPixmap, pDstPixmap, -1, -1,
				     pGC ? pGC->alu : GXcopy,
				     pGC ? pGC->planemask : FB_ALLONES))
					return FALSE;
			}
			(*uxa_screen->info->copy) (pDstPixmap,
						   src_off_x + pbox->x1 + dx,
						   src_off_y + pbox->y1 + dy,
						   dst_off_x + pbox->x1,
						   dst_off_y + pbox->y1,
						   pbox->x2 - pbox->x1,
						   pbox->y2 - pbox->y1);
		} else if (dx < 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
			/* Do a xdir = ydir = 1 blit instead. */
			if (dirsetup != 1) {
				if (dirsetup != 0)
					uxa_screen->info->done_copy(pDstPixmap);
				dirsetup = 1;
				if (!(*uxa_screen->info->prepare_copy)
				    (pSrcPixmap, pDstPixmap, 1, 1,
				     pGC ? pGC->alu : GXcopy,
				     pGC ? pGC->planemask : FB_ALLONES))
					return FALSE;
			}
			(*uxa_screen->info->copy) (pDstPixmap,
						   src_off_x + pbox->x1 + dx,
						   src_off_y + pbox->y1 + dy,
						   dst_off_x + pbox->x1,
						   dst_off_y + pbox->y1,
						   pbox->x2 - pbox->x1,
						   pbox->y2 - pbox->y1);
		} else if (dx >= 0) {
			/*
			 * xdir = 1, ydir = -1.
			 * Perform line-by-line xdir = ydir = 1 blits, going up.
			 */
			int i;
			if (dirsetup != 1) {
				if (dirsetup != 0)
					uxa_screen->info->done_copy(pDstPixmap);
				dirsetup = 1;
				if (!(*uxa_screen->info->prepare_copy)
				    (pSrcPixmap, pDstPixmap, 1, 1,
				     pGC ? pGC->alu : GXcopy,
				     pGC ? pGC->planemask : FB_ALLONES))
					return FALSE;
			}
			for (i = pbox->y2 - pbox->y1 - 1; i >= 0; i--)
				(*uxa_screen->info->copy) (pDstPixmap,
							   src_off_x +
							   pbox->x1 + dx,
							   src_off_y +
							   pbox->y1 + dy + i,
							   dst_off_x + pbox->x1,
							   dst_off_y +
							   pbox->y1 + i,
							   pbox->x2 - pbox->x1,
							   1);
		} else {
			/*
			 * xdir = -1, ydir = 1.
			 * Perform line-by-line xdir = ydir = -1 blits,
			 * going down.
			 */
			int i;
			if (dirsetup != -1) {
				if (dirsetup != 0)
					uxa_screen->info->done_copy(pDstPixmap);
				dirsetup = -1;
				if (!(*uxa_screen->info->prepare_copy)
				    (pSrcPixmap, pDstPixmap, -1, -1,
				     pGC ? pGC->alu : GXcopy,
				     pGC ? pGC->planemask : FB_ALLONES))
					return FALSE;
			}
			for (i = 0; i < pbox->y2 - pbox->y1; i++)
				(*uxa_screen->info->copy) (pDstPixmap,
							   src_off_x +
							   pbox->x1 + dx,
							   src_off_y +
							   pbox->y1 + dy + i,
							   dst_off_x + pbox->x1,
							   dst_off_y +
							   pbox->y1 + i,
							   pbox->x2 - pbox->x1,
							   1);
		}
	}
	if (dirsetup != 0)
		uxa_screen->info->done_copy(pDstPixmap);
	return TRUE;
}

void
uxa_copy_n_to_n(DrawablePtr pSrcDrawable,
		DrawablePtr pDstDrawable,
		GCPtr pGC,
		BoxPtr pbox,
		int nbox,
		int dx,
		int dy,
		Bool reverse, Bool upsidedown, Pixel bitplane, void *closure)
{
	ScreenPtr screen = pDstDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	int src_off_x, src_off_y;
	int dst_off_x, dst_off_y;
	PixmapPtr pSrcPixmap, pDstPixmap;

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pSrcDrawable, UXA_GLAMOR_ACCESS_RO)) {
			if (uxa_prepare_access(pDstDrawable, UXA_GLAMOR_ACCESS_RW)) {
				ok = glamor_copy_n_to_n_nf(pSrcDrawable, pDstDrawable,
							   pGC, pbox, nbox, dx, dy,
							   reverse, upsidedown, bitplane,
							   closure);
				uxa_finish_access(pDstDrawable, UXA_GLAMOR_ACCESS_RW);
			}
			uxa_finish_access(pSrcDrawable, UXA_GLAMOR_ACCESS_RO);
		}

		if (!ok)
			goto fallback;

		return;
	}

	if (uxa_screen->force_fallback)
		goto fallback;

	pSrcPixmap = uxa_get_drawable_pixmap(pSrcDrawable);
	pDstPixmap = uxa_get_drawable_pixmap(pDstDrawable);
	if (!pSrcPixmap || !pDstPixmap)
		goto fallback;

	if (uxa_screen->info->check_copy &&
	    !uxa_screen->info->check_copy(pSrcPixmap, pDstPixmap,
					  pGC ? pGC->alu : GXcopy,
					  pGC ? pGC->planemask : FB_ALLONES))
		goto fallback;

	uxa_get_drawable_deltas(pSrcDrawable, pSrcPixmap, &src_off_x,
				&src_off_y);
	uxa_get_drawable_deltas(pDstDrawable, pDstPixmap, &dst_off_x,
				&dst_off_y);

	/* Mixed directions must be handled specially if the card is lame */
	if ((uxa_screen->info->flags & UXA_TWO_BITBLT_DIRECTIONS) &&
	    reverse != upsidedown) {
		if (uxa_copy_n_to_n_two_dir
		    (pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy))
			return;
		goto fallback;
	}

	if (!uxa_pixmap_is_offscreen(pDstPixmap)) {
		int stride, bpp;
		char *dst;

		if (!uxa_pixmap_is_offscreen(pSrcPixmap))
			goto fallback;

		if (!uxa_screen->info->get_image)
			goto fallback;

		/* Don't bother with under 8bpp, XYPixmaps. */
		bpp = pSrcPixmap->drawable.bitsPerPixel;
		if (bpp != pDstDrawable->bitsPerPixel || bpp < 8)
			goto fallback;

		/* Only accelerate copies: no rop or planemask. */
		if (pGC && (!UXA_PM_IS_SOLID(pSrcDrawable, pGC->planemask) || pGC->alu != GXcopy))
			goto fallback;

		dst = pDstPixmap->devPrivate.ptr;
		stride = pDstPixmap->devKind;
		bpp /= 8;
		while (nbox--) {
			if (!uxa_screen->info->get_image(pSrcPixmap,
							 pbox->x1 + dx + src_off_x,
							 pbox->y1 + dy + src_off_y,
							 pbox->x2 - pbox->x1,
							 pbox->y2 - pbox->y1,
							 (char *) dst +
							 (pbox->y1 + dst_off_y) * stride +
							 (pbox->x1 + dst_off_x) * bpp,
							 stride))
				goto fallback;

			pbox++;
		}

		return;
	}

	if (uxa_pixmap_is_offscreen(pSrcPixmap)) {
	    if (!(*uxa_screen->info->prepare_copy) (pSrcPixmap, pDstPixmap,
						reverse ? -1 : 1,
						upsidedown ? -1 : 1,
						pGC ? pGC->alu : GXcopy,
						pGC ? pGC->
						planemask : FB_ALLONES))
		goto fallback;

	    while (nbox--) {
		(*uxa_screen->info->copy) (pDstPixmap,
					   pbox->x1 + dx + src_off_x,
					   pbox->y1 + dy + src_off_y,
					   pbox->x1 + dst_off_x,
					   pbox->y1 + dst_off_y,
					   pbox->x2 - pbox->x1,
					   pbox->y2 - pbox->y1);
		pbox++;
	    }

	    (*uxa_screen->info->done_copy) (pDstPixmap);
	} else {
	    int stride, bpp;
	    char *src;

	    if (!uxa_screen->info->put_image)
		goto fallback;

	    /* Don't bother with under 8bpp, XYPixmaps. */
	    bpp = pSrcPixmap->drawable.bitsPerPixel;
	    if (bpp != pDstDrawable->bitsPerPixel || bpp < 8)
		goto fallback;

	    /* Only accelerate copies: no rop or planemask. */
	    if (pGC && (!UXA_PM_IS_SOLID(pSrcDrawable, pGC->planemask) || pGC->alu != GXcopy))
		goto fallback;

	    src = pSrcPixmap->devPrivate.ptr;
	    stride = pSrcPixmap->devKind;
	    bpp /= 8;
	    while (nbox--) {
		if (!uxa_screen->info->put_image(pDstPixmap,
						 pbox->x1 + dst_off_x,
						 pbox->y1 + dst_off_y,
						 pbox->x2 - pbox->x1,
						 pbox->y2 - pbox->y1,
						 (char *) src +
						 (pbox->y1 + dy + src_off_y) * stride +
						 (pbox->x1 + dx + src_off_x) * bpp,
						 stride))
		    goto fallback;

		pbox++;
	    }
	}

	return;

fallback:
	UXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrcDrawable, pDstDrawable,
		      uxa_drawable_location(pSrcDrawable),
		      uxa_drawable_location(pDstDrawable)));
	if (uxa_prepare_access(pDstDrawable, UXA_ACCESS_RW)) {
		if (pSrcDrawable == pDstDrawable ||
		    uxa_prepare_access(pSrcDrawable, UXA_ACCESS_RO)) {
			fbCopyNtoN(pSrcDrawable, pDstDrawable, pGC, pbox, nbox,
				   dx, dy, reverse, upsidedown, bitplane,
				   closure);
			if (pSrcDrawable != pDstDrawable)
				uxa_finish_access(pSrcDrawable, UXA_ACCESS_RO);
		}
		uxa_finish_access(pDstDrawable, UXA_ACCESS_RW);
	}
}

RegionPtr
uxa_copy_area(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
	      int srcx, int srcy, int width, int height, int dstx, int dsty)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pDstDrawable->pScreen);

	if (uxa_screen->force_fallback) {
		return uxa_check_copy_area(pSrcDrawable, pDstDrawable, pGC,
					   srcx, srcy, width, height, dstx,
					   dsty);
	}

	return miDoCopy(pSrcDrawable, pDstDrawable, pGC,
			srcx, srcy, width, height,
			dstx, dsty, uxa_copy_n_to_n, 0, NULL);
}

static void
uxa_poly_point(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
	       DDXPointPtr ppt)
{
	int i;
	xRectangle *prect;
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_poly_point_nf(pDrawable, pGC, mode, npt, ppt);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (ok)
			return;
	}

	/* If we can't reuse the current GC as is, don't bother accelerating the
	 * points.
	 */
	if (pGC->fillStyle != FillSolid) {
		uxa_check_poly_point(pDrawable, pGC, mode, npt, ppt);
		return;
	}

	prect = malloc(sizeof(xRectangle) * npt);
	if (!prect)
		return;
	for (i = 0; i < npt; i++) {
		prect[i].x = ppt[i].x;
		prect[i].y = ppt[i].y;
		if (i > 0 && mode == CoordModePrevious) {
			prect[i].x += prect[i - 1].x;
			prect[i].y += prect[i - 1].y;
		}
		prect[i].width = 1;
		prect[i].height = 1;
	}
	pGC->ops->PolyFillRect(pDrawable, pGC, npt, prect);
	free(prect);
}

/**
 * uxa_poly_lines() checks if it can accelerate the lines as a group of
 * horizontal or vertical lines (rectangles), and uses existing rectangle fill
 * acceleration if so.
 */
static void
uxa_poly_lines(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
	       DDXPointPtr ppt)
{
	xRectangle *prect;
	int x1, x2, y1, y2;
	int i;
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_poly_lines_nf(pDrawable, pGC, mode, npt, ppt);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (ok)
			return;
	}

	/* Don't try to do wide lines or non-solid fill style. */
	if (pGC->lineWidth != 0 || pGC->lineStyle != LineSolid ||
	    pGC->fillStyle != FillSolid) {
		uxa_check_poly_lines(pDrawable, pGC, mode, npt, ppt);
		return;
	}

	prect = malloc(sizeof(xRectangle) * (npt - 1));
	if (!prect)
		return;
	x1 = ppt[0].x;
	y1 = ppt[0].y;
	/* If we have any non-horizontal/vertical, fall back. */
	for (i = 0; i < npt - 1; i++) {
		if (mode == CoordModePrevious) {
			x2 = x1 + ppt[i + 1].x;
			y2 = y1 + ppt[i + 1].y;
		} else {
			x2 = ppt[i + 1].x;
			y2 = ppt[i + 1].y;
		}

		if (x1 != x2 && y1 != y2) {
			free(prect);
			uxa_check_poly_lines(pDrawable, pGC, mode, npt, ppt);
			return;
		}

		if (x1 < x2) {
			prect[i].x = x1;
			prect[i].width = x2 - x1 + 1;
		} else {
			prect[i].x = x2;
			prect[i].width = x1 - x2 + 1;
		}
		if (y1 < y2) {
			prect[i].y = y1;
			prect[i].height = y2 - y1 + 1;
		} else {
			prect[i].y = y2;
			prect[i].height = y1 - y2 + 1;
		}

		x1 = x2;
		y1 = y2;
	}
	pGC->ops->PolyFillRect(pDrawable, pGC, npt - 1, prect);
	free(prect);
}

/**
 * uxa_poly_segment() checks if it can accelerate the lines as a group of
 * horizontal or vertical lines (rectangles), and uses existing rectangle fill
 * acceleration if so.
 */
static void
uxa_poly_segment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSeg)
{
	xRectangle *prect;
	int i;
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_poly_segment_nf(pDrawable, pGC, nseg, pSeg);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (ok)
			return;
	}

	/* Don't try to do wide lines or non-solid fill style. */
	if (pGC->lineWidth != 0 || pGC->lineStyle != LineSolid ||
	    pGC->fillStyle != FillSolid) {
		uxa_check_poly_segment(pDrawable, pGC, nseg, pSeg);
		return;
	}

	/* If we have any non-horizontal/vertical, fall back. */
	for (i = 0; i < nseg; i++) {
		if (pSeg[i].x1 != pSeg[i].x2 && pSeg[i].y1 != pSeg[i].y2) {
			uxa_check_poly_segment(pDrawable, pGC, nseg, pSeg);
			return;
		}
	}

	prect = malloc(sizeof(xRectangle) * nseg);
	if (!prect)
		return;
	for (i = 0; i < nseg; i++) {
		if (pSeg[i].x1 < pSeg[i].x2) {
			prect[i].x = pSeg[i].x1;
			prect[i].width = pSeg[i].x2 - pSeg[i].x1 + 1;
		} else {
			prect[i].x = pSeg[i].x2;
			prect[i].width = pSeg[i].x1 - pSeg[i].x2 + 1;
		}
		if (pSeg[i].y1 < pSeg[i].y2) {
			prect[i].y = pSeg[i].y1;
			prect[i].height = pSeg[i].y2 - pSeg[i].y1 + 1;
		} else {
			prect[i].y = pSeg[i].y2;
			prect[i].height = pSeg[i].y1 - pSeg[i].y2 + 1;
		}

		/* don't paint last pixel */
		if (pGC->capStyle == CapNotLast) {
			if (prect[i].width == 1)
				prect[i].height--;
			else
				prect[i].width--;
		}
	}
	pGC->ops->PolyFillRect(pDrawable, pGC, nseg, prect);
	free(prect);
}

static Bool uxa_fill_region_solid(DrawablePtr pDrawable, RegionPtr pRegion,
				  Pixel pixel, CARD32 planemask, CARD32 alu);

static void
uxa_poly_fill_rect(DrawablePtr pDrawable,
		   GCPtr pGC, int nrect, xRectangle * prect)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);
	RegionPtr pClip = fbGetCompositeClip(pGC);
	PixmapPtr pPixmap;
	RegionPtr pReg;
	BoxPtr pbox;
	int fullX1, fullX2, fullY1, fullY2;
	int xoff, yoff;
	int xorg, yorg;
	int n;

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_poly_fill_rect_nf(pDrawable, pGC, nrect, prect);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (!ok)
			uxa_check_poly_fill_rect(pDrawable, pGC, nrect, prect);

		return;
	}

	/* Compute intersection of rects and clip region */
	pReg = RECTS_TO_REGION(pScreen, nrect, prect, CT_UNSORTED);
	REGION_TRANSLATE(pScreen, pReg, pDrawable->x, pDrawable->y);
	REGION_INTERSECT(pScreen, pReg, pClip, pReg);

	if (!REGION_NUM_RECTS(pReg))
		goto out;

	if (uxa_screen->force_fallback)
		goto fallback;

	pPixmap = uxa_get_offscreen_pixmap (pDrawable, &xoff, &yoff);
	if (!pPixmap)
		goto fallback;

	/* For ROPs where overlaps don't matter, convert rectangles to region
	 * and call uxa_fill_region_{solid,tiled}.
	 */
	if ((pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled) &&
	    (nrect == 1 || pGC->alu == GXcopy || pGC->alu == GXclear ||
	     pGC->alu == GXnoop || pGC->alu == GXcopyInverted ||
	     pGC->alu == GXset)) {
		if (((pGC->fillStyle == FillSolid || pGC->tileIsPixel) &&
		     uxa_fill_region_solid(pDrawable, pReg,
					   pGC->fillStyle ==
					   FillSolid ? pGC->fgPixel : pGC->tile.
					   pixel, pGC->planemask, pGC->alu))
		    || (pGC->fillStyle == FillTiled && !pGC->tileIsPixel
			&& uxa_fill_region_tiled(pDrawable, pReg,
						 pGC->tile.pixmap, &pGC->patOrg,
						 pGC->planemask, pGC->alu))) {
			goto out;
		}
	}

	if (pGC->fillStyle != FillSolid &&
	    !(pGC->tileIsPixel && pGC->fillStyle == FillTiled)) {
		goto fallback;
	}

	if (uxa_screen->info->check_solid &&
	    !uxa_screen->info->check_solid(pDrawable, pGC->alu, pGC->planemask)) {
		goto fallback;
	}

	if (!(*uxa_screen->info->prepare_solid) (pPixmap,
						 pGC->alu,
						 pGC->planemask,
						 pGC->fgPixel)) {
fallback:
		uxa_check_poly_fill_rect(pDrawable, pGC, nrect, prect);
		goto out;
	}

	xorg = pDrawable->x;
	yorg = pDrawable->y;

	while (nrect--) {
		fullX1 = prect->x + xorg;
		fullY1 = prect->y + yorg;
		fullX2 = fullX1 + (int)prect->width;
		fullY2 = fullY1 + (int)prect->height;
		prect++;

		n = REGION_NUM_RECTS(pClip);
		pbox = REGION_RECTS(pClip);
		/*
		 * clip the rectangle to each box in the clip region
		 * this is logically equivalent to calling Intersect(),
		 * but rectangles may overlap each other here.
		 */
		while (n--) {
			int x1 = fullX1;
			int x2 = fullX2;
			int y1 = fullY1;
			int y2 = fullY2;

			if (pbox->x1 > x1)
				x1 = pbox->x1;
			if (pbox->x2 < x2)
				x2 = pbox->x2;
			if (pbox->y1 > y1)
				y1 = pbox->y1;
			if (pbox->y2 < y2)
				y2 = pbox->y2;
			pbox++;

			if (x1 >= x2 || y1 >= y2)
				continue;

			(*uxa_screen->info->solid) (pPixmap,
						    x1 + xoff,
						    y1 + yoff,
						    x2 + xoff,
						    y2 + yoff);
		}
	}
	(*uxa_screen->info->done_solid) (pPixmap);

out:
	REGION_UNINIT(pScreen, pReg);
	REGION_DESTROY(pScreen, pReg);
}

void
uxa_get_spans(DrawablePtr pDrawable,
	      int wMax,
	      DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_get_spans_nf(pDrawable, wMax, ppt,
						 pwidth, nspans, pdstStart);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (!ok)
			goto fallback;

		return;
	}

fallback:
	uxa_check_get_spans(pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
}

static void
uxa_set_spans(DrawablePtr pDrawable, GCPtr gc, char *src,
                 DDXPointPtr points, int *widths, int n, int sorted)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_set_spans_nf(pDrawable, gc, src,
						 points, widths, n, sorted);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (!ok)
			goto fallback;

		return;
	}

fallback:
	uxa_check_set_spans(pDrawable, gc, src, points, widths, n, sorted);
}

static RegionPtr
uxa_copy_plane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
	       int srcx, int srcy, int w, int h, int dstx, int dsty,
	       unsigned long bitPlane)
{
	ScreenPtr screen = pDst->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;
		RegionPtr region;

		if (uxa_prepare_access(pDst, UXA_GLAMOR_ACCESS_RW)) {
			if (uxa_prepare_access(pSrc, UXA_GLAMOR_ACCESS_RO)) {
				ok = glamor_copy_plane_nf(pSrc, pDst, pGC, srcx, srcy, w, h,
							  dstx, dsty, bitPlane, &region);
				uxa_finish_access(pSrc, UXA_GLAMOR_ACCESS_RO);
			}
			uxa_finish_access(pDst, UXA_GLAMOR_ACCESS_RW);
		}
		if (!ok)
			goto fallback;
		return region;
	}

fallback:
	return uxa_check_copy_plane(pSrc, pDst, pGC, srcx, srcy, w, h,
				    dstx, dsty, bitPlane);
}

static void
uxa_image_glyph_blt(DrawablePtr pDrawable, GCPtr pGC,
		    int x, int y, unsigned int nglyph,
		    CharInfoPtr * ppci, pointer pglyphBase)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_image_glyph_blt_nf(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}
		if (!ok)
			goto fallback;
		return;
	}

fallback:
	uxa_check_image_glyph_blt(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
}

static void
uxa_poly_glyph_blt(DrawablePtr pDrawable, GCPtr pGC,
		   int x, int y, unsigned int nglyph,
		   CharInfoPtr * ppci, pointer pglyphBase)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_poly_glyph_blt_nf(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}
		if (!ok)
			goto fallback;
		return;
	}

fallback:
	uxa_check_poly_glyph_blt(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
}

static void
uxa_push_pixels(GCPtr pGC, PixmapPtr pBitmap,
		DrawablePtr pDrawable, int w, int h, int x, int y)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok = 0;

		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			if (uxa_prepare_access(&pBitmap->drawable, UXA_GLAMOR_ACCESS_RO)) {
				ok = glamor_push_pixels_nf(pGC, pBitmap, pDrawable, w, h, x, y);
				uxa_finish_access(&pBitmap->drawable, UXA_GLAMOR_ACCESS_RO);
			}
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}
		if (!ok)
			goto fallback;
		return;
	}

fallback:
	uxa_check_push_pixels(pGC, pBitmap, pDrawable, w, h, x, y);
}

const GCOps uxa_ops = {
	uxa_fill_spans,
	uxa_set_spans,
	uxa_put_image,
	uxa_copy_area,
	uxa_copy_plane,
	uxa_poly_point,
	uxa_poly_lines,
	uxa_poly_segment,
	miPolyRectangle,
	uxa_check_poly_arc,
	miFillPolygon,
	uxa_poly_fill_rect,
	miPolyFillArc,
	miPolyText8,
	miPolyText16,
	miImageText8,
	miImageText16,
	uxa_image_glyph_blt,
	uxa_poly_glyph_blt,
	uxa_push_pixels,
};

void uxa_copy_window(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
	RegionRec rgnDst;
	int dx, dy;
	PixmapPtr pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);

	dx = ptOldOrg.x - pWin->drawable.x;
	dy = ptOldOrg.y - pWin->drawable.y;
	REGION_TRANSLATE(pWin->drawable.pScreen, prgnSrc, -dx, -dy);

	REGION_INIT(pWin->drawable.pScreen, &rgnDst, NullBox, 0);

	REGION_INTERSECT(pWin->drawable.pScreen, &rgnDst, &pWin->borderClip,
			 prgnSrc);
#ifdef COMPOSITE
	if (pPixmap->screen_x || pPixmap->screen_y)
		REGION_TRANSLATE(pWin->drawable.pScreen, &rgnDst,
				 -pPixmap->screen_x, -pPixmap->screen_y);
#endif

	miCopyRegion(&pPixmap->drawable, &pPixmap->drawable,
		     NULL, &rgnDst, dx, dy, uxa_copy_n_to_n, 0, NULL);

	REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
}

static Bool
uxa_fill_region_solid(DrawablePtr pDrawable,
		      RegionPtr pRegion,
		      Pixel pixel, CARD32 planemask, CARD32 alu)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	PixmapPtr pixmap;
	int xoff, yoff;
	int nbox;
	BoxPtr pBox;
	Bool ret = FALSE;

	pixmap = uxa_get_offscreen_pixmap(pDrawable, &xoff, &yoff);
	if (!pixmap)
		return FALSE;

	REGION_TRANSLATE(screen, pRegion, xoff, yoff);

	nbox = REGION_NUM_RECTS(pRegion);
	pBox = REGION_RECTS(pRegion);

	if (uxa_screen->info->check_solid &&
	    !uxa_screen->info->check_solid(&pixmap->drawable, alu, planemask))
		goto err;

	if (!uxa_screen->info->prepare_solid(pixmap, alu, planemask, pixel))
		goto err;

	while (nbox--) {
		uxa_screen->info->solid(pixmap,
					pBox->x1, pBox->y1,
					pBox->x2, pBox->y2);
		pBox++;
	}
	uxa_screen->info->done_solid(pixmap);
	ret = TRUE;

err:
	REGION_TRANSLATE(screen, pRegion, -xoff, -yoff);
	return ret;
}

/* Try to do an accelerated tile of the pTile into pRegion of pDrawable.
 * Based on fbFillRegionTiled(), fbTile().
 */
Bool
uxa_fill_region_tiled(DrawablePtr pDrawable,
		      RegionPtr pRegion,
		      PixmapPtr pTile,
		      DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);
	PixmapPtr pPixmap;
	int xoff, yoff;
	int tileWidth, tileHeight;
	int nbox = REGION_NUM_RECTS(pRegion);
	BoxPtr pBox = REGION_RECTS(pRegion);
	Bool ret = FALSE;

	tileWidth = pTile->drawable.width;
	tileHeight = pTile->drawable.height;

	/* If we're filling with a solid color, grab it out and go to
	 * FillRegionsolid, saving numerous copies.
	 */
	if (tileWidth == 1 && tileHeight == 1)
		return uxa_fill_region_solid(pDrawable, pRegion,
					     uxa_get_pixmap_first_pixel(pTile),
					     planemask, alu);

	pPixmap = uxa_get_offscreen_pixmap(pDrawable, &xoff, &yoff);
	if (!pPixmap || !uxa_pixmap_is_offscreen(pTile))
		goto out;

	if (uxa_screen->info->check_copy &&
	    !uxa_screen->info->check_copy(pTile, pPixmap, alu, planemask))
		return FALSE;

	REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);

	if ((*uxa_screen->info->prepare_copy) (pTile, pPixmap, 1, 1, alu,
					       planemask)) {
		while (nbox--) {
			int height = pBox->y2 - pBox->y1;
			int dstY = pBox->y1;
			int tileY;

			modulus(dstY - yoff - pDrawable->y - pPatOrg->y,
				tileHeight, tileY);

			while (height > 0) {
				int width = pBox->x2 - pBox->x1;
				int dstX = pBox->x1;
				int tileX;
				int h = tileHeight - tileY;

				if (h > height)
					h = height;
				height -= h;

				modulus(dstX - xoff - pDrawable->x - pPatOrg->x,
					tileWidth, tileX);

				while (width > 0) {
					int w = tileWidth - tileX;
					if (w > width)
						w = width;
					width -= w;

					(*uxa_screen->info->copy) (pPixmap,
								   tileX, tileY,
								   dstX, dstY,
								   w, h);
					dstX += w;
					tileX = 0;
				}
				dstY += h;
				tileY = 0;
			}
			pBox++;
		}
		(*uxa_screen->info->done_copy) (pPixmap);

		ret = TRUE;
	}

out:
	REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);

	return ret;
}

/**
 * Accelerates GetImage for solid ZPixmap downloads from framebuffer memory.
 *
 * This is probably the only case we actually care about.  The rest fall through
 * to migration and fbGetImage, which hopefully will result in migration pushing
 * the pixmap out of framebuffer.
 */
void
uxa_get_image(DrawablePtr pDrawable, int x, int y, int w, int h,
	      unsigned int format, unsigned long planeMask, char *d)
{
	ScreenPtr screen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	BoxRec Box;
	PixmapPtr pPix = uxa_get_drawable_pixmap(pDrawable);
	int xoff, yoff;
	Bool ok;

	uxa_get_drawable_deltas(pDrawable, pPix, &xoff, &yoff);

	Box.x1 = pDrawable->y + x + xoff;
	Box.y1 = pDrawable->y + y + yoff;
	Box.x2 = Box.x1 + w;
	Box.y2 = Box.y1 + h;

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		ok = 0;
		if (uxa_prepare_access(pDrawable, UXA_GLAMOR_ACCESS_RW)) {
			ok = glamor_get_image_nf(pDrawable, x, y, w, h,
						 format, planeMask, d);
			uxa_finish_access(pDrawable, UXA_GLAMOR_ACCESS_RW);
		}

		if (!ok)
			goto fallback;

		return;
	}

	if (uxa_screen->force_fallback)
		goto fallback;

	pPix = uxa_get_offscreen_pixmap(pDrawable, &xoff, &yoff);

	if (pPix == NULL || uxa_screen->info->get_image == NULL)
		goto fallback;

	/* Only cover the ZPixmap, solid copy case. */
	if (format != ZPixmap || !UXA_PM_IS_SOLID(pDrawable, planeMask))
		goto fallback;

	/* Only try to handle the 8bpp and up cases, since we don't want to
	 * think about <8bpp.
	 */
	if (pDrawable->bitsPerPixel < 8)
		goto fallback;

	ok = uxa_screen->info->get_image(pPix, pDrawable->x + x + xoff,
					 pDrawable->y + y + yoff, w, h, d,
					 PixmapBytePad(w, pDrawable->depth));
	if (ok)
		return;

fallback:
	UXA_FALLBACK(("from %p (%c)\n", pDrawable,
		      uxa_drawable_location(pDrawable)));

	if (uxa_prepare_access(pDrawable, UXA_ACCESS_RO)) {
		fbGetImage(pDrawable, x, y, w, h, format, planeMask, d);
		uxa_finish_access(pDrawable, UXA_ACCESS_RO);
	}

	return;
}
@


1.5
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.4
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d35 1
d54 16
a69 1
	if (uxa_screen->swappedOut || uxa_screen->force_fallback)
d99 11
a109 15
			if (pbox->y1 > y || pbox->y2 <= y)
				continue;

			if (x1 < pbox->x1)
				x1 = pbox->x1;

			if (x2 > pbox->x2)
				x2 = pbox->x2;

			if (x2 <= x1)
				continue;

			(*uxa_screen->info->solid) (dst_pixmap,
						    x1 + off_x, y + off_y,
						    x2 + off_x, y + 1 + off_y);
d126 1
a126 1
	PixmapPtr pPix = uxa_get_drawable_pixmap(pDrawable);
d137 1
a137 1
	if (uxa_screen->swappedOut || uxa_screen->force_fallback)
d202 1
a202 1
			uxa_finish_access(pDrawable);
d214 17
d232 2
a233 1
			      PixmapBytePad(w, pDrawable->depth)))
d236 1
d378 21
a398 1
	if (uxa_screen->swappedOut || uxa_screen->force_fallback)
d535 1
a535 1
				uxa_finish_access(pSrcDrawable);
d537 1
a537 1
		uxa_finish_access(pDstDrawable);
d547 1
a547 1
	if (uxa_screen->swappedOut || uxa_screen->force_fallback) {
d564 13
d615 13
d689 13
d759 2
a760 1
	register BoxPtr pbox;
d765 14
a778 1
	RegionPtr pReg = RECTS_TO_REGION(pScreen, nrect, prect, CT_UNSORTED);
d781 1
d788 1
a788 1
	if (uxa_screen->swappedOut || uxa_screen->force_fallback)
d884 157
d1043 1
a1043 1
	uxa_check_set_spans,
d1046 1
a1046 1
	uxa_check_copy_plane,
d1059 3
a1061 3
	uxa_check_image_glyph_blt,
	uxa_check_poly_glyph_blt,
	uxa_check_push_pixels,
d1248 15
a1262 1
	if (uxa_screen->swappedOut || uxa_screen->force_fallback)
d1292 1
a1292 1
		uxa_finish_access(pDrawable);
@


1.3
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d1 1
a39 18
static CARD32
format_for_depth(int depth)
{
	switch (depth) {
	case 1: return PICT_a1;
	case 4: return PICT_a4;
	case 8: return PICT_a8;
	case 15: return PICT_x1r5g5b5;
	case 16: return PICT_r5g6b5;
	default:
	case 24: return PICT_x8r8g8b8;
#if 0
	case 30: return PICT_x2r10g10b10;
#endif
	case 32: return PICT_a8r8g8b8;
	}
}

d47 2
a48 2
	PixmapPtr dst_pixmap, src_pixmap = NULL;
	BoxPtr pextent, pbox;
d50 1
a50 3
	int extentX1, extentX2, extentY1, extentY2;
	int fullX1, fullX2, fullY1;
	int partX1, partX2;
a51 4
	xRenderColor color;
	PictFormatPtr format;
	PicturePtr dst, src;
	int error;
d53 1
a53 1
	if (uxa_screen->swappedOut)
a62 119
	if (pGC->alu != GXcopy || pGC->planemask != FB_ALLONES)
		goto solid;

	format = PictureMatchFormat(screen,
				    dst_pixmap->drawable.depth,
				    format_for_depth(dst_pixmap->drawable.depth));
	dst = CreatePicture(0, &dst_pixmap->drawable, format, 0, 0, serverClient, &error);
	if (!dst)
		goto solid;

	ValidatePicture(dst);

	uxa_get_rgba_from_pixel(pGC->fgPixel,
				&color.red,
				&color.green,
				&color.blue,
				&color.alpha,
				format_for_depth(dst_pixmap->drawable.depth));
	src = CreateSolidPicture(0, &color, &error);
	if (!src) {
		FreePicture(dst, 0);
		goto solid;
	}

	if (!uxa_screen->info->check_composite(PictOpSrc, src, NULL, dst, 0, 0)) {
		FreePicture(src, 0);
		FreePicture(dst, 0);
		goto solid;
	}

	if (!uxa_screen->info->check_composite_texture ||
	    !uxa_screen->info->check_composite_texture(screen, src)) {
		PicturePtr solid;
		int src_off_x, src_off_y;

		solid = uxa_acquire_solid(screen, src->pSourcePict);
		FreePicture(src, 0);

		src = solid;
		src_pixmap = uxa_get_offscreen_pixmap(src->pDrawable,
						      &src_off_x, &src_off_y);
		if (!src_pixmap) {
			FreePicture(src, 0);
			FreePicture(dst, 0);
			goto solid;
		}
	}

	if (!uxa_screen->info->prepare_composite(PictOpSrc, src, NULL, dst, src_pixmap, NULL, dst_pixmap)) {
		FreePicture(src, 0);
		FreePicture(dst, 0);
		goto solid;
	}

	pextent = REGION_EXTENTS(pGC->screen, pClip);
	extentX1 = pextent->x1;
	extentY1 = pextent->y1;
	extentX2 = pextent->x2;
	extentY2 = pextent->y2;
	while (n--) {
		fullX1 = ppt->x;
		fullY1 = ppt->y;
		fullX2 = fullX1 + (int)*pwidth;
		ppt++;
		pwidth++;

		if (fullY1 < extentY1 || extentY2 <= fullY1)
			continue;

		if (fullX1 < extentX1)
			fullX1 = extentX1;

		if (fullX2 > extentX2)
			fullX2 = extentX2;

		if (fullX1 >= fullX2)
			continue;

		nbox = REGION_NUM_RECTS(pClip);
		if (nbox == 1) {
			uxa_screen->info->composite(dst_pixmap,
						    0, 0, 0, 0,
						    fullX1 + off_x,
						    fullY1 + off_y,
						    fullX2 - fullX1, 1);
		} else {
			pbox = REGION_RECTS(pClip);
			while (nbox--) {
				if (pbox->y1 > fullY1)
					break;

				if (pbox->y1 <= fullY1) {
					partX1 = pbox->x1;
					if (partX1 < fullX1)
						partX1 = fullX1;

					partX2 = pbox->x2;
					if (partX2 > fullX2)
						partX2 = fullX2;

					if (partX2 > partX1) {
						uxa_screen->info->composite(dst_pixmap,
									    0, 0, 0, 0,
									    partX1 + off_x,
									    fullY1 + off_y,
									    partX2 - partX1, 1);
					}
				}
				pbox++;
			}
		}
	}

	uxa_screen->info->done_composite(dst_pixmap);
	FreePicture(src, 0);
	FreePicture(dst, 0);
	return;

solid:
a72 5
	pextent = REGION_EXTENTS(pGC->screen, pClip);
	extentX1 = pextent->x1;
	extentY1 = pextent->y1;
	extentX2 = pextent->x2;
	extentY2 = pextent->y2;
d74 3
a76 3
		fullX1 = ppt->x;
		fullY1 = ppt->y;
		fullX2 = fullX1 + (int)*pwidth;
d80 5
a84 2
		if (fullY1 < extentY1 || extentY2 <= fullY1)
			continue;
d86 2
a87 2
		if (fullX1 < extentX1)
			fullX1 = extentX1;
d89 2
a90 2
		if (fullX2 > extentX2)
			fullX2 = extentX2;
d92 2
a93 2
		if (fullX1 >= fullX2)
			continue;
a94 2
		nbox = REGION_NUM_RECTS(pClip);
		if (nbox == 1) {
d96 3
a98 25
						    fullX1 + off_x,
						    fullY1 + off_y,
						    fullX2 + off_x,
						    fullY1 + 1 + off_y);
		} else {
			pbox = REGION_RECTS(pClip);
			while (nbox--) {
				if (pbox->y1 <= fullY1 && fullY1 < pbox->y2) {
					partX1 = pbox->x1;
					if (partX1 < fullX1)
						partX1 = fullX1;
					partX2 = pbox->x2;
					if (partX2 > fullX2)
						partX2 = fullX2;
					if (partX2 > partX1) {
						(*uxa_screen->info->
						 solid) (dst_pixmap,
							 partX1 + off_x,
							 fullY1 + off_y,
							 partX2 + off_x,
							 fullY1 + 1 + off_y);
					}
				}
				pbox++;
			}
d125 6
a134 3
	if (uxa_screen->swappedOut)
		return FALSE;

d136 1
a136 2

	if (!pPix || !uxa_screen->info->put_image)
d347 3
d478 2
a479 1
		if (uxa_prepare_access(pSrcDrawable, UXA_ACCESS_RO)) {
d483 2
a484 1
			uxa_finish_access(pSrcDrawable);
d496 1
a496 1
	if (uxa_screen->swappedOut) {
a669 2
	BoxPtr pextent;
	int extentX1, extentX2, extentY1, extentY2;
a670 1
	int partX1, partX2, partY1, partY2;
d683 1
a683 1
	if (uxa_screen->swappedOut)
a731 5
	pextent = REGION_EXTENTS(pGC->pScreen, pClip);
	extentX1 = pextent->x1;
	extentY1 = pextent->y1;
	extentX2 = pextent->x2;
	extentY2 = pextent->y2;
d739 22
a760 8
		if (fullX1 < extentX1)
			fullX1 = extentX1;

		if (fullY1 < extentY1)
			fullY1 = extentY1;

		if (fullX2 > extentX2)
			fullX2 = extentX2;
d762 2
a763 2
		if (fullY2 > extentY2)
			fullY2 = extentY2;
a764 4
		if ((fullX1 >= fullX2) || (fullY1 >= fullY2))
			continue;
		n = REGION_NUM_RECTS(pClip);
		if (n == 1) {
d766 4
a769 39
						    fullX1 + xoff,
						    fullY1 + yoff,
						    fullX2 + xoff,
						    fullY2 + yoff);
		} else {
			pbox = REGION_RECTS(pClip);
			/*
			 * clip the rectangle to each box in the clip region
			 * this is logically equivalent to calling Intersect(),
			 * but rectangles may overlap each other here.
			 */
			while (n--) {
				partX1 = pbox->x1;
				if (partX1 < fullX1)
					partX1 = fullX1;
				partY1 = pbox->y1;
				if (partY1 < fullY1)
					partY1 = fullY1;
				partX2 = pbox->x2;
				if (partX2 > fullX2)
					partX2 = fullX2;
				partY2 = pbox->y2;
				if (partY2 > fullY2)
					partY2 = fullY2;

				pbox++;

				if (partX1 < partX2 && partY1 < partY2) {
					(*uxa_screen->info->solid) (pPixmap,
								    partX1 +
								    xoff,
								    partY1 +
								    yoff,
								    partX2 +
								    xoff,
								    partY2 +
								    yoff);
				}
			}
d838 1
a838 1
	BoxPtr pBox, extents;
a848 1
	extents = REGION_EXTENTS(screen, pRegion);
d850 3
a852 77
	/* Using GEM, the relocation costs outweigh the advantages of the blitter */
	if (nbox == 1 || (alu != GXcopy && alu != GXclear) || planemask != FB_ALLONES) {
try_solid:
		if (uxa_screen->info->check_solid &&
		    !uxa_screen->info->check_solid(&pixmap->drawable, alu, planemask))
			goto err;

		if (!uxa_screen->info->prepare_solid(pixmap, alu, planemask, pixel))
			goto err;

		while (nbox--) {
			uxa_screen->info->solid(pixmap,
						pBox->x1, pBox->y1,
						pBox->x2, pBox->y2);
			pBox++;
		}

		uxa_screen->info->done_solid(pixmap);
	} else {
		PicturePtr dst, src;
		PixmapPtr src_pixmap = NULL;
		xRenderColor color;
		int error;

		dst = CreatePicture(0, &pixmap->drawable,
				    PictureMatchFormat(screen,
						       pixmap->drawable.depth,
						       format_for_depth(pixmap->drawable.depth)),
				    0, 0, serverClient, &error);
		if (!dst)
			goto err;

		ValidatePicture(dst);

		uxa_get_rgba_from_pixel(pixel,
					&color.red,
					&color.green,
					&color.blue,
					&color.alpha,
					format_for_depth(pixmap->drawable.depth));
		src = CreateSolidPicture(0, &color, &error);
		if (!src) {
			FreePicture(dst, 0);
			goto err;
		}

		if (!uxa_screen->info->check_composite(PictOpSrc, src, NULL, dst,
						       extents->x2 - extents->x1,
						       extents->y2 - extents->y1)) {
			FreePicture(src, 0);
			FreePicture(dst, 0);
			goto try_solid;
		}

		if (!uxa_screen->info->check_composite_texture ||
		    !uxa_screen->info->check_composite_texture(screen, src)) {
			PicturePtr solid;
			int src_off_x, src_off_y;

			solid = uxa_acquire_solid(screen, src->pSourcePict);
			FreePicture(src, 0);

			src = solid;
			src_pixmap = uxa_get_offscreen_pixmap(src->pDrawable,
							      &src_off_x, &src_off_y);
			if (!src_pixmap) {
				FreePicture(src, 0);
				FreePicture(dst, 0);
				goto err;
			}
		}

		if (!uxa_screen->info->prepare_composite(PictOpSrc, src, NULL, dst, src_pixmap, NULL, pixmap)) {
			FreePicture(src, 0);
			FreePicture(dst, 0);
			goto err;
		}
d854 2
a855 9
		while (nbox--) {
			uxa_screen->info->composite(pixmap,
						    0, 0, 0, 0,
						    pBox->x1,
						    pBox->y1,
						    pBox->x2 - pBox->x1,
						    pBox->y2 - pBox->y1);
			pBox++;
		}
d857 5
a861 3
		uxa_screen->info->done_composite(pixmap);
		FreePicture(src, 0);
		FreePicture(dst, 0);
d863 1
a863 1

d986 1
a986 1
	if (uxa_screen->swappedOut)
@


1.2
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d37 19
d61 2
a62 2
	ScreenPtr pScreen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
d64 1
a64 1
	PixmapPtr pPixmap = uxa_get_drawable_pixmap(pDrawable);
d71 89
d161 49
a209 3
	if (uxa_screen->swappedOut || pGC->fillStyle != FillSolid ||
	    !(pPixmap = uxa_get_offscreen_pixmap(pDrawable, &off_x, &off_y)) ||
	    !(*uxa_screen->info->prepare_solid) (pPixmap,
d212 2
a213 4
						 pGC->fgPixel)) {
		uxa_check_fill_spans(pDrawable, pGC, n, ppt, pwidth, fSorted);
		return;
	}
d215 1
a215 1
	pextent = REGION_EXTENTS(pGC->pScreen, pClip);
d241 1
a241 1
			(*uxa_screen->info->solid) (pPixmap,
d258 1
a258 1
						 solid) (pPixmap,
d269 6
a274 1
	(*uxa_screen->info->done_solid) (pPixmap);
a363 75
#ifdef MITSHM

#include "xorgVersion.h"

static Bool
uxa_do_shm_put_image(DrawablePtr pDrawable, GCPtr pGC, int depth,
		     unsigned int format, int w, int h, int sx, int sy, int sw,
		     int sh, int dx, int dy, char *data)
{
	int src_stride = PixmapBytePad(w, depth);

	if (uxa_do_put_image
	    (pDrawable, pGC, depth, dx, dy, sw, sh, format,
	     data + sy * src_stride + sx * BitsPerPixel(depth) / 8, src_stride))
		return TRUE;

	if (format == ZPixmap) {
		PixmapPtr pPixmap;

		pPixmap =
		    GetScratchPixmapHeader(pDrawable->pScreen, w, h, depth,
					   BitsPerPixel(depth), PixmapBytePad(w,
									      depth),
					   (pointer) data);
		if (!pPixmap)
			return FALSE;

		if (!uxa_prepare_access(pDrawable, UXA_ACCESS_RW)) {
			FreeScratchPixmapHeader(pPixmap);
			return FALSE;
		}

		fbCopyArea((DrawablePtr) pPixmap, pDrawable, pGC, sx, sy, sw,
			   sh, dx, dy);
		uxa_finish_access(pDrawable);

		FreeScratchPixmapHeader(pPixmap);

		return TRUE;
	}

	return FALSE;
}

#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,5,99,0,0)

/* The actual ShmPutImage isn't wrapped by the damage layer, so we need to
 * inform any interested parties of the damage incurred to the drawable.
 *
 * We also need to set the pending damage to ensure correct migration in all
 * cases.
 */
void
uxa_shm_put_image(DrawablePtr pDrawable, GCPtr pGC, int depth,
		  unsigned int format, int w, int h, int sx, int sy, int sw,
		  int sh, int dx, int dy, char *data)
{
	if (!uxa_do_shm_put_image
	    (pDrawable, pGC, depth, format, w, h, sx, sy, sw, sh, dx, dy,
	     data)) {
		if (!uxa_prepare_access(pDrawable, UXA_ACCESS_RW))
			return;
		fbShmPutImage(pDrawable, pGC, depth, format, w, h, sx, sy, sw,
			      sh, dx, dy, data);
		uxa_finish_access(pDrawable);
	}
}
#else
#define uxa_shm_put_image NULL
#endif

ShmFuncs uxa_shm_funcs = { NULL, uxa_shm_put_image };

#endif

a367 4
#ifdef MITSHM
	if (!uxa_do_shm_put_image
	    (pDrawable, pGC, depth, format, w, h, 0, 0, w, h, x, y, bits))
#else
a369 1
#endif
d515 8
d538 39
a576 2
	if (!uxa_pixmap_is_offscreen(pDstPixmap))
	    goto fallback;
d683 1
a683 1
	prect = xalloc(sizeof(xRectangle) * npt);
d697 1
a697 1
	xfree(prect);
d720 1
a720 1
	prect = xalloc(sizeof(xRectangle) * (npt - 1));
d736 1
a736 1
			xfree(prect);
d760 1
a760 1
	xfree(prect);
d789 1
a789 1
	prect = xalloc(sizeof(xRectangle) * nseg);
d817 1
a817 1
	xfree(prect);
d829 1
a829 1
	PixmapPtr pPixmap = uxa_get_drawable_pixmap(pDrawable);
d847 2
a848 1
	uxa_get_drawable_deltas(pDrawable, pPixmap, &xoff, &yoff);
d850 2
a851 1
	if (uxa_screen->swappedOut)
d879 6
a884 2
	if (!uxa_pixmap_is_offscreen(pPixmap) ||
	    !(*uxa_screen->info->prepare_solid) (pPixmap,
d1027 3
a1029 2
	uxa_screen_t *uxa_screen = uxa_get_screen(pDrawable->pScreen);
	PixmapPtr pPixmap = uxa_get_drawable_pixmap(pDrawable);
d1031 2
d1035 55
a1089 2
	uxa_get_drawable_deltas(pDrawable, pPixmap, &xoff, &yoff);
	REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);
d1091 7
a1097 5
	if (uxa_pixmap_is_offscreen(pPixmap) &&
	    (*uxa_screen->info->prepare_solid) (pPixmap, alu, planemask, pixel))
	{
		int nbox;
		BoxPtr pBox;
d1099 23
a1121 2
		nbox = REGION_NUM_RECTS(pRegion);
		pBox = REGION_RECTS(pRegion);
d1124 6
a1129 2
			(*uxa_screen->info->solid) (pPixmap, pBox->x1, pBox->y1,
						    pBox->x2, pBox->y2);
a1131 1
		(*uxa_screen->info->done_solid) (pPixmap);
d1133 3
a1135 1
		ret = TRUE;
d1138 1
a1138 1
	REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);
d1140 2
a1172 4
	pPixmap = uxa_get_drawable_pixmap(pDrawable);
	uxa_get_drawable_deltas(pDrawable, pPixmap, &xoff, &yoff);
	REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);

a1173 1

d1176 6
@


1.1
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d2 1
a2 1
 * Copyright  2001 Keith Packard
d4 1
a4 1
 * Partly based on code that is Copyright  The XFree86 Project Inc.
d26 1
a26 1
 *    Michel Dnzer <michel@@tungstengraphics.com>
d42 20
a61 21
    ScreenPtr	    pScreen = pDrawable->pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    RegionPtr	    pClip = fbGetCompositeClip(pGC);
    PixmapPtr	    pPixmap = uxa_get_drawable_pixmap (pDrawable);
    BoxPtr	    pextent, pbox;
    int		    nbox;
    int		    extentX1, extentX2, extentY1, extentY2;
    int		    fullX1, fullX2, fullY1;
    int		    partX1, partX2;
    int		    off_x, off_y;

    if (uxa_screen->swappedOut || pGC->fillStyle != FillSolid ||
	!(pPixmap = uxa_get_offscreen_pixmap (pDrawable, &off_x, &off_y)) ||
	!(*uxa_screen->info->prepare_solid) (pPixmap,
					     pGC->alu,
					     pGC->planemask,
					     pGC->fgPixel))
    {
	uxa_check_fill_spans (pDrawable, pGC, n, ppt, pwidth, fSorted);
	return;
    }
d63 17
a79 18
    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
    extentX1 = pextent->x1;
    extentY1 = pextent->y1;
    extentX2 = pextent->x2;
    extentY2 = pextent->y2;
    while (n--)
    {
	fullX1 = ppt->x;
	fullY1 = ppt->y;
	fullX2 = fullX1 + (int) *pwidth;
	ppt++;
	pwidth++;

	if (fullY1 < extentY1 || extentY2 <= fullY1)
	    continue;

	if (fullX1 < extentX1)
	    fullX1 = extentX1;
d81 2
a82 2
	if (fullX2 > extentX2)
	    fullX2 = extentX2;
d84 2
a85 2
	if (fullX1 >= fullX2)
	    continue;
d87 2
a88 21
	nbox = REGION_NUM_RECTS (pClip);
	if (nbox == 1)
	{
	    (*uxa_screen->info->solid) (pPixmap,
					fullX1 + off_x, fullY1 + off_y,
					fullX2 + off_x, fullY1 + 1 + off_y);
	}
	else
	{
	    pbox = REGION_RECTS(pClip);
	    while(nbox--)
	    {
		if (pbox->y1 <= fullY1 && fullY1 < pbox->y2)
		{
		    partX1 = pbox->x1;
		    if (partX1 < fullX1)
			partX1 = fullX1;
		    partX2 = pbox->x2;
		    if (partX2 > fullX2)
			partX2 = fullX2;
		    if (partX2 > partX1) {
d90 25
a114 3
						    partX1 + off_x, fullY1 + off_y,
						    partX2 + off_x, fullY1 + 1 + off_y);
		    }
a115 2
		pbox++;
	    }
d117 1
a117 2
    }
    (*uxa_screen->info->done_solid) (pPixmap);
d121 2
a122 2
uxa_do_put_image (DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
		  int w, int h, int format, char *bits, int src_stride)
d124 7
a130 8
    uxa_screen_t    *uxa_screen = uxa_get_screen(pDrawable->pScreen);
    PixmapPtr pPix = uxa_get_drawable_pixmap (pDrawable);
    RegionPtr pClip;
    BoxPtr pbox;
    int nbox;
    int xoff, yoff;
    int bpp = pDrawable->bitsPerPixel;
    Bool access_prepared = FALSE;
d132 66
a197 3
    /* Don't bother with under 8bpp, XYPixmaps. */
    if (format != ZPixmap || bpp < 8)
	return FALSE;
d199 2
a200 69
    /* Only accelerate copies: no rop or planemask. */
    if (!UXA_PM_IS_SOLID(pDrawable, pGC->planemask) || pGC->alu != GXcopy)
	return FALSE;

    if (uxa_screen->swappedOut)
	return FALSE;

    pPix = uxa_get_offscreen_pixmap (pDrawable, &xoff, &yoff);

    if (!pPix || !uxa_screen->info->put_image)
	return FALSE;

    x += pDrawable->x;
    y += pDrawable->y;

    pClip = fbGetCompositeClip(pGC);
    for (nbox = REGION_NUM_RECTS(pClip),
	 pbox = REGION_RECTS(pClip);
	 nbox--;
	 pbox++)
    {
	int x1 = x;
	int y1 = y;
	int x2 = x + w;
	int y2 = y + h;
	char *src;
	Bool ok;

	if (x1 < pbox->x1)
	    x1 = pbox->x1;
	if (y1 < pbox->y1)
	    y1 = pbox->y1;
	if (x2 > pbox->x2)
	    x2 = pbox->x2;
	if (y2 > pbox->y2)
	    y2 = pbox->y2;
	if (x1 >= x2 || y1 >= y2)
	    continue;

	src = bits + (y1 - y) * src_stride + (x1 - x) * (bpp / 8);
	ok = uxa_screen->info->put_image(pPix, x1 + xoff, y1 + yoff,
					 x2 - x1, y2 - y1, src, src_stride);
	/* If we fail to accelerate the upload, fall back to using unaccelerated
	 * fb calls.
	 */
	if (!ok) {
	    FbStip *dst;
	    FbStride dst_stride;
	    int	dstBpp;
	    int	dstXoff, dstYoff;

	    if (!access_prepared) {
		if (!uxa_prepare_access(pDrawable, UXA_ACCESS_RW))
		    return FALSE;
		access_prepared = TRUE;
	    }

	    fbGetStipDrawable(pDrawable, dst, dst_stride, dstBpp,
			      dstXoff, dstYoff);

	    fbBltStip((FbStip *)bits + (y1 - y) * (src_stride / sizeof(FbStip)),
		      src_stride / sizeof(FbStip),
		      (x1 - x) * dstBpp,
		      dst + (y1 + dstYoff) * dst_stride,
		      dst_stride,
		      (x1 + dstXoff) * dstBpp,
		      (x2 - x1) * dstBpp,
		      y2 - y1,
		      GXcopy, FB_ALLONES, dstBpp);
a201 1
    }
a202 2
    if (access_prepared)
	uxa_finish_access(pDrawable);
d204 1
a204 1
    return TRUE;
d209 2
d213 2
a214 2
		 unsigned int format, int w, int h, int sx, int sy, int sw,
		 int sh, int dx, int dy, char *data)
d216 1
a216 1
    int src_stride = PixmapBytePad(w, depth);
d218 20
a237 4
    if (uxa_do_put_image(pDrawable, pGC, depth, dx, dy, sw, sh, format, data +
			 sy * src_stride + sx * BitsPerPixel(depth) / 8,
			 src_stride))
	return TRUE;
d239 3
a241 3
    if (format == ZPixmap)
    {
	PixmapPtr pPixmap;
d243 1
a243 10
	pPixmap = GetScratchPixmapHeader(pDrawable->pScreen, w, h, depth,
					 BitsPerPixel(depth), PixmapBytePad(w, depth),
					 (pointer)data);
	if (!pPixmap)
	    return FALSE;

        if (!uxa_prepare_access (pDrawable, UXA_ACCESS_RW))
	    return FALSE;
	fbCopyArea((DrawablePtr)pPixmap, pDrawable, pGC, sx, sy, sw, sh, dx, dy);
	uxa_finish_access(pDrawable);
d245 2
a246 1
	FreeScratchPixmapHeader(pPixmap);
d248 2
a249 2
	return TRUE;
    }
d251 1
a251 2
    return FALSE;
}
d260 3
a262 3
uxa_shm_put_image(DrawablePtr pDrawable, GCPtr pGC, int depth, unsigned int format,
		  int w, int h, int sx, int sy, int sw, int sh, int dx, int dy,
		  char *data)
d264 9
a272 8
    if (!uxa_do_shm_put_image(pDrawable, pGC, depth, format, w, h, sx, sy, sw, sh,
			      dx, dy, data)) {
	if (!uxa_prepare_access (pDrawable, UXA_ACCESS_RW))
	    return;
	fbShmPutImage(pDrawable, pGC, depth, format, w, h, sx, sy, sw, sh, dx, dy,
		      data);
	uxa_finish_access(pDrawable);
    }
d274 3
d283 2
a284 2
uxa_put_image (DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
	     int w, int h, int leftPad, int format, char *bits)
d287 2
a288 2
    if (!uxa_do_shm_put_image(pDrawable, pGC, depth, format, w, h, 0, 0, w, h, x, y,
			  bits))
d290 2
a291 2
    if (!uxa_do_put_image(pDrawable, pGC, depth, x, y, w, h, format, bits,
		       PixmapBytePad(w, pDrawable->depth)))
d293 2
a294 2
	uxa_check_put_image(pDrawable, pGC, depth, x, y, w, h, leftPad, format,
			 bits);
d298 2
a299 2
uxa_copy_n_to_n_two_dir (DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
		   GCPtr pGC, BoxPtr pbox, int nbox, int dx, int dy)
d301 118
a418 10
    uxa_screen_t *uxa_screen = uxa_get_screen(pDstDrawable->pScreen);
    PixmapPtr pSrcPixmap, pDstPixmap;
    int src_off_x, src_off_y, dst_off_x, dst_off_y;
    int dirsetup;

    /* Need to get both pixmaps to call the driver routines */
    pSrcPixmap = uxa_get_offscreen_pixmap (pSrcDrawable, &src_off_x, &src_off_y);
    pDstPixmap = uxa_get_offscreen_pixmap (pDstDrawable, &dst_off_x, &dst_off_y);
    if (!pSrcPixmap || !pDstPixmap)
	return FALSE;
d420 54
a473 19
    /*
     * Now the case of a chip that only supports xdir = ydir = 1 or
     * xdir = ydir = -1, but we have xdir != ydir.
     */
    dirsetup = 0;	/* No direction set up yet. */
    for (; nbox; pbox++, nbox--) {
	if (dx >= 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
	    /* Do a xdir = ydir = -1 blit instead. */
	    if (dirsetup != -1) {
		if (dirsetup != 0)
		    uxa_screen->info->done_copy(pDstPixmap);
		dirsetup = -1;
		if (!(*uxa_screen->info->prepare_copy)(pSrcPixmap,
						   pDstPixmap,
						   -1, -1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
d475 2
a476 53
	    (*uxa_screen->info->copy)(pDstPixmap,
				   src_off_x + pbox->x1 + dx,
				   src_off_y + pbox->y1 + dy,
				   dst_off_x + pbox->x1,
				   dst_off_y + pbox->y1,
				   pbox->x2 - pbox->x1,
				   pbox->y2 - pbox->y1);
	} else if (dx < 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
	    /* Do a xdir = ydir = 1 blit instead. */
	    if (dirsetup != 1) {
		if (dirsetup != 0)
		    uxa_screen->info->done_copy(pDstPixmap);
		dirsetup = 1;
		if (!(*uxa_screen->info->prepare_copy)(pSrcPixmap,
						   pDstPixmap,
						   1, 1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    (*uxa_screen->info->copy)(pDstPixmap,
				   src_off_x + pbox->x1 + dx,
				   src_off_y + pbox->y1 + dy,
				   dst_off_x + pbox->x1,
				   dst_off_y + pbox->y1,
				   pbox->x2 - pbox->x1,
				   pbox->y2 - pbox->y1);
	} else if (dx >= 0) {
	    /*
	     * xdir = 1, ydir = -1.
	     * Perform line-by-line xdir = ydir = 1 blits, going up.
	     */
	    int i;
	    if (dirsetup != 1) {
		if (dirsetup != 0)
		    uxa_screen->info->done_copy(pDstPixmap);
		dirsetup = 1;
		if (!(*uxa_screen->info->prepare_copy)(pSrcPixmap,
						   pDstPixmap,
						   1, 1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    for (i = pbox->y2 - pbox->y1 - 1; i >= 0; i--)
		(*uxa_screen->info->copy)(pDstPixmap,
				       src_off_x + pbox->x1 + dx,
				       src_off_y + pbox->y1 + dy + i,
				       dst_off_x + pbox->x1,
				       dst_off_y + pbox->y1 + i,
				       pbox->x2 - pbox->x1, 1);
d478 5
a482 30
	    /*
	     * xdir = -1, ydir = 1.
	     * Perform line-by-line xdir = ydir = -1 blits, going down.
	     */
	    int i;
	    if (dirsetup != -1) {
		if (dirsetup != 0)
		    uxa_screen->info->done_copy(pDstPixmap);
		dirsetup = -1;
		if (!(*uxa_screen->info->prepare_copy)(pSrcPixmap,
						   pDstPixmap,
						   -1, -1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    for (i = 0; i < pbox->y2 - pbox->y1; i++)
		(*uxa_screen->info->copy)(pDstPixmap,
				       src_off_x + pbox->x1 + dx,
				       src_off_y + pbox->y1 + dy + i,
				       dst_off_x + pbox->x1,
				       dst_off_y + pbox->y1 + i,
				       pbox->x2 - pbox->x1, 1);
	}
    }
    if (dirsetup != 0)
	uxa_screen->info->done_copy(pDstPixmap);
    return TRUE;
}
d484 23
a506 52
void
uxa_copy_n_to_n (DrawablePtr    pSrcDrawable,
		 DrawablePtr    pDstDrawable,
		 GCPtr		pGC,
		 BoxPtr		pbox,
		 int		nbox,
		 int		dx,
		 int		dy,
		 Bool		reverse,
		 Bool		upsidedown,
		 Pixel		bitplane,
		 void		*closure)
{
    ScreenPtr       screen = pDstDrawable->pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(screen);
    int		    src_off_x, src_off_y;
    int		    dst_off_x, dst_off_y;
    PixmapPtr	    pSrcPixmap, pDstPixmap;

    pSrcPixmap = uxa_get_drawable_pixmap (pSrcDrawable);
    pDstPixmap = uxa_get_drawable_pixmap (pDstDrawable);

    uxa_get_drawable_deltas (pSrcDrawable, pSrcPixmap, &src_off_x, &src_off_y);
    uxa_get_drawable_deltas (pDstDrawable, pDstPixmap, &dst_off_x, &dst_off_y);

    /* Mixed directions must be handled specially if the card is lame */
    if ((uxa_screen->info->flags & UXA_TWO_BITBLT_DIRECTIONS) &&
	reverse != upsidedown) {
	if (uxa_copy_n_to_n_two_dir(pSrcDrawable, pDstDrawable, pGC, pbox, nbox,
			       dx, dy))
	    return;
	goto fallback;
    }

    if (!uxa_pixmap_is_offscreen(pSrcPixmap) ||
	!uxa_pixmap_is_offscreen(pDstPixmap) ||
	!(*uxa_screen->info->prepare_copy) (pSrcPixmap, pDstPixmap, reverse ? -1 : 1,
					   upsidedown ? -1 : 1,
					   pGC ? pGC->alu : GXcopy,
					   pGC ? pGC->planemask : FB_ALLONES)) {
	goto fallback;
    }

    while (nbox--)
    {
	(*uxa_screen->info->copy) (pDstPixmap,
				   pbox->x1 + dx + src_off_x,
				   pbox->y1 + dy + src_off_y,
				   pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
				   pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	pbox++;
    }
d508 3
a510 1
    (*uxa_screen->info->done_copy) (pDstPixmap);
d512 1
a512 1
    return;
d515 11
a525 8
    UXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrcDrawable, pDstDrawable,
		  uxa_drawable_location(pSrcDrawable),
		  uxa_drawable_location(pDstDrawable)));
    if (uxa_prepare_access (pDstDrawable, UXA_ACCESS_RW)) {
	if (uxa_prepare_access (pSrcDrawable, UXA_ACCESS_RO)) {
	    fbCopyNtoN (pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy,
			reverse, upsidedown, bitplane, closure);
	    uxa_finish_access (pSrcDrawable);
a526 2
	uxa_finish_access (pDstDrawable);
    }
d531 1
a531 1
	    int srcx, int srcy, int width, int height, int dstx, int dsty)
d533 7
a539 1
    uxa_screen_t    *uxa_screen = uxa_get_screen(pDstDrawable->pScreen);
d541 3
a543 8
    if (uxa_screen->swappedOut) {
        return  uxa_check_copy_area(pSrcDrawable, pDstDrawable, pGC,
                                 srcx, srcy, width, height, dstx, dsty);
    }

    return miDoCopy (pSrcDrawable, pDstDrawable, pGC,
		     srcx, srcy, width, height,
		     dstx, dsty, uxa_copy_n_to_n, 0, NULL);
d548 1
a548 1
	     DDXPointPtr ppt)
d550 2
a551 2
    int i;
    xRectangle *prect;
d553 7
a559 7
    /* If we can't reuse the current GC as is, don't bother accelerating the
     * points.
     */
    if (pGC->fillStyle != FillSolid) {
	uxa_check_poly_point(pDrawable, pGC, mode, npt, ppt);
	return;
    }
d561 15
a575 15
    prect = xalloc(sizeof(xRectangle) * npt);
    if (!prect)
	return;
    for (i = 0; i < npt; i++) {
	prect[i].x = ppt[i].x;
	prect[i].y = ppt[i].y;
	if (i > 0 && mode == CoordModePrevious) {
	    prect[i].x += prect[i - 1].x;
	    prect[i].y += prect[i - 1].y;
	}
	prect[i].width = 1;
	prect[i].height = 1;
    }
    pGC->ops->PolyFillRect(pDrawable, pGC, npt, prect);
    xfree(prect);
d587 25
a611 10
    xRectangle *prect;
    int x1, x2, y1, y2;
    int i;

    /* Don't try to do wide lines or non-solid fill style. */
    if (pGC->lineWidth != 0 || pGC->lineStyle != LineSolid ||
	pGC->fillStyle != FillSolid) {
	uxa_check_poly_lines(pDrawable, pGC, mode, npt, ppt);
	return;
    }
d613 5
a617 14
    prect = xalloc(sizeof(xRectangle) * (npt - 1));
    if (!prect)
	return;
    x1 = ppt[0].x;
    y1 = ppt[0].y;
    /* If we have any non-horizontal/vertical, fall back. */
    for (i = 0; i < npt - 1; i++) {
	if (mode == CoordModePrevious) {
	    x2 = x1 + ppt[i + 1].x;
	    y2 = y1 + ppt[i + 1].y;
	} else {
	    x2 = ppt[i + 1].x;
	    y2 = ppt[i + 1].y;
	}
d619 14
a632 5
	if (x1 != x2 && y1 != y2) {
	    xfree(prect);
	    uxa_check_poly_lines(pDrawable, pGC, mode, npt, ppt);
	    return;
	}
d634 2
a635 6
	if (x1 < x2) {
	    prect[i].x = x1;
	    prect[i].width = x2 - x1 + 1;
	} else {
	    prect[i].x = x2;
	    prect[i].width = x1 - x2 + 1;
d637 2
a638 13
	if (y1 < y2) {
	    prect[i].y = y1;
	    prect[i].height = y2 - y1 + 1;
	} else {
	    prect[i].y = y2;
	    prect[i].height = y1 - y2 + 1;
	}

	x1 = x2;
	y1 = y2;
    }
    pGC->ops->PolyFillRect(pDrawable, pGC, npt - 1, prect);
    xfree(prect);
d647 1
a647 2
uxa_poly_segment (DrawablePtr pDrawable, GCPtr pGC, int nseg,
		xSegment *pSeg)
d649 2
a650 2
    xRectangle *prect;
    int i;
d652 6
a657 7
    /* Don't try to do wide lines or non-solid fill style. */
    if (pGC->lineWidth != 0 || pGC->lineStyle != LineSolid ||
	pGC->fillStyle != FillSolid)
    {
	uxa_check_poly_segment(pDrawable, pGC, nseg, pSeg);
	return;
    }
d659 6
a664 5
    /* If we have any non-horizontal/vertical, fall back. */
    for (i = 0; i < nseg; i++) {
	if (pSeg[i].x1 != pSeg[i].x2 && pSeg[i].y1 != pSeg[i].y2) {
	    uxa_check_poly_segment(pDrawable, pGC, nseg, pSeg);
	    return;
a665 1
    }
d667 26
a692 10
    prect = xalloc(sizeof(xRectangle) * nseg);
    if (!prect)
	return;
    for (i = 0; i < nseg; i++) {
	if (pSeg[i].x1 < pSeg[i].x2) {
	    prect[i].x = pSeg[i].x1;
	    prect[i].width = pSeg[i].x2 - pSeg[i].x1 + 1;
	} else {
	    prect[i].x = pSeg[i].x2;
	    prect[i].width = pSeg[i].x1 - pSeg[i].x2 + 1;
d694 2
a695 18
	if (pSeg[i].y1 < pSeg[i].y2) {
	    prect[i].y = pSeg[i].y1;
	    prect[i].height = pSeg[i].y2 - pSeg[i].y1 + 1;
	} else {
	    prect[i].y = pSeg[i].y2;
	    prect[i].height = pSeg[i].y1 - pSeg[i].y2 + 1;
	}

	/* don't paint last pixel */
	if (pGC->capStyle == CapNotLast) {
	    if (prect[i].width == 1)
		prect[i].height--;
	    else
		prect[i].width--;
	}
    }
    pGC->ops->PolyFillRect(pDrawable, pGC, nseg, prect);
    xfree(prect);
d698 2
a699 2
static Bool uxa_fill_region_solid (DrawablePtr pDrawable, RegionPtr pRegion,
				Pixel pixel, CARD32 planemask, CARD32 alu);
d703 1
a703 3
		GCPtr	    pGC,
		int	    nrect,
		xRectangle  *prect)
d705 55
a759 55
    uxa_screen_t    *uxa_screen = uxa_get_screen(pDrawable->pScreen);
    RegionPtr	    pClip = fbGetCompositeClip(pGC);
    PixmapPtr	    pPixmap = uxa_get_drawable_pixmap(pDrawable);
    register BoxPtr pbox;
    BoxPtr	    pextent;
    int		    extentX1, extentX2, extentY1, extentY2;
    int		    fullX1, fullX2, fullY1, fullY2;
    int		    partX1, partX2, partY1, partY2;
    int		    xoff, yoff;
    int		    xorg, yorg;
    int		    n;
    RegionPtr pReg = RECTS_TO_REGION(pScreen, nrect, prect, CT_UNSORTED);

    /* Compute intersection of rects and clip region */
    REGION_TRANSLATE(pScreen, pReg, pDrawable->x, pDrawable->y);
    REGION_INTERSECT(pScreen, pReg, pClip, pReg);

    if (!REGION_NUM_RECTS(pReg))
	goto out;

    uxa_get_drawable_deltas(pDrawable, pPixmap, &xoff, &yoff);

    if (uxa_screen->swappedOut)
	goto fallback;

    /* For ROPs where overlaps don't matter, convert rectangles to region and
     * call uxa_fill_region_{solid,tiled}.
     */
    if ((pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled) &&
	(nrect == 1 || pGC->alu == GXcopy || pGC->alu == GXclear ||
	 pGC->alu == GXnoop || pGC->alu == GXcopyInverted ||
	 pGC->alu == GXset)) {
	if (((pGC->fillStyle == FillSolid || pGC->tileIsPixel) &&
	     uxa_fill_region_solid(pDrawable, pReg, pGC->fillStyle == FillSolid ?
				pGC->fgPixel : pGC->tile.pixel,	pGC->planemask,
				pGC->alu)) ||
	    (pGC->fillStyle == FillTiled && !pGC->tileIsPixel &&
	     uxa_fill_region_tiled(pDrawable, pReg, pGC->tile.pixmap, &pGC->patOrg,
				pGC->planemask, pGC->alu))) {
	    goto out;
	}
    }

    if (pGC->fillStyle != FillSolid &&
	!(pGC->tileIsPixel && pGC->fillStyle == FillTiled))
    {
	goto fallback;
    }

    if (!uxa_pixmap_is_offscreen (pPixmap) ||
	!(*uxa_screen->info->prepare_solid) (pPixmap,
					 pGC->alu,
					 pGC->planemask,
					 pGC->fgPixel))
    {
d761 2
a762 40
	uxa_check_poly_fill_rect (pDrawable, pGC, nrect, prect);
	goto out;
    }

    xorg = pDrawable->x;
    yorg = pDrawable->y;

    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
    extentX1 = pextent->x1;
    extentY1 = pextent->y1;
    extentX2 = pextent->x2;
    extentY2 = pextent->y2;
    while (nrect--)
    {
	fullX1 = prect->x + xorg;
	fullY1 = prect->y + yorg;
	fullX2 = fullX1 + (int) prect->width;
	fullY2 = fullY1 + (int) prect->height;
	prect++;

	if (fullX1 < extentX1)
	    fullX1 = extentX1;

	if (fullY1 < extentY1)
	    fullY1 = extentY1;

	if (fullX2 > extentX2)
	    fullX2 = extentX2;

	if (fullY2 > extentY2)
	    fullY2 = extentY2;

	if ((fullX1 >= fullX2) || (fullY1 >= fullY2))
	    continue;
	n = REGION_NUM_RECTS (pClip);
	if (n == 1)
	{
	    (*uxa_screen->info->solid) (pPixmap,
				     fullX1 + xoff, fullY1 + yoff,
				     fullX2 + xoff, fullY2 + yoff);
a763 22
	else
	{
	    pbox = REGION_RECTS(pClip);
	    /*
	     * clip the rectangle to each box in the clip region
	     * this is logically equivalent to calling Intersect(),
	     * but rectangles may overlap each other here.
	     */
	    while(n--)
	    {
		partX1 = pbox->x1;
		if (partX1 < fullX1)
		    partX1 = fullX1;
		partY1 = pbox->y1;
		if (partY1 < fullY1)
		    partY1 = fullY1;
		partX2 = pbox->x2;
		if (partX2 > fullX2)
		    partX2 = fullX2;
		partY2 = pbox->y2;
		if (partY2 > fullY2)
		    partY2 = fullY2;
d765 2
a766 1
		pbox++;
d768 68
a835 4
		if (partX1 < partX2 && partY1 < partY2) {
		    (*uxa_screen->info->solid) (pPixmap,
					     partX1 + xoff, partY1 + yoff,
					     partX2 + xoff, partY2 + yoff);
a836 1
	    }
d838 1
a838 2
    }
    (*uxa_screen->info->done_solid) (pPixmap);
d841 2
a842 2
    REGION_UNINIT(pScreen, pReg);
    REGION_DESTROY(pScreen, pReg);
d846 20
a865 20
    uxa_fill_spans,
    uxa_check_set_spans,
    uxa_put_image,
    uxa_copy_area,
    uxa_check_copy_plane,
    uxa_poly_point,
    uxa_poly_lines,
    uxa_poly_segment,
    miPolyRectangle,
    uxa_check_poly_arc,
    miFillPolygon,
    uxa_poly_fill_rect,
    miPolyFillArc,
    miPolyText8,
    miPolyText16,
    miImageText8,
    miImageText16,
    uxa_check_image_glyph_blt,
    uxa_check_poly_glyph_blt,
    uxa_check_push_pixels,
d868 1
a868 2
void
uxa_copy_window(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
d870 7
a876 3
    RegionRec	rgnDst;
    int		dx, dy;
    PixmapPtr	pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);
d878 1
a878 3
    dx = ptOldOrg.x - pWin->drawable.x;
    dy = ptOldOrg.y - pWin->drawable.y;
    REGION_TRANSLATE(pWin->drawable.pScreen, prgnSrc, -dx, -dy);
d880 2
a881 3
    REGION_INIT (pWin->drawable.pScreen, &rgnDst, NullBox, 0);

    REGION_INTERSECT(pWin->drawable.pScreen, &rgnDst, &pWin->borderClip, prgnSrc);
d883 3
a885 3
    if (pPixmap->screen_x || pPixmap->screen_y)
	REGION_TRANSLATE (pWin->drawable.pScreen, &rgnDst,
			  -pPixmap->screen_x, -pPixmap->screen_y);
d888 2
a889 3
    miCopyRegion (&pPixmap->drawable, &pPixmap->drawable,
		  NULL,
		  &rgnDst, dx, dy, uxa_copy_n_to_n, 0, NULL);
d891 1
a891 1
    REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
d895 3
a897 5
uxa_fill_region_solid (DrawablePtr	pDrawable,
		    RegionPtr	pRegion,
		    Pixel	pixel,
		    CARD32	planemask,
		    CARD32	alu)
d899 4
a902 13
    uxa_screen_t    *uxa_screen = uxa_get_screen(pDrawable->pScreen);
    PixmapPtr	    pPixmap = uxa_get_drawable_pixmap (pDrawable);
    int		    xoff, yoff;
    Bool	    ret = FALSE;

    uxa_get_drawable_deltas(pDrawable, pPixmap, &xoff, &yoff);
    REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);

    if (uxa_pixmap_is_offscreen (pPixmap) &&
	(*uxa_screen->info->prepare_solid) (pPixmap, alu, planemask, pixel))
    {
	int nbox;
	BoxPtr pBox;
d904 2
a905 2
	nbox = REGION_NUM_RECTS (pRegion);
	pBox = REGION_RECTS (pRegion);
d907 2
a908 1
	while (nbox--)
d910 14
a923 3
	    (*uxa_screen->info->solid) (pPixmap, pBox->x1, pBox->y1, pBox->x2,
				     pBox->y2);
	    pBox++;
a924 4
	(*uxa_screen->info->done_solid) (pPixmap);

	ret = TRUE;
    }
d926 1
a926 1
    REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);
d928 1
a928 1
    return ret;
d935 4
a938 6
uxa_fill_region_tiled (DrawablePtr	pDrawable,
		       RegionPtr	pRegion,
		       PixmapPtr	pTile,
		       DDXPointPtr	pPatOrg,
		       CARD32		planemask,
		       CARD32		alu)
d940 68
a1007 61
    uxa_screen_t    *uxa_screen = uxa_get_screen(pDrawable->pScreen);
    PixmapPtr	    pPixmap;
    int		    xoff, yoff;
    int		    tileWidth, tileHeight;
    int		    nbox = REGION_NUM_RECTS (pRegion);
    BoxPtr	    pBox = REGION_RECTS (pRegion);
    Bool	    ret = FALSE;

    tileWidth = pTile->drawable.width;
    tileHeight = pTile->drawable.height;

    /* If we're filling with a solid color, grab it out and go to
     * FillRegionsolid, saving numerous copies.
     */
    if (tileWidth == 1 && tileHeight == 1)
	return uxa_fill_region_solid(pDrawable, pRegion,
				     uxa_get_pixmap_first_pixel (pTile), planemask,
				     alu);

    pPixmap = uxa_get_drawable_pixmap (pDrawable);
    uxa_get_drawable_deltas(pDrawable, pPixmap, &xoff, &yoff);
    REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);

    pPixmap = uxa_get_offscreen_pixmap (pDrawable, &xoff, &yoff);

    if (!pPixmap || !uxa_pixmap_is_offscreen(pTile))
	goto out;

    if ((*uxa_screen->info->prepare_copy) (pTile, pPixmap, 1, 1, alu, planemask))
    {
	while (nbox--)
	{
	    int height = pBox->y2 - pBox->y1;
	    int dstY = pBox->y1;
	    int tileY;

	    modulus(dstY - yoff - pDrawable->y - pPatOrg->y, tileHeight, tileY);

	    while (height > 0) {
		int width = pBox->x2 - pBox->x1;
		int dstX = pBox->x1;
		int tileX;
		int h = tileHeight - tileY;

		if (h > height)
		    h = height;
		height -= h;

		modulus(dstX - xoff - pDrawable->x - pPatOrg->x, tileWidth,
			tileX);

		while (width > 0) {
		    int w = tileWidth - tileX;
		    if (w > width)
			w = width;
		    width -= w;

		    (*uxa_screen->info->copy) (pPixmap, tileX, tileY, dstX, dstY,
					    w, h);
		    dstX += w;
		    tileX = 0;
d1009 3
a1011 4
		dstY += h;
		tileY = 0;
	    }
	    pBox++;
a1012 4
	(*uxa_screen->info->done_copy) (pPixmap);

	ret = TRUE;
    }
d1015 1
a1015 63
    REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);

    return ret;
}

#ifndef SERVER_1_5
void
uxa_paint_window(WindowPtr pWin, RegionPtr pRegion, int what)
{
    ScreenPtr       screen = pWin->drawable.pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(screen);
    DDXPointRec     zeros = { 0, 0 };

    if (REGION_NIL(pRegion))
	return;

    if (uxa_screen->swappedOut) {
	uxa_check_paint_window(pWin, pRegion, what);
	return;
    }

    switch (what) {
    case PW_BACKGROUND:
	switch (pWin->backgroundState) {
	case None:
	    return;
	case ParentRelative:
	    do {
		pWin = pWin->parent;
	    } while (pWin->backgroundState == ParentRelative);
	    (*pWin->drawable.pScreen->PaintWindowBackground)(pWin, pRegion,
							     what);
	    return;
	case BackgroundPixel:
	    if (uxa_fill_region_solid(&pWin->drawable, pRegion,
				      pWin->background.pixel,
				      FB_ALLONES, GXcopy))
		return;
	    break;
	case BackgroundPixmap:
	    if (uxa_fill_region_tiled(&pWin->drawable, pRegion,
				      pWin->background.pixmap,
				      &zeros, FB_ALLONES, GXcopy))
		return;
	    break;
	}
	break;
    case PW_BORDER:
	if (pWin->borderIsPixel) {
	    if (uxa_fill_region_solid(&pWin->drawable, pRegion,
				      pWin->border.pixel,
				      FB_ALLONES, GXcopy))
		return;
	    break;
	} else {
	    if (uxa_fill_region_tiled(&pWin->drawable, pRegion,
				      pWin->border.pixmap,
				      &zeros, FB_ALLONES, GXcopy))
		return;
	    break;
	}
	break;
    }
d1017 1
a1017 1
    uxa_check_paint_window(pWin, pRegion, what);
a1018 1
#endif /* !SERVER_1_5 */
d1028 2
a1029 2
uxa_get_image (DrawablePtr pDrawable, int x, int y, int w, int h,
	       unsigned int format, unsigned long planeMask, char *d)
d1031 37
a1067 37
    ScreenPtr       screen = pDrawable->pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(screen);
    BoxRec	    Box;
    PixmapPtr	    pPix = uxa_get_drawable_pixmap (pDrawable);
    int		    xoff, yoff;
    Bool	    ok;

    uxa_get_drawable_deltas (pDrawable, pPix, &xoff, &yoff);

    Box.x1 = pDrawable->y + x + xoff;
    Box.y1 = pDrawable->y + y + yoff;
    Box.x2 = Box.x1 + w;
    Box.y2 = Box.y1 + h;

    if (uxa_screen->swappedOut)
	goto fallback;

    pPix = uxa_get_offscreen_pixmap (pDrawable, &xoff, &yoff);

    if (pPix == NULL || uxa_screen->info->get_image == NULL)
	goto fallback;

    /* Only cover the ZPixmap, solid copy case. */
    if (format != ZPixmap || !UXA_PM_IS_SOLID(pDrawable, planeMask))
	goto fallback;

    /* Only try to handle the 8bpp and up cases, since we don't want to think
     * about <8bpp.
     */
    if (pDrawable->bitsPerPixel < 8)
	goto fallback;

    ok = uxa_screen->info->get_image(pPix, pDrawable->x + x + xoff,
					   pDrawable->y + y + yoff, w, h, d,
					   PixmapBytePad(w, pDrawable->depth));
    if (ok)
	return;
d1070 2
a1071 2
    UXA_FALLBACK(("from %p (%c)\n", pDrawable,
		  uxa_drawable_location(pDrawable)));
d1073 4
a1076 4
    if (uxa_prepare_access (pDrawable, UXA_ACCESS_RO)) {
	fbGetImage (pDrawable, x, y, w, h, format, planeMask, d);
	uxa_finish_access (pDrawable);
    }
d1078 1
a1078 1
   return;
@

