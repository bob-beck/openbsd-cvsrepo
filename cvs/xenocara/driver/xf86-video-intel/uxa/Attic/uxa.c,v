head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.02.03.15.54.54;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2013.03.18.18.38.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.09.21.13.06;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.18.14.47.48;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.10.22.32.30;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.18.14.56.03;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.25.20.16.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright Â© 2001 Keith Packard
 *
 * Partly based on code that is Copyright Â© The XFree86 Project Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/** @@file
 * This file covers the initialization and teardown of UXA, and has various
 * functions not responsible for performing rendering, pixmap migration, or
 * memory management.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "uxa-priv.h"
#include <X11/fonts/fontstruct.h>
#include "dixfontstr.h"
#include "uxa.h"
#include "uxa-glamor.h"

#if HAS_DEVPRIVATEKEYREC
DevPrivateKeyRec uxa_screen_index;
#else
int uxa_screen_index;
#endif

/**
 * uxa_get_drawable_pixmap() returns a backing pixmap for a given drawable.
 *
 * @@param pDrawable the drawable being requested.
 *
 * This function returns the backing pixmap for a drawable, whether it is a
 * redirected window, unredirected window, or already a pixmap.  Note that
 * coordinate translation is needed when drawing to the backing pixmap of a
 * redirected window, and the translation coordinates are provided by calling
 * uxa_get_drawable_pixmap() on the drawable.
 */
PixmapPtr uxa_get_drawable_pixmap(DrawablePtr pDrawable)
{
	if (pDrawable->type == DRAWABLE_WINDOW)
		return pDrawable->pScreen->
		    GetWindowPixmap((WindowPtr) pDrawable);
	else
		return (PixmapPtr) pDrawable;
}

/**
 * Sets the offsets to add to coordinates to make them address the same bits in
 * the backing drawable. These coordinates are nonzero only for redirected
 * windows.
 */
void
uxa_get_drawable_deltas(DrawablePtr pDrawable, PixmapPtr pPixmap,
			int *xp, int *yp)
{
#ifdef COMPOSITE
	if (pDrawable->type == DRAWABLE_WINDOW) {
		*xp = -pPixmap->screen_x;
		*yp = -pPixmap->screen_y;
		return;
	}
#endif

	*xp = 0;
	*yp = 0;
}

/**
 * uxa_pixmap_is_offscreen() is used to determine if a pixmap is in offscreen
 * memory, meaning that acceleration could probably be done to it, and that it
 * will need to be wrapped by PrepareAccess()/FinishAccess() when accessing it
 * with the CPU.
 *
 * Note that except for UploadToScreen()/DownloadFromScreen() (which explicitly
 * deal with moving pixmaps in and out of system memory), UXA will give drivers
 * pixmaps as arguments for which uxa_pixmap_is_offscreen() is TRUE.
 *
 * @@return TRUE if the given drawable is in framebuffer memory.
 */
Bool uxa_pixmap_is_offscreen(PixmapPtr p)
{
	ScreenPtr pScreen = p->drawable.pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);

	if (uxa_screen->info->pixmap_is_offscreen)
		return uxa_screen->info->pixmap_is_offscreen(p);

	return FALSE;
}

/**
 * uxa_drawable_is_offscreen() is a convenience wrapper for
 * uxa_pixmap_is_offscreen().
 */
Bool uxa_drawable_is_offscreen(DrawablePtr pDrawable)
{
	return uxa_pixmap_is_offscreen(uxa_get_drawable_pixmap(pDrawable));
}

/**
  * Returns the pixmap which backs a drawable, and the offsets to add to
  * coordinates to make them address the same bits in the backing drawable.
  */
PixmapPtr uxa_get_offscreen_pixmap(DrawablePtr drawable, int *xp, int *yp)
{
	PixmapPtr pixmap = uxa_get_drawable_pixmap(drawable);

	uxa_get_drawable_deltas(drawable, pixmap, xp, yp);

	if (uxa_pixmap_is_offscreen(pixmap))
		return pixmap;
	else
		return NULL;
}

/**
 * uxa_prepare_access() is UXA's wrapper for the driver's PrepareAccess() handler.
 *
 * It deals with waiting for synchronization with the card, determining if
 * PrepareAccess() is necessary, and working around PrepareAccess() failure.
 */
Bool uxa_prepare_access(DrawablePtr pDrawable, uxa_access_t access)
{
	ScreenPtr pScreen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	PixmapPtr pPixmap = uxa_get_drawable_pixmap(pDrawable);
	Bool offscreen = uxa_pixmap_is_offscreen(pPixmap);

	if (!offscreen)
		return TRUE;

	if (uxa_screen->info->prepare_access)
		return (*uxa_screen->info->prepare_access) (pPixmap, access);
	return TRUE;
}

/**
 * uxa_finish_access() is UXA's wrapper for the driver's finish_access() handler.
 *
 * It deals with calling the driver's finish_access() only if necessary.
 */
void uxa_finish_access(DrawablePtr pDrawable, uxa_access_t access)
{
	ScreenPtr pScreen = pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	PixmapPtr pPixmap;

	if (uxa_screen->info->finish_access == NULL)
		return;

	pPixmap = uxa_get_drawable_pixmap(pDrawable);
	if (!uxa_pixmap_is_offscreen(pPixmap))
		return;

	(*uxa_screen->info->finish_access) (pPixmap, access);
}

/**
 * uxa_validate_gc() sets the ops to UXA's implementations, which may be
 * accelerated or may sync the card and fall back to fb.
 */
static void
uxa_validate_gc(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pGC->pScreen);
	/* fbValidateGC will do direct access to pixmaps if the tiling has
	 * changed.
	 * Preempt fbValidateGC by doing its work and masking the change out, so
	 * that we can do the Prepare/finish_access.
	 */

	/* If we are using GLAMOR, then the tile or stipple pixmap
	 * may be pure GLAMOR pixmap, then we should let the glamor
	 * to do the validation.
	 */
	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		glamor_validate_gc(pGC, changes, pDrawable);
		goto set_ops;
	}
#ifdef FB_24_32BIT
	if ((changes & GCTile) && fbGetRotatedPixmap(pGC)) {
		(*pGC->pScreen->DestroyPixmap) (fbGetRotatedPixmap(pGC));
		fbGetRotatedPixmap(pGC) = 0;
	}

	if (pGC->fillStyle == FillTiled) {
		PixmapPtr pOldTile, pNewTile;

		pOldTile = pGC->tile.pixmap;
		if (pOldTile->drawable.bitsPerPixel != pDrawable->bitsPerPixel) {
			pNewTile = fbGetRotatedPixmap(pGC);
			if (!pNewTile ||
			    pNewTile->drawable.bitsPerPixel !=
			    pDrawable->bitsPerPixel) {
				if (pNewTile)
					(*pGC->pScreen->
					 DestroyPixmap) (pNewTile);
				/* fb24_32ReformatTile will do direct access
				 * of a newly-allocated pixmap.  This isn't a
				 * problem yet, since we don't put pixmaps in
				 * FB until at least one accelerated UXA op.
				 */
				if (uxa_prepare_access
				    (&pOldTile->drawable, UXA_ACCESS_RO)) {
					pNewTile =
					    fb24_32ReformatTile(pOldTile,
								pDrawable->
								bitsPerPixel);
					uxa_finish_access(&pOldTile->drawable, UXA_ACCESS_RO);
				}
			}
			if (pNewTile) {
				fbGetRotatedPixmap(pGC) = pOldTile;
				pGC->tile.pixmap = pNewTile;
				changes |= GCTile;
			}
		}
	}
#endif
	if (changes & GCTile) {
		if (!pGC->tileIsPixel
		    && FbEvenTile(pGC->tile.pixmap->drawable.width *
				  pDrawable->bitsPerPixel)) {
			if (uxa_prepare_access
			    (&pGC->tile.pixmap->drawable, UXA_ACCESS_RW)) {
				fbPadPixmap(pGC->tile.pixmap);
				uxa_finish_access(&pGC->tile.pixmap->drawable, UXA_ACCESS_RW);
			}
		}
		/* Mask out the GCTile change notification, now that we've
		 * done FB's job for it.
		 */
		changes &= ~GCTile;
	}

	if (changes & GCStipple && pGC->stipple) {
		/* We can't inline stipple handling like we do for GCTile
		 * because it sets fbgc privates.
		 */
		if (uxa_prepare_access(&pGC->stipple->drawable, UXA_ACCESS_RW)) {
			fbValidateGC(pGC, changes, pDrawable);
			uxa_finish_access(&pGC->stipple->drawable, UXA_ACCESS_RW);
		}
	} else {
		fbValidateGC(pGC, changes, pDrawable);
	}

set_ops:
	pGC->ops = (GCOps *) & uxa_ops;
}

static GCFuncs uxaGCFuncs = {
	uxa_validate_gc,
	miChangeGC,
	miCopyGC,
	miDestroyGC,
	miChangeClip,
	miDestroyClip,
	miCopyClip
};

/**
 * uxa_create_gc makes a new GC and hooks up its funcs handler, so that
 * uxa_validate_gc() will get called.
 */
static int uxa_create_gc(GCPtr pGC)
{
	if (!fbCreateGC(pGC))
		return FALSE;

	pGC->funcs = &uxaGCFuncs;

	return TRUE;
}

Bool uxa_prepare_access_window(WindowPtr pWin)
{
	if (pWin->backgroundState == BackgroundPixmap) {
		if (!uxa_prepare_access
		    (&pWin->background.pixmap->drawable, UXA_ACCESS_RO))
			return FALSE;
	}

	if (pWin->borderIsPixel == FALSE) {
		if (!uxa_prepare_access
		    (&pWin->border.pixmap->drawable, UXA_ACCESS_RO)) {
			if (pWin->backgroundState == BackgroundPixmap)
				uxa_finish_access(&pWin->background.pixmap->
						  drawable, UXA_ACCESS_RO);
			return FALSE;
		}
	}
	return TRUE;
}

void uxa_finish_access_window(WindowPtr pWin)
{
	if (pWin->backgroundState == BackgroundPixmap)
		uxa_finish_access(&pWin->background.pixmap->drawable, UXA_ACCESS_RO);

	if (pWin->borderIsPixel == FALSE)
		uxa_finish_access(&pWin->border.pixmap->drawable, UXA_ACCESS_RO);
}

static Bool uxa_change_window_attributes(WindowPtr pWin, unsigned long mask)
{
	Bool ret;

	if (!uxa_prepare_access_window(pWin))
		return FALSE;
	ret = fbChangeWindowAttributes(pWin, mask);
	uxa_finish_access_window(pWin);
	return ret;
}

static RegionPtr uxa_bitmap_to_region(PixmapPtr pPix)
{
	RegionPtr ret;
	if (!uxa_prepare_access(&pPix->drawable, UXA_ACCESS_RO))
		return NULL;
	ret = fbPixmapToRegion(pPix);
	uxa_finish_access(&pPix->drawable, UXA_ACCESS_RO);
	return ret;
}

void uxa_set_fallback_debug(ScreenPtr screen, Bool enable)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	uxa_screen->fallback_debug = enable;
}

void uxa_set_force_fallback(ScreenPtr screen, Bool value)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	uxa_screen->force_fallback = value;
}

/**
 * uxa_close_screen() unwraps its wrapped screen functions and tears down UXA's
 * screen private, before calling down to the next CloseSccreen.
 */
static Bool uxa_close_screen(CLOSE_SCREEN_ARGS_DECL)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
#ifdef RENDER
	PictureScreenPtr ps = GetPictureScreenIfSet(screen);
#endif
	int n;

	if (uxa_screen->solid_clear)
		FreePicture(uxa_screen->solid_clear, 0);
	if (uxa_screen->solid_black)
		FreePicture(uxa_screen->solid_black, 0);
	if (uxa_screen->solid_white)
		FreePicture(uxa_screen->solid_white, 0);
	for (n = 0; n < uxa_screen->solid_cache_size; n++)
		FreePicture(uxa_screen->solid_cache[n].picture, 0);

	uxa_glyphs_fini(screen);

	if (screen->devPrivate) {
		/* Destroy the pixmap created by miScreenInit() *before*
		 * chaining up as we finalize ourselves here and so this
		 * is the last chance we have of releasing our resources
		 * associated with the Pixmap. So do it first.
		 */
		(void) (*screen->DestroyPixmap) (screen->devPrivate);
		screen->devPrivate = NULL;
	}

	screen->CreateGC = uxa_screen->SavedCreateGC;
	screen->CloseScreen = uxa_screen->SavedCloseScreen;
	screen->GetImage = uxa_screen->SavedGetImage;
	screen->GetSpans = uxa_screen->SavedGetSpans;
	screen->CreatePixmap = uxa_screen->SavedCreatePixmap;
	screen->DestroyPixmap = uxa_screen->SavedDestroyPixmap;
	screen->CopyWindow = uxa_screen->SavedCopyWindow;
	screen->ChangeWindowAttributes =
	    uxa_screen->SavedChangeWindowAttributes;
	screen->BitmapToRegion = uxa_screen->SavedBitmapToRegion;
#ifdef RENDER
	if (ps) {
		ps->Composite = uxa_screen->SavedComposite;
		ps->Glyphs = uxa_screen->SavedGlyphs;
		ps->Trapezoids = uxa_screen->SavedTrapezoids;
		ps->AddTraps = uxa_screen->SavedAddTraps;
		ps->Triangles = uxa_screen->SavedTriangles;

		ps->UnrealizeGlyph = uxa_screen->SavedUnrealizeGlyph;
	}
#endif

	free(uxa_screen);

	return (*screen->CloseScreen) (CLOSE_SCREEN_ARGS);
}

/**
 * This function allocates a driver structure for UXA drivers to fill in.  By
 * having UXA allocate the structure, the driver structure can be extended
 * without breaking ABI between UXA and the drivers.  The driver's
 * responsibility is to check beforehand that the UXA module has a matching
 * major number and sufficient minor.  Drivers are responsible for freeing the
 * driver structure using free().
 *
 * @@return a newly allocated, zero-filled driver structure
 */
uxa_driver_t *uxa_driver_alloc(void)
{
	return calloc(1, sizeof(uxa_driver_t));
}

/**
 * @@param screen screen being initialized
 * @@param pScreenInfo UXA driver record
 *
 * uxa_driver_init sets up UXA given a driver record filled in by the driver.
 * pScreenInfo should have been allocated by uxa_driver_alloc().  See the
 * comments in _UxaDriver for what must be filled in and what is optional.
 *
 * @@return TRUE if UXA was successfully initialized.
 */
Bool uxa_driver_init(ScreenPtr screen, uxa_driver_t * uxa_driver)
{
	uxa_screen_t *uxa_screen;

	if (!uxa_driver)
		return FALSE;

	if (uxa_driver->uxa_major != UXA_VERSION_MAJOR ||
	    uxa_driver->uxa_minor > UXA_VERSION_MINOR) {
		LogMessage(X_ERROR,
			   "UXA(%d): driver's UXA version requirements "
			   "(%d.%d) are incompatible with UXA version (%d.%d)\n",
			   screen->myNum, uxa_driver->uxa_major,
			   uxa_driver->uxa_minor, UXA_VERSION_MAJOR,
			   UXA_VERSION_MINOR);
		return FALSE;
	}

	if (!uxa_driver->prepare_solid) {
		LogMessage(X_ERROR,
			   "UXA(%d): uxa_driver_t::prepare_solid must be "
			   "non-NULL\n", screen->myNum);
		return FALSE;
	}

	if (!uxa_driver->prepare_copy) {
		LogMessage(X_ERROR,
			   "UXA(%d): uxa_driver_t::prepare_copy must be "
			   "non-NULL\n", screen->myNum);
		return FALSE;
	}
#if HAS_DIXREGISTERPRIVATEKEY
	if (!dixRegisterPrivateKey(&uxa_screen_index, PRIVATE_SCREEN, 0))
	    return FALSE;
#endif
	uxa_screen = calloc(sizeof(uxa_screen_t), 1);

	if (!uxa_screen) {
		LogMessage(X_WARNING,
			   "UXA(%d): Failed to allocate screen private\n",
			   screen->myNum);
		return FALSE;
	}

	uxa_screen->info = uxa_driver;

	dixSetPrivate(&screen->devPrivates, &uxa_screen_index, uxa_screen);

	uxa_screen->force_fallback = FALSE;

	uxa_screen->solid_cache_size = 0;
	uxa_screen->solid_clear = 0;
	uxa_screen->solid_black = 0;
	uxa_screen->solid_white = 0;

//    exaDDXDriverInit(screen);

	/*
	 * Replace various fb screen functions
	 */
	uxa_screen->SavedCloseScreen = screen->CloseScreen;
	screen->CloseScreen = uxa_close_screen;

	uxa_screen->SavedCreateGC = screen->CreateGC;
	screen->CreateGC = uxa_create_gc;

	uxa_screen->SavedGetImage = screen->GetImage;
	screen->GetImage = uxa_get_image;

	uxa_screen->SavedGetSpans = screen->GetSpans;
	screen->GetSpans = uxa_get_spans;

	uxa_screen->SavedCopyWindow = screen->CopyWindow;
	screen->CopyWindow = uxa_copy_window;

	uxa_screen->SavedChangeWindowAttributes =
	    screen->ChangeWindowAttributes;
	screen->ChangeWindowAttributes = uxa_change_window_attributes;

	uxa_screen->SavedBitmapToRegion = screen->BitmapToRegion;
	screen->BitmapToRegion = uxa_bitmap_to_region;

#ifdef RENDER
	{
		PictureScreenPtr ps = GetPictureScreenIfSet(screen);
		if (ps) {
			uxa_screen->SavedComposite = ps->Composite;
			ps->Composite = uxa_composite;

			uxa_screen->SavedGlyphs = ps->Glyphs;
			ps->Glyphs = uxa_glyphs;

			uxa_screen->SavedUnrealizeGlyph = ps->UnrealizeGlyph;
			ps->UnrealizeGlyph = uxa_glyph_unrealize;

			uxa_screen->SavedTriangles = ps->Triangles;
			ps->Triangles = uxa_triangles;

			uxa_screen->SavedTrapezoids = ps->Trapezoids;
			ps->Trapezoids = uxa_trapezoids;

			uxa_screen->SavedAddTraps = ps->AddTraps;
			ps->AddTraps = uxa_add_traps;
		}
	}
#endif

	LogMessage(X_INFO,
		   "UXA(%d): Driver registered support for the following"
		   " operations:\n", screen->myNum);
	assert(uxa_driver->prepare_solid != NULL);
	LogMessage(X_INFO, "        solid\n");
	assert(uxa_driver->prepare_copy != NULL);
	LogMessage(X_INFO, "        copy\n");
	if (uxa_driver->prepare_composite != NULL) {
		LogMessage(X_INFO, "        composite (RENDER acceleration)\n");
	}
	if (uxa_driver->put_image != NULL) {
		LogMessage(X_INFO, "        put_image\n");
	}
	if (uxa_driver->get_image != NULL) {
		LogMessage(X_INFO, "        get_image\n");
	}

	return TRUE;
}

Bool uxa_resources_init(ScreenPtr screen)
{
	if (!uxa_glyphs_init(screen))
		return FALSE;

	return TRUE;
}

/**
 * uxa_driver_fini tears down UXA on a given screen.
 *
 * @@param pScreen screen being torn down.
 */
void uxa_driver_fini(ScreenPtr pScreen)
{
	/*right now does nothing */
}
@


1.7
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.6
log
@Add compat-api.h. 1st step to get this version of the intel driver
working with xserver 1.13.
@
text
@d41 1
d164 1
a164 1
void uxa_finish_access(DrawablePtr pDrawable)
d177 1
a177 1
	(*uxa_screen->info->finish_access) (pPixmap);
d187 1
d193 9
d231 1
a231 1
					uxa_finish_access(&pOldTile->drawable);
d249 1
a249 1
				uxa_finish_access(&pGC->tile.pixmap->drawable);
d264 1
a264 1
			uxa_finish_access(&pGC->stipple->drawable);
d270 1
d311 1
a311 1
						  drawable);
d321 1
a321 1
		uxa_finish_access(&pWin->background.pixmap->drawable);
d324 1
a324 1
		uxa_finish_access(&pWin->border.pixmap->drawable);
d344 1
a344 1
	uxa_finish_access(&pPix->drawable);
a347 15
static void uxa_xorg_enable_disable_fb_access(SCRN_ARG_TYPE arg, Bool enable)
{
	SCRN_INFO_PTR(arg);
	uxa_screen_t *uxa_screen = uxa_get_screen(scrn->pScreen);

	if (!enable && uxa_screen->disableFbCount++ == 0)
		uxa_screen->swappedOut = TRUE;

	if (enable && --uxa_screen->disableFbCount == 0)
		uxa_screen->swappedOut = FALSE;

	if (uxa_screen->SavedEnableDisableFBAccess)
		uxa_screen->SavedEnableDisableFBAccess(arg, enable);
}

a368 1
	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
a404 1
	scrn->EnableDisableFBAccess = uxa_screen->SavedEnableDisableFBAccess;
a407 1
		ps->CompositeRects = uxa_screen->SavedCompositeRects;
d438 1
a438 1
 * @@param pScreen screen being initialized
a449 1
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d517 1
a517 1
	screen->GetSpans = uxa_check_get_spans;
a528 3
	uxa_screen->SavedEnableDisableFBAccess = scrn->EnableDisableFBAccess;
	scrn->EnableDisableFBAccess = uxa_xorg_enable_disable_fb_access;

a535 3
			uxa_screen->SavedCompositeRects = ps->CompositeRects;
			ps->CompositeRects = uxa_solid_rects;

d549 1
a549 1
			ps->AddTraps = uxa_check_add_traps;
@


1.5
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d336 1
a336 1
static void uxa_xorg_enable_disable_fb_access(int index, Bool enable)
d338 2
a339 2
	ScreenPtr screen = screenInfo.screens[index];
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
d348 1
a348 1
		uxa_screen->SavedEnableDisableFBAccess(index, enable);
d369 1
a369 1
static Bool uxa_close_screen(int i, ScreenPtr pScreen)
d371 2
a372 2
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
d374 1
a374 1
	PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
d387 1
a387 1
	uxa_glyphs_fini(pScreen);
d389 1
a389 1
	if (pScreen->devPrivate) {
d395 2
a396 2
		(void) (*pScreen->DestroyPixmap) (pScreen->devPrivate);
		pScreen->devPrivate = NULL;
d399 8
a406 8
	pScreen->CreateGC = uxa_screen->SavedCreateGC;
	pScreen->CloseScreen = uxa_screen->SavedCloseScreen;
	pScreen->GetImage = uxa_screen->SavedGetImage;
	pScreen->GetSpans = uxa_screen->SavedGetSpans;
	pScreen->CreatePixmap = uxa_screen->SavedCreatePixmap;
	pScreen->DestroyPixmap = uxa_screen->SavedDestroyPixmap;
	pScreen->CopyWindow = uxa_screen->SavedCopyWindow;
	pScreen->ChangeWindowAttributes =
d408 1
a408 1
	pScreen->BitmapToRegion = uxa_screen->SavedBitmapToRegion;
d425 1
a425 1
	return (*pScreen->CloseScreen) (i, pScreen);
@


1.4
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d2 1
a2 1
 * Copyright © 2001 Keith Packard
d4 1
a4 1
 * Partly based on code that is Copyright © The XFree86 Project Inc.
d167 1
a167 1
	PixmapPtr pPixmap = uxa_get_drawable_pixmap(pDrawable);
d172 1
d358 7
d389 10
d501 2
@


1.3
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d42 3
d46 1
d395 1
d400 2
d405 1
a405 1
	xfree(uxa_screen);
d416 1
a416 1
 * driver structure using xfree().
d422 1
a422 1
	return xcalloc(1, sizeof(uxa_driver_t));
a438 3
#ifdef RENDER
	PictureScreenPtr ps;
#endif
d467 3
a469 2
#ifdef RENDER
	ps = GetPictureScreenIfSet(screen);
d471 1
a471 2

	uxa_screen = xcalloc(sizeof(uxa_screen_t), 1);
d520 11
a530 3
	if (ps) {
		uxa_screen->SavedComposite = ps->Composite;
		ps->Composite = uxa_composite;
d532 2
a533 2
		uxa_screen->SavedGlyphs = ps->Glyphs;
		ps->Glyphs = uxa_glyphs;
d535 2
a536 2
		uxa_screen->SavedTriangles = ps->Triangles;
		ps->Triangles = uxa_triangles;
d538 2
a539 2
		uxa_screen->SavedTrapezoids = ps->Trapezoids;
		ps->Trapezoids = uxa_trapezoids;
d541 3
a543 2
		uxa_screen->SavedAddTraps = ps->AddTraps;
		ps->AddTraps = uxa_check_add_traps;
a546 10
#ifdef MITSHM
	/* Re-register with the MI funcs, which don't allow shared pixmaps.
	 * Shared pixmaps are almost always a performance loss for us, but this
	 * still allows for SHM PutImage.
	 */
	ShmRegisterFuncs(screen, &uxa_shm_funcs);
#endif

	uxa_glyphs_init(screen);

d563 8
@


1.2
log
@Accessing a pixmap in fallback if the prepare_access() callback failed
is verboten

So don't do it. Treat it the same as every other prepare access call in
uxa.  This patch sent upstream.

ok matthieu@@
@
text
@a42 3
#ifndef SERVER_1_5
static int uxa_generation;
#endif
d55 1
a55 2
PixmapPtr
uxa_get_drawable_pixmap(DrawablePtr pDrawable)
d57 6
a62 5
     if (pDrawable->type == DRAWABLE_WINDOW)
	return pDrawable->pScreen->GetWindowPixmap ((WindowPtr) pDrawable);
     else
	return (PixmapPtr) pDrawable;
}	
d70 2
a71 2
uxa_get_drawable_deltas (DrawablePtr pDrawable, PixmapPtr pPixmap,
			 int *xp, int *yp)
d74 5
a78 5
    if (pDrawable->type == DRAWABLE_WINDOW) {
	*xp = -pPixmap->screen_x;
	*yp = -pPixmap->screen_y;
	return;
    }
d81 2
a82 2
    *xp = 0;
    *yp = 0;
d97 1
a97 2
Bool
uxa_pixmap_is_offscreen(PixmapPtr p)
d99 2
a100 2
    ScreenPtr	    pScreen = p->drawable.pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
d102 2
a103 2
    if (uxa_screen->info->pixmap_is_offscreen)
	return uxa_screen->info->pixmap_is_offscreen(p);
d105 1
a105 1
    return FALSE;
d109 2
a110 1
 * uxa_drawable_is_offscreen() is a convenience wrapper for uxa_pixmap_is_offscreen().
d112 1
a112 2
Bool
uxa_drawable_is_offscreen (DrawablePtr pDrawable)
d114 1
a114 1
    return uxa_pixmap_is_offscreen (uxa_get_drawable_pixmap (pDrawable));
d121 1
a121 2
PixmapPtr
uxa_get_offscreen_pixmap (DrawablePtr drawable, int *xp, int *yp)
d123 1
a123 1
    PixmapPtr   pixmap = uxa_get_drawable_pixmap (drawable);
d125 1
a125 1
    uxa_get_drawable_deltas (drawable, pixmap, xp, yp);
d127 4
a130 4
    if (uxa_pixmap_is_offscreen (pixmap))
	return pixmap;
    else
	return NULL;
a132 2


d139 1
a139 2
Bool
uxa_prepare_access(DrawablePtr pDrawable, uxa_access_t access)
d141 7
a147 4
    ScreenPtr	    pScreen = pDrawable->pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    PixmapPtr	    pPixmap = uxa_get_drawable_pixmap (pDrawable);
    Bool	    offscreen = uxa_pixmap_is_offscreen(pPixmap);
d149 2
a150 1
    if (!offscreen)
a151 4

    if (uxa_screen->info->prepare_access)
	return (*uxa_screen->info->prepare_access) (pPixmap, access);
    return TRUE;
d159 1
a159 2
void
uxa_finish_access(DrawablePtr pDrawable)
d161 3
a163 3
    ScreenPtr	    pScreen = pDrawable->pScreen;
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    PixmapPtr	    pPixmap = uxa_get_drawable_pixmap (pDrawable);
d165 2
a166 2
    if (uxa_screen->info->finish_access == NULL)
	return;
d168 2
a169 2
    if (!uxa_pixmap_is_offscreen (pPixmap))
	return;
d171 1
a171 1
    (*uxa_screen->info->finish_access) (pPixmap);
d179 1
a179 1
uxa_validate_gc (GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
d181 5
a185 4
    /* fbValidateGC will do direct access to pixmaps if the tiling has changed.
     * Preempt fbValidateGC by doing its work and masking the change out, so
     * that we can do the Prepare/finish_access.
     */
d187 36
a222 25
    if ((changes & GCTile) && fbGetRotatedPixmap(pGC)) {
	(*pGC->pScreen->DestroyPixmap) (fbGetRotatedPixmap(pGC));
	fbGetRotatedPixmap(pGC) = 0;
    }
	
    if (pGC->fillStyle == FillTiled) {
	PixmapPtr	pOldTile, pNewTile;

	pOldTile = pGC->tile.pixmap;
	if (pOldTile->drawable.bitsPerPixel != pDrawable->bitsPerPixel)
	{
	    pNewTile = fbGetRotatedPixmap(pGC);
	    if (!pNewTile ||
		pNewTile ->drawable.bitsPerPixel != pDrawable->bitsPerPixel)
	    {
		if (pNewTile)
		    (*pGC->pScreen->DestroyPixmap) (pNewTile);
		/* fb24_32ReformatTile will do direct access of a newly-
		 * allocated pixmap.  This isn't a problem yet, since we don't
		 * put pixmaps in FB until at least one accelerated UXA op.
		 */
		if (uxa_prepare_access(&pOldTile->drawable, UXA_ACCESS_RO)) {
		    pNewTile = fb24_32ReformatTile (pOldTile,
						    pDrawable->bitsPerPixel);
		    uxa_finish_access(&pOldTile->drawable);
a223 7
	    }
	    if (pNewTile)
	    {
		fbGetRotatedPixmap(pGC) = pOldTile;
		pGC->tile.pixmap = pNewTile;
		changes |= GCTile;
	    }
a224 1
    }
d226 14
a239 8
    if (changes & GCTile) {
	if (!pGC->tileIsPixel && FbEvenTile (pGC->tile.pixmap->drawable.width *
					     pDrawable->bitsPerPixel))
	{
	    if (uxa_prepare_access(&pGC->tile.pixmap->drawable, UXA_ACCESS_RW)) {
		fbPadPixmap (pGC->tile.pixmap);
		uxa_finish_access(&pGC->tile.pixmap->drawable);
	    }
a240 5
	/* Mask out the GCTile change notification, now that we've done FB's
	 * job for it.
	 */
	changes &= ~GCTile;
    }
d242 23
a264 23
    if (changes & GCStipple && pGC->stipple) {
	/* We can't inline stipple handling like we do for GCTile because it sets
	 * fbgc privates.
	 */
	if (uxa_prepare_access(&pGC->stipple->drawable, UXA_ACCESS_RW)) {
	    fbValidateGC (pGC, changes, pDrawable);
	    uxa_finish_access(&pGC->stipple->drawable);
	}
    } else {
	fbValidateGC (pGC, changes, pDrawable);
    }

    pGC->ops = (GCOps *) &uxa_ops;
}

static GCFuncs	uxaGCFuncs = {
    uxa_validate_gc,
    miChangeGC,
    miCopyGC,
    miDestroyGC,
    miChangeClip,
    miDestroyClip,
    miCopyClip
d271 1
a271 2
static int
uxa_create_gc (GCPtr pGC)
d273 2
a274 2
    if (!fbCreateGC (pGC))
	return FALSE;
d276 1
a276 1
    pGC->funcs = &uxaGCFuncs;
d278 1
a278 1
    return TRUE;
d281 1
a281 2
Bool
uxa_prepare_access_window(WindowPtr pWin)
d283 5
a287 4
    if (pWin->backgroundState == BackgroundPixmap) {
        if (!uxa_prepare_access(&pWin->background.pixmap->drawable, UXA_ACCESS_RO))
	    return FALSE;
    }
d289 8
a296 5
    if (pWin->borderIsPixel == FALSE) {
        if (!uxa_prepare_access(&pWin->border.pixmap->drawable, UXA_ACCESS_RO)) {
	    if (pWin->backgroundState == BackgroundPixmap)
		uxa_finish_access(&pWin->background.pixmap->drawable);
	    return FALSE;
d298 1
a298 2
    }
    return TRUE;
d301 1
a301 2
void
uxa_finish_access_window(WindowPtr pWin)
d303 2
a304 2
    if (pWin->backgroundState == BackgroundPixmap) 
        uxa_finish_access(&pWin->background.pixmap->drawable);
d306 2
a307 2
    if (pWin->borderIsPixel == FALSE)
        uxa_finish_access(&pWin->border.pixmap->drawable);
d310 1
a310 2
static Bool
uxa_change_window_attributes(WindowPtr pWin, unsigned long mask)
d312 1
a312 1
    Bool ret;
d314 5
a318 5
    if (!uxa_prepare_access_window(pWin))
	return FALSE;
    ret = fbChangeWindowAttributes(pWin, mask);
    uxa_finish_access_window(pWin);
    return ret;
d321 8
a328 9
static RegionPtr
uxa_bitmap_to_region(PixmapPtr pPix)
{
  RegionPtr ret;
  if (!uxa_prepare_access(&pPix->drawable, UXA_ACCESS_RO))
    return NULL;
  ret = fbPixmapToRegion(pPix);
  uxa_finish_access(&pPix->drawable);
  return ret;
d331 1
a331 2
static void
uxa_xorg_enable_disable_fb_access (int index, Bool enable)
d333 2
a334 2
    ScreenPtr screen = screenInfo.screens[index];
    uxa_screen_t *uxa_screen = uxa_get_screen(screen);
d336 2
a337 2
    if (!enable && uxa_screen->disableFbCount++ == 0)
	uxa_screen->swappedOut = TRUE;
d339 2
a340 2
    if (enable && --uxa_screen->disableFbCount == 0)
	uxa_screen->swappedOut = FALSE;
d342 2
a343 2
    if (uxa_screen->SavedEnableDisableFBAccess)
       uxa_screen->SavedEnableDisableFBAccess(index, enable);
d346 1
a346 2
void
uxa_set_fallback_debug (ScreenPtr screen, Bool enable)
d348 1
a348 1
    uxa_screen_t *uxa_screen = uxa_get_screen(screen);
d350 1
a350 1
    uxa_screen->fallback_debug = enable;
d357 1
a357 2
static Bool
uxa_close_screen(int i, ScreenPtr pScreen)
d359 2
a360 2
    uxa_screen_t	*uxa_screen = uxa_get_screen(pScreen);
    ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
d362 1
a362 5
    PictureScreenPtr	ps = GetPictureScreenIfSet(pScreen);
#endif

#ifdef SERVER_1_5
    uxa_glyphs_fini(pScreen);
d364 1
d366 22
a387 14
    pScreen->CreateGC = uxa_screen->SavedCreateGC;
    pScreen->CloseScreen = uxa_screen->SavedCloseScreen;
    pScreen->GetImage = uxa_screen->SavedGetImage;
    pScreen->GetSpans = uxa_screen->SavedGetSpans;
#ifndef SERVER_1_5
    pScreen->PaintWindowBackground = uxa_screen->SavedPaintWindowBackground;
    pScreen->PaintWindowBorder = uxa_screen->SavedPaintWindowBorder;
#endif
    pScreen->CreatePixmap = uxa_screen->SavedCreatePixmap;
    pScreen->DestroyPixmap = uxa_screen->SavedDestroyPixmap;
    pScreen->CopyWindow = uxa_screen->SavedCopyWindow;
    pScreen->ChangeWindowAttributes = uxa_screen->SavedChangeWindowAttributes;
    pScreen->BitmapToRegion = uxa_screen->SavedBitmapToRegion;
    scrn->EnableDisableFBAccess = uxa_screen->SavedEnableDisableFBAccess;
d389 7
a395 7
    if (ps) {
	ps->Composite = uxa_screen->SavedComposite;
	ps->Glyphs = uxa_screen->SavedGlyphs;
	ps->Trapezoids = uxa_screen->SavedTrapezoids;
	ps->AddTraps = uxa_screen->SavedAddTraps;
	ps->Triangles = uxa_screen->SavedTriangles;
    }
d398 1
a398 1
    xfree (uxa_screen);
d400 1
a400 1
    return (*pScreen->CloseScreen) (i, pScreen);
d413 1
a413 2
uxa_driver_t *
uxa_driver_alloc(void)
d415 1
a415 1
    return xcalloc(1, sizeof(uxa_driver_t));
d428 1
a428 2
Bool
uxa_driver_init(ScreenPtr screen, uxa_driver_t *uxa_driver)
d430 2
a431 2
    uxa_screen_t	*uxa_screen;
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d433 1
a433 1
    PictureScreenPtr	ps;
d436 2
a437 13
    if (!uxa_driver)
	return FALSE;

    if (uxa_driver->uxa_major != UXA_VERSION_MAJOR ||
	uxa_driver->uxa_minor > UXA_VERSION_MINOR)
    {
	LogMessage(X_ERROR, "UXA(%d): driver's UXA version requirements "
		   "(%d.%d) are incompatible with UXA version (%d.%d)\n",
		   screen->myNum,
		   uxa_driver->uxa_major, uxa_driver->uxa_minor,
		   UXA_VERSION_MAJOR, UXA_VERSION_MINOR);
	return FALSE;
    }
d439 10
a448 5
    if (!uxa_driver->prepare_solid) {
	LogMessage(X_ERROR, "UXA(%d): uxa_driver_t::prepare_solid must be "
		   "non-NULL\n", screen->myNum);
	return FALSE;
    }
d450 6
a455 5
    if (!uxa_driver->prepare_copy) {
	LogMessage(X_ERROR, "UXA(%d): uxa_driver_t::prepare_copy must be "
		   "non-NULL\n", screen->myNum);
	return FALSE;
    }
d457 6
d464 1
a464 1
    ps = GetPictureScreenIfSet(screen);
d467 8
a474 1
    uxa_screen = xcalloc (sizeof (uxa_screen_t), 1);
d476 1
a476 5
    if (!uxa_screen) {
        LogMessage(X_WARNING, "UXA(%d): Failed to allocate screen private\n",
		   screen->myNum);
	return FALSE;
    }
d478 1
a478 1
    uxa_screen->info = uxa_driver;
d480 4
a483 9
#ifdef SERVER_1_5
    dixSetPrivate(&screen->devPrivates, &uxa_screen_index, uxa_screen);
#else
    if (uxa_generation != serverGeneration) {
	uxa_screen_index = AllocateScreenPrivateIndex();
	uxa_generation = serverGeneration;
    }
    screen->devPrivates[uxa_screen_index].ptr = uxa_screen;
#endif
d487 5
a491 5
    /*
     * Replace various fb screen functions
     */
    uxa_screen->SavedCloseScreen = screen->CloseScreen;
    screen->CloseScreen = uxa_close_screen;
d493 2
a494 2
    uxa_screen->SavedCreateGC = screen->CreateGC;
    screen->CreateGC = uxa_create_gc;
d496 2
a497 2
    uxa_screen->SavedGetImage = screen->GetImage;
    screen->GetImage = uxa_get_image;
d499 2
a500 2
    uxa_screen->SavedGetSpans = screen->GetSpans;
    screen->GetSpans = uxa_check_get_spans;
d502 2
a503 3
#ifndef SERVER_1_5
    uxa_screen->SavedPaintWindowBackground = screen->PaintWindowBackground;
    screen->PaintWindowBackground = uxa_paint_window;
d505 3
a507 3
    uxa_screen->SavedPaintWindowBorder = screen->PaintWindowBorder;
    screen->PaintWindowBorder = uxa_paint_window;
#endif /* !SERVER_1_5 */
d509 2
a510 2
    uxa_screen->SavedCopyWindow = screen->CopyWindow;
    screen->CopyWindow = uxa_copy_window;
d512 2
a513 2
    uxa_screen->SavedChangeWindowAttributes = screen->ChangeWindowAttributes;
    screen->ChangeWindowAttributes = uxa_change_window_attributes;
d515 4
a518 2
    uxa_screen->SavedBitmapToRegion = screen->BitmapToRegion;
    screen->BitmapToRegion = uxa_bitmap_to_region;
d520 2
a521 2
    uxa_screen->SavedEnableDisableFBAccess = scrn->EnableDisableFBAccess;
    scrn->EnableDisableFBAccess = uxa_xorg_enable_disable_fb_access;
d523 2
a524 9
#ifdef RENDER
    if (ps) {
        uxa_screen->SavedComposite = ps->Composite;
	ps->Composite = uxa_composite;

#ifdef SERVER_1_5
	uxa_screen->SavedGlyphs = ps->Glyphs;
	ps->Glyphs = uxa_glyphs;
#endif
d526 2
a527 2
	uxa_screen->SavedTriangles = ps->Triangles;
	ps->Triangles = uxa_triangles;
d529 3
a531 6
	uxa_screen->SavedTrapezoids = ps->Trapezoids;
	ps->Trapezoids = uxa_trapezoids;

	uxa_screen->SavedAddTraps = ps->AddTraps;
	ps->AddTraps = uxa_check_add_traps;
    }
d535 5
a539 5
    /* Re-register with the MI funcs, which don't allow shared pixmaps.
     * Shared pixmaps are almost always a performance loss for us, but this
     * still allows for SHM PutImage.
     */
    ShmRegisterFuncs(screen, &uxa_shm_funcs);
d542 1
a542 3
#ifdef SERVER_1_5
    uxa_glyphs_init(screen);
#endif
d544 16
a559 15
    LogMessage(X_INFO, "UXA(%d): Driver registered support for the following"
	       " operations:\n", screen->myNum);
    assert(uxa_driver->prepare_solid != NULL);
    LogMessage(X_INFO, "        solid\n");
    assert(uxa_driver->prepare_copy != NULL);
    LogMessage(X_INFO, "        copy\n");
    if (uxa_driver->prepare_composite != NULL) {
	LogMessage(X_INFO, "        composite (RENDER acceleration)\n");
    }
    if (uxa_driver->put_image != NULL) {
	LogMessage(X_INFO, "        put_image\n");
    }
    if (uxa_driver->get_image != NULL) {
	LogMessage(X_INFO, "        get_image\n");
    }
d561 1
a561 1
    return TRUE;
d569 1
a569 2
void
uxa_driver_fini (ScreenPtr pScreen)
d571 1
a571 1
    /*right now does nothing*/
@


1.1
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d250 4
a253 3
	uxa_prepare_access(&pGC->stipple->drawable, UXA_ACCESS_RW);
	fbValidateGC (pGC, changes, pDrawable);
	uxa_finish_access(&pGC->stipple->drawable);
@

