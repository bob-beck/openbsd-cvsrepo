head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.8
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_3:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.08.06.09.56.29;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	LoGpeNS1hy3meocn;

1.13
date	2014.05.09.19.55.33;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.31.15.15.12;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.11.19.24.49;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.20.20.18.27;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.17.17.39.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.02.21.21.11;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.02.21.14.37;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.18.20.08.27;	author naddy;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.11.10.49.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.04.10.17.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.28.54;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.02.15.23.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.17.23.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.17.23.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.16.45.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to libXi 1.7.6
@
text
@/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/***********************************************************************
 *
 * Input Extension library internal functions.
 *
 */

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdint.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/Xlibint.h>
#include <X11/extensions/XInput.h>
#include <X11/extensions/XInput2.h>
#include <X11/extensions/extutil.h>
#include <X11/extensions/geproto.h>
#include <X11/extensions/ge.h>
#include <X11/extensions/Xge.h>
#include "XIint.h"

#define ENQUEUE_EVENT	True
#define DONT_ENQUEUE	False
#define FP1616toDBL(x) ((x) * 1.0 / (1 << 16))

int copy_classes(XIDeviceInfo *to, xXIAnyInfo* from, int *nclasses);
int size_classes(xXIAnyInfo* from, int nclasses);

static XExtensionInfo *xinput_info;
static const char *xinput_extension_name = INAME;

static int XInputClose(
    Display *		/* dpy */,
    XExtCodes *		/* codes */
);

static char *XInputError(
    Display *		/* dpy */,
    int			/* code */,
    XExtCodes *		/* codes */,
    char *		/* buf */,
    int			/* n */
);

static Bool XInputWireToEvent(
    Display *		/* dpy */,
    XEvent *		/* re */,
    xEvent *		/* event */
);
static Bool XInputWireToCookie(
    Display*	        /* display */,
    XGenericEventCookie*	/* re */,
    xEvent*	        /* event */
);

static Bool XInputCopyCookie(
    Display*	        /* display */,
    XGenericEventCookie*	/* in */,
    XGenericEventCookie*	/* out */
);

static int
wireToDeviceEvent(xXIDeviceEvent *in, XGenericEventCookie* out);
static int
wireToDeviceChangedEvent(xXIDeviceChangedEvent *in, XGenericEventCookie *cookie);
static int
wireToHierarchyChangedEvent(xXIHierarchyEvent *in, XGenericEventCookie *cookie);
static int
wireToRawEvent(XExtDisplayInfo *info, xXIRawEvent *in, XGenericEventCookie *cookie);
static int
wireToEnterLeave(xXIEnterEvent *in, XGenericEventCookie *cookie);
static int
wireToPropertyEvent(xXIPropertyEvent *in, XGenericEventCookie *cookie);
static int
wireToTouchOwnershipEvent(xXITouchOwnershipEvent *in,
                          XGenericEventCookie *cookie);
static int
wireToBarrierEvent(xXIBarrierEvent *in,
                   XGenericEventCookie *cookie);

static /* const */ XEvent emptyevent;

typedef Status (*core_event_to_wire)(Display*, XEvent*, xEvent*);

static /* const */ XExtensionHooks xinput_extension_hooks = {
    NULL,	/* create_gc */
    NULL,	/* copy_gc */
    NULL,	/* flush_gc */
    NULL,	/* free_gc */
    NULL,	/* create_font */
    NULL,	/* free_font */
    XInputClose,	/* close_display */
    XInputWireToEvent,	/* wire_to_event */
    (core_event_to_wire)_XiEventToWire, /* event_to_wire */
    NULL,	/* error */
    XInputError,	/* error_string */
};

static const char *XInputErrorList[] = {
    "BadDevice, invalid or uninitialized input device",	/* BadDevice */
    "BadEvent, invalid event type",	/* BadEvent */
    "BadMode, invalid mode parameter",	/* BadMode  */
    "DeviceBusy, device is busy",	/* DeviceBusy */
    "BadClass, invalid event class",	/* BadClass */
};

/* Get the version supported by the server to know which number of
* events are support. Otherwise, a wrong number of events may smash
* the Xlib-internal event processing vector.
*
* Since the extension hasn't been initialized yet, we need to
* manually get the opcode, then the version.
*/
static int
_XiFindEventsSupported(Display *dpy)
{
    XExtCodes codes;
    XExtensionVersion *extversion = NULL;
    int nevents = 0;

    if (!XQueryExtension(dpy, INAME, &codes.major_opcode,
                         &codes.first_event, &codes.first_error))
        goto out;

    LockDisplay(dpy);
    extversion = _XiGetExtensionVersionRequest(dpy, INAME, codes.major_opcode);
    UnlockDisplay(dpy);
    SyncHandle();

    if (!extversion || !extversion->present)
        goto out;

    if (extversion->major_version >= 2)
        nevents = IEVENTS; /* number is fixed, XI2 adds GenericEvents only */
    else if (extversion->major_version <= 0)
    {
        printf("XInput_find_display: invalid extension version %d.%d\n",
                extversion->major_version, extversion->minor_version);
        goto out;
    }
    else
    {
        switch(extversion->minor_version)
        {
            case XI_Add_DeviceProperties_Minor:
                nevents = XI_DevicePropertyNotify + 1;
                break;
            case  XI_Add_DevicePresenceNotify_Minor:
                nevents = XI_DevicePresenceNotify + 1;
                break;
            default:
                nevents = XI_DeviceButtonstateNotify + 1;
                break;
        }
    }

out:
    if (extversion)
        XFree(extversion);
    return nevents;
}


_X_HIDDEN
XExtDisplayInfo *XInput_find_display (Display *dpy)
{
    XExtDisplayInfo *dpyinfo;
    if (!xinput_info) { if (!(xinput_info = XextCreateExtension())) return NULL; }
    if (!(dpyinfo = XextFindDisplay (xinput_info, dpy)))
    {
      int nevents = _XiFindEventsSupported(dpy);

      dpyinfo = XextAddDisplay (xinput_info, dpy,
                                xinput_extension_name,
                                &xinput_extension_hooks,
                                nevents, NULL);
      if (dpyinfo->codes) /* NULL if XI doesn't exist on the server */
      {
          XESetWireToEventCookie(dpy, dpyinfo->codes->major_opcode, XInputWireToCookie);
          XESetCopyEventCookie(dpy, dpyinfo->codes->major_opcode, XInputCopyCookie);
      }
    }
    return dpyinfo;
}

static XEXT_GENERATE_ERROR_STRING(XInputError, xinput_extension_name,
                                  IERRORS, XInputErrorList)
/*******************************************************************
*
* Input extension versions.
*
*/
static XExtensionVersion versions[] = { {XI_Absent, 0, 0},
{XI_Present, XI_Initial_Release_Major, XI_Initial_Release_Minor},
{XI_Present, XI_Add_XDeviceBell_Major, XI_Add_XDeviceBell_Minor},
{XI_Present, XI_Add_XSetDeviceValuators_Major,
 XI_Add_XSetDeviceValuators_Minor},
{XI_Present, XI_Add_XChangeDeviceControl_Major,
 XI_Add_XChangeDeviceControl_Minor},
{XI_Present, XI_Add_DevicePresenceNotify_Major,
 XI_Add_DevicePresenceNotify_Minor},
{XI_Present, XI_Add_DeviceProperties_Major,
 XI_Add_DeviceProperties_Minor},
{XI_Present, 2, 0},
{XI_Present, 2, 1},
{XI_Present, 2, 2}
};

/***********************************************************************
 *
 * Return errors reported by this extension.
 *
 */

void
_xibaddevice(
    Display	*dpy,
    int		*error)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    *error = info->codes->first_error + XI_BadDevice;
}

void
_xibadclass(
    Display	*dpy,
    int		*error)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    *error = info->codes->first_error + XI_BadClass;
}

void
_xibadevent(
    Display	*dpy,
    int		*error)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    *error = info->codes->first_error + XI_BadEvent;
}

void
_xibadmode(
    Display	*dpy,
    int		*error)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    *error = info->codes->first_error + XI_BadMode;
}

void
_xidevicebusy(
    Display	*dpy,
    int		*error)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    *error = info->codes->first_error + XI_DeviceBusy;
}

static int XInputCheckExtension(Display *dpy, XExtDisplayInfo *info)
{
    XextCheckExtension (dpy, info, xinput_extension_name, 0);
    return 1;
}

/*****************************************************************
 * Compare version numbers between info and the built-in version table.
 * Returns
 *   -1 if info's version is less than version_index's version,
 *   0 if equal (or DontCheck),
 *   1 if info's version is greater than version_index's version.
 * Returns -2 on initialization errors which shouldn't happen if you call it
 * correctly.
 */
_X_HIDDEN int
_XiCheckVersion(XExtDisplayInfo *info,
                int version_index)
{
    XExtensionVersion *ext;

    if (versions[version_index].major_version == Dont_Check)
        return 0;

    if (!info->data)
        return -2;

    ext = ((XInputData *) info->data)->vers;
    if (!ext)
        return -2;

    if (ext->major_version == versions[version_index].major_version &&
        ext->minor_version == versions[version_index].minor_version)
        return 0;

    if (ext->major_version < versions[version_index].major_version ||
        (ext->major_version == versions[version_index].major_version &&
         ext->minor_version < versions[version_index].minor_version))
        return -1;
    else
        return 1;
}

/***********************************************************************
 *
 * Check to see if the input extension is installed in the server.
 * Also check to see if the version is >= the requested version.
 *
 */

_X_HIDDEN int
_XiCheckExtInit(
    register Display	*dpy,
    register int	 version_index,
    XExtDisplayInfo	*info)
{
    if (!XInputCheckExtension(dpy, info)) {
	UnlockDisplay(dpy);
	return (-1);
    }

    if (info->data == NULL) {
	info->data = (XPointer) Xmalloc(sizeof(XInputData));
	if (!info->data) {
	    UnlockDisplay(dpy);
	    return (-1);
	}
	((XInputData *) info->data)->vers =
	    _XiGetExtensionVersionRequest(dpy, "XInputExtension", info->codes->major_opcode);
    }

    if (_XiCheckVersion(info, version_index) < 0) {
	UnlockDisplay(dpy);
	return -1;
    }

    return (0);
}

/***********************************************************************
 *
 * Close display routine.
 *
 */

static int
XInputClose(
    Display	*dpy,
    XExtCodes	*codes)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    if (info->data != NULL) {
	XFree((char *)((XInputData *) info->data)->vers);
	XFree((char *)info->data);
    }

    if (!XextRemoveDisplay(xinput_info, dpy))
        return 0;

    if (xinput_info->ndisplays == 0) {
        XextDestroyExtension(xinput_info);
        xinput_info = NULL;
    }

    return 1;
}

static int
Ones(Mask mask)
{
    register Mask y;

    y = (mask >> 1) & 033333333333;
    y = mask - y - ((y >> 1) & 033333333333);
    return (((y + (y >> 3)) & 030707070707) % 077);
}

static int count_bits(unsigned char* ptr, int len)
{
    int bits = 0;
    unsigned int i;
    unsigned char x;

    for (i = 0; i < len; i++)
    {
        x = ptr[i];
        while(x > 0)
        {
            bits += (x & 0x1);
            x >>= 1;
        }
    }
    return bits;
}

int
_XiGetDevicePresenceNotifyEvent(Display * dpy)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    return info->codes->first_event + XI_DevicePresenceNotify;
}

/***********************************************************************
 *
 * Handle Input extension events.
 * Reformat a wire event into an XEvent structure of the right type.
 *
 */

static Bool
XInputWireToEvent(
    Display	*dpy,
    XEvent	*re,
    xEvent	*event)
{
    unsigned int type, reltype;
    XExtDisplayInfo *info = XInput_find_display(dpy);
    XEvent *save = (XEvent *) info->data;

    type = event->u.u.type & 0x7f;
    reltype = (type - info->codes->first_event);

    if (type == GenericEvent || 
        (reltype != XI_DeviceValuator &&
	reltype != XI_DeviceKeystateNotify &&
	reltype != XI_DeviceButtonstateNotify)) {
	*save = emptyevent;
	save->type = type;
	((XAnyEvent *) save)->serial = _XSetLastRequestRead(dpy,
							    (xGenericReply *)
							    event);
	((XAnyEvent *) save)->send_event = ((event->u.u.type & 0x80) != 0);
	((XAnyEvent *) save)->display = dpy;
    }

    /* Process traditional events */
    if (type != GenericEvent)
    {
        switch (reltype) {
            case XI_DeviceMotionNotify:
                {
                    register XDeviceMotionEvent *ev = (XDeviceMotionEvent *) save;
                    deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

                    ev->root = ev2->root;
                    ev->window = ev2->event;
                    ev->subwindow = ev2->child;
                    ev->time = ev2->time;
                    ev->x_root = ev2->root_x;
                    ev->y_root = ev2->root_y;
                    ev->x = ev2->event_x;
                    ev->y = ev2->event_y;
                    ev->state = ev2->state;
                    ev->same_screen = ev2->same_screen;
                    ev->is_hint = ev2->detail;
                    ev->deviceid = ev2->deviceid & DEVICE_BITS;
                    return (DONT_ENQUEUE);
                }
                break;
            case XI_DeviceKeyPress:
            case XI_DeviceKeyRelease:
                {
                    register XDeviceKeyEvent *ev = (XDeviceKeyEvent *) save;
                    deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

                    ev->root = ev2->root;
                    ev->window = ev2->event;
                    ev->subwindow = ev2->child;
                    ev->time = ev2->time;
                    ev->x_root = ev2->root_x;
                    ev->y_root = ev2->root_y;
                    ev->x = ev2->event_x;
                    ev->y = ev2->event_y;
                    ev->state = ev2->state;
                    ev->same_screen = ev2->same_screen;
                    ev->keycode = ev2->detail;
                    ev->deviceid = ev2->deviceid & DEVICE_BITS;
                    if (ev2->deviceid & MORE_EVENTS)
                        return (DONT_ENQUEUE);
                    else {
                        *re = *save;
                        return (ENQUEUE_EVENT);
                    }
                }
                break;
            case XI_DeviceButtonPress:
            case XI_DeviceButtonRelease:
                {
                    register XDeviceButtonEvent *ev = (XDeviceButtonEvent *) save;
                    deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

                    ev->root = ev2->root;
                    ev->window = ev2->event;
                    ev->subwindow = ev2->child;
                    ev->time = ev2->time;
                    ev->x_root = ev2->root_x;
                    ev->y_root = ev2->root_y;
                    ev->x = ev2->event_x;
                    ev->y = ev2->event_y;
                    ev->state = ev2->state;
                    ev->same_screen = ev2->same_screen;
                    ev->button = ev2->detail;
                    ev->deviceid = ev2->deviceid & DEVICE_BITS;
                    if (ev2->deviceid & MORE_EVENTS)
                        return (DONT_ENQUEUE);
                    else {
                        *re = *save;
                        return (ENQUEUE_EVENT);
                    }
                }
                break;
            case XI_ProximityIn:
            case XI_ProximityOut:
                {
                    register XProximityNotifyEvent *ev = (XProximityNotifyEvent *) save;
                    deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

                    ev->root = ev2->root;
                    ev->window = ev2->event;
                    ev->subwindow = ev2->child;
                    ev->time = ev2->time;
                    ev->x_root = ev2->root_x;
                    ev->y_root = ev2->root_y;
                    ev->x = ev2->event_x;
                    ev->y = ev2->event_y;
                    ev->state = ev2->state;
                    ev->same_screen = ev2->same_screen;
                    ev->deviceid = ev2->deviceid & DEVICE_BITS;
                    if (ev2->deviceid & MORE_EVENTS)
                        return (DONT_ENQUEUE);
                    else {
                        *re = *save;
                        return (ENQUEUE_EVENT);
                    }
                }
                break;
            case XI_DeviceValuator:
                {
                    deviceValuator *xev = (deviceValuator *) event;
                    int save_type = save->type - info->codes->first_event;
                    int i;

                    if (save_type == XI_DeviceKeyPress || save_type == XI_DeviceKeyRelease) {
                        XDeviceKeyEvent *kev = (XDeviceKeyEvent *) save;

                        kev->device_state = xev->device_state;
                        kev->axes_count = xev->num_valuators;
                        kev->first_axis = xev->first_valuator;
                        i = xev->num_valuators;
                        if (i > 6)
                            i = 6;
                        switch (i) {
                            case 6:
                                kev->axis_data[5] = xev->valuator5;
                            case 5:
                                kev->axis_data[4] = xev->valuator4;
                            case 4:
                                kev->axis_data[3] = xev->valuator3;
                            case 3:
                                kev->axis_data[2] = xev->valuator2;
                            case 2:
                                kev->axis_data[1] = xev->valuator1;
                            case 1:
                                kev->axis_data[0] = xev->valuator0;
                        }
                    } else if (save_type == XI_DeviceButtonPress ||
                            save_type == XI_DeviceButtonRelease) {
                        XDeviceButtonEvent *bev = (XDeviceButtonEvent *) save;

                        bev->device_state = xev->device_state;
                        bev->axes_count = xev->num_valuators;
                        bev->first_axis = xev->first_valuator;
                        i = xev->num_valuators;
                        if (i > 6)
                            i = 6;
                        switch (i) {
                            case 6:
                                bev->axis_data[5] = xev->valuator5;
                            case 5:
                                bev->axis_data[4] = xev->valuator4;
                            case 4:
                                bev->axis_data[3] = xev->valuator3;
                            case 3:
                                bev->axis_data[2] = xev->valuator2;
                            case 2:
                                bev->axis_data[1] = xev->valuator1;
                            case 1:
                                bev->axis_data[0] = xev->valuator0;
                        }
                    } else if (save_type == XI_DeviceMotionNotify) {
                        XDeviceMotionEvent *mev = (XDeviceMotionEvent *) save;

                        mev->device_state = xev->device_state;
                        mev->axes_count = xev->num_valuators;
                        mev->first_axis = xev->first_valuator;
                        i = xev->num_valuators;
                        if (i > 6)
                            i = 6;
                        switch (i) {
                            case 6:
                                mev->axis_data[5] = xev->valuator5;
                            case 5:
                                mev->axis_data[4] = xev->valuator4;
                            case 4:
                                mev->axis_data[3] = xev->valuator3;
                            case 3:
                                mev->axis_data[2] = xev->valuator2;
                            case 2:
                                mev->axis_data[1] = xev->valuator1;
                            case 1:
                                mev->axis_data[0] = xev->valuator0;
                        }
                    } else if (save_type == XI_ProximityIn || save_type == XI_ProximityOut) {
                        XProximityNotifyEvent *pev = (XProximityNotifyEvent *) save;

                        pev->device_state = xev->device_state;
                        pev->axes_count = xev->num_valuators;
                        pev->first_axis = xev->first_valuator;
                        i = xev->num_valuators;
                        if (i > 6)
                            i = 6;
                        switch (i) {
                            case 6:
                                pev->axis_data[5] = xev->valuator5;
                            case 5:
                                pev->axis_data[4] = xev->valuator4;
                            case 4:
                                pev->axis_data[3] = xev->valuator3;
                            case 3:
                                pev->axis_data[2] = xev->valuator2;
                            case 2:
                                pev->axis_data[1] = xev->valuator1;
                            case 1:
                                pev->axis_data[0] = xev->valuator0;
                        }
                    } else if (save_type == XI_DeviceStateNotify) {
                        int j;
                        XDeviceStateNotifyEvent *sev = (XDeviceStateNotifyEvent *) save;
                        XInputClass *any = (XInputClass *) & sev->data[0];
                        XValuatorStatus *v;

                        for (i = 0; i < sev->num_classes; i++)
                            if (any->class != ValuatorClass)
                                any = (XInputClass *) ((char *)any + any->length);
                        v = (XValuatorStatus *) any;
                        i = v->num_valuators;
                        j = xev->num_valuators;
                        if (j > 3)
                            j = 3;
                        switch (j) {
                            case 3:
                                v->valuators[i + 2] = xev->valuator2;
                            case 2:
                                v->valuators[i + 1] = xev->valuator1;
                            case 1:
                                v->valuators[i + 0] = xev->valuator0;
                        }
                        v->num_valuators += j;

                    }
                    *re = *save;
                    return (ENQUEUE_EVENT);
                }
                break;
            case XI_DeviceFocusIn:
            case XI_DeviceFocusOut:
                {
                    register XDeviceFocusChangeEvent *ev = (XDeviceFocusChangeEvent *) re;
                    deviceFocus *fev = (deviceFocus *) event;

                    *ev = *((XDeviceFocusChangeEvent *) save);
                    ev->window = fev->window;
                    ev->time = fev->time;
                    ev->mode = fev->mode;
                    ev->detail = fev->detail;
                    ev->deviceid = fev->deviceid & DEVICE_BITS;
                    return (ENQUEUE_EVENT);
                }
                break;
            case XI_DeviceStateNotify:
                {
                    int j;
                    XDeviceStateNotifyEvent *stev = (XDeviceStateNotifyEvent *) save;
                    deviceStateNotify *sev = (deviceStateNotify *) event;
                    char *data;

                    stev->window = None;
                    stev->deviceid = sev->deviceid & DEVICE_BITS;
                    stev->time = sev->time;
                    stev->num_classes = Ones((Mask) sev->classes_reported & InputClassBits);
                    data = (char *)&stev->data[0];
                    if (sev->classes_reported & (1 << KeyClass)) {
                        register XKeyStatus *kstev = (XKeyStatus *) data;

                        kstev->class = KeyClass;
                        kstev->length = sizeof(XKeyStatus);
                        kstev->num_keys = sev->num_keys;
                        memcpy((char *)&kstev->keys[0], (char *)&sev->keys[0], 4);
                        data += sizeof(XKeyStatus);
                    }
                    if (sev->classes_reported & (1 << ButtonClass)) {
                        register XButtonStatus *bev = (XButtonStatus *) data;

                        bev->class = ButtonClass;
                        bev->length = sizeof(XButtonStatus);
                        bev->num_buttons = sev->num_buttons;
                        memcpy((char *)bev->buttons, (char *)sev->buttons, 4);
                        data += sizeof(XButtonStatus);
                    }
                    if (sev->classes_reported & (1 << ValuatorClass)) {
                        register XValuatorStatus *vev = (XValuatorStatus *) data;

                        vev->class = ValuatorClass;
                        vev->length = sizeof(XValuatorStatus);
                        vev->num_valuators = sev->num_valuators;
                        vev->mode = sev->classes_reported >> ModeBitsShift;
                        j = sev->num_valuators;
                        if (j > 3)
                            j = 3;
                        switch (j) {
                            case 3:
                                vev->valuators[2] = sev->valuator2;
                            case 2:
                                vev->valuators[1] = sev->valuator1;
                            case 1:
                                vev->valuators[0] = sev->valuator0;
                        }
                        data += sizeof(XValuatorStatus);
                    }
                    if (sev->deviceid & MORE_EVENTS)
                        return (DONT_ENQUEUE);
                    else {
                        *re = *save;
                        return (ENQUEUE_EVENT);
                    }
                }
                break;
            case XI_DeviceKeystateNotify:
                {
                    int i;
                    XInputClass *anyclass;
                    register XKeyStatus *kv;
                    deviceKeyStateNotify *ksev = (deviceKeyStateNotify *) event;
                    XDeviceStateNotifyEvent *kstev = (XDeviceStateNotifyEvent *) save;

                    anyclass = (XInputClass *) & kstev->data[0];
                    for (i = 0; i < kstev->num_classes; i++)
                        if (anyclass->class == KeyClass)
                            break;
                        else
                            anyclass = (XInputClass *) ((char *)anyclass +
                                    anyclass->length);

                    kv = (XKeyStatus *) anyclass;
                    kv->num_keys = 256;
                    memcpy((char *)&kv->keys[4], (char *)ksev->keys, 28);
                    if (ksev->deviceid & MORE_EVENTS)
                        return (DONT_ENQUEUE);
                    else {
                        *re = *save;
                        return (ENQUEUE_EVENT);
                    }
                }
                break;
            case XI_DeviceButtonstateNotify:
                {
                    int i;
                    XInputClass *anyclass;
                    register XButtonStatus *bv;
                    deviceButtonStateNotify *bsev = (deviceButtonStateNotify *) event;
                    XDeviceStateNotifyEvent *bstev = (XDeviceStateNotifyEvent *) save;

                    anyclass = (XInputClass *) & bstev->data[0];
                    for (i = 0; i < bstev->num_classes; i++)
                        if (anyclass->class == ButtonClass)
                            break;
                        else
                            anyclass = (XInputClass *) ((char *)anyclass +
                                    anyclass->length);

                    bv = (XButtonStatus *) anyclass;
                    bv->num_buttons = 256;
                    memcpy((char *)&bv->buttons[4], (char *)bsev->buttons, 28);
                    if (bsev->deviceid & MORE_EVENTS)
                        return (DONT_ENQUEUE);
                    else {
                        *re = *save;
                        return (ENQUEUE_EVENT);
                    }
                }
                break;
            case XI_DeviceMappingNotify:
                {
                    register XDeviceMappingEvent *ev = (XDeviceMappingEvent *) re;
                    deviceMappingNotify *ev2 = (deviceMappingNotify *) event;

                    *ev = *((XDeviceMappingEvent *) save);
                    ev->window = 0;
                    ev->first_keycode = ev2->firstKeyCode;
                    ev->request = ev2->request;
                    ev->count = ev2->count;
                    ev->time = ev2->time;
                    ev->deviceid = ev2->deviceid & DEVICE_BITS;
                    return (ENQUEUE_EVENT);
                }
                break;
            case XI_ChangeDeviceNotify:
                {
                    register XChangeDeviceNotifyEvent *ev = (XChangeDeviceNotifyEvent *) re;
                    changeDeviceNotify *ev2 = (changeDeviceNotify *) event;

                    *ev = *((XChangeDeviceNotifyEvent *) save);
                    ev->window = 0;
                    ev->request = ev2->request;
                    ev->time = ev2->time;
                    ev->deviceid = ev2->deviceid & DEVICE_BITS;
                    return (ENQUEUE_EVENT);
                }
                break;

            case XI_DevicePresenceNotify:
                {
                    XDevicePresenceNotifyEvent *ev = (XDevicePresenceNotifyEvent *) re;
                    devicePresenceNotify *ev2 = (devicePresenceNotify *) event;

                    *ev = *(XDevicePresenceNotifyEvent *) save;
                    ev->window = 0;
                    ev->time = ev2->time;
                    ev->devchange = ev2->devchange;
                    ev->deviceid = ev2->deviceid;
                    ev->control = ev2->control;
                    return (ENQUEUE_EVENT);
                }
                break;
            case XI_DevicePropertyNotify:
                {
                    XDevicePropertyNotifyEvent* ev = (XDevicePropertyNotifyEvent*)re;
                    devicePropertyNotify *ev2 = (devicePropertyNotify*)event;

                    *ev = *(XDevicePropertyNotifyEvent*)save;
                    ev->time = ev2->time;
                    ev->deviceid = ev2->deviceid;
                    ev->atom = ev2->atom;
                    ev->state = ev2->state;
                    return ENQUEUE_EVENT;
                }
                break;
            default:
                printf("XInputWireToEvent: UNKNOWN WIRE EVENT! type=%d\n", type);
                break;
        }
    }
    return (DONT_ENQUEUE);
}

static void xge_copy_to_cookie(xGenericEvent* ev,
                               XGenericEventCookie *cookie)
{
    cookie->type = ev->type;
    cookie->evtype = ev->evtype;
    cookie->extension = ev->extension;
}

static Bool
XInputWireToCookie(
    Display	*dpy,
    XGenericEventCookie *cookie,
    xEvent	*event)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);
    XEvent *save = (XEvent *) info->data;
    xGenericEvent* ge = (xGenericEvent*)event;

    if (ge->extension != info->codes->major_opcode)
    {
        printf("XInputWireToCookie: wrong extension opcode %d\n",
                ge->extension);
        return DONT_ENQUEUE;
    }

    *save = emptyevent;
    save->type = event->u.u.type;
    ((XAnyEvent*)save)->serial = _XSetLastRequestRead(dpy, (xGenericReply *) event);
    ((XAnyEvent*)save)->send_event = ((event->u.u.type & 0x80) != 0);
    ((XAnyEvent*)save)->display = dpy;

    xge_copy_to_cookie((xGenericEvent*)event, (XGenericEventCookie*)save);
    switch(ge->evtype)
    {
        case XI_Motion:
        case XI_ButtonPress:
        case XI_ButtonRelease:
        case XI_KeyPress:
        case XI_KeyRelease:
        case XI_TouchBegin:
        case XI_TouchUpdate:
        case XI_TouchEnd:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToDeviceEvent((xXIDeviceEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        case XI_DeviceChanged:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToDeviceChangedEvent((xXIDeviceChangedEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        case XI_HierarchyChanged:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToHierarchyChangedEvent((xXIHierarchyEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        case XI_TouchOwnership:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToTouchOwnershipEvent((xXITouchOwnershipEvent*)event,
                                           cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;

        case XI_RawKeyPress:
        case XI_RawKeyRelease:
        case XI_RawButtonPress:
        case XI_RawButtonRelease:
        case XI_RawMotion:
        case XI_RawTouchBegin:
        case XI_RawTouchUpdate:
        case XI_RawTouchEnd:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToRawEvent(info, (xXIRawEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        case XI_Enter:
        case XI_Leave:
        case XI_FocusIn:
        case XI_FocusOut:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToEnterLeave((xXIEnterEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        case XI_PropertyEvent:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToPropertyEvent((xXIPropertyEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        case XI_BarrierHit:
        case XI_BarrierLeave:
            *cookie = *(XGenericEventCookie*)save;
            if (!wireToBarrierEvent((xXIBarrierEvent*)event, cookie))
            {
                printf("XInputWireToCookie: CONVERSION FAILURE!  evtype=%d\n",
                        ge->evtype);
                break;
            }
            return ENQUEUE_EVENT;
        default:
            printf("XInputWireToCookie: Unknown generic event. type %d\n", ge->evtype);

    }
    return DONT_ENQUEUE;
}

/**
 * Calculate length in bytes needed for the device event with the given
 * button mask length, valuator mask length + valuator mask. All parameters
 * in bytes.
 */
static inline int
sizeDeviceEvent(int buttons_len, int valuators_len,
                unsigned char *valuators_mask)
{
    int len;

    len = sizeof(XIDeviceEvent);
    len += sizeof(XIButtonState) + buttons_len;
    len += sizeof(XIValuatorState) + valuators_len;
    len += count_bits(valuators_mask, valuators_len) * sizeof(double);
    len += sizeof(XIModifierState) + sizeof(XIGroupState);

    return len;
}

/* Return the size with added padding so next element would be
   double-aligned unless the architecture is known to allow unaligned
   data accesses.  Not doing this can cause a bus error on
   MIPSÂ N32. */
static int
pad_to_double(int size)
{
#if !defined(__i386__) && !defined(__sh__)
    if (size % sizeof(double) != 0)
        size += sizeof(double) - size % sizeof(double);
#endif
    return size;
}

/**
 * Set structure and atoms to size in bytes of XIButtonClassInfo, its
 * button state mask and labels array.
 */
static void
sizeXIButtonClassType(int num_buttons, int* structure, int* state, int* atoms)
{
    int size;
    int labels;

    *structure = pad_to_double(sizeof(XIButtonClassInfo));
    size = ((((num_buttons + 7)/8) + 3)/4);

    /* Force mask alignment with longs to avoid unaligned
     * access when accessing the atoms. */
    *state = pad_to_double(size * 4);
    labels = num_buttons * sizeof(Atom);

    /* Force mask alignment with longs to avoid
     * unaligned access when accessing the atoms. */
    labels += ((((num_buttons + 7)/8) + 3)/4) * sizeof(Atom);
    *atoms = pad_to_double(labels);
}

/**
 * Set structure and keycodes to size in bytes of XIKeyClassInfo and
 * its keycodes array.
 */
static void
sizeXIKeyClassType(int num_keycodes, int* structure, int* keycodes)
{
    *structure = pad_to_double(sizeof(XIKeyClassInfo));
    *keycodes = pad_to_double(num_keycodes * sizeof(int));
}

/**
 * Return the size in bytes required to store the matching class type
 * num_elements is num_buttons for XIButtonClass or num_keycodes for
 * XIKeyClass.
 *
 * Also used from copy_classes in XIQueryDevice.c
 */
static int
sizeDeviceClassType(int type, int num_elements)
{
    int l = 0;
    int extra1 = 0;
    int extra2 = 0;
    switch(type)
    {
        case XIButtonClass:
            sizeXIButtonClassType(num_elements, &l, &extra1, &extra2);
            l += extra1 + extra2;
            break;
        case XIKeyClass:
            sizeXIKeyClassType(num_elements, &l, &extra1);
            l += extra1;
            break;
        case XIValuatorClass:
            l = pad_to_double(sizeof(XIValuatorClassInfo));
            break;
        case XIScrollClass:
            l = pad_to_double(sizeof(XIScrollClassInfo));
            break;
        case XITouchClass:
            l = pad_to_double(sizeof(XITouchClassInfo));
            break;
        default:
            printf("sizeDeviceClassType: unknown type %d\n", type);
            break;
    }
    return l;
}

static Bool
copyHierarchyEvent(XGenericEventCookie *cookie_in,
                   XGenericEventCookie *cookie_out)
{
    XIHierarchyEvent *in, *out;
    void *ptr;

    in = cookie_in->data;

    ptr = cookie_out->data = malloc(sizeof(XIHierarchyEvent) +
                                    in->num_info * sizeof(XIHierarchyInfo));
    if (!ptr)
        return False;

    out = next_block(&ptr, sizeof(XIHierarchyEvent));
    *out = *in;
    out->info = next_block(&ptr, in->num_info * sizeof(XIHierarchyInfo));
    memcpy(out->info, in->info, in->num_info * sizeof(XIHierarchyInfo));

    return True;
}

static Bool
copyDeviceChangedEvent(XGenericEventCookie *in_cookie,
                       XGenericEventCookie *out_cookie)
{
    int len, i;
    XIDeviceChangedEvent *in, *out;
    XIAnyClassInfo *any;
    void *ptr;

    in = in_cookie->data;

    len = sizeof(XIDeviceChangedEvent);
    len += in->num_classes * sizeof(XIAnyClassInfo*);

    for (i = 0; i < in->num_classes; i++)
    {
        any = in->classes[i];
        switch(any->type)
        {
            case XIButtonClass:
                len += sizeDeviceClassType(XIButtonClass,
                        ((XIButtonClassInfo*)any)->num_buttons);
                break;
            case XIKeyClass:
                len += sizeDeviceClassType(XIKeyClass,
                        ((XIKeyClassInfo*)any)->num_keycodes);
                break;
            case XIValuatorClass:
                len += sizeDeviceClassType(XIValuatorClass, 0);
                break;
            case XIScrollClass:
                len += sizeDeviceClassType(XIScrollClass, 0);
                break;
            default:
                printf("copyDeviceChangedEvent: unknown type %d\n",
                        any->type);
                break;
        }

    }

    ptr = out_cookie->data = malloc(len);
    if (!ptr)
        return False;
    out = next_block(&ptr, sizeof(XIDeviceChangedEvent));
    *out = *in;

    out->classes = next_block(&ptr,
                              out->num_classes * sizeof(XIAnyClassInfo*));

    for (i = 0; i < in->num_classes; i++)
    {
        any = in->classes[i];

        switch(any->type)
        {
            case XIButtonClass:
                {
                    int struct_size;
                    int state_size;
                    int labels_size;
                    XIButtonClassInfo *bin, *bout;
                    bin = (XIButtonClassInfo*)any;
                    sizeXIButtonClassType(bin->num_buttons, &struct_size,
                                          &state_size, &labels_size);
                    bout = next_block(&ptr, struct_size);

                    *bout = *bin;
                    bout->state.mask = next_block(&ptr, state_size);
                    memcpy(bout->state.mask, bin->state.mask,
                            bout->state.mask_len);

                    bout->labels = next_block(&ptr, labels_size);
                    memcpy(bout->labels, bin->labels, bout->num_buttons * sizeof(Atom));
                    out->classes[i] = (XIAnyClassInfo*)bout;
                    break;
                }
            case XIKeyClass:
                {
                    XIKeyClassInfo *kin, *kout;
                    int struct_size;
                    int keycodes_size;
                    kin = (XIKeyClassInfo*)any;
                    sizeXIKeyClassType(kin->num_keycodes, &struct_size,
                                       &keycodes_size);

                    kout = next_block(&ptr, struct_size);
                    *kout = *kin;
                    kout->keycodes = next_block(&ptr, keycodes_size);
                    memcpy(kout->keycodes, kin->keycodes, kout->num_keycodes * sizeof(int));
                    out->classes[i] = (XIAnyClassInfo*)kout;
                    break;
                }
            case XIValuatorClass:
                {
                    XIValuatorClassInfo *vin, *vout;
                    vin = (XIValuatorClassInfo*)any;
                    vout = next_block(&ptr,
                                      sizeDeviceClassType(XIValuatorClass, 0));
                    *vout = *vin;
                    out->classes[i] = (XIAnyClassInfo*)vout;
                    break;
                }
            case XIScrollClass:
                {
                    XIScrollClassInfo *sin, *sout;
                    sin = (XIScrollClassInfo*)any;
                    sout = next_block(&ptr,
                                      sizeDeviceClassType(XIScrollClass, 0));
                    *sout = *sin;
                    out->classes[i] = (XIAnyClassInfo*)sout;
                    break;
                }
        }
    }

    return True;
}

static Bool
copyDeviceEvent(XGenericEventCookie *cookie_in,
                XGenericEventCookie *cookie_out)
{
    int len;
    XIDeviceEvent *in, *out;
    int bits; /* valuator bits */
    void *ptr;

    in = cookie_in->data;
    bits = count_bits(in->valuators.mask, in->valuators.mask_len);

    len = sizeDeviceEvent(in->buttons.mask_len, in->valuators.mask_len,
                          in->valuators.mask);

    ptr = cookie_out->data = malloc(len);
    if (!ptr)
        return False;

    out = next_block(&ptr, sizeof(XIDeviceEvent));
    *out = *in;

    out->buttons.mask = next_block(&ptr, in->buttons.mask_len);
    memcpy(out->buttons.mask, in->buttons.mask,
           out->buttons.mask_len);
    out->valuators.mask = next_block(&ptr, in->valuators.mask_len);
    memcpy(out->valuators.mask, in->valuators.mask,
           out->valuators.mask_len);
    out->valuators.values = next_block(&ptr, bits * sizeof(double));
    memcpy(out->valuators.values, in->valuators.values,
           bits * sizeof(double));

    return True;
}

static Bool
copyEnterEvent(XGenericEventCookie *cookie_in,
               XGenericEventCookie *cookie_out)
{
    int len;
    XIEnterEvent *in, *out;
    void *ptr;

    in = cookie_in->data;

    len = sizeof(XIEnterEvent) + in->buttons.mask_len;

    ptr = cookie_out->data = malloc(len);
    if (!ptr)
        return False;

    out = next_block(&ptr, sizeof(XIEnterEvent));
    *out = *in;

    out->buttons.mask = next_block(&ptr, in->buttons.mask_len);
    memcpy(out->buttons.mask, in->buttons.mask, out->buttons.mask_len);

    return True;
}

static Bool
copyPropertyEvent(XGenericEventCookie *cookie_in,
                  XGenericEventCookie *cookie_out)
{
    XIPropertyEvent *in, *out;

    in = cookie_in->data;

    out = cookie_out->data = malloc(sizeof(XIPropertyEvent));
    if (!out)
        return False;

    *out = *in;
    return True;
}

static Bool
copyTouchOwnershipEvent(XGenericEventCookie *cookie_in,
                        XGenericEventCookie *cookie_out)
{
    XITouchOwnershipEvent *in, *out;

    in = cookie_in->data;

    out = cookie_out->data = malloc(sizeof(XITouchOwnershipEvent));
    if (!out)
        return False;

    *out = *in;
    return True;
}

static Bool
copyRawEvent(XGenericEventCookie *cookie_in,
             XGenericEventCookie *cookie_out)
{
    XIRawEvent *in, *out;
    void *ptr;
    int len;
    int bits;

    in = cookie_in->data;

    bits = count_bits(in->valuators.mask, in->valuators.mask_len);
    len = sizeof(XIRawEvent) + in->valuators.mask_len;
    len += bits * sizeof(double) * 2;

    ptr = cookie_out->data = malloc(len);
    if (!ptr)
        return False;

    out = next_block(&ptr, sizeof(XIRawEvent));
    *out = *in;
    out->valuators.mask = next_block(&ptr, out->valuators.mask_len);
    memcpy(out->valuators.mask, in->valuators.mask, out->valuators.mask_len);

    out->valuators.values = next_block(&ptr, bits * sizeof(double));
    memcpy(out->valuators.values, in->valuators.values, bits * sizeof(double));

    out->raw_values = next_block(&ptr, bits * sizeof(double));
    memcpy(out->raw_values, in->raw_values, bits * sizeof(double));

    return True;
}

static Bool
copyBarrierEvent(XGenericEventCookie *in_cookie,
                 XGenericEventCookie *out_cookie)
{
    XIBarrierEvent *in, *out;

    in = in_cookie->data;

    out = out_cookie->data = calloc(1, sizeof(XIBarrierEvent));
    if (!out)
        return False;
    *out = *in;

    return True;
}

static Bool
XInputCopyCookie(Display *dpy, XGenericEventCookie *in, XGenericEventCookie *out)
{
    int ret = True;

    XExtDisplayInfo *info = XInput_find_display(dpy);

    if (in->extension != info->codes->major_opcode)
    {
        printf("XInputCopyCookie: wrong extension opcode %d\n",
                in->extension);
        return False;
    }

    *out = *in;
    out->data = NULL;
    out->cookie = 0;

    switch(in->evtype) {
        case XI_Motion:
        case XI_ButtonPress:
        case XI_ButtonRelease:
        case XI_KeyPress:
        case XI_KeyRelease:
        case XI_TouchBegin:
        case XI_TouchUpdate:
        case XI_TouchEnd:
            ret = copyDeviceEvent(in, out);
            break;
        case XI_DeviceChanged:
            ret = copyDeviceChangedEvent(in, out);
            break;
        case XI_HierarchyChanged:
            ret = copyHierarchyEvent(in, out);
            break;
        case XI_Enter:
        case XI_Leave:
        case XI_FocusIn:
        case XI_FocusOut:
            ret = copyEnterEvent(in, out);
            break;
        case XI_PropertyEvent:
            ret = copyPropertyEvent(in, out);
            break;
        case XI_TouchOwnership:
            ret = copyTouchOwnershipEvent(in, out);
            break;
        case XI_RawKeyPress:
        case XI_RawKeyRelease:
        case XI_RawButtonPress:
        case XI_RawButtonRelease:
        case XI_RawMotion:
        case XI_RawTouchBegin:
        case XI_RawTouchUpdate:
        case XI_RawTouchEnd:
            ret = copyRawEvent(in, out);
            break;
        case XI_BarrierHit:
        case XI_BarrierLeave:
            ret = copyBarrierEvent(in, out);
            break;
        default:
            printf("XInputCopyCookie: unknown evtype %d\n", in->evtype);
            ret = False;
    }

    if (!ret)
        printf("XInputCopyCookie: Failed to copy evtype %d", in->evtype);
    return ret;
}

static int
wireToDeviceEvent(xXIDeviceEvent *in, XGenericEventCookie* cookie)
{
    int len, i;
    unsigned char *ptr;
    void *ptr_lib;
    FP3232 *values;
    XIDeviceEvent *out;

    ptr = (unsigned char*)&in[1] + in->buttons_len * 4;

    len = sizeDeviceEvent(in->buttons_len * 4, in->valuators_len * 4, ptr);

    cookie->data = ptr_lib = malloc(len);

    out = next_block(&ptr_lib, sizeof(XIDeviceEvent));
    out->display = cookie->display;
    out->type = in->type;
    out->serial = cookie->serial;
    out->extension = in->extension;
    out->evtype = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time = in->time;
    out->deviceid = in->deviceid;
    out->sourceid = in->sourceid;
    out->detail = in->detail;
    out->root = in->root;
    out->event = in->event;
    out->child = in->child;
    out->root_x = FP1616toDBL(in->root_x);
    out->root_y = FP1616toDBL(in->root_y);
    out->event_x = FP1616toDBL(in->event_x);
    out->event_y = FP1616toDBL(in->event_y);
    out->flags = in->flags;
    out->mods.base = in->mods.base_mods;
    out->mods.locked = in->mods.locked_mods;
    out->mods.latched = in->mods.latched_mods;
    out->mods.effective = in->mods.effective_mods;
    out->group.base = in->group.base_group;
    out->group.locked = in->group.locked_group;
    out->group.latched = in->group.latched_group;
    out->group.effective = in->group.effective_group;
    out->buttons.mask_len = in->buttons_len * 4;
    out->valuators.mask_len = in->valuators_len * 4;

    out->buttons.mask = next_block(&ptr_lib, out->buttons.mask_len);

    /* buttons */
    ptr = (unsigned char*)&in[1];
    memcpy(out->buttons.mask, ptr, out->buttons.mask_len);
    ptr += in->buttons_len * 4;

    /* valuators */
    out->valuators.mask = next_block(&ptr_lib, out->valuators.mask_len);
    memcpy(out->valuators.mask, ptr, out->valuators.mask_len);
    ptr += in->valuators_len * 4;

    len = count_bits(out->valuators.mask, out->valuators.mask_len);
    out->valuators.values = next_block(&ptr_lib, len * sizeof(double));

    values = (FP3232*)ptr;
    for (i = 0; i < len; i++, values++)
    {
        out->valuators.values[i] = values->integral;
        out->valuators.values[i] += ((double)values->frac / (1 << 16) / (1 << 16));
    }


    return 1;
}

_X_HIDDEN int
size_classes(xXIAnyInfo* from, int nclasses)
{
    int len, i;
    xXIAnyInfo *any_wire;
    char *ptr_wire;

    /* len for to->classes */
    len = pad_to_double(nclasses * sizeof(XIAnyClassInfo*));
    ptr_wire = (char*)from;
    for (i = 0; i < nclasses; i++)
    {
        int l = 0;
        any_wire = (xXIAnyInfo*)ptr_wire;
        switch(any_wire->type)
        {
            case XIButtonClass:
                l = sizeDeviceClassType(XIButtonClass,
                        ((xXIButtonInfo*)any_wire)->num_buttons);
                break;
            case XIKeyClass:
                l = sizeDeviceClassType(XIKeyClass,
                        ((xXIKeyInfo*)any_wire)->num_keycodes);
                break;
            case XIValuatorClass:
                l = sizeDeviceClassType(XIValuatorClass, 0);
                break;
            case XIScrollClass:
                l = sizeDeviceClassType(XIScrollClass, 0);
                break;
            case XITouchClass:
                l = sizeDeviceClassType(XITouchClass, 0);
                break;
        }

        len += l;
        ptr_wire += any_wire->length * 4;
    }

    return len;
}

/* Copy classes from any into to->classes and return the number of bytes
 * copied. Memory layout of to->classes is
 * [clsptr][clsptr][clsptr][classinfo][classinfo]...
 *    |________|___________^
 *             |______________________^
 */
_X_HIDDEN int
copy_classes(XIDeviceInfo* to, xXIAnyInfo* from, int *nclasses)
{
    XIAnyClassInfo *any_lib;
    xXIAnyInfo *any_wire;
    void *ptr_lib;
    char *ptr_wire;
    int i, len;
    int cls_idx = 0;

    if (!to->classes)
        return -1;

    ptr_wire = (char*)from;
    ptr_lib = to->classes;
    to->classes = next_block(&ptr_lib,
                             pad_to_double((*nclasses) * sizeof(XIAnyClassInfo*)));
    memset(to->classes, 0, (*nclasses) * sizeof(XIAnyClassInfo*));
    len = 0; /* count wire length */

    for (i = 0; i < *nclasses; i++)
    {
        any_lib = (XIAnyClassInfo*)ptr_lib;
        any_wire = (xXIAnyInfo*)ptr_wire;

        switch(any_wire->type)
        {
            case XIButtonClass:
                {
                    XIButtonClassInfo *cls_lib;
                    xXIButtonInfo *cls_wire;
                    uint32_t *atoms;
                    int j;
                    int struct_size;
                    int state_size;
                    int labels_size;
                    int wire_mask_size;

                    cls_wire = (xXIButtonInfo*)any_wire;
                    sizeXIButtonClassType(cls_wire->num_buttons,
                                          &struct_size, &state_size,
                                          &labels_size);
                    cls_lib = next_block(&ptr_lib, struct_size);
                    wire_mask_size = ((cls_wire->num_buttons + 7)/8 + 3)/4 * 4;

                    cls_lib->type = cls_wire->type;
                    cls_lib->sourceid = cls_wire->sourceid;
                    cls_lib->num_buttons = cls_wire->num_buttons;
                    cls_lib->state.mask_len = state_size;
                    cls_lib->state.mask = next_block(&ptr_lib, state_size);
                    memcpy(cls_lib->state.mask, &cls_wire[1],
                           wire_mask_size);
                    if (state_size != wire_mask_size)
                        memset(&cls_lib->state.mask[wire_mask_size], 0,
                               state_size - wire_mask_size);

                    cls_lib->labels = next_block(&ptr_lib, labels_size);

                    atoms =(uint32_t*)((char*)&cls_wire[1] + wire_mask_size);
                    for (j = 0; j < cls_lib->num_buttons; j++)
                        cls_lib->labels[j] = *atoms++;

                    to->classes[cls_idx++] = any_lib;
                    break;
                }
            case XIKeyClass:
                {
                    XIKeyClassInfo *cls_lib;
                    xXIKeyInfo *cls_wire;
                    int struct_size;
                    int keycodes_size;

                    cls_wire = (xXIKeyInfo*)any_wire;
                    sizeXIKeyClassType(cls_wire->num_keycodes,
                                       &struct_size, &keycodes_size);
                    cls_lib = next_block(&ptr_lib, struct_size);

                    cls_lib->type = cls_wire->type;
                    cls_lib->sourceid = cls_wire->sourceid;
                    cls_lib->num_keycodes = cls_wire->num_keycodes;
                    cls_lib->keycodes = next_block(&ptr_lib, keycodes_size);
                    memcpy(cls_lib->keycodes, &cls_wire[1],
                            cls_lib->num_keycodes);

                    to->classes[cls_idx++] = any_lib;
                    break;
                }
            case XIValuatorClass:
                {
                    XIValuatorClassInfo *cls_lib;
                    xXIValuatorInfo *cls_wire;

                    cls_lib =
                      next_block(&ptr_lib,
                                 sizeDeviceClassType(XIValuatorClass, 0));
                    cls_wire = (xXIValuatorInfo*)any_wire;

                    cls_lib->type = cls_wire->type;
                    cls_lib->sourceid = cls_wire->sourceid;
                    cls_lib->number = cls_wire->number;
                    cls_lib->label  = cls_wire->label;
                    cls_lib->resolution = cls_wire->resolution;
                    cls_lib->min        = cls_wire->min.integral;
                    cls_lib->max        = cls_wire->max.integral;
                    cls_lib->value      = cls_wire->value.integral;
                    /* FIXME: fractional parts */
                    cls_lib->mode       = cls_wire->mode;

                    to->classes[cls_idx++] = any_lib;
                }
                break;
            case XIScrollClass:
                {
                    XIScrollClassInfo *cls_lib;
                    xXIScrollInfo *cls_wire;

                    cls_lib =
                      next_block(&ptr_lib,
                                 sizeDeviceClassType(XIScrollClass, 0));
                    cls_wire = (xXIScrollInfo*)any_wire;

                    cls_lib->type = cls_wire->type;
                    cls_lib->sourceid = cls_wire->sourceid;
                    cls_lib->number     = cls_wire->number;
                    cls_lib->scroll_type= cls_wire->scroll_type;
                    cls_lib->flags      = cls_wire->flags;
                    cls_lib->increment  = cls_wire->increment.integral;
                    cls_lib->increment += (unsigned int)cls_wire->increment.frac/(double)(1ULL << 32);

                    to->classes[cls_idx++] = any_lib;
                }
                break;
            case XITouchClass:
                {
                    XITouchClassInfo *cls_lib;
                    xXITouchInfo *cls_wire;

                    cls_wire = (xXITouchInfo*)any_wire;
                    cls_lib = next_block(&ptr_lib, sizeof(XITouchClassInfo));

                    cls_lib->type = cls_wire->type;
                    cls_lib->sourceid = cls_wire->sourceid;
                    cls_lib->mode = cls_wire->mode;
                    cls_lib->num_touches = cls_wire->num_touches;

                    to->classes[cls_idx++] = any_lib;
                }
                break;
        }
        len += any_wire->length * 4;
        ptr_wire += any_wire->length * 4;
    }

    /* we may have skipped unknown classes, reset nclasses */
    *nclasses = cls_idx;
    return len;
}


static int
wireToDeviceChangedEvent(xXIDeviceChangedEvent *in, XGenericEventCookie *cookie)
{
    XIDeviceChangedEvent *out;
    XIDeviceInfo info;
    int len;
    int nclasses = in->num_classes;

    len = size_classes((xXIAnyInfo*)&in[1], in->num_classes);

    cookie->data = out = malloc(sizeof(XIDeviceChangedEvent) + len);

    out->type = in->type;
    out->serial = cookie->serial;
    out->display = cookie->display;
    out->extension = in->extension;
    out->evtype = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time = in->time;
    out->deviceid = in->deviceid;
    out->sourceid = in->sourceid;
    out->reason = in->reason;

    out->classes = (XIAnyClassInfo**)&out[1];

    info.classes = out->classes;

    copy_classes(&info, (xXIAnyInfo*)&in[1], &nclasses);
    out->num_classes = nclasses;

    return 1;
}

static int
wireToHierarchyChangedEvent(xXIHierarchyEvent *in, XGenericEventCookie *cookie)
{
    int i;
    XIHierarchyInfo *info_out;
    xXIHierarchyInfo *info_in;
    XIHierarchyEvent *out;

    cookie->data = out = malloc(sizeof(XIHierarchyEvent) + in->num_info * sizeof(XIHierarchyInfo));;

    out->info           = (XIHierarchyInfo*)&out[1];
    out->display        = cookie->display;
    out->type           = in->type;
    out->serial         = cookie->serial;
    out->extension      = in->extension;
    out->evtype         = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time           = in->time;
    out->flags          = in->flags;
    out->num_info       = in->num_info;

    info_out            = out->info;
    info_in             = (xXIHierarchyInfo*)&in[1];

    for (i = 0; i < out->num_info; i++, info_out++, info_in++)
    {
        info_out->deviceid      = info_in->deviceid;
        info_out->attachment    = info_in->attachment;
        info_out->use           = info_in->use;
        info_out->enabled       = info_in->enabled;
        info_out->flags         = info_in->flags;
    }

    return 1;
}

static int
wireToRawEvent(XExtDisplayInfo *info, xXIRawEvent *in, XGenericEventCookie *cookie)
{
    int len, i, bits;
    FP3232 *values;
    XIRawEvent *out;
    void *ptr;

    len = sizeof(XIRawEvent) + in->valuators_len * 4;
    bits = count_bits((unsigned char*)&in[1], in->valuators_len * 4);
    len += bits * sizeof(double) * 2; /* raw + normal */

    cookie->data = ptr = calloc(1, len);
    if (!ptr)
        return 0;

    out = next_block(&ptr, sizeof(XIRawEvent));
    out->type           = in->type;
    out->serial         = cookie->serial;
    out->display        = cookie->display;
    out->extension      = in->extension;
    out->evtype         = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time           = in->time;
    out->detail         = in->detail;
    out->deviceid       = in->deviceid;
    out->flags          = in->flags;

    /* https://bugs.freedesktop.org/show_bug.cgi?id=34240 */
    if (_XiCheckVersion(info, XInput_2_2) >= 0)
        out->sourceid       = in->sourceid;
    else
        out->sourceid       = 0;

    out->valuators.mask_len = in->valuators_len * 4;
    out->valuators.mask = next_block(&ptr, out->valuators.mask_len);
    memcpy(out->valuators.mask, &in[1], out->valuators.mask_len);

    out->valuators.values = next_block(&ptr, bits * sizeof(double));
    out->raw_values = next_block(&ptr, bits * sizeof(double));

    values = (FP3232*)(((char*)&in[1]) + in->valuators_len * 4);
    for (i = 0; i < bits; i++)
    {
        out->valuators.values[i] = values->integral;
        out->valuators.values[i] += ((double)values->frac / (1 << 16) / (1 << 16));
        out->raw_values[i] = (values + bits)->integral;
        out->raw_values[i] += ((double)(values + bits)->frac / (1 << 16) / (1 << 16));
        values++;
    }

    return 1;
}

/* Memory layout of XIEnterEvents:
   [event][modifiers][group][button]
 */
static int
wireToEnterLeave(xXIEnterEvent *in, XGenericEventCookie *cookie)
{
    int len;
    XIEnterEvent *out;

    len = sizeof(XIEnterEvent) + in->buttons_len * 4;

    cookie->data = out = malloc(len);
    out->buttons.mask = (unsigned char*)&out[1];

    out->type           = in->type;
    out->serial         = cookie->serial;
    out->display        = cookie->display;
    out->extension      = in->extension;
    out->evtype         = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time           = in->time;
    out->detail         = in->detail;
    out->deviceid       = in->deviceid;
    out->root           = in->root;
    out->event          = in->event;
    out->child          = in->child;
    out->sourceid       = in->sourceid;
    out->root_x         = FP1616toDBL(in->root_x);
    out->root_y         = FP1616toDBL(in->root_y);
    out->event_x        = FP1616toDBL(in->event_x);
    out->event_y        = FP1616toDBL(in->event_y);
    out->mode           = in->mode;
    out->focus          = in->focus;
    out->same_screen    = in->same_screen;

    out->mods.base = in->mods.base_mods;
    out->mods.locked = in->mods.locked_mods;
    out->mods.latched = in->mods.latched_mods;
    out->mods.effective = in->mods.effective_mods;
    out->group.base = in->group.base_group;
    out->group.locked = in->group.locked_group;
    out->group.latched = in->group.latched_group;
    out->group.effective = in->group.effective_group;

    out->buttons.mask_len = in->buttons_len * 4;
    memcpy(out->buttons.mask, &in[1], out->buttons.mask_len);

    return 1;
}

static int
wireToPropertyEvent(xXIPropertyEvent *in, XGenericEventCookie *cookie)
{
    XIPropertyEvent *out = malloc(sizeof(XIPropertyEvent));

    cookie->data = out;

    out->type           = in->type;
    out->serial         = cookie->serial;
    out->extension      = in->extension;
    out->evtype         = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time           = in->time;
    out->property       = in->property;
    out->what           = in->what;
    out->deviceid       = in->deviceid;

    return 1;
}

static int
wireToTouchOwnershipEvent(xXITouchOwnershipEvent *in,
                          XGenericEventCookie *cookie)
{
    XITouchOwnershipEvent *out = malloc(sizeof(XITouchOwnershipEvent));

    cookie->data = out;

    out->type           = in->type;
    out->serial         = cookie->serial;
    out->display        = cookie->display;
    out->extension      = in->extension;
    out->evtype         = in->evtype;
    out->send_event     = ((in->type & 0x80) != 0);
    out->time           = in->time;
    out->deviceid       = in->deviceid;
    out->sourceid       = in->sourceid;
    out->touchid        = in->touchid;
    out->root           = in->root;
    out->event          = in->event;
    out->child          = in->child;
    out->flags          = in->flags;

    return 1;
}

#define FP3232_TO_DOUBLE(x) ((double) (x).integral + (x).frac / (1ULL << 32))

static int
wireToBarrierEvent(xXIBarrierEvent *in, XGenericEventCookie *cookie)
{
    XIBarrierEvent *out = malloc(sizeof(XIBarrierEvent));

    cookie->data = out;

    out->display    = cookie->display;
    out->type       = in->type;
    out->serial     = cookie->serial;
    out->extension  = in->extension;
    out->evtype     = in->evtype;
    out->send_event = ((in->type & 0x80) != 0);
    out->time       = in->time;
    out->deviceid   = in->deviceid;
    out->sourceid   = in->sourceid;
    out->event      = in->event;
    out->root       = in->root;
    out->root_x     = FP1616toDBL(in->root_x);
    out->root_y     = FP1616toDBL(in->root_y);
    out->dx         = FP3232_TO_DOUBLE (in->dx);
    out->dy         = FP3232_TO_DOUBLE (in->dy);
    out->dtime      = in->dtime;
    out->flags      = in->flags;
    out->barrier    = in->barrier;
    out->eventid    = in->eventid;

    return 1;
}
@


1.13
log
@Update to libXi 1.7.2.

Tested by ajacoutot@@ against gnome.
@
text
@d383 1
a383 1
	    _XiGetExtensionVersion(dpy, "XInputExtension", info);
d1524 1
a1524 1
    out->serial = in->sequenceNumber;
d1797 1
a1797 1
    out->serial = in->sequenceNumber;
d1830 1
a1830 1
    out->serial         = in->sequenceNumber;
d1871 1
a1871 1
    out->serial         = in->sequenceNumber;
d1922 1
a1922 1
    out->serial         = in->sequenceNumber;
d1965 1
a1965 1
    out->serial         = in->sequenceNumber;
d1986 1
a1986 1
    out->serial         = in->sequenceNumber;
d2014 1
a2014 1
    out->serial     = in->sequenceNumber;
@


1.12
log
@Update to libXi 1.6.3rc1
@
text
@a75 29
extern void _xibaddevice(
    Display *		/* dpy */,
    int *		/* error */
);

extern void _xibadclass(
    Display *		/* dpy */,
    int *		/* error */
);

extern void _xibadevent(
    Display *		/* dpy */,
    int *		/* error */
);

extern void _xibadmode(
    Display *		/* dpy */,
    int *		/* error */
);

extern void _xidevicebusy(
    Display *		/* dpy */,
    int *		/* error */
);

extern int _XiGetDevicePresenceNotifyEvent(
    Display *		/* dpy */
);

d80 1
a80 1
static /* const */ char *xinput_extension_name = INAME;
d127 3
d149 1
a149 1
static char *XInputErrorList[] = {
a472 1
    unsigned int i, j;
d597 1
d693 1
d738 1
d1028 10
d1419 12
d1432 2
d1492 4
d1999 32
@


1.11
log
@Update to libXi 1.6.1
@
text
@d1487 3
d1520 1
d1793 1
d1826 1
d1867 1
d1918 1
d1961 1
d1982 1
@


1.10
log
@Update to libXi 1.4.5.
@
text
@d53 4
d148 1
a148 1
wireToRawEvent(xXIRawEvent *in, XGenericEventCookie *cookie);
d153 3
d159 2
d170 1
a170 1
    _XiEventToWire,	/* event_to_wire */
d280 3
a282 1
{XI_Present, 2, 0}
d347 37
a396 2
    XExtensionVersion *ext;

d412 3
a414 8
    if (versions[version_index].major_version > Dont_Check) {
	ext = ((XInputData *) info->data)->vers;
	if ((ext->major_version < versions[version_index].major_version) ||
	    ((ext->major_version == versions[version_index].major_version) &&
	     (ext->minor_version < versions[version_index].minor_version))) {
	    UnlockDisplay(dpy);
	    return (-1);
	}
d416 1
d437 10
a446 1
    return XextRemoveDisplay(xinput_info, dpy);
a813 1
                        stev = (XDeviceStateNotifyEvent *) re;
a840 1
                        kstev = (XDeviceStateNotifyEvent *) re;
a867 1
                        bstev = (XDeviceStateNotifyEvent *) re;
d975 3
d1004 10
d1020 3
d1024 1
a1024 1
            if (!wireToRawEvent((xXIRawEvent*)event, cookie))
d1079 49
d1139 2
d1144 2
a1145 5
            l = sizeof(XIButtonClassInfo);
            l += num_elements * sizeof(Atom);
            /* Force mask alignment with longs to avoid
             * unaligned access when accessing the atoms. */
            l += ((((num_elements + 7)/8) + 3)/4) * sizeof(Atom);
d1148 2
a1149 2
            l = sizeof(XIKeyClassInfo);
            l += num_elements * sizeof(int);
d1152 7
a1158 1
            l = sizeof(XIValuatorClassInfo);
d1219 3
d1247 3
a1249 1
                    int size;
d1252 3
a1254 1
                    bout = next_block(&ptr, sizeof(XIButtonClass));
d1257 1
a1257 4
                    /* Force mask alignment with longs to avoid unaligned
                     * access when accessing the atoms. */
                    size = bout->state.mask_len/4 * sizeof(Atom);
                    bout->state.mask = next_block(&ptr, size);
d1261 1
a1261 1
                    bout->labels = next_block(&ptr, bout->num_buttons * sizeof(Atom));
d1269 2
d1272 2
d1275 1
a1275 1
                    kout = next_block(&ptr, sizeof(XIKeyClass));
d1277 1
a1277 1
                    kout->keycodes = next_block(&ptr, kout->num_keycodes * sizeof(int));
d1286 2
a1287 1
                    vout = next_block(&ptr, sizeof(XIValuatorClass));
d1292 10
d1385 16
d1459 3
d1479 3
d1576 2
a1577 1
    len = nclasses * sizeof(XIAnyClassInfo*); /* len for to->classes */
d1596 6
d1632 2
a1633 1
    to->classes = next_block(&ptr_lib, (*nclasses) * sizeof(XIAnyClassInfo*));
a1648 1
                    int size;
d1650 4
a1654 1
                    cls_lib = next_block(&ptr_lib, sizeof(XIButtonClassInfo));
d1656 5
d1665 2
a1666 5
                    size = ((((cls_wire->num_buttons + 7)/8) + 3)/4);
                    cls_lib->state.mask_len = size * 4;
                    /* Force mask alignment with longs to avoid unaligned
                     * access when accessing the atoms. */
                    cls_lib->state.mask = next_block(&ptr_lib, size * sizeof(Atom));
d1668 6
a1673 1
                           cls_lib->state.mask_len);
d1675 1
a1675 2
                    cls_lib->labels = next_block(&ptr_lib, cls_lib->num_buttons * sizeof(Atom));
                    atoms =(uint32_t*)((char*)&cls_wire[1] + cls_lib->state.mask_len);
d1686 2
a1688 1
                    cls_lib = next_block(&ptr_lib, sizeof(XIKeyClassInfo));
d1690 3
d1697 1
a1697 2
                    cls_lib->keycodes = next_block(&ptr_lib,
                            cls_lib->num_keycodes * sizeof(int));
d1709 3
a1711 1
                    cls_lib = next_block(&ptr_lib, sizeof(XIValuatorClassInfo));
d1728 37
d1844 1
a1844 1
wireToRawEvent(xXIRawEvent *in, XGenericEventCookie *cookie)
a1850 1

a1867 1
    out->sourceid       = 0; /* https://bugs.freedesktop.org/show_bug.cgi?id=34240 */
d1870 6
d1960 25
@


1.9
log
@Update to libXi 1.4.4.
@
text
@d271 1
a271 1
{XI_Present, XI_2_Major, XI_2_Minor}
@


1.8
log
@Update to libXi 1.4.3.
This contains more doc fixes and a few more bug fixes.
@
text
@d101 1
a101 1
int copy_classes(XIDeviceInfo *to, xXIAnyInfo* from, int nclasses);
d1452 1
a1452 1
copy_classes(XIDeviceInfo* to, xXIAnyInfo* from, int nclasses)
d1459 1
d1466 2
a1467 1
    to->classes = next_block(&ptr_lib, nclasses * sizeof(XIAnyClassInfo*));
d1470 1
a1470 1
    for (i = 0; i < nclasses; i++)
a1474 3
        to->classes[i] = any_lib;
        any_lib->type = any_wire->type;
        any_lib->sourceid = any_wire->sourceid;
d1488 2
d1504 1
d1515 2
d1523 1
d1534 2
d1545 1
d1552 3
d1565 1
a1579 1
    out->num_classes = in->num_classes;
d1585 2
a1586 1
    copy_classes(&info, (xXIAnyInfo*)&in[1], in->num_classes);
@


1.7
log
@Update to libXi 1.4.2.
Tested by ajacoutot@@, jasper@@, krw@@, shadchin@@.
I believe that the bugs spotted by krw@@ are fixed in an upcoming
inputproto update.
@
text
@d1262 1
a1262 1
    ptr = cookie_out->data = malloc(sizeof(XIRawEvent));
@


1.6
log
@Force alignment with sizeof(Atom) for XIButtonClassInfo.
From upstream; ok matthieu@@
@
text
@d1356 1
d1560 1
d1590 1
d1633 1
d1640 1
d1678 1
@


1.5
log
@Update to libXi 1.4.0. small bug fixes plus doc/spec/autotools churn.
@
text
@d1031 3
a1033 1
            l += ((((num_elements + 7)/8) + 3)/4) * 4;
d1126 1
d1132 4
a1135 1
                    bout->state.mask = next_block(&ptr, bout->state.mask_len);
d1482 1
d1489 5
a1493 2
                    cls_lib->state.mask_len = ((((cls_wire->num_buttons + 7)/8) + 3)/4) * 4;
                    cls_lib->state.mask = next_block(&ptr_lib, cls_lib->state.mask_len);
@


1.4
log
@Update to libXi 1.3.2
@
text
@a52 2
#define NEED_EVENTS
#define NEED_REPLIES
d1641 1
a1641 1
        out->valuators.values[i] += ((double)(values + bits)->frac / (1 << 16) / (1 << 16));
@


1.3
log
@Update to libXi 1.3. Tested on a bulk ports build by naddy@@.
@
text
@d176 57
d240 2
d245 6
a250 3
                                IEVENTS, NULL);
      XESetWireToEventCookie(dpy, dpyinfo->codes->major_opcode, XInputWireToCookie);
      XESetCopyEventCookie(dpy, dpyinfo->codes->major_opcode, XInputCopyCookie);
@


1.2
log
@update to libXi 1.2.1
@
text
@a0 2
/* $Xorg: XExtInt.c,v 1.4 2001/02/09 02:03:50 xorgcvs Exp $ */

a45 1
/* $XFree86: xc/lib/Xi/XExtInt.c,v 3.6 2001/12/14 19:55:09 dawes Exp $ */
d56 1
d58 1
d60 1
d63 1
d65 3
d72 33
d108 44
a151 4
static int XInputClose();
static char *XInputError();
static Bool XInputWireToEvent();
Status _XiEventToWire();
a153 6
typedef struct _XInputData
{
    XEvent data;
    XExtensionVersion *vers;
} XInputData;

d176 16
a191 3
XEXT_GENERATE_FIND_DISPLAY(XInput_find_display, xinput_info,
			   xinput_extension_name, &xinput_extension_hooks,
			   IEVENTS, NULL)
d193 2
a194 2
    static XEXT_GENERATE_ERROR_STRING(XInputError, xinput_extension_name,
				      IERRORS, XInputErrorList)
d196 17
a212 16
 *
 * Input extension versions.
 *
 */
    static XExtensionVersion versions[] = { {XI_Absent, 0, 0},
    {XI_Present, XI_Initial_Release_Major, XI_Initial_Release_Minor},
    {XI_Present, XI_Add_XDeviceBell_Major, XI_Add_XDeviceBell_Minor},
    {XI_Present, XI_Add_XSetDeviceValuators_Major,
     XI_Add_XSetDeviceValuators_Minor},
    {XI_Present, XI_Add_XChangeDeviceControl_Major,
     XI_Add_XChangeDeviceControl_Minor},
    {XI_Present, XI_Add_DevicePresenceNotify_Major,
     XI_Add_DevicePresenceNotify_Minor},
    {XI_Present, XI_Add_DeviceProperties_Major,
        XI_Add_DeviceProperties_Minor},
    };
d221 3
a223 3
_xibaddevice(dpy, error)
    Display *dpy;
    int *error;
d231 3
a233 3
_xibadclass(dpy, error)
    Display *dpy;
    int *error;
d241 3
a243 3
_xibadevent(dpy, error)
    Display *dpy;
    int *error;
d251 3
a253 3
_xibadmode(dpy, error)
    Display *dpy;
    int *error;
d261 3
a263 3
_xidevicebusy(dpy, error)
    Display *dpy;
    int *error;
d283 5
a287 5
int
_XiCheckExtInit(dpy, version_index, info)
    register Display *dpy;
    register int version_index;
    XExtDisplayInfo *info;
d325 3
a327 3
XInputClose(dpy, codes)
    Display *dpy;
    XExtCodes *codes;
d339 1
a339 2
Ones(mask)
    Mask mask;
d348 18
d382 4
a385 4
XInputWireToEvent(dpy, re, event)
    Display *dpy;
    XEvent *re;
    xEvent *event;
d395 2
a396 1
    if (reltype != XI_DeviceValuator &&
d398 1
a398 1
	reltype != XI_DeviceButtonstateNotify) {
d408 2
a409 2
    switch (reltype) {
    case XI_DeviceMotionNotify:
d411 416
a826 2
	register XDeviceMotionEvent *ev = (XDeviceMotionEvent *) save;
	deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;
d828 23
a850 39
	ev->root = ev2->root;
	ev->window = ev2->event;
	ev->subwindow = ev2->child;
	ev->time = ev2->time;
	ev->x_root = ev2->root_x;
	ev->y_root = ev2->root_y;
	ev->x = ev2->event_x;
	ev->y = ev2->event_y;
	ev->state = ev2->state;
	ev->same_screen = ev2->same_screen;
	ev->is_hint = ev2->detail;
	ev->deviceid = ev2->deviceid & DEVICE_BITS;
	return (DONT_ENQUEUE);
    }
	break;
    case XI_DeviceKeyPress:
    case XI_DeviceKeyRelease:
    {
	register XDeviceKeyEvent *ev = (XDeviceKeyEvent *) save;
	deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

	ev->root = ev2->root;
	ev->window = ev2->event;
	ev->subwindow = ev2->child;
	ev->time = ev2->time;
	ev->x_root = ev2->root_x;
	ev->y_root = ev2->root_y;
	ev->x = ev2->event_x;
	ev->y = ev2->event_y;
	ev->state = ev2->state;
	ev->same_screen = ev2->same_screen;
	ev->keycode = ev2->detail;
	ev->deviceid = ev2->deviceid & DEVICE_BITS;
	if (ev2->deviceid & MORE_EVENTS)
	    return (DONT_ENQUEUE);
	else {
	    *re = *save;
	    return (ENQUEUE_EVENT);
	}
d852 79
a930 25
	break;
    case XI_DeviceButtonPress:
    case XI_DeviceButtonRelease:
    {
	register XDeviceButtonEvent *ev = (XDeviceButtonEvent *) save;
	deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

	ev->root = ev2->root;
	ev->window = ev2->event;
	ev->subwindow = ev2->child;
	ev->time = ev2->time;
	ev->x_root = ev2->root_x;
	ev->y_root = ev2->root_y;
	ev->x = ev2->event_x;
	ev->y = ev2->event_y;
	ev->state = ev2->state;
	ev->same_screen = ev2->same_screen;
	ev->button = ev2->detail;
	ev->deviceid = ev2->deviceid & DEVICE_BITS;
	if (ev2->deviceid & MORE_EVENTS)
	    return (DONT_ENQUEUE);
	else {
	    *re = *save;
	    return (ENQUEUE_EVENT);
	}
d932 51
a982 24
	break;
    case XI_ProximityIn:
    case XI_ProximityOut:
    {
	register XProximityNotifyEvent *ev = (XProximityNotifyEvent *) save;
	deviceKeyButtonPointer *ev2 = (deviceKeyButtonPointer *) event;

	ev->root = ev2->root;
	ev->window = ev2->event;
	ev->subwindow = ev2->child;
	ev->time = ev2->time;
	ev->x_root = ev2->root_x;
	ev->y_root = ev2->root_y;
	ev->x = ev2->event_x;
	ev->y = ev2->event_y;
	ev->state = ev2->state;
	ev->same_screen = ev2->same_screen;
	ev->deviceid = ev2->deviceid & DEVICE_BITS;
	if (ev2->deviceid & MORE_EVENTS)
	    return (DONT_ENQUEUE);
	else {
	    *re = *save;
	    return (ENQUEUE_EVENT);
	}
d984 40
a1023 2
	break;
    case XI_DeviceValuator:
d1025 21
a1045 2
	deviceValuator *xev = (deviceValuator *) event;
	int save_type = save->type - info->codes->first_event;
d1047 5
a1051 2
	if (save_type == XI_DeviceKeyPress || save_type == XI_DeviceKeyRelease) {
	    XDeviceKeyEvent *kev = (XDeviceKeyEvent *) save;
d1053 2
a1054 112
	    kev->device_state = xev->device_state;
	    kev->axes_count = xev->num_valuators;
	    kev->first_axis = xev->first_valuator;
	    i = xev->num_valuators;
	    if (i > 6)
		i = 6;
	    switch (i) {
	    case 6:
		kev->axis_data[5] = xev->valuator5;
	    case 5:
		kev->axis_data[4] = xev->valuator4;
	    case 4:
		kev->axis_data[3] = xev->valuator3;
	    case 3:
		kev->axis_data[2] = xev->valuator2;
	    case 2:
		kev->axis_data[1] = xev->valuator1;
	    case 1:
		kev->axis_data[0] = xev->valuator0;
	    }
	} else if (save_type == XI_DeviceButtonPress ||
		   save_type == XI_DeviceButtonRelease) {
	    XDeviceButtonEvent *bev = (XDeviceButtonEvent *) save;

	    bev->device_state = xev->device_state;
	    bev->axes_count = xev->num_valuators;
	    bev->first_axis = xev->first_valuator;
	    i = xev->num_valuators;
	    if (i > 6)
		i = 6;
	    switch (i) {
	    case 6:
		bev->axis_data[5] = xev->valuator5;
	    case 5:
		bev->axis_data[4] = xev->valuator4;
	    case 4:
		bev->axis_data[3] = xev->valuator3;
	    case 3:
		bev->axis_data[2] = xev->valuator2;
	    case 2:
		bev->axis_data[1] = xev->valuator1;
	    case 1:
		bev->axis_data[0] = xev->valuator0;
	    }
	} else if (save_type == XI_DeviceMotionNotify) {
	    XDeviceMotionEvent *mev = (XDeviceMotionEvent *) save;

	    mev->device_state = xev->device_state;
	    mev->axes_count = xev->num_valuators;
	    mev->first_axis = xev->first_valuator;
	    i = xev->num_valuators;
	    if (i > 6)
		i = 6;
	    switch (i) {
	    case 6:
		mev->axis_data[5] = xev->valuator5;
	    case 5:
		mev->axis_data[4] = xev->valuator4;
	    case 4:
		mev->axis_data[3] = xev->valuator3;
	    case 3:
		mev->axis_data[2] = xev->valuator2;
	    case 2:
		mev->axis_data[1] = xev->valuator1;
	    case 1:
		mev->axis_data[0] = xev->valuator0;
	    }
	} else if (save_type == XI_ProximityIn || save_type == XI_ProximityOut) {
	    XProximityNotifyEvent *pev = (XProximityNotifyEvent *) save;

	    pev->device_state = xev->device_state;
	    pev->axes_count = xev->num_valuators;
	    pev->first_axis = xev->first_valuator;
	    i = xev->num_valuators;
	    if (i > 6)
		i = 6;
	    switch (i) {
	    case 6:
		pev->axis_data[5] = xev->valuator5;
	    case 5:
		pev->axis_data[4] = xev->valuator4;
	    case 4:
		pev->axis_data[3] = xev->valuator3;
	    case 3:
		pev->axis_data[2] = xev->valuator2;
	    case 2:
		pev->axis_data[1] = xev->valuator1;
	    case 1:
		pev->axis_data[0] = xev->valuator0;
	    }
	} else if (save_type == XI_DeviceStateNotify) {
	    XDeviceStateNotifyEvent *sev = (XDeviceStateNotifyEvent *) save;
	    XInputClass *any = (XInputClass *) & sev->data[0];
	    XValuatorStatus *v;

	    for (i = 0; i < sev->num_classes; i++)
		if (any->class != ValuatorClass)
		    any = (XInputClass *) ((char *)any + any->length);
	    v = (XValuatorStatus *) any;
	    i = v->num_valuators;
	    j = xev->num_valuators;
	    if (j > 3)
		j = 3;
	    switch (j) {
	    case 3:
		v->valuators[i + 2] = xev->valuator2;
	    case 2:
		v->valuators[i + 1] = xev->valuator1;
	    case 1:
		v->valuators[i + 0] = xev->valuator0;
	    }
	    v->num_valuators += j;
d1056 44
a1099 3
	}
	*re = *save;
	return (ENQUEUE_EVENT);
a1100 38
	break;
    case XI_DeviceFocusIn:
    case XI_DeviceFocusOut:
    {
	register XDeviceFocusChangeEvent *ev = (XDeviceFocusChangeEvent *) re;
	deviceFocus *fev = (deviceFocus *) event;

	*ev = *((XDeviceFocusChangeEvent *) save);
	ev->window = fev->window;
	ev->time = fev->time;
	ev->mode = fev->mode;
	ev->detail = fev->detail;
	ev->deviceid = fev->deviceid & DEVICE_BITS;
	return (ENQUEUE_EVENT);
    }
	break;
    case XI_DeviceStateNotify:
    {
	XDeviceStateNotifyEvent *stev = (XDeviceStateNotifyEvent *) save;
	deviceStateNotify *sev = (deviceStateNotify *) event;
	char *data;

	stev->window = None;
	stev->deviceid = sev->deviceid & DEVICE_BITS;
	stev->time = sev->time;
	stev->num_classes = Ones((Mask) sev->classes_reported & InputClassBits);
	data = (char *)&stev->data[0];
	if (sev->classes_reported & (1 << KeyClass)) {
	    register XKeyStatus *kstev = (XKeyStatus *) data;

	    kstev->class = KeyClass;
	    kstev->length = sizeof(XKeyStatus);
	    kstev->num_keys = sev->num_keys;
	    memcpy((char *)&kstev->keys[0], (char *)&sev->keys[0], 4);
	    data += sizeof(XKeyStatus);
	}
	if (sev->classes_reported & (1 << ButtonClass)) {
	    register XButtonStatus *bev = (XButtonStatus *) data;
d1102 120
a1221 8
	    bev->class = ButtonClass;
	    bev->length = sizeof(XButtonStatus);
	    bev->num_buttons = sev->num_buttons;
	    memcpy((char *)bev->buttons, (char *)sev->buttons, 4);
	    data += sizeof(XButtonStatus);
	}
	if (sev->classes_reported & (1 << ValuatorClass)) {
	    register XValuatorStatus *vev = (XValuatorStatus *) data;
d1223 5
a1227 24
	    vev->class = ValuatorClass;
	    vev->length = sizeof(XValuatorStatus);
	    vev->num_valuators = sev->num_valuators;
	    vev->mode = sev->classes_reported >> ModeBitsShift;
	    j = sev->num_valuators;
	    if (j > 3)
		j = 3;
	    switch (j) {
	    case 3:
		vev->valuators[2] = sev->valuator2;
	    case 2:
		vev->valuators[1] = sev->valuator1;
	    case 1:
		vev->valuators[0] = sev->valuator0;
	    }
	    data += sizeof(XValuatorStatus);
	}
	if (sev->deviceid & MORE_EVENTS)
	    return (DONT_ENQUEUE);
	else {
	    *re = *save;
	    stev = (XDeviceStateNotifyEvent *) re;
	    return (ENQUEUE_EVENT);
	}
d1229 38
a1266 27
	break;
    case XI_DeviceKeystateNotify:
    {
	int i;
	XInputClass *anyclass;
	register XKeyStatus *kv;
	deviceKeyStateNotify *ksev = (deviceKeyStateNotify *) event;
	XDeviceStateNotifyEvent *kstev = (XDeviceStateNotifyEvent *) save;

	anyclass = (XInputClass *) & kstev->data[0];
	for (i = 0; i < kstev->num_classes; i++)
	    if (anyclass->class == KeyClass)
		break;
	    else
		anyclass = (XInputClass *) ((char *)anyclass +
					    anyclass->length);

	kv = (XKeyStatus *) anyclass;
	kv->num_keys = 256;
	memcpy((char *)&kv->keys[4], (char *)ksev->keys, 28);
	if (ksev->deviceid & MORE_EVENTS)
	    return (DONT_ENQUEUE);
	else {
	    *re = *save;
	    kstev = (XDeviceStateNotifyEvent *) re;
	    return (ENQUEUE_EVENT);
	}
d1268 66
a1333 2
	break;
    case XI_DeviceButtonstateNotify:
d1335 2
a1336 24
	int i;
	XInputClass *anyclass;
	register XButtonStatus *bv;
	deviceButtonStateNotify *bsev = (deviceButtonStateNotify *) event;
	XDeviceStateNotifyEvent *bstev = (XDeviceStateNotifyEvent *) save;

	anyclass = (XInputClass *) & bstev->data[0];
	for (i = 0; i < bstev->num_classes; i++)
	    if (anyclass->class == ButtonClass)
		break;
	    else
		anyclass = (XInputClass *) ((char *)anyclass +
					    anyclass->length);

	bv = (XButtonStatus *) anyclass;
	bv->num_buttons = 256;
	memcpy((char *)&bv->buttons[4], (char *)bsev->buttons, 28);
	if (bsev->deviceid & MORE_EVENTS)
	    return (DONT_ENQUEUE);
	else {
	    *re = *save;
	    bstev = (XDeviceStateNotifyEvent *) re;
	    return (ENQUEUE_EVENT);
	}
d1338 15
a1352 2
	break;
    case XI_DeviceMappingNotify:
d1354 16
a1369 2
	register XDeviceMappingEvent *ev = (XDeviceMappingEvent *) re;
	deviceMappingNotify *ev2 = (deviceMappingNotify *) event;
d1371 2
a1372 36
	*ev = *((XDeviceMappingEvent *) save);
	ev->window = 0;
	ev->first_keycode = ev2->firstKeyCode;
	ev->request = ev2->request;
	ev->count = ev2->count;
	ev->time = ev2->time;
	ev->deviceid = ev2->deviceid & DEVICE_BITS;
	return (ENQUEUE_EVENT);
    }
	break;
    case XI_ChangeDeviceNotify:
    {
	register XChangeDeviceNotifyEvent *ev = (XChangeDeviceNotifyEvent *) re;
	changeDeviceNotify *ev2 = (changeDeviceNotify *) event;

	*ev = *((XChangeDeviceNotifyEvent *) save);
	ev->window = 0;
	ev->request = ev2->request;
	ev->time = ev2->time;
	ev->deviceid = ev2->deviceid & DEVICE_BITS;
	return (ENQUEUE_EVENT);
    }
	break;

    case XI_DevicePresenceNotify:
    {
	XDevicePresenceNotifyEvent *ev = (XDevicePresenceNotifyEvent *) re;
	devicePresenceNotify *ev2 = (devicePresenceNotify *) event;

	*ev = *(XDevicePresenceNotifyEvent *) save;
	ev->window = 0;
	ev->time = ev2->time;
        ev->devchange = ev2->devchange;
        ev->deviceid = ev2->deviceid;
        ev->control = ev2->control;
	return (ENQUEUE_EVENT);
a1373 1
	break;
d1375 30
a1404 1
    case XI_DevicePropertyNotify:
d1406 4
d1411 55
a1465 2
            XDevicePropertyNotifyEvent* ev = (XDevicePropertyNotifyEvent*)re;
            devicePropertyNotify *ev2 = (devicePropertyNotify*)event;
d1467 2
a1468 6
            *ev = *(XDevicePropertyNotifyEvent*)save;
            ev->time = ev2->time;
            ev->deviceid = ev2->deviceid;
            ev->atom = ev2->atom;
            ev->state = ev2->state;
            return ENQUEUE_EVENT;
d1470 101
a1570 1
        break;
d1572 11
a1582 3
    default:
	printf("XInputWireToEvent: UNKNOWN WIRE EVENT! type=%d\n", type);
	break;
d1585 68
a1652 1
    return (DONT_ENQUEUE);
@


1.1
log
@Initial revision
@
text
@a82 3
#define XInputCheckExtension(dpy,i,val) \
  XextCheckExtension (dpy, i, xinput_extension_name, val)

d122 5
a126 1
     XI_Add_XChangeDeviceControl_Minor}
d185 6
d206 4
a209 1
    XInputCheckExtension(dpy, info, -1);
d218 1
a218 1
	    _XiGetExtensionVersion(dpy, "XInputExtension");
d264 8
d686 31
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@libXi 1.1.3
@
text
@d83 3
d125 1
a125 3
     XI_Add_XChangeDeviceControl_Minor},
    {XI_Present, XI_Add_DevicePresenceNotify_Major,
     XI_Add_DevicePresenceNotify_Minor}
a183 6
static int XInputCheckExtension(Display *dpy, XExtDisplayInfo *info)
{
    XextCheckExtension (dpy, info, xinput_extension_name, 0);
    return 1;
}

d199 1
a199 4
    if (!XInputCheckExtension(dpy, info)) {
	UnlockDisplay(dpy);
	return (-1);
    }
d208 1
a208 1
	    _XiGetExtensionVersion(dpy, "XInputExtension", info);
a253 8
int
_XiGetDevicePresenceNotifyEvent(Display * dpy)
{
    XExtDisplayInfo *info = XInput_find_display(dpy);

    return info->codes->first_event + XI_DevicePresenceNotify;
}

a667 16

    case XI_DevicePresenceNotify:
    {
	XDevicePresenceNotifyEvent *ev = (XDevicePresenceNotifyEvent *) re;
	devicePresenceNotify *ev2 = (devicePresenceNotify *) event;

	*ev = *(XDevicePresenceNotifyEvent *) save;
	ev->window = 0;
	ev->time = ev2->time;
        ev->devchange = ev2->devchange;
        ev->deviceid = ev2->deviceid;
        ev->control = ev2->control;
	return (ENQUEUE_EVENT);
    }
	break;

@

