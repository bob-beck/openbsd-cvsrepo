head	1.1;
branch	1.1.1;
access;
symbols
	libdrm_2_4_79:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	libdrm_2_4_75:1.1.1.2
	libdrm_2_4_73:1.1.1.2
	libdrm_2_4_71:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	libdrm_2_4_67:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	libdrm_2_4_65:1.1.1.1
	libdrm_2_4_64:1.1.1.1
	libdrm:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.08.21.23.55.50;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	IINH94ZNafdY3NZg;

1.1.1.1
date	2015.08.21.23.55.50;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	IINH94ZNafdY3NZg;

1.1.1.2
date	2016.10.16.06.01.25;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	UDYjDzwIWWXeKnu7;

1.1.1.3
date	2017.04.14.07.46.04;	author jsg;	state Exp;
branches;
next	;
commitid	AidaeLRxsBwWWBha;


desc
@@


1.1
log
@Initial revision
@
text
@/* amdgpu_drm.h -- Public header for the amdgpu driver -*- linux-c -*-
 *
 * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
 * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2014 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Kevin E. Martin <martin@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *    Keith Whitwell <keith@@tungstengraphics.com>
 */

#ifndef __AMDGPU_DRM_H__
#define __AMDGPU_DRM_H__

#include "drm.h"

#define DRM_AMDGPU_GEM_CREATE		0x00
#define DRM_AMDGPU_GEM_MMAP		0x01
#define DRM_AMDGPU_CTX			0x02
#define DRM_AMDGPU_BO_LIST		0x03
#define DRM_AMDGPU_CS			0x04
#define DRM_AMDGPU_INFO			0x05
#define DRM_AMDGPU_GEM_METADATA		0x06
#define DRM_AMDGPU_GEM_WAIT_IDLE	0x07
#define DRM_AMDGPU_GEM_VA		0x08
#define DRM_AMDGPU_WAIT_CS		0x09
#define DRM_AMDGPU_GEM_OP		0x10
#define DRM_AMDGPU_GEM_USERPTR		0x11

#define DRM_IOCTL_AMDGPU_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_CREATE, union drm_amdgpu_gem_create)
#define DRM_IOCTL_AMDGPU_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_MMAP, union drm_amdgpu_gem_mmap)
#define DRM_IOCTL_AMDGPU_CTX		DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_CTX, union drm_amdgpu_ctx)
#define DRM_IOCTL_AMDGPU_BO_LIST	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_BO_LIST, union drm_amdgpu_bo_list)
#define DRM_IOCTL_AMDGPU_CS		DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_CS, union drm_amdgpu_cs)
#define DRM_IOCTL_AMDGPU_INFO		DRM_IOW(DRM_COMMAND_BASE + DRM_AMDGPU_INFO, struct drm_amdgpu_info)
#define DRM_IOCTL_AMDGPU_GEM_METADATA	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_METADATA, struct drm_amdgpu_gem_metadata)
#define DRM_IOCTL_AMDGPU_GEM_WAIT_IDLE	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_WAIT_IDLE, union drm_amdgpu_gem_wait_idle)
#define DRM_IOCTL_AMDGPU_GEM_VA		DRM_IOW(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_VA, struct drm_amdgpu_gem_va)
#define DRM_IOCTL_AMDGPU_WAIT_CS	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_WAIT_CS, union drm_amdgpu_wait_cs)
#define DRM_IOCTL_AMDGPU_GEM_OP		DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_OP, struct drm_amdgpu_gem_op)
#define DRM_IOCTL_AMDGPU_GEM_USERPTR	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_USERPTR, struct drm_amdgpu_gem_userptr)

#define AMDGPU_GEM_DOMAIN_CPU		0x1
#define AMDGPU_GEM_DOMAIN_GTT		0x2
#define AMDGPU_GEM_DOMAIN_VRAM		0x4
#define AMDGPU_GEM_DOMAIN_GDS		0x8
#define AMDGPU_GEM_DOMAIN_GWS		0x10
#define AMDGPU_GEM_DOMAIN_OA		0x20

/* Flag that CPU access will be required for the case of VRAM domain */
#define AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED	(1 << 0)
/* Flag that CPU access will not work, this VRAM domain is invisible */
#define AMDGPU_GEM_CREATE_NO_CPU_ACCESS		(1 << 1)
/* Flag that USWC attributes should be used for GTT */
#define AMDGPU_GEM_CREATE_CPU_GTT_USWC		(1 << 2)

struct drm_amdgpu_gem_create_in  {
	/** the requested memory size */
	uint64_t bo_size;
	/** physical start_addr alignment in bytes for some HW requirements */
	uint64_t alignment;
	/** the requested memory domains */
	uint64_t domains;
	/** allocation flags */
	uint64_t domain_flags;
};

struct drm_amdgpu_gem_create_out  {
	/** returned GEM object handle */
	uint32_t handle;
	uint32_t _pad;
};

union drm_amdgpu_gem_create {
	struct drm_amdgpu_gem_create_in		in;
	struct drm_amdgpu_gem_create_out	out;
};

/** Opcode to create new residency list.  */
#define AMDGPU_BO_LIST_OP_CREATE	0
/** Opcode to destroy previously created residency list */
#define AMDGPU_BO_LIST_OP_DESTROY	1
/** Opcode to update resource information in the list */
#define AMDGPU_BO_LIST_OP_UPDATE	2

struct drm_amdgpu_bo_list_in {
	/** Type of operation */
	uint32_t operation;
	/** Handle of list or 0 if we want to create one */
	uint32_t list_handle;
	/** Number of BOs in list  */
	uint32_t bo_number;
	/** Size of each element describing BO */
	uint32_t bo_info_size;
	/** Pointer to array describing BOs */
	uint64_t bo_info_ptr;
};

struct drm_amdgpu_bo_list_entry {
	/** Handle of BO */
	uint32_t bo_handle;
	/** New (if specified) BO priority to be used during migration */
	uint32_t bo_priority;
};

struct drm_amdgpu_bo_list_out {
	/** Handle of resource list  */
	uint32_t list_handle;
	uint32_t _pad;
};

union drm_amdgpu_bo_list {
	struct drm_amdgpu_bo_list_in in;
	struct drm_amdgpu_bo_list_out out;
};

/* context related */
#define AMDGPU_CTX_OP_ALLOC_CTX	1
#define AMDGPU_CTX_OP_FREE_CTX	2
#define AMDGPU_CTX_OP_QUERY_STATE	3

/* GPU reset status */
#define AMDGPU_CTX_NO_RESET		0
/* this the context caused it */
#define AMDGPU_CTX_GUILTY_RESET		1
/* some other context caused it */
#define AMDGPU_CTX_INNOCENT_RESET	2
/* unknown cause */
#define AMDGPU_CTX_UNKNOWN_RESET	3

struct drm_amdgpu_ctx_in {
	/** AMDGPU_CTX_OP_* */
	uint32_t	op;
	/** For future use, no flags defined so far */
	uint32_t	flags;
	uint32_t	ctx_id;
	uint32_t	_pad;
};

union drm_amdgpu_ctx_out {
		struct {
			uint32_t	ctx_id;
			uint32_t	_pad;
		} alloc;

		struct {
			/** For future use, no flags defined so far */
			uint64_t	flags;
			/** Number of resets caused by this context so far. */
			uint32_t	hangs;
			/** Reset status since the last call of the ioctl. */
			uint32_t	reset_status;
		} state;
};

union drm_amdgpu_ctx {
	struct drm_amdgpu_ctx_in in;
	union drm_amdgpu_ctx_out out;
};

/*
 * This is not a reliable API and you should expect it to fail for any
 * number of reasons and have fallback path that do not use userptr to
 * perform any operation.
 */
#define AMDGPU_GEM_USERPTR_READONLY	(1 << 0)
#define AMDGPU_GEM_USERPTR_ANONONLY	(1 << 1)
#define AMDGPU_GEM_USERPTR_VALIDATE	(1 << 2)
#define AMDGPU_GEM_USERPTR_REGISTER	(1 << 3)

struct drm_amdgpu_gem_userptr {
	uint64_t		addr;
	uint64_t		size;
	/* AMDGPU_GEM_USERPTR_* */
	uint32_t		flags;
	/* Resulting GEM handle */
	uint32_t		handle;
};

/* same meaning as the GB_TILE_MODE and GL_MACRO_TILE_MODE fields */
#define AMDGPU_TILING_ARRAY_MODE_SHIFT			0
#define AMDGPU_TILING_ARRAY_MODE_MASK			0xf
#define AMDGPU_TILING_PIPE_CONFIG_SHIFT			4
#define AMDGPU_TILING_PIPE_CONFIG_MASK			0x1f
#define AMDGPU_TILING_TILE_SPLIT_SHIFT			9
#define AMDGPU_TILING_TILE_SPLIT_MASK			0x7
#define AMDGPU_TILING_MICRO_TILE_MODE_SHIFT		12
#define AMDGPU_TILING_MICRO_TILE_MODE_MASK		0x7
#define AMDGPU_TILING_BANK_WIDTH_SHIFT			15
#define AMDGPU_TILING_BANK_WIDTH_MASK			0x3
#define AMDGPU_TILING_BANK_HEIGHT_SHIFT			17
#define AMDGPU_TILING_BANK_HEIGHT_MASK			0x3
#define AMDGPU_TILING_MACRO_TILE_ASPECT_SHIFT		19
#define AMDGPU_TILING_MACRO_TILE_ASPECT_MASK		0x3
#define AMDGPU_TILING_NUM_BANKS_SHIFT			21
#define AMDGPU_TILING_NUM_BANKS_MASK			0x3

#define AMDGPU_TILING_SET(field, value) \
	(((value) & AMDGPU_TILING_##field##_MASK) << AMDGPU_TILING_##field##_SHIFT)
#define AMDGPU_TILING_GET(value, field) \
	(((value) >> AMDGPU_TILING_##field##_SHIFT) & AMDGPU_TILING_##field##_MASK)

#define AMDGPU_GEM_METADATA_OP_SET_METADATA                  1
#define AMDGPU_GEM_METADATA_OP_GET_METADATA                  2

/** The same structure is shared for input/output */
struct drm_amdgpu_gem_metadata {
	/** GEM Object handle */
	uint32_t	handle;
	/** Do we want get or set metadata */
	uint32_t	op;
	struct {
		/** For future use, no flags defined so far */
		uint64_t	flags;
		/** family specific tiling info */
		uint64_t	tiling_info;
		uint32_t	data_size_bytes;
		uint32_t	data[64];
	} data;
};

struct drm_amdgpu_gem_mmap_in {
	/** the GEM object handle */
	uint32_t handle;
	uint32_t _pad;
};

struct drm_amdgpu_gem_mmap_out {
	/** mmap offset from the vma offset manager */
	uint64_t addr_ptr;
};

union drm_amdgpu_gem_mmap {
	struct drm_amdgpu_gem_mmap_in   in;
	struct drm_amdgpu_gem_mmap_out out;
};

struct drm_amdgpu_gem_wait_idle_in {
	/** GEM object handle */
	uint32_t handle;
	/** For future use, no flags defined so far */
	uint32_t flags;
	/** Absolute timeout to wait */
	uint64_t timeout;
};

struct drm_amdgpu_gem_wait_idle_out {
	/** BO status:  0 - BO is idle, 1 - BO is busy */
	uint32_t status;
	/** Returned current memory domain */
	uint32_t domain;
};

union drm_amdgpu_gem_wait_idle {
	struct drm_amdgpu_gem_wait_idle_in  in;
	struct drm_amdgpu_gem_wait_idle_out out;
};

struct drm_amdgpu_wait_cs_in {
	/** Command submission handle */
	uint64_t handle;
	/** Absolute timeout to wait */
	uint64_t timeout;
	uint32_t ip_type;
	uint32_t ip_instance;
	uint32_t ring;
	uint32_t ctx_id;
};

struct drm_amdgpu_wait_cs_out {
	/** CS status:  0 - CS completed, 1 - CS still busy */
	uint64_t status;
};

union drm_amdgpu_wait_cs {
	struct drm_amdgpu_wait_cs_in in;
	struct drm_amdgpu_wait_cs_out out;
};

#define AMDGPU_GEM_OP_GET_GEM_CREATE_INFO	0
#define AMDGPU_GEM_OP_SET_PLACEMENT		1

/* Sets or returns a value associated with a buffer. */
struct drm_amdgpu_gem_op {
	/** GEM object handle */
	uint32_t	handle;
	/** AMDGPU_GEM_OP_* */
	uint32_t	op;
	/** Input or return value */
	uint64_t	value;
};

#define AMDGPU_VA_OP_MAP			1
#define AMDGPU_VA_OP_UNMAP			2

/* Delay the page table update till the next CS */
#define AMDGPU_VM_DELAY_UPDATE		(1 << 0)

/* Mapping flags */
/* readable mapping */
#define AMDGPU_VM_PAGE_READABLE		(1 << 1)
/* writable mapping */
#define AMDGPU_VM_PAGE_WRITEABLE	(1 << 2)
/* executable mapping, new for VI */
#define AMDGPU_VM_PAGE_EXECUTABLE	(1 << 3)

struct drm_amdgpu_gem_va {
	/** GEM object handle */
	uint32_t handle;
	uint32_t _pad;
	/** AMDGPU_VA_OP_* */
	uint32_t operation;
	/** AMDGPU_VM_PAGE_* */
	uint32_t flags;
	/** va address to assign . Must be correctly aligned.*/
	uint64_t va_address;
	/** Specify offset inside of BO to assign. Must be correctly aligned.*/
	uint64_t offset_in_bo;
	/** Specify mapping size. Must be correctly aligned. */
	uint64_t map_size;
};

#define AMDGPU_HW_IP_GFX          0
#define AMDGPU_HW_IP_COMPUTE      1
#define AMDGPU_HW_IP_DMA          2
#define AMDGPU_HW_IP_UVD          3
#define AMDGPU_HW_IP_VCE          4
#define AMDGPU_HW_IP_NUM          5

#define AMDGPU_HW_IP_INSTANCE_MAX_COUNT 1

#define AMDGPU_CHUNK_ID_IB		0x01
#define AMDGPU_CHUNK_ID_FENCE		0x02
#define AMDGPU_CHUNK_ID_DEPENDENCIES	0x03

struct drm_amdgpu_cs_chunk {
	uint32_t		chunk_id;
	uint32_t		length_dw;
	uint64_t		chunk_data;
};

struct drm_amdgpu_cs_in {
	/** Rendering context id */
	uint32_t		ctx_id;
	/**  Handle of resource list associated with CS */
	uint32_t		bo_list_handle;
	uint32_t		num_chunks;
	uint32_t		_pad;
	/** this points to uint64_t * which point to cs chunks */
	uint64_t		chunks;
};

struct drm_amdgpu_cs_out {
	uint64_t handle;
};

union drm_amdgpu_cs {
	struct drm_amdgpu_cs_in in;
	struct drm_amdgpu_cs_out out;
};

/* Specify flags to be used for IB */

/* This IB should be submitted to CE */
#define AMDGPU_IB_FLAG_CE	(1<<0)

/* CE Preamble */
#define AMDGPU_IB_FLAG_PREAMBLE (1<<1)

struct drm_amdgpu_cs_chunk_ib {
	uint32_t _pad;
	/** AMDGPU_IB_FLAG_* */
	uint32_t flags;
	/** Virtual address to begin IB execution */
	uint64_t va_start;
	/** Size of submission */
	uint32_t ib_bytes;
	/** HW IP to submit to */
	uint32_t ip_type;
	/** HW IP index of the same type to submit to  */
	uint32_t ip_instance;
	/** Ring index to submit to */
	uint32_t ring;
};

struct drm_amdgpu_cs_chunk_dep {
	uint32_t ip_type;
	uint32_t ip_instance;
	uint32_t ring;
	uint32_t ctx_id;
	uint64_t handle;
};

struct drm_amdgpu_cs_chunk_fence {
	uint32_t handle;
	uint32_t offset;
};

struct drm_amdgpu_cs_chunk_data {
	union {
		struct drm_amdgpu_cs_chunk_ib		ib_data;
		struct drm_amdgpu_cs_chunk_fence	fence_data;
	};
};

/**
 *  Query h/w info: Flag that this is integrated (a.h.a. fusion) GPU
 *
 */
#define AMDGPU_IDS_FLAGS_FUSION         0x1

/* indicate if acceleration can be working */
#define AMDGPU_INFO_ACCEL_WORKING		0x00
/* get the crtc_id from the mode object id? */
#define AMDGPU_INFO_CRTC_FROM_ID		0x01
/* query hw IP info */
#define AMDGPU_INFO_HW_IP_INFO			0x02
/* query hw IP instance count for the specified type */
#define AMDGPU_INFO_HW_IP_COUNT			0x03
/* timestamp for GL_ARB_timer_query */
#define AMDGPU_INFO_TIMESTAMP			0x05
/* Query the firmware version */
#define AMDGPU_INFO_FW_VERSION			0x0e
	/* Subquery id: Query VCE firmware version */
	#define AMDGPU_INFO_FW_VCE		0x1
	/* Subquery id: Query UVD firmware version */
	#define AMDGPU_INFO_FW_UVD		0x2
	/* Subquery id: Query GMC firmware version */
	#define AMDGPU_INFO_FW_GMC		0x03
	/* Subquery id: Query GFX ME firmware version */
	#define AMDGPU_INFO_FW_GFX_ME		0x04
	/* Subquery id: Query GFX PFP firmware version */
	#define AMDGPU_INFO_FW_GFX_PFP		0x05
	/* Subquery id: Query GFX CE firmware version */
	#define AMDGPU_INFO_FW_GFX_CE		0x06
	/* Subquery id: Query GFX RLC firmware version */
	#define AMDGPU_INFO_FW_GFX_RLC		0x07
	/* Subquery id: Query GFX MEC firmware version */
	#define AMDGPU_INFO_FW_GFX_MEC		0x08
	/* Subquery id: Query SMC firmware version */
	#define AMDGPU_INFO_FW_SMC		0x0a
	/* Subquery id: Query SDMA firmware version */
	#define AMDGPU_INFO_FW_SDMA		0x0b
/* number of bytes moved for TTM migration */
#define AMDGPU_INFO_NUM_BYTES_MOVED		0x0f
/* the used VRAM size */
#define AMDGPU_INFO_VRAM_USAGE			0x10
/* the used GTT size */
#define AMDGPU_INFO_GTT_USAGE			0x11
/* Information about GDS, etc. resource configuration */
#define AMDGPU_INFO_GDS_CONFIG			0x13
/* Query information about VRAM and GTT domains */
#define AMDGPU_INFO_VRAM_GTT			0x14
/* Query information about register in MMR address space*/
#define AMDGPU_INFO_READ_MMR_REG		0x15
/* Query information about device: rev id, family, etc. */
#define AMDGPU_INFO_DEV_INFO			0x16
/* visible vram usage */
#define AMDGPU_INFO_VIS_VRAM_USAGE		0x17

#define AMDGPU_INFO_MMR_SE_INDEX_SHIFT	0
#define AMDGPU_INFO_MMR_SE_INDEX_MASK	0xff
#define AMDGPU_INFO_MMR_SH_INDEX_SHIFT	8
#define AMDGPU_INFO_MMR_SH_INDEX_MASK	0xff

/* Input structure for the INFO ioctl */
struct drm_amdgpu_info {
	/* Where the return value will be stored */
	uint64_t return_pointer;
	/* The size of the return value. Just like "size" in "snprintf",
	 * it limits how many bytes the kernel can write. */
	uint32_t return_size;
	/* The query request id. */
	uint32_t query;

	union {
		struct {
			uint32_t id;
			uint32_t _pad;
		} mode_crtc;

		struct {
			/** AMDGPU_HW_IP_* */
			uint32_t type;
			/**
			 * Index of the IP if there are more IPs of the same
			 * type. Ignored by AMDGPU_INFO_HW_IP_COUNT.
			 */
			uint32_t ip_instance;
		} query_hw_ip;

		struct {
			uint32_t dword_offset;
			/** number of registers to read */
			uint32_t count;
			uint32_t instance;
			/** For future use, no flags defined so far */
			uint32_t flags;
		} read_mmr_reg;

		struct {
			/** AMDGPU_INFO_FW_* */
			uint32_t fw_type;
			/**
			 * Index of the IP if there are more IPs of
			 * the same type.
			 */
			uint32_t ip_instance;
			/**
			 * Index of the engine. Whether this is used depends
			 * on the firmware type. (e.g. MEC, SDMA)
			 */
			uint32_t index;
			uint32_t _pad;
		} query_fw;
	};
};

struct drm_amdgpu_info_gds {
	/** GDS GFX partition size */
	uint32_t gds_gfx_partition_size;
	/** GDS compute partition size */
	uint32_t compute_partition_size;
	/** total GDS memory size */
	uint32_t gds_total_size;
	/** GWS size per GFX partition */
	uint32_t gws_per_gfx_partition;
	/** GSW size per compute partition */
	uint32_t gws_per_compute_partition;
	/** OA size per GFX partition */
	uint32_t oa_per_gfx_partition;
	/** OA size per compute partition */
	uint32_t oa_per_compute_partition;
	uint32_t _pad;
};

struct drm_amdgpu_info_vram_gtt {
	uint64_t vram_size;
	uint64_t vram_cpu_accessible_size;
	uint64_t gtt_size;
};

struct drm_amdgpu_info_firmware {
	uint32_t ver;
	uint32_t feature;
};

#define AMDGPU_VRAM_TYPE_UNKNOWN 0
#define AMDGPU_VRAM_TYPE_GDDR1 1
#define AMDGPU_VRAM_TYPE_DDR2  2
#define AMDGPU_VRAM_TYPE_GDDR3 3
#define AMDGPU_VRAM_TYPE_GDDR4 4
#define AMDGPU_VRAM_TYPE_GDDR5 5
#define AMDGPU_VRAM_TYPE_HBM   6
#define AMDGPU_VRAM_TYPE_DDR3  7

struct drm_amdgpu_info_device {
	/** PCI Device ID */
	uint32_t device_id;
	/** Internal chip revision: A0, A1, etc.) */
	uint32_t chip_rev;
	uint32_t external_rev;
	/** Revision id in PCI Config space */
	uint32_t pci_rev;
	uint32_t family;
	uint32_t num_shader_engines;
	uint32_t num_shader_arrays_per_engine;
	/* in KHz */
	uint32_t gpu_counter_freq;
	uint64_t max_engine_clock;
	uint64_t max_memory_clock;
	/* cu information */
	uint32_t cu_active_number;
	uint32_t cu_ao_mask;
	uint32_t cu_bitmap[4][4];
	/** Render backend pipe mask. One render backend is CB+DB. */
	uint32_t enabled_rb_pipes_mask;
	uint32_t num_rb_pipes;
	uint32_t num_hw_gfx_contexts;
	uint32_t _pad;
	uint64_t ids_flags;
	/** Starting virtual address for UMDs. */
	uint64_t virtual_address_offset;
	/** The maximum virtual address */
	uint64_t virtual_address_max;
	/** Required alignment of virtual addresses. */
	uint32_t virtual_address_alignment;
	/** Page table entry - fragment size */
	uint32_t pte_fragment_size;
	uint32_t gart_page_size;
	/** constant engine ram size*/
	uint32_t ce_ram_size;
	/** video memory type info*/
	uint32_t vram_type;
	/** video memory bit width*/
	uint32_t vram_bit_width;
	/* vce harvesting instance */
	uint32_t vce_harvest_config;
};

struct drm_amdgpu_info_hw_ip {
	/** Version of h/w IP */
	uint32_t  hw_ip_version_major;
	uint32_t  hw_ip_version_minor;
	/** Capabilities */
	uint64_t  capabilities_flags;
	/** command buffer address start alignment*/
	uint32_t  ib_start_alignment;
	/** command buffer size alignment*/
	uint32_t  ib_size_alignment;
	/** Bitmask of available rings. Bit 0 means ring 0, etc. */
	uint32_t  available_rings;
	uint32_t  _pad;
};

/*
 * Supported GPU families
 */
#define AMDGPU_FAMILY_UNKNOWN			0
#define AMDGPU_FAMILY_CI			120 /* Bonaire, Hawaii */
#define AMDGPU_FAMILY_KV			125 /* Kaveri, Kabini, Mullins */
#define AMDGPU_FAMILY_VI			130 /* Iceland, Tonga */
#define AMDGPU_FAMILY_CZ			135 /* Carrizo */

#endif
@


1.1.1.1
log
@Import libdrm 2.4.64
@
text
@@


1.1.1.2
log
@Import libdrm 2.4.71
@
text
@a36 4
#if defined(__cplusplus)
extern "C" {
#endif

a75 2
/* Flag that the memory should be in VRAM and cleared */
#define AMDGPU_GEM_CREATE_VRAM_CLEARED		(1 << 3)
a485 16
struct drm_amdgpu_query_fw {
	/** AMDGPU_INFO_FW_* */
	uint32_t fw_type;
	/**
	 * Index of the IP if there are more IPs of
	 * the same type.
	 */
	uint32_t ip_instance;
	/**
	 * Index of the engine. Whether this is used depends
	 * on the firmware type. (e.g. MEC, SDMA)
	 */
	uint32_t index;
	uint32_t _pad;
};

d521 15
a535 1
		struct drm_amdgpu_query_fw query_fw;
d643 1
a643 5
#define AMDGPU_FAMILY_CZ			135 /* Carrizo, Stoney */

#if defined(__cplusplus)
}
#endif
@


1.1.1.3
log
@Import libdrm 2.4.79
@
text
@a52 1
#define DRM_AMDGPU_WAIT_FENCES		0x12
a65 1
#define DRM_IOCTL_AMDGPU_WAIT_FENCES	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_WAIT_FENCES, union drm_amdgpu_wait_fences)
a81 4
/* Flag that create shadow bo(GTT) while allocating vram bo */
#define AMDGPU_GEM_CREATE_SHADOW		(1 << 4)
/* Flag that allocating the BO should use linear VRAM */
#define AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS	(1 << 5)
d85 1
a85 1
	__u64 bo_size;
d87 1
a87 1
	__u64 alignment;
d89 1
a89 1
	__u64 domains;
d91 1
a91 1
	__u64 domain_flags;
d96 2
a97 2
	__u32 handle;
	__u32 _pad;
d114 1
a114 1
	__u32 operation;
d116 1
a116 1
	__u32 list_handle;
d118 1
a118 1
	__u32 bo_number;
d120 1
a120 1
	__u32 bo_info_size;
d122 1
a122 1
	__u64 bo_info_ptr;
d127 1
a127 1
	__u32 bo_handle;
d129 1
a129 1
	__u32 bo_priority;
d134 2
a135 2
	__u32 list_handle;
	__u32 _pad;
d159 1
a159 1
	__u32	op;
d161 3
a163 3
	__u32	flags;
	__u32	ctx_id;
	__u32	_pad;
d168 2
a169 2
			__u32	ctx_id;
			__u32	_pad;
d174 1
a174 1
			__u64	flags;
d176 1
a176 1
			__u32	hangs;
d178 1
a178 1
			__u32	reset_status;
d198 2
a199 2
	__u64		addr;
	__u64		size;
d201 1
a201 1
	__u32		flags;
d203 1
a203 1
	__u32		handle;
a205 1
/* SI-CI-VI: */
a223 5
/* GFX9 and later: */
#define AMDGPU_TILING_SWIZZLE_MODE_SHIFT		0
#define AMDGPU_TILING_SWIZZLE_MODE_MASK			0x1f

/* Set/Get helpers for tiling flags. */
d225 1
a225 1
	(((__u64)(value) & AMDGPU_TILING_##field##_MASK) << AMDGPU_TILING_##field##_SHIFT)
d227 1
a227 1
	(((__u64)(value) >> AMDGPU_TILING_##field##_SHIFT) & AMDGPU_TILING_##field##_MASK)
d235 1
a235 1
	__u32	handle;
d237 1
a237 1
	__u32	op;
d240 1
a240 1
		__u64	flags;
d242 3
a244 3
		__u64	tiling_info;
		__u32	data_size_bytes;
		__u32	data[64];
d250 2
a251 2
	__u32 handle;
	__u32 _pad;
d256 1
a256 1
	__u64 addr_ptr;
d266 1
a266 1
	__u32 handle;
d268 1
a268 1
	__u32 flags;
d270 1
a270 1
	__u64 timeout;
d275 1
a275 1
	__u32 status;
d277 1
a277 1
	__u32 domain;
d287 1
a287 1
	__u64 handle;
d289 5
a293 5
	__u64 timeout;
	__u32 ip_type;
	__u32 ip_instance;
	__u32 ring;
	__u32 ctx_id;
d298 1
a298 1
	__u64 status;
a305 26
struct drm_amdgpu_fence {
	__u32 ctx_id;
	__u32 ip_type;
	__u32 ip_instance;
	__u32 ring;
	__u64 seq_no;
};

struct drm_amdgpu_wait_fences_in {
	/** This points to uint64_t * which points to fences */
	__u64 fences;
	__u32 fence_count;
	__u32 wait_all;
	__u64 timeout_ns;
};

struct drm_amdgpu_wait_fences_out {
	__u32 status;
	__u32 first_signaled;
};

union drm_amdgpu_wait_fences {
	struct drm_amdgpu_wait_fences_in in;
	struct drm_amdgpu_wait_fences_out out;
};

d312 1
a312 1
	__u32	handle;
d314 1
a314 1
	__u32	op;
d316 1
a316 1
	__u64	value;
a320 2
#define AMDGPU_VA_OP_CLEAR			3
#define AMDGPU_VA_OP_REPLACE			4
a331 14
/* partially resident texture */
#define AMDGPU_VM_PAGE_PRT		(1 << 4)
/* MTYPE flags use bit 5 to 8 */
#define AMDGPU_VM_MTYPE_MASK		(0xf << 5)
/* Default MTYPE. Pre-AI must use this.  Recommended for newer ASICs. */
#define AMDGPU_VM_MTYPE_DEFAULT		(0 << 5)
/* Use NC MTYPE instead of default MTYPE */
#define AMDGPU_VM_MTYPE_NC		(1 << 5)
/* Use WC MTYPE instead of default MTYPE */
#define AMDGPU_VM_MTYPE_WC		(2 << 5)
/* Use CC MTYPE instead of default MTYPE */
#define AMDGPU_VM_MTYPE_CC		(3 << 5)
/* Use UC MTYPE instead of default MTYPE */
#define AMDGPU_VM_MTYPE_UC		(4 << 5)
d335 2
a336 2
	__u32 handle;
	__u32 _pad;
d338 1
a338 1
	__u32 operation;
d340 1
a340 1
	__u32 flags;
d342 1
a342 1
	__u64 va_address;
d344 1
a344 1
	__u64 offset_in_bo;
d346 1
a346 1
	__u64 map_size;
d354 1
a354 2
#define AMDGPU_HW_IP_UVD_ENC      5
#define AMDGPU_HW_IP_NUM          6
d363 3
a365 3
	__u32		chunk_id;
	__u32		length_dw;
	__u64		chunk_data;
d370 1
a370 1
	__u32		ctx_id;
d372 5
a376 5
	__u32		bo_list_handle;
	__u32		num_chunks;
	__u32		_pad;
	/** this points to __u64 * which point to cs chunks */
	__u64		chunks;
d380 1
a380 1
	__u64 handle;
d393 1
a393 1
/* Preamble flag, which means the IB could be dropped if no context switch */
a395 3
/* Preempt flag, IB should set Pre_enb bit if PREEMPT flag detected */
#define AMDGPU_IB_FLAG_PREEMPT (1<<2)

d397 1
a397 1
	__u32 _pad;
d399 1
a399 1
	__u32 flags;
d401 1
a401 1
	__u64 va_start;
d403 1
a403 1
	__u32 ib_bytes;
d405 1
a405 1
	__u32 ip_type;
d407 1
a407 1
	__u32 ip_instance;
d409 1
a409 1
	__u32 ring;
d413 5
a417 5
	__u32 ip_type;
	__u32 ip_instance;
	__u32 ring;
	__u32 ctx_id;
	__u64 handle;
d421 2
a422 2
	__u32 handle;
	__u32 offset;
a436 1
#define AMDGPU_IDS_FLAGS_PREEMPTION     0x2
a469 4
	/* Subquery id: Query PSP SOS firmware version */
	#define AMDGPU_INFO_FW_SOS		0x0c
	/* Subquery id: Query PSP ASD firmware version */
	#define AMDGPU_INFO_FW_ASD		0x0d
a485 30
/* number of TTM buffer evictions */
#define AMDGPU_INFO_NUM_EVICTIONS		0x18
/* Query memory about VRAM and GTT domains */
#define AMDGPU_INFO_MEMORY			0x19
/* Query vce clock table */
#define AMDGPU_INFO_VCE_CLOCK_TABLE		0x1A
/* Query vbios related information */
#define AMDGPU_INFO_VBIOS			0x1B
	/* Subquery id: Query vbios size */
	#define AMDGPU_INFO_VBIOS_SIZE		0x1
	/* Subquery id: Query vbios image */
	#define AMDGPU_INFO_VBIOS_IMAGE		0x2
/* Query UVD handles */
#define AMDGPU_INFO_NUM_HANDLES			0x1C
/* Query sensor related information */
#define AMDGPU_INFO_SENSOR			0x1D
	/* Subquery id: Query GPU shader clock */
	#define AMDGPU_INFO_SENSOR_GFX_SCLK		0x1
	/* Subquery id: Query GPU memory clock */
	#define AMDGPU_INFO_SENSOR_GFX_MCLK		0x2
	/* Subquery id: Query GPU temperature */
	#define AMDGPU_INFO_SENSOR_GPU_TEMP		0x3
	/* Subquery id: Query GPU load */
	#define AMDGPU_INFO_SENSOR_GPU_LOAD		0x4
	/* Subquery id: Query average GPU power	*/
	#define AMDGPU_INFO_SENSOR_GPU_AVG_POWER	0x5
	/* Subquery id: Query northbridge voltage */
	#define AMDGPU_INFO_SENSOR_VDDNB		0x6
	/* Subquery id: Query graphics voltage */
	#define AMDGPU_INFO_SENSOR_VDDGFX		0x7
d494 1
a494 1
	__u32 fw_type;
d499 1
a499 1
	__u32 ip_instance;
d504 2
a505 2
	__u32 index;
	__u32 _pad;
d511 1
a511 1
	__u64 return_pointer;
d514 1
a514 1
	__u32 return_size;
d516 1
a516 1
	__u32 query;
d520 2
a521 2
			__u32 id;
			__u32 _pad;
d526 1
a526 1
			__u32 type;
d531 1
a531 1
			__u32 ip_instance;
d535 1
a535 1
			__u32 dword_offset;
d537 2
a538 2
			__u32 count;
			__u32 instance;
d540 1
a540 1
			__u32 flags;
a543 9

		struct {
			__u32 type;
			__u32 offset;
		} vbios_info;

		struct {
			__u32 type;
		} sensor_info;
d549 1
a549 1
	__u32 gds_gfx_partition_size;
d551 1
a551 1
	__u32 compute_partition_size;
d553 1
a553 1
	__u32 gds_total_size;
d555 1
a555 1
	__u32 gws_per_gfx_partition;
d557 1
a557 1
	__u32 gws_per_compute_partition;
d559 1
a559 1
	__u32 oa_per_gfx_partition;
d561 2
a562 2
	__u32 oa_per_compute_partition;
	__u32 _pad;
d566 3
a568 31
	__u64 vram_size;
	__u64 vram_cpu_accessible_size;
	__u64 gtt_size;
};

struct drm_amdgpu_heap_info {
	/** max. physical memory */
	__u64 total_heap_size;

	/** Theoretical max. available memory in the given heap */
	__u64 usable_heap_size;

	/**
	 * Number of bytes allocated in the heap. This includes all processes
	 * and private allocations in the kernel. It changes when new buffers
	 * are allocated, freed, and moved. It cannot be larger than
	 * heap_size.
	 */
	__u64 heap_usage;

	/**
	 * Theoretical possible max. size of buffer which
	 * could be allocated in the given heap
	 */
	__u64 max_allocation;
};

struct drm_amdgpu_memory_info {
	struct drm_amdgpu_heap_info vram;
	struct drm_amdgpu_heap_info cpu_accessible_vram;
	struct drm_amdgpu_heap_info gtt;
d572 2
a573 2
	__u32 ver;
	__u32 feature;
d587 1
a587 1
	__u32 device_id;
d589 2
a590 2
	__u32 chip_rev;
	__u32 external_rev;
d592 4
a595 4
	__u32 pci_rev;
	__u32 family;
	__u32 num_shader_engines;
	__u32 num_shader_arrays_per_engine;
d597 3
a599 3
	__u32 gpu_counter_freq;
	__u64 max_engine_clock;
	__u64 max_memory_clock;
d601 3
a603 3
	__u32 cu_active_number;
	__u32 cu_ao_mask;
	__u32 cu_bitmap[4][4];
d605 5
a609 5
	__u32 enabled_rb_pipes_mask;
	__u32 num_rb_pipes;
	__u32 num_hw_gfx_contexts;
	__u32 _pad;
	__u64 ids_flags;
d611 1
a611 1
	__u64 virtual_address_offset;
d613 1
a613 1
	__u64 virtual_address_max;
d615 1
a615 1
	__u32 virtual_address_alignment;
d617 2
a618 2
	__u32 pte_fragment_size;
	__u32 gart_page_size;
d620 1
a620 1
	__u32 ce_ram_size;
d622 1
a622 1
	__u32 vram_type;
d624 1
a624 1
	__u32 vram_bit_width;
d626 1
a626 11
	__u32 vce_harvest_config;
	/* gfx double offchip LDS buffers */
	__u32 gc_double_offchip_lds_buf;
	/* NGG Primitive Buffer */
	__u64 prim_buf_gpu_addr;
	/* NGG Position Buffer */
	__u64 pos_buf_gpu_addr;
	/* NGG Control Sideband */
	__u64 cntl_sb_buf_gpu_addr;
	/* NGG Parameter Cache */
	__u64 param_buf_gpu_addr;
d631 2
a632 2
	__u32  hw_ip_version_major;
	__u32  hw_ip_version_minor;
d634 1
a634 1
	__u64  capabilities_flags;
d636 1
a636 1
	__u32  ib_start_alignment;
d638 1
a638 1
	__u32  ib_size_alignment;
d640 2
a641 27
	__u32  available_rings;
	__u32  _pad;
};

struct drm_amdgpu_info_num_handles {
	/** Max handles as supported by firmware for UVD */
	__u32  uvd_max_handles;
	/** Handles currently in use for UVD */
	__u32  uvd_used_handles;
};

#define AMDGPU_VCE_CLOCK_TABLE_ENTRIES		6

struct drm_amdgpu_info_vce_clock_table_entry {
	/** System clock */
	__u32 sclk;
	/** Memory clock */
	__u32 mclk;
	/** VCE clock */
	__u32 eclk;
	__u32 pad;
};

struct drm_amdgpu_info_vce_clock_table {
	struct drm_amdgpu_info_vce_clock_table_entry entries[AMDGPU_VCE_CLOCK_TABLE_ENTRIES];
	__u32 num_valid_entries;
	__u32 pad;
a647 1
#define AMDGPU_FAMILY_SI			110 /* Hainan, Oland, Verde, Pitcairn, Tahiti */
a651 1
#define AMDGPU_FAMILY_AI			141 /* Vega10 */
@


