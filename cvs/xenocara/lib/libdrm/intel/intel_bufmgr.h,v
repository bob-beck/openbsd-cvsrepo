head	1.17;
access;
symbols
	libdrm_2_4_79:1.1.1.5
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17
	libdrm_2_4_75:1.1.1.5
	libdrm_2_4_73:1.1.1.4
	libdrm_2_4_71:1.1.1.3
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	libdrm_2_4_67:1.1.1.2
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	libdrm_2_4_65:1.1.1.1
	libdrm_2_4_64:1.1.1.1
	libdrm:1.1.1
	OPENBSD_5_8:1.12.0.2
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.02.05.05.46.41;	author jsg;	state Exp;
branches;
next	1.16;
commitid	7u73SYrl7j8vU8XM;

1.16
date	2016.11.19.05.45.01;	author jsg;	state Exp;
branches;
next	1.15;
commitid	tIcH9u4yWHjj9FVh;

1.15
date	2016.10.16.06.11.11;	author jsg;	state Exp;
branches;
next	1.14;
commitid	nvLf7SydSyxGShbn;

1.14
date	2016.03.20.10.41.29;	author jsg;	state Exp;
branches;
next	1.13;
commitid	mbp2aNpFrhnQxfR8;

1.13
date	2015.08.22.00.30.35;	author jsg;	state Exp;
branches;
next	1.12;
commitid	qzdJ3g11hqB96r2U;

1.12
date	2015.03.26.06.00.06;	author jsg;	state Exp;
branches;
next	1.11;
commitid	xcCFtgqKNdwnnIdt;

1.11
date	2015.02.07.01.34.35;	author jsg;	state Exp;
branches;
next	1.10;
commitid	ttKh4qveShZNixll;

1.10
date	2014.03.15.05.05.55;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.18.08.29.32;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.08.09.10.05;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.25.02.32.20;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.27.14.37.08;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.01.15.48.20;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.15.15.51.05;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.31.06.31.45;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.19.43.26;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.26.23.14.37;	author oga;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2015.08.21.23.56.05;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	IINH94ZNafdY3NZg;

1.1.1.2
date	2016.03.20.10.19.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	66ApiJCJocBDCoju;

1.1.1.3
date	2016.10.16.06.01.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	UDYjDzwIWWXeKnu7;

1.1.1.4
date	2016.11.19.05.36.56;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	J3nLYkpAOBFQLy9J;

1.1.1.5
date	2017.02.05.05.38.29;	author jsg;	state Exp;
branches;
next	;
commitid	GTUS6FM9u0BarnEJ;


desc
@@


1.17
log
@Merge libdrm 2.4.75
@
text
@/*
 * Copyright © 2008-2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

/**
 * @@file intel_bufmgr.h
 *
 * Public definitions of Intel-specific bufmgr functions.
 */

#ifndef INTEL_BUFMGR_H
#define INTEL_BUFMGR_H

#include <stdio.h>
#include <stdint.h>
#include <stdio.h>

#if defined(__cplusplus)
extern "C" {
#endif

struct drm_clip_rect;

typedef struct _drm_intel_bufmgr drm_intel_bufmgr;
typedef struct _drm_intel_context drm_intel_context;
typedef struct _drm_intel_bo drm_intel_bo;

struct _drm_intel_bo {
	/**
	 * Size in bytes of the buffer object.
	 *
	 * The size may be larger than the size originally requested for the
	 * allocation, such as being aligned to page size.
	 */
	unsigned long size;

	/**
	 * Alignment requirement for object
	 *
	 * Used for GTT mapping & pinning the object.
	 */
	unsigned long align;

	/**
	 * Deprecated field containing (possibly the low 32-bits of) the last
	 * seen virtual card address.  Use offset64 instead.
	 */
	unsigned long offset;

	/**
	 * Virtual address for accessing the buffer data.  Only valid while
	 * mapped.
	 */
#ifdef __cplusplus
	void *virt;
#else
	void *virtual;
#endif

	/** Buffer manager context associated with this buffer object */
	drm_intel_bufmgr *bufmgr;

	/**
	 * MM-specific handle for accessing object
	 */
	int handle;

	/**
	 * Last seen card virtual address (offset from the beginning of the
	 * aperture) for the object.  This should be used to fill relocation
	 * entries when calling drm_intel_bo_emit_reloc()
	 */
	uint64_t offset64;
};

enum aub_dump_bmp_format {
	AUB_DUMP_BMP_FORMAT_8BIT = 1,
	AUB_DUMP_BMP_FORMAT_ARGB_4444 = 4,
	AUB_DUMP_BMP_FORMAT_ARGB_0888 = 6,
	AUB_DUMP_BMP_FORMAT_ARGB_8888 = 7,
};

typedef struct _drm_intel_aub_annotation {
	uint32_t type;
	uint32_t subtype;
	uint32_t ending_offset;
} drm_intel_aub_annotation;

#define BO_ALLOC_FOR_RENDER (1<<0)

drm_intel_bo *drm_intel_bo_alloc(drm_intel_bufmgr *bufmgr, const char *name,
				 unsigned long size, unsigned int alignment);
drm_intel_bo *drm_intel_bo_alloc_for_render(drm_intel_bufmgr *bufmgr,
					    const char *name,
					    unsigned long size,
					    unsigned int alignment);
drm_intel_bo *drm_intel_bo_alloc_userptr(drm_intel_bufmgr *bufmgr,
					const char *name,
					void *addr, uint32_t tiling_mode,
					uint32_t stride, unsigned long size,
					unsigned long flags);
drm_intel_bo *drm_intel_bo_alloc_tiled(drm_intel_bufmgr *bufmgr,
				       const char *name,
				       int x, int y, int cpp,
				       uint32_t *tiling_mode,
				       unsigned long *pitch,
				       unsigned long flags);
void drm_intel_bo_reference(drm_intel_bo *bo);
void drm_intel_bo_unreference(drm_intel_bo *bo);
int drm_intel_bo_map(drm_intel_bo *bo, int write_enable);
int drm_intel_bo_unmap(drm_intel_bo *bo);

int drm_intel_bo_subdata(drm_intel_bo *bo, unsigned long offset,
			 unsigned long size, const void *data);
int drm_intel_bo_get_subdata(drm_intel_bo *bo, unsigned long offset,
			     unsigned long size, void *data);
void drm_intel_bo_wait_rendering(drm_intel_bo *bo);

void drm_intel_bufmgr_set_debug(drm_intel_bufmgr *bufmgr, int enable_debug);
void drm_intel_bufmgr_destroy(drm_intel_bufmgr *bufmgr);
int drm_intel_bo_exec(drm_intel_bo *bo, int used,
		      struct drm_clip_rect *cliprects, int num_cliprects, int DR4);
int drm_intel_bo_mrb_exec(drm_intel_bo *bo, int used,
			struct drm_clip_rect *cliprects, int num_cliprects, int DR4,
			unsigned int flags);
int drm_intel_bufmgr_check_aperture_space(drm_intel_bo ** bo_array, int count);

int drm_intel_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
			    drm_intel_bo *target_bo, uint32_t target_offset,
			    uint32_t read_domains, uint32_t write_domain);
int drm_intel_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
				  drm_intel_bo *target_bo,
				  uint32_t target_offset,
				  uint32_t read_domains, uint32_t write_domain);
int drm_intel_bo_pin(drm_intel_bo *bo, uint32_t alignment);
int drm_intel_bo_unpin(drm_intel_bo *bo);
int drm_intel_bo_set_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
			    uint32_t stride);
int drm_intel_bo_get_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
			    uint32_t * swizzle_mode);
int drm_intel_bo_flink(drm_intel_bo *bo, uint32_t * name);
int drm_intel_bo_busy(drm_intel_bo *bo);
int drm_intel_bo_madvise(drm_intel_bo *bo, int madv);
int drm_intel_bo_use_48b_address_range(drm_intel_bo *bo, uint32_t enable);
int drm_intel_bo_set_softpin_offset(drm_intel_bo *bo, uint64_t offset);

int drm_intel_bo_disable_reuse(drm_intel_bo *bo);
int drm_intel_bo_is_reusable(drm_intel_bo *bo);
int drm_intel_bo_references(drm_intel_bo *bo, drm_intel_bo *target_bo);

/* drm_intel_bufmgr_gem.c */
drm_intel_bufmgr *drm_intel_bufmgr_gem_init(int fd, int batch_size);
drm_intel_bo *drm_intel_bo_gem_create_from_name(drm_intel_bufmgr *bufmgr,
						const char *name,
						unsigned int handle);
void drm_intel_bufmgr_gem_enable_reuse(drm_intel_bufmgr *bufmgr);
void drm_intel_bufmgr_gem_enable_fenced_relocs(drm_intel_bufmgr *bufmgr);
void drm_intel_bufmgr_gem_set_vma_cache_size(drm_intel_bufmgr *bufmgr,
					     int limit);
int drm_intel_gem_bo_map_unsynchronized(drm_intel_bo *bo);
int drm_intel_gem_bo_map_gtt(drm_intel_bo *bo);
int drm_intel_gem_bo_unmap_gtt(drm_intel_bo *bo);

#define HAVE_DRM_INTEL_GEM_BO_DISABLE_IMPLICIT_SYNC 1
int drm_intel_bufmgr_gem_can_disable_implicit_sync(drm_intel_bufmgr *bufmgr);
void drm_intel_gem_bo_disable_implicit_sync(drm_intel_bo *bo);
void drm_intel_gem_bo_enable_implicit_sync(drm_intel_bo *bo);

void *drm_intel_gem_bo_map__cpu(drm_intel_bo *bo);
void *drm_intel_gem_bo_map__gtt(drm_intel_bo *bo);
void *drm_intel_gem_bo_map__wc(drm_intel_bo *bo);

int drm_intel_gem_bo_get_reloc_count(drm_intel_bo *bo);
void drm_intel_gem_bo_clear_relocs(drm_intel_bo *bo, int start);
void drm_intel_gem_bo_start_gtt_access(drm_intel_bo *bo, int write_enable);

void
drm_intel_bufmgr_gem_set_aub_filename(drm_intel_bufmgr *bufmgr,
				      const char *filename);
void drm_intel_bufmgr_gem_set_aub_dump(drm_intel_bufmgr *bufmgr, int enable);
void drm_intel_gem_bo_aub_dump_bmp(drm_intel_bo *bo,
				   int x1, int y1, int width, int height,
				   enum aub_dump_bmp_format format,
				   int pitch, int offset);
void
drm_intel_bufmgr_gem_set_aub_annotations(drm_intel_bo *bo,
					 drm_intel_aub_annotation *annotations,
					 unsigned count);

int drm_intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, int crtc_id);

int drm_intel_get_aperture_sizes(int fd, size_t *mappable, size_t *total);
int drm_intel_bufmgr_gem_get_devid(drm_intel_bufmgr *bufmgr);
int drm_intel_gem_bo_wait(drm_intel_bo *bo, int64_t timeout_ns);

drm_intel_context *drm_intel_gem_context_create(drm_intel_bufmgr *bufmgr);
int drm_intel_gem_context_get_id(drm_intel_context *ctx,
                                 uint32_t *ctx_id);
void drm_intel_gem_context_destroy(drm_intel_context *ctx);
int drm_intel_gem_bo_context_exec(drm_intel_bo *bo, drm_intel_context *ctx,
				  int used, unsigned int flags);
int drm_intel_gem_bo_fence_exec(drm_intel_bo *bo,
				drm_intel_context *ctx,
				int used,
				int in_fence,
				int *out_fence,
				unsigned int flags);

int drm_intel_bo_gem_export_to_prime(drm_intel_bo *bo, int *prime_fd);
drm_intel_bo *drm_intel_bo_gem_create_from_prime(drm_intel_bufmgr *bufmgr,
						int prime_fd, int size);

/* drm_intel_bufmgr_fake.c */
drm_intel_bufmgr *drm_intel_bufmgr_fake_init(int fd,
					     unsigned long low_offset,
					     void *low_virtual,
					     unsigned long size,
					     volatile unsigned int
					     *last_dispatch);
void drm_intel_bufmgr_fake_set_last_dispatch(drm_intel_bufmgr *bufmgr,
					     volatile unsigned int
					     *last_dispatch);
void drm_intel_bufmgr_fake_set_exec_callback(drm_intel_bufmgr *bufmgr,
					     int (*exec) (drm_intel_bo *bo,
							  unsigned int used,
							  void *priv),
					     void *priv);
void drm_intel_bufmgr_fake_set_fence_callback(drm_intel_bufmgr *bufmgr,
					      unsigned int (*emit) (void *priv),
					      void (*wait) (unsigned int fence,
							    void *priv),
					      void *priv);
drm_intel_bo *drm_intel_bo_fake_alloc_static(drm_intel_bufmgr *bufmgr,
					     const char *name,
					     unsigned long offset,
					     unsigned long size, void *virt);
void drm_intel_bo_fake_disable_backing_store(drm_intel_bo *bo,
					     void (*invalidate_cb) (drm_intel_bo
								    * bo,
								    void *ptr),
					     void *ptr);

void drm_intel_bufmgr_fake_contended_lock_take(drm_intel_bufmgr *bufmgr);
void drm_intel_bufmgr_fake_evict_all(drm_intel_bufmgr *bufmgr);

struct drm_intel_decode *drm_intel_decode_context_alloc(uint32_t devid);
void drm_intel_decode_context_free(struct drm_intel_decode *ctx);
void drm_intel_decode_set_batch_pointer(struct drm_intel_decode *ctx,
					void *data, uint32_t hw_offset,
					int count);
void drm_intel_decode_set_dump_past_end(struct drm_intel_decode *ctx,
					int dump_past_end);
void drm_intel_decode_set_head_tail(struct drm_intel_decode *ctx,
				    uint32_t head, uint32_t tail);
void drm_intel_decode_set_output_file(struct drm_intel_decode *ctx, FILE *out);
void drm_intel_decode(struct drm_intel_decode *ctx);

int drm_intel_reg_read(drm_intel_bufmgr *bufmgr,
		       uint32_t offset,
		       uint64_t *result);

int drm_intel_get_reset_stats(drm_intel_context *ctx,
			      uint32_t *reset_count,
			      uint32_t *active,
			      uint32_t *pending);

int drm_intel_get_subslice_total(int fd, unsigned int *subslice_total);
int drm_intel_get_eu_total(int fd, unsigned int *eu_total);

int drm_intel_get_pooled_eu(int fd);
int drm_intel_get_min_eu_in_pool(int fd);

/** @@{ Compatibility defines to keep old code building despite the symbol rename
 * from dri_* to drm_intel_*
 */
#define dri_bo drm_intel_bo
#define dri_bufmgr drm_intel_bufmgr
#define dri_bo_alloc drm_intel_bo_alloc
#define dri_bo_reference drm_intel_bo_reference
#define dri_bo_unreference drm_intel_bo_unreference
#define dri_bo_map drm_intel_bo_map
#define dri_bo_unmap drm_intel_bo_unmap
#define dri_bo_subdata drm_intel_bo_subdata
#define dri_bo_get_subdata drm_intel_bo_get_subdata
#define dri_bo_wait_rendering drm_intel_bo_wait_rendering
#define dri_bufmgr_set_debug drm_intel_bufmgr_set_debug
#define dri_bufmgr_destroy drm_intel_bufmgr_destroy
#define dri_bo_exec drm_intel_bo_exec
#define dri_bufmgr_check_aperture_space drm_intel_bufmgr_check_aperture_space
#define dri_bo_emit_reloc(reloc_bo, read, write, target_offset,		\
			  reloc_offset, target_bo)			\
	drm_intel_bo_emit_reloc(reloc_bo, reloc_offset,			\
				target_bo, target_offset,		\
				read, write);
#define dri_bo_pin drm_intel_bo_pin
#define dri_bo_unpin drm_intel_bo_unpin
#define dri_bo_get_tiling drm_intel_bo_get_tiling
#define dri_bo_set_tiling(bo, mode) drm_intel_bo_set_tiling(bo, mode, 0)
#define dri_bo_flink drm_intel_bo_flink
#define intel_bufmgr_gem_init drm_intel_bufmgr_gem_init
#define intel_bo_gem_create_from_name drm_intel_bo_gem_create_from_name
#define intel_bufmgr_gem_enable_reuse drm_intel_bufmgr_gem_enable_reuse
#define intel_bufmgr_fake_init drm_intel_bufmgr_fake_init
#define intel_bufmgr_fake_set_last_dispatch drm_intel_bufmgr_fake_set_last_dispatch
#define intel_bufmgr_fake_set_exec_callback drm_intel_bufmgr_fake_set_exec_callback
#define intel_bufmgr_fake_set_fence_callback drm_intel_bufmgr_fake_set_fence_callback
#define intel_bo_fake_alloc_static drm_intel_bo_fake_alloc_static
#define intel_bo_fake_disable_backing_store drm_intel_bo_fake_disable_backing_store
#define intel_bufmgr_fake_contended_lock_take drm_intel_bufmgr_fake_contended_lock_take
#define intel_bufmgr_fake_evict_all drm_intel_bufmgr_fake_evict_all

/** @@{ */

#if defined(__cplusplus)
}
#endif

#endif /* INTEL_BUFMGR_H */
@


1.16
log
@Merge libdrm 2.4.73
@
text
@d187 5
d220 2
d225 6
@


1.15
log
@Merge libdrm 2.4.71
@
text
@d187 4
@


1.14
log
@Merge libdrm 2.4.67
@
text
@d276 3
@


1.13
log
@Merge libdrm 2.4.64.  This changes the build to using the upstream
auto* build system and installing/using a libdrm specific set of drm
headers.  Thanks to Emil Velikov for removing the GNU makeisms
upstream.
@
text
@d167 2
@


1.12
log
@update to libdrm 2.4.60
@
text
@d41 4
d314 4
@


1.11
log
@update to libdrm 2.4.59
@
text
@d267 3
@


1.10
log
@update to libdrm 2.4.52
ok matthieu@@
@
text
@d116 5
@


1.9
log
@Update libdrm to 2.4.51.

ok mpi@@ kettenis@@
@
text
@d64 2
a65 3
	 * Last seen card virtual address (offset from the beginning of the
	 * aperture) for the object.  This should be used to fill relocation
	 * entries when calling drm_intel_bo_emit_reloc()
d86 7
@


1.8
log
@update to libdrm 2.4.46
ok mpi@@ kettenis@@
@
text
@d251 5
@


1.7
log
@update to libdrm 2.4.42

tested by matthieu@@ krw@@ mpi@@ shadchin@@ and ajacoutot@@
ok mpi@@
@
text
@d174 3
@


1.6
log
@Update to libdrm 2.4.31 and add the non-yet-linked libkms, prodded by jsg@@

Tested by jsg@@, ajacoutot@@, shadchin@@ and matthieu@@, ok matthieu@@
@
text
@d2 1
a2 1
 * Copyright © 2008 Intel Corporation
d39 1
d44 1
d89 13
d166 1
d169 1
d174 10
d187 11
d244 3
@


1.5
log
@Update libdrm_intel to that contained in libdrm 2.4.24. Needed for
updates to the ddx and to stop mesa 7.9.2 crashing very fast.

ok matthieu@@
@
text
@d37 1
d149 2
d153 2
d159 2
d193 13
@


1.4
log
@Add drm_intel_bo_is_reusable(), to check if a buffer object will be put
in the userland BO cache or not. Bump minor.

From Chris Wilson in upstream git. ok matthieu@@
@
text
@d39 2
d71 3
d75 1
d114 4
a117 1
		      drm_clip_rect_t * cliprects, int num_cliprects, int DR4);
d177 1
a177 1
					     unsigned long size, void *virtual);
@


1.3
log
@update libdrm to 2.4.15.

This diff seems larger than it is since upstream reindented some
sources.  This updates libdrm_intel to -current (which only affect the
GEM code) and libdrm to 2.4.15.  bumping both minor versions.

Discussed with matthieu@@
@
text
@d129 1
@


1.2
log
@update libdrm to 2.4.9 (actually to -current, but the only real changes
are to some assertions and a small change to modesetting code).

bump libdrm_intel minor due to added symbols, libdrm doesn't get bumped,
no change to symbol list.

ok matthieu@@.
@
text
@d43 35
a77 31
    /**
     * Size in bytes of the buffer object.
     *
     * The size may be larger than the size originally requested for the
     * allocation, such as being aligned to page size.
     */
    unsigned long size;
    /**
     * Alignment requirement for object
     *
     * Used for GTT mapping & pinning the object.
     */
    unsigned long align;

    /**
     * Card virtual address (offset from the beginning of the aperture) for the
     * object.  Only valid while validated.
     */
    unsigned long offset;
    /**
     * Virtual address for accessing the buffer data.  Only valid while mapped.
     */
    void *virtual;

    /** Buffer manager context associated with this buffer object */
    drm_intel_bufmgr *bufmgr;

    /**
     * MM-specific handle for accessing object
     */
    int handle;
d80 2
d88 6
d100 1
a100 1
		     unsigned long size, const void *data);
d102 1
a102 1
			 unsigned long size, void *data);
d108 2
a109 3
		      drm_clip_rect_t *cliprects, int num_cliprects,
		      int DR4);
int drm_intel_bufmgr_check_aperture_space(drm_intel_bo **bo_array, int count);
d114 4
d120 1
a120 1
int drm_intel_bo_set_tiling(drm_intel_bo *bo, uint32_t *tiling_mode,
d122 8
a129 3
int drm_intel_bo_get_tiling(drm_intel_bo *bo, uint32_t *tiling_mode,
			uint32_t *swizzle_mode);
int drm_intel_bo_flink(drm_intel_bo *bo, uint32_t *name);
d137 1
d142 2
d149 2
a150 1
					     volatile unsigned int *last_dispatch);
d152 2
a153 1
					     volatile unsigned int *last_dispatch);
d155 3
a157 3
					     int (*exec)(drm_intel_bo *bo,
							 unsigned int used,
							 void *priv),
d160 3
a162 3
					      unsigned int (*emit)(void *priv),
					      void (*wait)(unsigned int fence,
							   void *priv),
d166 2
a167 2
					     unsigned long offset, unsigned long size,
					     void *virtual);
d169 3
a171 2
					     void (*invalidate_cb)(drm_intel_bo *bo,
								   void *ptr),
d197 2
a198 2
			    target_bo, target_offset,			\
			    read, write);
a218 1

@


1.1
log
@Update libdrm to 2.4.3

This is needed for us to be able to update Mesa and xf86-video-intel.
Includes a few fixes, as well as the intel bufmgr interface and the
modesetting interface (which currently errors when you check if it's
enabled).

ok matthieu@@
@
text
@d78 4
d118 1
@


1.1.1.1
log
@Import libdrm 2.4.64
@
text
@d2 1
a2 1
 * Copyright © 2008-2012 Intel Corporation
a36 1
#include <stdio.h>
a37 7
#include <stdio.h>

#if defined(__cplusplus)
extern "C" {
#endif

struct drm_clip_rect;
a39 1
typedef struct _drm_intel_context drm_intel_context;
d43 31
a73 52
	/**
	 * Size in bytes of the buffer object.
	 *
	 * The size may be larger than the size originally requested for the
	 * allocation, such as being aligned to page size.
	 */
	unsigned long size;

	/**
	 * Alignment requirement for object
	 *
	 * Used for GTT mapping & pinning the object.
	 */
	unsigned long align;

	/**
	 * Deprecated field containing (possibly the low 32-bits of) the last
	 * seen virtual card address.  Use offset64 instead.
	 */
	unsigned long offset;

	/**
	 * Virtual address for accessing the buffer data.  Only valid while
	 * mapped.
	 */
#ifdef __cplusplus
	void *virt;
#else
	void *virtual;
#endif

	/** Buffer manager context associated with this buffer object */
	drm_intel_bufmgr *bufmgr;

	/**
	 * MM-specific handle for accessing object
	 */
	int handle;

	/**
	 * Last seen card virtual address (offset from the beginning of the
	 * aperture) for the object.  This should be used to fill relocation
	 * entries when calling drm_intel_bo_emit_reloc()
	 */
	uint64_t offset64;
};

enum aub_dump_bmp_format {
	AUB_DUMP_BMP_FORMAT_8BIT = 1,
	AUB_DUMP_BMP_FORMAT_ARGB_4444 = 4,
	AUB_DUMP_BMP_FORMAT_ARGB_0888 = 6,
	AUB_DUMP_BMP_FORMAT_ARGB_8888 = 7,
a75 8
typedef struct _drm_intel_aub_annotation {
	uint32_t type;
	uint32_t subtype;
	uint32_t ending_offset;
} drm_intel_aub_annotation;

#define BO_ALLOC_FOR_RENDER (1<<0)

a77 15
drm_intel_bo *drm_intel_bo_alloc_for_render(drm_intel_bufmgr *bufmgr,
					    const char *name,
					    unsigned long size,
					    unsigned int alignment);
drm_intel_bo *drm_intel_bo_alloc_userptr(drm_intel_bufmgr *bufmgr,
					const char *name,
					void *addr, uint32_t tiling_mode,
					uint32_t stride, unsigned long size,
					unsigned long flags);
drm_intel_bo *drm_intel_bo_alloc_tiled(drm_intel_bufmgr *bufmgr,
				       const char *name,
				       int x, int y, int cpp,
				       uint32_t *tiling_mode,
				       unsigned long *pitch,
				       unsigned long flags);
d84 1
a84 1
			 unsigned long size, const void *data);
d86 1
a86 1
			     unsigned long size, void *data);
d92 3
a94 5
		      struct drm_clip_rect *cliprects, int num_cliprects, int DR4);
int drm_intel_bo_mrb_exec(drm_intel_bo *bo, int used,
			struct drm_clip_rect *cliprects, int num_cliprects, int DR4,
			unsigned int flags);
int drm_intel_bufmgr_check_aperture_space(drm_intel_bo ** bo_array, int count);
a98 4
int drm_intel_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
				  drm_intel_bo *target_bo,
				  uint32_t target_offset,
				  uint32_t read_domains, uint32_t write_domain);
d101 1
a101 1
int drm_intel_bo_set_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
d103 3
a105 9
int drm_intel_bo_get_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
			    uint32_t * swizzle_mode);
int drm_intel_bo_flink(drm_intel_bo *bo, uint32_t * name);
int drm_intel_bo_busy(drm_intel_bo *bo);
int drm_intel_bo_madvise(drm_intel_bo *bo, int madv);

int drm_intel_bo_disable_reuse(drm_intel_bo *bo);
int drm_intel_bo_is_reusable(drm_intel_bo *bo);
int drm_intel_bo_references(drm_intel_bo *bo, drm_intel_bo *target_bo);
a112 4
void drm_intel_bufmgr_gem_enable_fenced_relocs(drm_intel_bufmgr *bufmgr);
void drm_intel_bufmgr_gem_set_vma_cache_size(drm_intel_bufmgr *bufmgr,
					     int limit);
int drm_intel_gem_bo_map_unsynchronized(drm_intel_bo *bo);
a113 4
int drm_intel_gem_bo_unmap_gtt(drm_intel_bo *bo);

int drm_intel_gem_bo_get_reloc_count(drm_intel_bo *bo);
void drm_intel_gem_bo_clear_relocs(drm_intel_bo *bo, int start);
a115 28
void
drm_intel_bufmgr_gem_set_aub_filename(drm_intel_bufmgr *bufmgr,
				      const char *filename);
void drm_intel_bufmgr_gem_set_aub_dump(drm_intel_bufmgr *bufmgr, int enable);
void drm_intel_gem_bo_aub_dump_bmp(drm_intel_bo *bo,
				   int x1, int y1, int width, int height,
				   enum aub_dump_bmp_format format,
				   int pitch, int offset);
void
drm_intel_bufmgr_gem_set_aub_annotations(drm_intel_bo *bo,
					 drm_intel_aub_annotation *annotations,
					 unsigned count);

int drm_intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, int crtc_id);

int drm_intel_get_aperture_sizes(int fd, size_t *mappable, size_t *total);
int drm_intel_bufmgr_gem_get_devid(drm_intel_bufmgr *bufmgr);
int drm_intel_gem_bo_wait(drm_intel_bo *bo, int64_t timeout_ns);

drm_intel_context *drm_intel_gem_context_create(drm_intel_bufmgr *bufmgr);
void drm_intel_gem_context_destroy(drm_intel_context *ctx);
int drm_intel_gem_bo_context_exec(drm_intel_bo *bo, drm_intel_context *ctx,
				  int used, unsigned int flags);

int drm_intel_bo_gem_export_to_prime(drm_intel_bo *bo, int *prime_fd);
drm_intel_bo *drm_intel_bo_gem_create_from_prime(drm_intel_bufmgr *bufmgr,
						int prime_fd, int size);

d121 1
a121 2
					     volatile unsigned int
					     *last_dispatch);
d123 1
a123 2
					     volatile unsigned int
					     *last_dispatch);
d125 3
a127 3
					     int (*exec) (drm_intel_bo *bo,
							  unsigned int used,
							  void *priv),
d130 3
a132 3
					      unsigned int (*emit) (void *priv),
					      void (*wait) (unsigned int fence,
							    void *priv),
d136 2
a137 2
					     unsigned long offset,
					     unsigned long size, void *virt);
d139 2
a140 3
					     void (*invalidate_cb) (drm_intel_bo
								    * bo,
								    void *ptr),
a145 24
struct drm_intel_decode *drm_intel_decode_context_alloc(uint32_t devid);
void drm_intel_decode_context_free(struct drm_intel_decode *ctx);
void drm_intel_decode_set_batch_pointer(struct drm_intel_decode *ctx,
					void *data, uint32_t hw_offset,
					int count);
void drm_intel_decode_set_dump_past_end(struct drm_intel_decode *ctx,
					int dump_past_end);
void drm_intel_decode_set_head_tail(struct drm_intel_decode *ctx,
				    uint32_t head, uint32_t tail);
void drm_intel_decode_set_output_file(struct drm_intel_decode *ctx, FILE *out);
void drm_intel_decode(struct drm_intel_decode *ctx);

int drm_intel_reg_read(drm_intel_bufmgr *bufmgr,
		       uint32_t offset,
		       uint64_t *result);

int drm_intel_get_reset_stats(drm_intel_context *ctx,
			      uint32_t *reset_count,
			      uint32_t *active,
			      uint32_t *pending);

int drm_intel_get_subslice_total(int fd, unsigned int *subslice_total);
int drm_intel_get_eu_total(int fd, unsigned int *eu_total);

d166 2
a167 2
				target_bo, target_offset,		\
				read, write);
d187 1
a187 3
#if defined(__cplusplus)
}
#endif
a188 1
#endif /* INTEL_BUFMGR_H */
@


1.1.1.2
log
@Import libdrm 2.4.67
@
text
@a166 2
int drm_intel_bo_use_48b_address_range(drm_intel_bo *bo, uint32_t enable);
int drm_intel_bo_set_softpin_offset(drm_intel_bo *bo, uint64_t offset);
@


1.1.1.3
log
@Import libdrm 2.4.71
@
text
@a275 3
int drm_intel_get_pooled_eu(int fd);
int drm_intel_get_min_eu_in_pool(int fd);

@


1.1.1.4
log
@Import libdrm 2.4.73
@
text
@a186 4
void *drm_intel_gem_bo_map__cpu(drm_intel_bo *bo);
void *drm_intel_gem_bo_map__gtt(drm_intel_bo *bo);
void *drm_intel_gem_bo_map__wc(drm_intel_bo *bo);

@


1.1.1.5
log
@Import libdrm 2.4.75
@
text
@a186 5
#define HAVE_DRM_INTEL_GEM_BO_DISABLE_IMPLICIT_SYNC 1
int drm_intel_bufmgr_gem_can_disable_implicit_sync(drm_intel_bufmgr *bufmgr);
void drm_intel_gem_bo_disable_implicit_sync(drm_intel_bo *bo);
void drm_intel_gem_bo_enable_implicit_sync(drm_intel_bo *bo);

a214 2
int drm_intel_gem_context_get_id(drm_intel_context *ctx,
                                 uint32_t *ctx_id);
a217 6
int drm_intel_gem_bo_fence_exec(drm_intel_bo *bo,
				drm_intel_context *ctx,
				int used,
				int in_fence,
				int *out_fence,
				unsigned int flags);
@


