head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	mesa-13_0_6:1.1.1.4
	mesa-13_0_5:1.1.1.4
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.3
date	2017.08.26.16.59.37;	author jsg;	state Exp;
branches;
next	1.2;
commitid	D0k2io1oY8gcsQ2S;

1.2
date	2017.08.14.09.58.01;	author jsg;	state dead;
branches;
next	1.1;
commitid	bC4bLqwWTo4kLw82;

1.1
date	2015.11.22.02.40.12;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.12;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.15.31;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.36.55;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.02.26.12.17.26;	author jsg;	state Exp;
branches;
next	;
commitid	xZcdklZavddTKAf1;


desc
@@


1.3
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/* Copyright © 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "brw_vec4.h"
#include "brw_cfg.h"
#include "brw_eu.h"
#include "brw_program.h"

using namespace brw;

static void
generate_math1_gen4(struct brw_codegen *p,
                    vec4_instruction *inst,
                    struct brw_reg dst,
                    struct brw_reg src)
{
   gen4_math(p,
	     dst,
	     brw_math_function(inst->opcode),
	     inst->base_mrf,
	     src,
	     BRW_MATH_PRECISION_FULL);
}

static void
check_gen6_math_src_arg(struct brw_reg src)
{
   /* Source swizzles are ignored. */
   assert(!src.abs);
   assert(!src.negate);
   assert(src.swizzle == BRW_SWIZZLE_XYZW);
}

static void
generate_math_gen6(struct brw_codegen *p,
                   vec4_instruction *inst,
                   struct brw_reg dst,
                   struct brw_reg src0,
                   struct brw_reg src1)
{
   /* Can't do writemask because math can't be align16. */
   assert(dst.writemask == WRITEMASK_XYZW);
   /* Source swizzles are ignored. */
   check_gen6_math_src_arg(src0);
   if (src1.file == BRW_GENERAL_REGISTER_FILE)
      check_gen6_math_src_arg(src1);

   brw_set_default_access_mode(p, BRW_ALIGN_1);
   gen6_math(p, dst, brw_math_function(inst->opcode), src0, src1);
   brw_set_default_access_mode(p, BRW_ALIGN_16);
}

static void
generate_math2_gen4(struct brw_codegen *p,
                    vec4_instruction *inst,
                    struct brw_reg dst,
                    struct brw_reg src0,
                    struct brw_reg src1)
{
   /* From the Ironlake PRM, Volume 4, Part 1, Section 6.1.13
    * "Message Payload":
    *
    * "Operand0[7].  For the INT DIV functions, this operand is the
    *  denominator."
    *  ...
    * "Operand1[7].  For the INT DIV functions, this operand is the
    *  numerator."
    */
   bool is_int_div = inst->opcode != SHADER_OPCODE_POW;
   struct brw_reg &op0 = is_int_div ? src1 : src0;
   struct brw_reg &op1 = is_int_div ? src0 : src1;

   brw_push_insn_state(p);
   brw_set_default_saturate(p, false);
   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
   brw_MOV(p, retype(brw_message_reg(inst->base_mrf + 1), op1.type), op1);
   brw_pop_insn_state(p);

   gen4_math(p,
	     dst,
	     brw_math_function(inst->opcode),
	     inst->base_mrf,
	     op0,
	     BRW_MATH_PRECISION_FULL);
}

static void
generate_tex(struct brw_codegen *p,
             struct brw_vue_prog_data *prog_data,
             gl_shader_stage stage,
             vec4_instruction *inst,
             struct brw_reg dst,
             struct brw_reg src,
             struct brw_reg surface_index,
             struct brw_reg sampler_index)
{
   const struct gen_device_info *devinfo = p->devinfo;
   int msg_type = -1;

   if (devinfo->gen >= 5) {
      switch (inst->opcode) {
      case SHADER_OPCODE_TEX:
      case SHADER_OPCODE_TXL:
	 if (inst->shadow_compare) {
	    msg_type = GEN5_SAMPLER_MESSAGE_SAMPLE_LOD_COMPARE;
	 } else {
	    msg_type = GEN5_SAMPLER_MESSAGE_SAMPLE_LOD;
	 }
	 break;
      case SHADER_OPCODE_TXD:
         if (inst->shadow_compare) {
            /* Gen7.5+.  Otherwise, lowered by brw_lower_texture_gradients(). */
            assert(devinfo->gen >= 8 || devinfo->is_haswell);
            msg_type = HSW_SAMPLER_MESSAGE_SAMPLE_DERIV_COMPARE;
         } else {
            msg_type = GEN5_SAMPLER_MESSAGE_SAMPLE_DERIVS;
         }
	 break;
      case SHADER_OPCODE_TXF:
	 msg_type = GEN5_SAMPLER_MESSAGE_SAMPLE_LD;
	 break;
      case SHADER_OPCODE_TXF_CMS_W:
         assert(devinfo->gen >= 9);
         msg_type = GEN9_SAMPLER_MESSAGE_SAMPLE_LD2DMS_W;
         break;
      case SHADER_OPCODE_TXF_CMS:
         if (devinfo->gen >= 7)
            msg_type = GEN7_SAMPLER_MESSAGE_SAMPLE_LD2DMS;
         else
            msg_type = GEN5_SAMPLER_MESSAGE_SAMPLE_LD;
         break;
      case SHADER_OPCODE_TXF_MCS:
         assert(devinfo->gen >= 7);
         msg_type = GEN7_SAMPLER_MESSAGE_SAMPLE_LD_MCS;
         break;
      case SHADER_OPCODE_TXS:
	 msg_type = GEN5_SAMPLER_MESSAGE_SAMPLE_RESINFO;
	 break;
      case SHADER_OPCODE_TG4:
         if (inst->shadow_compare) {
            msg_type = GEN7_SAMPLER_MESSAGE_SAMPLE_GATHER4_C;
         } else {
            msg_type = GEN7_SAMPLER_MESSAGE_SAMPLE_GATHER4;
         }
         break;
      case SHADER_OPCODE_TG4_OFFSET:
         if (inst->shadow_compare) {
            msg_type = GEN7_SAMPLER_MESSAGE_SAMPLE_GATHER4_PO_C;
         } else {
            msg_type = GEN7_SAMPLER_MESSAGE_SAMPLE_GATHER4_PO;
         }
         break;
      case SHADER_OPCODE_SAMPLEINFO:
         msg_type = GEN6_SAMPLER_MESSAGE_SAMPLE_SAMPLEINFO;
         break;
      default:
	 unreachable("should not get here: invalid vec4 texture opcode");
      }
   } else {
      switch (inst->opcode) {
      case SHADER_OPCODE_TEX:
      case SHADER_OPCODE_TXL:
	 if (inst->shadow_compare) {
	    msg_type = BRW_SAMPLER_MESSAGE_SIMD4X2_SAMPLE_LOD_COMPARE;
	    assert(inst->mlen == 3);
	 } else {
	    msg_type = BRW_SAMPLER_MESSAGE_SIMD4X2_SAMPLE_LOD;
	    assert(inst->mlen == 2);
	 }
	 break;
      case SHADER_OPCODE_TXD:
	 /* There is no sample_d_c message; comparisons are done manually. */
	 msg_type = BRW_SAMPLER_MESSAGE_SIMD4X2_SAMPLE_GRADIENTS;
	 assert(inst->mlen == 4);
	 break;
      case SHADER_OPCODE_TXF:
	 msg_type = BRW_SAMPLER_MESSAGE_SIMD4X2_LD;
	 assert(inst->mlen == 2);
	 break;
      case SHADER_OPCODE_TXS:
	 msg_type = BRW_SAMPLER_MESSAGE_SIMD4X2_RESINFO;
	 assert(inst->mlen == 2);
	 break;
      default:
	 unreachable("should not get here: invalid vec4 texture opcode");
      }
   }

   assert(msg_type != -1);

   assert(sampler_index.type == BRW_REGISTER_TYPE_UD);

   /* Load the message header if present.  If there's a texture offset, we need
    * to set it up explicitly and load the offset bitfield.  Otherwise, we can
    * use an implied move from g0 to the first message register.
    */
   if (inst->header_size != 0) {
      if (devinfo->gen < 6 && !inst->offset) {
         /* Set up an implied move from g0 to the MRF. */
         src = brw_vec8_grf(0, 0);
      } else {
         struct brw_reg header =
            retype(brw_message_reg(inst->base_mrf), BRW_REGISTER_TYPE_UD);
         uint32_t dw2 = 0;

         /* Explicitly set up the message header by copying g0 to the MRF. */
         brw_push_insn_state(p);
         brw_set_default_mask_control(p, BRW_MASK_DISABLE);
         brw_MOV(p, header, retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));

         brw_set_default_access_mode(p, BRW_ALIGN_1);

         if (inst->offset)
            /* Set the texel offset bits in DWord 2. */
            dw2 = inst->offset;

         if (devinfo->gen >= 9)
            /* SKL+ overloads BRW_SAMPLER_SIMD_MODE_SIMD4X2 to also do SIMD8D,
             * based on bit 22 in the header.
             */
            dw2 |= GEN9_SAMPLER_SIMD_MODE_EXTENSION_SIMD4X2;

         /* The VS, DS, and FS stages have the g0.2 payload delivered as 0,
          * so header0.2 is 0 when g0 is copied.  The HS and GS stages do
          * not, so we must set to to 0 to avoid setting undesirable bits
          * in the message header.
          */
         if (dw2 ||
             stage == MESA_SHADER_TESS_CTRL ||
             stage == MESA_SHADER_GEOMETRY) {
            brw_MOV(p, get_element_ud(header, 2), brw_imm_ud(dw2));
         }

         brw_adjust_sampler_state_pointer(p, header, sampler_index);
         brw_pop_insn_state(p);
      }
   }

   uint32_t return_format;

   switch (dst.type) {
   case BRW_REGISTER_TYPE_D:
      return_format = BRW_SAMPLER_RETURN_FORMAT_SINT32;
      break;
   case BRW_REGISTER_TYPE_UD:
      return_format = BRW_SAMPLER_RETURN_FORMAT_UINT32;
      break;
   default:
      return_format = BRW_SAMPLER_RETURN_FORMAT_FLOAT32;
      break;
   }

   uint32_t base_binding_table_index = (inst->opcode == SHADER_OPCODE_TG4 ||
         inst->opcode == SHADER_OPCODE_TG4_OFFSET)
         ? prog_data->base.binding_table.gather_texture_start
         : prog_data->base.binding_table.texture_start;

   if (surface_index.file == BRW_IMMEDIATE_VALUE &&
       sampler_index.file == BRW_IMMEDIATE_VALUE) {
      uint32_t surface = surface_index.ud;
      uint32_t sampler = sampler_index.ud;

      brw_SAMPLE(p,
                 dst,
                 inst->base_mrf,
                 src,
                 surface + base_binding_table_index,
                 sampler % 16,
                 msg_type,
                 1, /* response length */
                 inst->mlen,
                 inst->header_size != 0,
                 BRW_SAMPLER_SIMD_MODE_SIMD4X2,
                 return_format);

      brw_mark_surface_used(&prog_data->base, sampler + base_binding_table_index);
   } else {
      /* Non-constant sampler index. */

      struct brw_reg addr = vec1(retype(brw_address_reg(0), BRW_REGISTER_TYPE_UD));
      struct brw_reg surface_reg = vec1(retype(surface_index, BRW_REGISTER_TYPE_UD));
      struct brw_reg sampler_reg = vec1(retype(sampler_index, BRW_REGISTER_TYPE_UD));

      brw_push_insn_state(p);
      brw_set_default_mask_control(p, BRW_MASK_DISABLE);
      brw_set_default_access_mode(p, BRW_ALIGN_1);

      if (brw_regs_equal(&surface_reg, &sampler_reg)) {
         brw_MUL(p, addr, sampler_reg, brw_imm_uw(0x101));
      } else {
         if (sampler_reg.file == BRW_IMMEDIATE_VALUE) {
            brw_OR(p, addr, surface_reg, brw_imm_ud(sampler_reg.ud << 8));
         } else {
            brw_SHL(p, addr, sampler_reg, brw_imm_ud(8));
            brw_OR(p, addr, addr, surface_reg);
         }
      }
      if (base_binding_table_index)
         brw_ADD(p, addr, addr, brw_imm_ud(base_binding_table_index));
      brw_AND(p, addr, addr, brw_imm_ud(0xfff));

      brw_pop_insn_state(p);

      if (inst->base_mrf != -1)
         gen6_resolve_implied_move(p, &src, inst->base_mrf);

      /* dst = send(offset, a0.0 | <descriptor>) */
      brw_inst *insn = brw_send_indirect_message(
         p, BRW_SFID_SAMPLER, dst, src, addr);
      brw_set_sampler_message(p, insn,
                              0 /* surface */,
                              0 /* sampler */,
                              msg_type,
                              1 /* rlen */,
                              inst->mlen /* mlen */,
                              inst->header_size != 0 /* header */,
                              BRW_SAMPLER_SIMD_MODE_SIMD4X2,
                              return_format);

      /* visitor knows more than we do about the surface limit required,
       * so has already done marking.
       */
   }
}

static void
generate_vs_urb_write(struct brw_codegen *p, vec4_instruction *inst)
{
   brw_urb_WRITE(p,
		 brw_null_reg(), /* dest */
		 inst->base_mrf, /* starting mrf reg nr */
		 brw_vec8_grf(0, 0), /* src */
                 inst->urb_write_flags,
		 inst->mlen,
		 0,		/* response len */
		 inst->offset,	/* urb destination offset */
		 BRW_URB_SWIZZLE_INTERLEAVE);
}

static void
generate_gs_urb_write(struct brw_codegen *p, vec4_instruction *inst)
{
   struct brw_reg src = brw_message_reg(inst->base_mrf);
   brw_urb_WRITE(p,
                 brw_null_reg(), /* dest */
                 inst->base_mrf, /* starting mrf reg nr */
                 src,
                 inst->urb_write_flags,
                 inst->mlen,
                 0,             /* response len */
                 inst->offset,  /* urb destination offset */
                 BRW_URB_SWIZZLE_INTERLEAVE);
}

static void
generate_gs_urb_write_allocate(struct brw_codegen *p, vec4_instruction *inst)
{
   struct brw_reg src = brw_message_reg(inst->base_mrf);

   /* We pass the temporary passed in src0 as the writeback register */
   brw_urb_WRITE(p,
                 inst->src[0].as_brw_reg(), /* dest */
                 inst->base_mrf, /* starting mrf reg nr */
                 src,
                 BRW_URB_WRITE_ALLOCATE_COMPLETE,
                 inst->mlen,
                 1, /* response len */
                 inst->offset,  /* urb destination offset */
                 BRW_URB_SWIZZLE_INTERLEAVE);

   /* Now put allocated urb handle in dst.0 */
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, get_element_ud(inst->dst.as_brw_reg(), 0),
           get_element_ud(inst->src[0].as_brw_reg(), 0));
   brw_pop_insn_state(p);
}

static void
generate_gs_thread_end(struct brw_codegen *p, vec4_instruction *inst)
{
   struct brw_reg src = brw_message_reg(inst->base_mrf);
   brw_urb_WRITE(p,
                 brw_null_reg(), /* dest */
                 inst->base_mrf, /* starting mrf reg nr */
                 src,
                 BRW_URB_WRITE_EOT | inst->urb_write_flags,
                 inst->mlen,
                 0,              /* response len */
                 0,              /* urb destination offset */
                 BRW_URB_SWIZZLE_INTERLEAVE);
}

static void
generate_gs_set_write_offset(struct brw_codegen *p,
                             struct brw_reg dst,
                             struct brw_reg src0,
                             struct brw_reg src1)
{
   /* From p22 of volume 4 part 2 of the Ivy Bridge PRM (2.4.3.1 Message
    * Header: M0.3):
    *
    *     Slot 0 Offset. This field, after adding to the Global Offset field
    *     in the message descriptor, specifies the offset (in 256-bit units)
    *     from the start of the URB entry, as referenced by URB Handle 0, at
    *     which the data will be accessed.
    *
    * Similar text describes DWORD M0.4, which is slot 1 offset.
    *
    * Therefore, we want to multiply DWORDs 0 and 4 of src0 (the x components
    * of the register for geometry shader invocations 0 and 1) by the
    * immediate value in src1, and store the result in DWORDs 3 and 4 of dst.
    *
    * We can do this with the following EU instruction:
    *
    *     mul(2) dst.3<1>UD src0<8;2,4>UD src1<...>UW   { Align1 WE_all }
    */
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   assert(p->devinfo->gen >= 7 &&
          src1.file == BRW_IMMEDIATE_VALUE &&
          src1.type == BRW_REGISTER_TYPE_UD &&
          src1.ud <= USHRT_MAX);
   if (src0.file == BRW_IMMEDIATE_VALUE) {
      brw_MOV(p, suboffset(stride(dst, 2, 2, 1), 3),
              brw_imm_ud(src0.ud * src1.ud));
   } else {
      brw_MUL(p, suboffset(stride(dst, 2, 2, 1), 3), stride(src0, 8, 2, 4),
              retype(src1, BRW_REGISTER_TYPE_UW));
   }
   brw_pop_insn_state(p);
}

static void
generate_gs_set_vertex_count(struct brw_codegen *p,
                             struct brw_reg dst,
                             struct brw_reg src)
{
   brw_push_insn_state(p);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   if (p->devinfo->gen >= 8) {
      /* Move the vertex count into the second MRF for the EOT write. */
      brw_MOV(p, retype(brw_message_reg(dst.nr + 1), BRW_REGISTER_TYPE_UD),
              src);
   } else {
      /* If we think of the src and dst registers as composed of 8 DWORDs each,
       * we want to pick up the contents of DWORDs 0 and 4 from src, truncate
       * them to WORDs, and then pack them into DWORD 2 of dst.
       *
       * It's easier to get the EU to do this if we think of the src and dst
       * registers as composed of 16 WORDS each; then, we want to pick up the
       * contents of WORDs 0 and 8 from src, and pack them into WORDs 4 and 5
       * of dst.
       *
       * We can do that by the following EU instruction:
       *
       *     mov (2) dst.4<1>:uw src<8;1,0>:uw   { Align1, Q1, NoMask }
       */
      brw_set_default_access_mode(p, BRW_ALIGN_1);
      brw_MOV(p,
              suboffset(stride(retype(dst, BRW_REGISTER_TYPE_UW), 2, 2, 1), 4),
              stride(retype(src, BRW_REGISTER_TYPE_UW), 8, 1, 0));
   }
   brw_pop_insn_state(p);
}

static void
generate_gs_svb_write(struct brw_codegen *p,
                      struct brw_vue_prog_data *prog_data,
                      vec4_instruction *inst,
                      struct brw_reg dst,
                      struct brw_reg src0,
                      struct brw_reg src1)
{
   int binding = inst->sol_binding;
   bool final_write = inst->sol_final_write;

   brw_push_insn_state(p);
   brw_set_default_exec_size(p, BRW_EXECUTE_4);
   /* Copy Vertex data into M0.x */
   brw_MOV(p, stride(dst, 4, 4, 1),
           stride(retype(src0, BRW_REGISTER_TYPE_UD), 4, 4, 1));
   brw_pop_insn_state(p);

   brw_push_insn_state(p);
   /* Send SVB Write */
   brw_svb_write(p,
                 final_write ? src1 : brw_null_reg(), /* dest == src1 */
                 1, /* msg_reg_nr */
                 dst, /* src0 == previous dst */
                 SURF_INDEX_GEN6_SOL_BINDING(binding), /* binding_table_index */
                 final_write); /* send_commit_msg */

   /* Finally, wait for the write commit to occur so that we can proceed to
    * other things safely.
    *
    * From the Sandybridge PRM, Volume 4, Part 1, Section 3.3:
    *
    *   The write commit does not modify the destination register, but
    *   merely clears the dependency associated with the destination
    *   register. Thus, a simple “mov” instruction using the register as a
    *   source is sufficient to wait for the write commit to occur.
    */
   if (final_write) {
      brw_MOV(p, src1, src1);
   }
   brw_pop_insn_state(p);
}

static void
generate_gs_svb_set_destination_index(struct brw_codegen *p,
                                      vec4_instruction *inst,
                                      struct brw_reg dst,
                                      struct brw_reg src)
{
   int vertex = inst->sol_vertex;
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, get_element_ud(dst, 5), get_element_ud(src, vertex));
   brw_pop_insn_state(p);
}

static void
generate_gs_set_dword_2(struct brw_codegen *p,
                        struct brw_reg dst,
                        struct brw_reg src)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, suboffset(vec1(dst), 2), suboffset(vec1(src), 0));
   brw_pop_insn_state(p);
}

static void
generate_gs_prepare_channel_masks(struct brw_codegen *p,
                                  struct brw_reg dst)
{
   /* We want to left shift just DWORD 4 (the x component belonging to the
    * second geometry shader invocation) by 4 bits.  So generate the
    * instruction:
    *
    *     shl(1) dst.4<1>UD dst.4<0,1,0>UD 4UD { align1 WE_all }
    */
   dst = suboffset(vec1(dst), 4);
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_SHL(p, dst, dst, brw_imm_ud(4));
   brw_pop_insn_state(p);
}

static void
generate_gs_set_channel_masks(struct brw_codegen *p,
                              struct brw_reg dst,
                              struct brw_reg src)
{
   /* From p21 of volume 4 part 2 of the Ivy Bridge PRM (2.4.3.1 Message
    * Header: M0.5):
    *
    *     15 Vertex 1 DATA [3] / Vertex 0 DATA[7] Channel Mask
    *
    *        When Swizzle Control = URB_INTERLEAVED this bit controls Vertex 1
    *        DATA[3], when Swizzle Control = URB_NOSWIZZLE this bit controls
    *        Vertex 0 DATA[7].  This bit is ANDed with the corresponding
    *        channel enable to determine the final channel enable.  For the
    *        URB_READ_OWORD & URB_READ_HWORD messages, when final channel
    *        enable is 1 it indicates that Vertex 1 DATA [3] will be included
    *        in the writeback message.  For the URB_WRITE_OWORD &
    *        URB_WRITE_HWORD messages, when final channel enable is 1 it
    *        indicates that Vertex 1 DATA [3] will be written to the surface.
    *
    *        0: Vertex 1 DATA [3] / Vertex 0 DATA[7] channel not included
    *        1: Vertex DATA [3] / Vertex 0 DATA[7] channel included
    *
    *     14 Vertex 1 DATA [2] Channel Mask
    *     13 Vertex 1 DATA [1] Channel Mask
    *     12 Vertex 1 DATA [0] Channel Mask
    *     11 Vertex 0 DATA [3] Channel Mask
    *     10 Vertex 0 DATA [2] Channel Mask
    *      9 Vertex 0 DATA [1] Channel Mask
    *      8 Vertex 0 DATA [0] Channel Mask
    *
    * (This is from a section of the PRM that is agnostic to the particular
    * type of shader being executed, so "Vertex 0" and "Vertex 1" refer to
    * geometry shader invocations 0 and 1, respectively).  Since we have the
    * enable flags for geometry shader invocation 0 in bits 3:0 of DWORD 0,
    * and the enable flags for geometry shader invocation 1 in bits 7:0 of
    * DWORD 4, we just need to OR them together and store the result in bits
    * 15:8 of DWORD 5.
    *
    * It's easier to get the EU to do this if we think of the src and dst
    * registers as composed of 32 bytes each; then, we want to pick up the
    * contents of bytes 0 and 16 from src, OR them together, and store them in
    * byte 21.
    *
    * We can do that by the following EU instruction:
    *
    *     or(1) dst.21<1>UB src<0,1,0>UB src.16<0,1,0>UB { align1 WE_all }
    *
    * Note: this relies on the source register having zeros in (a) bits 7:4 of
    * DWORD 0 and (b) bits 3:0 of DWORD 4.  We can rely on (b) because the
    * source register was prepared by GS_OPCODE_PREPARE_CHANNEL_MASKS (which
    * shifts DWORD 4 left by 4 bits), and we can rely on (a) because prior to
    * the execution of GS_OPCODE_PREPARE_CHANNEL_MASKS, DWORDs 0 and 4 need to
    * contain valid channel mask values (which are in the range 0x0-0xf).
    */
   dst = retype(dst, BRW_REGISTER_TYPE_UB);
   src = retype(src, BRW_REGISTER_TYPE_UB);
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_OR(p, suboffset(vec1(dst), 21), vec1(src), suboffset(vec1(src), 16));
   brw_pop_insn_state(p);
}

static void
generate_gs_get_instance_id(struct brw_codegen *p,
                            struct brw_reg dst)
{
   /* We want to right shift R0.0 & R0.1 by GEN7_GS_PAYLOAD_INSTANCE_ID_SHIFT
    * and store into dst.0 & dst.4. So generate the instruction:
    *
    *     shr(8) dst<1> R0<1,4,0> GEN7_GS_PAYLOAD_INSTANCE_ID_SHIFT { align1 WE_normal 1Q }
    */
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   dst = retype(dst, BRW_REGISTER_TYPE_UD);
   struct brw_reg r0(retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));
   brw_SHR(p, dst, stride(r0, 1, 4, 0),
           brw_imm_ud(GEN7_GS_PAYLOAD_INSTANCE_ID_SHIFT));
   brw_pop_insn_state(p);
}

static void
generate_gs_ff_sync_set_primitives(struct brw_codegen *p,
                                   struct brw_reg dst,
                                   struct brw_reg src0,
                                   struct brw_reg src1,
                                   struct brw_reg src2)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   /* Save src0 data in 16:31 bits of dst.0 */
   brw_AND(p, suboffset(vec1(dst), 0), suboffset(vec1(src0), 0),
           brw_imm_ud(0xffffu));
   brw_SHL(p, suboffset(vec1(dst), 0), suboffset(vec1(dst), 0), brw_imm_ud(16));
   /* Save src1 data in 0:15 bits of dst.0 */
   brw_AND(p, suboffset(vec1(src2), 0), suboffset(vec1(src1), 0),
           brw_imm_ud(0xffffu));
   brw_OR(p, suboffset(vec1(dst), 0),
          suboffset(vec1(dst), 0),
          suboffset(vec1(src2), 0));
   brw_pop_insn_state(p);
}

static void
generate_gs_ff_sync(struct brw_codegen *p,
                    vec4_instruction *inst,
                    struct brw_reg dst,
                    struct brw_reg src0,
                    struct brw_reg src1)
{
   /* This opcode uses an implied MRF register for:
    *  - the header of the ff_sync message. And as such it is expected to be
    *    initialized to r0 before calling here.
    *  - the destination where we will write the allocated URB handle.
    */
   struct brw_reg header =
      retype(brw_message_reg(inst->base_mrf), BRW_REGISTER_TYPE_UD);

   /* Overwrite dword 0 of the header (SO vertices to write) and
    * dword 1 (number of primitives written).
    */
   brw_push_insn_state(p);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, get_element_ud(header, 0), get_element_ud(src1, 0));
   brw_MOV(p, get_element_ud(header, 1), get_element_ud(src0, 0));
   brw_pop_insn_state(p);

   /* Allocate URB handle in dst */
   brw_ff_sync(p,
               dst,
               0,
               header,
               1, /* allocate */
               1, /* response length */
               0 /* eot */);

   /* Now put allocated urb handle in header.0 */
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, get_element_ud(header, 0), get_element_ud(dst, 0));

   /* src1 is not an immediate when we use transform feedback */
   if (src1.file != BRW_IMMEDIATE_VALUE) {
      brw_set_default_exec_size(p, BRW_EXECUTE_4);
      brw_MOV(p, brw_vec4_grf(src1.nr, 0), brw_vec4_grf(dst.nr, 1));
   }

   brw_pop_insn_state(p);
}

static void
generate_gs_set_primitive_id(struct brw_codegen *p, struct brw_reg dst)
{
   /* In gen6, PrimitiveID is delivered in R0.1 of the payload */
   struct brw_reg src = brw_vec8_grf(0, 0);
   brw_push_insn_state(p);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, get_element_ud(dst, 0), get_element_ud(src, 1));
   brw_pop_insn_state(p);
}

static void
generate_tcs_get_instance_id(struct brw_codegen *p, struct brw_reg dst)
{
   const struct gen_device_info *devinfo = p->devinfo;
   const bool ivb = devinfo->is_ivybridge || devinfo->is_baytrail;

   /* "Instance Count" comes as part of the payload in r0.2 bits 23:17.
    *
    * Since we operate in SIMD4x2 mode, we need run half as many threads
    * as necessary.  So we assign (2i + 1, 2i) as the thread counts.  We
    * shift right by one less to accomplish the multiplication by two.
    */
   dst = retype(dst, BRW_REGISTER_TYPE_UD);
   struct brw_reg r0(retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);

   const int mask = ivb ? INTEL_MASK(22, 16) : INTEL_MASK(23, 17);
   const int shift = ivb ? 16 : 17;

   brw_AND(p, get_element_ud(dst, 0), get_element_ud(r0, 2), brw_imm_ud(mask));
   brw_SHR(p, get_element_ud(dst, 0), get_element_ud(dst, 0),
           brw_imm_ud(shift - 1));
   brw_ADD(p, get_element_ud(dst, 4), get_element_ud(dst, 0), brw_imm_ud(1));

   brw_pop_insn_state(p);
}

static void
generate_tcs_urb_write(struct brw_codegen *p,
                       vec4_instruction *inst,
                       struct brw_reg urb_header)
{
   const struct gen_device_info *devinfo = p->devinfo;

   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, brw_null_reg());
   brw_set_src0(p, send, urb_header);

   brw_set_message_descriptor(p, send, BRW_SFID_URB,
                              inst->mlen /* mlen */, 0 /* rlen */,
                              true /* header */, false /* eot */);
   brw_inst_set_urb_opcode(devinfo, send, BRW_URB_OPCODE_WRITE_OWORD);
   brw_inst_set_urb_global_offset(devinfo, send, inst->offset);
   if (inst->urb_write_flags & BRW_URB_WRITE_EOT) {
      brw_inst_set_eot(devinfo, send, 1);
   } else {
      brw_inst_set_urb_per_slot_offset(devinfo, send, 1);
      brw_inst_set_urb_swizzle_control(devinfo, send, BRW_URB_SWIZZLE_INTERLEAVE);
   }

   /* what happens to swizzles? */
}


static void
generate_tcs_input_urb_offsets(struct brw_codegen *p,
                               struct brw_reg dst,
                               struct brw_reg vertex,
                               struct brw_reg offset)
{
   /* Generates an URB read/write message header for HS/DS operation.
    * Inputs are a vertex index, and a byte offset from the beginning of
    * the vertex. */

   /* If `vertex` is not an immediate, we clobber a0.0 */

   assert(vertex.file == BRW_IMMEDIATE_VALUE || vertex.file == BRW_GENERAL_REGISTER_FILE);
   assert(vertex.type == BRW_REGISTER_TYPE_UD || vertex.type == BRW_REGISTER_TYPE_D);

   assert(dst.file == BRW_GENERAL_REGISTER_FILE);

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, dst, brw_imm_ud(0));

   /* m0.5 bits 8-15 are channel enables */
   brw_MOV(p, get_element_ud(dst, 5), brw_imm_ud(0xff00));

   /* m0.0-0.1: URB handles */
   if (vertex.file == BRW_IMMEDIATE_VALUE) {
      uint32_t vertex_index = vertex.ud;
      struct brw_reg index_reg = brw_vec1_grf(
            1 + (vertex_index >> 3), vertex_index & 7);

      brw_MOV(p, vec2(get_element_ud(dst, 0)),
              retype(index_reg, BRW_REGISTER_TYPE_UD));
   } else {
      /* Use indirect addressing.  ICP Handles are DWords (single channels
       * of a register) and start at g1.0.
       *
       * In order to start our region at g1.0, we add 8 to the vertex index,
       * effectively skipping over the 8 channels in g0.0.  This gives us a
       * DWord offset to the ICP Handle.
       *
       * Indirect addressing works in terms of bytes, so we then multiply
       * the DWord offset by 4 (by shifting left by 2).
       */
      struct brw_reg addr = brw_address_reg(0);

      /* bottom half: m0.0 = g[1.0 + vertex.0]UD */
      brw_ADD(p, addr, get_element_ud(vertex, 0), brw_imm_uw(0x8));
      brw_SHL(p, addr, addr, brw_imm_ud(2));
      brw_MOV(p, get_element_ud(dst, 0), deref_1ud(brw_indirect(0, 0), 0));

      /* top half: m0.1 = g[1.0 + vertex.4]UD */
      brw_ADD(p, addr, get_element_ud(vertex, 4), brw_imm_uw(0x8));
      brw_SHL(p, addr, addr, brw_imm_ud(2));
      brw_MOV(p, get_element_ud(dst, 1), deref_1ud(brw_indirect(0, 0), 0));
   }

   /* m0.3-0.4: 128bit-granular offsets into the URB from the handles */
   if (offset.file != ARF)
      brw_MOV(p, vec2(get_element_ud(dst, 3)), stride(offset, 4, 1, 0));

   brw_pop_insn_state(p);
}


static void
generate_tcs_output_urb_offsets(struct brw_codegen *p,
                                struct brw_reg dst,
                                struct brw_reg write_mask,
                                struct brw_reg offset)
{
   /* Generates an URB read/write message header for HS/DS operation, for the patch URB entry. */
   assert(dst.file == BRW_GENERAL_REGISTER_FILE || dst.file == BRW_MESSAGE_REGISTER_FILE);

   assert(write_mask.file == BRW_IMMEDIATE_VALUE);
   assert(write_mask.type == BRW_REGISTER_TYPE_UD);

   brw_push_insn_state(p);

   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, dst, brw_imm_ud(0));

   unsigned mask = write_mask.ud;

   /* m0.5 bits 15:12 and 11:8 are channel enables */
   brw_MOV(p, get_element_ud(dst, 5), brw_imm_ud((mask << 8) | (mask << 12)));

   /* HS patch URB handle is delivered in r0.0 */
   struct brw_reg urb_handle = brw_vec1_grf(0, 0);

   /* m0.0-0.1: URB handles */
   brw_MOV(p, vec2(get_element_ud(dst, 0)),
           retype(urb_handle, BRW_REGISTER_TYPE_UD));

   /* m0.3-0.4: 128bit-granular offsets into the URB from the handles */
   if (offset.file != ARF)
      brw_MOV(p, vec2(get_element_ud(dst, 3)), stride(offset, 4, 1, 0));

   brw_pop_insn_state(p);
}

static void
generate_tes_create_input_read_header(struct brw_codegen *p,
                                      struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   /* Initialize the register to 0 */
   brw_MOV(p, dst, brw_imm_ud(0));

   /* Enable all the channels in m0.5 bits 15:8 */
   brw_MOV(p, get_element_ud(dst, 5), brw_imm_ud(0xff00));

   /* Copy g1.3 (the patch URB handle) to m0.0 and m0.1.  For safety,
    * mask out irrelevant "Reserved" bits, as they're not marked MBZ.
    */
   brw_AND(p, vec2(get_element_ud(dst, 0)),
           retype(brw_vec1_grf(1, 3), BRW_REGISTER_TYPE_UD),
           brw_imm_ud(0x1fff));
   brw_pop_insn_state(p);
}

static void
generate_tes_add_indirect_urb_offset(struct brw_codegen *p,
                                     struct brw_reg dst,
                                     struct brw_reg header,
                                     struct brw_reg offset)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   brw_MOV(p, dst, header);
   /* m0.3-0.4: 128-bit-granular offsets into the URB from the handles */
   brw_MOV(p, vec2(get_element_ud(dst, 3)), stride(offset, 4, 1, 0));

   brw_pop_insn_state(p);
}

static void
generate_vec4_urb_read(struct brw_codegen *p,
                       vec4_instruction *inst,
                       struct brw_reg dst,
                       struct brw_reg header)
{
   const struct gen_device_info *devinfo = p->devinfo;

   assert(header.file == BRW_GENERAL_REGISTER_FILE);
   assert(header.type == BRW_REGISTER_TYPE_UD);

   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, dst);
   brw_set_src0(p, send, header);

   brw_set_message_descriptor(p, send, BRW_SFID_URB,
                              1 /* mlen */, 1 /* rlen */,
                              true /* header */, false /* eot */);
   brw_inst_set_urb_opcode(devinfo, send, BRW_URB_OPCODE_READ_OWORD);
   brw_inst_set_urb_swizzle_control(devinfo, send, BRW_URB_SWIZZLE_INTERLEAVE);
   brw_inst_set_urb_per_slot_offset(devinfo, send, 1);

   brw_inst_set_urb_global_offset(devinfo, send, inst->offset);
}

static void
generate_tcs_release_input(struct brw_codegen *p,
                           struct brw_reg header,
                           struct brw_reg vertex,
                           struct brw_reg is_unpaired)
{
   const struct gen_device_info *devinfo = p->devinfo;

   assert(vertex.file == BRW_IMMEDIATE_VALUE);
   assert(vertex.type == BRW_REGISTER_TYPE_UD);

   /* m0.0-0.1: URB handles */
   struct brw_reg urb_handles =
      retype(brw_vec2_grf(1 + (vertex.ud >> 3), vertex.ud & 7),
             BRW_REGISTER_TYPE_UD);

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, header, brw_imm_ud(0));
   brw_MOV(p, vec2(get_element_ud(header, 0)), urb_handles);
   brw_pop_insn_state(p);

   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, brw_null_reg());
   brw_set_src0(p, send, header);
   brw_set_message_descriptor(p, send, BRW_SFID_URB,
                              1 /* mlen */, 0 /* rlen */,
                              true /* header */, false /* eot */);
   brw_inst_set_urb_opcode(devinfo, send, BRW_URB_OPCODE_READ_OWORD);
   brw_inst_set_urb_complete(devinfo, send, 1);
   brw_inst_set_urb_swizzle_control(devinfo, send, is_unpaired.ud ?
                                    BRW_URB_SWIZZLE_NONE :
                                    BRW_URB_SWIZZLE_INTERLEAVE);
}

static void
generate_tcs_thread_end(struct brw_codegen *p, vec4_instruction *inst)
{
   struct brw_reg header = brw_message_reg(inst->base_mrf);

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, header, brw_imm_ud(0));
   brw_MOV(p, get_element_ud(header, 5), brw_imm_ud(WRITEMASK_X << 8));
   brw_MOV(p, get_element_ud(header, 0),
           retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD));
   brw_MOV(p, brw_message_reg(inst->base_mrf + 1), brw_imm_ud(0u));
   brw_pop_insn_state(p);

   brw_urb_WRITE(p,
                 brw_null_reg(), /* dest */
                 inst->base_mrf, /* starting mrf reg nr */
                 header,
                 BRW_URB_WRITE_EOT | BRW_URB_WRITE_OWORD |
                 BRW_URB_WRITE_USE_CHANNEL_MASKS,
                 inst->mlen,
                 0,              /* response len */
                 0,              /* urb destination offset */
                 0);
}

static void
generate_tes_get_primitive_id(struct brw_codegen *p, struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, dst, retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_D));
   brw_pop_insn_state(p);
}

static void
generate_tcs_get_primitive_id(struct brw_codegen *p, struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, dst, retype(brw_vec1_grf(0, 1), BRW_REGISTER_TYPE_UD));
   brw_pop_insn_state(p);
}

static void
generate_tcs_create_barrier_header(struct brw_codegen *p,
                                   struct brw_vue_prog_data *prog_data,
                                   struct brw_reg dst)
{
   const struct gen_device_info *devinfo = p->devinfo;
   const bool ivb = devinfo->is_ivybridge || devinfo->is_baytrail;
   struct brw_reg m0_2 = get_element_ud(dst, 2);
   unsigned instances = ((struct brw_tcs_prog_data *) prog_data)->instances;

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   /* Zero the message header */
   brw_MOV(p, retype(dst, BRW_REGISTER_TYPE_UD), brw_imm_ud(0u));

   /* Copy "Barrier ID" from r0.2, bits 16:13 (Gen7.5+) or 15:12 (Gen7) */
   brw_AND(p, m0_2,
           retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD),
           brw_imm_ud(ivb ? INTEL_MASK(15, 12) : INTEL_MASK(16, 13)));

   /* Shift it up to bits 27:24. */
   brw_SHL(p, m0_2, get_element_ud(dst, 2), brw_imm_ud(ivb ? 12 : 11));

   /* Set the Barrier Count and the enable bit */
   brw_OR(p, m0_2, m0_2, brw_imm_ud(instances << 9 | (1 << 15)));

   brw_pop_insn_state(p);
}

static void
generate_oword_dual_block_offsets(struct brw_codegen *p,
                                  struct brw_reg m1,
                                  struct brw_reg index)
{
   int second_vertex_offset;

   if (p->devinfo->gen >= 6)
      second_vertex_offset = 1;
   else
      second_vertex_offset = 16;

   m1 = retype(m1, BRW_REGISTER_TYPE_D);

   /* Set up M1 (message payload).  Only the block offsets in M1.0 and
    * M1.4 are used, and the rest are ignored.
    */
   struct brw_reg m1_0 = suboffset(vec1(m1), 0);
   struct brw_reg m1_4 = suboffset(vec1(m1), 4);
   struct brw_reg index_0 = suboffset(vec1(index), 0);
   struct brw_reg index_4 = suboffset(vec1(index), 4);

   brw_push_insn_state(p);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_set_default_access_mode(p, BRW_ALIGN_1);

   brw_MOV(p, m1_0, index_0);

   if (index.file == BRW_IMMEDIATE_VALUE) {
      index_4.ud += second_vertex_offset;
      brw_MOV(p, m1_4, index_4);
   } else {
      brw_ADD(p, m1_4, index_4, brw_imm_d(second_vertex_offset));
   }

   brw_pop_insn_state(p);
}

static void
generate_unpack_flags(struct brw_codegen *p,
                      struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_set_default_access_mode(p, BRW_ALIGN_1);

   struct brw_reg flags = brw_flag_reg(0, 0);
   struct brw_reg dst_0 = suboffset(vec1(dst), 0);
   struct brw_reg dst_4 = suboffset(vec1(dst), 4);

   brw_AND(p, dst_0, flags, brw_imm_ud(0x0f));
   brw_AND(p, dst_4, flags, brw_imm_ud(0xf0));
   brw_SHR(p, dst_4, dst_4, brw_imm_ud(4));

   brw_pop_insn_state(p);
}

static void
generate_scratch_read(struct brw_codegen *p,
                      vec4_instruction *inst,
                      struct brw_reg dst,
                      struct brw_reg index)
{
   const struct gen_device_info *devinfo = p->devinfo;
   struct brw_reg header = brw_vec8_grf(0, 0);

   gen6_resolve_implied_move(p, &header, inst->base_mrf);

   generate_oword_dual_block_offsets(p, brw_message_reg(inst->base_mrf + 1),
				     index);

   uint32_t msg_type;

   if (devinfo->gen >= 6)
      msg_type = GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ;
   else if (devinfo->gen == 5 || devinfo->is_g4x)
      msg_type = G45_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ;
   else
      msg_type = BRW_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ;

   const unsigned target_cache = devinfo->gen >= 7 ?
      BRW_DATAPORT_READ_TARGET_DATA_CACHE :
      BRW_DATAPORT_READ_TARGET_RENDER_CACHE;

   /* Each of the 8 channel enables is considered for whether each
    * dword is written.
    */
   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, dst);
   brw_set_src0(p, send, header);
   if (devinfo->gen < 6)
      brw_inst_set_cond_modifier(devinfo, send, inst->base_mrf);
   brw_set_dp_read_message(p, send,
                           brw_scratch_surface_idx(p),
			   BRW_DATAPORT_OWORD_DUAL_BLOCK_1OWORD,
			   msg_type, target_cache,
			   2, /* mlen */
                           true, /* header_present */
			   1 /* rlen */);
}

static void
generate_scratch_write(struct brw_codegen *p,
                       vec4_instruction *inst,
                       struct brw_reg dst,
                       struct brw_reg src,
                       struct brw_reg index)
{
   const struct gen_device_info *devinfo = p->devinfo;
   struct brw_reg header = brw_vec8_grf(0, 0);
   bool write_commit;

   /* If the instruction is predicated, we'll predicate the send, not
    * the header setup.
    */
   brw_set_default_predicate_control(p, false);

   gen6_resolve_implied_move(p, &header, inst->base_mrf);

   generate_oword_dual_block_offsets(p, brw_message_reg(inst->base_mrf + 1),
				     index);

   brw_MOV(p,
	   retype(brw_message_reg(inst->base_mrf + 2), BRW_REGISTER_TYPE_D),
	   retype(src, BRW_REGISTER_TYPE_D));

   uint32_t msg_type;

   if (devinfo->gen >= 7)
      msg_type = GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE;
   else if (devinfo->gen == 6)
      msg_type = GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE;
   else
      msg_type = BRW_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE;

   brw_set_default_predicate_control(p, inst->predicate);

   /* Pre-gen6, we have to specify write commits to ensure ordering
    * between reads and writes within a thread.  Afterwards, that's
    * guaranteed and write commits only matter for inter-thread
    * synchronization.
    */
   if (devinfo->gen >= 6) {
      write_commit = false;
   } else {
      /* The visitor set up our destination register to be g0.  This
       * means that when the next read comes along, we will end up
       * reading from g0 and causing a block on the write commit.  For
       * write-after-read, we are relying on the value of the previous
       * read being used (and thus blocking on completion) before our
       * write is executed.  This means we have to be careful in
       * instruction scheduling to not violate this assumption.
       */
      write_commit = true;
   }

   /* Each of the 8 channel enables is considered for whether each
    * dword is written.
    */
   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, dst);
   brw_set_src0(p, send, header);
   if (devinfo->gen < 6)
      brw_inst_set_cond_modifier(p->devinfo, send, inst->base_mrf);
   brw_set_dp_write_message(p, send,
                            brw_scratch_surface_idx(p),
			    BRW_DATAPORT_OWORD_DUAL_BLOCK_1OWORD,
			    msg_type,
			    3, /* mlen */
			    true, /* header present */
			    false, /* not a render target write */
			    write_commit, /* rlen */
			    false, /* eot */
			    write_commit);
}

static void
generate_pull_constant_load(struct brw_codegen *p,
                            struct brw_vue_prog_data *prog_data,
                            vec4_instruction *inst,
                            struct brw_reg dst,
                            struct brw_reg index,
                            struct brw_reg offset)
{
   const struct gen_device_info *devinfo = p->devinfo;
   assert(index.file == BRW_IMMEDIATE_VALUE &&
	  index.type == BRW_REGISTER_TYPE_UD);
   uint32_t surf_index = index.ud;

   struct brw_reg header = brw_vec8_grf(0, 0);

   gen6_resolve_implied_move(p, &header, inst->base_mrf);

   if (devinfo->gen >= 6) {
      if (offset.file == BRW_IMMEDIATE_VALUE) {
         brw_MOV(p, retype(brw_message_reg(inst->base_mrf + 1),
                           BRW_REGISTER_TYPE_D),
                 brw_imm_d(offset.ud >> 4));
      } else {
         brw_SHR(p, retype(brw_message_reg(inst->base_mrf + 1),
                           BRW_REGISTER_TYPE_D),
                 offset, brw_imm_d(4));
      }
   } else {
      brw_MOV(p, retype(brw_message_reg(inst->base_mrf + 1),
                        BRW_REGISTER_TYPE_D),
              offset);
   }

   uint32_t msg_type;

   if (devinfo->gen >= 6)
      msg_type = GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ;
   else if (devinfo->gen == 5 || devinfo->is_g4x)
      msg_type = G45_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ;
   else
      msg_type = BRW_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ;

   /* Each of the 8 channel enables is considered for whether each
    * dword is written.
    */
   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, dst);
   brw_set_src0(p, send, header);
   if (devinfo->gen < 6)
      brw_inst_set_cond_modifier(p->devinfo, send, inst->base_mrf);
   brw_set_dp_read_message(p, send,
			   surf_index,
			   BRW_DATAPORT_OWORD_DUAL_BLOCK_1OWORD,
			   msg_type,
			   BRW_DATAPORT_READ_TARGET_DATA_CACHE,
			   2, /* mlen */
                           true, /* header_present */
			   1 /* rlen */);
}

static void
generate_get_buffer_size(struct brw_codegen *p,
                         struct brw_vue_prog_data *prog_data,
                         vec4_instruction *inst,
                         struct brw_reg dst,
                         struct brw_reg src,
                         struct brw_reg surf_index)
{
   assert(p->devinfo->gen >= 7);
   assert(surf_index.type == BRW_REGISTER_TYPE_UD &&
          surf_index.file == BRW_IMMEDIATE_VALUE);

   brw_SAMPLE(p,
              dst,
              inst->base_mrf,
              src,
              surf_index.ud,
              0,
              GEN5_SAMPLER_MESSAGE_SAMPLE_RESINFO,
              1, /* response length */
              inst->mlen,
              inst->header_size > 0,
              BRW_SAMPLER_SIMD_MODE_SIMD4X2,
              BRW_SAMPLER_RETURN_FORMAT_SINT32);

   brw_mark_surface_used(&prog_data->base, surf_index.ud);
}

static void
generate_pull_constant_load_gen7(struct brw_codegen *p,
                                 struct brw_vue_prog_data *prog_data,
                                 vec4_instruction *inst,
                                 struct brw_reg dst,
                                 struct brw_reg surf_index,
                                 struct brw_reg offset)
{
   assert(surf_index.type == BRW_REGISTER_TYPE_UD);

   if (surf_index.file == BRW_IMMEDIATE_VALUE) {

      brw_inst *insn = brw_next_insn(p, BRW_OPCODE_SEND);
      brw_set_dest(p, insn, dst);
      brw_set_src0(p, insn, offset);
      brw_set_sampler_message(p, insn,
                              surf_index.ud,
                              0, /* LD message ignores sampler unit */
                              GEN5_SAMPLER_MESSAGE_SAMPLE_LD,
                              1, /* rlen */
                              inst->mlen,
                              inst->header_size != 0,
                              BRW_SAMPLER_SIMD_MODE_SIMD4X2,
                              0);

      brw_mark_surface_used(&prog_data->base, surf_index.ud);

   } else {

      struct brw_reg addr = vec1(retype(brw_address_reg(0), BRW_REGISTER_TYPE_UD));

      brw_push_insn_state(p);
      brw_set_default_mask_control(p, BRW_MASK_DISABLE);
      brw_set_default_access_mode(p, BRW_ALIGN_1);

      /* a0.0 = surf_index & 0xff */
      brw_inst *insn_and = brw_next_insn(p, BRW_OPCODE_AND);
      brw_inst_set_exec_size(p->devinfo, insn_and, BRW_EXECUTE_1);
      brw_set_dest(p, insn_and, addr);
      brw_set_src0(p, insn_and, vec1(retype(surf_index, BRW_REGISTER_TYPE_UD)));
      brw_set_src1(p, insn_and, brw_imm_ud(0x0ff));

      brw_pop_insn_state(p);

      /* dst = send(offset, a0.0 | <descriptor>) */
      brw_inst *insn = brw_send_indirect_message(
         p, BRW_SFID_SAMPLER, dst, offset, addr);
      brw_set_sampler_message(p, insn,
                              0 /* surface */,
                              0 /* sampler */,
                              GEN5_SAMPLER_MESSAGE_SAMPLE_LD,
                              1 /* rlen */,
                              inst->mlen,
                              inst->header_size != 0,
                              BRW_SAMPLER_SIMD_MODE_SIMD4X2,
                              0);
   }
}

static void
generate_set_simd4x2_header_gen9(struct brw_codegen *p,
                                 vec4_instruction *inst,
                                 struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   brw_set_default_exec_size(p, BRW_EXECUTE_8);
   brw_MOV(p, vec8(dst), retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));

   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, get_element_ud(dst, 2),
           brw_imm_ud(GEN9_SAMPLER_SIMD_MODE_EXTENSION_SIMD4X2));

   brw_pop_insn_state(p);
}

static void
generate_mov_indirect(struct brw_codegen *p,
                      vec4_instruction *inst,
                      struct brw_reg dst, struct brw_reg reg,
                      struct brw_reg indirect, struct brw_reg length)
{
   assert(indirect.type == BRW_REGISTER_TYPE_UD);
   assert(p->devinfo->gen >= 6);

   unsigned imm_byte_offset = reg.nr * REG_SIZE + reg.subnr * (REG_SIZE / 2);

   /* This instruction acts in align1 mode */
   assert(dst.writemask == WRITEMASK_XYZW);

   if (indirect.file == BRW_IMMEDIATE_VALUE) {
      imm_byte_offset += indirect.ud;

      reg.nr = imm_byte_offset / REG_SIZE;
      reg.subnr = (imm_byte_offset / (REG_SIZE / 2)) % 2;
      unsigned shift = (imm_byte_offset / 4) % 4;
      reg.swizzle += BRW_SWIZZLE4(shift, shift, shift, shift);

      brw_MOV(p, dst, reg);
   } else {
      brw_push_insn_state(p);
      brw_set_default_access_mode(p, BRW_ALIGN_1);
      brw_set_default_mask_control(p, BRW_MASK_DISABLE);

      struct brw_reg addr = vec8(brw_address_reg(0));

      /* We need to move the indirect value into the address register.  In
       * order to make things make some sense, we want to respect at least the
       * X component of the swizzle.  In order to do that, we need to convert
       * the subnr (probably 0) to an align1 subnr and add in the swizzle.
       */
      assert(brw_is_single_value_swizzle(indirect.swizzle));
      indirect.subnr = (indirect.subnr * 4 + BRW_GET_SWZ(indirect.swizzle, 0));

      /* We then use a region of <8,4,0>:uw to pick off the first 2 bytes of
       * the indirect and splat it out to all four channels of the given half
       * of a0.
       */
      indirect.subnr *= 2;
      indirect = stride(retype(indirect, BRW_REGISTER_TYPE_UW), 8, 4, 0);
      brw_ADD(p, addr, indirect, brw_imm_uw(imm_byte_offset));

      /* Now we need to incorporate the swizzle from the source register */
      if (reg.swizzle != BRW_SWIZZLE_XXXX) {
         uint32_t uv_swiz = BRW_GET_SWZ(reg.swizzle, 0) << 2 |
                            BRW_GET_SWZ(reg.swizzle, 1) << 6 |
                            BRW_GET_SWZ(reg.swizzle, 2) << 10 |
                            BRW_GET_SWZ(reg.swizzle, 3) << 14;
         uv_swiz |= uv_swiz << 16;

         brw_ADD(p, addr, addr, brw_imm_uv(uv_swiz));
      }

      brw_MOV(p, dst, retype(brw_VxH_indirect(0, 0), reg.type));

      brw_pop_insn_state(p);
   }
}

static void
generate_code(struct brw_codegen *p,
              const struct brw_compiler *compiler,
              void *log_data,
              const nir_shader *nir,
              struct brw_vue_prog_data *prog_data,
              const struct cfg_t *cfg)
{
   const struct gen_device_info *devinfo = p->devinfo;
   const char *stage_abbrev = _mesa_shader_stage_to_abbrev(nir->stage);
   bool debug_flag = INTEL_DEBUG &
      intel_debug_flag_for_shader_stage(nir->stage);
   struct annotation_info annotation;
   memset(&annotation, 0, sizeof(annotation));
   int spill_count = 0, fill_count = 0;
   int loop_count = 0;

   foreach_block_and_inst (block, vec4_instruction, inst, cfg) {
      struct brw_reg src[3], dst;

      if (unlikely(debug_flag))
         annotate(p->devinfo, &annotation, cfg, inst, p->next_insn_offset);

      for (unsigned int i = 0; i < 3; i++) {
         src[i] = inst->src[i].as_brw_reg();
      }
      dst = inst->dst.as_brw_reg();

      brw_set_default_predicate_control(p, inst->predicate);
      brw_set_default_predicate_inverse(p, inst->predicate_inverse);
      brw_set_default_flag_reg(p, 0, inst->flag_subreg);
      brw_set_default_saturate(p, inst->saturate);
      brw_set_default_mask_control(p, inst->force_writemask_all);
      brw_set_default_acc_write_control(p, inst->writes_accumulator);

      assert(inst->base_mrf + inst->mlen <= BRW_MAX_MRF(devinfo->gen));
      assert(inst->mlen <= BRW_MAX_MSG_LENGTH);

      unsigned pre_emit_nr_insn = p->nr_insn;

      switch (inst->opcode) {
      case VEC4_OPCODE_UNPACK_UNIFORM:
      case BRW_OPCODE_MOV:
         brw_MOV(p, dst, src[0]);
         break;
      case BRW_OPCODE_ADD:
         brw_ADD(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_MUL:
         brw_MUL(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_MACH:
         brw_MACH(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_MAD:
         assert(devinfo->gen >= 6);
         brw_MAD(p, dst, src[0], src[1], src[2]);
         break;

      case BRW_OPCODE_FRC:
         brw_FRC(p, dst, src[0]);
         break;
      case BRW_OPCODE_RNDD:
         brw_RNDD(p, dst, src[0]);
         break;
      case BRW_OPCODE_RNDE:
         brw_RNDE(p, dst, src[0]);
         break;
      case BRW_OPCODE_RNDZ:
         brw_RNDZ(p, dst, src[0]);
         break;

      case BRW_OPCODE_AND:
         brw_AND(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_OR:
         brw_OR(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_XOR:
         brw_XOR(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_NOT:
         brw_NOT(p, dst, src[0]);
         break;
      case BRW_OPCODE_ASR:
         brw_ASR(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_SHR:
         brw_SHR(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_SHL:
         brw_SHL(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_CMP:
         brw_CMP(p, dst, inst->conditional_mod, src[0], src[1]);
         break;
      case BRW_OPCODE_SEL:
         brw_SEL(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_DPH:
         brw_DPH(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_DP4:
         brw_DP4(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_DP3:
         brw_DP3(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_DP2:
         brw_DP2(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_F32TO16:
         assert(devinfo->gen >= 7);
         brw_F32TO16(p, dst, src[0]);
         break;

      case BRW_OPCODE_F16TO32:
         assert(devinfo->gen >= 7);
         brw_F16TO32(p, dst, src[0]);
         break;

      case BRW_OPCODE_LRP:
         assert(devinfo->gen >= 6);
         brw_LRP(p, dst, src[0], src[1], src[2]);
         break;

      case BRW_OPCODE_BFREV:
         assert(devinfo->gen >= 7);
         /* BFREV only supports UD type for src and dst. */
         brw_BFREV(p, retype(dst, BRW_REGISTER_TYPE_UD),
                   retype(src[0], BRW_REGISTER_TYPE_UD));
         break;
      case BRW_OPCODE_FBH:
         assert(devinfo->gen >= 7);
         /* FBH only supports UD type for dst. */
         brw_FBH(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
         break;
      case BRW_OPCODE_FBL:
         assert(devinfo->gen >= 7);
         /* FBL only supports UD type for dst. */
         brw_FBL(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
         break;
      case BRW_OPCODE_LZD:
         brw_LZD(p, dst, src[0]);
         break;
      case BRW_OPCODE_CBIT:
         assert(devinfo->gen >= 7);
         /* CBIT only supports UD type for dst. */
         brw_CBIT(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
         break;
      case BRW_OPCODE_ADDC:
         assert(devinfo->gen >= 7);
         brw_ADDC(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_SUBB:
         assert(devinfo->gen >= 7);
         brw_SUBB(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_MAC:
         brw_MAC(p, dst, src[0], src[1]);
         break;

      case BRW_OPCODE_BFE:
         assert(devinfo->gen >= 7);
         brw_BFE(p, dst, src[0], src[1], src[2]);
         break;

      case BRW_OPCODE_BFI1:
         assert(devinfo->gen >= 7);
         brw_BFI1(p, dst, src[0], src[1]);
         break;
      case BRW_OPCODE_BFI2:
         assert(devinfo->gen >= 7);
         brw_BFI2(p, dst, src[0], src[1], src[2]);
         break;

      case BRW_OPCODE_IF:
         if (!inst->src[0].is_null()) {
            /* The instruction has an embedded compare (only allowed on gen6) */
            assert(devinfo->gen == 6);
            gen6_IF(p, inst->conditional_mod, src[0], src[1]);
         } else {
            brw_inst *if_inst = brw_IF(p, BRW_EXECUTE_8);
            brw_inst_set_pred_control(p->devinfo, if_inst, inst->predicate);
         }
         break;

      case BRW_OPCODE_ELSE:
         brw_ELSE(p);
         break;
      case BRW_OPCODE_ENDIF:
         brw_ENDIF(p);
         break;

      case BRW_OPCODE_DO:
         brw_DO(p, BRW_EXECUTE_8);
         break;

      case BRW_OPCODE_BREAK:
         brw_BREAK(p);
         brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
         break;
      case BRW_OPCODE_CONTINUE:
         brw_CONT(p);
         brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
         break;

      case BRW_OPCODE_WHILE:
         brw_WHILE(p);
         loop_count++;
         break;

      case SHADER_OPCODE_RCP:
      case SHADER_OPCODE_RSQ:
      case SHADER_OPCODE_SQRT:
      case SHADER_OPCODE_EXP2:
      case SHADER_OPCODE_LOG2:
      case SHADER_OPCODE_SIN:
      case SHADER_OPCODE_COS:
         assert(inst->conditional_mod == BRW_CONDITIONAL_NONE);
         if (devinfo->gen >= 7) {
            gen6_math(p, dst, brw_math_function(inst->opcode), src[0],
                      brw_null_reg());
         } else if (devinfo->gen == 6) {
            generate_math_gen6(p, inst, dst, src[0], brw_null_reg());
         } else {
            generate_math1_gen4(p, inst, dst, src[0]);
         }
         break;

      case SHADER_OPCODE_POW:
      case SHADER_OPCODE_INT_QUOTIENT:
      case SHADER_OPCODE_INT_REMAINDER:
         assert(inst->conditional_mod == BRW_CONDITIONAL_NONE);
         if (devinfo->gen >= 7) {
            gen6_math(p, dst, brw_math_function(inst->opcode), src[0], src[1]);
         } else if (devinfo->gen == 6) {
            generate_math_gen6(p, inst, dst, src[0], src[1]);
         } else {
            generate_math2_gen4(p, inst, dst, src[0], src[1]);
         }
         break;

      case SHADER_OPCODE_TEX:
      case SHADER_OPCODE_TXD:
      case SHADER_OPCODE_TXF:
      case SHADER_OPCODE_TXF_CMS:
      case SHADER_OPCODE_TXF_CMS_W:
      case SHADER_OPCODE_TXF_MCS:
      case SHADER_OPCODE_TXL:
      case SHADER_OPCODE_TXS:
      case SHADER_OPCODE_TG4:
      case SHADER_OPCODE_TG4_OFFSET:
      case SHADER_OPCODE_SAMPLEINFO:
         generate_tex(p, prog_data, nir->stage,
                      inst, dst, src[0], src[1], src[2]);
         break;

      case VS_OPCODE_URB_WRITE:
         generate_vs_urb_write(p, inst);
         break;

      case SHADER_OPCODE_GEN4_SCRATCH_READ:
         generate_scratch_read(p, inst, dst, src[0]);
         fill_count++;
         break;

      case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
         generate_scratch_write(p, inst, dst, src[0], src[1]);
         spill_count++;
         break;

      case VS_OPCODE_PULL_CONSTANT_LOAD:
         generate_pull_constant_load(p, prog_data, inst, dst, src[0], src[1]);
         break;

      case VS_OPCODE_PULL_CONSTANT_LOAD_GEN7:
         generate_pull_constant_load_gen7(p, prog_data, inst, dst, src[0], src[1]);
         break;

      case VS_OPCODE_SET_SIMD4X2_HEADER_GEN9:
         generate_set_simd4x2_header_gen9(p, inst, dst);
         break;


      case VS_OPCODE_GET_BUFFER_SIZE:
         generate_get_buffer_size(p, prog_data, inst, dst, src[0], src[1]);
         break;

      case GS_OPCODE_URB_WRITE:
         generate_gs_urb_write(p, inst);
         break;

      case GS_OPCODE_URB_WRITE_ALLOCATE:
         generate_gs_urb_write_allocate(p, inst);
         break;

      case GS_OPCODE_SVB_WRITE:
         generate_gs_svb_write(p, prog_data, inst, dst, src[0], src[1]);
         break;

      case GS_OPCODE_SVB_SET_DST_INDEX:
         generate_gs_svb_set_destination_index(p, inst, dst, src[0]);
         break;

      case GS_OPCODE_THREAD_END:
         generate_gs_thread_end(p, inst);
         break;

      case GS_OPCODE_SET_WRITE_OFFSET:
         generate_gs_set_write_offset(p, dst, src[0], src[1]);
         break;

      case GS_OPCODE_SET_VERTEX_COUNT:
         generate_gs_set_vertex_count(p, dst, src[0]);
         break;

      case GS_OPCODE_FF_SYNC:
         generate_gs_ff_sync(p, inst, dst, src[0], src[1]);
         break;

      case GS_OPCODE_FF_SYNC_SET_PRIMITIVES:
         generate_gs_ff_sync_set_primitives(p, dst, src[0], src[1], src[2]);
         break;

      case GS_OPCODE_SET_PRIMITIVE_ID:
         generate_gs_set_primitive_id(p, dst);
         break;

      case GS_OPCODE_SET_DWORD_2:
         generate_gs_set_dword_2(p, dst, src[0]);
         break;

      case GS_OPCODE_PREPARE_CHANNEL_MASKS:
         generate_gs_prepare_channel_masks(p, dst);
         break;

      case GS_OPCODE_SET_CHANNEL_MASKS:
         generate_gs_set_channel_masks(p, dst, src[0]);
         break;

      case GS_OPCODE_GET_INSTANCE_ID:
         generate_gs_get_instance_id(p, dst);
         break;

      case SHADER_OPCODE_SHADER_TIME_ADD:
         brw_shader_time_add(p, src[0],
                             prog_data->base.binding_table.shader_time_start);
         brw_mark_surface_used(&prog_data->base,
                               prog_data->base.binding_table.shader_time_start);
         break;

      case SHADER_OPCODE_UNTYPED_ATOMIC:
         assert(src[2].file == BRW_IMMEDIATE_VALUE);
         brw_untyped_atomic(p, dst, src[0], src[1], src[2].ud, inst->mlen,
                            !inst->dst.is_null());
         break;

      case SHADER_OPCODE_UNTYPED_SURFACE_READ:
         assert(src[2].file == BRW_IMMEDIATE_VALUE);
         brw_untyped_surface_read(p, dst, src[0], src[1], inst->mlen,
                                  src[2].ud);
         break;

      case SHADER_OPCODE_UNTYPED_SURFACE_WRITE:
         assert(src[2].file == BRW_IMMEDIATE_VALUE);
         brw_untyped_surface_write(p, src[0], src[1], inst->mlen,
                                   src[2].ud);
         break;

      case SHADER_OPCODE_TYPED_ATOMIC:
         assert(src[2].file == BRW_IMMEDIATE_VALUE);
         brw_typed_atomic(p, dst, src[0], src[1], src[2].ud, inst->mlen,
                          !inst->dst.is_null());
         break;

      case SHADER_OPCODE_TYPED_SURFACE_READ:
         assert(src[2].file == BRW_IMMEDIATE_VALUE);
         brw_typed_surface_read(p, dst, src[0], src[1], inst->mlen,
                                src[2].ud);
         break;

      case SHADER_OPCODE_TYPED_SURFACE_WRITE:
         assert(src[2].file == BRW_IMMEDIATE_VALUE);
         brw_typed_surface_write(p, src[0], src[1], inst->mlen,
                                 src[2].ud);
         break;

      case SHADER_OPCODE_MEMORY_FENCE:
         brw_memory_fence(p, dst);
         break;

      case SHADER_OPCODE_FIND_LIVE_CHANNEL: {
         const struct brw_reg mask =
            brw_stage_has_packed_dispatch(devinfo, nir->stage,
                                          &prog_data->base) ? brw_imm_ud(~0u) :
            brw_dmask_reg();
         brw_find_live_channel(p, dst, mask);
         break;
      }

      case SHADER_OPCODE_BROADCAST:
         assert(inst->force_writemask_all);
         brw_broadcast(p, dst, src[0], src[1]);
         break;

      case VS_OPCODE_UNPACK_FLAGS_SIMD4X2:
         generate_unpack_flags(p, dst);
         break;

      case VEC4_OPCODE_MOV_BYTES: {
         /* Moves the low byte from each channel, using an Align1 access mode
          * and a <4,1,0> source region.
          */
         assert(src[0].type == BRW_REGISTER_TYPE_UB ||
                src[0].type == BRW_REGISTER_TYPE_B);

         brw_set_default_access_mode(p, BRW_ALIGN_1);
         src[0].vstride = BRW_VERTICAL_STRIDE_4;
         src[0].width = BRW_WIDTH_1;
         src[0].hstride = BRW_HORIZONTAL_STRIDE_0;
         brw_MOV(p, dst, src[0]);
         brw_set_default_access_mode(p, BRW_ALIGN_16);
         break;
      }

      case VEC4_OPCODE_PACK_BYTES: {
         /* Is effectively:
          *
          *   mov(8) dst<16,4,1>:UB src<4,1,0>:UB
          *
          * but destinations' only regioning is horizontal stride, so instead we
          * have to use two instructions:
          *
          *   mov(4) dst<1>:UB     src<4,1,0>:UB
          *   mov(4) dst.16<1>:UB  src.16<4,1,0>:UB
          *
          * where they pack the four bytes from the low and high four DW.
          */
         assert(_mesa_is_pow_two(dst.writemask) &&
                dst.writemask != 0);
         unsigned offset = __builtin_ctz(dst.writemask);

         dst.type = BRW_REGISTER_TYPE_UB;

         brw_set_default_access_mode(p, BRW_ALIGN_1);

         src[0].type = BRW_REGISTER_TYPE_UB;
         src[0].vstride = BRW_VERTICAL_STRIDE_4;
         src[0].width = BRW_WIDTH_1;
         src[0].hstride = BRW_HORIZONTAL_STRIDE_0;
         dst.subnr = offset * 4;
         struct brw_inst *insn = brw_MOV(p, dst, src[0]);
         brw_inst_set_exec_size(p->devinfo, insn, BRW_EXECUTE_4);
         brw_inst_set_no_dd_clear(p->devinfo, insn, true);
         brw_inst_set_no_dd_check(p->devinfo, insn, inst->no_dd_check);

         src[0].subnr = 16;
         dst.subnr = 16 + offset * 4;
         insn = brw_MOV(p, dst, src[0]);
         brw_inst_set_exec_size(p->devinfo, insn, BRW_EXECUTE_4);
         brw_inst_set_no_dd_clear(p->devinfo, insn, inst->no_dd_clear);
         brw_inst_set_no_dd_check(p->devinfo, insn, true);

         brw_set_default_access_mode(p, BRW_ALIGN_16);
         break;
      }

      case TCS_OPCODE_URB_WRITE:
         generate_tcs_urb_write(p, inst, src[0]);
         break;

      case VEC4_OPCODE_URB_READ:
         generate_vec4_urb_read(p, inst, dst, src[0]);
         break;

      case TCS_OPCODE_SET_INPUT_URB_OFFSETS:
         generate_tcs_input_urb_offsets(p, dst, src[0], src[1]);
         break;

      case TCS_OPCODE_SET_OUTPUT_URB_OFFSETS:
         generate_tcs_output_urb_offsets(p, dst, src[0], src[1]);
         break;

      case TCS_OPCODE_GET_INSTANCE_ID:
         generate_tcs_get_instance_id(p, dst);
         break;

      case TCS_OPCODE_GET_PRIMITIVE_ID:
         generate_tcs_get_primitive_id(p, dst);
         break;

      case TCS_OPCODE_CREATE_BARRIER_HEADER:
         generate_tcs_create_barrier_header(p, prog_data, dst);
         break;

      case TES_OPCODE_CREATE_INPUT_READ_HEADER:
         generate_tes_create_input_read_header(p, dst);
         break;

      case TES_OPCODE_ADD_INDIRECT_URB_OFFSET:
         generate_tes_add_indirect_urb_offset(p, dst, src[0], src[1]);
         break;

      case TES_OPCODE_GET_PRIMITIVE_ID:
         generate_tes_get_primitive_id(p, dst);
         break;

      case TCS_OPCODE_SRC0_010_IS_ZERO:
         /* If src_reg had stride like fs_reg, we wouldn't need this. */
         brw_MOV(p, brw_null_reg(), stride(src[0], 0, 1, 0));
         break;

      case TCS_OPCODE_RELEASE_INPUT:
         generate_tcs_release_input(p, dst, src[0], src[1]);
         break;

      case TCS_OPCODE_THREAD_END:
         generate_tcs_thread_end(p, inst);
         break;

      case SHADER_OPCODE_BARRIER:
         brw_barrier(p, src[0]);
         brw_WAIT(p);
         break;

      case SHADER_OPCODE_MOV_INDIRECT:
         generate_mov_indirect(p, inst, dst, src[0], src[1], src[2]);
         break;

      case BRW_OPCODE_DIM:
         assert(devinfo->is_haswell);
         assert(src[0].type == BRW_REGISTER_TYPE_DF);
         assert(dst.type == BRW_REGISTER_TYPE_DF);
         brw_DIM(p, dst, retype(src[0], BRW_REGISTER_TYPE_F));
         break;

      default:
         unreachable("Unsupported opcode");
      }

      if (inst->opcode == VEC4_OPCODE_PACK_BYTES) {
         /* Handled dependency hints in the generator. */

         assert(!inst->conditional_mod);
      } else if (inst->no_dd_clear || inst->no_dd_check || inst->conditional_mod) {
         assert(p->nr_insn == pre_emit_nr_insn + 1 ||
                !"conditional_mod, no_dd_check, or no_dd_clear set for IR "
                 "emitting more than 1 instruction");

         brw_inst *last = &p->store[pre_emit_nr_insn];

         if (inst->conditional_mod)
            brw_inst_set_cond_modifier(p->devinfo, last, inst->conditional_mod);
         brw_inst_set_no_dd_clear(p->devinfo, last, inst->no_dd_clear);
         brw_inst_set_no_dd_check(p->devinfo, last, inst->no_dd_check);
      }
   }

   brw_set_uip_jip(p, 0);
   annotation_finalize(&annotation, p->next_insn_offset);

#ifndef NDEBUG
   bool validated = brw_validate_instructions(p, 0, &annotation);
#else
   if (unlikely(debug_flag))
      brw_validate_instructions(p, 0, &annotation);
#endif

   int before_size = p->next_insn_offset;
   brw_compact_instructions(p, 0, annotation.ann_count, annotation.ann);
   int after_size = p->next_insn_offset;

   if (unlikely(debug_flag)) {
      fprintf(stderr, "Native code for %s %s shader %s:\n",
              nir->info.label ? nir->info.label : "unnamed",
              _mesa_shader_stage_to_string(nir->stage), nir->info.name);

      fprintf(stderr, "%s vec4 shader: %d instructions. %d loops. %u cycles. %d:%d "
                      "spills:fills. Compacted %d to %d bytes (%.0f%%)\n",
              stage_abbrev, before_size / 16, loop_count, cfg->cycle_count,
              spill_count, fill_count, before_size, after_size,
              100.0f * (before_size - after_size) / before_size);

      dump_assembly(p->store, annotation.ann_count, annotation.ann,
                    p->devinfo);
      ralloc_free(annotation.mem_ctx);
   }
   assert(validated);

   compiler->shader_debug_log(log_data,
                              "%s vec4 shader: %d inst, %d loops, %u cycles, "
                              "%d:%d spills:fills, compacted %d to %d bytes.",
                              stage_abbrev, before_size / 16,
                              loop_count, cfg->cycle_count, spill_count,
                              fill_count, before_size, after_size);

}

extern "C" const unsigned *
brw_vec4_generate_assembly(const struct brw_compiler *compiler,
                           void *log_data,
                           void *mem_ctx,
                           const nir_shader *nir,
                           struct brw_vue_prog_data *prog_data,
                           const struct cfg_t *cfg,
                           unsigned *out_assembly_size)
{
   struct brw_codegen *p = rzalloc(mem_ctx, struct brw_codegen);
   brw_init_codegen(compiler->devinfo, p, mem_ctx);
   brw_set_default_access_mode(p, BRW_ALIGN_16);

   generate_code(p, compiler, log_data, nir, prog_data, cfg);

   return brw_get_program(p, out_assembly_size);
}
@


1.2
log
@Merge Mesa 17.1.6
@
text
@a22 1
#include <ctype.h>
a24 2

extern "C" {
d26 1
a26 24
#include "main/macros.h"
#include "program/prog_print.h"
#include "program/prog_parameter.h"
};

namespace brw {

struct brw_reg
vec4_instruction::get_dst(void)
{
   struct brw_reg brw_reg;

   switch (dst.file) {
   case GRF:
      brw_reg = brw_vec8_grf(dst.reg + dst.reg_offset, 0);
      brw_reg = retype(brw_reg, dst.type);
      brw_reg.dw1.bits.writemask = dst.writemask;
      break;

   case MRF:
      brw_reg = brw_message_reg(dst.reg + dst.reg_offset);
      brw_reg = retype(brw_reg, dst.type);
      brw_reg.dw1.bits.writemask = dst.writemask;
      break;
d28 1
a28 4
   case HW_REG:
      assert(dst.type == dst.fixed_hw_reg.type);
      brw_reg = dst.fixed_hw_reg;
      break;
d30 5
a34 104
   case BAD_FILE:
      brw_reg = brw_null_reg();
      break;

   default:
      unreachable("not reached");
   }
   return brw_reg;
}

struct brw_reg
vec4_instruction::get_src(const struct brw_vue_prog_data *prog_data, int i)
{
   struct brw_reg brw_reg;

   switch (src[i].file) {
   case GRF:
      brw_reg = brw_vec8_grf(src[i].reg + src[i].reg_offset, 0);
      brw_reg = retype(brw_reg, src[i].type);
      brw_reg.dw1.bits.swizzle = src[i].swizzle;
      if (src[i].abs)
	 brw_reg = brw_abs(brw_reg);
      if (src[i].negate)
	 brw_reg = negate(brw_reg);
      break;

   case IMM:
      switch (src[i].type) {
      case BRW_REGISTER_TYPE_F:
	 brw_reg = brw_imm_f(src[i].fixed_hw_reg.dw1.f);
	 break;
      case BRW_REGISTER_TYPE_D:
	 brw_reg = brw_imm_d(src[i].fixed_hw_reg.dw1.d);
	 break;
      case BRW_REGISTER_TYPE_UD:
	 brw_reg = brw_imm_ud(src[i].fixed_hw_reg.dw1.ud);
	 break;
      case BRW_REGISTER_TYPE_VF:
         brw_reg = brw_imm_vf(src[i].fixed_hw_reg.dw1.ud);
         break;
      default:
	 unreachable("not reached");
      }
      break;

   case UNIFORM:
      brw_reg = stride(brw_vec4_grf(prog_data->base.dispatch_grf_start_reg +
                                    (src[i].reg + src[i].reg_offset) / 2,
				    ((src[i].reg + src[i].reg_offset) % 2) * 4),
		       0, 4, 1);
      brw_reg = retype(brw_reg, src[i].type);
      brw_reg.dw1.bits.swizzle = src[i].swizzle;
      if (src[i].abs)
	 brw_reg = brw_abs(brw_reg);
      if (src[i].negate)
	 brw_reg = negate(brw_reg);

      /* This should have been moved to pull constants. */
      assert(!src[i].reladdr);
      break;

   case HW_REG:
      assert(src[i].type == src[i].fixed_hw_reg.type);
      brw_reg = src[i].fixed_hw_reg;
      break;

   case BAD_FILE:
      /* Probably unused. */
      brw_reg = brw_null_reg();
      break;
   case ATTR:
   default:
      unreachable("not reached");
   }

   return brw_reg;
}

vec4_generator::vec4_generator(const struct brw_compiler *compiler,
                               void *log_data,
                               struct gl_shader_program *shader_prog,
                               struct gl_program *prog,
                               struct brw_vue_prog_data *prog_data,
                               void *mem_ctx,
                               bool debug_flag,
                               const char *stage_name,
                               const char *stage_abbrev)
   : compiler(compiler), log_data(log_data), devinfo(compiler->devinfo),
     shader_prog(shader_prog), prog(prog), prog_data(prog_data),
     mem_ctx(mem_ctx), stage_name(stage_name), stage_abbrev(stage_abbrev),
     debug_flag(debug_flag)
{
   p = rzalloc(mem_ctx, struct brw_codegen);
   brw_init_codegen(devinfo, p, mem_ctx);
}

vec4_generator::~vec4_generator()
{
}

void
vec4_generator::generate_math1_gen4(vec4_instruction *inst,
                                    struct brw_reg dst,
                                    struct brw_reg src)
d50 1
a50 1
   assert(src.dw1.bits.swizzle == BRW_SWIZZLE_XYZW);
d53 6
a58 5
void
vec4_generator::generate_math_gen6(vec4_instruction *inst,
                                   struct brw_reg dst,
                                   struct brw_reg src0,
                                   struct brw_reg src1)
d61 1
a61 1
   assert(dst.dw1.bits.writemask == WRITEMASK_XYZW);
d72 6
a77 5
void
vec4_generator::generate_math2_gen4(vec4_instruction *inst,
                                    struct brw_reg dst,
                                    struct brw_reg src0,
                                    struct brw_reg src1)
d106 9
a114 5
void
vec4_generator::generate_tex(vec4_instruction *inst,
                             struct brw_reg dst,
                             struct brw_reg src,
                             struct brw_reg sampler_index)
d116 1
d141 4
d172 3
d242 8
a249 1
         if (dw2)
d251 1
d277 4
a280 2
   if (sampler_index.file == BRW_IMMEDIATE_VALUE) {
      uint32_t sampler = sampler_index.dw1.ud;
d286 1
a286 1
                 sampler + base_binding_table_index,
d300 1
d307 10
a316 2
      /* addr = ((sampler * 0x101) + base_binding_table_index) & 0xfff */
      brw_MUL(p, addr, sampler_reg, brw_imm_uw(0x101));
d345 2
a346 2
void
vec4_generator::generate_vs_urb_write(vec4_instruction *inst)
d359 2
a360 2
void
vec4_generator::generate_gs_urb_write(vec4_instruction *inst)
d374 2
a375 2
void
vec4_generator::generate_gs_urb_write_allocate(vec4_instruction *inst)
d381 1
a381 1
                 inst->get_src(this->prog_data, 0), /* dest */
d394 2
a395 3
   brw_MOV(p, get_element_ud(inst->get_dst(), 0),
           get_element_ud(inst->get_src(this->prog_data, 0), 0));
   brw_set_default_access_mode(p, BRW_ALIGN_16);
d399 2
a400 2
void
vec4_generator::generate_gs_thread_end(vec4_instruction *inst)
d408 1
a408 1
                 devinfo->gen >= 8 ? 2 : 1,/* message len */
d414 5
a418 4
void
vec4_generator::generate_gs_set_write_offset(struct brw_reg dst,
                                             struct brw_reg src0,
                                             struct brw_reg src1)
d441 1
a441 1
   assert(devinfo->gen >= 7 &&
d444 8
a451 4
          src1.dw1.ud <= USHRT_MAX);
   brw_MUL(p, suboffset(stride(dst, 2, 2, 1), 3), stride(src0, 8, 2, 4),
           retype(src1, BRW_REGISTER_TYPE_UW));
   brw_set_default_access_mode(p, BRW_ALIGN_16);
d455 4
a458 3
void
vec4_generator::generate_gs_set_vertex_count(struct brw_reg dst,
                                             struct brw_reg src)
d463 1
a463 1
   if (devinfo->gen >= 8) {
a484 1
      brw_set_default_access_mode(p, BRW_ALIGN_16);
d489 7
a495 5
void
vec4_generator::generate_gs_svb_write(vec4_instruction *inst,
                                      struct brw_reg dst,
                                      struct brw_reg src0,
                                      struct brw_reg src1)
d501 1
d505 1
d507 1
d532 5
a536 4
void
vec4_generator::generate_gs_svb_set_destination_index(vec4_instruction *inst,
                                                      struct brw_reg dst,
                                                      struct brw_reg src)
a537 1

d546 4
a549 2
void
vec4_generator::generate_gs_set_dword_2(struct brw_reg dst, struct brw_reg src)
d558 3
a560 2
void
vec4_generator::generate_gs_prepare_channel_masks(struct brw_reg dst)
d576 4
a579 3
void
vec4_generator::generate_gs_set_channel_masks(struct brw_reg dst,
                                              struct brw_reg src)
d640 3
a642 2
void
vec4_generator::generate_gs_get_instance_id(struct brw_reg dst)
d658 6
a663 5
void
vec4_generator::generate_gs_ff_sync_set_primitives(struct brw_reg dst,
                                                   struct brw_reg src0,
                                                   struct brw_reg src1,
                                                   struct brw_reg src2)
d680 6
a685 5
void
vec4_generator::generate_gs_ff_sync(vec4_instruction *inst,
                                    struct brw_reg dst,
                                    struct brw_reg src0,
                                    struct brw_reg src1)
d721 2
a722 1
   if (src1.file != BRW_IMMEDIATE_VALUE)
d724 1
d729 2
a730 2
void
vec4_generator::generate_gs_set_primitive_id(struct brw_reg dst)
d741 339
a1079 3
void
vec4_generator::generate_oword_dual_block_offsets(struct brw_reg m1,
                                                  struct brw_reg index)
d1083 1
a1083 1
   if (devinfo->gen >= 6)
d1105 1
a1105 1
      index_4.dw1.ud += second_vertex_offset;
d1114 3
a1116 2
void
vec4_generator::generate_unpack_flags(struct brw_reg dst)
d1133 5
a1137 4
void
vec4_generator::generate_scratch_read(vec4_instruction *inst,
                                      struct brw_reg dst,
                                      struct brw_reg index)
d1139 1
d1144 1
a1144 1
   generate_oword_dual_block_offsets(brw_message_reg(inst->base_mrf + 1),
d1156 4
d1167 1
a1167 1
      brw_inst_set_cond_modifier(p->devinfo, send, inst->base_mrf);
d1169 1
a1169 1
			   255, /* binding table index: stateless access */
d1171 1
a1171 2
			   msg_type,
			   BRW_DATAPORT_READ_TARGET_RENDER_CACHE,
d1177 6
a1182 5
void
vec4_generator::generate_scratch_write(vec4_instruction *inst,
                                       struct brw_reg dst,
                                       struct brw_reg src,
                                       struct brw_reg index)
d1184 1
d1195 1
a1195 1
   generate_oword_dual_block_offsets(brw_message_reg(inst->base_mrf + 1),
d1241 1
a1241 1
			    255, /* binding table index: stateless access */
d1252 7
a1258 5
void
vec4_generator::generate_pull_constant_load(vec4_instruction *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset)
d1260 1
d1263 1
a1263 1
   uint32_t surf_index = index.dw1.ud;
d1269 15
a1283 2
   brw_MOV(p, retype(brw_message_reg(inst->base_mrf + 1), BRW_REGISTER_TYPE_D),
	   offset);
d1310 1
d1312 26
a1337 1
   brw_mark_surface_used(&prog_data->base, surf_index);
d1340 7
a1346 5
void
vec4_generator::generate_pull_constant_load_gen7(vec4_instruction *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg surf_index,
                                                 struct brw_reg offset)
d1356 1
a1356 1
                              surf_index.dw1.ud,
d1365 1
a1365 1
      brw_mark_surface_used(&prog_data->base, surf_index.dw1.ud);
a1395 4

      /* visitor knows more than we do about the surface limit required,
       * so has already done marking.
       */
d1399 4
a1402 3
void
vec4_generator::generate_set_simd4x2_header_gen9(vec4_instruction *inst,
                                                 struct brw_reg dst)
d1417 5
a1421 2
void
vec4_generator::generate_code(const cfg_t *cfg)
d1423 69
d1494 1
d1504 1
a1504 1
	 src[i] = inst->get_src(this->prog_data, i);
d1506 1
a1506 1
      dst = inst->get_dst();
d1515 3
a1519 25
      if (dst.width == BRW_WIDTH_4) {
         /* This happens in attribute fixups for "dual instanced" geometry
          * shaders, since they use attributes that are vec4's.  Since the exec
          * width is only 4, it's essential that the caller set
          * force_writemask_all in order to make sure the instruction is executed
          * regardless of which channels are enabled.
          */
         assert(inst->force_writemask_all);

         /* Fix up any <8;8,1> or <0;4,1> source registers to <4;4,1> to satisfy
          * the following register region restrictions (from Graphics BSpec:
          * 3D-Media-GPGPU Engine > EU Overview > Registers and Register Regions
          * > Register Region Restrictions)
          *
          *     1. ExecSize must be greater than or equal to Width.
          *
          *     2. If ExecSize = Width and HorzStride != 0, VertStride must be set
          *        to Width * HorzStride."
          */
         for (int i = 0; i < 3; i++) {
            if (src[i].file == BRW_GENERAL_REGISTER_FILE)
               src[i] = stride(src[i], 4, 4, 1);
         }
      }

d1629 3
d1664 1
a1664 1
         if (inst->src[0].file != BAD_FILE) {
d1711 1
a1711 1
            generate_math_gen6(inst, dst, src[0], brw_null_reg());
d1713 1
a1713 1
            generate_math1_gen4(inst, dst, src[0]);
d1724 1
a1724 1
            generate_math_gen6(inst, dst, src[0], src[1]);
d1726 1
a1726 1
            generate_math2_gen4(inst, dst, src[0], src[1]);
d1734 1
d1740 3
a1742 1
         generate_tex(inst, dst, src[0], src[1]);
d1746 1
a1746 1
         generate_vs_urb_write(inst);
d1750 2
a1751 1
         generate_scratch_read(inst, dst, src[0]);
d1755 2
a1756 1
         generate_scratch_write(inst, dst, src[0], src[1]);
d1760 1
a1760 1
         generate_pull_constant_load(inst, dst, src[0], src[1]);
d1764 1
a1764 1
         generate_pull_constant_load_gen7(inst, dst, src[0], src[1]);
d1768 6
a1773 1
         generate_set_simd4x2_header_gen9(inst, dst);
d1777 1
a1777 1
         generate_gs_urb_write(inst);
d1781 1
a1781 1
         generate_gs_urb_write_allocate(inst);
d1785 1
a1785 1
         generate_gs_svb_write(inst, dst, src[0], src[1]);
d1789 1
a1789 1
         generate_gs_svb_set_destination_index(inst, dst, src[0]);
d1793 1
a1793 1
         generate_gs_thread_end(inst);
d1797 1
a1797 1
         generate_gs_set_write_offset(dst, src[0], src[1]);
d1801 1
a1801 1
         generate_gs_set_vertex_count(dst, src[0]);
d1805 1
a1805 1
         generate_gs_ff_sync(inst, dst, src[0], src[1]);
d1809 1
a1809 1
         generate_gs_ff_sync_set_primitives(dst, src[0], src[1], src[2]);
d1813 1
a1813 1
         generate_gs_set_primitive_id(dst);
d1817 1
a1817 1
         generate_gs_set_dword_2(dst, src[0]);
d1821 1
a1821 1
         generate_gs_prepare_channel_masks(dst);
d1825 1
a1825 1
         generate_gs_set_channel_masks(dst, src[0]);
d1829 1
a1829 1
         generate_gs_get_instance_id(dst);
d1841 1
a1841 1
         brw_untyped_atomic(p, dst, src[0], src[1], src[2].dw1.ud, inst->mlen,
d1848 1
a1848 1
                                  src[2].dw1.ud);
d1854 1
a1854 1
                                   src[2].dw1.ud);
d1859 1
a1859 1
         brw_typed_atomic(p, dst, src[0], src[1], src[2].dw1.ud, inst->mlen,
d1866 1
a1866 1
                                src[2].dw1.ud);
d1872 1
a1872 1
                                 src[2].dw1.ud);
d1879 6
a1884 2
      case SHADER_OPCODE_FIND_LIVE_CHANNEL:
         brw_find_live_channel(p, dst);
d1886 1
d1889 1
d1894 1
a1894 1
         generate_unpack_flags(dst);
d1926 3
a1928 3
         assert(_mesa_is_pow_two(dst.dw1.bits.writemask) &&
                dst.dw1.bits.writemask != 0);
         unsigned offset = __builtin_ctz(dst.dw1.bits.writemask);
d1955 69
d2046 1
a2046 1
   brw_set_uip_jip(p);
d2049 7
d2061 8
a2068 12
      if (shader_prog) {
         fprintf(stderr, "Native code for %s %s shader %d:\n",
                 shader_prog->Label ? shader_prog->Label : "unnamed",
                 stage_name, shader_prog->Name);
      } else {
         fprintf(stderr, "Native code for %s program %d:\n", stage_name,
                 prog->Id);
      }
      fprintf(stderr, "%s vec4 shader: %d instructions. %d loops. Compacted %d to %d"
                      " bytes (%.0f%%)\n",
              stage_abbrev,
              before_size / 16, loop_count, before_size, after_size,
d2072 2
a2073 2
                    p->devinfo, prog);
      ralloc_free(annotation.ann);
d2075 1
d2078 6
a2083 4
                              "%s vec4 shader: %d inst, %d loops, "
                              "compacted %d to %d bytes.\n",
                              stage_abbrev, before_size / 16, loop_count,
                              before_size, after_size);
d2086 8
a2093 3
const unsigned *
vec4_generator::generate_assembly(const cfg_t *cfg,
                                  unsigned *assembly_size)
d2095 2
a2097 1
   generate_code(cfg);
d2099 3
a2101 1
   return brw_get_program(p, assembly_size);
a2102 2

} /* namespace brw */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d23 1
d26 2
d29 125
a153 1
#include "brw_program.h"
d155 3
a157 1
using namespace brw;
d159 4
a162 5
static void
generate_math1_gen4(struct brw_codegen *p,
                    vec4_instruction *inst,
                    struct brw_reg dst,
                    struct brw_reg src)
d178 1
a178 1
   assert(src.swizzle == BRW_SWIZZLE_XYZW);
d181 5
a185 6
static void
generate_math_gen6(struct brw_codegen *p,
                   vec4_instruction *inst,
                   struct brw_reg dst,
                   struct brw_reg src0,
                   struct brw_reg src1)
d188 1
a188 1
   assert(dst.writemask == WRITEMASK_XYZW);
d199 5
a203 6
static void
generate_math2_gen4(struct brw_codegen *p,
                    vec4_instruction *inst,
                    struct brw_reg dst,
                    struct brw_reg src0,
                    struct brw_reg src1)
d232 5
a236 8
static void
generate_tex(struct brw_codegen *p,
             struct brw_vue_prog_data *prog_data,
             vec4_instruction *inst,
             struct brw_reg dst,
             struct brw_reg src,
             struct brw_reg surface_index,
             struct brw_reg sampler_index)
a237 1
   const struct brw_device_info *devinfo = p->devinfo;
a261 4
      case SHADER_OPCODE_TXF_CMS_W:
         assert(devinfo->gen >= 9);
         msg_type = GEN9_SAMPLER_MESSAGE_SAMPLE_LD2DMS_W;
         break;
a288 3
      case SHADER_OPCODE_SAMPLEINFO:
         msg_type = GEN6_SAMPLER_MESSAGE_SAMPLE_SAMPLEINFO;
         break;
d383 2
a384 4
   if (surface_index.file == BRW_IMMEDIATE_VALUE &&
       sampler_index.file == BRW_IMMEDIATE_VALUE) {
      uint32_t surface = surface_index.ud;
      uint32_t sampler = sampler_index.ud;
d390 1
a390 1
                 surface + base_binding_table_index,
a403 1
      struct brw_reg surface_reg = vec1(retype(surface_index, BRW_REGISTER_TYPE_UD));
d410 2
a411 6
      if (memcmp(&surface_reg, &sampler_reg, sizeof(surface_reg)) == 0) {
         brw_MUL(p, addr, sampler_reg, brw_imm_uw(0x101));
      } else {
         brw_SHL(p, addr, sampler_reg, brw_imm_ud(8));
         brw_OR(p, addr, addr, surface_reg);
      }
d440 2
a441 2
static void
generate_vs_urb_write(struct brw_codegen *p, vec4_instruction *inst)
d454 2
a455 2
static void
generate_gs_urb_write(struct brw_codegen *p, vec4_instruction *inst)
d469 2
a470 2
static void
generate_gs_urb_write_allocate(struct brw_codegen *p, vec4_instruction *inst)
d476 1
a476 1
                 inst->src[0].as_brw_reg(), /* dest */
d489 3
a491 2
   brw_MOV(p, get_element_ud(inst->dst.as_brw_reg(), 0),
           get_element_ud(inst->src[0].as_brw_reg(), 0));
d495 2
a496 2
static void
generate_gs_thread_end(struct brw_codegen *p, vec4_instruction *inst)
d504 1
a504 1
                 inst->mlen,
d510 4
a513 5
static void
generate_gs_set_write_offset(struct brw_codegen *p,
                             struct brw_reg dst,
                             struct brw_reg src0,
                             struct brw_reg src1)
d536 1
a536 1
   assert(p->devinfo->gen >= 7 &&
d539 4
a542 8
          src1.ud <= USHRT_MAX);
   if (src0.file == BRW_IMMEDIATE_VALUE) {
      brw_MOV(p, suboffset(stride(dst, 2, 2, 1), 3),
              brw_imm_ud(src0.ud * src1.ud));
   } else {
      brw_MUL(p, suboffset(stride(dst, 2, 2, 1), 3), stride(src0, 8, 2, 4),
              retype(src1, BRW_REGISTER_TYPE_UW));
   }
d546 3
a548 4
static void
generate_gs_set_vertex_count(struct brw_codegen *p,
                             struct brw_reg dst,
                             struct brw_reg src)
d553 1
a553 1
   if (p->devinfo->gen >= 8) {
d575 1
d580 5
a584 7
static void
generate_gs_svb_write(struct brw_codegen *p,
                      struct brw_vue_prog_data *prog_data,
                      vec4_instruction *inst,
                      struct brw_reg dst,
                      struct brw_reg src0,
                      struct brw_reg src1)
d618 4
a621 5
static void
generate_gs_svb_set_destination_index(struct brw_codegen *p,
                                      vec4_instruction *inst,
                                      struct brw_reg dst,
                                      struct brw_reg src)
d623 1
d632 2
a633 4
static void
generate_gs_set_dword_2(struct brw_codegen *p,
                        struct brw_reg dst,
                        struct brw_reg src)
d642 2
a643 3
static void
generate_gs_prepare_channel_masks(struct brw_codegen *p,
                                  struct brw_reg dst)
d659 3
a661 4
static void
generate_gs_set_channel_masks(struct brw_codegen *p,
                              struct brw_reg dst,
                              struct brw_reg src)
d722 2
a723 3
static void
generate_gs_get_instance_id(struct brw_codegen *p,
                            struct brw_reg dst)
d739 5
a743 6
static void
generate_gs_ff_sync_set_primitives(struct brw_codegen *p,
                                   struct brw_reg dst,
                                   struct brw_reg src0,
                                   struct brw_reg src1,
                                   struct brw_reg src2)
d760 5
a764 6
static void
generate_gs_ff_sync(struct brw_codegen *p,
                    vec4_instruction *inst,
                    struct brw_reg dst,
                    struct brw_reg src0,
                    struct brw_reg src1)
d806 2
a807 2
static void
generate_gs_set_primitive_id(struct brw_codegen *p, struct brw_reg dst)
d818 3
a820 339
static void
generate_tcs_get_instance_id(struct brw_codegen *p, struct brw_reg dst)
{
   const struct brw_device_info *devinfo = p->devinfo;
   const bool ivb = devinfo->is_ivybridge || devinfo->is_baytrail;

   /* "Instance Count" comes as part of the payload in r0.2 bits 23:17.
    *
    * Since we operate in SIMD4x2 mode, we need run half as many threads
    * as necessary.  So we assign (2i + 1, 2i) as the thread counts.  We
    * shift right by one less to accomplish the multiplication by two.
    */
   dst = retype(dst, BRW_REGISTER_TYPE_UD);
   struct brw_reg r0(retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);

   const int mask = ivb ? INTEL_MASK(22, 16) : INTEL_MASK(23, 17);
   const int shift = ivb ? 16 : 17;

   brw_AND(p, get_element_ud(dst, 0), get_element_ud(r0, 2), brw_imm_ud(mask));
   brw_SHR(p, get_element_ud(dst, 0), get_element_ud(dst, 0),
           brw_imm_ud(shift - 1));
   brw_ADD(p, get_element_ud(dst, 4), get_element_ud(dst, 0), brw_imm_ud(1));

   brw_pop_insn_state(p);
}

static void
generate_tcs_urb_write(struct brw_codegen *p,
                       vec4_instruction *inst,
                       struct brw_reg urb_header)
{
   const struct brw_device_info *devinfo = p->devinfo;

   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, brw_null_reg());
   brw_set_src0(p, send, urb_header);

   brw_set_message_descriptor(p, send, BRW_SFID_URB,
                              inst->mlen /* mlen */, 0 /* rlen */,
                              true /* header */, false /* eot */);
   brw_inst_set_urb_opcode(devinfo, send, BRW_URB_OPCODE_WRITE_OWORD);
   brw_inst_set_urb_global_offset(devinfo, send, inst->offset);
   if (inst->urb_write_flags & BRW_URB_WRITE_EOT) {
      brw_inst_set_eot(devinfo, send, 1);
   } else {
      brw_inst_set_urb_per_slot_offset(devinfo, send, 1);
      brw_inst_set_urb_swizzle_control(devinfo, send, BRW_URB_SWIZZLE_INTERLEAVE);
   }

   /* what happens to swizzles? */
}


static void
generate_tcs_input_urb_offsets(struct brw_codegen *p,
                               struct brw_reg dst,
                               struct brw_reg vertex,
                               struct brw_reg offset)
{
   /* Generates an URB read/write message header for HS/DS operation.
    * Inputs are a vertex index, and a byte offset from the beginning of
    * the vertex. */

   /* If `vertex` is not an immediate, we clobber a0.0 */

   assert(vertex.file == BRW_IMMEDIATE_VALUE || vertex.file == BRW_GENERAL_REGISTER_FILE);
   assert(vertex.type == BRW_REGISTER_TYPE_UD || vertex.type == BRW_REGISTER_TYPE_D);

   assert(dst.file == BRW_GENERAL_REGISTER_FILE);

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, dst, brw_imm_ud(0));

   /* m0.5 bits 8-15 are channel enables */
   brw_MOV(p, get_element_ud(dst, 5), brw_imm_ud(0xff00));

   /* m0.0-0.1: URB handles */
   if (vertex.file == BRW_IMMEDIATE_VALUE) {
      uint32_t vertex_index = vertex.ud;
      struct brw_reg index_reg = brw_vec1_grf(
            1 + (vertex_index >> 3), vertex_index & 7);

      brw_MOV(p, vec2(get_element_ud(dst, 0)),
              retype(index_reg, BRW_REGISTER_TYPE_UD));
   } else {
      /* Use indirect addressing.  ICP Handles are DWords (single channels
       * of a register) and start at g1.0.
       *
       * In order to start our region at g1.0, we add 8 to the vertex index,
       * effectively skipping over the 8 channels in g0.0.  This gives us a
       * DWord offset to the ICP Handle.
       *
       * Indirect addressing works in terms of bytes, so we then multiply
       * the DWord offset by 4 (by shifting left by 2).
       */
      struct brw_reg addr = brw_address_reg(0);

      /* bottom half: m0.0 = g[1.0 + vertex.0]UD */
      brw_ADD(p, addr, get_element_ud(vertex, 0), brw_imm_uw(0x8));
      brw_SHL(p, addr, addr, brw_imm_ud(2));
      brw_MOV(p, get_element_ud(dst, 0), deref_1ud(brw_indirect(0, 0), 0));

      /* top half: m0.1 = g[1.0 + vertex.4]UD */
      brw_ADD(p, addr, get_element_ud(vertex, 4), brw_imm_uw(0x8));
      brw_SHL(p, addr, addr, brw_imm_ud(2));
      brw_MOV(p, get_element_ud(dst, 1), deref_1ud(brw_indirect(0, 0), 0));
   }

   /* m0.3-0.4: 128bit-granular offsets into the URB from the handles */
   if (offset.file != ARF)
      brw_MOV(p, vec2(get_element_ud(dst, 3)), stride(offset, 4, 1, 0));

   brw_pop_insn_state(p);
}


static void
generate_tcs_output_urb_offsets(struct brw_codegen *p,
                                struct brw_reg dst,
                                struct brw_reg write_mask,
                                struct brw_reg offset)
{
   /* Generates an URB read/write message header for HS/DS operation, for the patch URB entry. */
   assert(dst.file == BRW_GENERAL_REGISTER_FILE || dst.file == BRW_MESSAGE_REGISTER_FILE);

   assert(write_mask.file == BRW_IMMEDIATE_VALUE);
   assert(write_mask.type == BRW_REGISTER_TYPE_UD);

   brw_push_insn_state(p);

   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, dst, brw_imm_ud(0));

   unsigned mask = write_mask.ud;

   /* m0.5 bits 15:12 and 11:8 are channel enables */
   brw_MOV(p, get_element_ud(dst, 5), brw_imm_ud((mask << 8) | (mask << 12)));

   /* HS patch URB handle is delivered in r0.0 */
   struct brw_reg urb_handle = brw_vec1_grf(0, 0);

   /* m0.0-0.1: URB handles */
   brw_MOV(p, vec2(get_element_ud(dst, 0)),
           retype(urb_handle, BRW_REGISTER_TYPE_UD));

   /* m0.3-0.4: 128bit-granular offsets into the URB from the handles */
   if (offset.file != ARF)
      brw_MOV(p, vec2(get_element_ud(dst, 3)), stride(offset, 4, 1, 0));

   brw_pop_insn_state(p);
}

static void
generate_tes_create_input_read_header(struct brw_codegen *p,
                                      struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   /* Initialize the register to 0 */
   brw_MOV(p, dst, brw_imm_ud(0));

   /* Enable all the channels in m0.5 bits 15:8 */
   brw_MOV(p, get_element_ud(dst, 5), brw_imm_ud(0xff00));

   /* Copy g1.3 (the patch URB handle) to m0.0 and m0.1.  For safety,
    * mask out irrelevant "Reserved" bits, as they're not marked MBZ.
    */
   brw_AND(p, vec2(get_element_ud(dst, 0)),
           retype(brw_vec1_grf(1, 3), BRW_REGISTER_TYPE_UD),
           brw_imm_ud(0x1fff));
   brw_pop_insn_state(p);
}

static void
generate_tes_add_indirect_urb_offset(struct brw_codegen *p,
                                     struct brw_reg dst,
                                     struct brw_reg header,
                                     struct brw_reg offset)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   brw_MOV(p, dst, header);
   /* m0.3-0.4: 128-bit-granular offsets into the URB from the handles */
   brw_MOV(p, vec2(get_element_ud(dst, 3)), stride(offset, 4, 1, 0));

   brw_pop_insn_state(p);
}

static void
generate_vec4_urb_read(struct brw_codegen *p,
                       vec4_instruction *inst,
                       struct brw_reg dst,
                       struct brw_reg header)
{
   const struct brw_device_info *devinfo = p->devinfo;

   assert(header.file == BRW_GENERAL_REGISTER_FILE);
   assert(header.type == BRW_REGISTER_TYPE_UD);

   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, dst);
   brw_set_src0(p, send, header);

   brw_set_message_descriptor(p, send, BRW_SFID_URB,
                              1 /* mlen */, 1 /* rlen */,
                              true /* header */, false /* eot */);
   brw_inst_set_urb_opcode(devinfo, send, BRW_URB_OPCODE_READ_OWORD);
   brw_inst_set_urb_swizzle_control(devinfo, send, BRW_URB_SWIZZLE_INTERLEAVE);
   brw_inst_set_urb_per_slot_offset(devinfo, send, 1);

   brw_inst_set_urb_global_offset(devinfo, send, inst->offset);
}

static void
generate_tcs_release_input(struct brw_codegen *p,
                           struct brw_reg header,
                           struct brw_reg vertex,
                           struct brw_reg is_unpaired)
{
   const struct brw_device_info *devinfo = p->devinfo;

   assert(vertex.file == BRW_IMMEDIATE_VALUE);
   assert(vertex.type == BRW_REGISTER_TYPE_UD);

   /* m0.0-0.1: URB handles */
   struct brw_reg urb_handles =
      retype(brw_vec2_grf(1 + (vertex.ud >> 3), vertex.ud & 7),
             BRW_REGISTER_TYPE_UD);

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, header, brw_imm_ud(0));
   brw_MOV(p, vec2(get_element_ud(header, 0)), urb_handles);
   brw_pop_insn_state(p);

   brw_inst *send = brw_next_insn(p, BRW_OPCODE_SEND);
   brw_set_dest(p, send, brw_null_reg());
   brw_set_src0(p, send, header);
   brw_set_message_descriptor(p, send, BRW_SFID_URB,
                              1 /* mlen */, 0 /* rlen */,
                              true /* header */, false /* eot */);
   brw_inst_set_urb_opcode(devinfo, send, BRW_URB_OPCODE_READ_OWORD);
   brw_inst_set_urb_complete(devinfo, send, 1);
   brw_inst_set_urb_swizzle_control(devinfo, send, is_unpaired.ud ?
                                    BRW_URB_SWIZZLE_NONE :
                                    BRW_URB_SWIZZLE_INTERLEAVE);
}

static void
generate_tcs_thread_end(struct brw_codegen *p, vec4_instruction *inst)
{
   struct brw_reg header = brw_message_reg(inst->base_mrf);

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);
   brw_MOV(p, header, brw_imm_ud(0));
   brw_MOV(p, get_element_ud(header, 5), brw_imm_ud(WRITEMASK_X << 8));
   brw_MOV(p, get_element_ud(header, 0),
           retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD));
   brw_MOV(p, brw_message_reg(inst->base_mrf + 1), brw_imm_ud(0u));
   brw_pop_insn_state(p);

   brw_urb_WRITE(p,
                 brw_null_reg(), /* dest */
                 inst->base_mrf, /* starting mrf reg nr */
                 header,
                 BRW_URB_WRITE_EOT | BRW_URB_WRITE_OWORD |
                 BRW_URB_WRITE_USE_CHANNEL_MASKS,
                 inst->mlen,
                 0,              /* response len */
                 0,              /* urb destination offset */
                 0);
}

static void
generate_tes_get_primitive_id(struct brw_codegen *p, struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, dst, retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_D));
   brw_pop_insn_state(p);
}

static void
generate_tcs_get_primitive_id(struct brw_codegen *p, struct brw_reg dst)
{
   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_MOV(p, dst, retype(brw_vec1_grf(0, 1), BRW_REGISTER_TYPE_UD));
   brw_pop_insn_state(p);
}

static void
generate_tcs_create_barrier_header(struct brw_codegen *p,
                                   struct brw_vue_prog_data *prog_data,
                                   struct brw_reg dst)
{
   const struct brw_device_info *devinfo = p->devinfo;
   const bool ivb = devinfo->is_ivybridge || devinfo->is_baytrail;
   struct brw_reg m0_2 = get_element_ud(dst, 2);
   unsigned instances = ((struct brw_tcs_prog_data *) prog_data)->instances;

   brw_push_insn_state(p);
   brw_set_default_access_mode(p, BRW_ALIGN_1);
   brw_set_default_mask_control(p, BRW_MASK_DISABLE);

   /* Zero the message header */
   brw_MOV(p, retype(dst, BRW_REGISTER_TYPE_UD), brw_imm_ud(0u));

   /* Copy "Barrier ID" from r0.2, bits 16:13 (Gen7.5+) or 15:12 (Gen7) */
   brw_AND(p, m0_2,
           retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD),
           brw_imm_ud(ivb ? INTEL_MASK(15, 12) : INTEL_MASK(16, 13)));

   /* Shift it up to bits 27:24. */
   brw_SHL(p, m0_2, get_element_ud(dst, 2), brw_imm_ud(ivb ? 12 : 11));

   /* Set the Barrier Count and the enable bit */
   brw_OR(p, m0_2, m0_2, brw_imm_ud(instances << 9 | (1 << 15)));

   brw_pop_insn_state(p);
}

static void
generate_oword_dual_block_offsets(struct brw_codegen *p,
                                  struct brw_reg m1,
                                  struct brw_reg index)
d824 1
a824 1
   if (p->devinfo->gen >= 6)
d846 1
a846 1
      index_4.ud += second_vertex_offset;
d855 2
a856 3
static void
generate_unpack_flags(struct brw_codegen *p,
                      struct brw_reg dst)
d873 4
a876 5
static void
generate_scratch_read(struct brw_codegen *p,
                      vec4_instruction *inst,
                      struct brw_reg dst,
                      struct brw_reg index)
a877 1
   const struct brw_device_info *devinfo = p->devinfo;
d882 1
a882 1
   generate_oword_dual_block_offsets(p, brw_message_reg(inst->base_mrf + 1),
d901 1
a901 1
      brw_inst_set_cond_modifier(devinfo, send, inst->base_mrf);
d903 1
a903 1
                           brw_scratch_surface_idx(p),
d912 5
a916 6
static void
generate_scratch_write(struct brw_codegen *p,
                       vec4_instruction *inst,
                       struct brw_reg dst,
                       struct brw_reg src,
                       struct brw_reg index)
a917 1
   const struct brw_device_info *devinfo = p->devinfo;
d928 1
a928 1
   generate_oword_dual_block_offsets(p, brw_message_reg(inst->base_mrf + 1),
d974 1
a974 1
                            brw_scratch_surface_idx(p),
d985 5
a989 7
static void
generate_pull_constant_load(struct brw_codegen *p,
                            struct brw_vue_prog_data *prog_data,
                            vec4_instruction *inst,
                            struct brw_reg dst,
                            struct brw_reg index,
                            struct brw_reg offset)
a990 1
   const struct brw_device_info *devinfo = p->devinfo;
d993 1
a993 1
   uint32_t surf_index = index.ud;
d999 2
a1000 15
   if (devinfo->gen >= 6) {
      if (offset.file == BRW_IMMEDIATE_VALUE) {
         brw_MOV(p, retype(brw_message_reg(inst->base_mrf + 1),
                           BRW_REGISTER_TYPE_D),
                 brw_imm_d(offset.ud >> 4));
      } else {
         brw_SHR(p, retype(brw_message_reg(inst->base_mrf + 1),
                           BRW_REGISTER_TYPE_D),
                 offset, brw_imm_d(4));
      }
   } else {
      brw_MOV(p, retype(brw_message_reg(inst->base_mrf + 1),
                        BRW_REGISTER_TYPE_D),
              offset);
   }
a1026 26
}

static void
generate_get_buffer_size(struct brw_codegen *p,
                         struct brw_vue_prog_data *prog_data,
                         vec4_instruction *inst,
                         struct brw_reg dst,
                         struct brw_reg src,
                         struct brw_reg surf_index)
{
   assert(p->devinfo->gen >= 7);
   assert(surf_index.type == BRW_REGISTER_TYPE_UD &&
          surf_index.file == BRW_IMMEDIATE_VALUE);

   brw_SAMPLE(p,
              dst,
              inst->base_mrf,
              src,
              surf_index.ud,
              0,
              GEN5_SAMPLER_MESSAGE_SAMPLE_RESINFO,
              1, /* response length */
              inst->mlen,
              inst->header_size > 0,
              BRW_SAMPLER_SIMD_MODE_SIMD4X2,
              BRW_SAMPLER_RETURN_FORMAT_SINT32);
d1028 1
a1028 1
   brw_mark_surface_used(&prog_data->base, surf_index.ud);
d1031 5
a1035 7
static void
generate_pull_constant_load_gen7(struct brw_codegen *p,
                                 struct brw_vue_prog_data *prog_data,
                                 vec4_instruction *inst,
                                 struct brw_reg dst,
                                 struct brw_reg surf_index,
                                 struct brw_reg offset)
d1045 1
a1045 1
                              surf_index.ud,
d1054 1
a1054 1
      brw_mark_surface_used(&prog_data->base, surf_index.ud);
d1085 4
d1092 3
a1094 4
static void
generate_set_simd4x2_header_gen9(struct brw_codegen *p,
                                 vec4_instruction *inst,
                                 struct brw_reg dst)
d1109 3
a1111 12
static void
generate_code(struct brw_codegen *p,
              const struct brw_compiler *compiler,
              void *log_data,
              const nir_shader *nir,
              struct brw_vue_prog_data *prog_data,
              const struct cfg_t *cfg)
{
   const struct brw_device_info *devinfo = p->devinfo;
   const char *stage_abbrev = _mesa_shader_stage_to_abbrev(nir->stage);
   bool debug_flag = INTEL_DEBUG &
      intel_debug_flag_for_shader_stage(nir->stage);
d1123 1
a1123 1
         src[i] = inst->src[i].as_brw_reg();
d1125 1
a1125 1
      dst = inst->dst.as_brw_reg();
a1133 3
      assert(inst->base_mrf + inst->mlen <= BRW_MAX_MRF(devinfo->gen));
      assert(inst->mlen <= BRW_MAX_MSG_LENGTH);

d1302 1
a1302 1
         if (!inst->src[0].is_null()) {
d1349 1
a1349 1
            generate_math_gen6(p, inst, dst, src[0], brw_null_reg());
d1351 1
a1351 1
            generate_math1_gen4(p, inst, dst, src[0]);
d1362 1
a1362 1
            generate_math_gen6(p, inst, dst, src[0], src[1]);
d1364 1
a1364 1
            generate_math2_gen4(p, inst, dst, src[0], src[1]);
a1371 1
      case SHADER_OPCODE_TXF_CMS_W:
d1377 1
a1377 2
      case SHADER_OPCODE_SAMPLEINFO:
         generate_tex(p, prog_data, inst, dst, src[0], src[1], src[2]);
d1381 1
a1381 1
         generate_vs_urb_write(p, inst);
d1385 1
a1385 1
         generate_scratch_read(p, inst, dst, src[0]);
d1389 1
a1389 1
         generate_scratch_write(p, inst, dst, src[0], src[1]);
d1393 1
a1393 1
         generate_pull_constant_load(p, prog_data, inst, dst, src[0], src[1]);
d1397 1
a1397 1
         generate_pull_constant_load_gen7(p, prog_data, inst, dst, src[0], src[1]);
d1401 1
a1401 6
         generate_set_simd4x2_header_gen9(p, inst, dst);
         break;


      case VS_OPCODE_GET_BUFFER_SIZE:
         generate_get_buffer_size(p, prog_data, inst, dst, src[0], src[1]);
d1405 1
a1405 1
         generate_gs_urb_write(p, inst);
d1409 1
a1409 1
         generate_gs_urb_write_allocate(p, inst);
d1413 1
a1413 1
         generate_gs_svb_write(p, prog_data, inst, dst, src[0], src[1]);
d1417 1
a1417 1
         generate_gs_svb_set_destination_index(p, inst, dst, src[0]);
d1421 1
a1421 1
         generate_gs_thread_end(p, inst);
d1425 1
a1425 1
         generate_gs_set_write_offset(p, dst, src[0], src[1]);
d1429 1
a1429 1
         generate_gs_set_vertex_count(p, dst, src[0]);
d1433 1
a1433 1
         generate_gs_ff_sync(p, inst, dst, src[0], src[1]);
d1437 1
a1437 1
         generate_gs_ff_sync_set_primitives(p, dst, src[0], src[1], src[2]);
d1441 1
a1441 1
         generate_gs_set_primitive_id(p, dst);
d1445 1
a1445 1
         generate_gs_set_dword_2(p, dst, src[0]);
d1449 1
a1449 1
         generate_gs_prepare_channel_masks(p, dst);
d1453 1
a1453 1
         generate_gs_set_channel_masks(p, dst, src[0]);
d1457 1
a1457 1
         generate_gs_get_instance_id(p, dst);
d1469 1
a1469 1
         brw_untyped_atomic(p, dst, src[0], src[1], src[2].ud, inst->mlen,
d1476 1
a1476 1
                                  src[2].ud);
d1482 1
a1482 1
                                   src[2].ud);
d1487 1
a1487 1
         brw_typed_atomic(p, dst, src[0], src[1], src[2].ud, inst->mlen,
d1494 1
a1494 1
                                src[2].ud);
d1500 1
a1500 1
                                 src[2].ud);
d1516 1
a1516 1
         generate_unpack_flags(p, dst);
d1548 3
a1550 3
         assert(_mesa_is_pow_two(dst.writemask) &&
                dst.writemask != 0);
         unsigned offset = __builtin_ctz(dst.writemask);
a1576 59
      case TCS_OPCODE_URB_WRITE:
         generate_tcs_urb_write(p, inst, src[0]);
         break;

      case VEC4_OPCODE_URB_READ:
         generate_vec4_urb_read(p, inst, dst, src[0]);
         break;

      case TCS_OPCODE_SET_INPUT_URB_OFFSETS:
         generate_tcs_input_urb_offsets(p, dst, src[0], src[1]);
         break;

      case TCS_OPCODE_SET_OUTPUT_URB_OFFSETS:
         generate_tcs_output_urb_offsets(p, dst, src[0], src[1]);
         break;

      case TCS_OPCODE_GET_INSTANCE_ID:
         generate_tcs_get_instance_id(p, dst);
         break;

      case TCS_OPCODE_GET_PRIMITIVE_ID:
         generate_tcs_get_primitive_id(p, dst);
         break;

      case TCS_OPCODE_CREATE_BARRIER_HEADER:
         generate_tcs_create_barrier_header(p, prog_data, dst);
         break;

      case TES_OPCODE_CREATE_INPUT_READ_HEADER:
         generate_tes_create_input_read_header(p, dst);
         break;

      case TES_OPCODE_ADD_INDIRECT_URB_OFFSET:
         generate_tes_add_indirect_urb_offset(p, dst, src[0], src[1]);
         break;

      case TES_OPCODE_GET_PRIMITIVE_ID:
         generate_tes_get_primitive_id(p, dst);
         break;

      case TCS_OPCODE_SRC0_010_IS_ZERO:
         /* If src_reg had stride like fs_reg, we wouldn't need this. */
         brw_MOV(p, brw_null_reg(), stride(src[0], 0, 1, 0));
         brw_inst_set_cond_modifier(devinfo, brw_last_inst, BRW_CONDITIONAL_Z);
         break;

      case TCS_OPCODE_RELEASE_INPUT:
         generate_tcs_release_input(p, dst, src[0], src[1]);
         break;

      case TCS_OPCODE_THREAD_END:
         generate_tcs_thread_end(p, inst);
         break;

      case SHADER_OPCODE_BARRIER:
         brw_barrier(p, src[0]);
         brw_WAIT(p);
         break;

a1601 7
#ifndef NDEBUG
   bool validated = brw_validate_instructions(p, 0, &annotation);
#else
   if (unlikely(debug_flag))
      brw_validate_instructions(p, 0, &annotation);
#endif

d1607 10
a1616 6
      fprintf(stderr, "Native code for %s %s shader %s:\n",
              nir->info.label ? nir->info.label : "unnamed",
              _mesa_shader_stage_to_string(nir->stage), nir->info.name);

      fprintf(stderr, "%s vec4 shader: %d instructions. %d loops. %u cycles."
                      "Compacted %d to %d bytes (%.0f%%)\n",
d1618 1
a1618 1
              before_size / 16, loop_count, cfg->cycle_count, before_size, after_size,
d1622 2
a1623 2
                    p->devinfo);
      ralloc_free(annotation.mem_ctx);
a1624 1
   assert(validated);
d1627 3
a1629 4
                              "%s vec4 shader: %d inst, %d loops, %u cycles, "
                              "compacted %d to %d bytes.",
                              stage_abbrev, before_size / 16,
                              loop_count, cfg->cycle_count,
d1633 3
a1635 8
extern "C" const unsigned *
brw_vec4_generate_assembly(const struct brw_compiler *compiler,
                           void *log_data,
                           void *mem_ctx,
                           const nir_shader *nir,
                           struct brw_vue_prog_data *prog_data,
                           const struct cfg_t *cfg,
                           unsigned *out_assembly_size)
a1636 2
   struct brw_codegen *p = rzalloc(mem_ctx, struct brw_codegen);
   brw_init_codegen(compiler->devinfo, p, mem_ctx);
d1638 1
d1640 2
a1641 1
   generate_code(p, compiler, log_data, nir, prog_data, cfg);
d1643 1
a1643 2
   return brw_get_program(p, out_assembly_size);
}
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d115 1
a115 1
   const struct gen_device_info *devinfo = p->devinfo;
d298 1
a298 1
      if (brw_regs_equal(&surface_reg, &sampler_reg)) {
a487 1
   brw_set_default_exec_size(p, BRW_EXECUTE_4);
a490 1
   brw_pop_insn_state(p);
a491 1
   brw_push_insn_state(p);
d705 1
a705 2
   if (src1.file != BRW_IMMEDIATE_VALUE) {
      brw_set_default_exec_size(p, BRW_EXECUTE_4);
a706 1
   }
d726 1
a726 1
   const struct gen_device_info *devinfo = p->devinfo;
d757 1
a757 1
   const struct gen_device_info *devinfo = p->devinfo;
d927 1
a927 1
   const struct gen_device_info *devinfo = p->devinfo;
d952 1
a952 1
   const struct gen_device_info *devinfo = p->devinfo;
d1032 1
a1032 1
   const struct gen_device_info *devinfo = p->devinfo;
d1121 1
a1121 1
   const struct gen_device_info *devinfo = p->devinfo;
a1137 4
   const unsigned target_cache = devinfo->gen >= 7 ?
      BRW_DATAPORT_READ_TARGET_DATA_CACHE :
      BRW_DATAPORT_READ_TARGET_RENDER_CACHE;

d1149 2
a1150 1
			   msg_type, target_cache,
d1163 1
a1163 1
   const struct gen_device_info *devinfo = p->devinfo;
d1239 1
a1239 1
   const struct gen_device_info *devinfo = p->devinfo;
a1396 63
generate_mov_indirect(struct brw_codegen *p,
                      vec4_instruction *inst,
                      struct brw_reg dst, struct brw_reg reg,
                      struct brw_reg indirect, struct brw_reg length)
{
   assert(indirect.type == BRW_REGISTER_TYPE_UD);
   assert(p->devinfo->gen >= 6);

   unsigned imm_byte_offset = reg.nr * REG_SIZE + reg.subnr * (REG_SIZE / 2);

   /* This instruction acts in align1 mode */
   assert(dst.writemask == WRITEMASK_XYZW);

   if (indirect.file == BRW_IMMEDIATE_VALUE) {
      imm_byte_offset += indirect.ud;

      reg.nr = imm_byte_offset / REG_SIZE;
      reg.subnr = (imm_byte_offset / (REG_SIZE / 2)) % 2;
      unsigned shift = (imm_byte_offset / 4) % 4;
      reg.swizzle += BRW_SWIZZLE4(shift, shift, shift, shift);

      brw_MOV(p, dst, reg);
   } else {
      brw_push_insn_state(p);
      brw_set_default_access_mode(p, BRW_ALIGN_1);
      brw_set_default_mask_control(p, BRW_MASK_DISABLE);

      struct brw_reg addr = vec8(brw_address_reg(0));

      /* We need to move the indirect value into the address register.  In
       * order to make things make some sense, we want to respect at least the
       * X component of the swizzle.  In order to do that, we need to convert
       * the subnr (probably 0) to an align1 subnr and add in the swizzle.
       */
      assert(brw_is_single_value_swizzle(indirect.swizzle));
      indirect.subnr = (indirect.subnr * 4 + BRW_GET_SWZ(indirect.swizzle, 0));

      /* We then use a region of <8,4,0>:uw to pick off the first 2 bytes of
       * the indirect and splat it out to all four channels of the given half
       * of a0.
       */
      indirect.subnr *= 2;
      indirect = stride(retype(indirect, BRW_REGISTER_TYPE_UW), 8, 4, 0);
      brw_ADD(p, addr, indirect, brw_imm_uw(imm_byte_offset));

      /* Now we need to incorporate the swizzle from the source register */
      if (reg.swizzle != BRW_SWIZZLE_XXXX) {
         uint32_t uv_swiz = BRW_GET_SWZ(reg.swizzle, 0) << 2 |
                            BRW_GET_SWZ(reg.swizzle, 1) << 6 |
                            BRW_GET_SWZ(reg.swizzle, 2) << 10 |
                            BRW_GET_SWZ(reg.swizzle, 3) << 14;
         uv_swiz |= uv_swiz << 16;

         brw_ADD(p, addr, addr, brw_imm_uv(uv_swiz));
      }

      brw_MOV(p, dst, retype(brw_VxH_indirect(0, 0), reg.type));

      brw_pop_insn_state(p);
   }
}

static void
d1404 1
a1404 1
   const struct gen_device_info *devinfo = p->devinfo;
a1409 1
   int spill_count = 0, fill_count = 0;
d1435 25
a1568 3
      case BRW_OPCODE_LZD:
         brw_LZD(p, dst, src[0]);
         break;
a1686 1
         fill_count++;
a1690 1
         spill_count++;
d1813 2
a1814 6
      case SHADER_OPCODE_FIND_LIVE_CHANNEL: {
         const struct brw_reg mask =
            brw_stage_has_packed_dispatch(devinfo, nir->stage,
                                          &prog_data->base) ? brw_imm_ud(~0u) :
            brw_dmask_reg();
         brw_find_live_channel(p, dst, mask);
a1815 1
      }
a1817 1
         assert(inst->force_writemask_all);
d1926 1
a1941 11
      case SHADER_OPCODE_MOV_INDIRECT:
         generate_mov_indirect(p, inst, dst, src[0], src[1], src[2]);
         break;

      case BRW_OPCODE_DIM:
         assert(devinfo->is_haswell);
         assert(src[0].type == BRW_REGISTER_TYPE_DF);
         assert(dst.type == BRW_REGISTER_TYPE_DF);
         brw_DIM(p, dst, retype(src[0], BRW_REGISTER_TYPE_F));
         break;

d1964 1
a1964 1
   brw_set_uip_jip(p, 0);
d1983 4
a1986 4
      fprintf(stderr, "%s vec4 shader: %d instructions. %d loops. %u cycles. %d:%d "
                      "spills:fills. Compacted %d to %d bytes (%.0f%%)\n",
              stage_abbrev, before_size / 16, loop_count, cfg->cycle_count,
              spill_count, fill_count, before_size, after_size,
d1997 1
a1997 1
                              "%d:%d spills:fills, compacted %d to %d bytes.",
d1999 2
a2000 3
                              loop_count, cfg->cycle_count, spill_count,
                              fill_count, before_size, after_size);

@


1.1.1.4
log
@Import Mesa 13.0.5
@
text
@a108 1
             gl_shader_stage stage,
d241 1
a241 8
         /* The VS, DS, and FS stages have the g0.2 payload delivered as 0,
          * so header0.2 is 0 when g0 is copied.  The HS and GS stages do
          * not, so we must set to to 0 to avoid setting undesirable bits
          * in the message header.
          */
         if (dw2 ||
             stage == MESA_SHADER_TESS_CTRL ||
             stage == MESA_SHADER_GEOMETRY) {
a242 1
         }
d301 2
a302 6
         if (sampler_reg.file == BRW_IMMEDIATE_VALUE) {
            brw_OR(p, addr, surface_reg, brw_imm_ud(sampler_reg.ud << 8));
         } else {
            brw_SHL(p, addr, sampler_reg, brw_imm_ud(8));
            brw_OR(p, addr, addr, surface_reg);
         }
d1728 1
a1728 2
         generate_tex(p, prog_data, nir->stage,
                      inst, dst, src[0], src[1], src[2]);
@


