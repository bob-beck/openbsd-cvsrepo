head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.4
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.14
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.12
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.10
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.8
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	FGr8CFhVerRlpSoE;

1.7
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to pixman 0.34.0.
@
text
@/*
 * Copyright Â© 2005 Eric Anholt
 * Copyright Â© 2009 Chris Wilson
 * Copyright Â© 2010 Soeren Sandmann
 * Copyright Â© 2010 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Eric Anholt not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Eric Anholt makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdio.h>
#include <stdlib.h> /* abort() */
#include <math.h>
#include <time.h>
#include "utils.h"

typedef struct image_t image_t;

static const color_t colors[] =
{
    { 1.0, 1.0, 1.0, 1.0 },
    { 1.0, 1.0, 1.0, 0.0 },
    { 0.0, 0.0, 0.0, 1.0 },
    { 0.0, 0.0, 0.0, 0.0 },
    { 1.0, 0.0, 0.0, 1.0 },
    { 0.0, 1.0, 0.0, 1.0 },
    { 0.0, 0.0, 1.0, 1.0 },
    { 0.5, 0.0, 0.0, 0.5 },
};

static uint16_t
_color_double_to_short (double d)
{
    uint32_t i;

    i = (uint32_t) (d * 65536);
    i -= (i >> 16);

    return i;
}

static void
compute_pixman_color (const color_t *color,
		      pixman_color_t *out)
{
    out->red   = _color_double_to_short (color->r);
    out->green = _color_double_to_short (color->g);
    out->blue  = _color_double_to_short (color->b);
    out->alpha = _color_double_to_short (color->a);
}

#define REPEAT 0x01000000
#define FLAGS  0xff000000

static const int sizes[] =
{
    0,
    1,
    1 | REPEAT,
    10
};

static const pixman_format_code_t formats[] =
{
    /* 32 bpp formats */
    PIXMAN_a8r8g8b8,
    PIXMAN_x8r8g8b8,
    PIXMAN_a8b8g8r8,
    PIXMAN_x8b8g8r8,
    PIXMAN_b8g8r8a8,
    PIXMAN_b8g8r8x8,
    PIXMAN_r8g8b8a8,
    PIXMAN_r8g8b8x8,
    PIXMAN_x2r10g10b10,
    PIXMAN_x2b10g10r10,
    PIXMAN_a2r10g10b10,
    PIXMAN_a2b10g10r10,
    
    /* sRGB formats */
    PIXMAN_a8r8g8b8_sRGB,

    /* 24 bpp formats */
    PIXMAN_r8g8b8,
    PIXMAN_b8g8r8,
    PIXMAN_r5g6b5,
    PIXMAN_b5g6r5,

    /* 16 bpp formats */
    PIXMAN_x1r5g5b5,
    PIXMAN_x1b5g5r5,
    PIXMAN_a1r5g5b5,
    PIXMAN_a1b5g5r5,
    PIXMAN_a4b4g4r4,
    PIXMAN_x4b4g4r4,
    PIXMAN_a4r4g4b4,
    PIXMAN_x4r4g4b4,

    /* 8 bpp formats */
    PIXMAN_a8,
    PIXMAN_r3g3b2,
    PIXMAN_b2g3r3,
    PIXMAN_a2r2g2b2,
    PIXMAN_a2b2g2r2,
    PIXMAN_x4a4,

    /* 4 bpp formats */
    PIXMAN_a4,
    PIXMAN_r1g2b1,
    PIXMAN_b1g2r1,
    PIXMAN_a1r1g1b1,
    PIXMAN_a1b1g1r1,

    /* 1 bpp formats */
    PIXMAN_a1,
};

struct image_t
{
    pixman_image_t *image;
    pixman_format_code_t format;
    const color_t *color;
    pixman_repeat_t repeat;
    int size;
};

static const pixman_op_t operators[] =
{
    PIXMAN_OP_CLEAR,
    PIXMAN_OP_SRC,
    PIXMAN_OP_DST,
    PIXMAN_OP_OVER,
    PIXMAN_OP_OVER_REVERSE,
    PIXMAN_OP_IN,
    PIXMAN_OP_IN_REVERSE,
    PIXMAN_OP_OUT,
    PIXMAN_OP_OUT_REVERSE,
    PIXMAN_OP_ATOP,
    PIXMAN_OP_ATOP_REVERSE,
    PIXMAN_OP_XOR,
    PIXMAN_OP_ADD,
    PIXMAN_OP_SATURATE,

    PIXMAN_OP_DISJOINT_CLEAR,
    PIXMAN_OP_DISJOINT_SRC,
    PIXMAN_OP_DISJOINT_DST,
    PIXMAN_OP_DISJOINT_OVER,
    PIXMAN_OP_DISJOINT_OVER_REVERSE,
    PIXMAN_OP_DISJOINT_IN,
    PIXMAN_OP_DISJOINT_IN_REVERSE,
    PIXMAN_OP_DISJOINT_OUT,
    PIXMAN_OP_DISJOINT_OUT_REVERSE,
    PIXMAN_OP_DISJOINT_ATOP,
    PIXMAN_OP_DISJOINT_ATOP_REVERSE,
    PIXMAN_OP_DISJOINT_XOR,

    PIXMAN_OP_CONJOINT_CLEAR,
    PIXMAN_OP_CONJOINT_SRC,
    PIXMAN_OP_CONJOINT_DST,
    PIXMAN_OP_CONJOINT_OVER,
    PIXMAN_OP_CONJOINT_OVER_REVERSE,
    PIXMAN_OP_CONJOINT_IN,
    PIXMAN_OP_CONJOINT_IN_REVERSE,
    PIXMAN_OP_CONJOINT_OUT,
    PIXMAN_OP_CONJOINT_OUT_REVERSE,
    PIXMAN_OP_CONJOINT_ATOP,
    PIXMAN_OP_CONJOINT_ATOP_REVERSE,
    PIXMAN_OP_CONJOINT_XOR,
};

static uint32_t
get_value (pixman_image_t *image)
{
    uint32_t value = *(uint32_t *)pixman_image_get_data (image);

#ifdef WORDS_BIGENDIAN
    {
	pixman_format_code_t format = pixman_image_get_format (image);
	value >>= 8 * sizeof(value) - PIXMAN_FORMAT_BPP (format);
    }
#endif

    return value;
}

static char *
describe_image (image_t *info, char *buf)
{
    if (info->size)
    {
	sprintf (buf, "%s, %dx%d%s",
		 format_name (info->format),
		 info->size, info->size,
		 info->repeat ? " R" :"");
    }
    else
    {
	sprintf (buf, "solid");
    }

    return buf;
}

static char *
describe_color (const color_t *color, char *buf)
{
    sprintf (buf, "%.3f %.3f %.3f %.3f",
	     color->r, color->g, color->b, color->a);

    return buf;
}

static pixman_bool_t
composite_test (image_t *dst,
		pixman_op_t op,
		image_t *src,
		image_t *mask,
		pixman_bool_t component_alpha,
		int testno)
{
    color_t expected, tdst, tsrc, tmsk;
    pixel_checker_t checker;

    if (mask)
    {
	pixman_image_set_component_alpha (mask->image, component_alpha);

	pixman_image_composite (op, src->image, mask->image, dst->image,
				0, 0, 0, 0, 0, 0, dst->size, dst->size);
    }
    else
    {
	pixman_image_composite (op, src->image, NULL, dst->image,
				0, 0,
				0, 0,
				0, 0,
				dst->size, dst->size);
    }

    tdst = *dst->color;
    tsrc = *src->color;

    if (mask)
    {
	tmsk = *mask->color;
    }

    /* It turns out that by construction all source, mask etc. colors are
     * linear because they are made from fills, and fills are always in linear
     * color space.  However, if they have been converted to bitmaps, we need
     * to simulate the sRGB approximation to pass the test cases.
     */
    if (src->size)
    {
	if (PIXMAN_FORMAT_TYPE (src->format) == PIXMAN_TYPE_ARGB_SRGB)
        {
	    tsrc.r = convert_linear_to_srgb (tsrc.r);
	    tsrc.g = convert_linear_to_srgb (tsrc.g);
	    tsrc.b = convert_linear_to_srgb (tsrc.b);
	    round_color (src->format, &tsrc);
	    tsrc.r = convert_srgb_to_linear (tsrc.r);
	    tsrc.g = convert_srgb_to_linear (tsrc.g);
	    tsrc.b = convert_srgb_to_linear (tsrc.b);
	}
        else
        {
	    round_color (src->format, &tsrc);
	}
    }

    if (mask && mask->size)
    {
	if (PIXMAN_FORMAT_TYPE (mask->format) == PIXMAN_TYPE_ARGB_SRGB)
	{
	    tmsk.r = convert_linear_to_srgb (tmsk.r);
	    tmsk.g = convert_linear_to_srgb (tmsk.g);
	    tmsk.b = convert_linear_to_srgb (tmsk.b);
	    round_color (mask->format, &tmsk);
	    tmsk.r = convert_srgb_to_linear (tmsk.r);
	    tmsk.g = convert_srgb_to_linear (tmsk.g);
	    tmsk.b = convert_srgb_to_linear (tmsk.b);
	}
	else
	{
	    round_color (mask->format, &tmsk);
	}
    }

    if (PIXMAN_FORMAT_TYPE (dst->format) == PIXMAN_TYPE_ARGB_SRGB)
    {
	tdst.r = convert_linear_to_srgb (tdst.r);
	tdst.g = convert_linear_to_srgb (tdst.g);
	tdst.b = convert_linear_to_srgb (tdst.b);
    	round_color (dst->format, &tdst);
	tdst.r = convert_srgb_to_linear (tdst.r);
	tdst.g = convert_srgb_to_linear (tdst.g);
	tdst.b = convert_srgb_to_linear (tdst.b);
    }
    else
    {
    	round_color (dst->format, &tdst);
    }

    do_composite (op,
		  &tsrc,
		  mask? &tmsk : NULL,
		  &tdst,
		  &expected,
		  component_alpha);

    pixel_checker_init (&checker, dst->format);

    if (!pixel_checker_check (&checker, get_value (dst->image), &expected))
    {
	char buf[40], buf2[40];
	int a, r, g, b;
	uint32_t pixel;

	printf ("---- Test %d failed ----\n", testno);
	printf ("Operator:      %s %s\n",
                operator_name (op), component_alpha ? "CA" : "");

	printf ("Source:        %s\n", describe_image (src, buf));
	if (mask != NULL)
	    printf ("Mask:          %s\n", describe_image (mask, buf));

	printf ("Destination:   %s\n\n", describe_image (dst, buf));
	printf ("               R     G     B     A         Rounded\n");
	printf ("Source color:  %s     %s\n",
		describe_color (src->color, buf),
		describe_color (&tsrc, buf2));
	if (mask)
	{
	    printf ("Mask color:    %s     %s\n",
		    describe_color (mask->color, buf),
		    describe_color (&tmsk, buf2));
	}
	printf ("Dest. color:   %s     %s\n",
		describe_color (dst->color, buf),
		describe_color (&tdst, buf2));

	pixel = get_value (dst->image);

	printf ("Expected:      %s\n", describe_color (&expected, buf));

	pixel_checker_split_pixel (&checker, pixel, &a, &r, &g, &b);

	printf ("Got:           %5d %5d %5d %5d  [pixel: 0x%08x]\n", r, g, b, a, pixel);
	pixel_checker_get_min (&checker, &expected, &a, &r, &g, &b);
	printf ("Min accepted:  %5d %5d %5d %5d\n", r, g, b, a);
	pixel_checker_get_max (&checker, &expected, &a, &r, &g, &b);
	printf ("Max accepted:  %5d %5d %5d %5d\n", r, g, b, a);

	return FALSE;
    }
    return TRUE;
}

static void
image_init (image_t *info,
	    int color,
	    int format,
	    int size)
{
    pixman_color_t fill;

    info->color = &colors[color];
    compute_pixman_color (info->color, &fill);

    info->format = formats[format];
    info->size = sizes[size] & ~FLAGS;
    info->repeat = PIXMAN_REPEAT_NONE;

    if (info->size)
    {
	pixman_image_t *solid;

	info->image = pixman_image_create_bits (info->format,
						info->size, info->size,
						NULL, 0);

	solid = pixman_image_create_solid_fill (&fill);
	pixman_image_composite32 (PIXMAN_OP_SRC, solid, NULL, info->image,
				  0, 0, 0, 0, 0, 0, info->size, info->size);
	pixman_image_unref (solid);

	if (sizes[size] & REPEAT)
	{
	    pixman_image_set_repeat (info->image, PIXMAN_REPEAT_NORMAL);
	    info->repeat = PIXMAN_REPEAT_NORMAL;
	}
    }
    else
    {
	info->image = pixman_image_create_solid_fill (&fill);
    }
}

static void
image_fini (image_t *info)
{
    pixman_image_unref (info->image);
}

static int
random_size (void)
{
    return prng_rand_n (ARRAY_LENGTH (sizes));
}

static int
random_color (void)
{
    return prng_rand_n (ARRAY_LENGTH (colors));
}

static int
random_format (void)
{
    return prng_rand_n (ARRAY_LENGTH (formats));
}

static pixman_bool_t
run_test (uint32_t seed)
{
    image_t src, mask, dst;
    pixman_op_t op;
    int ca;
    int ok;

    prng_srand (seed);

    image_init (&dst, random_color(), random_format(), 1);
    image_init (&src, random_color(), random_format(), random_size());
    image_init (&mask, random_color(), random_format(), random_size());

    op = operators [prng_rand_n (ARRAY_LENGTH (operators))];

    ca = prng_rand_n (3);

    switch (ca)
    {
    case 0:
	ok = composite_test (&dst, op, &src, NULL, FALSE, seed);
	break;
    case 1:
	ok = composite_test (&dst, op, &src, &mask, FALSE, seed);
	break;
    case 2:
	ok = composite_test (&dst, op, &src, &mask,
			     mask.size? TRUE : FALSE, seed);
	break;
    default:
	ok = FALSE;
	break;
    }

    image_fini (&src);
    image_fini (&mask);
    image_fini (&dst);

    return ok;
}

int
main (int argc, char **argv)
{
#define N_TESTS (8 * 1024 * 1024)
    int result = 0;
    uint32_t seed;
    int32_t i;

    if (argc > 1)
    {
	char *end;

	i = strtol (argv[1], &end, 0);

	if (end != argv[1])
	{
	    if (!run_test (i))
		return 1;
	    else
		return 0;
	}
	else
	{
	    printf ("Usage:\n\n   %s <number>\n\n", argv[0]);
	    return -1;
	}
    }

    if (getenv ("PIXMAN_RANDOMIZE_TESTS"))
	seed = get_random_seed();
    else
	seed = 1;

#ifdef USE_OPENMP
#   pragma omp parallel for default(none) shared(result, argv, seed)
#endif
    for (i = 0; i <= N_TESTS; ++i)
    {
	if (!result && !run_test (i + seed))
	{
	    printf ("Test 0x%08X failed.\n", seed + i);

	    result = seed + i;
	}
    }

    return result;
}
@


1.7
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@a301 11
    if (mask)
    {
	if (component_alpha && PIXMAN_FORMAT_R (mask->format) == 0)
	{
	    /* Ax component-alpha masks expand alpha into
	     * all color channels.
	     */
	    tmsk.r = tmsk.g = tmsk.b = tmsk.a;
	}
    }

@


1.6
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@a30 1
typedef struct format_t format_t;
a31 7
typedef struct operator_t operator_t;

struct format_t
{
    pixman_format_code_t format;
    const char *name;
};
d77 1
a77 1
static const format_t formats[] =
a78 2
#define P(x) { PIXMAN_##x, #x }

d80 12
a91 12
    P(a8r8g8b8),
    P(x8r8g8b8),
    P(a8b8g8r8),
    P(x8b8g8r8),
    P(b8g8r8a8),
    P(b8g8r8x8),
    P(r8g8b8a8),
    P(r8g8b8x8),
    P(x2r10g10b10),
    P(x2b10g10r10),
    P(a2r10g10b10),
    P(a2b10g10r10),
d94 1
a94 1
    P(a8r8g8b8_sRGB),
d97 4
a100 4
    P(r8g8b8),
    P(b8g8r8),
    P(r5g6b5),
    P(b5g6r5),
d103 8
a110 8
    P(x1r5g5b5),
    P(x1b5g5r5),
    P(a1r5g5b5),
    P(a1b5g5r5),
    P(a4b4g4r4),
    P(x4b4g4r4),
    P(a4r4g4b4),
    P(x4r4g4b4),
d113 6
a118 6
    P(a8),
    P(r3g3b2),
    P(b2g3r3),
    P(a2r2g2b2),
    P(a2b2g2r2),
    P(x4a4),
d121 5
a125 5
    P(a4),
    P(r1g2b1),
    P(b1g2r1),
    P(a1r1g1b1),
    P(a1b1g1r1),
d128 1
a128 2
    P(a1)
#undef P
d134 1
a134 1
    const format_t *format;
d140 1
a140 1
struct operator_t
d142 40
a181 2
    pixman_op_t op;
    const char *name;
a183 323
static const operator_t operators[] =
{
#define P(x) { PIXMAN_OP_##x, #x }
    P(CLEAR),
    P(SRC),
    P(DST),
    P(OVER),
    P(OVER_REVERSE),
    P(IN),
    P(IN_REVERSE),
    P(OUT),
    P(OUT_REVERSE),
    P(ATOP),
    P(ATOP_REVERSE),
    P(XOR),
    P(ADD),
    P(SATURATE),

    P(DISJOINT_CLEAR),
    P(DISJOINT_SRC),
    P(DISJOINT_DST),
    P(DISJOINT_OVER),
    P(DISJOINT_OVER_REVERSE),
    P(DISJOINT_IN),
    P(DISJOINT_IN_REVERSE),
    P(DISJOINT_OUT),
    P(DISJOINT_OUT_REVERSE),
    P(DISJOINT_ATOP),
    P(DISJOINT_ATOP_REVERSE),
    P(DISJOINT_XOR),

    P(CONJOINT_CLEAR),
    P(CONJOINT_SRC),
    P(CONJOINT_DST),
    P(CONJOINT_OVER),
    P(CONJOINT_OVER_REVERSE),
    P(CONJOINT_IN),
    P(CONJOINT_IN_REVERSE),
    P(CONJOINT_OUT),
    P(CONJOINT_OUT_REVERSE),
    P(CONJOINT_ATOP),
    P(CONJOINT_ATOP_REVERSE),
    P(CONJOINT_XOR),
#undef P
};

static double
calc_op (pixman_op_t op, double src, double dst, double srca, double dsta)
{
#define mult_chan(src, dst, Fa, Fb) MIN ((src) * (Fa) + (dst) * (Fb), 1.0)

    double Fa, Fb;

    switch (op)
    {
    case PIXMAN_OP_CLEAR:
    case PIXMAN_OP_DISJOINT_CLEAR:
    case PIXMAN_OP_CONJOINT_CLEAR:
	return mult_chan (src, dst, 0.0, 0.0);

    case PIXMAN_OP_SRC:
    case PIXMAN_OP_DISJOINT_SRC:
    case PIXMAN_OP_CONJOINT_SRC:
	return mult_chan (src, dst, 1.0, 0.0);

    case PIXMAN_OP_DST:
    case PIXMAN_OP_DISJOINT_DST:
    case PIXMAN_OP_CONJOINT_DST:
	return mult_chan (src, dst, 0.0, 1.0);

    case PIXMAN_OP_OVER:
	return mult_chan (src, dst, 1.0, 1.0 - srca);

    case PIXMAN_OP_OVER_REVERSE:
	return mult_chan (src, dst, 1.0 - dsta, 1.0);

    case PIXMAN_OP_IN:
	return mult_chan (src, dst, dsta, 0.0);

    case PIXMAN_OP_IN_REVERSE:
	return mult_chan (src, dst, 0.0, srca);

    case PIXMAN_OP_OUT:
	return mult_chan (src, dst, 1.0 - dsta, 0.0);

    case PIXMAN_OP_OUT_REVERSE:
	return mult_chan (src, dst, 0.0, 1.0 - srca);

    case PIXMAN_OP_ATOP:
	return mult_chan (src, dst, dsta, 1.0 - srca);

    case PIXMAN_OP_ATOP_REVERSE:
	return mult_chan (src, dst, 1.0 - dsta,  srca);

    case PIXMAN_OP_XOR:
	return mult_chan (src, dst, 1.0 - dsta, 1.0 - srca);

    case PIXMAN_OP_ADD:
	return mult_chan (src, dst, 1.0, 1.0);

    case PIXMAN_OP_SATURATE:
    case PIXMAN_OP_DISJOINT_OVER_REVERSE:
	if (srca == 0.0)
	    Fa = 1.0;
	else
	    Fa = MIN (1.0, (1.0 - dsta) / srca);
	return mult_chan (src, dst, Fa, 1.0);

    case PIXMAN_OP_DISJOINT_OVER:
	if (dsta == 0.0)
	    Fb = 1.0;
	else
	    Fb = MIN (1.0, (1.0 - srca) / dsta);
	return mult_chan (src, dst, 1.0, Fb);

    case PIXMAN_OP_DISJOINT_IN:
	if (srca == 0.0)
	    Fa = 0.0;
	else
	    Fa = MAX (0.0, 1.0 - (1.0 - dsta) / srca);
	return mult_chan (src, dst, Fa, 0.0);

    case PIXMAN_OP_DISJOINT_IN_REVERSE:
	if (dsta == 0.0)
	    Fb = 0.0;
	else
	    Fb = MAX (0.0, 1.0 - (1.0 - srca) / dsta);
	return mult_chan (src, dst, 0.0, Fb);

    case PIXMAN_OP_DISJOINT_OUT:
	if (srca == 0.0)
	    Fa = 1.0;
	else
	    Fa = MIN (1.0, (1.0 - dsta) / srca);
	return mult_chan (src, dst, Fa, 0.0);

    case PIXMAN_OP_DISJOINT_OUT_REVERSE:
	if (dsta == 0.0)
	    Fb = 1.0;
	else
	    Fb = MIN (1.0, (1.0 - srca) / dsta);
	return mult_chan (src, dst, 0.0, Fb);

    case PIXMAN_OP_DISJOINT_ATOP:
	if (srca == 0.0)
	    Fa = 0.0;
	else
	    Fa = MAX (0.0, 1.0 - (1.0 - dsta) / srca);
	if (dsta == 0.0)
	    Fb = 1.0;
	else
	    Fb = MIN (1.0, (1.0 - srca) / dsta);
	return mult_chan (src, dst, Fa, Fb);

    case PIXMAN_OP_DISJOINT_ATOP_REVERSE:
	if (srca == 0.0)
	    Fa = 1.0;
	else
	    Fa = MIN (1.0, (1.0 - dsta) / srca);
	if (dsta == 0.0)
	    Fb = 0.0;
	else
	    Fb = MAX (0.0, 1.0 - (1.0 - srca) / dsta);
	return mult_chan (src, dst, Fa, Fb);

    case PIXMAN_OP_DISJOINT_XOR:
	if (srca == 0.0)
	    Fa = 1.0;
	else
	    Fa = MIN (1.0, (1.0 - dsta) / srca);
	if (dsta == 0.0)
	    Fb = 1.0;
	else
	    Fb = MIN (1.0, (1.0 - srca) / dsta);
	return mult_chan (src, dst, Fa, Fb);

    case PIXMAN_OP_CONJOINT_OVER:
	if (dsta == 0.0)
	    Fb = 0.0;
	else
	    Fb = MAX (0.0, 1.0 - srca / dsta);
	return mult_chan (src, dst, 1.0, Fb);

    case PIXMAN_OP_CONJOINT_OVER_REVERSE:
	if (srca == 0.0)
	    Fa = 0.0;
	else
	    Fa = MAX (0.0, 1.0 - dsta / srca);
	return mult_chan (src, dst, Fa, 1.0);

    case PIXMAN_OP_CONJOINT_IN:
	if (srca == 0.0)
	    Fa = 1.0;
	else
	    Fa = MIN (1.0, dsta / srca);
	return mult_chan (src, dst, Fa, 0.0);

    case PIXMAN_OP_CONJOINT_IN_REVERSE:
	if (dsta == 0.0)
	    Fb = 1.0;
	else
	    Fb = MIN (1.0, srca / dsta);
	return mult_chan (src, dst, 0.0, Fb);

    case PIXMAN_OP_CONJOINT_OUT:
	if (srca == 0.0)
	    Fa = 0.0;
	else
	    Fa = MAX (0.0, 1.0 - dsta / srca);
	return mult_chan (src, dst, Fa, 0.0);

    case PIXMAN_OP_CONJOINT_OUT_REVERSE:
	if (dsta == 0.0)
	    Fb = 0.0;
	else
	    Fb = MAX (0.0, 1.0 - srca / dsta);
	return mult_chan (src, dst, 0.0, Fb);

    case PIXMAN_OP_CONJOINT_ATOP:
	if (srca == 0.0)
	    Fa = 1.0;
	else
	    Fa = MIN (1.0, dsta / srca);
	if (dsta == 0.0)
	    Fb = 0.0;
	else
	    Fb = MAX (0.0, 1.0 - srca / dsta);
	return mult_chan (src, dst, Fa, Fb);

    case PIXMAN_OP_CONJOINT_ATOP_REVERSE:
	if (srca == 0.0)
	    Fa = 0.0;
	else
	    Fa = MAX (0.0, 1.0 - dsta / srca);
	if (dsta == 0.0)
	    Fb = 1.0;
	else
	    Fb = MIN (1.0, srca / dsta);
	return mult_chan (src, dst, Fa, Fb);

    case PIXMAN_OP_CONJOINT_XOR:
	if (srca == 0.0)
	    Fa = 0.0;
	else
	    Fa = MAX (0.0, 1.0 - dsta / srca);
	if (dsta == 0.0)
	    Fb = 0.0;
	else
	    Fb = MAX (0.0, 1.0 - srca / dsta);
	return mult_chan (src, dst, Fa, Fb);

    case PIXMAN_OP_MULTIPLY:
    case PIXMAN_OP_SCREEN:
    case PIXMAN_OP_OVERLAY:
    case PIXMAN_OP_DARKEN:
    case PIXMAN_OP_LIGHTEN:
    case PIXMAN_OP_COLOR_DODGE:
    case PIXMAN_OP_COLOR_BURN:
    case PIXMAN_OP_HARD_LIGHT:
    case PIXMAN_OP_SOFT_LIGHT:
    case PIXMAN_OP_DIFFERENCE:
    case PIXMAN_OP_EXCLUSION:
    case PIXMAN_OP_HSL_HUE:
    case PIXMAN_OP_HSL_SATURATION:
    case PIXMAN_OP_HSL_COLOR:
    case PIXMAN_OP_HSL_LUMINOSITY:
    default:
	abort();
	return 0; /* silence MSVC */
    }
#undef mult_chan
}

static void
do_composite (pixman_op_t op,
	      const color_t *src,
	      const color_t *mask,
	      const color_t *dst,
	      color_t *result,
	      pixman_bool_t component_alpha)
{
    color_t srcval, srcalpha;

    if (mask == NULL)
    {
	srcval = *src;

	srcalpha.r = src->a;
	srcalpha.g = src->a;
	srcalpha.b = src->a;
	srcalpha.a = src->a;
    }
    else if (component_alpha)
    {
	srcval.r = src->r * mask->r;
	srcval.g = src->g * mask->g;
	srcval.b = src->b * mask->b;
	srcval.a = src->a * mask->a;

	srcalpha.r = src->a * mask->r;
	srcalpha.g = src->a * mask->g;
	srcalpha.b = src->a * mask->b;
	srcalpha.a = src->a * mask->a;
    }
    else
    {
	srcval.r = src->r * mask->a;
	srcval.g = src->g * mask->a;
	srcval.b = src->b * mask->a;
	srcval.a = src->a * mask->a;

	srcalpha.r = src->a * mask->a;
	srcalpha.g = src->a * mask->a;
	srcalpha.b = src->a * mask->a;
	srcalpha.a = src->a * mask->a;
    }

    result->r = calc_op (op, srcval.r, dst->r, srcalpha.r, dst->a);
    result->g = calc_op (op, srcval.g, dst->g, srcalpha.g, dst->a);
    result->b = calc_op (op, srcval.b, dst->b, srcalpha.b, dst->a);
    result->a = calc_op (op, srcval.a, dst->a, srcalpha.a, dst->a);
}

d205 1
a205 1
		 info->format->name,
d228 1
a228 1
		const operator_t *op,
d241 1
a241 1
	pixman_image_composite (op->op, src->image, mask->image, dst->image,
d246 1
a246 1
	pixman_image_composite (op->op, src->image, NULL, dst->image,
d268 1
a268 1
	if (PIXMAN_FORMAT_TYPE (src->format->format) == PIXMAN_TYPE_ARGB_SRGB)
d273 1
a273 1
	    round_color (src->format->format, &tsrc);
d280 1
a280 1
	    round_color (src->format->format, &tsrc);
d286 1
a286 1
	if (PIXMAN_FORMAT_TYPE (mask->format->format) == PIXMAN_TYPE_ARGB_SRGB)
d291 1
a291 1
	    round_color (mask->format->format, &tmsk);
d298 1
a298 1
	    round_color (mask->format->format, &tmsk);
d304 1
a304 1
	if (component_alpha && PIXMAN_FORMAT_R (mask->format->format) == 0)
d313 1
a313 1
    if (PIXMAN_FORMAT_TYPE (dst->format->format) == PIXMAN_TYPE_ARGB_SRGB)
d318 1
a318 1
    	round_color (dst->format->format, &tdst);
d325 1
a325 1
    	round_color (dst->format->format, &tdst);
d328 1
a328 1
    do_composite (op->op,
d335 1
a335 1
    pixel_checker_init (&checker, dst->format->format);
d345 1
a345 1
		 op->name, component_alpha ? "CA" : "");
d394 1
a394 1
    info->format = &formats[format];
d402 1
a402 1
	info->image = pixman_image_create_bits (info->format->format,
d432 1
a432 1
    return lcg_rand_n (ARRAY_LENGTH (sizes));
d438 1
a438 1
    return lcg_rand_n (ARRAY_LENGTH (colors));
d444 1
a444 1
    return lcg_rand_n (ARRAY_LENGTH (formats));
d451 1
a451 1
    const operator_t *op;
d455 1
a455 1
    lcg_srand (seed);
d461 1
a461 1
    op = &(operators [lcg_rand_n (ARRAY_LENGTH (operators))]);
d463 1
a463 1
    ca = lcg_rand_n (3);
@


1.5
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d102 3
a529 1
    pixman_color_t fill;
a531 8
    pixman_image_t *solid;

    /* Initialize dst */
    compute_pixman_color (dst->color, &fill);
    solid = pixman_image_create_solid_fill (&fill);
    pixman_image_composite32 (PIXMAN_OP_SRC, solid, NULL, dst->image,
			      0, 0, 0, 0, 0, 0, dst->size, dst->size);
    pixman_image_unref (solid);
a549 2
    round_color (dst->format->format, &tdst);

a550 2
    if (src->size)
	round_color (src->format->format, &tsrc);
d555 39
a593 1
	if (mask->size)
d595 5
d607 15
@


1.4
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@a24 2
#define PIXMAN_USE_INTERNAL_API
#include <pixman.h>
a30 1
typedef struct color_t color_t;
a34 5
struct color_t
{
    double r, g, b, a;
};

d477 2
a478 3
static void
color_correct (pixman_format_code_t format,
	       color_t *color)
d480 1
a480 16
#define MASK(x) ((1 << (x)) - 1)
#define round_pix(pix, m)						\
    ((int)((pix) * (MASK(m)) + .5) / (double) (MASK(m)))

    if (PIXMAN_FORMAT_R (format) == 0)
    {
	color->r = 0.0;
	color->g = 0.0;
	color->b = 0.0;
    }
    else
    {
	color->r = round_pix (color->r, PIXMAN_FORMAT_R (format));
	color->g = round_pix (color->g, PIXMAN_FORMAT_G (format));
	color->b = round_pix (color->b, PIXMAN_FORMAT_B (format));
    }
a481 21
    if (PIXMAN_FORMAT_A (format) == 0)
	color->a = 1.0;
    else
	color->a = round_pix (color->a, PIXMAN_FORMAT_A (format));

#undef round_pix
#undef MASK
}

static void
get_pixel (pixman_image_t *image,
	   pixman_format_code_t format,
	   color_t *color)
{
#define MASK(N) ((1UL << (N))-1)

    unsigned long rs, gs, bs, as;
    int a, r, g, b;
    unsigned long val;

    val = *(unsigned long *) pixman_image_get_data (image);
a482 66
    val >>= 8 * sizeof(val) - PIXMAN_FORMAT_BPP (format);
#endif

    /* Number of bits in each channel */
    a = PIXMAN_FORMAT_A (format);
    r = PIXMAN_FORMAT_R (format);
    g = PIXMAN_FORMAT_G (format);
    b = PIXMAN_FORMAT_B (format);

    switch (PIXMAN_FORMAT_TYPE (format))
    {
    case PIXMAN_TYPE_ARGB:
        bs = 0;
        gs = b + bs;
        rs = g + gs;
        as = r + rs;
	break;

    case PIXMAN_TYPE_ABGR:
        rs = 0;
        gs = r + rs;
        bs = g + gs;
        as = b + bs;
	break;

    case PIXMAN_TYPE_BGRA:
        as = 0;
	rs = PIXMAN_FORMAT_BPP (format) - (b + g + r);
        gs = r + rs;
        bs = g + gs;
	break;

    case PIXMAN_TYPE_RGBA:
	as = 0;
	bs = PIXMAN_FORMAT_BPP (format) - (b + g + r);
	gs = b + bs;
	rs = g + gs;
	break;

    case PIXMAN_TYPE_A:
        as = 0;
        rs = 0;
        gs = 0;
        bs = 0;
	break;

    case PIXMAN_TYPE_OTHER:
    case PIXMAN_TYPE_COLOR:
    case PIXMAN_TYPE_GRAY:
    case PIXMAN_TYPE_YUY2:
    case PIXMAN_TYPE_YV12:
    default:
	abort ();
        as = 0;
        rs = 0;
        gs = 0;
        bs = 0;
	break;
    }

    if (MASK (a) != 0)
	color->a = ((val >> as) & MASK (a)) / (double) MASK (a);
    else
	color->a = 1.0;

    if (MASK (r) != 0)
d484 2
a485 3
	color->r = ((val >> rs) & MASK (r)) / (double) MASK (r);
	color->g = ((val >> gs) & MASK (g)) / (double) MASK (g);
	color->b = ((val >> bs) & MASK (b)) / (double) MASK (b);
d487 1
a487 25
    else
    {
	color->r = 0.0;
	color->g = 0.0;
	color->b = 0.0;
    }

#undef MASK
}

static double
eval_diff (color_t *expected, color_t *test, pixman_format_code_t format)
{
    double rscale, gscale, bscale, ascale;
    double rdiff, gdiff, bdiff, adiff;

    rscale = 1.0 * ((1 << PIXMAN_FORMAT_R (format)) - 1);
    gscale = 1.0 * ((1 << PIXMAN_FORMAT_G (format)) - 1);
    bscale = 1.0 * ((1 << PIXMAN_FORMAT_B (format)) - 1);
    ascale = 1.0 * ((1 << PIXMAN_FORMAT_A (format)) - 1);

    rdiff = fabs (test->r - expected->r) * rscale;
    bdiff = fabs (test->g - expected->g) * gscale;
    gdiff = fabs (test->b - expected->b) * bscale;
    adiff = fabs (test->a - expected->a) * ascale;
d489 1
a489 1
    return MAX (MAX (MAX (rdiff, gdiff), bdiff), adiff);
d497 1
a497 1
	sprintf (buf, "%s %dx%d%s",
d500 1
a500 1
		 info->repeat ? "R" :"");
d510 9
a518 4
/* Test a composite of a given operation, source, mask, and destination
 * picture.
 * Fills the window, and samples from the 0,0 pixel corner.
 */
d524 2
a525 1
		pixman_bool_t component_alpha)
d528 3
a530 4
    pixman_rectangle16_t rect;
    color_t expected, result, tdst, tsrc, tmsk;
    double diff;
    pixman_bool_t success = TRUE;
d532 1
d534 4
a537 4
    rect.x = rect.y = 0;
    rect.width = rect.height = dst->size;
    pixman_image_fill_rectangles (PIXMAN_OP_SRC, dst->image,
				  &fill, 1, &rect);
d539 1
a539 1
    if (mask != NULL)
d542 1
d544 1
a544 19
				0, 0,
				0, 0,
				0, 0,
				dst->size, dst->size);

	tmsk = *mask->color;
	if (mask->size)
	{
	    color_correct (mask->format->format, &tmsk);

	    if (component_alpha &&
		PIXMAN_FORMAT_R (mask->format->format) == 0)
	    {
		/* Ax component-alpha masks expand alpha into
		 * all color channels.
		 */
		tmsk.r = tmsk.g = tmsk.b = tmsk.a;
	    }
	}
a553 1
    get_pixel (dst->image, dst->format->format, &result);
d556 2
a557 1
    color_correct (dst->format->format, &tdst);
d560 1
a560 27
	color_correct (src->format->format, &tsrc);
    do_composite (op->op, &tsrc, mask ? &tmsk : NULL, &tdst,
		  &expected, component_alpha);
    color_correct (dst->format->format, &expected);

    diff = eval_diff (&expected, &result, dst->format->format);

    /* FIXME: We should find out what deviation is acceptable. 3.0
     * is clearly absurd for 2 bit formats for example. On the other
     * hand currently 1.0 does not work.
     */
    if (diff > 3.0)
    {
	char buf[40];

	sprintf (buf, "%s %scomposite",
		 op->name,
		 component_alpha ? "CA " : "");

	printf ("%s test error of %.4f --\n"
		"           R    G    B    A\n"
		"got:       %.2f %.2f %.2f %.2f [%08lx]\n"
		"expected:  %.2f %.2f %.2f %.2f\n",
		buf, diff,
		result.r, result.g, result.b, result.a,
		*(unsigned long *) pixman_image_get_data (dst->image),
		expected.r, expected.g, expected.b, expected.a);
d562 6
a567 1
	if (mask != NULL)
d569 4
a572 12
	    printf ("src color: %.2f %.2f %.2f %.2f\n"
		    "msk color: %.2f %.2f %.2f %.2f\n"
		    "dst color: %.2f %.2f %.2f %.2f\n",
		    src->color->r, src->color->g,
		    src->color->b, src->color->a,
		    mask->color->r, mask->color->g,
		    mask->color->b, mask->color->a,
		    dst->color->r, dst->color->g,
		    dst->color->b, dst->color->a);
	    printf ("src: %s, ", describe_image (src, buf));
	    printf ("mask: %s, ", describe_image (mask, buf));
	    printf ("dst: %s\n\n", describe_image (dst, buf));
d574 31
a604 1
	else
d606 3
a608 8
	    printf ("src color: %.2f %.2f %.2f %.2f\n"
		    "dst color: %.2f %.2f %.2f %.2f\n",
		    src->color->r, src->color->g,
		    src->color->b, src->color->a,
		    dst->color->r, dst->color->g,
		    dst->color->b, dst->color->a);
	    printf ("src: %s, ", describe_image (src, buf));
	    printf ("dst: %s\n\n", describe_image (dst, buf));
d610 3
d614 13
a626 1
	success = FALSE;
d628 1
a628 2

    return success;
d648 1
a648 1
	pixman_rectangle16_t rect;
d654 4
a657 4
	rect.x = rect.y = 0;
	rect.width = rect.height = info->size;
	pixman_image_fill_rectangles (PIXMAN_OP_SRC, info->image, &fill,
				      1, &rect);
d659 1
a659 1
	if (size & REPEAT)
d704 1
a704 1
    
d716 1
a716 1
	ok = composite_test (&dst, op, &src, NULL, FALSE);
d719 1
a719 1
	ok = composite_test (&dst, op, &src, &mask, FALSE);
d723 1
a723 1
			     mask.size? TRUE : FALSE);
d742 2
a743 1
    uint32_t i, seed;
d748 1
a748 1
	
d769 1
a769 1
    
d778 1
a778 1
	    
d782 1
a782 1
    
@


1.3
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@a29 1
#include <config.h>
@


1.2
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@a33 4
#define ARRAY_LENGTH(A) ((int) (sizeof (A) / sizeof ((A) [0])))
#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))

d105 2
d212 1
a212 1
#define mult_chan(src, dst, Fa, Fb) min ((src) * (Fa) + (dst) * (Fb), 1.0)
d268 1
a268 1
	    Fa = min (1.0, (1.0 - dsta) / srca);
d275 1
a275 1
	    Fb = min (1.0, (1.0 - srca) / dsta);
d282 1
a282 1
	    Fa = max (0.0, 1.0 - (1.0 - dsta) / srca);
d289 1
a289 1
	    Fb = max (0.0, 1.0 - (1.0 - srca) / dsta);
d296 1
a296 1
	    Fa = min (1.0, (1.0 - dsta) / srca);
d303 1
a303 1
	    Fb = min (1.0, (1.0 - srca) / dsta);
d310 1
a310 1
	    Fa = max (0.0, 1.0 - (1.0 - dsta) / srca);
d314 1
a314 1
	    Fb = min (1.0, (1.0 - srca) / dsta);
d321 1
a321 1
	    Fa = min (1.0, (1.0 - dsta) / srca);
d325 1
a325 1
	    Fb = max (0.0, 1.0 - (1.0 - srca) / dsta);
d332 1
a332 1
	    Fa = min (1.0, (1.0 - dsta) / srca);
d336 1
a336 1
	    Fb = min (1.0, (1.0 - srca) / dsta);
d343 1
a343 1
	    Fb = max (0.0, 1.0 - srca / dsta);
d350 1
a350 1
	    Fa = max (0.0, 1.0 - dsta / srca);
d357 1
a357 1
	    Fa = min (1.0, dsta / srca);
d364 1
a364 1
	    Fb = min (1.0, srca / dsta);
d371 1
a371 1
	    Fa = max (0.0, 1.0 - dsta / srca);
d378 1
a378 1
	    Fb = max (0.0, 1.0 - srca / dsta);
d385 1
a385 1
	    Fa = min (1.0, dsta / srca);
d389 1
a389 1
	    Fb = max (0.0, 1.0 - srca / dsta);
d396 1
a396 1
	    Fa = max (0.0, 1.0 - dsta / srca);
d400 1
a400 1
	    Fb = min (1.0, srca / dsta);
d407 1
a407 1
	    Fa = max (0.0, 1.0 - dsta / srca);
d411 1
a411 1
	    Fb = max (0.0, 1.0 - srca / dsta);
d431 1
d561 7
d626 1
a626 1
    return max (max (max (rdiff, gdiff), bdiff), adiff);
d630 1
a630 1
describe_image (image_t *info, char *buf, int buflen)
d634 4
a637 4
	snprintf (buf, buflen, "%s %dx%d%s",
		  info->format->name,
		  info->size, info->size,
		  info->repeat ? "R" :"");
d641 1
a641 1
	snprintf (buf, buflen, "solid");
d723 3
a725 4
	snprintf (buf, sizeof (buf),
		  "%s %scomposite",
		  op->name,
		  component_alpha ? "CA " : "");
d747 3
a749 3
	    printf ("src: %s, ", describe_image (src, buf, sizeof (buf)));
	    printf ("mask: %s, ", describe_image (mask, buf, sizeof (buf)));
	    printf ("dst: %s\n\n", describe_image (dst, buf, sizeof (buf)));
d759 2
a760 2
	    printf ("src: %s, ", describe_image (src, buf, sizeof (buf)));
	    printf ("dst: %s\n\n", describe_image (dst, buf, sizeof (buf)));
d880 1
a880 1
    int i;
d902 5
d908 1
a908 1
#   pragma omp parallel for default(none) shared(result) shared(argv) 
d910 1
a910 1
    for (i = 1; i <= N_TESTS; ++i)
d912 1
a912 1
	if (!result && !run_test (i))
d914 3
a916 3
	    printf ("Test %d failed.\n", i);

	    result = i;
@


1.1
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d2 4
a5 2
 * Copyright © 2005 Eric Anholt
 * Copyright © 2009 Chris Wilson
d25 1
a25 1

d31 2
a32 3

#define FALSE 0
#define TRUE !FALSE
d54 1
a54 1
static color_t colors[] =
a55 1
    /* these are premultiplied in main() */
d57 3
a62 1
    { 0.0, 0.0, 0.0, 1.0 },
d87 11
a100 1
    P(a8),
d102 1
a102 1
    /* 32bpp formats */
a108 3

    /* XXX: and here the errors begin! */
#if 0
d110 1
a111 1
    P(x2b10g10r10),
d114 1
a114 1
    /* 24bpp formats */
a116 2

    /* 16bpp formats */
d120 3
a123 1
    P(x1r5g5b5),
d125 2
a126 1
    P(x1b5g5r5),
a128 2
    P(a4b4g4r4),
    P(x4b4g4r4),
d130 1
a130 1
    /* 8bpp formats */
a135 1

d138 1
a138 1
    /* 4bpp formats */
d145 1
a145 1
    /* 1bpp formats */
a146 1
#endif
d491 3
a493 2
#define round_pix(pix, mask) \
    ((int)((pix) * (mask) + .5) / (double) (mask))
d514 1
d605 1
a605 1
eval_diff (color_t *expected, color_t *test)
d610 4
a613 7
    /* XXX: Need to be provided mask shifts so we can produce useful error
     * values.
     */
    rscale = 1.0 * (1 << 5);
    gscale = 1.0 * (1 << 6);
    bscale = 1.0 * (1 << 5);
    ascale = 1.0 * 32;
d707 6
a712 1
    diff = eval_diff (&expected, &result);
d730 1
a730 1
	
a763 3
#define REPEAT 0x01000000
#define FLAGS  0xff000000

d776 1
a776 1
    info->size = size & ~FLAGS;
d810 20
a829 2
int
main (void)
d831 14
a844 5
    pixman_bool_t ok, group_ok = TRUE, ca;
    int i, d, m, s;
    int tests_passed = 0, tests_total = 0;
    int sizes[] = { 1, 1 | REPEAT, 10 };
    int num_tests;
d846 1
a846 1
    for (i = 0; i < ARRAY_LENGTH (colors); i++)
d848 13
a860 3
	colors[i].r *= colors[i].a;
	colors[i].g *= colors[i].a;
	colors[i].b *= colors[i].a;
d863 3
a865 1
    num_tests = ARRAY_LENGTH (colors) * ARRAY_LENGTH (formats);
d867 2
a868 3
    for (d = 0; d < num_tests; d++)
    {
	image_t dst;
d870 6
a875 2
	image_init (
	    &dst, d / ARRAY_LENGTH (formats), d % ARRAY_LENGTH (formats), 1);
d877 5
d883 1
a883 3
	for (s = -ARRAY_LENGTH (colors);
	     s < ARRAY_LENGTH (sizes) * num_tests;
	     s++)
d885 2
a886 6
	    image_t src;

	    if (s < 0)
	    {
		image_init (&src, -s - 1, 0, 0);
	    }
d888 8
a895 6
	    {
		image_init (&src,
			    s / ARRAY_LENGTH (sizes) / ARRAY_LENGTH (formats),
			    s / ARRAY_LENGTH (sizes) % ARRAY_LENGTH (formats),
			    sizes[s % ARRAY_LENGTH (sizes)]);
	    }
d897 8
a904 45
	    for (m = -ARRAY_LENGTH (colors);
		 m < ARRAY_LENGTH (sizes) * num_tests;
		 m++)
	    {
		image_t mask;

		if (m < 0)
		{
		    image_init (&mask, -m - 1, 0, 0);
		}
		else
		{
		    image_init (
			&mask,
			m / ARRAY_LENGTH (sizes) / ARRAY_LENGTH (formats),
			m / ARRAY_LENGTH (sizes) % ARRAY_LENGTH (formats),
			sizes[m % ARRAY_LENGTH (sizes)]);
		}

		for (ca = -1; ca <= 1; ca++)
		{
		    for (i = 0; i < ARRAY_LENGTH (operators); i++)
		    {
			const operator_t *op = &operators[i];

			switch (ca)
			{
			case -1:
			    ok = composite_test (&dst, op, &src, NULL, FALSE);
			    break;
			case 0:
			    ok = composite_test (&dst, op, &src, &mask, FALSE);
			    break;
			case 1:
			    ok = composite_test (&dst, op, &src, &mask,
						 mask.size? TRUE : FALSE);
			    break;
                        default:
                            break;
			}
			group_ok = group_ok && ok;
			tests_passed += ok;
			tests_total++;
		    }
		}
d906 1
a906 3
		image_fini (&mask);
	    }
	    image_fini (&src);
a907 1
	image_fini (&dst);
d909 2
a910 2

    return group_ok == FALSE;
@

