head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.6
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "compint.h"

static void
compScreenUpdate(ScreenPtr pScreen)
{
    compCheckTree(pScreen);
    compPaintChildrenToWindow(pScreen->root);
}

static void
compBlockHandler(ScreenPtr pScreen, void *pTimeout, void *pReadmask)
{
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->BlockHandler = cs->BlockHandler;
    compScreenUpdate(pScreen);
    (*pScreen->BlockHandler) (pScreen, pTimeout, pReadmask);

    /* Next damage will restore the block handler */
    cs->BlockHandler = NULL;
}

static void
compReportDamage(DamagePtr pDamage, RegionPtr pRegion, void *closure)
{
    WindowPtr pWin = (WindowPtr) closure;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    CompWindowPtr cw = GetCompWindow(pWin);

    if (!cs->BlockHandler) {
        cs->BlockHandler = pScreen->BlockHandler;
        pScreen->BlockHandler = compBlockHandler;
    }
    cw->damaged = TRUE;

    /* Mark the ancestors */
    pWin = pWin->parent;
    while (pWin) {
        if (pWin->damagedDescendants)
            break;
        pWin->damagedDescendants = TRUE;
        pWin = pWin->parent;
    }
}

static void
compDestroyDamage(DamagePtr pDamage, void *closure)
{
    WindowPtr pWin = (WindowPtr) closure;
    CompWindowPtr cw = GetCompWindow(pWin);

    cw->damage = 0;
}

static Bool
compMarkWindows(WindowPtr pWin, WindowPtr *ppLayerWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr pLayerWin = pWin;

    if (!pWin->viewable)
        return FALSE;

    (*pScreen->MarkOverlappedWindows) (pWin, pWin, &pLayerWin);
    (*pScreen->MarkWindow) (pLayerWin->parent);

    *ppLayerWin = pLayerWin;

    return TRUE;
}

static void
compHandleMarkedWindows(WindowPtr pWin, WindowPtr pLayerWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    (*pScreen->ValidateTree) (pLayerWin->parent, pLayerWin, VTOther);
    (*pScreen->HandleExposures) (pLayerWin->parent);
    if (pScreen->PostValidateTree)
        (*pScreen->PostValidateTree) (pLayerWin->parent, pLayerWin, VTOther);
}

/*
 * Redirect one window for one client
 */
int
compRedirectWindow(ClientPtr pClient, WindowPtr pWin, int update)
{
    CompWindowPtr cw = GetCompWindow(pWin);
    CompClientWindowPtr ccw;
    CompScreenPtr cs = GetCompScreen(pWin->drawable.pScreen);
    WindowPtr pLayerWin;
    Bool anyMarked = FALSE;

    if (pWin == cs->pOverlayWin) {
        return Success;
    }

    if (!pWin->parent)
        return BadMatch;

    /*
     * Only one Manual update is allowed
     */
    if (cw && update == CompositeRedirectManual)
        for (ccw = cw->clients; ccw; ccw = ccw->next)
            if (ccw->update == CompositeRedirectManual)
                return BadAccess;

    /*
     * Allocate per-client per-window structure
     * The client *could* allocate multiple, but while supported,
     * it is not expected to be common
     */
    ccw = malloc(sizeof(CompClientWindowRec));
    if (!ccw)
        return BadAlloc;
    ccw->id = FakeClientID(pClient->index);
    ccw->update = update;
    /*
     * Now make sure there's a per-window structure to hang this from
     */
    if (!cw) {
        cw = malloc(sizeof(CompWindowRec));
        if (!cw) {
            free(ccw);
            return BadAlloc;
        }
        cw->damage = DamageCreate(compReportDamage,
                                  compDestroyDamage,
                                  DamageReportNonEmpty,
                                  FALSE, pWin->drawable.pScreen, pWin);
        if (!cw->damage) {
            free(ccw);
            free(cw);
            return BadAlloc;
        }

        anyMarked = compMarkWindows(pWin, &pLayerWin);

        RegionNull(&cw->borderClip);
        cw->update = CompositeRedirectAutomatic;
        cw->clients = 0;
        cw->oldx = COMP_ORIGIN_INVALID;
        cw->oldy = COMP_ORIGIN_INVALID;
        cw->damageRegistered = FALSE;
        cw->damaged = FALSE;
        cw->pOldPixmap = NullPixmap;
        dixSetPrivate(&pWin->devPrivates, CompWindowPrivateKey, cw);
    }
    ccw->next = cw->clients;
    cw->clients = ccw;
    if (!AddResource(ccw->id, CompositeClientWindowType, pWin))
        return BadAlloc;
    if (ccw->update == CompositeRedirectManual) {
        if (!anyMarked)
            anyMarked = compMarkWindows(pWin, &pLayerWin);

        if (cw->damageRegistered) {
            DamageUnregister(cw->damage);
            cw->damageRegistered = FALSE;
        }
        cw->update = CompositeRedirectManual;
    }
    else if (cw->update == CompositeRedirectAutomatic && !cw->damageRegistered) {
        if (!anyMarked)
            anyMarked = compMarkWindows(pWin, &pLayerWin);
    }

    if (!compCheckRedirect(pWin)) {
        FreeResource(ccw->id, RT_NONE);
        return BadAlloc;
    }

    if (anyMarked)
        compHandleMarkedWindows(pWin, pLayerWin);

    return Success;
}

void
compRestoreWindow(WindowPtr pWin, PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr pParent = pWin->parent;

    if (pParent->drawable.depth == pWin->drawable.depth) {
        GCPtr pGC = GetScratchGC(pWin->drawable.depth, pScreen);
        int bw = (int) pWin->borderWidth;
        int x = bw;
        int y = bw;
        int w = pWin->drawable.width;
        int h = pWin->drawable.height;

        if (pGC) {
            ChangeGCVal val;

            val.val = IncludeInferiors;
            ChangeGC(NullClient, pGC, GCSubwindowMode, &val);
            ValidateGC(&pWin->drawable, pGC);
            (*pGC->ops->CopyArea) (&pPixmap->drawable,
                                   &pWin->drawable, pGC, x, y, w, h, 0, 0);
            FreeScratchGC(pGC);
        }
    }
}

/*
 * Free one of the per-client per-window resources, clearing
 * redirect and the per-window pointer as appropriate
 */
void
compFreeClientWindow(WindowPtr pWin, XID id)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompWindowPtr cw = GetCompWindow(pWin);
    CompClientWindowPtr ccw, *prev;
    Bool anyMarked = FALSE;
    WindowPtr pLayerWin;
    PixmapPtr pPixmap = NULL;

    if (!cw)
        return;
    for (prev = &cw->clients; (ccw = *prev); prev = &ccw->next) {
        if (ccw->id == id) {
            *prev = ccw->next;
            if (ccw->update == CompositeRedirectManual)
                cw->update = CompositeRedirectAutomatic;
            free(ccw);
            break;
        }
    }
    if (!cw->clients) {
        anyMarked = compMarkWindows(pWin, &pLayerWin);

        if (pWin->redirectDraw != RedirectDrawNone) {
            pPixmap = (*pScreen->GetWindowPixmap) (pWin);
            compSetParentPixmap(pWin);
        }

        if (cw->damage)
            DamageDestroy(cw->damage);

        RegionUninit(&cw->borderClip);

        dixSetPrivate(&pWin->devPrivates, CompWindowPrivateKey, NULL);
        free(cw);
    }
    else if (cw->update == CompositeRedirectAutomatic &&
             !cw->damageRegistered && pWin->redirectDraw != RedirectDrawNone) {
        anyMarked = compMarkWindows(pWin, &pLayerWin);

        DamageRegister(&pWin->drawable, cw->damage);
        cw->damageRegistered = TRUE;
        pWin->redirectDraw = RedirectDrawAutomatic;
        DamageDamageRegion(&pWin->drawable, &pWin->borderSize);
    }

    if (anyMarked)
        compHandleMarkedWindows(pWin, pLayerWin);

    if (pPixmap) {
        compRestoreWindow(pWin, pPixmap);
        (*pScreen->DestroyPixmap) (pPixmap);
    }
}

/*
 * This is easy, just free the appropriate resource.
 */

int
compUnredirectWindow(ClientPtr pClient, WindowPtr pWin, int update)
{
    CompWindowPtr cw = GetCompWindow(pWin);
    CompClientWindowPtr ccw;

    if (!cw)
        return BadValue;

    for (ccw = cw->clients; ccw; ccw = ccw->next)
        if (ccw->update == update && CLIENT_ID(ccw->id) == pClient->index) {
            FreeResource(ccw->id, RT_NONE);
            return Success;
        }
    return BadValue;
}

/*
 * Redirect all subwindows for one client
 */

int
compRedirectSubwindows(ClientPtr pClient, WindowPtr pWin, int update)
{
    CompSubwindowsPtr csw = GetCompSubwindows(pWin);
    CompClientWindowPtr ccw;
    WindowPtr pChild;

    /*
     * Only one Manual update is allowed
     */
    if (csw && update == CompositeRedirectManual)
        for (ccw = csw->clients; ccw; ccw = ccw->next)
            if (ccw->update == CompositeRedirectManual)
                return BadAccess;
    /*
     * Allocate per-client per-window structure
     * The client *could* allocate multiple, but while supported,
     * it is not expected to be common
     */
    ccw = malloc(sizeof(CompClientWindowRec));
    if (!ccw)
        return BadAlloc;
    ccw->id = FakeClientID(pClient->index);
    ccw->update = update;
    /*
     * Now make sure there's a per-window structure to hang this from
     */
    if (!csw) {
        csw = malloc(sizeof(CompSubwindowsRec));
        if (!csw) {
            free(ccw);
            return BadAlloc;
        }
        csw->update = CompositeRedirectAutomatic;
        csw->clients = 0;
        dixSetPrivate(&pWin->devPrivates, CompSubwindowsPrivateKey, csw);
    }
    /*
     * Redirect all existing windows
     */
    for (pChild = pWin->lastChild; pChild; pChild = pChild->prevSib) {
        int ret = compRedirectWindow(pClient, pChild, update);

        if (ret != Success) {
            for (pChild = pChild->nextSib; pChild; pChild = pChild->nextSib)
                (void) compUnredirectWindow(pClient, pChild, update);
            if (!csw->clients) {
                free(csw);
                dixSetPrivate(&pWin->devPrivates, CompSubwindowsPrivateKey, 0);
            }
            free(ccw);
            return ret;
        }
    }
    /*
     * Hook into subwindows list
     */
    ccw->next = csw->clients;
    csw->clients = ccw;
    if (!AddResource(ccw->id, CompositeClientSubwindowsType, pWin))
        return BadAlloc;
    if (ccw->update == CompositeRedirectManual) {
        csw->update = CompositeRedirectManual;
        /*
         * tell damage extension that damage events for this client are
         * critical output
         */
        DamageExtSetCritical(pClient, TRUE);
        pWin->inhibitBGPaint = TRUE;
    }
    return Success;
}

/*
 * Free one of the per-client per-subwindows resources,
 * which frees one redirect per subwindow
 */
void
compFreeClientSubwindows(WindowPtr pWin, XID id)
{
    CompSubwindowsPtr csw = GetCompSubwindows(pWin);
    CompClientWindowPtr ccw, *prev;
    WindowPtr pChild;

    if (!csw)
        return;
    for (prev = &csw->clients; (ccw = *prev); prev = &ccw->next) {
        if (ccw->id == id) {
            ClientPtr pClient = clients[CLIENT_ID(id)];

            *prev = ccw->next;
            if (ccw->update == CompositeRedirectManual) {
                /*
                 * tell damage extension that damage events for this client are
                 * critical output
                 */
                DamageExtSetCritical(pClient, FALSE);
                csw->update = CompositeRedirectAutomatic;
                pWin->inhibitBGPaint = FALSE;
                if (pWin->mapped)
                    (*pWin->drawable.pScreen->ClearToBackground) (pWin, 0, 0, 0,
                                                                  0, TRUE);
            }

            /*
             * Unredirect all existing subwindows
             */
            for (pChild = pWin->lastChild; pChild; pChild = pChild->prevSib)
                (void) compUnredirectWindow(pClient, pChild, ccw->update);

            free(ccw);
            break;
        }
    }

    /*
     * Check if all of the per-client records are gone
     */
    if (!csw->clients) {
        dixSetPrivate(&pWin->devPrivates, CompSubwindowsPrivateKey, NULL);
        free(csw);
    }
}

/*
 * This is easy, just free the appropriate resource.
 */

int
compUnredirectSubwindows(ClientPtr pClient, WindowPtr pWin, int update)
{
    CompSubwindowsPtr csw = GetCompSubwindows(pWin);
    CompClientWindowPtr ccw;

    if (!csw)
        return BadValue;
    for (ccw = csw->clients; ccw; ccw = ccw->next)
        if (ccw->update == update && CLIENT_ID(ccw->id) == pClient->index) {
            FreeResource(ccw->id, RT_NONE);
            return Success;
        }
    return BadValue;
}

/*
 * Add redirection information for one subwindow (during reparent)
 */

int
compRedirectOneSubwindow(WindowPtr pParent, WindowPtr pWin)
{
    CompSubwindowsPtr csw = GetCompSubwindows(pParent);
    CompClientWindowPtr ccw;

    if (!csw)
        return Success;
    for (ccw = csw->clients; ccw; ccw = ccw->next) {
        int ret = compRedirectWindow(clients[CLIENT_ID(ccw->id)],
                                     pWin, ccw->update);

        if (ret != Success)
            return ret;
    }
    return Success;
}

/*
 * Remove redirection information for one subwindow (during reparent)
 */

int
compUnredirectOneSubwindow(WindowPtr pParent, WindowPtr pWin)
{
    CompSubwindowsPtr csw = GetCompSubwindows(pParent);
    CompClientWindowPtr ccw;

    if (!csw)
        return Success;
    for (ccw = csw->clients; ccw; ccw = ccw->next) {
        int ret = compUnredirectWindow(clients[CLIENT_ID(ccw->id)],
                                       pWin, ccw->update);

        if (ret != Success)
            return ret;
    }
    return Success;
}

static PixmapPtr
compNewPixmap(WindowPtr pWin, int x, int y, int w, int h)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr pParent = pWin->parent;
    PixmapPtr pPixmap;

    pPixmap = (*pScreen->CreatePixmap) (pScreen, w, h, pWin->drawable.depth,
                                        CREATE_PIXMAP_USAGE_BACKING_PIXMAP);

    if (!pPixmap)
        return 0;

    pPixmap->screen_x = x;
    pPixmap->screen_y = y;

    if (pParent->drawable.depth == pWin->drawable.depth) {
        GCPtr pGC = GetScratchGC(pWin->drawable.depth, pScreen);

        if (pGC) {
            ChangeGCVal val;

            val.val = IncludeInferiors;
            ChangeGC(NullClient, pGC, GCSubwindowMode, &val);
            ValidateGC(&pPixmap->drawable, pGC);
            (*pGC->ops->CopyArea) (&pParent->drawable,
                                   &pPixmap->drawable,
                                   pGC,
                                   x - pParent->drawable.x,
                                   y - pParent->drawable.y, w, h, 0, 0);
            FreeScratchGC(pGC);
        }
    }
    else {
        PictFormatPtr pSrcFormat = PictureWindowFormat(pParent);
        PictFormatPtr pDstFormat = PictureWindowFormat(pWin);
        XID inferiors = IncludeInferiors;
        int error;

        PicturePtr pSrcPicture = CreatePicture(None,
                                               &pParent->drawable,
                                               pSrcFormat,
                                               CPSubwindowMode,
                                               &inferiors,
                                               serverClient, &error);

        PicturePtr pDstPicture = CreatePicture(None,
                                               &pPixmap->drawable,
                                               pDstFormat,
                                               0, 0,
                                               serverClient, &error);

        if (pSrcPicture && pDstPicture) {
            CompositePicture(PictOpSrc,
                             pSrcPicture,
                             NULL,
                             pDstPicture,
                             x - pParent->drawable.x,
                             y - pParent->drawable.y, 0, 0, 0, 0, w, h);
        }
        if (pSrcPicture)
            FreePicture(pSrcPicture, 0);
        if (pDstPicture)
            FreePicture(pDstPicture, 0);
    }
    return pPixmap;
}

Bool
compAllocPixmap(WindowPtr pWin)
{
    int bw = (int) pWin->borderWidth;
    int x = pWin->drawable.x - bw;
    int y = pWin->drawable.y - bw;
    int w = pWin->drawable.width + (bw << 1);
    int h = pWin->drawable.height + (bw << 1);
    PixmapPtr pPixmap = compNewPixmap(pWin, x, y, w, h);
    CompWindowPtr cw = GetCompWindow(pWin);

    if (!pPixmap)
        return FALSE;
    if (cw->update == CompositeRedirectAutomatic)
        pWin->redirectDraw = RedirectDrawAutomatic;
    else
        pWin->redirectDraw = RedirectDrawManual;

    compSetPixmap(pWin, pPixmap);
    cw->oldx = COMP_ORIGIN_INVALID;
    cw->oldy = COMP_ORIGIN_INVALID;
    cw->damageRegistered = FALSE;
    if (cw->update == CompositeRedirectAutomatic) {
        DamageRegister(&pWin->drawable, cw->damage);
        cw->damageRegistered = TRUE;
    }

    /* Make sure our borderClip is up to date */
    RegionUninit(&cw->borderClip);
    RegionCopy(&cw->borderClip, &pWin->borderClip);
    cw->borderClipX = pWin->drawable.x;
    cw->borderClipY = pWin->drawable.y;

    return TRUE;
}

void
compSetParentPixmap(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    PixmapPtr pParentPixmap;
    CompWindowPtr cw = GetCompWindow(pWin);

    if (cw->damageRegistered) {
        DamageUnregister(cw->damage);
        cw->damageRegistered = FALSE;
        DamageEmpty(cw->damage);
    }
    /*
     * Move the parent-constrained border clip region back into
     * the window so that ValidateTree will handle the unmap
     * case correctly.  Unmap adds the window borderClip to the
     * parent exposed area; regions beyond the parent cause crashes
     */
    RegionCopy(&pWin->borderClip, &cw->borderClip);
    pParentPixmap = (*pScreen->GetWindowPixmap) (pWin->parent);
    pWin->redirectDraw = RedirectDrawNone;
    compSetPixmap(pWin, pParentPixmap);
}

/*
 * Make sure the pixmap is the right size and offset.  Allocate a new
 * pixmap to change size, adjust origin to change offset, leaving the
 * old pixmap in cw->pOldPixmap so bits can be recovered
 */
Bool
compReallocPixmap(WindowPtr pWin, int draw_x, int draw_y,
                  unsigned int w, unsigned int h, int bw)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    PixmapPtr pOld = (*pScreen->GetWindowPixmap) (pWin);
    PixmapPtr pNew;
    CompWindowPtr cw = GetCompWindow(pWin);
    int pix_x, pix_y;
    int pix_w, pix_h;

    assert(cw && pWin->redirectDraw != RedirectDrawNone);
    cw->oldx = pOld->screen_x;
    cw->oldy = pOld->screen_y;
    pix_x = draw_x - bw;
    pix_y = draw_y - bw;
    pix_w = w + (bw << 1);
    pix_h = h + (bw << 1);
    if (pix_w != pOld->drawable.width || pix_h != pOld->drawable.height) {
        pNew = compNewPixmap(pWin, pix_x, pix_y, pix_w, pix_h);
        if (!pNew)
            return FALSE;
        cw->pOldPixmap = pOld;
        compSetPixmap(pWin, pNew);
    }
    else {
        pNew = pOld;
        cw->pOldPixmap = 0;
    }
    pNew->screen_x = pix_x;
    pNew->screen_y = pix_y;
    return TRUE;
}
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d159 1
a159 1
     * Allocate per-client per-window structure 
d356 1
a356 1
     * Allocate per-client per-window structure 
d404 1
a404 1
        /* 
d433 1
a433 1
                /* 
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d58 1
a58 1
compBlockHandler(ScreenPtr pScreen, pointer pTimeout, pointer pReadmask)
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d208 1
a208 1
            DamageUnregister(&pWin->drawable, cw->damage);
d641 1
a641 1
        DamageUnregister(&pWin->drawable, cw->damage);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d58 1
a58 1
compBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
a59 1
    ScreenPtr pScreen = screenInfo.screens[i];
d64 1
a64 1
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
d563 2
a564 2
        PictFormatPtr pSrcFormat = compWindowFormat(pParent);
        PictFormatPtr pDstFormat = compWindowFormat(pWin);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d51 1
a51 1
compScreenUpdate (ScreenPtr pScreen)
d53 2
a54 2
    compCheckTree (pScreen);
    compPaintChildrenToWindow (pScreen->root);
d58 1
a58 4
compBlockHandler (int	    i,
		  pointer   blockData,
		  pointer   pTimeout,
		  pointer   pReadmask)
d60 2
a61 2
    ScreenPtr	    pScreen = screenInfo.screens[i];
    CompScreenPtr   cs = GetCompScreen (pScreen);
d64 1
a64 1
    compScreenUpdate (pScreen);
d72 1
a72 1
compReportDamage (DamagePtr pDamage, RegionPtr pRegion, void *closure)
d74 4
a77 4
    WindowPtr	    pWin = (WindowPtr) closure;
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    CompScreenPtr   cs = GetCompScreen (pScreen);
    CompWindowPtr   cw = GetCompWindow (pWin);
d88 4
a91 4
	if (pWin->damagedDescendants)
	    break;
	pWin->damagedDescendants = TRUE;
	pWin = pWin->parent;
d96 1
a96 1
compDestroyDamage (DamagePtr pDamage, void *closure)
d98 2
a99 2
    WindowPtr	    pWin = (WindowPtr) closure;
    CompWindowPtr   cw = GetCompWindow (pWin);
d105 1
a105 2
compMarkWindows(WindowPtr pWin,
		WindowPtr *ppLayerWin)
d111 1
a111 1
	return FALSE;
d113 2
a114 2
    (*pScreen->MarkOverlappedWindows)(pWin, pWin, &pLayerWin);
    (*pScreen->MarkWindow)(pLayerWin->parent);
d126 2
a127 2
    (*pScreen->ValidateTree)(pLayerWin->parent, pLayerWin, VTOther);
    (*pScreen->HandleExposures)(pLayerWin->parent);
d129 1
a129 1
	(*pScreen->PostValidateTree)(pLayerWin->parent, pLayerWin, VTOther);
d136 1
a136 1
compRedirectWindow (ClientPtr pClient, WindowPtr pWin, int update)
d138 6
a143 6
    CompWindowPtr	cw = GetCompWindow (pWin);
    CompClientWindowPtr	ccw;
    CompScreenPtr       cs = GetCompScreen(pWin->drawable.pScreen);
    WindowPtr		pLayerWin;
    Bool		anyMarked = FALSE;
    
d145 1
a145 1
	return Success;
d149 1
a149 1
	return BadMatch;
d155 4
a158 4
	for (ccw = cw->clients; ccw; ccw = ccw->next)
	    if (ccw->update == CompositeRedirectManual)
		return BadAccess;
    
d164 1
a164 1
    ccw = malloc(sizeof (CompClientWindowRec));
d166 2
a167 2
	return BadAlloc;
    ccw->id = FakeClientID (pClient->index);
d172 27
a198 32
    if (!cw)
    {
	cw = malloc(sizeof (CompWindowRec));
	if (!cw)
	{
	    free(ccw);
	    return BadAlloc;
	}
	cw->damage = DamageCreate (compReportDamage,
				   compDestroyDamage,
				   DamageReportNonEmpty,
				   FALSE,
				   pWin->drawable.pScreen,
				   pWin);
	if (!cw->damage)
	{
	    free(ccw);
	    free(cw);
	    return BadAlloc;
	}

	anyMarked = compMarkWindows (pWin, &pLayerWin);

	RegionNull(&cw->borderClip);
	cw->update = CompositeRedirectAutomatic;
	cw->clients = 0;
	cw->oldx = COMP_ORIGIN_INVALID;
	cw->oldy = COMP_ORIGIN_INVALID;
	cw->damageRegistered = FALSE;
	cw->damaged = FALSE;
	cw->pOldPixmap = NullPixmap;
	dixSetPrivate(&pWin->devPrivates, CompWindowPrivateKey, cw);
d202 11
a212 13
    if (!AddResource (ccw->id, CompositeClientWindowType, pWin))
	return BadAlloc;
    if (ccw->update == CompositeRedirectManual)
    {
	if (!anyMarked)
	    anyMarked = compMarkWindows (pWin, &pLayerWin);

	if (cw->damageRegistered)
	{
	    DamageUnregister (&pWin->drawable, cw->damage);
	    cw->damageRegistered = FALSE;
	}
	cw->update = CompositeRedirectManual;
d215 2
a216 2
	if (!anyMarked)
	    anyMarked = compMarkWindows (pWin, &pLayerWin);
d219 3
a221 4
    if (!compCheckRedirect (pWin))
    {
	FreeResource (ccw->id, RT_NONE);
	return BadAlloc;
d225 2
a226 2
	compHandleMarkedWindows (pWin, pLayerWin);
    
d231 1
a231 1
compRestoreWindow (WindowPtr pWin, PixmapPtr pPixmap)
d237 17
a253 18
	GCPtr pGC = GetScratchGC (pWin->drawable.depth, pScreen);
	int bw = (int) pWin->borderWidth;
	int x = bw;
	int y = bw;
	int w = pWin->drawable.width;
	int h = pWin->drawable.height;

	if (pGC) {
	    ChangeGCVal val;
	    val.val = IncludeInferiors;
	    ChangeGC (NullClient, pGC, GCSubwindowMode, &val);
	    ValidateGC(&pWin->drawable, pGC);
	    (*pGC->ops->CopyArea) (&pPixmap->drawable,
				   &pWin->drawable,
				   pGC,
				   x, y, w, h, 0, 0);
	    FreeScratchGC (pGC);
	}
d262 1
a262 1
compFreeClientWindow (WindowPtr pWin, XID id)
d264 6
a269 6
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompWindowPtr	cw = GetCompWindow (pWin);
    CompClientWindowPtr	ccw, *prev;
    Bool		anyMarked = FALSE;
    WindowPtr		pLayerWin;
    PixmapPtr           pPixmap = NULL;
d272 25
a296 28
	return;
    for (prev = &cw->clients; (ccw = *prev); prev = &ccw->next)
    {
	if (ccw->id == id)
	{
	    *prev = ccw->next;
	    if (ccw->update == CompositeRedirectManual)
		cw->update = CompositeRedirectAutomatic;
	    free(ccw);
	    break;
	}
    }
    if (!cw->clients)
    {
	anyMarked = compMarkWindows (pWin, &pLayerWin);
    
	if (pWin->redirectDraw != RedirectDrawNone) {
	    pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	    compSetParentPixmap (pWin);
	}

	if (cw->damage)
	    DamageDestroy (cw->damage);
	
	RegionUninit(&cw->borderClip);
    
	dixSetPrivate(&pWin->devPrivates, CompWindowPrivateKey, NULL);
	free(cw);
d299 7
a305 8
	     !cw->damageRegistered && pWin->redirectDraw != RedirectDrawNone)
    {
	anyMarked = compMarkWindows (pWin, &pLayerWin);

	DamageRegister (&pWin->drawable, cw->damage);
	cw->damageRegistered = TRUE;
	pWin->redirectDraw = RedirectDrawAutomatic;
	DamageDamageRegion(&pWin->drawable, &pWin->borderSize);
d309 1
a309 1
	compHandleMarkedWindows (pWin, pLayerWin);
d312 2
a313 2
	compRestoreWindow (pWin, pPixmap);
	(*pScreen->DestroyPixmap) (pPixmap);
d322 1
a322 1
compUnredirectWindow (ClientPtr pClient, WindowPtr pWin, int update)
d324 2
a325 2
    CompWindowPtr	cw = GetCompWindow (pWin);
    CompClientWindowPtr	ccw;
d328 1
a328 1
	return BadValue;
d331 4
a334 5
	if (ccw->update == update && CLIENT_ID(ccw->id) == pClient->index)
	{
	    FreeResource (ccw->id, RT_NONE);
	    return Success;
	}
d337 1
a337 1
	
d343 1
a343 1
compRedirectSubwindows (ClientPtr pClient, WindowPtr pWin, int update)
d345 3
a347 3
    CompSubwindowsPtr	csw = GetCompSubwindows (pWin);
    CompClientWindowPtr	ccw;
    WindowPtr		pChild;
d353 3
a355 3
	for (ccw = csw->clients; ccw; ccw = ccw->next)
	    if (ccw->update == CompositeRedirectManual)
		return BadAccess;
d361 1
a361 1
    ccw = malloc(sizeof (CompClientWindowRec));
d363 2
a364 2
	return BadAlloc;
    ccw->id = FakeClientID (pClient->index);
d369 9
a377 11
    if (!csw)
    {
	csw = malloc(sizeof (CompSubwindowsRec));
	if (!csw)
	{
	    free(ccw);
	    return BadAlloc;
	}
	csw->update = CompositeRedirectAutomatic;
	csw->clients = 0;
	dixSetPrivate(&pWin->devPrivates, CompSubwindowsPrivateKey, csw);
d382 13
a394 15
    for (pChild = pWin->lastChild; pChild; pChild = pChild->prevSib)
    {
	int ret = compRedirectWindow (pClient, pChild, update);
	if (ret != Success)
	{
	    for (pChild = pChild->nextSib; pChild; pChild = pChild->nextSib)
		(void) compUnredirectWindow (pClient, pChild, update);
	    if (!csw->clients)
	    {
		free(csw);
		dixSetPrivate(&pWin->devPrivates, CompSubwindowsPrivateKey, 0);
	    }
	    free(ccw);
	    return ret;
	}
d401 10
a410 11
    if (!AddResource (ccw->id, CompositeClientSubwindowsType, pWin))
	return BadAlloc;
    if (ccw->update == CompositeRedirectManual)
    {
	csw->update = CompositeRedirectManual;
	/* 
	 * tell damage extension that damage events for this client are
	 * critical output
	 */
	DamageExtSetCritical (pClient, TRUE);
	pWin->inhibitBGPaint = TRUE;
d420 1
a420 1
compFreeClientSubwindows (WindowPtr pWin, XID id)
d422 3
a424 3
    CompSubwindowsPtr	csw = GetCompSubwindows (pWin);
    CompClientWindowPtr	ccw, *prev;
    WindowPtr		pChild;
d427 28
a454 30
	return;
    for (prev = &csw->clients; (ccw = *prev); prev = &ccw->next)
    {
	if (ccw->id == id)
	{
	    ClientPtr	pClient = clients[CLIENT_ID(id)];
	    
	    *prev = ccw->next;
	    if (ccw->update == CompositeRedirectManual)
	    {
		/* 
		 * tell damage extension that damage events for this client are
		 * critical output
		 */
		DamageExtSetCritical (pClient, FALSE);
		csw->update = CompositeRedirectAutomatic;
		pWin->inhibitBGPaint = FALSE;
		if (pWin->mapped)
		    (*pWin->drawable.pScreen->ClearToBackground)(pWin, 0, 0, 0, 0, TRUE);
	    }

	    /*
	     * Unredirect all existing subwindows
	     */
	    for (pChild = pWin->lastChild; pChild; pChild = pChild->prevSib)
		(void) compUnredirectWindow (pClient, pChild, ccw->update);

	    free(ccw);
	    break;
	}
d460 3
a462 4
    if (!csw->clients)
    {
	dixSetPrivate(&pWin->devPrivates, CompSubwindowsPrivateKey, NULL);
	free(csw);
d471 1
a471 1
compUnredirectSubwindows (ClientPtr pClient, WindowPtr pWin, int update)
d473 3
a475 3
    CompSubwindowsPtr	csw = GetCompSubwindows (pWin);
    CompClientWindowPtr	ccw;
    
d477 1
a477 1
	return BadValue;
d479 4
a482 5
	if (ccw->update == update && CLIENT_ID(ccw->id) == pClient->index)
	{
	    FreeResource (ccw->id, RT_NONE);
	    return Success;
	}
d491 1
a491 1
compRedirectOneSubwindow (WindowPtr pParent, WindowPtr pWin)
d493 2
a494 2
    CompSubwindowsPtr	csw = GetCompSubwindows (pParent);
    CompClientWindowPtr	ccw;
d497 7
a503 7
	return Success;
    for (ccw = csw->clients; ccw; ccw = ccw->next)
    {
	int ret = compRedirectWindow (clients[CLIENT_ID(ccw->id)],
				      pWin, ccw->update);
	if (ret != Success)
	    return ret;
d513 1
a513 1
compUnredirectOneSubwindow (WindowPtr pParent, WindowPtr pWin)
d515 2
a516 2
    CompSubwindowsPtr	csw = GetCompSubwindows (pParent);
    CompClientWindowPtr	ccw;
d519 7
a525 7
	return Success;
    for (ccw = csw->clients; ccw; ccw = ccw->next)
    {
	int ret = compUnredirectWindow (clients[CLIENT_ID(ccw->id)],
					pWin, ccw->update);
	if (ret != Success)
	    return ret;
d531 1
a531 1
compNewPixmap (WindowPtr pWin, int x, int y, int w, int h)
d533 3
a535 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    WindowPtr	    pParent = pWin->parent;
    PixmapPtr	    pPixmap;
d538 1
a538 1
					CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
d541 2
a542 2
	return 0;
    
d546 48
a593 53
    if (pParent->drawable.depth == pWin->drawable.depth)
    {
	GCPtr	pGC = GetScratchGC (pWin->drawable.depth, pScreen);
	
	if (pGC)
	{
	    ChangeGCVal val;
	    val.val = IncludeInferiors;
	    ChangeGC (NullClient, pGC, GCSubwindowMode, &val);
	    ValidateGC(&pPixmap->drawable, pGC);
	    (*pGC->ops->CopyArea) (&pParent->drawable,
				   &pPixmap->drawable,
				   pGC,
				   x - pParent->drawable.x,
				   y - pParent->drawable.y,
				   w, h, 0, 0);
	    FreeScratchGC (pGC);
	}
    }
    else
    {
	PictFormatPtr	pSrcFormat = compWindowFormat (pParent);
	PictFormatPtr	pDstFormat = compWindowFormat (pWin);
	XID		inferiors = IncludeInferiors;
	int		error;

	PicturePtr	pSrcPicture = CreatePicture (None,
						     &pParent->drawable,
						     pSrcFormat,
						     CPSubwindowMode,
						     &inferiors,
						     serverClient, &error);
						    
	PicturePtr	pDstPicture = CreatePicture (None,
						     &pPixmap->drawable,
						     pDstFormat,
						     0, 0,
						     serverClient, &error);

	if (pSrcPicture && pDstPicture)
	{
	    CompositePicture (PictOpSrc,
			      pSrcPicture,
			      NULL,
			      pDstPicture,
			      x - pParent->drawable.x,
			      y - pParent->drawable.y,
			      0, 0, 0, 0, w, h);
	}
	if (pSrcPicture)
	    FreePicture (pSrcPicture, 0);
	if (pDstPicture)
	    FreePicture (pDstPicture, 0);
d599 1
a599 1
compAllocPixmap (WindowPtr pWin)
d601 7
a607 7
    int		    bw = (int) pWin->borderWidth;
    int		    x = pWin->drawable.x - bw;
    int		    y = pWin->drawable.y - bw;
    int		    w = pWin->drawable.width + (bw << 1);
    int		    h = pWin->drawable.height + (bw << 1);
    PixmapPtr	    pPixmap = compNewPixmap (pWin, x, y, w, h);
    CompWindowPtr   cw = GetCompWindow (pWin);
d610 1
a610 1
	return FALSE;
d612 1
a612 1
	pWin->redirectDraw = RedirectDrawAutomatic;
d614 1
a614 1
	pWin->redirectDraw = RedirectDrawManual;
d616 1
a616 1
    compSetPixmap (pWin, pPixmap);
d620 3
a622 4
    if (cw->update == CompositeRedirectAutomatic)
    {
	DamageRegister (&pWin->drawable, cw->damage);
	cw->damageRegistered = TRUE;
d635 1
a635 1
compSetParentPixmap (WindowPtr pWin)
d637 8
a644 9
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    PixmapPtr	    pParentPixmap;
    CompWindowPtr   cw = GetCompWindow (pWin);

    if (cw->damageRegistered)
    {
	DamageUnregister (&pWin->drawable, cw->damage);
	cw->damageRegistered = FALSE;
	DamageEmpty (cw->damage);
d655 1
a655 1
    compSetPixmap (pWin, pParentPixmap);
d664 2
a665 2
compReallocPixmap (WindowPtr pWin, int draw_x, int draw_y,
		   unsigned int w, unsigned int h, int bw)
d667 6
a672 6
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    PixmapPtr	    pOld = (*pScreen->GetWindowPixmap) (pWin);
    PixmapPtr	    pNew;
    CompWindowPtr   cw = GetCompWindow (pWin);
    int		    pix_x, pix_y;
    int		    pix_w, pix_h;
d674 1
a674 1
    assert (cw && pWin->redirectDraw != RedirectDrawNone);
d681 10
a690 12
    if (pix_w != pOld->drawable.width || pix_h != pOld->drawable.height)
    {
	pNew = compNewPixmap (pWin, pix_x, pix_y, pix_w, pix_h);
	if (!pNew)
	    return FALSE;
	cw->pOldPixmap = pOld;
	compSetPixmap (pWin, pNew);
    }
    else
    {
	pNew = pOld;
	cw->pOldPixmap = 0;
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
d51 24
d82 4
a85 1
    cs->damaged = TRUE;
d87 9
d107 29
a143 1
    Bool		wasMapped = pWin->mapped;
d145 2
d196 2
a197 6
	if (wasMapped)
	{
	    DisableMapUnmapEvents (pWin);
	    UnmapWindow (pWin, FALSE);
	    EnableMapUnmapEvents (pWin);
	}
a199 2
	cw->borderClipX = 0;
	cw->borderClipY = 0;
d215 3
a217 10
	/* If the window was CompositeRedirectAutomatic, then
	 * unmap the window so that the parent clip list will
	 * be correctly recomputed.
	 */
	if (pWin->mapped) 
	{
	    DisableMapUnmapEvents (pWin);
	    UnmapWindow (pWin, FALSE);
	    EnableMapUnmapEvents (pWin);
	}
d225 4
d235 3
a237 9
    if (wasMapped && !pWin->mapped)
    {
	Bool	overrideRedirect = pWin->overrideRedirect;
	pWin->overrideRedirect = TRUE;
	DisableMapUnmapEvents (pWin);
	MapWindow (pWin, pClient);
	EnableMapUnmapEvents (pWin);
	pWin->overrideRedirect = overrideRedirect;
    }
d242 28
d277 1
d280 3
a282 1
    Bool		wasMapped = pWin->mapped;
d299 5
a303 5
	if (wasMapped)
	{
	    DisableMapUnmapEvents (pWin);
	    UnmapWindow (pWin, FALSE);
	    EnableMapUnmapEvents (pWin);
a304 3
    
	if (pWin->redirectDraw != RedirectDrawNone)
	    compFreePixmap (pWin);
d317 2
d324 7
a330 8
    if (wasMapped && !pWin->mapped)
    {
	Bool	overrideRedirect = pWin->overrideRedirect;
	pWin->overrideRedirect = TRUE;
	DisableMapUnmapEvents (pWin);
	MapWindow (pWin, clients[CLIENT_ID(id)]);
	EnableMapUnmapEvents (pWin);
	pWin->overrideRedirect = overrideRedirect;
d433 1
d466 1
d572 1
a572 1
    
a576 4
	/*
	 * Copy bits from the parent into the new pixmap so that it will
	 * have "reasonable" contents in case for background None areas.
	 */
d581 1
a581 1
	    
a582 1
	    ChangeGC (serverClient, pGC, GCSubwindowMode, &val);
d657 7
d668 1
a668 1
compFreePixmap (WindowPtr pWin)
d671 1
a671 1
    PixmapPtr	    pRedirectPixmap, pParentPixmap;
a686 1
    pRedirectPixmap = (*pScreen->GetWindowPixmap) (pWin);
a689 1
    (*pScreen->DestroyPixmap) (pRedirectPixmap);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d241 1
a241 1
	DamageRegionAppend(&pWin->drawable, &pWin->borderSize);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d102 1
a102 1
    ccw = xalloc (sizeof (CompClientWindowRec));
d112 1
a112 1
	cw = xalloc (sizeof (CompWindowRec));
d115 1
a115 1
	    xfree (ccw);
d126 2
a127 2
	    xfree (ccw);
	    xfree (cw);
d137 1
a137 1
	REGION_NULL (pScreen, &cw->borderClip);
d211 1
a211 1
	    xfree (ccw);
d230 1
a230 1
	REGION_UNINIT (pScreen, &cw->borderClip);
d233 1
a233 1
	xfree (cw);
d299 1
a299 1
    ccw = xalloc (sizeof (CompClientWindowRec));
d309 1
a309 1
	csw = xalloc (sizeof (CompSubwindowsRec));
d312 1
a312 1
	    xfree (ccw);
d331 1
a331 1
		xfree (csw);
d334 1
a334 1
	    xfree (ccw);
d395 1
a395 1
	    xfree (ccw);
d406 1
a406 1
	xfree (csw);
d501 2
a502 1
	    XID val = IncludeInferiors;
d505 1
a505 1
	    dixChangeGC (serverClient, pGC, GCSubwindowMode, &val, NULL);
d602 1
a602 1
    REGION_COPY (pScreen, &pWin->borderClip, &cw->borderClip);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems
d4 10
a13 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Sun Microsystems not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Sun Microsystems makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d15 7
a21 7
 * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d138 2
d146 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d151 10
d237 1
a237 1
	DamageDamageRegion (&pWin->drawable, &pWin->borderSize);
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d49 1
a49 1
void
d85 3
d143 1
a143 1
	pWin->devPrivates[CompWindowPrivateIndex].ptr = cw;
d210 1
a210 1
	if (pWin->redirectDraw)
d218 1
a218 1
	pWin->devPrivates[CompWindowPrivateIndex].ptr = 0;
d222 1
a222 1
	     !cw->damageRegistered && pWin->redirectDraw)
d226 1
d303 1
a303 1
	pWin->devPrivates[CompSubwindowsPrivateIndex].ptr = csw;
d318 1
a318 1
		pWin->devPrivates[CompSubwindowsPrivateIndex].ptr = 0;
d391 1
a391 1
	pWin->devPrivates[CompSubwindowsPrivateIndex].ptr = 0;
a466 1
    GCPtr	    pGC;
d468 2
a469 1
    pPixmap = (*pScreen->CreatePixmap) (pScreen, w, h, pWin->drawable.depth);
d477 1
a477 7
    pGC = GetScratchGC (pWin->drawable.depth, pScreen);
    
    /*
     * Copy bits from the parent into the new pixmap so that it will
     * have "reasonable" contents in case for background None areas.
     */
    if (pGC)
d479 1
a479 1
	XID val = IncludeInferiors;
d481 53
a533 9
	ValidateGC(&pPixmap->drawable, pGC);
	dixChangeGC (serverClient, pGC, GCSubwindowMode, &val, NULL);
	(*pGC->ops->CopyArea) (&pParent->drawable,
			       &pPixmap->drawable,
			       pGC,
			       x - pParent->drawable.x,
			       y - pParent->drawable.y,
			       w, h, 0, 0);
	FreeScratchGC (pGC);
d551 5
a555 1
    pWin->redirectDraw = TRUE;
d590 1
a590 1
    pWin->redirectDraw = FALSE;
d611 1
a611 1
    assert (cw && pWin->redirectDraw);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d51 1
a51 1
static void
d209 1
a209 1
	if (pWin->redirectDraw != RedirectDrawNone)
d221 1
a221 1
	     !cw->damageRegistered && pWin->redirectDraw != RedirectDrawNone)
a224 1
	pWin->redirectDraw = RedirectDrawAutomatic;
d465 1
d475 7
a481 1
    if (pParent->drawable.depth == pWin->drawable.depth)
d483 1
a483 1
	GCPtr	pGC = GetScratchGC (pWin->drawable.depth, pScreen);
d485 9
a493 53
	/*
	 * Copy bits from the parent into the new pixmap so that it will
	 * have "reasonable" contents in case for background None areas.
	 */
	if (pGC)
	{
	    XID val = IncludeInferiors;
	    
	    ValidateGC(&pPixmap->drawable, pGC);
	    dixChangeGC (serverClient, pGC, GCSubwindowMode, &val, NULL);
	    (*pGC->ops->CopyArea) (&pParent->drawable,
				   &pPixmap->drawable,
				   pGC,
				   x - pParent->drawable.x,
				   y - pParent->drawable.y,
				   w, h, 0, 0);
	    FreeScratchGC (pGC);
	}
    }
    else
    {
	PictFormatPtr	pSrcFormat = compWindowFormat (pParent);
	PictFormatPtr	pDstFormat = compWindowFormat (pWin);
	XID		inferiors = IncludeInferiors;
	int		error;

	PicturePtr	pSrcPicture = CreatePicture (None,
						     &pParent->drawable,
						     pSrcFormat,
						     CPSubwindowMode,
						     &inferiors,
						     serverClient, &error);
						    
	PicturePtr	pDstPicture = CreatePicture (None,
						     &pPixmap->drawable,
						     pDstFormat,
						     0, 0,
						     serverClient, &error);

	if (pSrcPicture && pDstPicture)
	{
	    CompositePicture (PictOpSrc,
			      pSrcPicture,
			      NULL,
			      pDstPicture,
			      x - pParent->drawable.x,
			      y - pParent->drawable.y,
			      0, 0, 0, 0, w, h);
	}
	if (pSrcPicture)
	    FreePicture (pSrcPicture, 0);
	if (pDstPicture)
	    FreePicture (pDstPicture, 0);
d511 1
a511 5
    if (cw->update == CompositeRedirectAutomatic)
	pWin->redirectDraw = RedirectDrawAutomatic;
    else
	pWin->redirectDraw = RedirectDrawManual;

d546 1
a546 1
    pWin->redirectDraw = RedirectDrawNone;
d567 1
a567 1
    assert (cw && pWin->redirectDraw != RedirectDrawNone);
@

