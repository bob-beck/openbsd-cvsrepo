head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v1_4_0_90:1.1.1.4
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.06.09;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.13.21.17.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "compint.h"
#include "xace.h"
#include "protocol-versions.h"
#include "extinit.h"

static CARD8 CompositeReqCode;
static DevPrivateKeyRec CompositeClientPrivateKeyRec;

#define CompositeClientPrivateKey (&CompositeClientPrivateKeyRec)
RESTYPE CompositeClientWindowType;
RESTYPE CompositeClientSubwindowsType;
RESTYPE CompositeClientOverlayType;

typedef struct _CompositeClient {
    int major_version;
    int minor_version;
} CompositeClientRec, *CompositeClientPtr;

#define GetCompositeClient(pClient) ((CompositeClientPtr) \
    dixLookupPrivate(&(pClient)->devPrivates, CompositeClientPrivateKey))

static void
CompositeClientCallback(CallbackListPtr *list, void *closure, void *data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
    ClientPtr pClient = clientinfo->client;
    CompositeClientPtr pCompositeClient = GetCompositeClient(pClient);

    pCompositeClient->major_version = 0;
    pCompositeClient->minor_version = 0;
}

static int
FreeCompositeClientWindow(void *value, XID ccwid)
{
    WindowPtr pWin = value;

    compFreeClientWindow(pWin, ccwid);
    return Success;
}

static int
FreeCompositeClientSubwindows(void *value, XID ccwid)
{
    WindowPtr pWin = value;

    compFreeClientSubwindows(pWin, ccwid);
    return Success;
}

static int
FreeCompositeClientOverlay(void *value, XID ccwid)
{
    CompOverlayClientPtr pOc = (CompOverlayClientPtr) value;

    compFreeOverlayClient(pOc);
    return Success;
}

static int
ProcCompositeQueryVersion(ClientPtr client)
{
    CompositeClientPtr pCompositeClient = GetCompositeClient(client);
    xCompositeQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    REQUEST(xCompositeQueryVersionReq);

    REQUEST_SIZE_MATCH(xCompositeQueryVersionReq);
    if (stuff->majorVersion < SERVER_COMPOSITE_MAJOR_VERSION) {
        rep.majorVersion = stuff->majorVersion;
        rep.minorVersion = stuff->minorVersion;
    }
    else {
        rep.majorVersion = SERVER_COMPOSITE_MAJOR_VERSION;
        rep.minorVersion = SERVER_COMPOSITE_MINOR_VERSION;
    }
    pCompositeClient->major_version = rep.majorVersion;
    pCompositeClient->minor_version = rep.minorVersion;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.majorVersion);
        swapl(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xCompositeQueryVersionReply), &rep);
    return Success;
}

#define VERIFY_WINDOW(pWindow, wid, client, mode)			\
    do {								\
	int err;							\
	err = dixLookupResourceByType((void **) &pWindow, wid,	\
				      RT_WINDOW, client, mode);		\
	if (err != Success) {						\
	    client->errorValue = wid;					\
	    return err;							\
	}								\
    } while (0)

static int
ProcCompositeRedirectWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xCompositeRedirectWindowReq);

    REQUEST_SIZE_MATCH(xCompositeRedirectWindowReq);
    VERIFY_WINDOW(pWin, stuff->window, client,
                  DixSetAttrAccess | DixManageAccess | DixBlendAccess);

    return compRedirectWindow(client, pWin, stuff->update);
}

static int
ProcCompositeRedirectSubwindows(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xCompositeRedirectSubwindowsReq);

    REQUEST_SIZE_MATCH(xCompositeRedirectSubwindowsReq);
    VERIFY_WINDOW(pWin, stuff->window, client,
                  DixSetAttrAccess | DixManageAccess | DixBlendAccess);

    return compRedirectSubwindows(client, pWin, stuff->update);
}

static int
ProcCompositeUnredirectWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xCompositeUnredirectWindowReq);

    REQUEST_SIZE_MATCH(xCompositeUnredirectWindowReq);
    VERIFY_WINDOW(pWin, stuff->window, client,
                  DixSetAttrAccess | DixManageAccess | DixBlendAccess);

    return compUnredirectWindow(client, pWin, stuff->update);
}

static int
ProcCompositeUnredirectSubwindows(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xCompositeUnredirectSubwindowsReq);

    REQUEST_SIZE_MATCH(xCompositeUnredirectSubwindowsReq);
    VERIFY_WINDOW(pWin, stuff->window, client,
                  DixSetAttrAccess | DixManageAccess | DixBlendAccess);

    return compUnredirectSubwindows(client, pWin, stuff->update);
}

static int
ProcCompositeCreateRegionFromBorderClip(ClientPtr client)
{
    WindowPtr pWin;
    CompWindowPtr cw;
    RegionPtr pBorderClip, pRegion;

    REQUEST(xCompositeCreateRegionFromBorderClipReq);

    REQUEST_SIZE_MATCH(xCompositeCreateRegionFromBorderClipReq);
    VERIFY_WINDOW(pWin, stuff->window, client, DixGetAttrAccess);
    LEGAL_NEW_RESOURCE(stuff->region, client);

    cw = GetCompWindow(pWin);
    if (cw)
        pBorderClip = &cw->borderClip;
    else
        pBorderClip = &pWin->borderClip;
    pRegion = XFixesRegionCopy(pBorderClip);
    if (!pRegion)
        return BadAlloc;
    RegionTranslate(pRegion, -pWin->drawable.x, -pWin->drawable.y);

    if (!AddResource(stuff->region, RegionResType, (void *) pRegion))
        return BadAlloc;

    return Success;
}

static int
ProcCompositeNameWindowPixmap(ClientPtr client)
{
    WindowPtr pWin;
    CompWindowPtr cw;
    PixmapPtr pPixmap;
    ScreenPtr pScreen;
    int rc;

    REQUEST(xCompositeNameWindowPixmapReq);

    REQUEST_SIZE_MATCH(xCompositeNameWindowPixmapReq);
    VERIFY_WINDOW(pWin, stuff->window, client, DixGetAttrAccess);

    pScreen = pWin->drawable.pScreen;

    if (!pWin->viewable)
        return BadMatch;

    LEGAL_NEW_RESOURCE(stuff->pixmap, client);

    cw = GetCompWindow(pWin);
    if (!cw)
        return BadMatch;

    pPixmap = (*pScreen->GetWindowPixmap) (pWin);
    if (!pPixmap)
        return BadMatch;

    /* security creation/labeling check */
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pixmap, RT_PIXMAP,
                  pPixmap, RT_WINDOW, pWin, DixCreateAccess);
    if (rc != Success)
        return rc;

    ++pPixmap->refcnt;

    if (!AddResource(stuff->pixmap, RT_PIXMAP, (void *) pPixmap))
        return BadAlloc;

    if (pScreen->NameWindowPixmap) {
        rc = pScreen->NameWindowPixmap(pWin, pPixmap, stuff->pixmap);
        if (rc != Success) {
            FreeResource(stuff->pixmap, RT_NONE);
            return rc;
        }
    }

    return Success;
}

static int
ProcCompositeGetOverlayWindow(ClientPtr client)
{
    REQUEST(xCompositeGetOverlayWindowReq);
    xCompositeGetOverlayWindowReply rep;
    WindowPtr pWin;
    ScreenPtr pScreen;
    CompScreenPtr cs;
    CompOverlayClientPtr pOc;
    int rc;

    REQUEST_SIZE_MATCH(xCompositeGetOverlayWindowReq);
    VERIFY_WINDOW(pWin, stuff->window, client, DixGetAttrAccess);
    pScreen = pWin->drawable.pScreen;

    /*
     * Create an OverlayClient structure to mark this client's
     * interest in the overlay window
     */
    pOc = compCreateOverlayClient(pScreen, client);
    if (pOc == NULL)
        return BadAlloc;

    /*
     * Make sure the overlay window exists
     */
    cs = GetCompScreen(pScreen);
    if (cs->pOverlayWin == NULL)
        if (!compCreateOverlayWindow(pScreen)) {
            FreeResource(pOc->resource, RT_NONE);
            return BadAlloc;
        }

    rc = XaceHook(XACE_RESOURCE_ACCESS, client, cs->pOverlayWin->drawable.id,
                  RT_WINDOW, cs->pOverlayWin, RT_NONE, NULL, DixGetAttrAccess);
    if (rc != Success) {
        FreeResource(pOc->resource, RT_NONE);
        return rc;
    }

    rep = (xCompositeGetOverlayWindowReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .overlayWin = cs->pOverlayWin->drawable.id
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.overlayWin);
    }
    WriteToClient(client, sz_xCompositeGetOverlayWindowReply, &rep);

    return Success;
}

static int
ProcCompositeReleaseOverlayWindow(ClientPtr client)
{
    REQUEST(xCompositeReleaseOverlayWindowReq);
    WindowPtr pWin;
    CompOverlayClientPtr pOc;

    REQUEST_SIZE_MATCH(xCompositeReleaseOverlayWindowReq);
    VERIFY_WINDOW(pWin, stuff->window, client, DixGetAttrAccess);

    /*
     * Has client queried a reference to the overlay window
     * on this screen? If not, generate an error.
     */
    pOc = compFindOverlayClient(pWin->drawable.pScreen, client);
    if (pOc == NULL)
        return BadMatch;

    /* The delete function will free the client structure */
    FreeResource(pOc->resource, RT_NONE);

    return Success;
}

static int (*ProcCompositeVector[CompositeNumberRequests]) (ClientPtr) = {
ProcCompositeQueryVersion,
        ProcCompositeRedirectWindow,
        ProcCompositeRedirectSubwindows,
        ProcCompositeUnredirectWindow,
        ProcCompositeUnredirectSubwindows,
        ProcCompositeCreateRegionFromBorderClip,
        ProcCompositeNameWindowPixmap,
        ProcCompositeGetOverlayWindow, ProcCompositeReleaseOverlayWindow,};

static int
ProcCompositeDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < CompositeNumberRequests)
        return (*ProcCompositeVector[stuff->data]) (client);
    else
        return BadRequest;
}

static int
SProcCompositeQueryVersion(ClientPtr client)
{
    REQUEST(xCompositeQueryVersionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeQueryVersionReq);
    swapl(&stuff->majorVersion);
    swapl(&stuff->minorVersion);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeRedirectWindow(ClientPtr client)
{
    REQUEST(xCompositeRedirectWindowReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeRedirectWindowReq);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeRedirectSubwindows(ClientPtr client)
{
    REQUEST(xCompositeRedirectSubwindowsReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeRedirectSubwindowsReq);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeUnredirectWindow(ClientPtr client)
{
    REQUEST(xCompositeUnredirectWindowReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeUnredirectWindowReq);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeUnredirectSubwindows(ClientPtr client)
{
    REQUEST(xCompositeUnredirectSubwindowsReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeUnredirectSubwindowsReq);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeCreateRegionFromBorderClip(ClientPtr client)
{
    REQUEST(xCompositeCreateRegionFromBorderClipReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeCreateRegionFromBorderClipReq);
    swapl(&stuff->region);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeNameWindowPixmap(ClientPtr client)
{
    REQUEST(xCompositeNameWindowPixmapReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeNameWindowPixmapReq);
    swapl(&stuff->window);
    swapl(&stuff->pixmap);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeGetOverlayWindow(ClientPtr client)
{
    REQUEST(xCompositeGetOverlayWindowReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeGetOverlayWindowReq);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int
SProcCompositeReleaseOverlayWindow(ClientPtr client)
{
    REQUEST(xCompositeReleaseOverlayWindowReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xCompositeReleaseOverlayWindowReq);
    swapl(&stuff->window);
    return (*ProcCompositeVector[stuff->compositeReqType]) (client);
}

static int (*SProcCompositeVector[CompositeNumberRequests]) (ClientPtr) = {
SProcCompositeQueryVersion,
        SProcCompositeRedirectWindow,
        SProcCompositeRedirectSubwindows,
        SProcCompositeUnredirectWindow,
        SProcCompositeUnredirectSubwindows,
        SProcCompositeCreateRegionFromBorderClip,
        SProcCompositeNameWindowPixmap,
        SProcCompositeGetOverlayWindow, SProcCompositeReleaseOverlayWindow,};

static int
SProcCompositeDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < CompositeNumberRequests)
        return (*SProcCompositeVector[stuff->data]) (client);
    else
        return BadRequest;
}

/** @@see GetDefaultBytes */
static void
GetCompositeClientWindowBytes(void *value, XID id, ResourceSizePtr size)
{
    WindowPtr window = value;

    /* Currently only pixmap bytes are reported to clients. */
    size->resourceSize = 0;

    /* Calculate pixmap reference sizes. */
    size->pixmapRefSize = 0;
    if (window->redirectDraw != RedirectDrawNone)
    {
        SizeType pixmapSizeFunc = GetResourceTypeSizeFunc(RT_PIXMAP);
        ResourceSizeRec pixmapSize = { 0, 0 };
        ScreenPtr screen = window->drawable.pScreen;
        PixmapPtr pixmap = screen->GetWindowPixmap(window);
        pixmapSizeFunc(pixmap, pixmap->drawable.id, &pixmapSize);
        size->pixmapRefSize += pixmapSize.pixmapRefSize;
    }
}

void
CompositeExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int s;

    /* Assume initialization is going to fail */
    noCompositeExtension = TRUE;

    for (s = 0; s < screenInfo.numScreens; s++) {
        ScreenPtr pScreen = screenInfo.screens[s];
        VisualPtr vis;

        /* Composite on 8bpp pseudocolor root windows appears to fail, so
         * just disable it on anything pseudocolor for safety.
         */
        for (vis = pScreen->visuals; vis->vid != pScreen->rootVisual; vis++);
        if ((vis->class | DynamicClass) == PseudoColor)
            return;

        /* Ensure that Render is initialized, which is required for automatic
         * compositing.
         */
        if (GetPictureScreenIfSet(pScreen) == NULL)
            return;
    }

    CompositeClientWindowType = CreateNewResourceType
        (FreeCompositeClientWindow, "CompositeClientWindow");
    if (!CompositeClientWindowType)
        return;

    SetResourceTypeSizeFunc(CompositeClientWindowType,
                            GetCompositeClientWindowBytes);

    CompositeClientSubwindowsType = CreateNewResourceType
        (FreeCompositeClientSubwindows, "CompositeClientSubwindows");
    if (!CompositeClientSubwindowsType)
        return;

    CompositeClientOverlayType = CreateNewResourceType
        (FreeCompositeClientOverlay, "CompositeClientOverlay");
    if (!CompositeClientOverlayType)
        return;

    if (!dixRegisterPrivateKey(&CompositeClientPrivateKeyRec, PRIVATE_CLIENT,
                               sizeof(CompositeClientRec)))
        return;

    if (!AddCallback(&ClientStateCallback, CompositeClientCallback, 0))
        return;

    for (s = 0; s < screenInfo.numScreens; s++)
        if (!compScreenInit(screenInfo.screens[s]))
            return;

    extEntry = AddExtension(COMPOSITE_NAME, 0, 0,
                            ProcCompositeDispatch, SProcCompositeDispatch,
                            NULL, StandardMinorOpcode);
    if (!extEntry)
        return;
    CompositeReqCode = (CARD8) extEntry->base;

    /* Initialization succeeded */
    noCompositeExtension = FALSE;
}

#ifdef PANORAMIX
#include "panoramiXsrv.h"

int (*PanoramiXSaveCompositeVector[CompositeNumberRequests]) (ClientPtr);

static int
PanoramiXCompositeRedirectWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int rc = 0, j;

    REQUEST(xCompositeRedirectWindowReq);

    REQUEST_SIZE_MATCH(xCompositeRedirectWindowReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    FOR_NSCREENS_FORWARD(j) {
        stuff->window = win->info[j].id;
        rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
        if (rc != Success)
            break;
    }

    return rc;
}

static int
PanoramiXCompositeRedirectSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int rc = 0, j;

    REQUEST(xCompositeRedirectSubwindowsReq);

    REQUEST_SIZE_MATCH(xCompositeRedirectSubwindowsReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    FOR_NSCREENS_FORWARD(j) {
        stuff->window = win->info[j].id;
        rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
        if (rc != Success)
            break;
    }

    return rc;
}

static int
PanoramiXCompositeUnredirectWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int rc = 0, j;

    REQUEST(xCompositeUnredirectWindowReq);

    REQUEST_SIZE_MATCH(xCompositeUnredirectWindowReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    FOR_NSCREENS_FORWARD(j) {
        stuff->window = win->info[j].id;
        rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
        if (rc != Success)
            break;
    }

    return rc;
}

static int
PanoramiXCompositeUnredirectSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int rc = 0, j;

    REQUEST(xCompositeUnredirectSubwindowsReq);

    REQUEST_SIZE_MATCH(xCompositeUnredirectSubwindowsReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    FOR_NSCREENS_FORWARD(j) {
        stuff->window = win->info[j].id;
        rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
        if (rc != Success)
            break;
    }

    return rc;
}

static int
PanoramiXCompositeNameWindowPixmap(ClientPtr client)
{
    WindowPtr pWin;
    CompWindowPtr cw;
    PixmapPtr pPixmap;
    int rc;
    PanoramiXRes *win, *newPix;
    int i;

    REQUEST(xCompositeNameWindowPixmapReq);

    REQUEST_SIZE_MATCH(xCompositeNameWindowPixmapReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    LEGAL_NEW_RESOURCE(stuff->pixmap, client);

    if (!(newPix = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = FALSE;
    panoramix_setup_ids(newPix, client, stuff->pixmap);

    FOR_NSCREENS(i) {
        rc = dixLookupResourceByType((void **) &pWin, win->info[i].id,
                                     RT_WINDOW, client, DixGetAttrAccess);
        if (rc != Success) {
            client->errorValue = stuff->window;
            free(newPix);
            return rc;
        }

        if (!pWin->viewable) {
            free(newPix);
            return BadMatch;
        }

        cw = GetCompWindow(pWin);
        if (!cw) {
            free(newPix);
            return BadMatch;
        }

        pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);
        if (!pPixmap) {
            free(newPix);
            return BadMatch;
        }

        if (!AddResource(newPix->info[i].id, RT_PIXMAP, (void *) pPixmap))
            return BadAlloc;

        ++pPixmap->refcnt;
    }

    if (!AddResource(stuff->pixmap, XRT_PIXMAP, (void *) newPix))
        return BadAlloc;

    return Success;
}

static int
PanoramiXCompositeGetOverlayWindow(ClientPtr client)
{
    REQUEST(xCompositeGetOverlayWindowReq);
    xCompositeGetOverlayWindowReply rep;
    WindowPtr pWin;
    ScreenPtr pScreen;
    CompScreenPtr cs;
    CompOverlayClientPtr pOc;
    int rc;
    PanoramiXRes *win, *overlayWin = NULL;
    int i;

    REQUEST_SIZE_MATCH(xCompositeGetOverlayWindowReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    cs = GetCompScreen(screenInfo.screens[0]);
    if (!cs->pOverlayWin) {
        if (!(overlayWin = malloc(sizeof(PanoramiXRes))))
            return BadAlloc;

        overlayWin->type = XRT_WINDOW;
        overlayWin->u.win.root = FALSE;
    }

    FOR_NSCREENS_BACKWARD(i) {
        rc = dixLookupResourceByType((void **) &pWin, win->info[i].id,
                                     RT_WINDOW, client, DixGetAttrAccess);
        if (rc != Success) {
            client->errorValue = stuff->window;
            free(overlayWin);
            return rc;
        }
        pScreen = pWin->drawable.pScreen;

        /*
         * Create an OverlayClient structure to mark this client's
         * interest in the overlay window
         */
        pOc = compCreateOverlayClient(pScreen, client);
        if (pOc == NULL) {
            free(overlayWin);
            return BadAlloc;
        }

        /*
         * Make sure the overlay window exists
         */
        cs = GetCompScreen(pScreen);
        if (cs->pOverlayWin == NULL)
            if (!compCreateOverlayWindow(pScreen)) {
                FreeResource(pOc->resource, RT_NONE);
                free(overlayWin);
                return BadAlloc;
            }

        rc = XaceHook(XACE_RESOURCE_ACCESS, client,
                      cs->pOverlayWin->drawable.id,
                      RT_WINDOW, cs->pOverlayWin, RT_NONE, NULL,
                      DixGetAttrAccess);
        if (rc != Success) {
            FreeResource(pOc->resource, RT_NONE);
            free(overlayWin);
            return rc;
        }
    }

    if (overlayWin) {
        FOR_NSCREENS(i) {
            cs = GetCompScreen(screenInfo.screens[i]);
            overlayWin->info[i].id = cs->pOverlayWin->drawable.id;
        }

        AddResource(overlayWin->info[0].id, XRT_WINDOW, overlayWin);
    }

    cs = GetCompScreen(screenInfo.screens[0]);

    rep = (xCompositeGetOverlayWindowReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .overlayWin = cs->pOverlayWin->drawable.id
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.overlayWin);
    }
    WriteToClient(client, sz_xCompositeGetOverlayWindowReply, &rep);

    return Success;
}

static int
PanoramiXCompositeReleaseOverlayWindow(ClientPtr client)
{
    REQUEST(xCompositeReleaseOverlayWindowReq);
    WindowPtr pWin;
    CompOverlayClientPtr pOc;
    PanoramiXRes *win;
    int i, rc;

    REQUEST_SIZE_MATCH(xCompositeReleaseOverlayWindowReq);

    if ((rc = dixLookupResourceByType((void **) &win, stuff->window, XRT_WINDOW,
                                      client, DixUnknownAccess))) {
        client->errorValue = stuff->window;
        return rc;
    }

    FOR_NSCREENS_BACKWARD(i) {
        if ((rc = dixLookupResourceByType((void **) &pWin, win->info[i].id,
                                          XRT_WINDOW, client,
                                          DixUnknownAccess))) {
            client->errorValue = stuff->window;
            return rc;
        }

        /*
         * Has client queried a reference to the overlay window
         * on this screen? If not, generate an error.
         */
        pOc = compFindOverlayClient(pWin->drawable.pScreen, client);
        if (pOc == NULL)
            return BadMatch;

        /* The delete function will free the client structure */
        FreeResource(pOc->resource, RT_NONE);
    }

    return Success;
}

void
PanoramiXCompositeInit(void)
{
    int i;

    for (i = 0; i < CompositeNumberRequests; i++)
        PanoramiXSaveCompositeVector[i] = ProcCompositeVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcCompositeVector[X_CompositeRedirectWindow] =
        PanoramiXCompositeRedirectWindow;
    ProcCompositeVector[X_CompositeRedirectSubwindows] =
        PanoramiXCompositeRedirectSubwindows;
    ProcCompositeVector[X_CompositeUnredirectWindow] =
        PanoramiXCompositeUnredirectWindow;
    ProcCompositeVector[X_CompositeUnredirectSubwindows] =
        PanoramiXCompositeUnredirectSubwindows;
    ProcCompositeVector[X_CompositeNameWindowPixmap] =
        PanoramiXCompositeNameWindowPixmap;
    ProcCompositeVector[X_CompositeGetOverlayWindow] =
        PanoramiXCompositeGetOverlayWindow;
    ProcCompositeVector[X_CompositeReleaseOverlayWindow] =
        PanoramiXCompositeReleaseOverlayWindow;
}

void
PanoramiXCompositeReset(void)
{
    int i;

    for (i = 0; i < CompositeNumberRequests; i++)
        ProcCompositeVector[i] = PanoramiXSaveCompositeVector[i];
}

#endif
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d302 1
a302 1
    /* 
d354 1
a354 1
    /* 
a595 3

    miRegisterRedirectBorderClipProc(compSetRedirectBorderClip,
                                     compGetRedirectBorderClip);
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d70 1
a70 1
CompositeClientCallback(CallbackListPtr *list, pointer closure, pointer data)
d81 1
a81 1
FreeCompositeClientWindow(pointer value, XID ccwid)
d90 1
a90 1
FreeCompositeClientSubwindows(pointer value, XID ccwid)
d99 1
a99 1
FreeCompositeClientOverlay(pointer value, XID ccwid)
d143 1
a143 1
	err = dixLookupResourceByType((pointer *) &pWindow, wid,	\
d230 1
a230 1
    if (!AddResource(stuff->region, RegionResType, (pointer) pRegion))
d242 1
d250 2
d261 1
a261 1
    pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);
d273 1
a273 1
    if (!AddResource(stuff->pixmap, RT_PIXMAP, (pointer) pPixmap))
d276 8
a348 1
    ScreenPtr pScreen;
a352 1
    pScreen = pWin->drawable.pScreen;
d514 1
a514 1
GetCompositeClientWindowBytes(pointer value, XID id, ResourceSizePtr size)
d768 1
a768 1
        if (!AddResource(newPix->info[i].id, RT_PIXMAP, (pointer) pPixmap))
d774 1
a774 1
    if (!AddResource(stuff->pixmap, XRT_PIXMAP, (pointer) newPix))
d811 1
a811 1
        rc = dixLookupResourceByType((pointer *) &pWin, win->info[i].id,
a884 1
    ScreenPtr pScreen;
a903 1
        pScreen = pWin->drawable.pScreen;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d806 1
d816 2
a817 1
        if (pOc == NULL)
d819 1
d828 1
d838 1
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d51 1
d111 5
a115 1
    xCompositeQueryVersionReply rep;
a119 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d136 1
a136 1
    WriteToClient(client, sizeof(xCompositeQueryVersionReply), (char *) &rep);
d316 6
a321 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.overlayWin = cs->pOverlayWin->drawable.id;
d328 1
a328 2
    (void) WriteToClient(client, sz_xCompositeGetOverlayWindowReply,
                         (char *) &rep);
d503 22
d557 3
d849 6
a854 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.overlayWin = cs->pOverlayWin->drawable.id;
d861 1
a861 2
    (void) WriteToClient(client, sz_xCompositeGetOverlayWindowReply,
                         (char *) &rep);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d52 1
a52 1
static CARD8	CompositeReqCode;
d54 1
d56 3
a58 3
RESTYPE		CompositeClientWindowType;
RESTYPE		CompositeClientSubwindowsType;
RESTYPE		CompositeClientOverlayType;
d61 2
a62 2
    int	    major_version;
    int	    minor_version;
d69 5
a73 7
CompositeClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    CompositeClientPtr	pCompositeClient = GetCompositeClient (pClient);
d80 1
a80 1
FreeCompositeClientWindow (pointer value, XID ccwid)
d82 1
a82 1
    WindowPtr	pWin = value;
d84 1
a84 1
    compFreeClientWindow (pWin, ccwid);
d89 1
a89 1
FreeCompositeClientSubwindows (pointer value, XID ccwid)
d91 1
a91 1
    WindowPtr	pWin = value;
d93 1
a93 1
    compFreeClientSubwindows (pWin, ccwid);
d98 1
a98 1
FreeCompositeClientOverlay (pointer value, XID ccwid)
d102 1
a102 1
    compFreeOverlayClient (pOc);
d107 1
a107 1
ProcCompositeQueryVersion (ClientPtr client)
d109 1
a109 1
    CompositeClientPtr pCompositeClient = GetCompositeClient (client);
d111 1
a111 1
    register int n;
d119 5
a123 4
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else {
	rep.majorVersion = SERVER_COMPOSITE_MAJOR_VERSION;
d129 4
a132 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
d134 1
a134 1
    WriteToClient(client, sizeof(xCompositeQueryVersionReply), (char *)&rep);
d150 1
a150 1
ProcCompositeRedirectWindow (ClientPtr client)
d152 2
a153 1
    WindowPtr	pWin;
d158 1
a158 1
		  DixSetAttrAccess|DixManageAccess|DixBlendAccess);
d160 1
a160 1
    return compRedirectWindow (client, pWin, stuff->update);
d164 1
a164 1
ProcCompositeRedirectSubwindows (ClientPtr client)
d166 2
a167 1
    WindowPtr	pWin;
d172 1
a172 1
		  DixSetAttrAccess|DixManageAccess|DixBlendAccess);
d174 1
a174 1
    return compRedirectSubwindows (client, pWin, stuff->update);
d178 1
a178 1
ProcCompositeUnredirectWindow (ClientPtr client)
d180 2
a181 1
    WindowPtr	pWin;
d186 1
a186 1
		  DixSetAttrAccess|DixManageAccess|DixBlendAccess);
d188 1
a188 1
    return compUnredirectWindow (client, pWin, stuff->update);
d192 1
a192 1
ProcCompositeUnredirectSubwindows (ClientPtr client)
d194 2
a195 1
    WindowPtr	pWin;
d200 1
a200 1
		  DixSetAttrAccess|DixManageAccess|DixBlendAccess);
d202 1
a202 1
    return compUnredirectSubwindows (client, pWin, stuff->update);
d206 1
a206 1
ProcCompositeCreateRegionFromBorderClip (ClientPtr client)
d208 4
a211 3
    WindowPtr	    pWin;
    CompWindowPtr   cw;
    RegionPtr	    pBorderClip, pRegion;
d216 3
a218 3
    LEGAL_NEW_RESOURCE (stuff->region, client);
    
    cw = GetCompWindow (pWin);
d220 1
a220 1
	pBorderClip = &cw->borderClip;
d222 2
a223 2
	pBorderClip = &pWin->borderClip;
    pRegion = XFixesRegionCopy (pBorderClip);
d225 1
a225 1
	return BadAlloc;
d227 3
a229 3
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
d235 1
a235 1
ProcCompositeNameWindowPixmap (ClientPtr client)
d237 3
a239 3
    WindowPtr	    pWin;
    CompWindowPtr   cw;
    PixmapPtr	    pPixmap;
d241 1
d248 3
a250 1
	return BadMatch;
d252 1
a252 3
    LEGAL_NEW_RESOURCE (stuff->pixmap, client);
    
    cw = GetCompWindow (pWin);
d254 1
a254 1
	return BadMatch;
d258 1
a258 1
	return BadMatch;
d262 1
a262 1
		  pPixmap, RT_WINDOW, pWin, DixCreateAccess);
d264 1
a264 1
	return rc;
d268 2
a269 2
    if (!AddResource (stuff->pixmap, RT_PIXMAP, (pointer) pPixmap))
	return BadAlloc;
a273 1

d275 1
a275 1
ProcCompositeGetOverlayWindow (ClientPtr client)
d277 1
a277 1
    REQUEST(xCompositeGetOverlayWindowReq); 
d295 1
a295 1
	return BadAlloc;
d302 4
a305 5
	if (!compCreateOverlayWindow(pScreen))
	{
	    FreeResource (pOc->resource, RT_NONE);
	    return BadAlloc;
	}
d308 4
a311 5
		  RT_WINDOW, cs->pOverlayWin, RT_NONE, NULL, DixGetAttrAccess);
    if (rc != Success)
    {
	FreeResource (pOc->resource, RT_NONE);
	return rc;
d319 4
a322 6
    if (client->swapped)
    {
	int n;
	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.overlayWin, n);
d324 2
a325 1
    (void) WriteToClient(client, sz_xCompositeGetOverlayWindowReply, (char *)&rep);
d331 1
a331 1
ProcCompositeReleaseOverlayWindow (ClientPtr client)
d333 1
a333 1
    REQUEST(xCompositeReleaseOverlayWindowReq); 
d346 1
a346 1
    pOc = compFindOverlayClient (pWin->drawable.pScreen, client);
d348 1
a348 1
	return BadMatch;
d351 1
a351 1
    FreeResource (pOc->resource, RT_NONE);
d356 9
a364 11
static int (*ProcCompositeVector[CompositeNumberRequests])(ClientPtr) = {
    ProcCompositeQueryVersion,
    ProcCompositeRedirectWindow,
    ProcCompositeRedirectSubwindows,
    ProcCompositeUnredirectWindow,
    ProcCompositeUnredirectSubwindows,
    ProcCompositeCreateRegionFromBorderClip,
    ProcCompositeNameWindowPixmap,
    ProcCompositeGetOverlayWindow,
    ProcCompositeReleaseOverlayWindow,
};
d367 1
a367 1
ProcCompositeDispatch (ClientPtr client)
d370 1
a370 1
    
d372 1
a372 1
	return (*ProcCompositeVector[stuff->data]) (client);
d374 1
a374 1
	return BadRequest;
d378 1
a378 1
SProcCompositeQueryVersion (ClientPtr client)
a379 1
    int n;
d382 1
a382 1
    swaps(&stuff->length, n);
d384 2
a385 2
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
d390 1
a390 1
SProcCompositeRedirectWindow (ClientPtr client)
a391 1
    int n;
d394 1
a394 1
    swaps(&stuff->length, n);
d396 1
a396 1
    swapl (&stuff->window, n);
d401 1
a401 1
SProcCompositeRedirectSubwindows (ClientPtr client)
a402 1
    int n;
d405 1
a405 1
    swaps(&stuff->length, n);
d407 1
a407 1
    swapl (&stuff->window, n);
d412 1
a412 1
SProcCompositeUnredirectWindow (ClientPtr client)
a413 1
    int n;
d416 1
a416 1
    swaps(&stuff->length, n);
d418 1
a418 1
    swapl (&stuff->window, n);
d423 1
a423 1
SProcCompositeUnredirectSubwindows (ClientPtr client)
a424 1
    int n;
d427 1
a427 1
    swaps(&stuff->length, n);
d429 1
a429 1
    swapl (&stuff->window, n);
d434 1
a434 1
SProcCompositeCreateRegionFromBorderClip (ClientPtr client)
a435 1
    int n;
d438 1
a438 1
    swaps(&stuff->length, n);
d440 2
a441 2
    swapl (&stuff->region, n);
    swapl (&stuff->window, n);
d446 1
a446 1
SProcCompositeNameWindowPixmap (ClientPtr client)
a447 1
    int n;
d450 1
a450 1
    swaps(&stuff->length, n);
d452 2
a453 2
    swapl (&stuff->window, n);
    swapl (&stuff->pixmap, n);
d458 1
a458 1
SProcCompositeGetOverlayWindow (ClientPtr client)
a459 1
    int n;
d462 1
a462 1
    swaps (&stuff->length, n);
d464 1
a464 1
    swapl(&stuff->window, n);
d469 1
a469 1
SProcCompositeReleaseOverlayWindow (ClientPtr client)
a470 1
    int n;
d473 1
a473 1
    swaps (&stuff->length, n);
d475 1
a475 1
    swapl(&stuff->window, n);
d479 9
a487 11
static int (*SProcCompositeVector[CompositeNumberRequests])(ClientPtr) = {
    SProcCompositeQueryVersion,
    SProcCompositeRedirectWindow,
    SProcCompositeRedirectSubwindows,
    SProcCompositeUnredirectWindow,
    SProcCompositeUnredirectSubwindows,
    SProcCompositeCreateRegionFromBorderClip,
    SProcCompositeNameWindowPixmap,
    SProcCompositeGetOverlayWindow,
    SProcCompositeReleaseOverlayWindow,
};
d490 1
a490 1
SProcCompositeDispatch (ClientPtr client)
d493 1
a493 1
    
d495 1
a495 1
	return (*SProcCompositeVector[stuff->data]) (client);
d497 1
a497 1
	return BadRequest;
d501 1
a501 1
CompositeExtensionInit (void)
d503 2
a504 2
    ExtensionEntry  *extEntry;
    int		    s;
d510 2
a511 2
	ScreenPtr pScreen = screenInfo.screens[s];
	VisualPtr vis;
d513 12
a524 13
	/* Composite on 8bpp pseudocolor root windows appears to fail, so
	 * just disable it on anything pseudocolor for safety.
	 */
	for (vis = pScreen->visuals; vis->vid != pScreen->rootVisual; vis++)
	    ;
	if ((vis->class | DynamicClass) == PseudoColor)
	    return;

	/* Ensure that Render is initialized, which is required for automatic
	 * compositing.
	 */
	if (GetPictureScreenIfSet(pScreen) == NULL)
	    return;
d528 1
a528 1
	(FreeCompositeClientWindow, "CompositeClientWindow");
d530 1
a530 1
	return;
d533 1
a533 1
	(FreeCompositeClientSubwindows, "CompositeClientSubwindows");
d535 1
a535 1
	return;
d538 1
a538 1
	(FreeCompositeClientOverlay, "CompositeClientOverlay");
d540 1
a540 1
	return;
d543 2
a544 2
			       sizeof(CompositeClientRec)))
	return;
d546 2
a547 2
    if (!AddCallback (&ClientStateCallback, CompositeClientCallback, 0))
	return;
d550 2
a551 2
	if (!compScreenInit (screenInfo.screens[s]))
	    return;
d553 3
a555 3
    extEntry = AddExtension (COMPOSITE_NAME, 0, 0,
			     ProcCompositeDispatch, SProcCompositeDispatch,
			     NULL, StandardMinorOpcode);
d557 1
a557 1
	return;
d560 2
a561 2
    miRegisterRedirectBorderClipProc (compSetRedirectBorderClip,
				      compGetRedirectBorderClip);
d573 1
a573 1
PanoramiXCompositeRedirectWindow (ClientPtr client)
d577 1
d582 4
a585 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d589 4
a592 3
	stuff->window = win->info[j].id;
	rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
	if (rc != Success) break;
d599 1
a599 1
PanoramiXCompositeRedirectSubwindows (ClientPtr client)
d603 1
d608 4
a611 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d615 4
a618 3
	stuff->window = win->info[j].id;
	rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
	if (rc != Success) break;
d625 1
a625 1
PanoramiXCompositeUnredirectWindow (ClientPtr client)
d629 1
d634 4
a637 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d641 4
a644 3
	stuff->window = win->info[j].id;
	rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
	if (rc != Success) break;
d651 1
a651 1
PanoramiXCompositeUnredirectSubwindows (ClientPtr client)
d655 1
d660 4
a663 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d667 4
a670 3
	stuff->window = win->info[j].id;
	rc = (*PanoramiXSaveCompositeVector[stuff->compositeReqType]) (client);
	if (rc != Success) break;
d677 1
a677 1
PanoramiXCompositeNameWindowPixmap (ClientPtr client)
d679 3
a681 3
    WindowPtr	    pWin;
    CompWindowPtr   cw;
    PixmapPtr	    pPixmap;
d685 1
d690 4
a693 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d696 1
a696 1
    LEGAL_NEW_RESOURCE (stuff->pixmap, client);
d698 2
a699 2
    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d706 7
a712 8
	rc = dixLookupResourceByType ((void **) &pWin, win->info[i].id,
				      RT_WINDOW, client, DixGetAttrAccess);
	if (rc != Success)
	{
	    client->errorValue = stuff->window;
	    free (newPix);
	    return rc;
	}
d714 4
a717 5
	if (!pWin->viewable)
	{
	    free (newPix);
	    return BadMatch;
	}
d719 5
a723 6
	cw = GetCompWindow (pWin);
	if (!cw)
	{
	    free (newPix);
	    return BadMatch;
	}
d725 5
a729 6
	pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);
	if (!pPixmap)
	{
	    free (newPix);
	    return BadMatch;
	}
d731 2
a732 3
	if (!AddResource (newPix->info[i].id, RT_PIXMAP,
			  (pointer) pPixmap))
	    return BadAlloc;
d734 1
a734 1
	++pPixmap->refcnt;
d737 2
a738 2
    if (!AddResource (stuff->pixmap, XRT_PIXMAP, (pointer) newPix))
	return BadAlloc;
a742 1

d744 1
a744 1
PanoramiXCompositeGetOverlayWindow (ClientPtr client)
d758 4
a761 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d765 3
a767 4
    if (!cs->pOverlayWin)
    {
	if(!(overlayWin = malloc(sizeof(PanoramiXRes))))
	    return BadAlloc;
d769 2
a770 2
	overlayWin->type = XRT_WINDOW;
	overlayWin->u.win.root = FALSE;
d774 41
a814 45
	rc = dixLookupResourceByType((pointer *)&pWin, win->info[i].id,
				     RT_WINDOW, client, DixGetAttrAccess);
	if (rc != Success)
	{
	    client->errorValue = stuff->window;
	    return rc;
	}
	pScreen = pWin->drawable.pScreen;

	/*
	 * Create an OverlayClient structure to mark this client's
	 * interest in the overlay window
	 */
	pOc = compCreateOverlayClient(pScreen, client);
	if (pOc == NULL)
	    return BadAlloc;

	/*
	 * Make sure the overlay window exists
	 */
	cs = GetCompScreen(pScreen);
	if (cs->pOverlayWin == NULL)
	    if (!compCreateOverlayWindow(pScreen))
	    {
		FreeResource (pOc->resource, RT_NONE);
		return BadAlloc;
	    }

	rc = XaceHook(XACE_RESOURCE_ACCESS, client,
		      cs->pOverlayWin->drawable.id,
		      RT_WINDOW, cs->pOverlayWin, RT_NONE, NULL,
		      DixGetAttrAccess);
	if (rc != Success)
	{
	    FreeResource (pOc->resource, RT_NONE);
	    return rc;
	}
    }

    if (overlayWin)
    {
	FOR_NSCREENS(i) {
	    cs = GetCompScreen(screenInfo.screens[i]);
	    overlayWin->info[i].id = cs->pOverlayWin->drawable.id;
	}
d816 1
a816 1
	AddResource(overlayWin->info[0].id, XRT_WINDOW, overlayWin);
d826 4
a829 6
    if (client->swapped)
    {
	int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.overlayWin, n);
d831 2
a832 1
    (void) WriteToClient(client, sz_xCompositeGetOverlayWindowReply, (char *)&rep);
d838 1
a838 1
PanoramiXCompositeReleaseOverlayWindow (ClientPtr client)
d849 4
a852 4
    if ((rc = dixLookupResourceByType((void **)&win, stuff->window, XRT_WINDOW,
				      client, DixUnknownAccess))) {
	client->errorValue = stuff->window;
	return rc;
d856 15
a870 15
	if ((rc = dixLookupResourceByType((void **)&pWin, win->info[i].id,
					  XRT_WINDOW, client,
					  DixUnknownAccess))) {
	    client->errorValue = stuff->window;
	    return rc;
	}
	pScreen = pWin->drawable.pScreen;

	/*
	 * Has client queried a reference to the overlay window
	 * on this screen? If not, generate an error.
	 */
	pOc = compFindOverlayClient (pWin->drawable.pScreen, client);
	if (pOc == NULL)
	    return BadMatch;
d872 2
a873 2
	/* The delete function will free the client structure */
	FreeResource (pOc->resource, RT_NONE);
d880 1
a880 1
PanoramiXCompositeInit (void)
d885 1
a885 1
	PanoramiXSaveCompositeVector[i] = ProcCompositeVector[i];
d890 1
a890 1
	PanoramiXCompositeRedirectWindow;
d892 1
a892 1
	PanoramiXCompositeRedirectSubwindows;
d894 1
a894 1
	PanoramiXCompositeUnredirectWindow;
d896 1
a896 1
	PanoramiXCompositeUnredirectSubwindows;
d898 1
a898 1
	PanoramiXCompositeNameWindowPixmap;
d900 1
a900 1
	PanoramiXCompositeGetOverlayWindow;
d902 1
a902 1
	PanoramiXCompositeReleaseOverlayWindow;
d906 1
a906 1
PanoramiXCompositeReset (void)
d911 1
a911 1
	ProcCompositeVector[i] = PanoramiXSaveCompositeVector[i];
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
a537 7
#ifdef PANORAMIX
    /* Xinerama's rewriting of window drawing before Composite gets to it
     * breaks Composite.
     */
    if (!noPanoramiXExtension)
	return;
#endif
d578 352
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d53 2
a54 2
static int CompositeClientPrivateKeyIndex;
static DevPrivateKey CompositeClientPrivateKey = &CompositeClientPrivateKeyIndex;
d135 1
a135 1
    return(client->noClientException);
d143 1
a143 4
	if (err == BadValue) {						\
	    client->errorValue = wid;					\
	    return BadWindow;						\
	} else if (err != Success) {					\
d221 1
a221 1
    REGION_TRANSLATE (pScreen, pRegion, -pWin->drawable.x, -pWin->drawable.y);
d226 1
a226 1
    return(client->noClientException);
d265 1
a265 1
    return(client->noClientException);
d325 1
a325 1
    return client->noClientException;
d351 1
a351 1
    return client->noClientException;
d561 2
a562 2
    if (!dixRequestPrivate(CompositeClientPrivateKey,
			   sizeof(CompositeClientRec)))
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems
d4 10
a13 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Sun Microsystems not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Sun Microsystems makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d15 7
a21 7
 * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d50 1
a50 3

#define SERVER_COMPOSITE_MAJOR	0
#define SERVER_COMPOSITE_MINOR	4
d119 1
a119 1
    if (stuff->majorVersion < SERVER_COMPOSITE_MAJOR) {
d123 2
a124 2
	rep.majorVersion = SERVER_COMPOSITE_MAJOR;
        rep.minorVersion = SERVER_COMPOSITE_MINOR;
d138 14
a155 1
    int rc;
d159 3
a161 7
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW, client,
			   DixSetAttrAccess|DixManageAccess|DixBlendAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return (rc == BadValue) ? BadWindow : rc;
    }
a168 1
    int rc;
d172 3
a174 7
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW, client,
			   DixSetAttrAccess|DixManageAccess|DixBlendAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return (rc == BadValue) ? BadWindow : rc;
    }
d185 3
a187 6
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
    {
	client->errorValue = stuff->window;
	return BadWindow;
    }
d198 3
a200 6
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
    {
	client->errorValue = stuff->window;
	return BadWindow;
    }
a209 1
    int rc;
d213 1
a213 8
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW, client,
			   DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return (rc == BadValue) ? BadWindow : rc;
    }
    
d242 1
a242 7
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW, client,
			   DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return (rc == BadValue) ? BadWindow : rc;
    }
d284 1
a284 7
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW, client,
			   DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return (rc == BadValue) ? BadWindow : rc;
    }
d340 1
a340 6
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
    {
	client->errorValue = stuff->window;
	return BadWindow;
    }
d549 2
a550 1
    CompositeClientWindowType = CreateNewResourceType (FreeCompositeClientWindow);
d554 2
a555 1
    CompositeClientSubwindowsType = CreateNewResourceType (FreeCompositeClientSubwindows);
d559 2
a560 1
    CompositeClientOverlayType = CreateNewResourceType (FreeCompositeClientOverlay);
d567 1
d571 4
a581 3
    for (s = 0; s < screenInfo.numScreens; s++)
	if (!compScreenInit (screenInfo.screens[s]))
	    return;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d54 2
a55 1
static DevPrivateKey CompositeClientPrivateKey = &CompositeClientPrivateKey;
d58 1
a58 4
static RESTYPE	CompositeClientOverlayType;

static void deleteCompOverlayClient (CompOverlayClientPtr pOcToDel, 
				     ScreenPtr pScreen);
a80 5
static void
CompositeResetProc (ExtensionEntry *extEntry)
{
}
    
a102 12
    ScreenPtr pScreen = pOc->pScreen;
    CompScreenPtr cs;

    deleteCompOverlayClient(pOc, pScreen);

    /* Unmap overlay window when there are no more clients using it */
    cs = GetCompScreen(pScreen);
    if (cs->pOverlayClients == NULL) {
	if (cs->pOverlayWin != NULL) {
	    UnmapWindow(cs->pOverlayWin, FALSE);
	}
    }
d104 1
d147 1
a147 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW, client,
d165 1
a165 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW, client,
d217 1
a217 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW, client,
d253 1
a253 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW, client,
a288 131
/*
 * Routines for manipulating the per-screen overlay clients list.
 * This list indicates which clients have called GetOverlayWindow
 * for this screen.
 */

/* Return the screen's overlay client list element for the given client */
static CompOverlayClientPtr
findCompOverlayClient (ClientPtr pClient, ScreenPtr pScreen) 
{
    CompScreenPtr    cs = GetCompScreen(pScreen);
    CompOverlayClientPtr pOc;

    for (pOc = cs->pOverlayClients; pOc != NULL; pOc = pOc->pNext) {
	if (pOc->pClient == pClient) {
	    return pOc;
	}
    }

    return NULL;           
}

static int
createCompOverlayClient (ClientPtr pClient, ScreenPtr pScreen)
{
    CompScreenPtr    cs = GetCompScreen(pScreen);
    CompOverlayClientPtr pOc;

    pOc = (CompOverlayClientPtr) xalloc(sizeof(CompOverlayClientRec));
    if (pOc == NULL) {
	return BadAlloc;
    }
    pOc->pClient = pClient;
    pOc->pScreen = pScreen;
    pOc->resource = FakeClientID(pClient->index);
    pOc->pNext = cs->pOverlayClients;
    cs->pOverlayClients = pOc;

    /* 
     * Create a resource for this element so it can be deleted
     * when the client goes away.
     */
    if (!AddResource (pOc->resource, CompositeClientOverlayType, 
		      (pointer) pOc)) {
	xfree(pOc);
	return BadAlloc;
    }

    return Success;
}

/* 
 * Delete the given overlay client list element from its screen list.
 */
static void
deleteCompOverlayClient (CompOverlayClientPtr pOcToDel, ScreenPtr pScreen)
{
    CompScreenPtr    cs = GetCompScreen(pScreen);
    CompOverlayClientPtr pOc, pNext;
    CompOverlayClientPtr pOcLast = NULL;

    pOc = cs->pOverlayClients;
    while (pOc != NULL) {
	pNext = pOc->pNext;
	if (pOc == pOcToDel) {
	    xfree(pOc);
	    if (pOcLast == NULL) {
		cs->pOverlayClients = pNext;
	    } else {
		pOcLast->pNext = pNext;
	    }
	    break;
	}
	pOcLast = pOc;
	pOc = pNext;
    }
}

/* 
 * Delete all the hide-counts list elements for this screen.
 */
void
deleteCompOverlayClientsForScreen (ScreenPtr pScreen)
{
    CompScreenPtr    cs = GetCompScreen(pScreen);
    CompOverlayClientPtr pOc, pTmp;

    pOc = cs->pOverlayClients;
    while (pOc != NULL) {
	pTmp = pOc->pNext;
	FreeResource(pOc->resource, 0);
	pOc = pTmp;
    }
    cs->pOverlayClients = NULL;
}

/* 
** If necessary, create the overlay window. And map it 
** Note: I found it excessively difficult to destroy this window
** during compCloseScreen; DeleteWindow can't be called because
** the input devices are already shut down. So we are going to 
** just allocate an overlay window once per screen per X server
** invocation.
*/

static WindowPtr
createOverlayWindow (ScreenPtr pScreen)
{
    int wid = FakeClientID(0);
    WindowPtr pWin;
    XID overrideRedirect = TRUE;
    int result;

    pWin = CreateWindow (
	        wid, WindowTable[pScreen->myNum],
    	        0, 0, pScreen->width, pScreen->height, 0, 
	        InputOutput, CWOverrideRedirect, &overrideRedirect,
	        WindowTable[pScreen->myNum]->drawable.depth, 
	        serverClient, pScreen->rootVisual, &result);
    if (pWin == NULL) {
	return NULL;
    }

    if (!AddResource(wid, RT_WINDOW, (pointer)pWin)) {
	DeleteWindow(pWin, None);
	return NULL;
    }

    return pWin;
}

d301 1
a301 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW, client,
d310 11
d322 4
a325 3
    if (cs->pOverlayWin == NULL) {
	cs->pOverlayWin = createOverlayWindow(pScreen);
	if (cs->pOverlayWin == NULL) {
a327 1
    }
d332 2
a334 10

    MapWindow(cs->pOverlayWin, serverClient);

    /* Record that client is using this overlay window */
    pOc = findCompOverlayClient(client, pScreen);
    if (pOc == NULL) {
	int ret = createCompOverlayClient(client, pScreen);
	if (ret != Success) {
	    return ret;
	}
a360 1
    CompScreenPtr cs;
d375 2
a376 2
    pOc = findCompOverlayClient(client, pWin->drawable.pScreen);
    if (pOc == NULL) {
a377 1
    }
d380 1
a380 6
    FreeResource (pOc->resource, 0);

    cs = GetCompScreen(pScreen);
    if (cs->pOverlayClients == NULL) {
	UnmapWindow(cs->pOverlayWin, FALSE);
    }
d597 1
a597 1
			     CompositeResetProc, StandardMinorOpcode);
@


1.1
log
@Initial revision
@
text
@a1 3
 * $Id$
 *
 *
d48 4
d54 1
a54 1
int		CompositeClientPrivateIndex;
d57 1
a57 1
RESTYPE		CompositeClientOverlayType;
d67 2
a68 1
#define GetCompositeClient(pClient)    ((CompositeClientPtr) (pClient)->devPrivates[CompositeClientPrivateIndex].ptr)
d138 1
a138 1
    if (stuff->majorVersion < COMPOSITE_MAJOR) {
d142 2
a143 6
	rep.majorVersion = COMPOSITE_MAJOR;
	if (stuff->majorVersion == COMPOSITE_MAJOR && 
	    stuff->minorVersion < COMPOSITE_MINOR)
	    rep.minorVersion = stuff->minorVersion;
	else
	    rep.minorVersion = COMPOSITE_MINOR;
d161 1
d165 3
a167 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
d170 1
a170 1
	return BadWindow;
d179 1
d183 3
a185 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
d188 1
a188 1
	return BadWindow;
d231 1
d235 3
a237 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
d240 1
a240 1
	return BadWindow;
d267 1
d271 3
a273 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
d276 1
a276 1
	return BadWindow;
d278 4
a281 1
    
d292 6
d299 1
a299 1
    
d438 1
a438 1
int
d447 1
d450 3
a452 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
d455 1
a455 1
	return BadWindow;
d466 6
d500 1
a500 1
int
d538 1
a538 1
int (*ProcCompositeVector[CompositeNumberRequests])(ClientPtr) = {
d648 1
a648 1
int
d660 1
a660 1
int
d672 1
a672 1
int (*SProcCompositeVector[CompositeNumberRequests])(ClientPtr) = {
d701 29
d742 2
a743 3
    CompositeClientPrivateIndex = AllocateClientPrivateIndex ();
    if (!AllocateClientPrivate (CompositeClientPrivateIndex, 
				sizeof (CompositeClientRec)))
d760 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d272 1
a272 4

    if (!pWin->viewable)
	return BadMatch;

@


1.1.1.3
log
@xserver 1.4
@
text
@d2 3
a51 3
#define SERVER_COMPOSITE_MAJOR	0
#define SERVER_COMPOSITE_MINOR	4

d53 1
a53 1
static int	CompositeClientPrivateIndex;
d56 1
a56 1
static RESTYPE	CompositeClientOverlayType;
d136 1
a136 1
    if (stuff->majorVersion < SERVER_COMPOSITE_MAJOR) {
d140 6
a145 2
	rep.majorVersion = SERVER_COMPOSITE_MAJOR;
        rep.minorVersion = SERVER_COMPOSITE_MINOR;
d426 1
a426 1
static int
d480 1
a480 1
static int
d518 1
a518 1
static int (*ProcCompositeVector[CompositeNumberRequests])(ClientPtr) = {
d628 1
a628 1
static int
d640 1
a640 1
static int
d652 1
a652 1
static int (*SProcCompositeVector[CompositeNumberRequests])(ClientPtr) = {
a679 26

    for (s = 0; s < screenInfo.numScreens; s++) {
	ScreenPtr pScreen = screenInfo.screens[s];
	VisualPtr vis;

	/* Composite on 8bpp pseudocolor root windows appears to fail, so
	 * just disable it on anything pseudocolor for safety.
	 */
	for (vis = pScreen->visuals; vis->vid != pScreen->rootVisual; vis++)
	    ;
	if ((vis->class | DynamicClass) == PseudoColor)
	    return;

	/* Ensure that Render is initialized, which is required for automatic
	 * compositing.
	 */
	if (GetPictureScreenIfSet(pScreen) == NULL)
	    return;
    }
#ifdef PANORAMIX
    /* Xinerama's rewriting of window drawing before Composite gets to it
     * breaks Composite.
     */
    if (!noPanoramiXExtension)
	return;
#endif
@


1.1.1.4
log
@xserver 1.4.0.90
@
text
@a676 3
    /* Assume initialization is going to fail */
    noCompositeExtension = TRUE;

a733 3

    /* Initialization succeeded */
    noCompositeExtension = FALSE;
@


