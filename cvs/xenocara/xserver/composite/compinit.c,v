head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "compint.h"
#include "compositeext.h"

DevPrivateKeyRec CompScreenPrivateKeyRec;
DevPrivateKeyRec CompWindowPrivateKeyRec;
DevPrivateKeyRec CompSubwindowsPrivateKeyRec;

static Bool
compCloseScreen(ScreenPtr pScreen)
{
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret;

    free(cs->alternateVisuals);

    pScreen->CloseScreen = cs->CloseScreen;
    pScreen->InstallColormap = cs->InstallColormap;
    pScreen->ChangeWindowAttributes = cs->ChangeWindowAttributes;
    pScreen->ReparentWindow = cs->ReparentWindow;
    pScreen->ConfigNotify = cs->ConfigNotify;
    pScreen->MoveWindow = cs->MoveWindow;
    pScreen->ResizeWindow = cs->ResizeWindow;
    pScreen->ChangeBorderWidth = cs->ChangeBorderWidth;

    pScreen->ClipNotify = cs->ClipNotify;
    pScreen->UnrealizeWindow = cs->UnrealizeWindow;
    pScreen->RealizeWindow = cs->RealizeWindow;
    pScreen->DestroyWindow = cs->DestroyWindow;
    pScreen->CreateWindow = cs->CreateWindow;
    pScreen->CopyWindow = cs->CopyWindow;
    pScreen->PositionWindow = cs->PositionWindow;

    pScreen->GetImage = cs->GetImage;
    pScreen->GetSpans = cs->GetSpans;
    pScreen->SourceValidate = cs->SourceValidate;

    free(cs);
    dixSetPrivate(&pScreen->devPrivates, CompScreenPrivateKey, NULL);
    ret = (*pScreen->CloseScreen) (pScreen);

    return ret;
}

static void
compInstallColormap(ColormapPtr pColormap)
{
    VisualPtr pVisual = pColormap->pVisual;
    ScreenPtr pScreen = pColormap->pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    int a;

    for (a = 0; a < cs->numAlternateVisuals; a++)
        if (pVisual->vid == cs->alternateVisuals[a])
            return;
    pScreen->InstallColormap = cs->InstallColormap;
    (*pScreen->InstallColormap) (pColormap);
    cs->InstallColormap = pScreen->InstallColormap;
    pScreen->InstallColormap = compInstallColormap;
}

static void
compCheckBackingStore(WindowPtr pWin)
{
    if (pWin->backingStore != NotUseful && !pWin->backStorage) {
        compRedirectWindow(serverClient, pWin, CompositeRedirectAutomatic);
        pWin->backStorage = TRUE;
    }
    else if (pWin->backingStore == NotUseful && pWin->backStorage) {
        compUnredirectWindow(serverClient, pWin,
                             CompositeRedirectAutomatic);
        pWin->backStorage = FALSE;
    }
}

/* Fake backing store via automatic redirection */
static Bool
compChangeWindowAttributes(WindowPtr pWin, unsigned long mask)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret;

    pScreen->ChangeWindowAttributes = cs->ChangeWindowAttributes;
    ret = pScreen->ChangeWindowAttributes(pWin, mask);

    if (ret && (mask & CWBackingStore) &&
        pScreen->backingStoreSupport != NotUseful)
        compCheckBackingStore(pWin);

    pScreen->ChangeWindowAttributes = compChangeWindowAttributes;

    return ret;
}

static void
compGetImage(DrawablePtr pDrawable,
             int sx, int sy,
             int w, int h,
             unsigned int format, unsigned long planemask, char *pdstLine)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->GetImage = cs->GetImage;
    if (pDrawable->type == DRAWABLE_WINDOW)
        compPaintChildrenToWindow((WindowPtr) pDrawable);
    (*pScreen->GetImage) (pDrawable, sx, sy, w, h, format, planemask, pdstLine);
    cs->GetImage = pScreen->GetImage;
    pScreen->GetImage = compGetImage;
}

static void
compGetSpans(DrawablePtr pDrawable, int wMax, DDXPointPtr ppt, int *pwidth,
             int nspans, char *pdstStart)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->GetSpans = cs->GetSpans;
    if (pDrawable->type == DRAWABLE_WINDOW)
        compPaintChildrenToWindow((WindowPtr) pDrawable);
    (*pScreen->GetSpans) (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
    cs->GetSpans = pScreen->GetSpans;
    pScreen->GetSpans = compGetSpans;
}

static void
compSourceValidate(DrawablePtr pDrawable,
                   int x, int y,
                   int width, int height, unsigned int subWindowMode)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->SourceValidate = cs->SourceValidate;
    if (pDrawable->type == DRAWABLE_WINDOW && subWindowMode == IncludeInferiors)
        compPaintChildrenToWindow((WindowPtr) pDrawable);
    if (pScreen->SourceValidate)
        (*pScreen->SourceValidate) (pDrawable, x, y, width, height,
                                    subWindowMode);
    cs->SourceValidate = pScreen->SourceValidate;
    pScreen->SourceValidate = compSourceValidate;
}

/*
 * Add alternate visuals -- always expose an ARGB32 and RGB24 visual
 */

static DepthPtr
compFindVisuallessDepth(ScreenPtr pScreen, int d)
{
    int i;

    for (i = 0; i < pScreen->numDepths; i++) {
        DepthPtr depth = &pScreen->allowedDepths[i];

        if (depth->depth == d) {
            /*
             * Make sure it doesn't have visuals already
             */
            if (depth->numVids)
                return 0;
            /*
             * looks fine
             */
            return depth;
        }
    }
    /*
     * If there isn't one, then it's gonna be hard to have
     * an associated visual
     */
    return 0;
}

/*
 * Add a list of visual IDs to the list of visuals to implicitly redirect.
 */
static Bool
compRegisterAlternateVisuals(CompScreenPtr cs, VisualID * vids, int nVisuals)
{
    VisualID *p;

    p = reallocarray(cs->alternateVisuals,
                     cs->numAlternateVisuals + nVisuals, sizeof(VisualID));
    if (p == NULL)
        return FALSE;

    memcpy(&p[cs->numAlternateVisuals], vids, sizeof(VisualID) * nVisuals);

    cs->alternateVisuals = p;
    cs->numAlternateVisuals += nVisuals;

    return TRUE;
}

Bool
CompositeRegisterAlternateVisuals(ScreenPtr pScreen, VisualID * vids,
                                  int nVisuals)
{
    CompScreenPtr cs = GetCompScreen(pScreen);

    return compRegisterAlternateVisuals(cs, vids, nVisuals);
}

Bool
CompositeRegisterImplicitRedirectionException(ScreenPtr pScreen,
                                              VisualID parentVisual,
                                              VisualID winVisual)
{
    CompScreenPtr cs = GetCompScreen(pScreen);
    CompImplicitRedirectException *p;

    p = reallocarray(cs->implicitRedirectExceptions,
                     cs->numImplicitRedirectExceptions + 1, sizeof(p[0]));
    if (p == NULL)
        return FALSE;

    p[cs->numImplicitRedirectExceptions].parentVisual = parentVisual;
    p[cs->numImplicitRedirectExceptions].winVisual = winVisual;

    cs->implicitRedirectExceptions = p;
    cs->numImplicitRedirectExceptions++;

    return TRUE;
}

typedef struct _alternateVisual {
    int depth;
    CARD32 format;
} CompAlternateVisual;

static CompAlternateVisual altVisuals[] = {
#if COMP_INCLUDE_RGB24_VISUAL
    {24, PICT_r8g8b8},
#endif
    {32, PICT_a8r8g8b8},
};

static const int NUM_COMP_ALTERNATE_VISUALS = sizeof(altVisuals) /
    sizeof(CompAlternateVisual);

static Bool
compAddAlternateVisual(ScreenPtr pScreen, CompScreenPtr cs,
                       CompAlternateVisual * alt)
{
    VisualPtr visual;
    DepthPtr depth;
    PictFormatPtr pPictFormat;
    unsigned long alphaMask;

    /*
     * The ARGB32 visual is always available.  Other alternate depth visuals
     * are only provided if their depth is less than the root window depth.
     * There's no deep reason for this.
     */
    if (alt->depth >= pScreen->rootDepth && alt->depth != 32)
        return FALSE;

    depth = compFindVisuallessDepth(pScreen, alt->depth);
    if (!depth)
        /* alt->depth doesn't exist or already has alternate visuals. */
        return TRUE;

    pPictFormat = PictureMatchFormat(pScreen, alt->depth, alt->format);
    if (!pPictFormat)
        return FALSE;

    if (ResizeVisualArray(pScreen, 1, depth) == FALSE) {
        return FALSE;
    }

    visual = pScreen->visuals + (pScreen->numVisuals - 1);      /* the new one */

    /* Initialize the visual */
    visual->bitsPerRGBValue = 8;
    if (PICT_FORMAT_TYPE(alt->format) == PICT_TYPE_COLOR) {
        visual->class = PseudoColor;
        visual->nplanes = PICT_FORMAT_BPP(alt->format);
        visual->ColormapEntries = 1 << visual->nplanes;
    }
    else {
        DirectFormatRec *direct = &pPictFormat->direct;

        visual->class = TrueColor;
        visual->redMask = ((unsigned long) direct->redMask) << direct->red;
        visual->greenMask =
            ((unsigned long) direct->greenMask) << direct->green;
        visual->blueMask = ((unsigned long) direct->blueMask) << direct->blue;
        alphaMask = ((unsigned long) direct->alphaMask) << direct->alpha;
        visual->offsetRed = direct->red;
        visual->offsetGreen = direct->green;
        visual->offsetBlue = direct->blue;
        /*
         * Include A bits in this (unlike GLX which includes only RGB)
         * This lets DIX compute suitable masks for colormap allocations
         */
        visual->nplanes = Ones(visual->redMask |
                               visual->greenMask |
                               visual->blueMask | alphaMask);
        /* find widest component */
        visual->ColormapEntries = (1 << max(Ones(visual->redMask),
                                            max(Ones(visual->greenMask),
                                                Ones(visual->blueMask))));
    }

    /* remember the visual ID to detect auto-update windows */
    compRegisterAlternateVisuals(cs, &visual->vid, 1);

    return TRUE;
}

static Bool
compAddAlternateVisuals(ScreenPtr pScreen, CompScreenPtr cs)
{
    int alt, ret = 0;

    for (alt = 0; alt < NUM_COMP_ALTERNATE_VISUALS; alt++)
        ret |= compAddAlternateVisual(pScreen, cs, altVisuals + alt);

    return ! !ret;
}

Bool
compScreenInit(ScreenPtr pScreen)
{
    CompScreenPtr cs;

    if (!dixRegisterPrivateKey(&CompScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&CompWindowPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&CompSubwindowsPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    if (GetCompScreen(pScreen))
        return TRUE;
    cs = (CompScreenPtr) malloc(sizeof(CompScreenRec));
    if (!cs)
        return FALSE;

    cs->overlayWid = FakeClientID(0);
    cs->pOverlayWin = NULL;
    cs->pOverlayClients = NULL;

    cs->numAlternateVisuals = 0;
    cs->alternateVisuals = NULL;
    cs->numImplicitRedirectExceptions = 0;
    cs->implicitRedirectExceptions = NULL;

    if (!compAddAlternateVisuals(pScreen, cs)) {
        free(cs);
        return FALSE;
    }

    if (!disableBackingStore)
        pScreen->backingStoreSupport = WhenMapped;

    cs->PositionWindow = pScreen->PositionWindow;
    pScreen->PositionWindow = compPositionWindow;

    cs->CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = compCopyWindow;

    cs->CreateWindow = pScreen->CreateWindow;
    pScreen->CreateWindow = compCreateWindow;

    cs->DestroyWindow = pScreen->DestroyWindow;
    pScreen->DestroyWindow = compDestroyWindow;

    cs->RealizeWindow = pScreen->RealizeWindow;
    pScreen->RealizeWindow = compRealizeWindow;

    cs->UnrealizeWindow = pScreen->UnrealizeWindow;
    pScreen->UnrealizeWindow = compUnrealizeWindow;

    cs->ClipNotify = pScreen->ClipNotify;
    pScreen->ClipNotify = compClipNotify;

    cs->ConfigNotify = pScreen->ConfigNotify;
    pScreen->ConfigNotify = compConfigNotify;

    cs->MoveWindow = pScreen->MoveWindow;
    pScreen->MoveWindow = compMoveWindow;

    cs->ResizeWindow = pScreen->ResizeWindow;
    pScreen->ResizeWindow = compResizeWindow;

    cs->ChangeBorderWidth = pScreen->ChangeBorderWidth;
    pScreen->ChangeBorderWidth = compChangeBorderWidth;

    cs->ReparentWindow = pScreen->ReparentWindow;
    pScreen->ReparentWindow = compReparentWindow;

    cs->InstallColormap = pScreen->InstallColormap;
    pScreen->InstallColormap = compInstallColormap;

    cs->ChangeWindowAttributes = pScreen->ChangeWindowAttributes;
    pScreen->ChangeWindowAttributes = compChangeWindowAttributes;

    cs->BlockHandler = NULL;

    cs->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = compCloseScreen;

    cs->GetImage = pScreen->GetImage;
    pScreen->GetImage = compGetImage;

    cs->GetSpans = pScreen->GetSpans;
    pScreen->GetSpans = compGetSpans;

    cs->SourceValidate = pScreen->SourceValidate;
    pScreen->SourceValidate = compSourceValidate;

    dixSetPrivate(&pScreen->devPrivates, CompScreenPrivateKey, cs);

    RegisterRealChildHeadProc(CompositeRealChildHead);

    return TRUE;
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d108 14
d134 2
a135 11
        pScreen->backingStoreSupport != NotUseful) {
        if (pWin->backingStore != NotUseful && !pWin->backStorage) {
            compRedirectWindow(serverClient, pWin, CompositeRedirectAutomatic);
            pWin->backStorage = TRUE;
        }
        else if (pWin->backingStore == NotUseful && pWin->backStorage) {
            compUnredirectWindow(serverClient, pWin,
                                 CompositeRedirectAutomatic);
            pWin->backStorage = FALSE;
        }
    }
d231 2
a232 2
    p = realloc(cs->alternateVisuals,
                sizeof(VisualID) * (cs->numAlternateVisuals + nVisuals));
d261 2
a262 2
    p = realloc(cs->implicitRedirectExceptions,
                sizeof(p[0]) * (cs->numImplicitRedirectExceptions + 1));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d81 1
d123 1
a123 1
            pWin->backStorage = (void *) (intptr_t) 1;
d128 1
a128 1
            pWin->backStorage = NULL;
d155 15
d212 1
a212 1
     * If there isn't one, then it's gonna be hard to have 
d450 3
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d122 1
a122 1
            pWin->backStorage = (pointer) (intptr_t) 1;
d232 22
d374 2
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d120 1
a120 1
        if (pWin->backingStore != NotUseful) {
d124 1
a124 1
        else {
d357 3
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d56 1
a56 1
compCloseScreen(int index, ScreenPtr pScreen)
d85 1
a85 1
    ret = (*pScreen->CloseScreen) (index, pScreen);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d56 1
a56 1
compCloseScreen (int index, ScreenPtr pScreen)
d58 2
a59 2
    CompScreenPtr   cs = GetCompScreen (pScreen);
    Bool	    ret;
d71 1
a71 1
    
d91 1
a91 1
compInstallColormap (ColormapPtr pColormap)
d93 4
a96 4
    VisualPtr	    pVisual = pColormap->pVisual;
    ScreenPtr	    pScreen = pColormap->pScreen;
    CompScreenPtr   cs = GetCompScreen (pScreen);
    int		    a;
d99 2
a100 2
	if (pVisual->vid == cs->alternateVisuals[a])
	    return;
d112 1
a112 1
    CompScreenPtr cs = GetCompScreen (pScreen);
d119 10
a128 9
	    pScreen->backingStoreSupport != NotUseful) {
	if (pWin->backingStore != NotUseful) {
	    compRedirectWindow(serverClient, pWin, CompositeRedirectAutomatic);
	    pWin->backStorage = (pointer) (intptr_t) 1;
	} else {
	    compUnredirectWindow(serverClient, pWin,
				 CompositeRedirectAutomatic);
	    pWin->backStorage = NULL;
	}
d137 4
a140 6
compGetImage (DrawablePtr pDrawable,
	      int sx, int sy,
	      int w, int h,
	      unsigned int format,
	      unsigned long planemask,
	      char *pdstLine)
d143 1
a143 1
    CompScreenPtr cs = GetCompScreen (pScreen);
d147 1
a147 1
	compPaintChildrenToWindow ((WindowPtr) pDrawable);
d153 4
a156 4
static void compSourceValidate(DrawablePtr pDrawable,
			       int x, int y,
			       int width, int height,
			       unsigned int subWindowMode)
d159 1
a159 1
    CompScreenPtr cs = GetCompScreen (pScreen);
d163 1
a163 1
	compPaintChildrenToWindow ((WindowPtr) pDrawable);
d165 2
a166 2
	(*pScreen->SourceValidate) (pDrawable, x, y, width, height,
				    subWindowMode);
d176 1
a176 1
compFindVisuallessDepth (ScreenPtr pScreen, int d)
d178 4
a181 1
    int		i;
d183 11
a193 15
    for (i = 0; i < pScreen->numDepths; i++)
    {
	DepthPtr    depth = &pScreen->allowedDepths[i];
	if (depth->depth == d)
	{
	    /*
	     * Make sure it doesn't have visuals already
	     */
	    if (depth->numVids)
		return 0;
	    /*
	     * looks fine
	     */
	    return depth;
	}
d206 1
a206 1
compRegisterAlternateVisuals (CompScreenPtr cs, VisualID *vids, int nVisuals)
d211 3
a213 3
		 sizeof(VisualID) * (cs->numAlternateVisuals + nVisuals));
    if(p == NULL)
	return FALSE;
d223 3
a225 2
Bool CompositeRegisterAlternateVisuals (ScreenPtr pScreen, VisualID *vids,
					int nVisuals)
d227 2
a228 1
    CompScreenPtr cs = GetCompScreen (pScreen);
d233 2
a234 2
    int		depth;
    CARD32	format;
d237 1
a237 1
static CompAlternateVisual  altVisuals[] = {
d239 1
a239 1
    {	24,	PICT_r8g8b8 },
d241 1
a241 1
    {	32,	PICT_a8r8g8b8 },
d245 1
a245 1
					      sizeof(CompAlternateVisual);
d249 1
a249 1
		       CompAlternateVisual *alt)
d251 4
a254 4
    VisualPtr	    visual;
    DepthPtr	    depth;
    PictFormatPtr   pPictFormat;
    unsigned long   alphaMask;
d262 1
a262 1
	return FALSE;
d264 1
a264 1
    depth = compFindVisuallessDepth (pScreen, alt->depth);
d266 2
a267 2
	/* alt->depth doesn't exist or already has alternate visuals. */
	return TRUE;
d269 1
a269 1
    pPictFormat = PictureMatchFormat (pScreen, alt->depth, alt->format);
d271 1
a271 1
	return FALSE;
d277 1
a277 1
    visual = pScreen->visuals + (pScreen->numVisuals - 1); /* the new one */
d282 27
a308 25
	visual->class = PseudoColor;
	visual->nplanes = PICT_FORMAT_BPP(alt->format);
	visual->ColormapEntries = 1 << visual->nplanes;
    } else {
	DirectFormatRec *direct = &pPictFormat->direct;
	visual->class = TrueColor;
	visual->redMask   = ((unsigned long)direct->redMask) << direct->red;
	visual->greenMask = ((unsigned long)direct->greenMask) << direct->green;
	visual->blueMask  = ((unsigned long)direct->blueMask) << direct->blue;
	alphaMask = ((unsigned long)direct->alphaMask) << direct->alpha;
	visual->offsetRed   = direct->red;
	visual->offsetGreen = direct->green;
	visual->offsetBlue  = direct->blue;
	/*
	 * Include A bits in this (unlike GLX which includes only RGB)
	 * This lets DIX compute suitable masks for colormap allocations
	 */
	visual->nplanes = Ones (visual->redMask |
		visual->greenMask |
		visual->blueMask |
		alphaMask);
	/* find widest component */
	visual->ColormapEntries = (1 << max (Ones (visual->redMask),
		    max (Ones (visual->greenMask),
			Ones (visual->blueMask))));
d318 1
a318 1
compAddAlternateVisuals (ScreenPtr pScreen, CompScreenPtr cs)
d323 1
a323 1
	ret |= compAddAlternateVisual(pScreen, cs, altVisuals + alt);
d325 1
a325 1
    return !!ret;
d329 1
a329 1
compScreenInit (ScreenPtr pScreen)
d331 1
a331 1
    CompScreenPtr   cs;
d334 1
a334 1
	return FALSE;
d336 1
a336 1
	return FALSE;
d338 1
a338 1
	return FALSE;
d340 3
a342 3
    if (GetCompScreen (pScreen))
	return TRUE;
    cs = (CompScreenPtr) malloc(sizeof (CompScreenRec));
d344 1
a344 1
	return FALSE;
d353 3
a355 4
    if (!compAddAlternateVisuals (pScreen, cs))
    {
	free(cs);
	return FALSE;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
a63 1
    pScreen->BlockHandler = cs->BlockHandler;
d80 3
d136 6
a141 1
compScreenUpdate (ScreenPtr pScreen)
d143 2
a144 1
    CompScreenPtr   cs = GetCompScreen (pScreen);
d146 6
a151 6
    compCheckTree (pScreen);
    if (cs->damaged)
    {
	compWindowUpdate (pScreen->root);
	cs->damaged = FALSE;
    }
d154 4
a157 5
static void
compBlockHandler (int	    i,
		  pointer   blockData,
		  pointer   pTimeout,
		  pointer   pReadmask)
d159 2
a160 2
    ScreenPtr	    pScreen = screenInfo.screens[i];
    CompScreenPtr   cs = GetCompScreen (pScreen);
d162 8
a169 5
    pScreen->BlockHandler = cs->BlockHandler;
    compScreenUpdate (pScreen);
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
    cs->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = compBlockHandler;
a343 1
    cs->damaged = FALSE;
d399 1
a399 2
    cs->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = compBlockHandler;
d403 6
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d51 3
a53 7
static int CompScreenPrivateKeyIndex;
DevPrivateKey CompScreenPrivateKey = &CompScreenPrivateKeyIndex;
static int CompWindowPrivateKeyIndex;
DevPrivateKey CompWindowPrivateKey = &CompWindowPrivateKeyIndex;
static int CompSubwindowsPrivateKeyIndex;
DevPrivateKey CompSubwindowsPrivateKey = &CompSubwindowsPrivateKeyIndex;

d61 1
a61 1
    xfree (cs->alternateVisuals);
d68 1
d81 1
a81 1
    xfree (cs);
d141 1
a141 1
	compWindowUpdate (WindowTable[pScreen->myNum]);
d202 1
a202 1
    p = xrealloc(cs->alternateVisuals,
d321 7
d330 1
a330 1
    cs = (CompScreenPtr) xalloc (sizeof (CompScreenRec));
d344 1
a344 1
	xfree (cs);
d368 3
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems
d4 10
a13 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Sun Microsystems not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Sun Microsystems makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d15 7
a21 7
 * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d49 1
a217 1
_X_EXPORT
d244 1
a244 6
    VisualPtr	    visual, visuals;
    int		    i;
    int		    numVisuals;
    XID		    *installedCmaps;
    ColormapPtr	    installedCmap;
    int		    numInstalledCmaps;
a246 1
    VisualID	    *vid;
d266 2
a267 20
    vid = xalloc(sizeof(VisualID));
    if (!vid)
	return FALSE;

    /* Find the installed colormaps */
    installedCmaps = xalloc (pScreen->maxInstalledCmaps * sizeof (XID));
    if (!installedCmaps) {
	xfree(vid);
	return FALSE;
    }
    numInstalledCmaps = pScreen->ListInstalledColormaps(pScreen, 
	    installedCmaps);

    /* realloc the visual array to fit the new one in place */
    numVisuals = pScreen->numVisuals;
    visuals = xrealloc(pScreen->visuals, (numVisuals + 1) * sizeof(VisualRec));
    if (!visuals) {
	xfree(vid);
	xfree(installedCmaps);
	return FALSE;
d270 1
a270 21
    /*
     * Fix up any existing installed colormaps -- we'll assume that
     * the only ones created so far have been installed.  If this
     * isn't true, we'll have to walk the resource database looking
     * for all colormaps.
     */
    for (i = 0; i < numInstalledCmaps; i++) {
	int j;

	installedCmap = LookupIDByType (installedCmaps[i], RT_COLORMAP);
	if (!installedCmap)
	    continue;
	j = installedCmap->pVisual - pScreen->visuals;
	installedCmap->pVisual = &visuals[j];
    }

    xfree(installedCmaps);

    pScreen->visuals = visuals;
    visual = visuals + pScreen->numVisuals; /* the new one */
    pScreen->numVisuals++;
a272 1
    visual->vid = FakeClientID (0);
a304 4
    /* Fix up the depth */
    *vid = visual->vid;
    depth->numVids = 1;
    depth->vids = vid;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d49 6
a54 3
DevPrivateKey CompScreenPrivateKey = &CompScreenPrivateKey;
DevPrivateKey CompWindowPrivateKey = &CompWindowPrivateKey;
DevPrivateKey CompSubwindowsPrivateKey = &CompSubwindowsPrivateKey;
a81 8
    deleteCompOverlayClientsForScreen(pScreen);

    /* 
    ** Note: no need to call DeleteWindow; the server has
    ** already destroyed it.
    */
    cs->pOverlayWin = NULL;

d121 1
a121 1
	    pWin->backStorage = TRUE;
d125 1
a125 1
	    pWin->backStorage = FALSE;
d379 1
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d49 3
a51 4
int	CompScreenPrivateIndex;
int	CompWindowPrivateIndex;
int	CompSubwindowsPrivateIndex;
int	CompGeneration;
d65 1
a71 1
    pScreen->PaintWindowBackground = cs->PaintWindowBackground;
d88 1
a88 1
    pScreen->devPrivates[CompScreenPrivateIndex].ptr = 0;
d111 28
a228 6
#if COMP_INCLUDE_RGB24_VISUAL
#define NUM_COMP_ALTERNATE_VISUALS 2
#else
#define NUM_COMP_ALTERNATE_VISUALS 1
#endif

d234 1
a234 1
static CompAlternateVisual  altVisuals[NUM_COMP_ALTERNATE_VISUALS] = {
d241 3
d245 2
a246 1
compAddAlternateVisuals (ScreenPtr pScreen, CompScreenPtr cs)
d248 1
a248 3
    VisualPtr	    visuals;
    DepthPtr	    depths[NUM_COMP_ALTERNATE_VISUALS];
    PictFormatPtr   pPictFormats[NUM_COMP_ALTERNATE_VISUALS];
a250 1
    VisualID	    *vids[NUM_COMP_ALTERNATE_VISUALS];
d254 12
a265 18
    int		    numAlternate = 0;
    int		    alt;
    
    for (alt = 0; alt < NUM_COMP_ALTERNATE_VISUALS; alt++)
    {
	DepthPtr	depth;
	PictFormatPtr   pPictFormat;
	
	depth = compFindVisuallessDepth (pScreen, altVisuals[alt].depth);
	if (!depth)
	    continue;
	/*
	 * Find the right picture format
	 */
	pPictFormat = PictureMatchFormat (pScreen, altVisuals[alt].depth,
					  altVisuals[alt].format);
	if (!pPictFormat)
	    continue;
d267 3
a269 12
	/*
	 * Allocate vid list for this depth
	 */
	vids[numAlternate] = xalloc (sizeof (VisualID));
	if (!vids[numAlternate])
	    continue;
	depths[numAlternate] = depth;
	pPictFormats[numAlternate] = pPictFormat;
	numAlternate++;
    }
    
    if (!numAlternate)
d272 9
a280 3
    /*
     * Find the installed colormaps
     */
d282 2
a283 4
    if (!installedCmaps)
    {
	for (alt = 0; alt < numAlternate; alt++)
	    xfree (vids[alt]);
d286 4
a289 6
    numInstalledCmaps = (*pScreen->ListInstalledColormaps) (pScreen, 
							    installedCmaps);
    
    /*
     * realloc the visual array to fit the new one in place
     */
d291 4
a294 7
    visuals = xrealloc (pScreen->visuals,
			(numVisuals + numAlternate) * sizeof (VisualRec));
    if (!visuals)
    {
	for (alt = 0; alt < numAlternate; alt++)
	    xfree (vids[alt]);
	xfree (installedCmaps);
d297 1
a297 1
    
d304 1
a304 2
    for (i = 0; i < numInstalledCmaps; i++)
    {
d306 1
a306 1
	
d314 1
a314 1
    xfree (installedCmaps);
d317 2
a318 1
    pScreen->numVisuals = numVisuals + numAlternate;
d320 9
a328 10
    for (alt = 0; alt < numAlternate; alt++)
    {
	DepthPtr	depth = depths[alt];
	PictFormatPtr	pPictFormat = pPictFormats[alt];
	VisualPtr	visual = &visuals[numVisuals + alt];
	unsigned long	alphaMask;

	/*
	 * Initialize the visual
	 */
d330 7
a336 14
	visual->bitsPerRGBValue = 8;

	visual->vid = FakeClientID (0);
	visual->redMask   = (((unsigned long) pPictFormat->direct.redMask) << 
			     pPictFormat->direct.red);
	visual->greenMask = (((unsigned long) pPictFormat->direct.greenMask) << 
			     pPictFormat->direct.green);
	visual->blueMask  = (((unsigned long) pPictFormat->direct.blueMask) << 
			     pPictFormat->direct.blue);
	alphaMask =  (((unsigned long) pPictFormat->direct.alphaMask) << 
		      pPictFormat->direct.alpha);
	visual->offsetRed   = pPictFormat->direct.red;
	visual->offsetGreen = pPictFormat->direct.green;
	visual->offsetBlue  = pPictFormat->direct.blue;
d342 4
a345 6
				visual->greenMask |
				visual->blueMask |
				alphaMask);
	/*
	 * find widest component
	 */
d347 3
a349 2
					     max (Ones (visual->greenMask),
						  Ones (visual->blueMask))));
d351 7
a357 12
	/*
	 * remember the visual ID to detect auto-update windows
	 */
	compRegisterAlternateVisuals(cs, &visual->vid, 1);
	
	/*
	 * Fix up the depth
	 */
	vids[alt][0] = visual->vid;
	depth->numVids = 1;
	depth->vids = vids[alt];
    }
d361 11
a376 19
    if (CompGeneration != serverGeneration)
    {
	CompScreenPrivateIndex = AllocateScreenPrivateIndex ();
	if (CompScreenPrivateIndex == -1)
	    return FALSE;
	CompWindowPrivateIndex = AllocateWindowPrivateIndex ();
	if (CompWindowPrivateIndex == -1)
	    return FALSE;
	CompSubwindowsPrivateIndex = AllocateWindowPrivateIndex ();
	if (CompSubwindowsPrivateIndex == -1)
	    return FALSE;
	CompGeneration = serverGeneration;
    }
    if (!AllocateWindowPrivate (pScreen, CompWindowPrivateIndex, 0))
	return FALSE;

    if (!AllocateWindowPrivate (pScreen, CompSubwindowsPrivateIndex, 0))
	return FALSE;

a413 3
    cs->PaintWindowBackground = pScreen->PaintWindowBackground;
    pScreen->PaintWindowBackground = compPaintWindowBackground;

d432 3
d441 1
a441 1
    pScreen->devPrivates[CompScreenPrivateIndex].ptr = (pointer) cs;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d54 1
a54 1
static int	CompGeneration;
d204 6
d215 1
a215 1
static CompAlternateVisual  altVisuals[] = {
a221 3
static const int NUM_COMP_ALTERNATE_VISUALS = sizeof(altVisuals) /
					      sizeof(CompAlternateVisual);

d223 1
a223 2
compAddAlternateVisual(ScreenPtr pScreen, CompScreenPtr cs,
		       CompAlternateVisual *alt)
d225 3
a227 1
    VisualPtr	    visual, visuals;
d230 1
d234 32
a265 4
    DepthPtr	    depth;
    PictFormatPtr   pPictFormat;
    VisualID	    *vid;
    unsigned long   alphaMask;
d268 1
a268 3
     * The ARGB32 visual is always available.  Other alternate depth visuals
     * are only provided if their depth is less than the root window depth.
     * There's no deep reason for this.
a269 17
    if (alt->depth >= pScreen->rootDepth && alt->depth != 32)
	return FALSE;

    depth = compFindVisuallessDepth (pScreen, alt->depth);
    if (!depth)
	/* alt->depth doesn't exist or already has alternate visuals. */
	return TRUE;

    pPictFormat = PictureMatchFormat (pScreen, alt->depth, alt->format);
    if (!pPictFormat)
	return FALSE;

    vid = xalloc(sizeof(VisualID));
    if (!vid)
	return FALSE;

    /* Find the installed colormaps */
d271 4
a274 2
    if (!installedCmaps) {
	xfree(vid);
d277 6
a282 4
    numInstalledCmaps = pScreen->ListInstalledColormaps(pScreen, 
	    installedCmaps);

    /* realloc the visual array to fit the new one in place */
d284 7
a290 4
    visuals = xrealloc(pScreen->visuals, (numVisuals + 1) * sizeof(VisualRec));
    if (!visuals) {
	xfree(vid);
	xfree(installedCmaps);
d293 1
a293 1

d300 2
a301 1
    for (i = 0; i < numInstalledCmaps; i++) {
d303 1
a303 1

d311 1
a311 1
    xfree(installedCmaps);
d314 1
a314 2
    visual = visuals + pScreen->numVisuals; /* the new one */
    pScreen->numVisuals++;
d316 10
a325 9
    /* Initialize the visual */
    visual->vid = FakeClientID (0);
    visual->bitsPerRGBValue = 8;
    if (PICT_FORMAT_TYPE(alt->format) == PICT_TYPE_COLOR) {
	visual->class = PseudoColor;
	visual->nplanes = PICT_FORMAT_BPP(alt->format);
	visual->ColormapEntries = 1 << visual->nplanes;
    } else {
	DirectFormatRec *direct = &pPictFormat->direct;
d327 14
a340 7
	visual->redMask   = ((unsigned long)direct->redMask) << direct->red;
	visual->greenMask = ((unsigned long)direct->greenMask) << direct->green;
	visual->blueMask  = ((unsigned long)direct->blueMask) << direct->blue;
	alphaMask = ((unsigned long)direct->alphaMask) << direct->alpha;
	visual->offsetRed   = direct->red;
	visual->offsetGreen = direct->green;
	visual->offsetBlue  = direct->blue;
d346 6
a351 4
		visual->greenMask |
		visual->blueMask |
		alphaMask);
	/* find widest component */
d353 14
a366 2
		    max (Ones (visual->greenMask),
			Ones (visual->blueMask))));
a367 8

    /* remember the visual ID to detect auto-update windows */
    compRegisterAlternateVisuals(cs, &visual->vid, 1);

    /* Fix up the depth */
    *vid = visual->vid;
    depth->numVids = 1;
    depth->vids = vid;
a368 11
}

static Bool
compAddAlternateVisuals (ScreenPtr pScreen, CompScreenPtr cs)
{
    int alt, ret = 0;

    for (alt = 0; alt < NUM_COMP_ALTERNATE_VISUALS; alt++)
	ret |= compAddAlternateVisual(pScreen, cs, altVisuals + alt);

    return !!ret;
@

