head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "compint.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

#ifdef COMPOSITE_DEBUG
static int
compCheckWindow(WindowPtr pWin, void *data)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    PixmapPtr pWinPixmap = (*pScreen->GetWindowPixmap) (pWin);
    PixmapPtr pParentPixmap =
        pWin->parent ? (*pScreen->GetWindowPixmap) (pWin->parent) : 0;
    PixmapPtr pScreenPixmap = (*pScreen->GetScreenPixmap) (pScreen);

    if (!pWin->parent) {
        assert(pWin->redirectDraw == RedirectDrawNone);
        assert(pWinPixmap == pScreenPixmap);
    }
    else if (pWin->redirectDraw != RedirectDrawNone) {
        assert(pWinPixmap != pParentPixmap);
        assert(pWinPixmap != pScreenPixmap);
    }
    else {
        assert(pWinPixmap == pParentPixmap);
    }
    assert(0 < pWinPixmap->refcnt && pWinPixmap->refcnt < 3);
    assert(0 < pScreenPixmap->refcnt && pScreenPixmap->refcnt < 3);
    if (pParentPixmap)
        assert(0 <= pParentPixmap->refcnt && pParentPixmap->refcnt < 3);
    return WT_WALKCHILDREN;
}

void
compCheckTree(ScreenPtr pScreen)
{
    WalkTree(pScreen, compCheckWindow, 0);
}
#endif

typedef struct _compPixmapVisit {
    WindowPtr pWindow;
    PixmapPtr pPixmap;
} CompPixmapVisitRec, *CompPixmapVisitPtr;

static Bool
compRepaintBorder(ClientPtr pClient, void *closure)
{
    WindowPtr pWindow;
    int rc =
        dixLookupWindow(&pWindow, (XID) (intptr_t) closure, pClient,
                        DixWriteAccess);

    if (rc == Success) {
        RegionRec exposed;

        RegionNull(&exposed);
        RegionSubtract(&exposed, &pWindow->borderClip, &pWindow->winSize);
        pWindow->drawable.pScreen->PaintWindow(pWindow, &exposed, PW_BORDER);
        RegionUninit(&exposed);
    }
    return TRUE;
}

static int
compSetPixmapVisitWindow(WindowPtr pWindow, void *data)
{
    CompPixmapVisitPtr pVisit = (CompPixmapVisitPtr) data;
    ScreenPtr pScreen = pWindow->drawable.pScreen;

    if (pWindow != pVisit->pWindow && pWindow->redirectDraw != RedirectDrawNone)
        return WT_DONTWALKCHILDREN;
    (*pScreen->SetWindowPixmap) (pWindow, pVisit->pPixmap);
    /*
     * Recompute winSize and borderSize.  This is duplicate effort
     * when resizing pixmaps, but necessary when changing redirection.
     * Might be nice to fix this.
     */
    SetWinSize(pWindow);
    SetBorderSize(pWindow);
    if (HasBorder(pWindow))
        QueueWorkProc(compRepaintBorder, serverClient,
                      (void *) (intptr_t) pWindow->drawable.id);
    return WT_WALKCHILDREN;
}

void
compSetPixmap(WindowPtr pWindow, PixmapPtr pPixmap)
{
    CompPixmapVisitRec visitRec;

    visitRec.pWindow = pWindow;
    visitRec.pPixmap = pPixmap;
    TraverseTree(pWindow, compSetPixmapVisitWindow, (void *) &visitRec);
    compCheckTree(pWindow->drawable.pScreen);
}

Bool
compCheckRedirect(WindowPtr pWin)
{
    CompWindowPtr cw = GetCompWindow(pWin);
    CompScreenPtr cs = GetCompScreen(pWin->drawable.pScreen);
    Bool should;

    should = pWin->realized && (pWin->drawable.class != InputOnly) &&
        (cw != NULL) && (pWin->parent != NULL);

    /* Never redirect the overlay window */
    if (cs->pOverlayWin != NULL) {
        if (pWin == cs->pOverlayWin) {
            should = FALSE;
        }
    }

    if (should != (pWin->redirectDraw != RedirectDrawNone)) {
        if (should)
            return compAllocPixmap(pWin);
        else {
            ScreenPtr pScreen = pWin->drawable.pScreen;
            PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);

            compSetParentPixmap(pWin);
            compRestoreWindow(pWin, pPixmap);
            (*pScreen->DestroyPixmap) (pPixmap);
        }
    }
    else if (should) {
        if (cw->update == CompositeRedirectAutomatic)
            pWin->redirectDraw = RedirectDrawAutomatic;
        else
            pWin->redirectDraw = RedirectDrawManual;
    }
    return TRUE;
}

static int
updateOverlayWindow(ScreenPtr pScreen)
{
    CompScreenPtr cs;
    WindowPtr pWin;             /* overlay window */
    XID vlist[2];
    int w = pScreen->width;
    int h = pScreen->height;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        w = PanoramiXPixWidth;
        h = PanoramiXPixHeight;
    }
#endif

    cs = GetCompScreen(pScreen);
    if ((pWin = cs->pOverlayWin) != NULL) {
        if ((pWin->drawable.width == w) && (pWin->drawable.height == h))
            return Success;

        /* Let's resize the overlay window. */
        vlist[0] = w;
        vlist[1] = h;
        return ConfigureWindow(pWin, CWWidth | CWHeight, vlist, wClient(pWin));
    }

    /* Let's be on the safe side and not assume an overlay window is
       always allocated. */
    return Success;
}

Bool
compPositionWindow(WindowPtr pWin, int x, int y)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret = TRUE;

    pScreen->PositionWindow = cs->PositionWindow;
    /*
     * "Shouldn't need this as all possible places should be wrapped
     *
     compCheckRedirect (pWin);
     */
#ifdef COMPOSITE_DEBUG
    if ((pWin->redirectDraw != RedirectDrawNone) !=
        (pWin->viewable && (GetCompWindow(pWin) != NULL)))
        OsAbort();
#endif
    if (pWin->redirectDraw != RedirectDrawNone) {
        PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);
        int bw = wBorderWidth(pWin);
        int nx = pWin->drawable.x - bw;
        int ny = pWin->drawable.y - bw;

        if (pPixmap->screen_x != nx || pPixmap->screen_y != ny) {
            pPixmap->screen_x = nx;
            pPixmap->screen_y = ny;
            pPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        }
    }

    if (!(*pScreen->PositionWindow) (pWin, x, y))
        ret = FALSE;
    cs->PositionWindow = pScreen->PositionWindow;
    pScreen->PositionWindow = compPositionWindow;
    compCheckTree(pWin->drawable.pScreen);
    if (updateOverlayWindow(pScreen) != Success)
        ret = FALSE;
    return ret;
}

Bool
compRealizeWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret = TRUE;

    pScreen->RealizeWindow = cs->RealizeWindow;
    compCheckRedirect(pWin);
    if (!(*pScreen->RealizeWindow) (pWin))
        ret = FALSE;
    cs->RealizeWindow = pScreen->RealizeWindow;
    pScreen->RealizeWindow = compRealizeWindow;
    compCheckTree(pWin->drawable.pScreen);
    return ret;
}

Bool
compUnrealizeWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret = TRUE;

    pScreen->UnrealizeWindow = cs->UnrealizeWindow;
    compCheckRedirect(pWin);
    if (!(*pScreen->UnrealizeWindow) (pWin))
        ret = FALSE;
    cs->UnrealizeWindow = pScreen->UnrealizeWindow;
    pScreen->UnrealizeWindow = compUnrealizeWindow;
    compCheckTree(pWin->drawable.pScreen);
    return ret;
}

/*
 * Called after the borderClip for the window has settled down
 * We use this to make sure our extra borderClip has the right origin
 */

void
compClipNotify(WindowPtr pWin, int dx, int dy)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    CompWindowPtr cw = GetCompWindow(pWin);

    if (cw) {
        if (cw->borderClipX != pWin->drawable.x ||
            cw->borderClipY != pWin->drawable.y) {
            RegionTranslate(&cw->borderClip,
                            pWin->drawable.x - cw->borderClipX,
                            pWin->drawable.y - cw->borderClipY);
            cw->borderClipX = pWin->drawable.x;
            cw->borderClipY = pWin->drawable.y;
        }
    }
    if (cs->ClipNotify) {
        pScreen->ClipNotify = cs->ClipNotify;
        (*pScreen->ClipNotify) (pWin, dx, dy);
        cs->ClipNotify = pScreen->ClipNotify;
        pScreen->ClipNotify = compClipNotify;
    }
}

/*
 * Returns TRUE if the window needs server-provided automatic redirect,
 * which is true if the child and parent aren't both regular or ARGB visuals
 */

static Bool
compIsAlternateVisual(ScreenPtr pScreen, XID visual)
{
    CompScreenPtr cs = GetCompScreen(pScreen);
    int i;

    for (i = 0; i < cs->numAlternateVisuals; i++)
        if (cs->alternateVisuals[i] == visual)
            return TRUE;
    return FALSE;
}

static Bool
compIsImplicitRedirectException(ScreenPtr pScreen,
                                XID parentVisual, XID winVisual)
{
    CompScreenPtr cs = GetCompScreen(pScreen);
    int i;

    for (i = 0; i < cs->numImplicitRedirectExceptions; i++)
        if (cs->implicitRedirectExceptions[i].parentVisual == parentVisual &&
            cs->implicitRedirectExceptions[i].winVisual == winVisual)
            return TRUE;

    return FALSE;
}

static Bool
compImplicitRedirect(WindowPtr pWin, WindowPtr pParent)
{
    if (pParent) {
        ScreenPtr pScreen = pWin->drawable.pScreen;
        XID winVisual = wVisual(pWin);
        XID parentVisual = wVisual(pParent);

        if (compIsImplicitRedirectException(pScreen, parentVisual, winVisual))
            return FALSE;

        if (winVisual != parentVisual &&
            (compIsAlternateVisual(pScreen, winVisual) ||
             compIsAlternateVisual(pScreen, parentVisual)))
            return TRUE;
    }
    return FALSE;
}

static void
compFreeOldPixmap(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    if (pWin->redirectDraw != RedirectDrawNone) {
        CompWindowPtr cw = GetCompWindow(pWin);

        if (cw->pOldPixmap) {
            (*pScreen->DestroyPixmap) (cw->pOldPixmap);
            cw->pOldPixmap = NullPixmap;
        }
    }
}

void
compMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->MoveWindow = cs->MoveWindow;
    (*pScreen->MoveWindow) (pWin, x, y, pSib, kind);
    cs->MoveWindow = pScreen->MoveWindow;
    pScreen->MoveWindow = compMoveWindow;

    compFreeOldPixmap(pWin);
    compCheckTree(pScreen);
}

void
compResizeWindow(WindowPtr pWin, int x, int y,
                 unsigned int w, unsigned int h, WindowPtr pSib)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->ResizeWindow = cs->ResizeWindow;
    (*pScreen->ResizeWindow) (pWin, x, y, w, h, pSib);
    cs->ResizeWindow = pScreen->ResizeWindow;
    pScreen->ResizeWindow = compResizeWindow;

    compFreeOldPixmap(pWin);
    compCheckTree(pWin->drawable.pScreen);
}

void
compChangeBorderWidth(WindowPtr pWin, unsigned int bw)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->ChangeBorderWidth = cs->ChangeBorderWidth;
    (*pScreen->ChangeBorderWidth) (pWin, bw);
    cs->ChangeBorderWidth = pScreen->ChangeBorderWidth;
    pScreen->ChangeBorderWidth = compChangeBorderWidth;

    compFreeOldPixmap(pWin);
    compCheckTree(pWin->drawable.pScreen);
}

void
compReparentWindow(WindowPtr pWin, WindowPtr pPriorParent)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);

    pScreen->ReparentWindow = cs->ReparentWindow;
    /*
     * Remove any implicit redirect due to synthesized visual
     */
    if (compImplicitRedirect(pWin, pPriorParent))
        compUnredirectWindow(serverClient, pWin, CompositeRedirectAutomatic);
    /*
     * Handle subwindows redirection
     */
    compUnredirectOneSubwindow(pPriorParent, pWin);
    compRedirectOneSubwindow(pWin->parent, pWin);
    /*
     * Add any implict redirect due to synthesized visual
     */
    if (compImplicitRedirect(pWin, pWin->parent))
        compRedirectWindow(serverClient, pWin, CompositeRedirectAutomatic);

    /*
     * Allocate any necessary redirect pixmap
     * (this actually should never be true; pWin is always unmapped)
     */
    compCheckRedirect(pWin);

    /*
     * Reset pixmap pointers as appropriate
     */
    if (pWin->parent && pWin->redirectDraw == RedirectDrawNone)
        compSetPixmap(pWin, (*pScreen->GetWindowPixmap) (pWin->parent));
    /*
     * Call down to next function
     */
    if (pScreen->ReparentWindow)
        (*pScreen->ReparentWindow) (pWin, pPriorParent);
    cs->ReparentWindow = pScreen->ReparentWindow;
    pScreen->ReparentWindow = compReparentWindow;
    compCheckTree(pWin->drawable.pScreen);
}

void
compCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    int dx = 0, dy = 0;

    if (pWin->redirectDraw != RedirectDrawNone) {
        PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);
        CompWindowPtr cw = GetCompWindow(pWin);

        assert(cw->oldx != COMP_ORIGIN_INVALID);
        assert(cw->oldy != COMP_ORIGIN_INVALID);
        if (cw->pOldPixmap) {
            /*
             * Ok, the old bits are available in pOldPixmap and
             * need to be copied to pNewPixmap.
             */
            RegionRec rgnDst;
            GCPtr pGC;

            dx = ptOldOrg.x - pWin->drawable.x;
            dy = ptOldOrg.y - pWin->drawable.y;
            RegionTranslate(prgnSrc, -dx, -dy);

            RegionNull(&rgnDst);

            RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);

            RegionTranslate(&rgnDst, -pPixmap->screen_x, -pPixmap->screen_y);

            dx = dx + pPixmap->screen_x - cw->oldx;
            dy = dy + pPixmap->screen_y - cw->oldy;
            pGC = GetScratchGC(pPixmap->drawable.depth, pScreen);
            if (pGC) {
                BoxPtr pBox = RegionRects(&rgnDst);
                int nBox = RegionNumRects(&rgnDst);

                ValidateGC(&pPixmap->drawable, pGC);
                while (nBox--) {
                    (void) (*pGC->ops->CopyArea) (&cw->pOldPixmap->drawable,
                                                  &pPixmap->drawable,
                                                  pGC,
                                                  pBox->x1 + dx, pBox->y1 + dy,
                                                  pBox->x2 - pBox->x1,
                                                  pBox->y2 - pBox->y1,
                                                  pBox->x1, pBox->y1);
                    pBox++;
                }
                FreeScratchGC(pGC);
            }
            RegionUninit(&rgnDst);
            return;
        }
        dx = pPixmap->screen_x - cw->oldx;
        dy = pPixmap->screen_y - cw->oldy;
        ptOldOrg.x += dx;
        ptOldOrg.y += dy;
    }

    pScreen->CopyWindow = cs->CopyWindow;
    if (ptOldOrg.x != pWin->drawable.x || ptOldOrg.y != pWin->drawable.y) {
        if (dx || dy)
            RegionTranslate(prgnSrc, dx, dy);
        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
        if (dx || dy)
            RegionTranslate(prgnSrc, -dx, -dy);
    }
    else {
        ptOldOrg.x -= dx;
        ptOldOrg.y -= dy;
        RegionTranslate(prgnSrc,
                        pWin->drawable.x - ptOldOrg.x,
                        pWin->drawable.y - ptOldOrg.y);
        DamageDamageRegion(&pWin->drawable, prgnSrc);
    }
    cs->CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = compCopyWindow;
    compCheckTree(pWin->drawable.pScreen);
}

Bool
compCreateWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret;

    pScreen->CreateWindow = cs->CreateWindow;
    ret = (*pScreen->CreateWindow) (pWin);
    if (pWin->parent && ret) {
        CompSubwindowsPtr csw = GetCompSubwindows(pWin->parent);
        CompClientWindowPtr ccw;
        PixmapPtr parent_pixmap = (*pScreen->GetWindowPixmap)(pWin->parent);
        PixmapPtr window_pixmap = (*pScreen->GetWindowPixmap)(pWin);

        if (window_pixmap != parent_pixmap)
            (*pScreen->SetWindowPixmap) (pWin, parent_pixmap);
        if (csw)
            for (ccw = csw->clients; ccw; ccw = ccw->next)
                compRedirectWindow(clients[CLIENT_ID(ccw->id)],
                                   pWin, ccw->update);
        if (compImplicitRedirect(pWin, pWin->parent))
            compRedirectWindow(serverClient, pWin, CompositeRedirectAutomatic);
    }
    cs->CreateWindow = pScreen->CreateWindow;
    pScreen->CreateWindow = compCreateWindow;
    compCheckTree(pWin->drawable.pScreen);
    return ret;
}

Bool
compDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    CompWindowPtr cw;
    CompSubwindowsPtr csw;
    Bool ret;

    pScreen->DestroyWindow = cs->DestroyWindow;
    while ((cw = GetCompWindow(pWin)))
        FreeResource(cw->clients->id, RT_NONE);
    while ((csw = GetCompSubwindows(pWin)))
        FreeResource(csw->clients->id, RT_NONE);

    if (pWin->redirectDraw != RedirectDrawNone) {
        PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);

        compSetParentPixmap(pWin);
        (*pScreen->DestroyPixmap) (pPixmap);
    }
    ret = (*pScreen->DestroyWindow) (pWin);
    cs->DestroyWindow = pScreen->DestroyWindow;
    pScreen->DestroyWindow = compDestroyWindow;
/*    compCheckTree (pWin->drawable.pScreen); can't check -- tree isn't good*/
    return ret;
}

void
compSetRedirectBorderClip(WindowPtr pWin, RegionPtr pRegion)
{
    CompWindowPtr cw = GetCompWindow(pWin);
    RegionRec damage;

    RegionNull(&damage);
    /*
     * Align old border clip with new border clip
     */
    RegionTranslate(&cw->borderClip,
                    pWin->drawable.x - cw->borderClipX,
                    pWin->drawable.y - cw->borderClipY);
    /*
     * Compute newly visible portion of window for repaint
     */
    RegionSubtract(&damage, pRegion, &cw->borderClip);
    /*
     * Report that as damaged so it will be redrawn
     */
    DamageDamageRegion(&pWin->drawable, &damage);
    RegionUninit(&damage);
    /*
     * Save the new border clip region
     */
    RegionCopy(&cw->borderClip, pRegion);
    cw->borderClipX = pWin->drawable.x;
    cw->borderClipY = pWin->drawable.y;
}

RegionPtr
compGetRedirectBorderClip(WindowPtr pWin)
{
    CompWindowPtr cw = GetCompWindow(pWin);

    return &cw->borderClip;
}

static void
compWindowUpdateAutomatic(WindowPtr pWin)
{
    CompWindowPtr cw = GetCompWindow(pWin);
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr pParent = pWin->parent;
    PixmapPtr pSrcPixmap = (*pScreen->GetWindowPixmap) (pWin);
    PictFormatPtr pSrcFormat = PictureWindowFormat(pWin);
    PictFormatPtr pDstFormat = PictureWindowFormat(pWin->parent);
    int error;
    RegionPtr pRegion = DamageRegion(cw->damage);
    PicturePtr pSrcPicture = CreatePicture(0, &pSrcPixmap->drawable,
                                           pSrcFormat,
                                           0, 0,
                                           serverClient,
                                           &error);
    XID subwindowMode = IncludeInferiors;
    PicturePtr pDstPicture = CreatePicture(0, &pParent->drawable,
                                           pDstFormat,
                                           CPSubwindowMode,
                                           &subwindowMode,
                                           serverClient,
                                           &error);

    /*
     * First move the region from window to screen coordinates
     */
    RegionTranslate(pRegion, pWin->drawable.x, pWin->drawable.y);

    /*
     * Clip against the "real" border clip
     */
    RegionIntersect(pRegion, pRegion, &cw->borderClip);

    /*
     * Now translate from screen to dest coordinates
     */
    RegionTranslate(pRegion, -pParent->drawable.x, -pParent->drawable.y);

    /*
     * Clip the picture
     */
    SetPictureClipRegion(pDstPicture, 0, 0, pRegion);

    /*
     * And paint
     */
    CompositePicture(PictOpSrc, pSrcPicture, 0, pDstPicture,
                     0, 0,      /* src_x, src_y */
                     0, 0,      /* msk_x, msk_y */
                     pSrcPixmap->screen_x - pParent->drawable.x,
                     pSrcPixmap->screen_y - pParent->drawable.y,
                     pSrcPixmap->drawable.width, pSrcPixmap->drawable.height);
    FreePicture(pSrcPicture, 0);
    FreePicture(pDstPicture, 0);
    /*
     * Empty the damage region.  This has the nice effect of
     * rendering the translations above harmless
     */
    DamageEmpty(cw->damage);
}

static void
compPaintWindowToParent(WindowPtr pWin)
{
    compPaintChildrenToWindow(pWin);

    if (pWin->redirectDraw != RedirectDrawNone) {
        CompWindowPtr cw = GetCompWindow(pWin);

        if (cw->damaged) {
            compWindowUpdateAutomatic(pWin);
            cw->damaged = FALSE;
        }
    }
}

void
compPaintChildrenToWindow(WindowPtr pWin)
{
    WindowPtr pChild;

    if (!pWin->damagedDescendants)
        return;

    for (pChild = pWin->lastChild; pChild; pChild = pChild->prevSib)
        compPaintWindowToParent(pChild);

    pWin->damagedDescendants = FALSE;
}

WindowPtr
CompositeRealChildHead(WindowPtr pWin)
{
    WindowPtr pChild, pChildBefore;
    CompScreenPtr cs;

    if (!pWin->parent &&
        (screenIsSaved == SCREEN_SAVER_ON) &&
        (HasSaverWindow(pWin->drawable.pScreen))) {

        /* First child is the screen saver; see if next child is the overlay */
        pChildBefore = pWin->firstChild;
        pChild = pChildBefore->nextSib;

    }
    else {
        pChildBefore = NullWindow;
        pChild = pWin->firstChild;
    }

    if (!pChild) {
        return NullWindow;
    }

    cs = GetCompScreen(pWin->drawable.pScreen);
    if (pChild == cs->pOverlayWin) {
        return pChild;
    }
    else {
        return pChildBefore;
    }
}

int
compConfigNotify(WindowPtr pWin, int x, int y, int w, int h,
                 int bw, WindowPtr pSib)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    CompScreenPtr cs = GetCompScreen(pScreen);
    Bool ret = 0;
    WindowPtr pParent = pWin->parent;
    int draw_x, draw_y;
    Bool alloc_ret;

    if (cs->ConfigNotify) {
        pScreen->ConfigNotify = cs->ConfigNotify;
        ret = (*pScreen->ConfigNotify) (pWin, x, y, w, h, bw, pSib);
        cs->ConfigNotify = pScreen->ConfigNotify;
        pScreen->ConfigNotify = compConfigNotify;

        if (ret)
            return ret;
    }

    if (pWin->redirectDraw == RedirectDrawNone)
        return Success;

    compCheckTree(pScreen);

    draw_x = pParent->drawable.x + x + bw;
    draw_y = pParent->drawable.y + y + bw;
    alloc_ret = compReallocPixmap(pWin, draw_x, draw_y, w, h, bw);

    if (alloc_ret == FALSE)
        return BadAlloc;
    return Success;
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d107 1
a107 1
        miPaintWindow(pWindow, &exposed, PW_BORDER);
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d570 2
d573 2
a574 3
        (*pScreen->SetWindowPixmap) (pWin,
                                     (*pScreen->GetWindowPixmap) (pWin->
                                                                  parent));
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d56 1
a56 1
compCheckWindow(WindowPtr pWin, pointer data)
d95 1
a95 1
compRepaintBorder(ClientPtr pClient, pointer closure)
d114 1
a114 1
compSetPixmapVisitWindow(WindowPtr pWindow, pointer data)
d131 1
a131 1
                      (pointer) (intptr_t) pWindow->drawable.id);
d142 1
a142 1
    TraverseTree(pWindow, compSetPixmapVisitWindow, (pointer) &visitRec);
d339 15
d361 3
a495 1
            PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);
d528 1
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d211 2
a212 1
    /* Let's be on the safe side and not assume an overlay window is always allocated. */
a634 22
static VisualPtr
compGetWindowVisual(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    VisualID vid = wVisual(pWin);
    int i;

    for (i = 0; i < pScreen->numVisuals; i++)
        if (pScreen->visuals[i].vid == vid)
            return &pScreen->visuals[i];
    return 0;
}

PictFormatPtr
compWindowFormat(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    return PictureMatchVisual(pScreen, pWin->drawable.depth,
                              compGetWindowVisual(pWin));
}

d642 2
a643 2
    PictFormatPtr pSrcFormat = compWindowFormat(pWin);
    PictFormatPtr pDstFormat = compWindowFormat(pWin->parent);
d682 2
a683 1
    CompositePicture(PictOpSrc, pSrcPicture, 0, pDstPicture, 0, 0,      /* src_x, src_y */
@


1.8
log
@Update to xserver 1.11.2
@
text
@d56 1
a56 1
compCheckWindow (WindowPtr pWin, pointer data)
d58 13
a70 18
    ScreenPtr	pScreen = pWin->drawable.pScreen;
    PixmapPtr	pWinPixmap = (*pScreen->GetWindowPixmap) (pWin);
    PixmapPtr	pParentPixmap = pWin->parent ? (*pScreen->GetWindowPixmap) (pWin->parent) : 0;
    PixmapPtr	pScreenPixmap = (*pScreen->GetScreenPixmap) (pScreen);

    if (!pWin->parent)
    {
	assert (pWin->redirectDraw == RedirectDrawNone);
	assert (pWinPixmap == pScreenPixmap);
    }
    else if (pWin->redirectDraw != RedirectDrawNone)
    {
	assert (pWinPixmap != pParentPixmap);
	assert (pWinPixmap != pScreenPixmap);
    }
    else
    {
	assert (pWinPixmap == pParentPixmap);
d72 5
a76 2
    assert (0 < pWinPixmap->refcnt && pWinPixmap->refcnt < 3);
    assert (0 < pScreenPixmap->refcnt && pScreenPixmap->refcnt < 3);
d78 1
a78 1
	assert (0 <= pParentPixmap->refcnt && pParentPixmap->refcnt < 3);
d83 1
a83 1
compCheckTree (ScreenPtr pScreen)
d85 1
a85 1
    WalkTree (pScreen, compCheckWindow, 0);
d90 2
a91 2
    WindowPtr	pWindow;
    PixmapPtr	pPixmap;
d95 1
a95 1
compRepaintBorder (ClientPtr pClient, pointer closure)
d98 3
a100 1
    int rc = dixLookupWindow(&pWindow, (XID)(intptr_t)closure, pClient, DixWriteAccess);
d103 1
a103 1
	RegionRec exposed;
d105 4
a108 4
	RegionNull(&exposed);
	RegionSubtract(&exposed, &pWindow->borderClip, &pWindow->winSize);
	miPaintWindow(pWindow, &exposed, PW_BORDER);
	RegionUninit(&exposed);
d114 1
a114 1
compSetPixmapVisitWindow (WindowPtr pWindow, pointer data)
d116 2
a117 2
    CompPixmapVisitPtr	pVisit = (CompPixmapVisitPtr) data;
    ScreenPtr		pScreen = pWindow->drawable.pScreen;
d120 1
a120 1
	return WT_DONTWALKCHILDREN;
d127 5
a131 5
    SetWinSize (pWindow);
    SetBorderSize (pWindow);
    if (HasBorder (pWindow))
	QueueWorkProc (compRepaintBorder, serverClient,
		       (pointer)(intptr_t) pWindow->drawable.id);
d136 1
a136 1
compSetPixmap (WindowPtr pWindow, PixmapPtr pPixmap)
d138 1
a138 1
    CompPixmapVisitRec	visitRec;
d142 2
a143 2
    TraverseTree (pWindow, compSetPixmapVisitWindow, (pointer) &visitRec);
    compCheckTree (pWindow->drawable.pScreen);
d147 1
a147 1
compCheckRedirect (WindowPtr pWin)
d149 3
a151 3
    CompWindowPtr   cw = GetCompWindow (pWin);
    CompScreenPtr   cs = GetCompScreen(pWin->drawable.pScreen);
    Bool	    should;
d154 1
a154 1
	     (cw != NULL) && (pWin->parent != NULL);
d158 22
a179 21
	if (pWin == cs->pOverlayWin) {
	    should = FALSE;
	}
    }

    if (should != (pWin->redirectDraw != RedirectDrawNone))
    {
	if (should)
	    return compAllocPixmap (pWin);
	else {
	    ScreenPtr pScreen = pWin->drawable.pScreen;
	    PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	    compSetParentPixmap (pWin);
	    compRestoreWindow (pWin, pPixmap);
	    (*pScreen->DestroyPixmap) (pPixmap);
	}
    } else if (should) {
	if (cw->update == CompositeRedirectAutomatic)
	    pWin->redirectDraw = RedirectDrawAutomatic;
	else
	    pWin->redirectDraw = RedirectDrawManual;
d187 5
a191 5
	CompScreenPtr cs;
	WindowPtr pWin; /* overlay window */
	XID vlist[2];
	int w = pScreen->width;
	int h = pScreen->height;
d194 4
a197 5
	if (!noPanoramiXExtension)
	{
	    w = PanoramiXPixWidth;
	    h = PanoramiXPixHeight;
	}
d200 10
a209 11
	cs = GetCompScreen(pScreen);
	if ((pWin = cs->pOverlayWin) != NULL) {
		if ((pWin->drawable.width == w) &&
			(pWin->drawable.height == h))
			return Success;

		/* Let's resize the overlay window. */
		vlist[0] = w;
		vlist[1] = h;
		return ConfigureWindow(pWin, CWWidth | CWHeight, vlist, wClient(pWin));
	}
d211 2
a212 2
	/* Let's be on the safe side and not assume an overlay window is always allocated. */
	return Success;
d216 1
a216 1
compPositionWindow (WindowPtr pWin, int x, int y)
d218 3
a220 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    CompScreenPtr   cs = GetCompScreen (pScreen);
    Bool	    ret = TRUE;
d226 1
a226 1
    compCheckRedirect (pWin);
d230 2
a231 2
	(pWin->viewable && (GetCompWindow(pWin) != NULL)))
	OsAbort ();
d233 11
a243 13
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	PixmapPtr   pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	int	    bw = wBorderWidth (pWin);
	int	    nx = pWin->drawable.x - bw;
	int	    ny = pWin->drawable.y - bw;

	if (pPixmap->screen_x != nx || pPixmap->screen_y != ny)
	{
	    pPixmap->screen_x = nx;
	    pPixmap->screen_y = ny;
	    pPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	}
d247 1
a247 1
	ret = FALSE;
d250 1
a250 1
    compCheckTree (pWin->drawable.pScreen);
d252 1
a252 1
	ret = FALSE;
d257 1
a257 1
compRealizeWindow (WindowPtr pWin)
d259 3
a261 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    CompScreenPtr   cs = GetCompScreen (pScreen);
    Bool	    ret = TRUE;
d264 1
a264 1
    compCheckRedirect (pWin);
d266 1
a266 1
	ret = FALSE;
d269 1
a269 1
    compCheckTree (pWin->drawable.pScreen);
d274 1
a274 1
compUnrealizeWindow (WindowPtr pWin)
d276 3
a278 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    CompScreenPtr   cs = GetCompScreen (pScreen);
    Bool	    ret = TRUE;
d281 1
a281 1
    compCheckRedirect (pWin);
d283 1
a283 1
	ret = FALSE;
d286 1
a286 1
    compCheckTree (pWin->drawable.pScreen);
d296 1
a296 1
compClipNotify (WindowPtr pWin, int dx, int dy)
d298 19
a316 22
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
    CompWindowPtr	cw = GetCompWindow (pWin);

    if (cw)
    {
	if (cw->borderClipX != pWin->drawable.x ||
	    cw->borderClipY != pWin->drawable.y)
	{
	    RegionTranslate(&cw->borderClip,
			      pWin->drawable.x - cw->borderClipX,
			      pWin->drawable.y - cw->borderClipY);
	    cw->borderClipX = pWin->drawable.x;
	    cw->borderClipY = pWin->drawable.y;
	}
    }
    if (cs->ClipNotify)
    {
	pScreen->ClipNotify = cs->ClipNotify;
	(*pScreen->ClipNotify) (pWin, dx, dy);
	cs->ClipNotify = pScreen->ClipNotify;
	pScreen->ClipNotify = compClipNotify;
d326 1
a326 2
compIsAlternateVisual (ScreenPtr    pScreen,
		       XID	    visual)
d328 2
a329 2
    CompScreenPtr	cs = GetCompScreen (pScreen);
    int			i;
d332 2
a333 2
	if (cs->alternateVisuals[i] == visual)
	    return TRUE;
d338 1
a338 1
compImplicitRedirect (WindowPtr pWin, WindowPtr pParent)
d340 9
a348 10
    if (pParent)
    {
	ScreenPtr	pScreen = pWin->drawable.pScreen;
	XID		winVisual = wVisual (pWin);
	XID		parentVisual = wVisual (pParent);

	if (winVisual != parentVisual &&
	    (compIsAlternateVisual (pScreen, winVisual) ||
	     compIsAlternateVisual (pScreen, parentVisual)))
	    return TRUE;
d353 2
a354 1
static void compFreeOldPixmap(WindowPtr pWin)
d356 9
a364 9
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	CompWindowPtr	cw = GetCompWindow (pWin);
	if (cw->pOldPixmap)
	{
	    (*pScreen->DestroyPixmap) (cw->pOldPixmap);
	    cw->pOldPixmap = NullPixmap;
	}
d367 1
d369 1
a369 1
compMoveWindow (WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
d371 2
a372 2
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
d380 1
a380 1
    compCheckTree (pScreen);
d384 2
a385 2
compResizeWindow (WindowPtr pWin, int x, int y,
		  unsigned int w, unsigned int h, WindowPtr pSib)
d387 2
a388 2
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
d396 1
a396 1
    compCheckTree (pWin->drawable.pScreen);
d400 1
a400 1
compChangeBorderWidth (WindowPtr pWin, unsigned int bw)
d402 2
a403 2
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
d411 1
a411 1
    compCheckTree (pWin->drawable.pScreen);
d415 1
a415 1
compReparentWindow (WindowPtr pWin, WindowPtr pPriorParent)
d417 2
a418 2
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
d424 2
a425 2
    if (compImplicitRedirect (pWin, pPriorParent))
	compUnredirectWindow (serverClient, pWin, CompositeRedirectAutomatic);
d429 2
a430 2
    compUnredirectOneSubwindow (pPriorParent, pWin);
    compRedirectOneSubwindow (pWin->parent, pWin);
d434 2
a435 2
    if (compImplicitRedirect (pWin, pWin->parent))
	compRedirectWindow (serverClient, pWin, CompositeRedirectAutomatic);
d441 1
a441 1
    compCheckRedirect (pWin);
d447 1
a447 1
	compSetPixmap (pWin, (*pScreen->GetWindowPixmap) (pWin->parent));
d452 1
a452 1
	(*pScreen->ReparentWindow) (pWin, pPriorParent);
d455 1
a455 1
    compCheckTree (pWin->drawable.pScreen);
d459 1
a459 1
compCopyWindow (WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
d461 55
a515 61
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    CompScreenPtr   cs = GetCompScreen (pScreen);
    int		    dx = 0, dy = 0;

    if (pWin->redirectDraw != RedirectDrawNone)
    {
	PixmapPtr	pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	CompWindowPtr	cw = GetCompWindow (pWin);

	assert (cw->oldx != COMP_ORIGIN_INVALID);
	assert (cw->oldy != COMP_ORIGIN_INVALID);
	if (cw->pOldPixmap)
	{
	    /*
	     * Ok, the old bits are available in pOldPixmap and
	     * need to be copied to pNewPixmap.
	     */
	    RegionRec	rgnDst;
	    PixmapPtr	pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	    GCPtr	pGC;

	    dx = ptOldOrg.x - pWin->drawable.x;
	    dy = ptOldOrg.y - pWin->drawable.y;
	    RegionTranslate(prgnSrc, -dx, -dy);

	    RegionNull(&rgnDst);

	    RegionIntersect(&rgnDst,
			     &pWin->borderClip, prgnSrc);

	    RegionTranslate(&rgnDst,
			      -pPixmap->screen_x, -pPixmap->screen_y);

	    dx = dx + pPixmap->screen_x - cw->oldx;
	    dy = dy + pPixmap->screen_y - cw->oldy;
	    pGC = GetScratchGC (pPixmap->drawable.depth, pScreen);
	    if (pGC)
	    {
		BoxPtr	pBox = RegionRects (&rgnDst);
		int	nBox = RegionNumRects (&rgnDst);

		ValidateGC(&pPixmap->drawable, pGC);
		while (nBox--)
		{
		    (void) (*pGC->ops->CopyArea) (&cw->pOldPixmap->drawable,
						  &pPixmap->drawable,
						  pGC,
						  pBox->x1 + dx, pBox->y1 + dy,
						  pBox->x2 - pBox->x1,
						  pBox->y2 - pBox->y1,
						  pBox->x1, pBox->y1);
		    pBox++;
		}
		FreeScratchGC (pGC);
	    }
	    return;
	}
	dx = pPixmap->screen_x - cw->oldx;
	dy = pPixmap->screen_y - cw->oldy;
	ptOldOrg.x += dx;
	ptOldOrg.y += dy;
d519 14
a532 16
    if (ptOldOrg.x != pWin->drawable.x || ptOldOrg.y != pWin->drawable.y)
    {
	if (dx || dy)
	    RegionTranslate(prgnSrc, dx, dy);
	(*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
	if (dx || dy)
	    RegionTranslate(prgnSrc, -dx, -dy);
    }
    else
    {
	ptOldOrg.x -= dx;
	ptOldOrg.y -= dy;
	RegionTranslate(prgnSrc,
			  pWin->drawable.x - ptOldOrg.x,
			  pWin->drawable.y - ptOldOrg.y);
	DamageDamageRegion(&pWin->drawable, prgnSrc);
d536 1
a536 1
    compCheckTree (pWin->drawable.pScreen);
d540 1
a540 1
compCreateWindow (WindowPtr pWin)
d542 3
a544 3
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
    Bool		ret;
d548 13
a560 12
    if (pWin->parent && ret)
    {
	CompSubwindowsPtr	csw = GetCompSubwindows (pWin->parent);
        CompClientWindowPtr	ccw;

	(*pScreen->SetWindowPixmap) (pWin, (*pScreen->GetWindowPixmap) (pWin->parent));
	if (csw)
	    for (ccw = csw->clients; ccw; ccw = ccw->next)
		compRedirectWindow (clients[CLIENT_ID(ccw->id)],
				    pWin, ccw->update);
	if (compImplicitRedirect (pWin, pWin->parent))
	    compRedirectWindow (serverClient, pWin, CompositeRedirectAutomatic);
d564 1
a564 1
    compCheckTree (pWin->drawable.pScreen);
d569 1
a569 1
compDestroyWindow (WindowPtr pWin)
d571 5
a575 5
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
    CompWindowPtr	cw;
    CompSubwindowsPtr	csw;
    Bool		ret;
d578 4
a581 4
    while ((cw = GetCompWindow (pWin)))
	FreeResource (cw->clients->id, RT_NONE);
    while ((csw = GetCompSubwindows (pWin)))
	FreeResource (csw->clients->id, RT_NONE);
d584 4
a587 3
	PixmapPtr pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	compSetParentPixmap (pWin);
	(*pScreen->DestroyPixmap) (pPixmap);
d597 1
a597 1
compSetRedirectBorderClip (WindowPtr pWin, RegionPtr pRegion)
d599 2
a600 2
    CompWindowPtr   cw = GetCompWindow (pWin);
    RegionRec	    damage;
d607 2
a608 2
		      pWin->drawable.x - cw->borderClipX,
		      pWin->drawable.y - cw->borderClipY);
d627 1
a627 1
compGetRedirectBorderClip (WindowPtr pWin)
d629 1
a629 1
    CompWindowPtr   cw = GetCompWindow (pWin);
d635 1
a635 1
compGetWindowVisual (WindowPtr pWin)
d637 3
a639 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    VisualID	    vid = wVisual (pWin);
    int		    i;
d642 2
a643 2
	if (pScreen->visuals[i].vid == vid)
	    return &pScreen->visuals[i];
d648 1
a648 1
compWindowFormat (WindowPtr pWin)
d650 1
a650 1
    ScreenPtr	pScreen = pWin->drawable.pScreen;
d652 2
a653 2
    return PictureMatchVisual (pScreen, pWin->drawable.depth,
			       compGetWindowVisual (pWin));
d657 1
a657 1
compWindowUpdateAutomatic (WindowPtr pWin)
d659 20
a678 20
    CompWindowPtr   cw = GetCompWindow (pWin);
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    WindowPtr	    pParent = pWin->parent;
    PixmapPtr	    pSrcPixmap = (*pScreen->GetWindowPixmap) (pWin);
    PictFormatPtr   pSrcFormat = compWindowFormat (pWin);
    PictFormatPtr   pDstFormat = compWindowFormat (pWin->parent);
    int		    error;
    RegionPtr	    pRegion = DamageRegion (cw->damage);
    PicturePtr	    pSrcPicture = CreatePicture (0, &pSrcPixmap->drawable,
						 pSrcFormat,
						 0, 0,
						 serverClient,
						 &error);
    XID		    subwindowMode = IncludeInferiors;
    PicturePtr	    pDstPicture = CreatePicture (0, &pParent->drawable,
						 pDstFormat,
						 CPSubwindowMode,
						 &subwindowMode,
						 serverClient,
						 &error);
d683 1
a683 2
    RegionTranslate(pRegion,
		      pWin->drawable.x, pWin->drawable.y);
d693 1
a693 2
    RegionTranslate(pRegion,
		      -pParent->drawable.x, -pParent->drawable.y);
d698 1
a698 1
    SetPictureClipRegion (pDstPicture, 0, 0, pRegion);
d703 7
a709 12
    CompositePicture (PictOpSrc,
		      pSrcPicture,
		      0,
		      pDstPicture,
		      0, 0, /* src_x, src_y */
		      0, 0, /* msk_x, msk_y */
		      pSrcPixmap->screen_x - pParent->drawable.x,
		      pSrcPixmap->screen_y - pParent->drawable.y,
		      pSrcPixmap->drawable.width,
		      pSrcPixmap->drawable.height);
    FreePicture (pSrcPicture, 0);
    FreePicture (pDstPicture, 0);
d714 1
a714 1
    DamageEmpty (cw->damage);
d718 1
a718 1
compPaintWindowToParent (WindowPtr pWin)
d720 1
a720 1
    compPaintChildrenToWindow (pWin);
d722 7
a728 9
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	CompWindowPtr	cw = GetCompWindow(pWin);

	if (cw->damaged)
	{
	    compWindowUpdateAutomatic (pWin);
	    cw->damaged = FALSE;
	}
d733 1
a733 1
compPaintChildrenToWindow (WindowPtr pWin)
d738 1
a738 1
	return;
d741 1
a741 1
	compPaintWindowToParent (pChild);
d747 1
a747 1
CompositeRealChildHead (WindowPtr pWin)
d753 6
a758 2
	(screenIsSaved == SCREEN_SAVER_ON) &&
	(HasSaverWindow (pWin->drawable.pScreen))) {
d760 4
a763 7
	/* First child is the screen saver; see if next child is the overlay */
	pChildBefore = pWin->firstChild;
	pChild = pChildBefore->nextSib;

    } else {
	pChildBefore = NullWindow;
	pChild = pWin->firstChild;
d767 1
a767 1
	return NullWindow;
d772 4
a775 3
	return pChild;
    } else {
	return pChildBefore;
d781 1
a781 1
		 int bw, WindowPtr pSib)
d783 5
a787 5
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompScreenPtr	cs = GetCompScreen (pScreen);
    Bool                ret = 0;
    WindowPtr		pParent = pWin->parent;
    int			draw_x, draw_y;
d790 5
a794 6
    if (cs->ConfigNotify)
    {
	pScreen->ConfigNotify = cs->ConfigNotify;
	ret = (*pScreen->ConfigNotify)(pWin, x, y, w, h, bw, pSib);
	cs->ConfigNotify = pScreen->ConfigNotify;
	pScreen->ConfigNotify = compConfigNotify;
d796 2
a797 2
	if (ret)
	    return ret;
d801 1
a801 1
	return Success;
d803 1
a803 1
    compCheckTree (pScreen);
d807 1
a807 1
    alloc_ret = compReallocPixmap (pWin, draw_x, draw_y, w, h, bw);
d810 1
a810 1
	return BadAlloc;
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
d50 4
d167 10
d178 1
a178 1
	    compFreePixmap (pWin);
d189 10
d202 2
a203 2
		if ((pWin->drawable.width == pScreen->width) &&
			(pWin->drawable.height == pScreen->height))
d207 2
a208 2
		vlist[0] = pScreen->width;
		vlist[1] = pScreen->height;
d596 5
a600 2
    if (pWin->redirectDraw != RedirectDrawNone)
	compFreePixmap (pWin);
d736 2
a737 2
void
compWindowUpdate (WindowPtr pWin)
d739 1
a739 1
    WindowPtr	pChild;
a740 2
    for (pChild = pWin->lastChild; pChild; pChild = pChild->prevSib)
	compWindowUpdate (pChild);
d751 14
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d522 1
a522 1
	DamageRegionAppend(&pWin->drawable, prgnSrc);
d601 1
a601 1
    DamageRegionAppend(&pWin->drawable, &damage);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d101 2
a102 2
	REGION_NULL(pScreen, &exposed);
	REGION_SUBTRACT(pScreen, &exposed, &pWindow->borderClip, &pWindow->winSize);
d104 1
a104 1
	REGION_UNINIT(pScreen, &exposed);
d286 1
a286 1
	    REGION_TRANSLATE (pScreen, &cw->borderClip,
d337 1
a337 2
void
compMoveWindow (WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
a339 27
    CompScreenPtr	cs = GetCompScreen (pScreen);

    compCheckTree (pScreen);
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	WindowPtr		pParent;
	int			draw_x, draw_y;
	unsigned int		w, h, bw;

	/* if this is a root window, can't be moved */
	if (!(pParent = pWin->parent))
	   return;

	bw = wBorderWidth (pWin);
	draw_x = pParent->drawable.x + x + (int)bw;
	draw_y = pParent->drawable.y + y + (int)bw;
	w = pWin->drawable.width;
	h = pWin->drawable.height;
	compReallocPixmap (pWin, draw_x, draw_y, w, h, bw);
    }
    compCheckTree (pScreen);

    pScreen->MoveWindow = cs->MoveWindow;
    (*pScreen->MoveWindow) (pWin, x, y, pSib, kind);
    cs->MoveWindow = pScreen->MoveWindow;
    pScreen->MoveWindow = compMoveWindow;

d349 6
d356 6
a371 18
    compCheckTree (pScreen);
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	WindowPtr		pParent;
	int			draw_x, draw_y;
	unsigned int		bw;

	/* if this is a root window, can't be moved */
	if (!(pParent = pWin->parent))
	   return;

	bw = wBorderWidth (pWin);
	draw_x = pParent->drawable.x + x + (int)bw;
	draw_y = pParent->drawable.y + y + (int)bw;
	compReallocPixmap (pWin, draw_x, draw_y, w, h, bw);
    }
    compCheckTree (pScreen);

d376 2
a377 9
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	CompWindowPtr	cw = GetCompWindow (pWin);
	if (cw->pOldPixmap)
	{
	    (*pScreen->DestroyPixmap) (cw->pOldPixmap);
	    cw->pOldPixmap = NullPixmap;
	}
    }
a386 19
    compCheckTree (pScreen);
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	WindowPtr		pParent;
	int			draw_x, draw_y;
	unsigned int		w, h;

	/* if this is a root window, can't be moved */
	if (!(pParent = pWin->parent))
	   return;

	draw_x = pWin->drawable.x;
	draw_y = pWin->drawable.y;
	w = pWin->drawable.width;
	h = pWin->drawable.height;
	compReallocPixmap (pWin, draw_x, draw_y, w, h, bw);
    }
    compCheckTree (pScreen);

d391 2
a392 9
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	CompWindowPtr	cw = GetCompWindow (pWin);
	if (cw->pOldPixmap)
	{
	    (*pScreen->DestroyPixmap) (cw->pOldPixmap);
	    cw->pOldPixmap = NullPixmap;
	}
    }
d466 1
a466 1
	    REGION_TRANSLATE(pWin->drawable.pScreen, prgnSrc, -dx, -dy);
d468 1
a468 1
	    REGION_NULL (pWin->drawable.pScreen, &rgnDst);
d470 1
a470 1
	    REGION_INTERSECT(pWin->drawable.pScreen, &rgnDst,
d473 1
a473 1
	    REGION_TRANSLATE (pWin->drawable.pScreen, &rgnDst,
d481 2
a482 2
		BoxPtr	pBox = REGION_RECTS (&rgnDst);
		int	nBox = REGION_NUM_RECTS (&rgnDst);
d510 1
a510 1
	    REGION_TRANSLATE (pScreen, prgnSrc, dx, dy);
d513 1
a513 1
	    REGION_TRANSLATE (pScreen, prgnSrc, -dx, -dy);
d519 1
a519 1
	REGION_TRANSLATE (prgnSrc, prgnSrc,
d587 1
a587 1
    REGION_NULL (pScreen, &damage);
d591 1
a591 1
    REGION_TRANSLATE (pScreen, &cw->borderClip,
d597 1
a597 1
    REGION_SUBTRACT (pScreen, &damage, pRegion, &cw->borderClip);
d602 1
a602 1
    REGION_UNINIT (pScreen, &damage);
d606 1
a606 1
    REGION_COPY (pScreen, &cw->borderClip, pRegion);
d668 1
a668 1
    REGION_TRANSLATE (pScreen, pRegion,
d674 1
a674 1
    REGION_INTERSECT (pScreen, pRegion, pRegion, &cw->borderClip);
d679 1
a679 1
    REGION_TRANSLATE (pScreen, pRegion,
d736 1
a736 1
	(HasSaverWindow (pWin->drawable.pScreen->myNum))) {
d757 36
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems
d4 10
a13 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Sun Microsystems not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Sun Microsystems makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d15 7
a21 7
 * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d96 1
a96 1
    int rc = dixLookupWindow(&pWindow, (XID)closure, pClient, DixWriteAccess);
d127 1
a127 1
		       (pointer) pWindow->drawable.id);
d208 1
a208 1
	abort ();
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d57 1
a57 1
    
d125 1
a125 1
	QueueWorkProc (compRepaintBorder, serverClient, 
d156 2
a157 2
    }	
    
d279 1
a279 1
    
d282 1
a282 1
	if (cw->borderClipX != pWin->drawable.x || 
d327 1
a327 1
    
d348 1
a348 1
	
d352 1
a352 1
	
d393 1
a393 1
	
d397 1
a397 1
	
d404 1
a404 1
    
d433 1
a433 1
	
d437 1
a437 1
	
d484 1
a484 1
    
d490 1
a490 1
    
d517 1
a517 1
	
d529 1
a529 1
	    
d538 2
a539 2
	    
	    REGION_TRANSLATE (pWin->drawable.pScreen, &rgnDst, 
d541 1
a541 1
	    
d549 1
a549 1
		
d571 1
a571 1
    
d588 1
a588 1
	DamageDamageRegion (&pWin->drawable, prgnSrc);
d637 1
a637 1
    
d667 1
a667 1
    DamageDamageRegion (&pWin->drawable, &damage);
d702 1
a702 1
    
d719 1
a719 1
						 pSrcFormat, 
d726 1
a726 1
						 CPSubwindowMode, 
d730 1
a730 1
    
d734 1
a734 1
    REGION_TRANSLATE (pScreen, pRegion, 
d736 1
a736 1
    
d745 1
a745 1
    REGION_TRANSLATE (pScreen, pRegion, 
d747 1
a747 1
    
d752 1
a752 1
    
d816 1
a816 1
    
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d95 1
a95 1
    int rc = dixLookupWindow(&pWindow, (XID)closure, pClient,DixUnknownAccess);
d102 1
a102 1
	(*pWindow->drawable.pScreen->PaintWindowBorder)(pWindow, &exposed, PW_BORDER);
a265 15
}

void
compPaintWindowBackground (WindowPtr pWin, RegionPtr pRegion, int what)
{
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    CompSubwindowsPtr	csw = GetCompSubwindows (pWin);
    CompScreenPtr	cs = GetCompScreen (pScreen);
    
    if (csw && csw->update == CompositeRedirectManual)
	return;
    pScreen->PaintWindowBackground = cs->PaintWindowBackground;
    (*pScreen->PaintWindowBackground) (pWin, pRegion, what);
    cs->PaintWindowBackground = pScreen->PaintWindowBackground;
    pScreen->PaintWindowBackground = compPaintWindowBackground;
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d60 1
a60 1
	assert (!pWin->redirectDraw);
d63 1
a63 1
    else if (pWin->redirectDraw)
d94 2
a95 1
    WindowPtr	pWindow = LookupWindow ((XID) closure, pClient);
d97 1
a97 2
    if (pWindow)
    {
d114 1
a114 1
    if (pWindow != pVisit->pWindow && pWindow->redirectDraw)
d149 2
a150 2
	     (cw != NULL);
    
d158 1
a158 1
    if (should != pWin->redirectDraw)
d168 23
d205 2
a206 1
    if (pWin->redirectDraw != (pWin->viewable && (GetCompWindow(pWin) != NULL)))
d209 1
a209 1
    if (pWin->redirectDraw)
d229 2
d358 1
a358 1
    if (pWin->redirectDraw)
d382 1
a382 1
    if (pWin->redirectDraw)
d403 1
a403 1
    if (pWin->redirectDraw)
d424 1
a424 1
    if (pWin->redirectDraw)
d443 1
a443 1
    if (pWin->redirectDraw)
d465 1
a465 1
    if (pWin->redirectDraw)
d509 1
a509 1
    if (pWin->parent && !pWin->redirectDraw)
d528 1
a528 1
    if (pWin->redirectDraw)
d653 1
a653 1
    if (pWin->redirectDraw)
d713 1
a713 1
static PictFormatPtr
d797 1
a797 1
    if (pWin->redirectDraw)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d62 1
a62 1
	assert (pWin->redirectDraw == RedirectDrawNone);
d65 1
a65 1
    else if (pWin->redirectDraw != RedirectDrawNone)
d96 1
a96 2
    WindowPtr pWindow;
    int rc = dixLookupWindow(&pWindow, (XID)closure, pClient,DixUnknownAccess);
d98 2
a99 1
    if (rc == Success) {
d116 1
a116 1
    if (pWindow != pVisit->pWindow && pWindow->redirectDraw != RedirectDrawNone)
d160 1
a160 1
    if (should != (pWin->redirectDraw != RedirectDrawNone))
d184 1
a184 2
    if ((pWin->redirectDraw != RedirectDrawNone) !=
	(pWin->viewable && (GetCompWindow(pWin) != NULL)))
d187 1
a187 1
    if (pWin->redirectDraw != RedirectDrawNone)
d334 1
a334 1
    if (pWin->redirectDraw != RedirectDrawNone)
d358 1
a358 1
    if (pWin->redirectDraw != RedirectDrawNone)
d379 1
a379 1
    if (pWin->redirectDraw != RedirectDrawNone)
d400 1
a400 1
    if (pWin->redirectDraw != RedirectDrawNone)
d419 1
a419 1
    if (pWin->redirectDraw != RedirectDrawNone)
d441 1
a441 1
    if (pWin->redirectDraw != RedirectDrawNone)
d485 1
a485 1
    if (pWin->parent && pWin->redirectDraw == RedirectDrawNone)
d504 1
a504 1
    if (pWin->redirectDraw != RedirectDrawNone)
d629 1
a629 1
    if (pWin->redirectDraw != RedirectDrawNone)
d689 1
a689 1
PictFormatPtr
d773 1
a773 1
    if (pWin->redirectDraw != RedirectDrawNone)
@

