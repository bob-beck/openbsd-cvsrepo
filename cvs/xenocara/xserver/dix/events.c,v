head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.2
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.07.07.06.22.19;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	21XRahzR5S1ldK8i;

1.16
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	7pAEtF6Y5EgemkuY;

1.14
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.12.08.10.53.01;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.28.15.36.33;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.22;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.17.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Merge upstream fixes to the X event swapping code.

(CVE-2017-10971 and CVE-2017-10972).
@
text
@/************************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/* The panoramix components contained the following notice */
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/

/*
 * Copyright (c) 2003-2005, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/** @@file events.c
 * This file handles event delivery and a big part of the server-side protocol
 * handling (the parts for input devices).
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include "misc.h"
#include "resource.h"
#include <X11/Xproto.h>
#include "windowstr.h"
#include "inputstr.h"
#include "inpututils.h"
#include "scrnintstr.h"
#include "cursorstr.h"

#include "dixstruct.h"
#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#include "globals.h"

#include <X11/extensions/XKBproto.h>
#include "xkbsrv.h"
#include "xace.h"
#include "probes.h"

#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include "exglobals.h"
#include "exevents.h"
#include "extnsionst.h"

#include "dixevents.h"
#include "dixgrabs.h"
#include "dispatch.h"

#include <X11/extensions/ge.h>
#include "geext.h"
#include "geint.h"

#include "eventstr.h"
#include "enterleave.h"
#include "eventconvert.h"
#include "mi.h"

/* Extension events type numbering starts at EXTENSION_EVENT_BASE.  */
#define NoSuchEvent 0x80000000  /* so doesn't match NoEventMask */
#define StructureAndSubMask ( StructureNotifyMask | SubstructureNotifyMask )
#define AllButtonsMask ( \
	Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask )
#define MotionMask ( \
	PointerMotionMask | Button1MotionMask | \
	Button2MotionMask | Button3MotionMask | Button4MotionMask | \
	Button5MotionMask | ButtonMotionMask )
#define PropagateMask ( \
	KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | \
	MotionMask )
#define PointerGrabMask ( \
	ButtonPressMask | ButtonReleaseMask | \
	EnterWindowMask | LeaveWindowMask | \
	PointerMotionHintMask | KeymapStateMask | \
	MotionMask )
#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )
#define LastEventMask OwnerGrabButtonMask
#define AllEventMasks (LastEventMask|(LastEventMask-1))

/* @@return the core event type or 0 if the event is not a core event */
static inline int
core_get_type(const xEvent *event)
{
    int type = event->u.u.type;

    return ((type & EXTENSION_EVENT_BASE) || type == GenericEvent) ? 0 : type;
}

/* @@return the XI2 event type or 0 if the event is not a XI2 event */
static inline int
xi2_get_type(const xEvent *event)
{
    const xGenericEvent *e = (const xGenericEvent *) event;

    return (e->type != GenericEvent ||
            e->extension != IReqCode) ? 0 : e->evtype;
}

/**
 * Used to indicate a implicit passive grab created by a ButtonPress event.
 * See DeliverEventsToWindow().
 */
#define ImplicitGrabMask (1 << 7)

#define WID(w) ((w) ? ((w)->drawable.id) : 0)

#define XE_KBPTR (xE->u.keyButtonPointer)

CallbackListPtr EventCallback;
CallbackListPtr DeviceEventCallback;

#define DNPMCOUNT 8

Mask DontPropagateMasks[DNPMCOUNT];
static int DontPropagateRefCnts[DNPMCOUNT];

static void CheckVirtualMotion(DeviceIntPtr pDev, QdEventPtr qe,
                               WindowPtr pWin);
static void CheckPhysLimits(DeviceIntPtr pDev, CursorPtr cursor,
                            Bool generateEvents, Bool confineToScreen,
                            ScreenPtr pScreen);
static Bool IsWrongPointerBarrierClient(ClientPtr client,
                                        DeviceIntPtr dev,
                                        xEvent *event);

/** Key repeat hack. Do not use but in TryClientEvents */
extern BOOL EventIsKeyRepeat(xEvent *event);

/**
 * Main input device struct.
 *     inputInfo.pointer
 *     is the core pointer. Referred to as "virtual core pointer", "VCP",
 *     "core pointer" or inputInfo.pointer. The VCP is the first master
 *     pointer device and cannot be deleted.
 *
 *     inputInfo.keyboard
 *     is the core keyboard ("virtual core keyboard", "VCK", "core keyboard").
 *     See inputInfo.pointer.
 *
 *     inputInfo.devices
 *     linked list containing all devices including VCP and VCK.
 *
 *     inputInfo.off_devices
 *     Devices that have not been initialized and are thus turned off.
 *
 *     inputInfo.numDevices
 *     Total number of devices.
 *
 *     inputInfo.all_devices
 *     Virtual device used for XIAllDevices passive grabs. This device is
 *     not part of the inputInfo.devices list and mostly unset except for
 *     the deviceid. It exists because passivegrabs need a valid device
 *     reference.
 *
 *     inputInfo.all_master_devices
 *     Virtual device used for XIAllMasterDevices passive grabs. This device
 *     is not part of the inputInfo.devices list and mostly unset except for
 *     the deviceid. It exists because passivegrabs need a valid device
 *     reference.
 */
InputInfo inputInfo;

EventSyncInfoRec syncEvents;

static struct DeviceEventTime {
    Bool reset;
    TimeStamp time;
} lastDeviceEventTime[MAXDEVICES];

/**
 * The root window the given device is currently on.
 */
#define RootWindow(sprite) sprite->spriteTrace[0]

static xEvent *swapEvent = NULL;
static int swapEventLen = 0;

void
NotImplemented(xEvent *from, xEvent *to)
{
    FatalError("Not implemented");
}

/**
 * Convert the given event type from an XI event to a core event.
 * @@param[in] The XI 1.x event type.
 * @@return The matching core event type or 0 if there is none.
 */
int
XItoCoreType(int xitype)
{
    int coretype = 0;

    if (xitype == DeviceMotionNotify)
        coretype = MotionNotify;
    else if (xitype == DeviceButtonPress)
        coretype = ButtonPress;
    else if (xitype == DeviceButtonRelease)
        coretype = ButtonRelease;
    else if (xitype == DeviceKeyPress)
        coretype = KeyPress;
    else if (xitype == DeviceKeyRelease)
        coretype = KeyRelease;

    return coretype;
}

/**
 * @@return true if the device owns a cursor, false if device shares a cursor
 * sprite with another device.
 */
Bool
DevHasCursor(DeviceIntPtr pDev)
{
    return pDev->spriteInfo->spriteOwner;
}

/*
 * @@return true if a device is a pointer, check is the same as used by XI to
 * fill the 'use' field.
 */
Bool
IsPointerDevice(DeviceIntPtr dev)
{
    return (dev->type == MASTER_POINTER) ||
        (dev->valuator && dev->button) || (dev->valuator && !dev->key);
}

/*
 * @@return true if a device is a keyboard, check is the same as used by XI to
 * fill the 'use' field.
 *
 * Some pointer devices have keys as well (e.g. multimedia keys). Try to not
 * count them as keyboard devices.
 */
Bool
IsKeyboardDevice(DeviceIntPtr dev)
{
    return (dev->type == MASTER_KEYBOARD) ||
        ((dev->key && dev->kbdfeed) && !IsPointerDevice(dev));
}

Bool
IsMaster(DeviceIntPtr dev)
{
    return dev->type == MASTER_POINTER || dev->type == MASTER_KEYBOARD;
}

Bool
IsFloating(DeviceIntPtr dev)
{
    return !IsMaster(dev) && GetMaster(dev, MASTER_KEYBOARD) == NULL;
}

/**
 * Max event opcode.
 */
extern int lastEvent;

#define CantBeFiltered NoEventMask
/**
 * Event masks for each event type.
 *
 * One set of filters for each device, initialized by memcpy of
 * default_filter in InitEvents.
 *
 * Filters are used whether a given event may be delivered to a client,
 * usually in the form of if (window-event-mask & filter); then deliver event.
 *
 * One notable filter is for PointerMotion/DevicePointerMotion events. Each
 * time a button is pressed, the filter is modified to also contain the
 * matching ButtonXMotion mask.
 */
Mask event_filters[MAXDEVICES][MAXEVENTS];

static const Mask default_filter[MAXEVENTS] = {
    NoSuchEvent,                /* 0 */
    NoSuchEvent,                /* 1 */
    KeyPressMask,               /* KeyPress */
    KeyReleaseMask,             /* KeyRelease */
    ButtonPressMask,            /* ButtonPress */
    ButtonReleaseMask,          /* ButtonRelease */
    PointerMotionMask,          /* MotionNotify (initial state) */
    EnterWindowMask,            /* EnterNotify */
    LeaveWindowMask,            /* LeaveNotify */
    FocusChangeMask,            /* FocusIn */
    FocusChangeMask,            /* FocusOut */
    KeymapStateMask,            /* KeymapNotify */
    ExposureMask,               /* Expose */
    CantBeFiltered,             /* GraphicsExpose */
    CantBeFiltered,             /* NoExpose */
    VisibilityChangeMask,       /* VisibilityNotify */
    SubstructureNotifyMask,     /* CreateNotify */
    StructureAndSubMask,        /* DestroyNotify */
    StructureAndSubMask,        /* UnmapNotify */
    StructureAndSubMask,        /* MapNotify */
    SubstructureRedirectMask,   /* MapRequest */
    StructureAndSubMask,        /* ReparentNotify */
    StructureAndSubMask,        /* ConfigureNotify */
    SubstructureRedirectMask,   /* ConfigureRequest */
    StructureAndSubMask,        /* GravityNotify */
    ResizeRedirectMask,         /* ResizeRequest */
    StructureAndSubMask,        /* CirculateNotify */
    SubstructureRedirectMask,   /* CirculateRequest */
    PropertyChangeMask,         /* PropertyNotify */
    CantBeFiltered,             /* SelectionClear */
    CantBeFiltered,             /* SelectionRequest */
    CantBeFiltered,             /* SelectionNotify */
    ColormapChangeMask,         /* ColormapNotify */
    CantBeFiltered,             /* ClientMessage */
    CantBeFiltered              /* MappingNotify */
};

/**
 * For the given event, return the matching event filter. This filter may then
 * be AND'ed with the selected event mask.
 *
 * For XI2 events, the returned filter is simply the byte containing the event
 * mask we're interested in. E.g. for a mask of (1 << 13), this would be
 * byte[1].
 *
 * @@param[in] dev The device the event belongs to, may be NULL.
 * @@param[in] event The event to get the filter for. Only the type of the
 *                  event matters, or the extension + evtype for GenericEvents.
 * @@return The filter mask for the given event.
 *
 * @@see GetEventMask
 */
Mask
GetEventFilter(DeviceIntPtr dev, xEvent *event)
{
    int evtype = 0;

    if (event->u.u.type != GenericEvent)
        return event_get_filter_from_type(dev, event->u.u.type);
    else if ((evtype = xi2_get_type(event)))
        return event_get_filter_from_xi2type(evtype);
    ErrorF("[dix] Unknown event type %d. No filter\n", event->u.u.type);
    return 0;
}

/**
 * Return the single byte of the device's XI2 mask that contains the mask
 * for the event_type.
 */
int
GetXI2MaskByte(XI2Mask *mask, DeviceIntPtr dev, int event_type)
{
    /* we just return the matching filter because that's the only use
     * for this mask anyway.
     */
    if (xi2mask_isset(mask, dev, event_type))
        return event_get_filter_from_xi2type(event_type);
    else
        return 0;
}

/**
 * @@return TRUE if the mask is set for this event from this device on the
 * window, or FALSE otherwise.
 */
Bool
WindowXI2MaskIsset(DeviceIntPtr dev, WindowPtr win, xEvent *ev)
{
    OtherInputMasks *inputMasks = wOtherInputMasks(win);
    int evtype;

    if (!inputMasks || xi2_get_type(ev) == 0)
        return 0;

    evtype = ((xGenericEvent *) ev)->evtype;

    return xi2mask_isset(inputMasks->xi2mask, dev, evtype);
}

Mask
GetEventMask(DeviceIntPtr dev, xEvent *event, InputClients * other)
{
    int evtype;

    /* XI2 filters are only ever 8 bit, so let's return a 8 bit mask */
    if ((evtype = xi2_get_type(event))) {
        return GetXI2MaskByte(other->xi2mask, dev, evtype);
    }
    else if (core_get_type(event) != 0)
        return other->mask[XIAllDevices];
    else
        return other->mask[dev->id];
}

static CARD8 criticalEvents[32] = {
    0x7c, 0x30, 0x40            /* key, button, expose, and configure events */
};

static void
SyntheticMotion(DeviceIntPtr dev, int x, int y)
{
    int screenno = 0;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        screenno = dev->spriteInfo->sprite->screen->myNum;
#endif
    PostSyntheticMotion(dev, x, y, screenno,
                        (syncEvents.playingEvents) ? syncEvents.time.
                        milliseconds : currentTime.milliseconds);

}

#ifdef PANORAMIX
static void PostNewCursor(DeviceIntPtr pDev);

static Bool
XineramaSetCursorPosition(DeviceIntPtr pDev, int x, int y, Bool generateEvent)
{
    ScreenPtr pScreen;
    int i;
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    /* x,y are in Screen 0 coordinates.  We need to decide what Screen
       to send the message too and what the coordinates relative to
       that screen are. */

    pScreen = pSprite->screen;
    x += screenInfo.screens[0]->x;
    y += screenInfo.screens[0]->y;

    if (!point_on_screen(pScreen, x, y)) {
        FOR_NSCREENS(i) {
            if (i == pScreen->myNum)
                continue;
            if (point_on_screen(screenInfo.screens[i], x, y)) {
                pScreen = screenInfo.screens[i];
                break;
            }
        }
    }

    pSprite->screen = pScreen;
    pSprite->hotPhys.x = x - screenInfo.screens[0]->x;
    pSprite->hotPhys.y = y - screenInfo.screens[0]->y;
    x -= pScreen->x;
    y -= pScreen->y;

    return (*pScreen->SetCursorPosition) (pDev, pScreen, x, y, generateEvent);
}

static void
XineramaConstrainCursor(DeviceIntPtr pDev)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;
    ScreenPtr pScreen;
    BoxRec newBox;

    pScreen = pSprite->screen;
    newBox = pSprite->physLimits;

    /* Translate the constraining box to the screen
       the sprite is actually on */
    newBox.x1 += screenInfo.screens[0]->x - pScreen->x;
    newBox.x2 += screenInfo.screens[0]->x - pScreen->x;
    newBox.y1 += screenInfo.screens[0]->y - pScreen->y;
    newBox.y2 += screenInfo.screens[0]->y - pScreen->y;

    (*pScreen->ConstrainCursor) (pDev, pScreen, &newBox);
}

static Bool
XineramaSetWindowPntrs(DeviceIntPtr pDev, WindowPtr pWin)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    if (pWin == screenInfo.screens[0]->root) {
        int i;

        FOR_NSCREENS(i)
            pSprite->windows[i] = screenInfo.screens[i]->root;
    }
    else {
        PanoramiXRes *win;
        int rc, i;

        rc = dixLookupResourceByType((void **) &win, pWin->drawable.id,
                                     XRT_WINDOW, serverClient, DixReadAccess);
        if (rc != Success)
            return FALSE;

        FOR_NSCREENS(i) {
            rc = dixLookupWindow(pSprite->windows + i, win->info[i].id,
                                 serverClient, DixReadAccess);
            if (rc != Success)  /* window is being unmapped */
                return FALSE;
        }
    }
    return TRUE;
}

static void
XineramaConfineCursorToWindow(DeviceIntPtr pDev,
                              WindowPtr pWin, Bool generateEvents)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    int x, y, off_x, off_y, i;

    if (!XineramaSetWindowPntrs(pDev, pWin))
        return;

    i = PanoramiXNumScreens - 1;

    RegionCopy(&pSprite->Reg1, &pSprite->windows[i]->borderSize);
    off_x = screenInfo.screens[i]->x;
    off_y = screenInfo.screens[i]->y;

    while (i--) {
        x = off_x - screenInfo.screens[i]->x;
        y = off_y - screenInfo.screens[i]->y;

        if (x || y)
            RegionTranslate(&pSprite->Reg1, x, y);

        RegionUnion(&pSprite->Reg1, &pSprite->Reg1,
                    &pSprite->windows[i]->borderSize);

        off_x = screenInfo.screens[i]->x;
        off_y = screenInfo.screens[i]->y;
    }

    pSprite->hotLimits = *RegionExtents(&pSprite->Reg1);

    if (RegionNumRects(&pSprite->Reg1) > 1)
        pSprite->hotShape = &pSprite->Reg1;
    else
        pSprite->hotShape = NullRegion;

    pSprite->confined = FALSE;
    pSprite->confineWin =
        (pWin == screenInfo.screens[0]->root) ? NullWindow : pWin;

    CheckPhysLimits(pDev, pSprite->current, generateEvents, FALSE, NULL);
}

#endif                          /* PANORAMIX */

/**
 * Modifies the filter for the given protocol event type to the given masks.
 *
 * There's only two callers: UpdateDeviceState() and XI's SetMaskForExtEvent().
 * The latter initialises masks for the matching XI events, it's a once-off
 * setting.
 * UDS however changes the mask for MotionNotify and DeviceMotionNotify each
 * time a button is pressed to include the matching ButtonXMotion mask in the
 * filter.
 *
 * @@param[in] deviceid The device to modify the filter for.
 * @@param[in] mask The new filter mask.
 * @@param[in] event Protocol event type.
 */
void
SetMaskForEvent(int deviceid, Mask mask, int event)
{
    if (deviceid < 0 || deviceid >= MAXDEVICES)
        FatalError("SetMaskForEvent: bogus device id");
    event_filters[deviceid][event] = mask;
}

void
SetCriticalEvent(int event)
{
    if (event >= MAXEVENTS)
        FatalError("SetCriticalEvent: bogus event number");
    criticalEvents[event >> 3] |= 1 << (event & 7);
}

void
ConfineToShape(DeviceIntPtr pDev, RegionPtr shape, int *px, int *py)
{
    BoxRec box;
    int x = *px, y = *py;
    int incx = 1, incy = 1;

    if (RegionContainsPoint(shape, x, y, &box))
        return;
    box = *RegionExtents(shape);
    /* this is rather crude */
    do {
        x += incx;
        if (x >= box.x2) {
            incx = -1;
            x = *px - 1;
        }
        else if (x < box.x1) {
            incx = 1;
            x = *px;
            y += incy;
            if (y >= box.y2) {
                incy = -1;
                y = *py - 1;
            }
            else if (y < box.y1)
                return;         /* should never get here! */
        }
    } while (!RegionContainsPoint(shape, x, y, &box));
    *px = x;
    *py = y;
}

static void
CheckPhysLimits(DeviceIntPtr pDev, CursorPtr cursor, Bool generateEvents,
                Bool confineToScreen, /* unused if PanoramiX on */
                ScreenPtr pScreen)    /* unused if PanoramiX on */
{
    HotSpot new;
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    if (!cursor)
        return;
    new = pSprite->hotPhys;
#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        /* I don't care what the DDX has to say about it */
        pSprite->physLimits = pSprite->hotLimits;
    else
#endif
    {
        if (pScreen)
            new.pScreen = pScreen;
        else
            pScreen = new.pScreen;
        (*pScreen->CursorLimits) (pDev, pScreen, cursor, &pSprite->hotLimits,
                                  &pSprite->physLimits);
        pSprite->confined = confineToScreen;
        (*pScreen->ConstrainCursor) (pDev, pScreen, &pSprite->physLimits);
    }

    /* constrain the pointer to those limits */
    if (new.x < pSprite->physLimits.x1)
        new.x = pSprite->physLimits.x1;
    else if (new.x >= pSprite->physLimits.x2)
        new.x = pSprite->physLimits.x2 - 1;
    if (new.y < pSprite->physLimits.y1)
        new.y = pSprite->physLimits.y1;
    else if (new.y >= pSprite->physLimits.y2)
        new.y = pSprite->physLimits.y2 - 1;
    if (pSprite->hotShape)
        ConfineToShape(pDev, pSprite->hotShape, &new.x, &new.y);
    if ((
#ifdef PANORAMIX
            noPanoramiXExtension &&
#endif
            (pScreen != pSprite->hotPhys.pScreen)) ||
        (new.x != pSprite->hotPhys.x) || (new.y != pSprite->hotPhys.y)) {
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            XineramaSetCursorPosition(pDev, new.x, new.y, generateEvents);
        else
#endif
        {
            if (pScreen != pSprite->hotPhys.pScreen)
                pSprite->hotPhys = new;
            (*pScreen->SetCursorPosition)
                (pDev, pScreen, new.x, new.y, generateEvents);
        }
        if (!generateEvents)
            SyntheticMotion(pDev, new.x, new.y);
    }

#ifdef PANORAMIX
    /* Tell DDX what the limits are */
    if (!noPanoramiXExtension)
        XineramaConstrainCursor(pDev);
#endif
}

static void
CheckVirtualMotion(DeviceIntPtr pDev, QdEventPtr qe, WindowPtr pWin)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;
    RegionPtr reg = NULL;
    DeviceEvent *ev = NULL;

    if (qe) {
        ev = &qe->event->device_event;
        switch (ev->type) {
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            pSprite->hot.pScreen = qe->pScreen;
            pSprite->hot.x = ev->root_x;
            pSprite->hot.y = ev->root_y;
            pWin =
                pDev->deviceGrab.grab ? pDev->deviceGrab.grab->
                confineTo : NullWindow;
            break;
        default:
            break;
        }
    }
    if (pWin) {
        BoxRec lims;

#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            int x, y, off_x, off_y, i;

            if (!XineramaSetWindowPntrs(pDev, pWin))
                return;

            i = PanoramiXNumScreens - 1;

            RegionCopy(&pSprite->Reg2, &pSprite->windows[i]->borderSize);
            off_x = screenInfo.screens[i]->x;
            off_y = screenInfo.screens[i]->y;

            while (i--) {
                x = off_x - screenInfo.screens[i]->x;
                y = off_y - screenInfo.screens[i]->y;

                if (x || y)
                    RegionTranslate(&pSprite->Reg2, x, y);

                RegionUnion(&pSprite->Reg2, &pSprite->Reg2,
                            &pSprite->windows[i]->borderSize);

                off_x = screenInfo.screens[i]->x;
                off_y = screenInfo.screens[i]->y;
            }
        }
        else
#endif
        {
            if (pSprite->hot.pScreen != pWin->drawable.pScreen) {
                pSprite->hot.pScreen = pWin->drawable.pScreen;
                pSprite->hot.x = pSprite->hot.y = 0;
            }
        }

        lims = *RegionExtents(&pWin->borderSize);
        if (pSprite->hot.x < lims.x1)
            pSprite->hot.x = lims.x1;
        else if (pSprite->hot.x >= lims.x2)
            pSprite->hot.x = lims.x2 - 1;
        if (pSprite->hot.y < lims.y1)
            pSprite->hot.y = lims.y1;
        else if (pSprite->hot.y >= lims.y2)
            pSprite->hot.y = lims.y2 - 1;

#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            if (RegionNumRects(&pSprite->Reg2) > 1)
                reg = &pSprite->Reg2;

        }
        else
#endif
        {
            if (wBoundingShape(pWin))
                reg = &pWin->borderSize;
        }

        if (reg)
            ConfineToShape(pDev, reg, &pSprite->hot.x, &pSprite->hot.y);

        if (qe && ev) {
            qe->pScreen = pSprite->hot.pScreen;
            ev->root_x = pSprite->hot.x;
            ev->root_y = pSprite->hot.y;
        }
    }
#ifdef PANORAMIX
    if (noPanoramiXExtension)   /* No typo. Only set the root win if disabled */
#endif
        RootWindow(pDev->spriteInfo->sprite) = pSprite->hot.pScreen->root;
}

static void
ConfineCursorToWindow(DeviceIntPtr pDev, WindowPtr pWin, Bool generateEvents,
                      Bool confineToScreen)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    if (syncEvents.playingEvents) {
        CheckVirtualMotion(pDev, (QdEventPtr) NULL, pWin);
        SyntheticMotion(pDev, pSprite->hot.x, pSprite->hot.y);
    }
    else {
#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            XineramaConfineCursorToWindow(pDev, pWin, generateEvents);
            return;
        }
#endif
        pSprite->hotLimits = *RegionExtents(&pWin->borderSize);
        pSprite->hotShape = wBoundingShape(pWin) ? &pWin->borderSize
            : NullRegion;
        CheckPhysLimits(pDev, pSprite->current, generateEvents,
                        confineToScreen, pWin->drawable.pScreen);
    }
}

Bool
PointerConfinedToScreen(DeviceIntPtr pDev)
{
    return pDev->spriteInfo->sprite->confined;
}

/**
 * Update the sprite cursor to the given cursor.
 *
 * ChangeToCursor() will display the new cursor and free the old cursor (if
 * applicable). If the provided cursor is already the updated cursor, nothing
 * happens.
 */
static void
ChangeToCursor(DeviceIntPtr pDev, CursorPtr cursor)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;
    ScreenPtr pScreen;

    if (cursor != pSprite->current) {
        if ((pSprite->current->bits->xhot != cursor->bits->xhot) ||
            (pSprite->current->bits->yhot != cursor->bits->yhot))
            CheckPhysLimits(pDev, cursor, FALSE, pSprite->confined,
                            (ScreenPtr) NULL);
#ifdef PANORAMIX
        /* XXX: is this really necessary?? (whot) */
        if (!noPanoramiXExtension)
            pScreen = pSprite->screen;
        else
#endif
            pScreen = pSprite->hotPhys.pScreen;

        (*pScreen->DisplayCursor) (pDev, pScreen, cursor);
        FreeCursor(pSprite->current, (Cursor) 0);
        pSprite->current = RefCursor(cursor);
    }
}

/**
 * @@returns true if b is a descendent of a
 */
Bool
IsParent(WindowPtr a, WindowPtr b)
{
    for (b = b->parent; b; b = b->parent)
        if (b == a)
            return TRUE;
    return FALSE;
}

/**
 * Update the cursor displayed on the screen.
 *
 * Called whenever a cursor may have changed shape or position.
 */
static void
PostNewCursor(DeviceIntPtr pDev)
{
    WindowPtr win;
    GrabPtr grab = pDev->deviceGrab.grab;
    SpritePtr pSprite = pDev->spriteInfo->sprite;
    CursorPtr pCursor;

    if (syncEvents.playingEvents)
        return;
    if (grab) {
        if (grab->cursor) {
            ChangeToCursor(pDev, grab->cursor);
            return;
        }
        if (IsParent(grab->window, pSprite->win))
            win = pSprite->win;
        else
            win = grab->window;
    }
    else
        win = pSprite->win;
    for (; win; win = win->parent) {
        if (win->optional) {
            pCursor = WindowGetDeviceCursor(win, pDev);
            if (!pCursor && win->optional->cursor != NullCursor)
                pCursor = win->optional->cursor;
            if (pCursor) {
                ChangeToCursor(pDev, pCursor);
                return;
            }
        }
    }
}

/**
 * @@param dev device which you want to know its current root window
 * @@return root window where dev's sprite is located
 */
WindowPtr
GetCurrentRootWindow(DeviceIntPtr dev)
{
    return RootWindow(dev->spriteInfo->sprite);
}

/**
 * @@return window underneath the cursor sprite.
 */
WindowPtr
GetSpriteWindow(DeviceIntPtr pDev)
{
    return pDev->spriteInfo->sprite->win;
}

/**
 * @@return current sprite cursor.
 */
CursorPtr
GetSpriteCursor(DeviceIntPtr pDev)
{
    return pDev->spriteInfo->sprite->current;
}

/**
 * Set x/y current sprite position in screen coordinates.
 */
void
GetSpritePosition(DeviceIntPtr pDev, int *px, int *py)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    *px = pSprite->hotPhys.x;
    *py = pSprite->hotPhys.y;
}

#ifdef PANORAMIX
int
XineramaGetCursorScreen(DeviceIntPtr pDev)
{
    if (!noPanoramiXExtension) {
        return pDev->spriteInfo->sprite->screen->myNum;
    }
    else {
        return 0;
    }
}
#endif                          /* PANORAMIX */

#define TIMESLOP (5 * 60 * 1000)        /* 5 minutes */

static void
MonthChangedOrBadTime(CARD32 *ms)
{
    /* If the ddx/OS is careless about not processing timestamped events from
     * different sources in sorted order, then it's possible for time to go
     * backwards when it should not.  Here we ensure a decent time.
     */
    if ((currentTime.milliseconds - *ms) > TIMESLOP)
        currentTime.months++;
    else
        *ms = currentTime.milliseconds;
}

void
NoticeTime(const DeviceIntPtr dev, TimeStamp time)
{
    currentTime = time;
    lastDeviceEventTime[XIAllDevices].time = currentTime;
    lastDeviceEventTime[dev->id].time = currentTime;

    LastEventTimeToggleResetFlag(dev->id, TRUE);
    LastEventTimeToggleResetFlag(XIAllDevices, TRUE);
}

static void
NoticeTimeMillis(const DeviceIntPtr dev, CARD32 *ms)
{
    TimeStamp time;
    if (*ms < currentTime.milliseconds)
        MonthChangedOrBadTime(ms);
    time.months = currentTime.months;
    time.milliseconds = *ms;
    NoticeTime(dev, time);
}

void
NoticeEventTime(InternalEvent *ev, DeviceIntPtr dev)
{
    if (!syncEvents.playingEvents)
        NoticeTimeMillis(dev, &ev->any.time);
}

TimeStamp
LastEventTime(int deviceid)
{
    return lastDeviceEventTime[deviceid].time;
}

Bool
LastEventTimeWasReset(int deviceid)
{
    return lastDeviceEventTime[deviceid].reset;
}

void
LastEventTimeToggleResetFlag(int deviceid, Bool state)
{
    lastDeviceEventTime[deviceid].reset = state;
}

void
LastEventTimeToggleResetAll(Bool state)
{
    DeviceIntPtr dev;
    nt_list_for_each_entry(dev, inputInfo.devices, next) {
        LastEventTimeToggleResetFlag(dev->id, FALSE);
    }
    LastEventTimeToggleResetFlag(XIAllDevices, FALSE);
    LastEventTimeToggleResetFlag(XIAllMasterDevices, FALSE);
}

/**************************************************************************
 *            The following procedures deal with synchronous events       *
 **************************************************************************/

/**
 * EnqueueEvent is a device's processInputProc if a device is frozen.
 * Instead of delivering the events to the client, the event is tacked onto a
 * linked list for later delivery.
 */
void
EnqueueEvent(InternalEvent *ev, DeviceIntPtr device)
{
    QdEventPtr tail = NULL;
    QdEventPtr qe;
    SpritePtr pSprite = device->spriteInfo->sprite;
    int eventlen;
    DeviceEvent *event = &ev->device_event;

    if (!xorg_list_is_empty(&syncEvents.pending))
        tail = xorg_list_last_entry(&syncEvents.pending, QdEventRec, next);

    NoticeTimeMillis(device, &ev->any.time);

    /* Fix for key repeating bug. */
    if (device->key != NULL && device->key->xkbInfo != NULL &&
        event->type == ET_KeyRelease)
        AccessXCancelRepeatKey(device->key->xkbInfo, event->detail.key);

    if (DeviceEventCallback) {
        DeviceEventInfoRec eventinfo;

        /*  The RECORD spec says that the root window field of motion events
         *  must be valid.  At this point, it hasn't been filled in yet, so
         *  we do it here.  The long expression below is necessary to get
         *  the current root window; the apparently reasonable alternative
         *  GetCurrentRootWindow()->drawable.id doesn't give you the right
         *  answer on the first motion event after a screen change because
         *  the data that GetCurrentRootWindow relies on hasn't been
         *  updated yet.
         */
        if (ev->any.type == ET_Motion)
            ev->device_event.root = pSprite->hotPhys.pScreen->root->drawable.id;

        eventinfo.event = ev;
        eventinfo.device = device;
        CallCallbacks(&DeviceEventCallback, (void *) &eventinfo);
    }

    if (event->type == ET_Motion) {
#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            event->root_x += pSprite->screen->x - screenInfo.screens[0]->x;
            event->root_y += pSprite->screen->y - screenInfo.screens[0]->y;
        }
#endif
        pSprite->hotPhys.x = event->root_x;
        pSprite->hotPhys.y = event->root_y;
        /* do motion compression, but not if from different devices */
        if (tail &&
            (tail->event->any.type == ET_Motion) &&
            (tail->device == device) &&
            (tail->pScreen == pSprite->hotPhys.pScreen)) {
            DeviceEvent *tailev = &tail->event->device_event;

            tailev->root_x = pSprite->hotPhys.x;
            tailev->root_y = pSprite->hotPhys.y;
            tailev->time = event->time;
            tail->months = currentTime.months;
            return;
        }
    }

    eventlen = event->length;

    qe = malloc(sizeof(QdEventRec) + eventlen);
    if (!qe)
        return;
    xorg_list_init(&qe->next);
    qe->device = device;
    qe->pScreen = pSprite->hotPhys.pScreen;
    qe->months = currentTime.months;
    qe->event = (InternalEvent *) (qe + 1);
    memcpy(qe->event, event, eventlen);
    xorg_list_append(&qe->next, &syncEvents.pending);
}

/**
 * Run through the list of events queued up in syncEvents.
 * For each event do:
 * If the device for this event is not frozen anymore, take it and process it
 * as usually.
 * After that, check if there's any devices in the list that are not frozen.
 * If there is none, we're done. If there is at least one device that is not
 * frozen, then re-run from the beginning of the event queue.
 */
void
PlayReleasedEvents(void)
{
    QdEventPtr tmp;
    QdEventPtr qe;
    DeviceIntPtr dev;
    DeviceIntPtr pDev;

 restart:
    xorg_list_for_each_entry_safe(qe, tmp, &syncEvents.pending, next) {
        if (!qe->device->deviceGrab.sync.frozen) {
            xorg_list_del(&qe->next);
            pDev = qe->device;
            if (qe->event->any.type == ET_Motion)
                CheckVirtualMotion(pDev, qe, NullWindow);
            syncEvents.time.months = qe->months;
            syncEvents.time.milliseconds = qe->event->any.time;
#ifdef PANORAMIX
            /* Translate back to the sprite screen since processInputProc
               will translate from sprite screen to screen 0 upon reentry
               to the DIX layer */
            if (!noPanoramiXExtension) {
                DeviceEvent *ev = &qe->event->device_event;

                switch (ev->type) {
                case ET_Motion:
                case ET_ButtonPress:
                case ET_ButtonRelease:
                case ET_KeyPress:
                case ET_KeyRelease:
                case ET_ProximityIn:
                case ET_ProximityOut:
                case ET_TouchBegin:
                case ET_TouchUpdate:
                case ET_TouchEnd:
                    ev->root_x += screenInfo.screens[0]->x -
                        pDev->spriteInfo->sprite->screen->x;
                    ev->root_y += screenInfo.screens[0]->y -
                        pDev->spriteInfo->sprite->screen->y;
                    break;
                default:
                    break;
                }

            }
#endif
            (*qe->device->public.processInputProc) (qe->event, qe->device);
            free(qe);
            for (dev = inputInfo.devices; dev && dev->deviceGrab.sync.frozen;
                 dev = dev->next);
            if (!dev)
                break;

            /* Playing the event may have unfrozen another device. */
            /* So to play it safe, restart at the head of the queue */
            goto restart;
        }
    }
}

/**
 * Freeze or thaw the given devices. The device's processing proc is
 * switched to either the real processing proc (in case of thawing) or an
 * enqueuing processing proc (usually EnqueueEvent()).
 *
 * @@param dev The device to freeze/thaw
 * @@param frozen True to freeze or false to thaw.
 */
static void
FreezeThaw(DeviceIntPtr dev, Bool frozen)
{
    dev->deviceGrab.sync.frozen = frozen;
    if (frozen)
        dev->public.processInputProc = dev->public.enqueueInputProc;
    else
        dev->public.processInputProc = dev->public.realInputProc;
}

/**
 * Unfreeze devices and replay all events to the respective clients.
 *
 * ComputeFreezes takes the first event in the device's frozen event queue. It
 * runs up the sprite tree (spriteTrace) and searches for the window to replay
 * the events from. If it is found, it checks for passive grabs one down from
 * the window or delivers the events.
 */
static void
ComputeFreezes(void)
{
    DeviceIntPtr replayDev = syncEvents.replayDev;
    WindowPtr w;
    GrabPtr grab;
    DeviceIntPtr dev;

    for (dev = inputInfo.devices; dev; dev = dev->next)
        FreezeThaw(dev, dev->deviceGrab.sync.other ||
                   (dev->deviceGrab.sync.state >= FROZEN));
    if (syncEvents.playingEvents ||
        (!replayDev && xorg_list_is_empty(&syncEvents.pending)))
        return;
    syncEvents.playingEvents = TRUE;
    if (replayDev) {
        DeviceEvent *event = replayDev->deviceGrab.sync.event;

        syncEvents.replayDev = (DeviceIntPtr) NULL;

        w = XYToWindow(replayDev->spriteInfo->sprite,
                       event->root_x, event->root_y);
        if (!CheckDeviceGrabs(replayDev, event, syncEvents.replayWin)) {
            if (IsTouchEvent((InternalEvent *) event)) {
                TouchPointInfoPtr ti =
                    TouchFindByClientID(replayDev, event->touchid);
                BUG_WARN(!ti);

                TouchListenerAcceptReject(replayDev, ti, 0, XIRejectTouch);
            }
            else if (replayDev->focus &&
                     !IsPointerEvent((InternalEvent *) event))
                DeliverFocusedEvent(replayDev, (InternalEvent *) event, w);
            else
                DeliverDeviceEvents(w, (InternalEvent *) event, NullGrab,
                                    NullWindow, replayDev);
        }
    }
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (!dev->deviceGrab.sync.frozen) {
            PlayReleasedEvents();
            break;
        }
    }
    syncEvents.playingEvents = FALSE;
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (DevHasCursor(dev)) {
            /* the following may have been skipped during replay,
               so do it now */
            if ((grab = dev->deviceGrab.grab) && grab->confineTo) {
                if (grab->confineTo->drawable.pScreen !=
                    dev->spriteInfo->sprite->hotPhys.pScreen)
                    dev->spriteInfo->sprite->hotPhys.x =
                        dev->spriteInfo->sprite->hotPhys.y = 0;
                ConfineCursorToWindow(dev, grab->confineTo, TRUE, TRUE);
            }
            else
                ConfineCursorToWindow(dev,
                                      dev->spriteInfo->sprite->hotPhys.pScreen->
                                      root, TRUE, FALSE);
            PostNewCursor(dev);
        }
    }
}

#ifdef RANDR
void
ScreenRestructured(ScreenPtr pScreen)
{
    GrabPtr grab;
    DeviceIntPtr pDev;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (!IsFloating(pDev) && !DevHasCursor(pDev))
            continue;

        /* GrabDevice doesn't have a confineTo field, so we don't need to
         * worry about it. */
        if ((grab = pDev->deviceGrab.grab) && grab->confineTo) {
            if (grab->confineTo->drawable.pScreen
                != pDev->spriteInfo->sprite->hotPhys.pScreen)
                pDev->spriteInfo->sprite->hotPhys.x =
                    pDev->spriteInfo->sprite->hotPhys.y = 0;
            ConfineCursorToWindow(pDev, grab->confineTo, TRUE, TRUE);
        }
        else
            ConfineCursorToWindow(pDev,
                                  pDev->spriteInfo->sprite->hotPhys.pScreen->
                                  root, TRUE, FALSE);
    }
}
#endif

static void
CheckGrabForSyncs(DeviceIntPtr thisDev, Bool thisMode, Bool otherMode)
{
    GrabPtr grab = thisDev->deviceGrab.grab;
    DeviceIntPtr dev;

    if (thisMode == GrabModeSync)
        thisDev->deviceGrab.sync.state = FROZEN_NO_EVENT;
    else {                      /* free both if same client owns both */
        thisDev->deviceGrab.sync.state = THAWED;
        if (thisDev->deviceGrab.sync.other &&
            (CLIENT_BITS(thisDev->deviceGrab.sync.other->resource) ==
             CLIENT_BITS(grab->resource)))
            thisDev->deviceGrab.sync.other = NullGrab;
    }

    if (IsMaster(thisDev)) {
        dev = GetPairedDevice(thisDev);
        if (otherMode == GrabModeSync)
            dev->deviceGrab.sync.other = grab;
        else {                  /* free both if same client owns both */
            if (dev->deviceGrab.sync.other &&
                (CLIENT_BITS(dev->deviceGrab.sync.other->resource) ==
                 CLIENT_BITS(grab->resource)))
                dev->deviceGrab.sync.other = NullGrab;
        }
    }
    ComputeFreezes();
}

/**
 * Save the device's master device id. This needs to be done
 * if a client directly grabs a slave device that is attached to a master. For
 * the duration of the grab, the device is detached, ungrabbing re-attaches it
 * though.
 *
 * We store the ID of the master device only in case the master disappears
 * while the device has a grab.
 */
static void
DetachFromMaster(DeviceIntPtr dev)
{
    if (IsFloating(dev))
        return;

    dev->saved_master_id = GetMaster(dev, MASTER_ATTACHED)->id;

    AttachDevice(NULL, dev, NULL);
}

static void
ReattachToOldMaster(DeviceIntPtr dev)
{
    DeviceIntPtr master = NULL;

    if (IsMaster(dev))
        return;

    dixLookupDevice(&master, dev->saved_master_id, serverClient, DixUseAccess);

    if (master) {
        AttachDevice(serverClient, dev, master);
        dev->saved_master_id = 0;
    }
}

/**
 * Update touch records when an explicit grab is activated. Any touches owned by
 * the grabbing client are updated so the listener state reflects the new grab.
 */
static void
UpdateTouchesForGrab(DeviceIntPtr mouse)
{
    int i;

    if (!mouse->touch || mouse->deviceGrab.fromPassiveGrab)
        return;

    for (i = 0; i < mouse->touch->num_touches; i++) {
        TouchPointInfoPtr ti = mouse->touch->touches + i;
        TouchListener *listener = &ti->listeners[0];
        GrabPtr grab = mouse->deviceGrab.grab;

        if (ti->active &&
            CLIENT_BITS(listener->listener) == grab->resource) {
            listener->listener = grab->resource;
            listener->level = grab->grabtype;
            listener->state = LISTENER_IS_OWNER;
            listener->window = grab->window;

            if (grab->grabtype == CORE || grab->grabtype == XI ||
                !xi2mask_isset(grab->xi2mask, mouse, XI_TouchBegin))
                listener->type = LISTENER_POINTER_GRAB;
            else
                listener->type = LISTENER_GRAB;
            if (listener->grab)
                FreeGrab(listener->grab);
            listener->grab = AllocGrab(grab);
        }
    }
}

/**
 * Activate a pointer grab on the given device. A pointer grab will cause all
 * core pointer events of this device to be delivered to the grabbing client only.
 * No other device will send core events to the grab client while the grab is
 * on, but core events will be sent to other clients.
 * Can cause the cursor to change if a grab cursor is set.
 *
 * Note that parameter autoGrab may be (True & ImplicitGrabMask) if the grab
 * is an implicit grab caused by a ButtonPress event.
 *
 * @@param mouse The device to grab.
 * @@param grab The grab structure, needs to be setup.
 * @@param autoGrab True if the grab was caused by a button down event and not
 * explicitely by a client.
 */
void
ActivatePointerGrab(DeviceIntPtr mouse, GrabPtr grab,
                    TimeStamp time, Bool autoGrab)
{
    GrabInfoPtr grabinfo = &mouse->deviceGrab;
    GrabPtr oldgrab = grabinfo->grab;
    WindowPtr oldWin = (grabinfo->grab) ?
        grabinfo->grab->window : mouse->spriteInfo->sprite->win;
    Bool isPassive = autoGrab & ~ImplicitGrabMask;

    /* slave devices need to float for the duration of the grab. */
    if (grab->grabtype == XI2 &&
        !(autoGrab & ImplicitGrabMask) && !IsMaster(mouse))
        DetachFromMaster(mouse);

    if (grab->confineTo) {
        if (grab->confineTo->drawable.pScreen
            != mouse->spriteInfo->sprite->hotPhys.pScreen)
            mouse->spriteInfo->sprite->hotPhys.x =
                mouse->spriteInfo->sprite->hotPhys.y = 0;
        ConfineCursorToWindow(mouse, grab->confineTo, FALSE, TRUE);
    }
    DoEnterLeaveEvents(mouse, mouse->id, oldWin, grab->window, NotifyGrab);
    mouse->valuator->motionHintWindow = NullWindow;
    if (syncEvents.playingEvents)
        grabinfo->grabTime = syncEvents.time;
    else
        grabinfo->grabTime = time;
    grabinfo->grab = AllocGrab(grab);
    grabinfo->fromPassiveGrab = isPassive;
    grabinfo->implicitGrab = autoGrab & ImplicitGrabMask;
    PostNewCursor(mouse);
    UpdateTouchesForGrab(mouse);
    CheckGrabForSyncs(mouse, (Bool) grab->pointerMode,
                      (Bool) grab->keyboardMode);
    if (oldgrab)
        FreeGrab(oldgrab);
}

/**
 * Delete grab on given device, update the sprite.
 *
 * Extension devices are set up for ActivateKeyboardGrab().
 */
void
DeactivatePointerGrab(DeviceIntPtr mouse)
{
    GrabPtr grab = mouse->deviceGrab.grab;
    DeviceIntPtr dev;
    Bool wasPassive = mouse->deviceGrab.fromPassiveGrab;
    Bool wasImplicit = (mouse->deviceGrab.fromPassiveGrab &&
                        mouse->deviceGrab.implicitGrab);
    XID grab_resource = grab->resource;
    int i;

    /* If an explicit grab was deactivated, we must remove it from the head of
     * all the touches' listener lists. */
    for (i = 0; !wasPassive && mouse->touch && i < mouse->touch->num_touches; i++) {
        TouchPointInfoPtr ti = mouse->touch->touches + i;
        if (ti->active && TouchResourceIsOwner(ti, grab_resource)) {
            int mode = XIRejectTouch;
            /* Rejecting will generate a TouchEnd, but we must not
               emulate a ButtonRelease here. So pretend the listener
               already has the end event */
            if (grab->grabtype == CORE || grab->grabtype == XI ||
                    !xi2mask_isset(mouse->deviceGrab.grab->xi2mask, mouse, XI_TouchBegin)) {
                mode = XIAcceptTouch;
                /* NOTE: we set the state here, but
                 * ProcessTouchOwnershipEvent() will still call
                 * TouchEmitTouchEnd for this listener. The other half of
                 * this hack is in DeliverTouchEndEvent */
                ti->listeners[0].state = LISTENER_HAS_END;
            }
            TouchListenerAcceptReject(mouse, ti, 0, mode);
        }
    }

    TouchRemovePointerGrab(mouse);

    mouse->valuator->motionHintWindow = NullWindow;
    mouse->deviceGrab.grab = NullGrab;
    mouse->deviceGrab.sync.state = NOT_GRABBED;
    mouse->deviceGrab.fromPassiveGrab = FALSE;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (dev->deviceGrab.sync.other == grab)
            dev->deviceGrab.sync.other = NullGrab;
    }
    DoEnterLeaveEvents(mouse, mouse->id, grab->window,
                       mouse->spriteInfo->sprite->win, NotifyUngrab);
    if (grab->confineTo)
        ConfineCursorToWindow(mouse, GetCurrentRootWindow(mouse), FALSE, FALSE);
    PostNewCursor(mouse);

    if (!wasImplicit && grab->grabtype == XI2)
        ReattachToOldMaster(mouse);

    ComputeFreezes();

    FreeGrab(grab);
}

/**
 * Activate a keyboard grab on the given device.
 *
 * Extension devices have ActivateKeyboardGrab() set as their grabbing proc.
 */
void
ActivateKeyboardGrab(DeviceIntPtr keybd, GrabPtr grab, TimeStamp time,
                     Bool passive)
{
    GrabInfoPtr grabinfo = &keybd->deviceGrab;
    GrabPtr oldgrab = grabinfo->grab;
    WindowPtr oldWin;

    /* slave devices need to float for the duration of the grab. */
    if (grab->grabtype == XI2 && keybd->enabled &&
        !(passive & ImplicitGrabMask) && !IsMaster(keybd))
        DetachFromMaster(keybd);

    if (!keybd->enabled)
        oldWin = NULL;
    else if (grabinfo->grab)
        oldWin = grabinfo->grab->window;
    else if (keybd->focus)
        oldWin = keybd->focus->win;
    else
        oldWin = keybd->spriteInfo->sprite->win;
    if (oldWin == FollowKeyboardWin)
        oldWin = keybd->focus->win;
    if (keybd->valuator)
        keybd->valuator->motionHintWindow = NullWindow;
    if (oldWin)
        DoFocusEvents(keybd, oldWin, grab->window, NotifyGrab);
    if (syncEvents.playingEvents)
        grabinfo->grabTime = syncEvents.time;
    else
        grabinfo->grabTime = time;
    grabinfo->grab = AllocGrab(grab);
    grabinfo->fromPassiveGrab = passive;
    grabinfo->implicitGrab = passive & ImplicitGrabMask;
    CheckGrabForSyncs(keybd, (Bool) grab->keyboardMode,
                      (Bool) grab->pointerMode);
    if (oldgrab)
        FreeGrab(oldgrab);
}

/**
 * Delete keyboard grab for the given device.
 */
void
DeactivateKeyboardGrab(DeviceIntPtr keybd)
{
    GrabPtr grab = keybd->deviceGrab.grab;
    DeviceIntPtr dev;
    WindowPtr focusWin;
    Bool wasImplicit = (keybd->deviceGrab.fromPassiveGrab &&
                        keybd->deviceGrab.implicitGrab);

    if (keybd->valuator)
        keybd->valuator->motionHintWindow = NullWindow;
    keybd->deviceGrab.grab = NullGrab;
    keybd->deviceGrab.sync.state = NOT_GRABBED;
    keybd->deviceGrab.fromPassiveGrab = FALSE;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (dev->deviceGrab.sync.other == grab)
            dev->deviceGrab.sync.other = NullGrab;
    }

    if (keybd->focus)
        focusWin = keybd->focus->win;
    else if (keybd->spriteInfo->sprite)
        focusWin = keybd->spriteInfo->sprite->win;
    else
        focusWin = NullWindow;

    if (focusWin == FollowKeyboardWin)
        focusWin = inputInfo.keyboard->focus->win;

    DoFocusEvents(keybd, grab->window, focusWin, NotifyUngrab);

    if (!wasImplicit && grab->grabtype == XI2)
        ReattachToOldMaster(keybd);

    ComputeFreezes();

    FreeGrab(grab);
}

void
AllowSome(ClientPtr client, TimeStamp time, DeviceIntPtr thisDev, int newState)
{
    Bool thisGrabbed, otherGrabbed, othersFrozen, thisSynced;
    TimeStamp grabTime;
    DeviceIntPtr dev;
    GrabInfoPtr devgrabinfo, grabinfo = &thisDev->deviceGrab;

    thisGrabbed = grabinfo->grab && SameClient(grabinfo->grab, client);
    thisSynced = FALSE;
    otherGrabbed = FALSE;
    othersFrozen = FALSE;
    grabTime = grabinfo->grabTime;
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        devgrabinfo = &dev->deviceGrab;

        if (dev == thisDev)
            continue;
        if (devgrabinfo->grab && SameClient(devgrabinfo->grab, client)) {
            if (!(thisGrabbed || otherGrabbed) ||
                (CompareTimeStamps(devgrabinfo->grabTime, grabTime) == LATER))
                grabTime = devgrabinfo->grabTime;
            otherGrabbed = TRUE;
            if (grabinfo->sync.other == devgrabinfo->grab)
                thisSynced = TRUE;
            if (devgrabinfo->sync.state >= FROZEN)
                othersFrozen = TRUE;
        }
    }
    if (!((thisGrabbed && grabinfo->sync.state >= FROZEN) || thisSynced))
        return;
    if ((CompareTimeStamps(time, currentTime) == LATER) ||
        (CompareTimeStamps(time, grabTime) == EARLIER))
        return;
    switch (newState) {
    case THAWED:               /* Async */
        if (thisGrabbed)
            grabinfo->sync.state = THAWED;
        if (thisSynced)
            grabinfo->sync.other = NullGrab;
        ComputeFreezes();
        break;
    case FREEZE_NEXT_EVENT:    /* Sync */
        if (thisGrabbed) {
            grabinfo->sync.state = FREEZE_NEXT_EVENT;
            if (thisSynced)
                grabinfo->sync.other = NullGrab;
            ComputeFreezes();
        }
        break;
    case THAWED_BOTH:          /* AsyncBoth */
        if (othersFrozen) {
            for (dev = inputInfo.devices; dev; dev = dev->next) {
                devgrabinfo = &dev->deviceGrab;
                if (devgrabinfo->grab && SameClient(devgrabinfo->grab, client))
                    devgrabinfo->sync.state = THAWED;
                if (devgrabinfo->sync.other &&
                    SameClient(devgrabinfo->sync.other, client))
                    devgrabinfo->sync.other = NullGrab;
            }
            ComputeFreezes();
        }
        break;
    case FREEZE_BOTH_NEXT_EVENT:       /* SyncBoth */
        if (othersFrozen) {
            for (dev = inputInfo.devices; dev; dev = dev->next) {
                devgrabinfo = &dev->deviceGrab;
                if (devgrabinfo->grab && SameClient(devgrabinfo->grab, client))
                    devgrabinfo->sync.state = FREEZE_BOTH_NEXT_EVENT;
                if (devgrabinfo->sync.other
                    && SameClient(devgrabinfo->sync.other, client))
                    devgrabinfo->sync.other = NullGrab;
            }
            ComputeFreezes();
        }
        break;
    case NOT_GRABBED:          /* Replay */
        if (thisGrabbed && grabinfo->sync.state == FROZEN_WITH_EVENT) {
            if (thisSynced)
                grabinfo->sync.other = NullGrab;
            syncEvents.replayDev = thisDev;
            syncEvents.replayWin = grabinfo->grab->window;
            (*grabinfo->DeactivateGrab) (thisDev);
            syncEvents.replayDev = (DeviceIntPtr) NULL;
        }
        break;
    case THAW_OTHERS:          /* AsyncOthers */
        if (othersFrozen) {
            for (dev = inputInfo.devices; dev; dev = dev->next) {
                if (dev == thisDev)
                    continue;
                devgrabinfo = &dev->deviceGrab;
                if (devgrabinfo->grab && SameClient(devgrabinfo->grab, client))
                    devgrabinfo->sync.state = THAWED;
                if (devgrabinfo->sync.other
                    && SameClient(devgrabinfo->sync.other, client))
                    devgrabinfo->sync.other = NullGrab;
            }
            ComputeFreezes();
        }
        break;
    }

    /* We've unfrozen the grab. If the grab was a touch grab, we're now the
     * owner and expected to accept/reject it. Reject == ReplayPointer which
     * we've handled in ComputeFreezes() (during DeactivateGrab) above,
     * anything else is accept.
     */
    if (newState != NOT_GRABBED /* Replay */ &&
        IsTouchEvent((InternalEvent*)grabinfo->sync.event)) {
        TouchAcceptAndEnd(thisDev, grabinfo->sync.event->touchid);
    }
}

/**
 * Server-side protocol handling for AllowEvents request.
 *
 * Release some events from a frozen device.
 */
int
ProcAllowEvents(ClientPtr client)
{
    TimeStamp time;
    DeviceIntPtr mouse = NULL;
    DeviceIntPtr keybd = NULL;

    REQUEST(xAllowEventsReq);

    REQUEST_SIZE_MATCH(xAllowEventsReq);
    time = ClientTimeToServerTime(stuff->time);

    mouse = PickPointer(client);
    keybd = PickKeyboard(client);

    switch (stuff->mode) {
    case ReplayPointer:
        AllowSome(client, time, mouse, NOT_GRABBED);
        break;
    case SyncPointer:
        AllowSome(client, time, mouse, FREEZE_NEXT_EVENT);
        break;
    case AsyncPointer:
        AllowSome(client, time, mouse, THAWED);
        break;
    case ReplayKeyboard:
        AllowSome(client, time, keybd, NOT_GRABBED);
        break;
    case SyncKeyboard:
        AllowSome(client, time, keybd, FREEZE_NEXT_EVENT);
        break;
    case AsyncKeyboard:
        AllowSome(client, time, keybd, THAWED);
        break;
    case SyncBoth:
        AllowSome(client, time, keybd, FREEZE_BOTH_NEXT_EVENT);
        break;
    case AsyncBoth:
        AllowSome(client, time, keybd, THAWED_BOTH);
        break;
    default:
        client->errorValue = stuff->mode;
        return BadValue;
    }
    return Success;
}

/**
 * Deactivate grabs from any device that has been grabbed by the client.
 */
void
ReleaseActiveGrabs(ClientPtr client)
{
    DeviceIntPtr dev;
    Bool done;

    /* XXX CloseDownClient should remove passive grabs before
     * releasing active grabs.
     */
    do {
        done = TRUE;
        for (dev = inputInfo.devices; dev; dev = dev->next) {
            if (dev->deviceGrab.grab &&
                SameClient(dev->deviceGrab.grab, client)) {
                (*dev->deviceGrab.DeactivateGrab) (dev);
                done = FALSE;
            }
        }
    } while (!done);
}

/**************************************************************************
 *            The following procedures deal with delivering events        *
 **************************************************************************/

/**
 * Deliver the given events to the given client.
 *
 * More than one event may be delivered at a time. This is the case with
 * DeviceMotionNotifies which may be followed by DeviceValuator events.
 *
 * TryClientEvents() is the last station before actually writing the events to
 * the socket. Anything that is not filtered here, will get delivered to the
 * client.
 * An event is only delivered if
 *   - mask and filter match up.
 *   - no other client has a grab on the device that caused the event.
 *
 *
 * @@param client The target client to deliver to.
 * @@param dev The device the event came from. May be NULL.
 * @@param pEvents The events to be delivered.
 * @@param count Number of elements in pEvents.
 * @@param mask Event mask as set by the window.
 * @@param filter Mask based on event type.
 * @@param grab Possible grab on the device that caused the event.
 *
 * @@return 1 if event was delivered, 0 if not or -1 if grab was not set by the
 * client.
 */
int
TryClientEvents(ClientPtr client, DeviceIntPtr dev, xEvent *pEvents,
                int count, Mask mask, Mask filter, GrabPtr grab)
{
    int type;

#ifdef DEBUG_EVENTS
    ErrorF("[dix] Event([%d, %d], mask=0x%lx), client=%d%s",
           pEvents->u.u.type, pEvents->u.u.detail, mask,
           client ? client->index : -1,
           (client && client->clientGone) ? " (gone)" : "");
#endif

    if (!client || client == serverClient || client->clientGone) {
#ifdef DEBUG_EVENTS
        ErrorF(" not delivered to fake/dead client\n");
#endif
        return 0;
    }

    if (filter != CantBeFiltered && !(mask & filter)) {
#ifdef DEBUG_EVENTS
        ErrorF(" filtered\n");
#endif
        return 0;
    }

    if (grab && !SameClient(grab, client)) {
#ifdef DEBUG_EVENTS
        ErrorF(" not delivered due to grab\n");
#endif
        return -1;              /* don't send, but notify caller */
    }

    type = pEvents->u.u.type;
    if (type == MotionNotify) {
        if (mask & PointerMotionHintMask) {
            if (WID(dev->valuator->motionHintWindow) ==
                pEvents->u.keyButtonPointer.event) {
#ifdef DEBUG_EVENTS
                ErrorF("[dix] \n");
                ErrorF("[dix] motionHintWindow == keyButtonPointer.event\n");
#endif
                return 1;       /* don't send, but pretend we did */
            }
            pEvents->u.u.detail = NotifyHint;
        }
        else {
            pEvents->u.u.detail = NotifyNormal;
        }
    }
    else if (type == DeviceMotionNotify) {
        if (MaybeSendDeviceMotionNotifyHint((deviceKeyButtonPointer *) pEvents,
                                            mask) != 0)
            return 1;
    }
    else if (type == KeyPress) {
        if (EventIsKeyRepeat(pEvents)) {
            if (!_XkbWantsDetectableAutoRepeat(client)) {
                xEvent release = *pEvents;

                release.u.u.type = KeyRelease;
                WriteEventsToClient(client, 1, &release);
#ifdef DEBUG_EVENTS
                ErrorF(" (plus fake core release for repeat)");
#endif
            }
            else {
#ifdef DEBUG_EVENTS
                ErrorF(" (detectable autorepeat for core)");
#endif
            }
        }

    }
    else if (type == DeviceKeyPress) {
        if (EventIsKeyRepeat(pEvents)) {
            if (!_XkbWantsDetectableAutoRepeat(client)) {
                deviceKeyButtonPointer release =
                    *(deviceKeyButtonPointer *) pEvents;
                release.type = DeviceKeyRelease;
#ifdef DEBUG_EVENTS
                ErrorF(" (plus fake xi1 release for repeat)");
#endif
                WriteEventsToClient(client, 1, (xEvent *) &release);
            }
            else {
#ifdef DEBUG_EVENTS
                ErrorF(" (detectable autorepeat for core)");
#endif
            }
        }
    }

    if (BitIsOn(criticalEvents, type)) {
        if (client->smart_priority < SMART_MAX_PRIORITY)
            client->smart_priority++;
        SetCriticalOutputPending();
    }

    WriteEventsToClient(client, count, pEvents);
#ifdef DEBUG_EVENTS
    ErrorF("[dix]  delivered\n");
#endif
    return 1;
}

static BOOL
ActivateImplicitGrab(DeviceIntPtr dev, ClientPtr client, WindowPtr win,
                     xEvent *event, Mask deliveryMask)
{
    GrabPtr tempGrab;
    OtherInputMasks *inputMasks;
    CARD8 type = event->u.u.type;
    enum InputLevel grabtype;

    if (type == ButtonPress)
        grabtype = CORE;
    else if (type == DeviceButtonPress)
        grabtype = XI;
    else if ((type = xi2_get_type(event)) == XI_ButtonPress)
        grabtype = XI2;
    else
        return FALSE;

    tempGrab = AllocGrab(NULL);
    if (!tempGrab)
        return FALSE;
    tempGrab->next = NULL;
    tempGrab->device = dev;
    tempGrab->resource = client->clientAsMask;
    tempGrab->window = win;
    tempGrab->ownerEvents = (deliveryMask & OwnerGrabButtonMask) ? TRUE : FALSE;
    tempGrab->eventMask = deliveryMask;
    tempGrab->keyboardMode = GrabModeAsync;
    tempGrab->pointerMode = GrabModeAsync;
    tempGrab->confineTo = NullWindow;
    tempGrab->cursor = NullCursor;
    tempGrab->type = type;
    tempGrab->grabtype = grabtype;

    /* get the XI and XI2 device mask */
    inputMasks = wOtherInputMasks(win);
    tempGrab->deviceMask = (inputMasks) ? inputMasks->inputEvents[dev->id] : 0;

    if (inputMasks)
        xi2mask_merge(tempGrab->xi2mask, inputMasks->xi2mask);

    (*dev->deviceGrab.ActivateGrab) (dev, tempGrab,
                                     currentTime, TRUE | ImplicitGrabMask);
    FreeGrab(tempGrab);
    return TRUE;
}

/**
 * Attempt event delivery to the client owning the window.
 */
static enum EventDeliveryState
DeliverToWindowOwner(DeviceIntPtr dev, WindowPtr win,
                     xEvent *events, int count, Mask filter, GrabPtr grab)
{
    /* if nobody ever wants to see this event, skip some work */
    if (filter != CantBeFiltered &&
        !((wOtherEventMasks(win) | win->eventMask) & filter))
        return EVENT_SKIP;

    if (IsInterferingGrab(wClient(win), dev, events))
        return EVENT_SKIP;

    if (!XaceHook(XACE_RECEIVE_ACCESS, wClient(win), win, events, count)) {
        int attempt = TryClientEvents(wClient(win), dev, events,
                                      count, win->eventMask,
                                      filter, grab);

        if (attempt > 0)
            return EVENT_DELIVERED;
        if (attempt < 0)
            return EVENT_REJECTED;
    }

    return EVENT_NOT_DELIVERED;
}

/**
 * Get the list of clients that should be tried for event delivery on the
 * given window.
 *
 * @@return 1 if the client list should be traversed, zero if the event
 * should be skipped.
 */
static Bool
GetClientsForDelivery(DeviceIntPtr dev, WindowPtr win,
                      xEvent *events, Mask filter, InputClients ** iclients)
{
    int rc = 0;

    if (core_get_type(events) != 0)
        *iclients = (InputClients *) wOtherClients(win);
    else if (xi2_get_type(events) != 0) {
        OtherInputMasks *inputMasks = wOtherInputMasks(win);

        /* Has any client selected for the event? */
        if (!WindowXI2MaskIsset(dev, win, events))
            goto out;
        *iclients = inputMasks->inputClients;
    }
    else {
        OtherInputMasks *inputMasks = wOtherInputMasks(win);

        /* Has any client selected for the event? */
        if (!inputMasks || !(inputMasks->inputEvents[dev->id] & filter))
            goto out;

        *iclients = inputMasks->inputClients;
    }

    rc = 1;
 out:
    return rc;
}

/**
 * Try delivery on each client in inputclients, provided the event mask
 * accepts it and there is no interfering core grab..
 */
static enum EventDeliveryState
DeliverEventToInputClients(DeviceIntPtr dev, InputClients * inputclients,
                           WindowPtr win, xEvent *events,
                           int count, Mask filter, GrabPtr grab,
                           ClientPtr *client_return, Mask *mask_return)
{
    int attempt;
    enum EventDeliveryState rc = EVENT_NOT_DELIVERED;
    Bool have_device_button_grab_class_client = FALSE;

    for (; inputclients; inputclients = inputclients->next) {
        Mask mask;
        ClientPtr client = rClient(inputclients);

        if (IsInterferingGrab(client, dev, events))
            continue;

        if (IsWrongPointerBarrierClient(client, dev, events))
            continue;

        mask = GetEventMask(dev, events, inputclients);

        if (XaceHook(XACE_RECEIVE_ACCESS, client, win, events, count))
            /* do nothing */ ;
        else if ((attempt = TryClientEvents(client, dev,
                                            events, count,
                                            mask, filter, grab))) {
            if (attempt > 0) {
                /*
                 * The order of clients is arbitrary therefore if one
                 * client belongs to DeviceButtonGrabClass make sure to
                 * catch it.
                 */
                if (!have_device_button_grab_class_client) {
                    rc = EVENT_DELIVERED;
                    *client_return = client;
                    *mask_return = mask;
                    /* Success overrides non-success, so if we've been
                     * successful on one client, return that */
                    if (mask & DeviceButtonGrabMask)
                        have_device_button_grab_class_client = TRUE;
                }
            } else if (rc == EVENT_NOT_DELIVERED)
                rc = EVENT_REJECTED;
        }
    }

    return rc;
}

/**
 * Deliver events to clients registered on the window.
 *
 * @@param client_return On successful delivery, set to the recipient.
 * @@param mask_return On successful delivery, set to the recipient's event
 * mask for this event.
 */
static enum EventDeliveryState
DeliverEventToWindowMask(DeviceIntPtr dev, WindowPtr win, xEvent *events,
                         int count, Mask filter, GrabPtr grab,
                         ClientPtr *client_return, Mask *mask_return)
{
    InputClients *iclients;

    if (!GetClientsForDelivery(dev, win, events, filter, &iclients))
        return EVENT_SKIP;

    return DeliverEventToInputClients(dev, iclients, win, events, count, filter,
                                      grab, client_return, mask_return);

}

/**
 * Deliver events to a window. At this point, we do not yet know if the event
 * actually needs to be delivered. May activate a grab if the event is a
 * button press.
 *
 * Core events are always delivered to the window owner. If the filter is
 * something other than CantBeFiltered, the event is also delivered to other
 * clients with the matching mask on the window.
 *
 * More than one event may be delivered at a time. This is the case with
 * DeviceMotionNotifies which may be followed by DeviceValuator events.
 *
 * @@param pWin The window that would get the event.
 * @@param pEvents The events to be delivered.
 * @@param count Number of elements in pEvents.
 * @@param filter Mask based on event type.
 * @@param grab Possible grab on the device that caused the event.
 *
 * @@return a positive number if at least one successful delivery has been
 * made, 0 if no events were delivered, or a negative number if the event
 * has not been delivered _and_ rejected by at least one client.
 */
int
DeliverEventsToWindow(DeviceIntPtr pDev, WindowPtr pWin, xEvent
                      *pEvents, int count, Mask filter, GrabPtr grab)
{
    int deliveries = 0, nondeliveries = 0;
    ClientPtr client = NullClient;
    Mask deliveryMask = 0;      /* If a grab occurs due to a button press, then
                                   this mask is the mask of the grab. */
    int type = pEvents->u.u.type;

    /* Deliver to window owner */
    if ((filter == CantBeFiltered) || core_get_type(pEvents) != 0) {
        enum EventDeliveryState rc;

        rc = DeliverToWindowOwner(pDev, pWin, pEvents, count, filter, grab);

        switch (rc) {
        case EVENT_SKIP:
            return 0;
        case EVENT_REJECTED:
            nondeliveries--;
            break;
        case EVENT_DELIVERED:
            /* We delivered to the owner, with our event mask */
            deliveries++;
            client = wClient(pWin);
            deliveryMask = pWin->eventMask;
            break;
        case EVENT_NOT_DELIVERED:
            break;
        }
    }

    /* CantBeFiltered means only window owner gets the event */
    if (filter != CantBeFiltered) {
        enum EventDeliveryState rc;

        rc = DeliverEventToWindowMask(pDev, pWin, pEvents, count, filter,
                                      grab, &client, &deliveryMask);

        switch (rc) {
        case EVENT_SKIP:
            return 0;
        case EVENT_REJECTED:
            nondeliveries--;
            break;
        case EVENT_DELIVERED:
            deliveries++;
            break;
        case EVENT_NOT_DELIVERED:
            break;
        }
    }

    if (deliveries) {
        /*
         * Note that since core events are delivered first, an implicit grab may
         * be activated on a core grab, stopping the XI events.
         */
        if (!grab &&
            ActivateImplicitGrab(pDev, client, pWin, pEvents, deliveryMask))
            /* grab activated */ ;
        else if (type == MotionNotify)
            pDev->valuator->motionHintWindow = pWin;
        else if (type == DeviceMotionNotify || type == DeviceButtonPress)
            CheckDeviceGrabAndHintWindow(pWin, type,
                                         (deviceKeyButtonPointer *) pEvents,
                                         grab, client, deliveryMask);
        return deliveries;
    }
    return nondeliveries;
}

/**
 * Filter out raw events for XI 2.0 and XI 2.1 clients.
 *
 * If there is a grab on the device, 2.0 clients only get raw events if they
 * have the grab. 2.1+ clients get raw events in all cases.
 *
 * @@return TRUE if the event should be discarded, FALSE otherwise.
 */
static BOOL
FilterRawEvents(const ClientPtr client, const GrabPtr grab, WindowPtr root)
{
    XIClientPtr client_xi_version;
    int cmp;

    /* device not grabbed -> don't filter */
    if (!grab)
        return FALSE;

    client_xi_version =
        dixLookupPrivate(&client->devPrivates, XIClientPrivateKey);

    cmp = version_compare(client_xi_version->major_version,
                          client_xi_version->minor_version, 2, 0);
    /* XI 2.0: if device is grabbed, skip
       XI 2.1: if device is grabbed by us, skip, we've already delivered */
    if (cmp == 0)
        return TRUE;

    return (grab->window != root) ? FALSE : SameClient(grab, client);
}

/**
 * Deliver a raw event to the grab owner (if any) and to all root windows.
 *
 * Raw event delivery differs between XI 2.0 and XI 2.1.
 * XI 2.0: events delivered to the grabbing client (if any) OR to all root
 * windows
 * XI 2.1: events delivered to all root windows, regardless of grabbing
 * state.
 */
void
DeliverRawEvent(RawDeviceEvent *ev, DeviceIntPtr device)
{
    GrabPtr grab = device->deviceGrab.grab;
    xEvent *xi;
    int i, rc;
    int filter;

    rc = EventToXI2((InternalEvent *) ev, (xEvent **) &xi);
    if (rc != Success) {
        ErrorF("[Xi] %s: XI2 conversion failed in %s (%d)\n",
               __func__, device->name, rc);
        return;
    }

    if (grab)
        DeliverGrabbedEvent((InternalEvent *) ev, device, FALSE);

    filter = GetEventFilter(device, xi);

    for (i = 0; i < screenInfo.numScreens; i++) {
        WindowPtr root;
        InputClients *inputclients;

        root = screenInfo.screens[i]->root;
        if (!GetClientsForDelivery(device, root, xi, filter, &inputclients))
            continue;

        for (; inputclients; inputclients = inputclients->next) {
            ClientPtr c;        /* unused */
            Mask m;             /* unused */
            InputClients ic = *inputclients;

            /* Because we run through the list manually, copy the actual
             * list, shorten the copy to only have one client and then pass
             * that down to DeliverEventToInputClients. This way we avoid
             * double events on XI 2.1 clients that have a grab on the
             * device.
             */
            ic.next = NULL;

            if (!FilterRawEvents(rClient(&ic), grab, root))
                DeliverEventToInputClients(device, &ic, root, xi, 1,
                                           filter, NULL, &c, &m);
        }
    }

    free(xi);
}

/* If the event goes to dontClient, don't send it and return 0.  if
   send works,  return 1 or if send didn't work, return 2.
   Only works for core events.
*/

#ifdef PANORAMIX
static int
XineramaTryClientEventsResult(ClientPtr client,
                              GrabPtr grab, Mask mask, Mask filter)
{
    if ((client) && (client != serverClient) && (!client->clientGone) &&
        ((filter == CantBeFiltered) || (mask & filter))) {
        if (grab && !SameClient(grab, client))
            return -1;
        else
            return 1;
    }
    return 0;
}
#endif

/**
 * Try to deliver events to the interested parties.
 *
 * @@param pWin The window that would get the event.
 * @@param pEvents The events to be delivered.
 * @@param count Number of elements in pEvents.
 * @@param filter Mask based on event type.
 * @@param dontClient Don't deliver to the dontClient.
 */
int
MaybeDeliverEventsToClient(WindowPtr pWin, xEvent *pEvents,
                           int count, Mask filter, ClientPtr dontClient)
{
    OtherClients *other;

    if (pWin->eventMask & filter) {
        if (wClient(pWin) == dontClient)
            return 0;
#ifdef PANORAMIX
        if (!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
            return XineramaTryClientEventsResult(wClient(pWin), NullGrab,
                                                 pWin->eventMask, filter);
#endif
        if (XaceHook(XACE_RECEIVE_ACCESS, wClient(pWin), pWin, pEvents, count))
            return 1;           /* don't send, but pretend we did */
        return TryClientEvents(wClient(pWin), NULL, pEvents, count,
                               pWin->eventMask, filter, NullGrab);
    }
    for (other = wOtherClients(pWin); other; other = other->next) {
        if (other->mask & filter) {
            if (SameClient(other, dontClient))
                return 0;
#ifdef PANORAMIX
            if (!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
                return XineramaTryClientEventsResult(rClient(other), NullGrab,
                                                     other->mask, filter);
#endif
            if (XaceHook(XACE_RECEIVE_ACCESS, rClient(other), pWin, pEvents,
                         count))
                return 1;       /* don't send, but pretend we did */
            return TryClientEvents(rClient(other), NULL, pEvents, count,
                                   other->mask, filter, NullGrab);
        }
    }
    return 2;
}

static Window
FindChildForEvent(SpritePtr pSprite, WindowPtr event)
{
    WindowPtr w = DeepestSpriteWin(pSprite);
    Window child = None;

    /* If the search ends up past the root should the child field be
       set to none or should the value in the argument be passed
       through. It probably doesn't matter since everyone calls
       this function with child == None anyway. */
    while (w) {
        /* If the source window is same as event window, child should be
           none.  Don't bother going all all the way back to the root. */

        if (w == event) {
            child = None;
            break;
        }

        if (w->parent == event) {
            child = w->drawable.id;
            break;
        }
        w = w->parent;
    }
    return child;
}

/**
 * Adjust event fields to comply with the window properties.
 *
 * @@param xE Event to be modified in place
 * @@param pWin The window to get the information from.
 * @@param child Child window setting for event (if applicable)
 * @@param calcChild If True, calculate the child window.
 */
void
FixUpEventFromWindow(SpritePtr pSprite,
                     xEvent *xE, WindowPtr pWin, Window child, Bool calcChild)
{
    int evtype;

    if (calcChild)
        child = FindChildForEvent(pSprite, pWin);

    if ((evtype = xi2_get_type(xE))) {
        xXIDeviceEvent *event = (xXIDeviceEvent *) xE;

        switch (evtype) {
        case XI_RawKeyPress:
        case XI_RawKeyRelease:
        case XI_RawButtonPress:
        case XI_RawButtonRelease:
        case XI_RawMotion:
        case XI_RawTouchBegin:
        case XI_RawTouchUpdate:
        case XI_RawTouchEnd:
        case XI_DeviceChanged:
        case XI_HierarchyChanged:
        case XI_PropertyEvent:
        case XI_BarrierHit:
        case XI_BarrierLeave:
            return;
        default:
            break;
        }

        event->root = RootWindow(pSprite)->drawable.id;
        event->event = pWin->drawable.id;

        if (evtype == XI_TouchOwnership) {
            event->child = child;
            return;
        }

        if (pSprite->hot.pScreen == pWin->drawable.pScreen) {
            event->event_x = event->root_x - double_to_fp1616(pWin->drawable.x);
            event->event_y = event->root_y - double_to_fp1616(pWin->drawable.y);
            event->child = child;
        }
        else {
            event->event_x = 0;
            event->event_y = 0;
            event->child = None;
        }

        if (event->evtype == XI_Enter || event->evtype == XI_Leave ||
            event->evtype == XI_FocusIn || event->evtype == XI_FocusOut)
            ((xXIEnterEvent *) event)->same_screen =
                (pSprite->hot.pScreen == pWin->drawable.pScreen);

    }
    else {
        XE_KBPTR.root = RootWindow(pSprite)->drawable.id;
        XE_KBPTR.event = pWin->drawable.id;
        if (pSprite->hot.pScreen == pWin->drawable.pScreen) {
            XE_KBPTR.sameScreen = xTrue;
            XE_KBPTR.child = child;
            XE_KBPTR.eventX = XE_KBPTR.rootX - pWin->drawable.x;
            XE_KBPTR.eventY = XE_KBPTR.rootY - pWin->drawable.y;
        }
        else {
            XE_KBPTR.sameScreen = xFalse;
            XE_KBPTR.child = None;
            XE_KBPTR.eventX = 0;
            XE_KBPTR.eventY = 0;
        }
    }
}

/**
 * Check if a given event is deliverable at all on a given window.
 *
 * This function only checks if any client wants it, not for a specific
 * client.
 *
 * @@param[in] dev The device this event is being sent for.
 * @@param[in] evtype The event type of the event that is to be sent.
 * @@param[in] win The current event window.
 *
 * @@return Bitmask of ::EVENT_XI2_MASK, ::EVENT_XI1_MASK, ::EVENT_CORE_MASK, and
 *         ::EVENT_DONT_PROPAGATE_MASK.
 */
int
EventIsDeliverable(DeviceIntPtr dev, int evtype, WindowPtr win)
{
    int rc = 0;
    int filter = 0;
    int type;
    OtherInputMasks *inputMasks = wOtherInputMasks(win);

    if ((type = GetXI2Type(evtype)) != 0) {
        if (inputMasks && xi2mask_isset(inputMasks->xi2mask, dev, type))
            rc |= EVENT_XI2_MASK;
    }

    if ((type = GetXIType(evtype)) != 0) {
        filter = event_get_filter_from_type(dev, type);

        /* Check for XI mask */
        if (inputMasks &&
            (inputMasks->deliverableEvents[dev->id] & filter) &&
            (inputMasks->inputEvents[dev->id] & filter))
            rc |= EVENT_XI1_MASK;

        /* Check for XI DontPropagate mask */
        if (inputMasks && (inputMasks->dontPropagateMask[dev->id] & filter))
            rc |= EVENT_DONT_PROPAGATE_MASK;

    }

    if ((type = GetCoreType(evtype)) != 0) {
        filter = event_get_filter_from_type(dev, type);

        /* Check for core mask */
        if ((win->deliverableEvents & filter) &&
            ((wOtherEventMasks(win) | win->eventMask) & filter))
            rc |= EVENT_CORE_MASK;

        /* Check for core DontPropagate mask */
        if (filter & wDontPropagateMask(win))
            rc |= EVENT_DONT_PROPAGATE_MASK;
    }

    return rc;
}

static int
DeliverEvent(DeviceIntPtr dev, xEvent *xE, int count,
             WindowPtr win, Window child, GrabPtr grab)
{
    SpritePtr pSprite = dev->spriteInfo->sprite;
    Mask filter;
    int deliveries = 0;

    if (XaceHook(XACE_SEND_ACCESS, NULL, dev, win, xE, count) == Success) {
        filter = GetEventFilter(dev, xE);
        FixUpEventFromWindow(pSprite, xE, win, child, FALSE);
        deliveries = DeliverEventsToWindow(dev, win, xE, count, filter, grab);
    }

    return deliveries;
}

static int
DeliverOneEvent(InternalEvent *event, DeviceIntPtr dev, enum InputLevel level,
                WindowPtr win, Window child, GrabPtr grab)
{
    xEvent *xE = NULL;
    int count = 0;
    int deliveries = 0;
    int rc;

    switch (level) {
    case XI2:
        rc = EventToXI2(event, &xE);
        count = 1;
        break;
    case XI:
        rc = EventToXI(event, &xE, &count);
        break;
    case CORE:
        rc = EventToCore(event, &xE, &count);
        break;
    default:
        rc = BadImplementation;
        break;
    }

    if (rc == Success) {
        deliveries = DeliverEvent(dev, xE, count, win, child, grab);
        free(xE);
    }
    else
        BUG_WARN_MSG(rc != BadMatch,
                     "%s: conversion to level %d failed with rc %d\n",
                     dev->name, level, rc);
    return deliveries;
}

/**
 * Deliver events caused by input devices.
 *
 * For events from a non-grabbed, non-focus device, DeliverDeviceEvents is
 * called directly from the processInputProc.
 * For grabbed devices, DeliverGrabbedEvent is called first, and _may_ call
 * DeliverDeviceEvents.
 * For focused events, DeliverFocusedEvent is called first, and _may_ call
 * DeliverDeviceEvents.
 *
 * @@param pWin Window to deliver event to.
 * @@param event The events to deliver, not yet in wire format.
 * @@param grab Possible grab on a device.
 * @@param stopAt Don't recurse up to the root window.
 * @@param dev The device that is responsible for the event.
 *
 * @@see DeliverGrabbedEvent
 * @@see DeliverFocusedEvent
 */
int
DeliverDeviceEvents(WindowPtr pWin, InternalEvent *event, GrabPtr grab,
                    WindowPtr stopAt, DeviceIntPtr dev)
{
    Window child = None;
    int deliveries = 0;
    int mask;

    verify_internal_event(event);

    while (pWin) {
        if ((mask = EventIsDeliverable(dev, event->any.type, pWin))) {
            /* XI2 events first */
            if (mask & EVENT_XI2_MASK) {
                deliveries =
                    DeliverOneEvent(event, dev, XI2, pWin, child, grab);
                if (deliveries > 0)
                    break;
            }

            /* XI events */
            if (mask & EVENT_XI1_MASK) {
                deliveries = DeliverOneEvent(event, dev, XI, pWin, child, grab);
                if (deliveries > 0)
                    break;
            }

            /* Core event */
            if ((mask & EVENT_CORE_MASK) && IsMaster(dev) && dev->coreEvents) {
                deliveries =
                    DeliverOneEvent(event, dev, CORE, pWin, child, grab);
                if (deliveries > 0)
                    break;
            }

        }

        if ((deliveries < 0) || (pWin == stopAt) ||
            (mask & EVENT_DONT_PROPAGATE_MASK)) {
            deliveries = 0;
            break;
        }

        child = pWin->drawable.id;
        pWin = pWin->parent;
    }

    return deliveries;
}

/**
 * Deliver event to a window and it's immediate parent. Used for most window
 * events (CreateNotify, ConfigureNotify, etc.). Not useful for events that
 * propagate up the tree or extension events
 *
 * In case of a ReparentNotify event, the event will be delivered to the
 * otherParent as well.
 *
 * @@param pWin Window to deliver events to.
 * @@param xE Events to deliver.
 * @@param count number of events in xE.
 * @@param otherParent Used for ReparentNotify events.
 */
int
DeliverEvents(WindowPtr pWin, xEvent *xE, int count, WindowPtr otherParent)
{
    DeviceIntRec dummy;
    int deliveries;

#ifdef PANORAMIX
    if (!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
        return count;
#endif

    if (!count)
        return 0;

    dummy.id = XIAllDevices;

    switch (xE->u.u.type) {
    case DestroyNotify:
    case UnmapNotify:
    case MapNotify:
    case MapRequest:
    case ReparentNotify:
    case ConfigureNotify:
    case ConfigureRequest:
    case GravityNotify:
    case CirculateNotify:
    case CirculateRequest:
        xE->u.destroyNotify.event = pWin->drawable.id;
        break;
    }

    switch (xE->u.u.type) {
    case DestroyNotify:
    case UnmapNotify:
    case MapNotify:
    case ReparentNotify:
    case ConfigureNotify:
    case GravityNotify:
    case CirculateNotify:
        break;
    default:
    {
        Mask filter;

        filter = GetEventFilter(&dummy, xE);
        return DeliverEventsToWindow(&dummy, pWin, xE, count, filter, NullGrab);
    }
    }

    deliveries = DeliverEventsToWindow(&dummy, pWin, xE, count,
                                       StructureNotifyMask, NullGrab);
    if (pWin->parent) {
        xE->u.destroyNotify.event = pWin->parent->drawable.id;
        deliveries += DeliverEventsToWindow(&dummy, pWin->parent, xE, count,
                                            SubstructureNotifyMask, NullGrab);
        if (xE->u.u.type == ReparentNotify) {
            xE->u.destroyNotify.event = otherParent->drawable.id;
            deliveries += DeliverEventsToWindow(&dummy,
                                                otherParent, xE, count,
                                                SubstructureNotifyMask,
                                                NullGrab);
        }
    }
    return deliveries;
}

Bool
PointInBorderSize(WindowPtr pWin, int x, int y)
{
    BoxRec box;

    if (RegionContainsPoint(&pWin->borderSize, x, y, &box))
        return TRUE;

#ifdef PANORAMIX
    if (!noPanoramiXExtension &&
        XineramaSetWindowPntrs(inputInfo.pointer, pWin)) {
        SpritePtr pSprite = inputInfo.pointer->spriteInfo->sprite;
        int i;

        FOR_NSCREENS_FORWARD_SKIP(i) {
            if (RegionContainsPoint(&pSprite->windows[i]->borderSize,
                                    x + screenInfo.screens[0]->x -
                                    screenInfo.screens[i]->x,
                                    y + screenInfo.screens[0]->y -
                                    screenInfo.screens[i]->y, &box))
                return TRUE;
        }
    }
#endif
    return FALSE;
}

/**
 * Traversed from the root window to the window at the position x/y. While
 * traversing, it sets up the traversal history in the spriteTrace array.
 * After completing, the spriteTrace history is set in the following way:
 *   spriteTrace[0] ... root window
 *   spriteTrace[1] ... top level window that encloses x/y
 *       ...
 *   spriteTrace[spriteTraceGood - 1] ... window at x/y
 *
 * @@returns the window at the given coordinates.
 */
WindowPtr
XYToWindow(SpritePtr pSprite, int x, int y)
{
    ScreenPtr pScreen = RootWindow(pSprite)->drawable.pScreen;

    return (*pScreen->XYToWindow)(pScreen, pSprite, x, y);
}

/**
 * Ungrab a currently FocusIn grabbed device and grab the device on the
 * given window. If the win given is the NoneWin, the device is ungrabbed if
 * applicable and FALSE is returned.
 *
 * @@returns TRUE if the device has been grabbed, or FALSE otherwise.
 */
BOOL
ActivateFocusInGrab(DeviceIntPtr dev, WindowPtr old, WindowPtr win)
{
    BOOL rc = FALSE;
    DeviceEvent event;

    if (dev->deviceGrab.grab) {
        if (!dev->deviceGrab.fromPassiveGrab ||
            dev->deviceGrab.grab->type != XI_Enter ||
            dev->deviceGrab.grab->window == win ||
            IsParent(dev->deviceGrab.grab->window, win))
            return FALSE;
        DoEnterLeaveEvents(dev, dev->id, old, win, XINotifyPassiveUngrab);
        (*dev->deviceGrab.DeactivateGrab) (dev);
    }

    if (win == NoneWin || win == PointerRootWin)
        return FALSE;

    event = (DeviceEvent) {
        .header = ET_Internal,
        .type = ET_FocusIn,
        .length = sizeof(DeviceEvent),
        .time = GetTimeInMillis(),
        .deviceid = dev->id,
        .sourceid = dev->id,
        .detail.button = 0
    };
    rc = (CheckPassiveGrabsOnWindow(win, dev, (InternalEvent *) &event, FALSE,
                                    TRUE) != NULL);
    if (rc)
        DoEnterLeaveEvents(dev, dev->id, old, win, XINotifyPassiveUngrab);
    return rc;
}

/**
 * Ungrab a currently Enter grabbed device and grab the device for the given
 * window.
 *
 * @@returns TRUE if the device has been grabbed, or FALSE otherwise.
 */
static BOOL
ActivateEnterGrab(DeviceIntPtr dev, WindowPtr old, WindowPtr win)
{
    BOOL rc = FALSE;
    DeviceEvent event;

    if (dev->deviceGrab.grab) {
        if (!dev->deviceGrab.fromPassiveGrab ||
            dev->deviceGrab.grab->type != XI_Enter ||
            dev->deviceGrab.grab->window == win ||
            IsParent(dev->deviceGrab.grab->window, win))
            return FALSE;
        DoEnterLeaveEvents(dev, dev->id, old, win, XINotifyPassiveUngrab);
        (*dev->deviceGrab.DeactivateGrab) (dev);
    }

    event = (DeviceEvent) {
        .header = ET_Internal,
        .type = ET_Enter,
        .length = sizeof(DeviceEvent),
        .time = GetTimeInMillis(),
        .deviceid = dev->id,
        .sourceid = dev->id,
        .detail.button = 0
    };
    rc = (CheckPassiveGrabsOnWindow(win, dev, (InternalEvent *) &event, FALSE,
                                    TRUE) != NULL);
    if (rc)
        DoEnterLeaveEvents(dev, dev->id, old, win, XINotifyPassiveGrab);
    return rc;
}

/**
 * Update the sprite coordinates based on the event. Update the cursor
 * position, then update the event with the new coordinates that may have been
 * changed. If the window underneath the sprite has changed, change to new
 * cursor and send enter/leave events.
 *
 * CheckMotion() will not do anything and return FALSE if the event is not a
 * pointer event.
 *
 * @@return TRUE if the sprite has moved or FALSE otherwise.
 */
Bool
CheckMotion(DeviceEvent *ev, DeviceIntPtr pDev)
{
    WindowPtr prevSpriteWin, newSpriteWin;
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    verify_internal_event((InternalEvent *) ev);

    prevSpriteWin = pSprite->win;

    if (ev && !syncEvents.playingEvents) {
        /* GetPointerEvents() guarantees that pointer events have the correct
           rootX/Y set already. */
        switch (ev->type) {
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_Motion:
        case ET_TouchBegin:
        case ET_TouchUpdate:
        case ET_TouchEnd:
            break;
        default:
            /* all other events return FALSE */
            return FALSE;
        }

#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            /* Motion events entering DIX get translated to Screen 0
               coordinates.  Replayed events have already been
               translated since they've entered DIX before */
            ev->root_x += pSprite->screen->x - screenInfo.screens[0]->x;
            ev->root_y += pSprite->screen->y - screenInfo.screens[0]->y;
        }
        else
#endif
        {
            if (pSprite->hot.pScreen != pSprite->hotPhys.pScreen) {
                pSprite->hot.pScreen = pSprite->hotPhys.pScreen;
                RootWindow(pDev->spriteInfo->sprite) =
                    pSprite->hot.pScreen->root;
            }
        }

        pSprite->hot.x = ev->root_x;
        pSprite->hot.y = ev->root_y;
        if (pSprite->hot.x < pSprite->physLimits.x1)
            pSprite->hot.x = pSprite->physLimits.x1;
        else if (pSprite->hot.x >= pSprite->physLimits.x2)
            pSprite->hot.x = pSprite->physLimits.x2 - 1;
        if (pSprite->hot.y < pSprite->physLimits.y1)
            pSprite->hot.y = pSprite->physLimits.y1;
        else if (pSprite->hot.y >= pSprite->physLimits.y2)
            pSprite->hot.y = pSprite->physLimits.y2 - 1;
        if (pSprite->hotShape)
            ConfineToShape(pDev, pSprite->hotShape, &pSprite->hot.x,
                           &pSprite->hot.y);
        pSprite->hotPhys = pSprite->hot;

        if ((pSprite->hotPhys.x != ev->root_x) ||
            (pSprite->hotPhys.y != ev->root_y)) {
#ifdef PANORAMIX
            if (!noPanoramiXExtension) {
                XineramaSetCursorPosition(pDev, pSprite->hotPhys.x,
                                          pSprite->hotPhys.y, FALSE);
            }
            else
#endif
            {
                (*pSprite->hotPhys.pScreen->SetCursorPosition) (pDev,
                                                                pSprite->
                                                                hotPhys.pScreen,
                                                                pSprite->
                                                                hotPhys.x,
                                                                pSprite->
                                                                hotPhys.y,
                                                                FALSE);
            }
        }

        ev->root_x = pSprite->hot.x;
        ev->root_y = pSprite->hot.y;
    }

    newSpriteWin = XYToWindow(pSprite, pSprite->hot.x, pSprite->hot.y);

    if (newSpriteWin != prevSpriteWin) {
        int sourceid;

        if (!ev) {
            UpdateCurrentTimeIf();
            sourceid = pDev->id;        /* when from WindowsRestructured */
        }
        else
            sourceid = ev->sourceid;

        if (prevSpriteWin != NullWindow) {
            if (!ActivateEnterGrab(pDev, prevSpriteWin, newSpriteWin))
                DoEnterLeaveEvents(pDev, sourceid, prevSpriteWin,
                                   newSpriteWin, NotifyNormal);
        }
        /* set pSprite->win after ActivateEnterGrab, otherwise
           sprite window == grab_window and no enter/leave events are
           sent. */
        pSprite->win = newSpriteWin;
        PostNewCursor(pDev);
        return FALSE;
    }
    return TRUE;
}

/**
 * Windows have restructured, we need to update the sprite position and the
 * sprite's cursor.
 */
void
WindowsRestructured(void)
{
    DeviceIntPtr pDev = inputInfo.devices;

    while (pDev) {
        if (IsMaster(pDev) || IsFloating(pDev))
            CheckMotion(NULL, pDev);
        pDev = pDev->next;
    }
}

#ifdef PANORAMIX
/* This was added to support reconfiguration under Xdmx.  The problem is
 * that if the 0th screen (i.e., screenInfo.screens[0]) is moved to an origin
 * other than 0,0, the information in the private sprite structure must
 * be updated accordingly, or XYToWindow (and other routines) will not
 * compute correctly. */
void
ReinitializeRootWindow(WindowPtr win, int xoff, int yoff)
{
    GrabPtr grab;
    DeviceIntPtr pDev;
    SpritePtr pSprite;

    if (noPanoramiXExtension)
        return;

    pDev = inputInfo.devices;
    while (pDev) {
        if (DevHasCursor(pDev)) {
            pSprite = pDev->spriteInfo->sprite;
            pSprite->hot.x -= xoff;
            pSprite->hot.y -= yoff;

            pSprite->hotPhys.x -= xoff;
            pSprite->hotPhys.y -= yoff;

            pSprite->hotLimits.x1 -= xoff;
            pSprite->hotLimits.y1 -= yoff;
            pSprite->hotLimits.x2 -= xoff;
            pSprite->hotLimits.y2 -= yoff;

            if (RegionNotEmpty(&pSprite->Reg1))
                RegionTranslate(&pSprite->Reg1, xoff, yoff);
            if (RegionNotEmpty(&pSprite->Reg2))
                RegionTranslate(&pSprite->Reg2, xoff, yoff);

            /* FIXME: if we call ConfineCursorToWindow, must we do anything else? */
            if ((grab = pDev->deviceGrab.grab) && grab->confineTo) {
                if (grab->confineTo->drawable.pScreen
                    != pSprite->hotPhys.pScreen)
                    pSprite->hotPhys.x = pSprite->hotPhys.y = 0;
                ConfineCursorToWindow(pDev, grab->confineTo, TRUE, TRUE);
            }
            else
                ConfineCursorToWindow(pDev,
                                      pSprite->hotPhys.pScreen->root,
                                      TRUE, FALSE);

        }
        pDev = pDev->next;
    }
}
#endif

/**
 * Initialize a sprite for the given device and set it to some sane values. If
 * the device already has a sprite alloc'd, don't realloc but just reset to
 * default values.
 * If a window is supplied, the sprite will be initialized with the window's
 * cursor and positioned in the center of the window's screen. The root window
 * is a good choice to pass in here.
 *
 * It's a good idea to call it only for pointer devices, unless you have a
 * really talented keyboard.
 *
 * @@param pDev The device to initialize.
 * @@param pWin The window where to generate the sprite in.
 *
 */
void
InitializeSprite(DeviceIntPtr pDev, WindowPtr pWin)
{
    SpritePtr pSprite;
    ScreenPtr pScreen;
    CursorPtr pCursor;

    if (!pDev->spriteInfo->sprite) {
        DeviceIntPtr it;

        pDev->spriteInfo->sprite = (SpritePtr) calloc(1, sizeof(SpriteRec));
        if (!pDev->spriteInfo->sprite)
            FatalError("InitializeSprite: failed to allocate sprite struct");

        /* We may have paired another device with this device before our
         * device had a actual sprite. We need to check for this and reset the
         * sprite field for all paired devices.
         *
         * The VCK is always paired with the VCP before the VCP has a sprite.
         */
        for (it = inputInfo.devices; it; it = it->next) {
            if (it->spriteInfo->paired == pDev)
                it->spriteInfo->sprite = pDev->spriteInfo->sprite;
        }
        if (inputInfo.keyboard->spriteInfo->paired == pDev)
            inputInfo.keyboard->spriteInfo->sprite = pDev->spriteInfo->sprite;
    }

    pSprite = pDev->spriteInfo->sprite;
    pDev->spriteInfo->spriteOwner = TRUE;

    pScreen = (pWin) ? pWin->drawable.pScreen : (ScreenPtr) NULL;
    pSprite->hot.pScreen = pScreen;
    pSprite->hotPhys.pScreen = pScreen;
    if (pScreen) {
        pSprite->hotPhys.x = pScreen->width / 2;
        pSprite->hotPhys.y = pScreen->height / 2;
        pSprite->hotLimits.x2 = pScreen->width;
        pSprite->hotLimits.y2 = pScreen->height;
    }

    pSprite->hot = pSprite->hotPhys;
    pSprite->win = pWin;

    if (pWin) {
        pCursor = wCursor(pWin);
        pSprite->spriteTrace = (WindowPtr *) calloc(1, 32 * sizeof(WindowPtr));
        if (!pSprite->spriteTrace)
            FatalError("Failed to allocate spriteTrace");
        pSprite->spriteTraceSize = 32;

        RootWindow(pDev->spriteInfo->sprite) = pWin;
        pSprite->spriteTraceGood = 1;

        pSprite->pEnqueueScreen = pScreen;
        pSprite->pDequeueScreen = pSprite->pEnqueueScreen;

    }
    else {
        pCursor = NullCursor;
        pSprite->spriteTrace = NULL;
        pSprite->spriteTraceSize = 0;
        pSprite->spriteTraceGood = 0;
        pSprite->pEnqueueScreen = screenInfo.screens[0];
        pSprite->pDequeueScreen = pSprite->pEnqueueScreen;
    }
    pCursor = RefCursor(pCursor);
    if (pSprite->current)
        FreeCursor(pSprite->current, None);
    pSprite->current = pCursor;

    if (pScreen) {
        (*pScreen->RealizeCursor) (pDev, pScreen, pSprite->current);
        (*pScreen->CursorLimits) (pDev, pScreen, pSprite->current,
                                  &pSprite->hotLimits, &pSprite->physLimits);
        pSprite->confined = FALSE;

        (*pScreen->ConstrainCursor) (pDev, pScreen, &pSprite->physLimits);
        (*pScreen->SetCursorPosition) (pDev, pScreen, pSprite->hot.x,
                                       pSprite->hot.y, FALSE);
        (*pScreen->DisplayCursor) (pDev, pScreen, pSprite->current);
    }
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        pSprite->hotLimits.x1 = -screenInfo.screens[0]->x;
        pSprite->hotLimits.y1 = -screenInfo.screens[0]->y;
        pSprite->hotLimits.x2 = PanoramiXPixWidth - screenInfo.screens[0]->x;
        pSprite->hotLimits.y2 = PanoramiXPixHeight - screenInfo.screens[0]->y;
        pSprite->physLimits = pSprite->hotLimits;
        pSprite->confineWin = NullWindow;
        pSprite->hotShape = NullRegion;
        pSprite->screen = pScreen;
        /* gotta UNINIT these someplace */
        RegionNull(&pSprite->Reg1);
        RegionNull(&pSprite->Reg2);
    }
#endif
}

void FreeSprite(DeviceIntPtr dev)
{
    if (DevHasCursor(dev) && dev->spriteInfo->sprite) {
        if (dev->spriteInfo->sprite->current)
            FreeCursor(dev->spriteInfo->sprite->current, None);
        free(dev->spriteInfo->sprite->spriteTrace);
        free(dev->spriteInfo->sprite);
    }
    dev->spriteInfo->sprite = NULL;
}


/**
 * Update the mouse sprite info when the server switches from a pScreen to another.
 * Otherwise, the pScreen of the mouse sprite is never updated when we switch
 * from a pScreen to another. Never updating the pScreen of the mouse sprite
 * implies that windows that are in pScreen whose pScreen->myNum >0 will never
 * get pointer events. This is  because in CheckMotion(), sprite.hotPhys.pScreen
 * always points to the first pScreen it has been set by
 * DefineInitialRootWindow().
 *
 * Calling this function is useful for use cases where the server
 * has more than one pScreen.
 * This function is similar to DefineInitialRootWindow() but it does not
 * reset the mouse pointer position.
 * @@param win must be the new pScreen we are switching to.
 */
void
UpdateSpriteForScreen(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    SpritePtr pSprite = NULL;
    WindowPtr win = NULL;
    CursorPtr pCursor;

    if (!pScreen)
        return;

    if (!pDev->spriteInfo->sprite)
        return;

    pSprite = pDev->spriteInfo->sprite;

    win = pScreen->root;

    pSprite->hotPhys.pScreen = pScreen;
    pSprite->hot = pSprite->hotPhys;
    pSprite->hotLimits.x2 = pScreen->width;
    pSprite->hotLimits.y2 = pScreen->height;
    pSprite->win = win;
    pCursor = RefCursor(wCursor(win));
    if (pSprite->current)
        FreeCursor(pSprite->current, 0);
    pSprite->current = pCursor;
    pSprite->spriteTraceGood = 1;
    pSprite->spriteTrace[0] = win;
    (*pScreen->CursorLimits) (pDev,
                              pScreen,
                              pSprite->current,
                              &pSprite->hotLimits, &pSprite->physLimits);
    pSprite->confined = FALSE;
    (*pScreen->ConstrainCursor) (pDev, pScreen, &pSprite->physLimits);
    (*pScreen->DisplayCursor) (pDev, pScreen, pSprite->current);

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        pSprite->hotLimits.x1 = -screenInfo.screens[0]->x;
        pSprite->hotLimits.y1 = -screenInfo.screens[0]->y;
        pSprite->hotLimits.x2 = PanoramiXPixWidth - screenInfo.screens[0]->x;
        pSprite->hotLimits.y2 = PanoramiXPixHeight - screenInfo.screens[0]->y;
        pSprite->physLimits = pSprite->hotLimits;
        pSprite->screen = pScreen;
    }
#endif
}

/*
 * This does not take any shortcuts, and even ignores its argument, since
 * it does not happen very often, and one has to walk up the tree since
 * this might be a newly instantiated cursor for an intermediate window
 * between the one the pointer is in and the one that the last cursor was
 * instantiated from.
 */
void
WindowHasNewCursor(WindowPtr pWin)
{
    DeviceIntPtr pDev;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if (DevHasCursor(pDev))
            PostNewCursor(pDev);
}

void
NewCurrentScreen(DeviceIntPtr pDev, ScreenPtr newScreen, int x, int y)
{
    DeviceIntPtr ptr;
    SpritePtr pSprite;

    ptr =
        IsFloating(pDev) ? pDev :
        GetXTestDevice(GetMaster(pDev, MASTER_POINTER));
    pSprite = ptr->spriteInfo->sprite;

    pSprite->hotPhys.x = x;
    pSprite->hotPhys.y = y;
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        pSprite->hotPhys.x += newScreen->x - screenInfo.screens[0]->x;
        pSprite->hotPhys.y += newScreen->y - screenInfo.screens[0]->y;
        if (newScreen != pSprite->screen) {
            pSprite->screen = newScreen;
            /* Make sure we tell the DDX to update its copy of the screen */
            if (pSprite->confineWin)
                XineramaConfineCursorToWindow(ptr, pSprite->confineWin, TRUE);
            else
                XineramaConfineCursorToWindow(ptr, screenInfo.screens[0]->root,
                                              TRUE);
            /* if the pointer wasn't confined, the DDX won't get
               told of the pointer warp so we reposition it here */
            if (!syncEvents.playingEvents)
                (*pSprite->screen->SetCursorPosition) (ptr,
                                                       pSprite->screen,
                                                       pSprite->hotPhys.x +
                                                       screenInfo.screens[0]->
                                                       x - pSprite->screen->x,
                                                       pSprite->hotPhys.y +
                                                       screenInfo.screens[0]->
                                                       y - pSprite->screen->y,
                                                       FALSE);
        }
    }
    else
#endif
    if (newScreen != pSprite->hotPhys.pScreen)
        ConfineCursorToWindow(ptr, newScreen->root, TRUE, FALSE);
}

#ifdef PANORAMIX

static Bool
XineramaPointInWindowIsVisible(WindowPtr pWin, int x, int y)
{
    BoxRec box;
    int i, xoff, yoff;

    if (!pWin->realized)
        return FALSE;

    if (RegionContainsPoint(&pWin->borderClip, x, y, &box))
        return TRUE;

    if (!XineramaSetWindowPntrs(inputInfo.pointer, pWin))
         return FALSE;

    xoff = x + screenInfo.screens[0]->x;
    yoff = y + screenInfo.screens[0]->y;

    FOR_NSCREENS_FORWARD_SKIP(i) {
        pWin = inputInfo.pointer->spriteInfo->sprite->windows[i];

        x = xoff - screenInfo.screens[i]->x;
        y = yoff - screenInfo.screens[i]->y;

        if (RegionContainsPoint(&pWin->borderClip, x, y, &box)
            && (!wInputShape(pWin) ||
                RegionContainsPoint(wInputShape(pWin),
                                    x - pWin->drawable.x,
                                    y - pWin->drawable.y, &box)))
            return TRUE;

    }

    return FALSE;
}

static int
XineramaWarpPointer(ClientPtr client)
{
    WindowPtr dest = NULL;
    int x, y, rc;
    SpritePtr pSprite = PickPointer(client)->spriteInfo->sprite;

    REQUEST(xWarpPointerReq);

    if (stuff->dstWid != None) {
        rc = dixLookupWindow(&dest, stuff->dstWid, client, DixReadAccess);
        if (rc != Success)
            return rc;
    }
    x = pSprite->hotPhys.x;
    y = pSprite->hotPhys.y;

    if (stuff->srcWid != None) {
        int winX, winY;
        XID winID = stuff->srcWid;
        WindowPtr source;

        rc = dixLookupWindow(&source, winID, client, DixReadAccess);
        if (rc != Success)
            return rc;

        winX = source->drawable.x;
        winY = source->drawable.y;
        if (source == screenInfo.screens[0]->root) {
            winX -= screenInfo.screens[0]->x;
            winY -= screenInfo.screens[0]->y;
        }
        if (x < winX + stuff->srcX ||
            y < winY + stuff->srcY ||
            (stuff->srcWidth != 0 &&
             winX + stuff->srcX + (int) stuff->srcWidth < x) ||
            (stuff->srcHeight != 0 &&
             winY + stuff->srcY + (int) stuff->srcHeight < y) ||
            !XineramaPointInWindowIsVisible(source, x, y))
            return Success;
    }
    if (dest) {
        x = dest->drawable.x;
        y = dest->drawable.y;
        if (dest == screenInfo.screens[0]->root) {
            x -= screenInfo.screens[0]->x;
            y -= screenInfo.screens[0]->y;
        }
    }

    x += stuff->dstX;
    y += stuff->dstY;

    if (x < pSprite->physLimits.x1)
        x = pSprite->physLimits.x1;
    else if (x >= pSprite->physLimits.x2)
        x = pSprite->physLimits.x2 - 1;
    if (y < pSprite->physLimits.y1)
        y = pSprite->physLimits.y1;
    else if (y >= pSprite->physLimits.y2)
        y = pSprite->physLimits.y2 - 1;
    if (pSprite->hotShape)
        ConfineToShape(PickPointer(client), pSprite->hotShape, &x, &y);

    XineramaSetCursorPosition(PickPointer(client), x, y, TRUE);

    return Success;
}

#endif

/**
 * Server-side protocol handling for WarpPointer request.
 * Warps the cursor position to the coordinates given in the request.
 */
int
ProcWarpPointer(ClientPtr client)
{
    WindowPtr dest = NULL;
    int x, y, rc;
    ScreenPtr newScreen;
    DeviceIntPtr dev, tmp;
    SpritePtr pSprite;

    REQUEST(xWarpPointerReq);
    REQUEST_SIZE_MATCH(xWarpPointerReq);

    dev = PickPointer(client);

    for (tmp = inputInfo.devices; tmp; tmp = tmp->next) {
        if (GetMaster(tmp, MASTER_ATTACHED) == dev) {
            rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixWriteAccess);
            if (rc != Success)
                return rc;
        }
    }

    if (dev->lastSlave)
        dev = dev->lastSlave;
    pSprite = dev->spriteInfo->sprite;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        return XineramaWarpPointer(client);
#endif

    if (stuff->dstWid != None) {
        rc = dixLookupWindow(&dest, stuff->dstWid, client, DixGetAttrAccess);
        if (rc != Success)
            return rc;
    }
    x = pSprite->hotPhys.x;
    y = pSprite->hotPhys.y;

    if (stuff->srcWid != None) {
        int winX, winY;
        XID winID = stuff->srcWid;
        WindowPtr source;

        rc = dixLookupWindow(&source, winID, client, DixGetAttrAccess);
        if (rc != Success)
            return rc;

        winX = source->drawable.x;
        winY = source->drawable.y;
        if (source->drawable.pScreen != pSprite->hotPhys.pScreen ||
            x < winX + stuff->srcX ||
            y < winY + stuff->srcY ||
            (stuff->srcWidth != 0 &&
             winX + stuff->srcX + (int) stuff->srcWidth < x) ||
            (stuff->srcHeight != 0 &&
             winY + stuff->srcY + (int) stuff->srcHeight < y) ||
            !PointInWindowIsVisible(source, x, y))
            return Success;
    }
    if (dest) {
        x = dest->drawable.x;
        y = dest->drawable.y;
        newScreen = dest->drawable.pScreen;
    }
    else
        newScreen = pSprite->hotPhys.pScreen;

    x += stuff->dstX;
    y += stuff->dstY;

    if (x < 0)
        x = 0;
    else if (x >= newScreen->width)
        x = newScreen->width - 1;
    if (y < 0)
        y = 0;
    else if (y >= newScreen->height)
        y = newScreen->height - 1;

    if (newScreen == pSprite->hotPhys.pScreen) {
        if (x < pSprite->physLimits.x1)
            x = pSprite->physLimits.x1;
        else if (x >= pSprite->physLimits.x2)
            x = pSprite->physLimits.x2 - 1;
        if (y < pSprite->physLimits.y1)
            y = pSprite->physLimits.y1;
        else if (y >= pSprite->physLimits.y2)
            y = pSprite->physLimits.y2 - 1;
        if (pSprite->hotShape)
            ConfineToShape(dev, pSprite->hotShape, &x, &y);
        (*newScreen->SetCursorPosition) (dev, newScreen, x, y, TRUE);
    }
    else if (!PointerConfinedToScreen(dev)) {
        NewCurrentScreen(dev, newScreen, x, y);
    }
    return Success;
}

static Bool
BorderSizeNotEmpty(DeviceIntPtr pDev, WindowPtr pWin)
{
    if (RegionNotEmpty(&pWin->borderSize))
        return TRUE;

#ifdef PANORAMIX
    if (!noPanoramiXExtension && XineramaSetWindowPntrs(pDev, pWin)) {
        int i;

        FOR_NSCREENS_FORWARD_SKIP(i) {
            if (RegionNotEmpty
                (&pDev->spriteInfo->sprite->windows[i]->borderSize))
                return TRUE;
        }
    }
#endif
    return FALSE;
}

/**
 * Activate the given passive grab. If the grab is activated successfully, the
 * event has been delivered to the client.
 *
 * @@param device The device of the event to check.
 * @@param grab The grab to check.
 * @@param event The current device event.
 * @@param real_event The original event, in case of touch emulation. The
 * real event is the one stored in the sync queue.
 *
 * @@return Whether the grab has been activated.
 */
Bool
ActivatePassiveGrab(DeviceIntPtr device, GrabPtr grab, InternalEvent *event,
                    InternalEvent *real_event)
{
    SpritePtr pSprite = device->spriteInfo->sprite;
    GrabInfoPtr grabinfo = &device->deviceGrab;
    xEvent *xE = NULL;
    int count;
    int rc;

    /* The only consumers of corestate are Xi 1.x and core events, which
     * are guaranteed to come from DeviceEvents. */
    if (grab->grabtype == XI || grab->grabtype == CORE) {
        DeviceIntPtr gdev;

        event->device_event.corestate &= 0x1f00;

        if (grab->grabtype == CORE)
            gdev = GetMaster(device, KEYBOARD_OR_FLOAT);
        else
            gdev = grab->modifierDevice;

        if (gdev && gdev->key && gdev->key->xkbInfo)
            event->device_event.corestate |=
                gdev->key->xkbInfo->state.grab_mods & (~0x1f00);
    }

    if (grab->grabtype == CORE) {
        rc = EventToCore(event, &xE, &count);
        if (rc != Success) {
            BUG_WARN_MSG(rc != BadMatch, "[dix] %s: core conversion failed"
                         "(%d, %d).\n", device->name, event->any.type, rc);
            return FALSE;
        }
    }
    else if (grab->grabtype == XI2) {
        rc = EventToXI2(event, &xE);
        if (rc != Success) {
            if (rc != BadMatch)
                BUG_WARN_MSG(rc != BadMatch, "[dix] %s: XI2 conversion failed"
                             "(%d, %d).\n", device->name, event->any.type, rc);
            return FALSE;
        }
        count = 1;
    }
    else {
        rc = EventToXI(event, &xE, &count);
        if (rc != Success) {
            if (rc != BadMatch)
                BUG_WARN_MSG(rc != BadMatch, "[dix] %s: XI conversion failed"
                             "(%d, %d).\n", device->name, event->any.type, rc);
            return FALSE;
        }
    }

    (*grabinfo->ActivateGrab) (device, grab,
                               ClientTimeToServerTime(event->any.time), TRUE);

    if (xE) {
        FixUpEventFromWindow(pSprite, xE, grab->window, None, TRUE);

        /* XXX: XACE? */
        TryClientEvents(rClient(grab), device, xE, count,
                        GetEventFilter(device, xE),
                        GetEventFilter(device, xE), grab);
    }

    if (grabinfo->sync.state == FROZEN_NO_EVENT)
        grabinfo->sync.state = FROZEN_WITH_EVENT;
    *grabinfo->sync.event = real_event->device_event;

    free(xE);
    return TRUE;
}

static BOOL
CoreGrabInterferes(DeviceIntPtr device, GrabPtr grab)
{
    DeviceIntPtr other;
    BOOL interfering = FALSE;

    for (other = inputInfo.devices; other; other = other->next) {
        GrabPtr othergrab = other->deviceGrab.grab;

        if (othergrab && othergrab->grabtype == CORE &&
            SameClient(grab, rClient(othergrab)) &&
            ((IsPointerDevice(grab->device) &&
              IsPointerDevice(othergrab->device)) ||
             (IsKeyboardDevice(grab->device) &&
              IsKeyboardDevice(othergrab->device)))) {
            interfering = TRUE;
            break;
        }
    }

    return interfering;
}

enum MatchFlags {
    NO_MATCH = 0x0,
    CORE_MATCH = 0x1,
    XI_MATCH = 0x2,
    XI2_MATCH = 0x4,
};

/**
 * Match the grab against the temporary grab on the given input level.
 * Modifies the temporary grab pointer.
 *
 * @@param grab The grab to match against
 * @@param tmp The temporary grab to use for matching
 * @@param level The input level we want to match on
 * @@param event_type Wire protocol event type
 *
 * @@return The respective matched flag or 0 for no match
 */
static enum MatchFlags
MatchForType(const GrabPtr grab, GrabPtr tmp, enum InputLevel level,
             int event_type)
{
    enum MatchFlags match;
    BOOL ignore_device = FALSE;
    int grabtype;
    int evtype;

    switch (level) {
    case XI2:
        grabtype = XI2;
        evtype = GetXI2Type(event_type);
        BUG_WARN(!evtype);
        match = XI2_MATCH;
        break;
    case XI:
        grabtype = XI;
        evtype = GetXIType(event_type);
        match = XI_MATCH;
        break;
    case CORE:
        grabtype = CORE;
        evtype = GetCoreType(event_type);
        match = CORE_MATCH;
        ignore_device = TRUE;
        break;
    default:
        return NO_MATCH;
    }

    tmp->grabtype = grabtype;
    tmp->type = evtype;

    if (tmp->type && GrabMatchesSecond(tmp, grab, ignore_device))
        return match;

    return NO_MATCH;
}

/**
 * Check an individual grab against an event to determine if a passive grab
 * should be activated.
 *
 * @@param device The device of the event to check.
 * @@param grab The grab to check.
 * @@param event The current device event.
 * @@param checkCore Check for core grabs too.
 * @@param tempGrab A pre-allocated temporary grab record for matching. This
 *        must have the window and device values filled in.
 *
 * @@return Whether the grab matches the event.
 */
static Bool
CheckPassiveGrab(DeviceIntPtr device, GrabPtr grab, InternalEvent *event,
                 Bool checkCore, GrabPtr tempGrab)
{
    DeviceIntPtr gdev;
    XkbSrvInfoPtr xkbi = NULL;
    enum MatchFlags match = 0;
    int emulated_type = 0;

    gdev = grab->modifierDevice;
    if (grab->grabtype == CORE) {
        gdev = GetMaster(device, KEYBOARD_OR_FLOAT);
    }
    else if (grab->grabtype == XI2) {
        /* if the device is an attached slave device, gdev must be the
         * attached master keyboard. Since the slave may have been
         * reattached after the grab, the modifier device may not be the
         * same. */
        if (!IsMaster(grab->device) && !IsFloating(device))
            gdev = GetMaster(device, MASTER_KEYBOARD);
    }

    if (gdev && gdev->key)
        xkbi = gdev->key->xkbInfo;
    tempGrab->modifierDevice = grab->modifierDevice;
    tempGrab->modifiersDetail.exact = xkbi ? xkbi->state.grab_mods : 0;

    /* Check for XI2 and XI grabs first */
    match = MatchForType(grab, tempGrab, XI2, event->any.type);

    if (!match && IsTouchEvent(event) &&
        (event->device_event.flags & TOUCH_POINTER_EMULATED)) {
        emulated_type = TouchGetPointerEventType(event);
        match = MatchForType(grab, tempGrab, XI2, emulated_type);
    }

    if (!match)
        match = MatchForType(grab, tempGrab, XI, event->any.type);

    if (!match && emulated_type)
        match = MatchForType(grab, tempGrab, XI, emulated_type);

    if (!match && checkCore) {
        match = MatchForType(grab, tempGrab, CORE, event->any.type);
        if (!match && emulated_type)
            match = MatchForType(grab, tempGrab, CORE, emulated_type);
    }

    if (!match || (grab->confineTo &&
                   (!grab->confineTo->realized ||
                    !BorderSizeNotEmpty(device, grab->confineTo))))
        return FALSE;

    /* In some cases a passive core grab may exist, but the client
     * already has a core grab on some other device. In this case we
     * must not get the grab, otherwise we may never ungrab the
     * device.
     */

    if (grab->grabtype == CORE) {
        /* A passive grab may have been created for a different device
           than it is assigned to at this point in time.
           Update the grab's device and modifier device to reflect the
           current state.
           Since XGrabDeviceButton requires to specify the
           modifierDevice explicitly, we don't override this choice.
         */
        if (grab->type < GenericEvent) {
            grab->device = device;
            grab->modifierDevice = GetMaster(device, MASTER_KEYBOARD);
        }

        if (CoreGrabInterferes(device, grab))
            return FALSE;
    }

    return TRUE;
}

/**
 * "CheckPassiveGrabsOnWindow" checks to see if the event passed in causes a
 * passive grab set on the window to be activated.
 * If activate is true and a passive grab is found, it will be activated,
 * and the event will be delivered to the client.
 *
 * @@param pWin The window that may be subject to a passive grab.
 * @@param device Device that caused the event.
 * @@param event The current device event.
 * @@param checkCore Check for core grabs too.
 * @@param activate If a grab is found, activate it and deliver the event.
 */

GrabPtr
CheckPassiveGrabsOnWindow(WindowPtr pWin,
                          DeviceIntPtr device,
                          InternalEvent *event, BOOL checkCore, BOOL activate)
{
    GrabPtr grab = wPassiveGrabs(pWin);
    GrabPtr tempGrab;

    if (!grab)
        return NULL;

    tempGrab = AllocGrab(NULL);
    if (tempGrab == NULL)
        return NULL;

    /* Fill out the grab details, but leave the type for later before
     * comparing */
    switch (event->any.type) {
    case ET_KeyPress:
    case ET_KeyRelease:
        tempGrab->detail.exact = event->device_event.detail.key;
        break;
    case ET_ButtonPress:
    case ET_ButtonRelease:
    case ET_TouchBegin:
    case ET_TouchEnd:
        tempGrab->detail.exact = event->device_event.detail.button;
        break;
    default:
        tempGrab->detail.exact = 0;
        break;
    }
    tempGrab->window = pWin;
    tempGrab->device = device;
    tempGrab->detail.pMask = NULL;
    tempGrab->modifiersDetail.pMask = NULL;
    tempGrab->next = NULL;

    for (; grab; grab = grab->next) {
        if (!CheckPassiveGrab(device, grab, event, checkCore, tempGrab))
            continue;

        if (activate && !ActivatePassiveGrab(device, grab, event, event))
            continue;

        break;
    }

    FreeGrab(tempGrab);
    return grab;
}

/**
 * CheckDeviceGrabs handles both keyboard and pointer events that may cause
 * a passive grab to be activated.
 *
 * If the event is a keyboard event, the ancestors of the focus window are
 * traced down and tried to see if they have any passive grabs to be
 * activated.  If the focus window itself is reached and it's descendants
 * contain the pointer, the ancestors of the window that the pointer is in
 * are then traced down starting at the focus window, otherwise no grabs are
 * activated.
 * If the event is a pointer event, the ancestors of the window that the
 * pointer is in are traced down starting at the root until CheckPassiveGrabs
 * causes a passive grab to activate or all the windows are
 * tried. PRH
 *
 * If a grab is activated, the event has been sent to the client already!
 *
 * The event we pass in must always be an XI event. From this, we then emulate
 * the core event and then check for grabs.
 *
 * @@param device The device that caused the event.
 * @@param xE The event to handle (Device{Button|Key}Press).
 * @@param count Number of events in list.
 * @@return TRUE if a grab has been activated or false otherwise.
*/

Bool
CheckDeviceGrabs(DeviceIntPtr device, DeviceEvent *event, WindowPtr ancestor)
{
    int i;
    WindowPtr pWin = NULL;
    FocusClassPtr focus =
        IsPointerEvent((InternalEvent *) event) ? NULL : device->focus;
    BOOL sendCore = (IsMaster(device) && device->coreEvents);
    Bool ret = FALSE;

    if (event->type != ET_ButtonPress && event->type != ET_KeyPress)
        return FALSE;

    if (event->type == ET_ButtonPress && (device->button->buttonsDown != 1))
        return FALSE;

    if (device->deviceGrab.grab)
        return FALSE;

    i = 0;
    if (ancestor) {
        while (i < device->spriteInfo->sprite->spriteTraceGood)
            if (device->spriteInfo->sprite->spriteTrace[i++] == ancestor)
                break;
        if (i == device->spriteInfo->sprite->spriteTraceGood)
            goto out;
    }

    if (focus) {
        for (; i < focus->traceGood; i++) {
            pWin = focus->trace[i];
            if (CheckPassiveGrabsOnWindow(pWin, device, (InternalEvent *) event,
                                          sendCore, TRUE)) {
                ret = TRUE;
                goto out;
            }
        }

        if ((focus->win == NoneWin) ||
            (i >= device->spriteInfo->sprite->spriteTraceGood) ||
            (pWin && pWin != device->spriteInfo->sprite->spriteTrace[i - 1]))
            goto out;
    }

    for (; i < device->spriteInfo->sprite->spriteTraceGood; i++) {
        pWin = device->spriteInfo->sprite->spriteTrace[i];
        if (CheckPassiveGrabsOnWindow(pWin, device, (InternalEvent *) event,
                                      sendCore, TRUE)) {
            ret = TRUE;
            goto out;
        }
    }

 out:
    if (ret == TRUE && event->type == ET_KeyPress)
        device->deviceGrab.activatingKey = event->detail.key;
    return ret;
}

/**
 * Called for keyboard events to deliver event to whatever client owns the
 * focus.
 *
 * The event is delivered to the keyboard's focus window, the root window or
 * to the window owning the input focus.
 *
 * @@param keybd The keyboard originating the event.
 * @@param event The event, not yet in wire format.
 * @@param window Window underneath the sprite.
 */
void
DeliverFocusedEvent(DeviceIntPtr keybd, InternalEvent *event, WindowPtr window)
{
    DeviceIntPtr ptr;
    WindowPtr focus = keybd->focus->win;
    BOOL sendCore = (IsMaster(keybd) && keybd->coreEvents);
    xEvent *core = NULL, *xE = NULL, *xi2 = NULL;
    int count, rc;
    int deliveries = 0;

    if (focus == FollowKeyboardWin)
        focus = inputInfo.keyboard->focus->win;
    if (!focus)
        return;
    if (focus == PointerRootWin) {
        DeliverDeviceEvents(window, event, NullGrab, NullWindow, keybd);
        return;
    }
    if ((focus == window) || IsParent(focus, window)) {
        if (DeliverDeviceEvents(window, event, NullGrab, focus, keybd))
            return;
    }

    /* just deliver it to the focus window */
    ptr = GetMaster(keybd, POINTER_OR_FLOAT);

    rc = EventToXI2(event, &xi2);
    if (rc == Success) {
        /* XXX: XACE */
        int filter = GetEventFilter(keybd, xi2);

        FixUpEventFromWindow(ptr->spriteInfo->sprite, xi2, focus, None, FALSE);
        deliveries = DeliverEventsToWindow(keybd, focus, xi2, 1,
                                           filter, NullGrab);
        if (deliveries > 0)
            goto unwind;
    }
    else if (rc != BadMatch)
        ErrorF
            ("[dix] %s: XI2 conversion failed in DFE (%d, %d). Skipping delivery.\n",
             keybd->name, event->any.type, rc);

    rc = EventToXI(event, &xE, &count);
    if (rc == Success &&
        XaceHook(XACE_SEND_ACCESS, NULL, keybd, focus, xE, count) == Success) {
        FixUpEventFromWindow(ptr->spriteInfo->sprite, xE, focus, None, FALSE);
        deliveries = DeliverEventsToWindow(keybd, focus, xE, count,
                                           GetEventFilter(keybd, xE), NullGrab);

        if (deliveries > 0)
            goto unwind;
    }
    else if (rc != BadMatch)
        ErrorF
            ("[dix] %s: XI conversion failed in DFE (%d, %d). Skipping delivery.\n",
             keybd->name, event->any.type, rc);

    if (sendCore) {
        rc = EventToCore(event, &core, &count);
        if (rc == Success) {
            if (XaceHook(XACE_SEND_ACCESS, NULL, keybd, focus, core, count) ==
                Success) {
                FixUpEventFromWindow(keybd->spriteInfo->sprite, core, focus,
                                     None, FALSE);
                deliveries =
                    DeliverEventsToWindow(keybd, focus, core, count,
                                          GetEventFilter(keybd, core),
                                          NullGrab);
            }
        }
        else if (rc != BadMatch)
            ErrorF
                ("[dix] %s: core conversion failed DFE (%d, %d). Skipping delivery.\n",
                 keybd->name, event->any.type, rc);
    }

 unwind:
    free(core);
    free(xE);
    free(xi2);
    return;
}

int
DeliverOneGrabbedEvent(InternalEvent *event, DeviceIntPtr dev,
                       enum InputLevel level)
{
    SpritePtr pSprite = dev->spriteInfo->sprite;
    int rc;
    xEvent *xE = NULL;
    int count = 0;
    int deliveries = 0;
    Mask mask;
    GrabInfoPtr grabinfo = &dev->deviceGrab;
    GrabPtr grab = grabinfo->grab;
    Mask filter;

    if (grab->grabtype != level)
        return 0;

    switch (level) {
    case XI2:
        rc = EventToXI2(event, &xE);
        count = 1;
        if (rc == Success) {
            int evtype = xi2_get_type(xE);

            mask = GetXI2MaskByte(grab->xi2mask, dev, evtype);
            filter = GetEventFilter(dev, xE);
        }
        break;
    case XI:
        if (grabinfo->fromPassiveGrab && grabinfo->implicitGrab)
            mask = grab->deviceMask;
        else
            mask = grab->eventMask;
        rc = EventToXI(event, &xE, &count);
        if (rc == Success)
            filter = GetEventFilter(dev, xE);
        break;
    case CORE:
        rc = EventToCore(event, &xE, &count);
        mask = grab->eventMask;
        if (rc == Success)
            filter = GetEventFilter(dev, xE);
        break;
    default:
        BUG_WARN_MSG(1, "Invalid input level %d\n", level);
        return 0;
    }

    if (rc == Success) {
        FixUpEventFromWindow(pSprite, xE, grab->window, None, TRUE);
        if (XaceHook(XACE_SEND_ACCESS, 0, dev,
                     grab->window, xE, count) ||
            XaceHook(XACE_RECEIVE_ACCESS, rClient(grab),
                     grab->window, xE, count))
            deliveries = 1;     /* don't send, but pretend we did */
        else if (level != CORE || !IsInterferingGrab(rClient(grab), dev, xE)) {
            deliveries = TryClientEvents(rClient(grab), dev,
                                         xE, count, mask, filter, grab);
        }
    }
    else
        BUG_WARN_MSG(rc != BadMatch,
                     "%s: conversion to mode %d failed on %d with %d\n",
                     dev->name, level, event->any.type, rc);

    free(xE);
    return deliveries;
}

/**
 * Deliver an event from a device that is currently grabbed. Uses
 * DeliverDeviceEvents() for further delivery if a ownerEvents is set on the
 * grab. If not, TryClientEvents() is used.
 *
 * @@param deactivateGrab True if the device's grab should be deactivated.
 *
 * @@return The number of events delivered.
 */
int
DeliverGrabbedEvent(InternalEvent *event, DeviceIntPtr thisDev,
                    Bool deactivateGrab)
{
    GrabPtr grab;
    GrabInfoPtr grabinfo;
    int deliveries = 0;
    DeviceIntPtr dev;
    SpritePtr pSprite = thisDev->spriteInfo->sprite;
    BOOL sendCore = FALSE;

    grabinfo = &thisDev->deviceGrab;
    grab = grabinfo->grab;

    if (grab->ownerEvents) {
        WindowPtr focus;

        /* Hack: Some pointer device have a focus class. So we need to check
         * for the type of event, to see if we really want to deliver it to
         * the focus window. For pointer events, the answer is no.
         */
        if (IsPointerEvent(event))
            focus = PointerRootWin;
        else if (thisDev->focus) {
            focus = thisDev->focus->win;
            if (focus == FollowKeyboardWin)
                focus = inputInfo.keyboard->focus->win;
        }
        else
            focus = PointerRootWin;
        if (focus == PointerRootWin)
            deliveries = DeliverDeviceEvents(pSprite->win, event, grab,
                                             NullWindow, thisDev);
        else if (focus && (focus == pSprite->win ||
                           IsParent(focus, pSprite->win)))
            deliveries = DeliverDeviceEvents(pSprite->win, event, grab, focus,
                                             thisDev);
        else if (focus)
            deliveries = DeliverDeviceEvents(focus, event, grab, focus,
                                             thisDev);
    }
    if (!deliveries) {
        sendCore = (IsMaster(thisDev) && thisDev->coreEvents);
        /* try core event */
        if ((sendCore && grab->grabtype == CORE) || grab->grabtype != CORE)
            deliveries = DeliverOneGrabbedEvent(event, thisDev, grab->grabtype);

        if (deliveries && (event->any.type == ET_Motion))
            thisDev->valuator->motionHintWindow = grab->window;
    }
    if (deliveries && !deactivateGrab &&
        (event->any.type == ET_KeyPress ||
         event->any.type == ET_KeyRelease ||
         event->any.type == ET_ButtonPress ||
         event->any.type == ET_ButtonRelease)) {
        switch (grabinfo->sync.state) {
        case FREEZE_BOTH_NEXT_EVENT:
            dev = GetPairedDevice(thisDev);
            if (dev) {
                FreezeThaw(dev, TRUE);
                if ((dev->deviceGrab.sync.state == FREEZE_BOTH_NEXT_EVENT) &&
                    (CLIENT_BITS(grab->resource) ==
                     CLIENT_BITS(dev->deviceGrab.grab->resource)))
                    dev->deviceGrab.sync.state = FROZEN_NO_EVENT;
                else
                    dev->deviceGrab.sync.other = grab;
            }
            /* fall through */
        case FREEZE_NEXT_EVENT:
            grabinfo->sync.state = FROZEN_WITH_EVENT;
            FreezeThaw(thisDev, TRUE);
            *grabinfo->sync.event = event->device_event;
            break;
        }
    }

    return deliveries;
}

/* This function is used to set the key pressed or key released state -
   this is only used when the pressing of keys does not cause
   the device's processInputProc to be called, as in for example Mouse Keys.
*/
void
FixKeyState(DeviceEvent *event, DeviceIntPtr keybd)
{
    int key = event->detail.key;

    if (event->type == ET_KeyPress) {
        DebugF("FixKeyState: Key %d %s\n", key,
               ((event->type == ET_KeyPress) ? "down" : "up"));
    }

    if (event->type == ET_KeyPress)
        set_key_down(keybd, key, KEY_PROCESSED);
    else if (event->type == ET_KeyRelease)
        set_key_up(keybd, key, KEY_PROCESSED);
    else
        FatalError("Impossible keyboard event");
}

#define AtMostOneClient \
	(SubstructureRedirectMask | ResizeRedirectMask | ButtonPressMask)
#define ManagerMask \
	(SubstructureRedirectMask | ResizeRedirectMask)

/**
 * Recalculate which events may be deliverable for the given window.
 * Recalculated mask is used for quicker determination which events may be
 * delivered to a window.
 *
 * The otherEventMasks on a WindowOptional is the combination of all event
 * masks set by all clients on the window.
 * deliverableEventMask is the combination of the eventMask and the
 * otherEventMask plus the events that may be propagated to the parent.
 *
 * Traverses to siblings and parents of the window.
 */
void
RecalculateDeliverableEvents(WindowPtr pWin)
{
    OtherClients *others;
    WindowPtr pChild;

    pChild = pWin;
    while (1) {
        if (pChild->optional) {
            pChild->optional->otherEventMasks = 0;
            for (others = wOtherClients(pChild); others; others = others->next) {
                pChild->optional->otherEventMasks |= others->mask;
            }
        }
        pChild->deliverableEvents = pChild->eventMask |
            wOtherEventMasks(pChild);
        if (pChild->parent)
            pChild->deliverableEvents |=
                (pChild->parent->deliverableEvents &
                 ~wDontPropagateMask(pChild) & PropagateMask);
        if (pChild->firstChild) {
            pChild = pChild->firstChild;
            continue;
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            break;
        pChild = pChild->nextSib;
    }
}

/**
 *
 *  \param value must conform to DeleteType
 */
int
OtherClientGone(void *value, XID id)
{
    OtherClientsPtr other, prev;
    WindowPtr pWin = (WindowPtr) value;

    prev = 0;
    for (other = wOtherClients(pWin); other; other = other->next) {
        if (other->resource == id) {
            if (prev)
                prev->next = other->next;
            else {
                if (!(pWin->optional->otherClients = other->next))
                    CheckWindowOptionalNeed(pWin);
            }
            free(other);
            RecalculateDeliverableEvents(pWin);
            return Success;
        }
        prev = other;
    }
    FatalError("client not on event list");
}

int
EventSelectForWindow(WindowPtr pWin, ClientPtr client, Mask mask)
{
    Mask check;
    OtherClients *others;
    DeviceIntPtr dev;
    int rc;

    if (mask & ~AllEventMasks) {
        client->errorValue = mask;
        return BadValue;
    }
    check = (mask & ManagerMask);
    if (check) {
        rc = XaceHook(XACE_RESOURCE_ACCESS, client, pWin->drawable.id,
                      RT_WINDOW, pWin, RT_NONE, NULL, DixManageAccess);
        if (rc != Success)
            return rc;
    }
    check = (mask & AtMostOneClient);
    if (check & (pWin->eventMask | wOtherEventMasks(pWin))) {
        /* It is illegal for two different clients to select on any of the
           events for AtMostOneClient. However, it is OK, for some client to
           continue selecting on one of those events.  */
        if ((wClient(pWin) != client) && (check & pWin->eventMask))
            return BadAccess;
        for (others = wOtherClients(pWin); others; others = others->next) {
            if (!SameClient(others, client) && (check & others->mask))
                return BadAccess;
        }
    }
    if (wClient(pWin) == client) {
        check = pWin->eventMask;
        pWin->eventMask = mask;
    }
    else {
        for (others = wOtherClients(pWin); others; others = others->next) {
            if (SameClient(others, client)) {
                check = others->mask;
                if (mask == 0) {
                    FreeResource(others->resource, RT_NONE);
                    return Success;
                }
                else
                    others->mask = mask;
                goto maskSet;
            }
        }
        check = 0;
        if (!pWin->optional && !MakeWindowOptional(pWin))
            return BadAlloc;
        others = malloc(sizeof(OtherClients));
        if (!others)
            return BadAlloc;
        others->mask = mask;
        others->resource = FakeClientID(client->index);
        others->next = pWin->optional->otherClients;
        pWin->optional->otherClients = others;
        if (!AddResource(others->resource, RT_OTHERCLIENT, (void *) pWin))
            return BadAlloc;
    }
 maskSet:
    if ((mask & PointerMotionHintMask) && !(check & PointerMotionHintMask)) {
        for (dev = inputInfo.devices; dev; dev = dev->next) {
            if (dev->valuator && dev->valuator->motionHintWindow == pWin)
                dev->valuator->motionHintWindow = NullWindow;
        }
    }
    RecalculateDeliverableEvents(pWin);
    return Success;
}

int
EventSuppressForWindow(WindowPtr pWin, ClientPtr client,
                       Mask mask, Bool *checkOptional)
{
    int i, freed;

    if (mask & ~PropagateMask) {
        client->errorValue = mask;
        return BadValue;
    }
    if (pWin->dontPropagate)
        DontPropagateRefCnts[pWin->dontPropagate]--;
    if (!mask)
        i = 0;
    else {
        for (i = DNPMCOUNT, freed = 0; --i > 0;) {
            if (!DontPropagateRefCnts[i])
                freed = i;
            else if (mask == DontPropagateMasks[i])
                break;
        }
        if (!i && freed) {
            i = freed;
            DontPropagateMasks[i] = mask;
        }
    }
    if (i || !mask) {
        pWin->dontPropagate = i;
        if (i)
            DontPropagateRefCnts[i]++;
        if (pWin->optional) {
            pWin->optional->dontPropagateMask = mask;
            *checkOptional = TRUE;
        }
    }
    else {
        if (!pWin->optional && !MakeWindowOptional(pWin)) {
            if (pWin->dontPropagate)
                DontPropagateRefCnts[pWin->dontPropagate]++;
            return BadAlloc;
        }
        pWin->dontPropagate = 0;
        pWin->optional->dontPropagateMask = mask;
    }
    RecalculateDeliverableEvents(pWin);
    return Success;
}

/**
 * Assembles an EnterNotify or LeaveNotify and sends it event to the client.
 * Uses the paired keyboard to get some additional information.
 */
void
CoreEnterLeaveEvent(DeviceIntPtr mouse,
                    int type,
                    int mode, int detail, WindowPtr pWin, Window child)
{
    xEvent event = {
        .u.u.type = type,
        .u.u.detail = detail
    };
    WindowPtr focus;
    DeviceIntPtr keybd;
    GrabPtr grab = mouse->deviceGrab.grab;
    Mask mask;

    keybd = GetMaster(mouse, KEYBOARD_OR_FLOAT);

    if ((pWin == mouse->valuator->motionHintWindow) &&
        (detail != NotifyInferior))
        mouse->valuator->motionHintWindow = NullWindow;
    if (grab) {
        mask = (pWin == grab->window) ? grab->eventMask : 0;
        if (grab->ownerEvents)
            mask |= EventMaskForClient(pWin, rClient(grab));
    }
    else {
        mask = pWin->eventMask | wOtherEventMasks(pWin);
    }

    event.u.enterLeave.time = currentTime.milliseconds;
    event.u.enterLeave.rootX = mouse->spriteInfo->sprite->hot.x;
    event.u.enterLeave.rootY = mouse->spriteInfo->sprite->hot.y;
    /* Counts on the same initial structure of crossing & button events! */
    FixUpEventFromWindow(mouse->spriteInfo->sprite, &event, pWin, None, FALSE);
    /* Enter/Leave events always set child */
    event.u.enterLeave.child = child;
    event.u.enterLeave.flags = event.u.keyButtonPointer.sameScreen ?
        ELFlagSameScreen : 0;
    event.u.enterLeave.state =
        mouse->button ? (mouse->button->state & 0x1f00) : 0;
    if (keybd)
        event.u.enterLeave.state |=
            XkbGrabStateFromRec(&keybd->key->xkbInfo->state);
    event.u.enterLeave.mode = mode;
    focus = (keybd) ? keybd->focus->win : None;
    if ((focus != NoneWin) &&
        ((pWin == focus) || (focus == PointerRootWin) || IsParent(focus, pWin)))
        event.u.enterLeave.flags |= ELFlagFocus;

    if ((mask & GetEventFilter(mouse, &event))) {
        if (grab)
            TryClientEvents(rClient(grab), mouse, &event, 1, mask,
                            GetEventFilter(mouse, &event), grab);
        else
            DeliverEventsToWindow(mouse, pWin, &event, 1,
                                  GetEventFilter(mouse, &event), NullGrab);
    }

    if ((type == EnterNotify) && (mask & KeymapStateMask)) {
        xKeymapEvent ke = {
            .type = KeymapNotify
        };
        ClientPtr client = grab ? rClient(grab) : wClient(pWin);
        int rc;

        rc = XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixReadAccess);
        if (rc == Success)
            memcpy((char *) &ke.map[0], (char *) &keybd->key->down[1], 31);

        if (grab)
            TryClientEvents(rClient(grab), keybd, (xEvent *) &ke, 1,
                            mask, KeymapStateMask, grab);
        else
            DeliverEventsToWindow(mouse, pWin, (xEvent *) &ke, 1,
                                  KeymapStateMask, NullGrab);
    }
}

void
DeviceEnterLeaveEvent(DeviceIntPtr mouse,
                      int sourceid,
                      int type,
                      int mode, int detail, WindowPtr pWin, Window child)
{
    GrabPtr grab = mouse->deviceGrab.grab;
    xXIEnterEvent *event;
    WindowPtr focus;
    int filter;
    int btlen, len, i;
    DeviceIntPtr kbd;

    if ((mode == XINotifyPassiveGrab && type == XI_Leave) ||
        (mode == XINotifyPassiveUngrab && type == XI_Enter))
        return;

    btlen = (mouse->button) ? bits_to_bytes(mouse->button->numButtons) : 0;
    btlen = bytes_to_int32(btlen);
    len = sizeof(xXIEnterEvent) + btlen * 4;

    event = calloc(1, len);
    event->type = GenericEvent;
    event->extension = IReqCode;
    event->evtype = type;
    event->length = (len - sizeof(xEvent)) / 4;
    event->buttons_len = btlen;
    event->detail = detail;
    event->time = currentTime.milliseconds;
    event->deviceid = mouse->id;
    event->sourceid = sourceid;
    event->mode = mode;
    event->root_x = double_to_fp1616(mouse->spriteInfo->sprite->hot.x);
    event->root_y = double_to_fp1616(mouse->spriteInfo->sprite->hot.y);

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(&event[1], i);

    kbd = GetMaster(mouse, MASTER_KEYBOARD);
    if (kbd && kbd->key) {
        event->mods.base_mods = kbd->key->xkbInfo->state.base_mods;
        event->mods.latched_mods = kbd->key->xkbInfo->state.latched_mods;
        event->mods.locked_mods = kbd->key->xkbInfo->state.locked_mods;

        event->group.base_group = kbd->key->xkbInfo->state.base_group;
        event->group.latched_group = kbd->key->xkbInfo->state.latched_group;
        event->group.locked_group = kbd->key->xkbInfo->state.locked_group;
    }

    focus = (kbd) ? kbd->focus->win : None;
    if ((focus != NoneWin) &&
        ((pWin == focus) || (focus == PointerRootWin) || IsParent(focus, pWin)))
        event->focus = TRUE;

    FixUpEventFromWindow(mouse->spriteInfo->sprite, (xEvent *) event, pWin,
                         None, FALSE);

    filter = GetEventFilter(mouse, (xEvent *) event);

    if (grab && grab->grabtype == XI2) {
        Mask mask;

        mask = xi2mask_isset(grab->xi2mask, mouse, type);
        TryClientEvents(rClient(grab), mouse, (xEvent *) event, 1, mask, 1,
                        grab);
    }
    else {
        if (!WindowXI2MaskIsset(mouse, pWin, (xEvent *) event))
            goto out;
        DeliverEventsToWindow(mouse, pWin, (xEvent *) event, 1, filter,
                              NullGrab);
    }

 out:
    free(event);
}

void
CoreFocusEvent(DeviceIntPtr dev, int type, int mode, int detail, WindowPtr pWin)
{
    xEvent event = {
        .u.u.type = type,
        .u.u.detail = detail
    };
    event.u.focus.mode = mode;
    event.u.focus.window = pWin->drawable.id;

    DeliverEventsToWindow(dev, pWin, &event, 1,
                          GetEventFilter(dev, &event), NullGrab);
    if ((type == FocusIn) &&
        ((pWin->eventMask | wOtherEventMasks(pWin)) & KeymapStateMask)) {
        xKeymapEvent ke = {
            .type = KeymapNotify
        };
        ClientPtr client = wClient(pWin);
        int rc;

        rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess);
        if (rc == Success)
            memcpy((char *) &ke.map[0], (char *) &dev->key->down[1], 31);

        DeliverEventsToWindow(dev, pWin, (xEvent *) &ke, 1,
                              KeymapStateMask, NullGrab);
    }
}

/**
 * Set the input focus to the given window. Subsequent keyboard events will be
 * delivered to the given window.
 *
 * Usually called from ProcSetInputFocus as result of a client request. If so,
 * the device is the inputInfo.keyboard.
 * If called from ProcXSetInputFocus as result of a client xinput request, the
 * device is set to the device specified by the client.
 *
 * @@param client Client that requested input focus change.
 * @@param dev Focus device.
 * @@param focusID The window to obtain the focus. Can be PointerRoot or None.
 * @@param revertTo Specifies where the focus reverts to when window becomes
 * unviewable.
 * @@param ctime Specifies the time.
 * @@param followOK True if pointer is allowed to follow the keyboard.
 */
int
SetInputFocus(ClientPtr client,
              DeviceIntPtr dev,
              Window focusID, CARD8 revertTo, Time ctime, Bool followOK)
{
    FocusClassPtr focus;
    WindowPtr focusWin;
    int mode, rc;
    TimeStamp time;
    DeviceIntPtr keybd;         /* used for FollowKeyboard or FollowKeyboardWin */

    UpdateCurrentTime();
    if ((revertTo != RevertToParent) &&
        (revertTo != RevertToPointerRoot) &&
        (revertTo != RevertToNone) &&
        ((revertTo != RevertToFollowKeyboard) || !followOK)) {
        client->errorValue = revertTo;
        return BadValue;
    }
    time = ClientTimeToServerTime(ctime);

    keybd = GetMaster(dev, KEYBOARD_OR_FLOAT);

    if ((focusID == None) || (focusID == PointerRoot))
        focusWin = (WindowPtr) (long) focusID;
    else if ((focusID == FollowKeyboard) && followOK) {
        focusWin = keybd->focus->win;
    }
    else {
        rc = dixLookupWindow(&focusWin, focusID, client, DixSetAttrAccess);
        if (rc != Success)
            return rc;
        /* It is a match error to try to set the input focus to an
           unviewable window. */
        if (!focusWin->realized)
            return BadMatch;
    }
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixSetFocusAccess);
    if (rc != Success)
        return Success;

    focus = dev->focus;
    if ((CompareTimeStamps(time, currentTime) == LATER) ||
        (CompareTimeStamps(time, focus->time) == EARLIER))
        return Success;
    mode = (dev->deviceGrab.grab) ? NotifyWhileGrabbed : NotifyNormal;
    if (focus->win == FollowKeyboardWin) {
        if (!ActivateFocusInGrab(dev, keybd->focus->win, focusWin))
            DoFocusEvents(dev, keybd->focus->win, focusWin, mode);
    }
    else {
        if (!ActivateFocusInGrab(dev, focus->win, focusWin))
            DoFocusEvents(dev, focus->win, focusWin, mode);
    }
    focus->time = time;
    focus->revert = revertTo;
    if (focusID == FollowKeyboard)
        focus->win = FollowKeyboardWin;
    else
        focus->win = focusWin;
    if ((focusWin == NoneWin) || (focusWin == PointerRootWin))
        focus->traceGood = 0;
    else {
        int depth = 0;
        WindowPtr pWin;

        for (pWin = focusWin; pWin; pWin = pWin->parent)
            depth++;
        if (depth > focus->traceSize) {
            focus->traceSize = depth + 1;
            focus->trace = reallocarray(focus->trace, focus->traceSize,
                                        sizeof(WindowPtr));
        }
        focus->traceGood = depth;
        for (pWin = focusWin, depth--; pWin; pWin = pWin->parent, depth--)
            focus->trace[depth] = pWin;
    }
    return Success;
}

/**
 * Server-side protocol handling for SetInputFocus request.
 *
 * Sets the input focus for the virtual core keyboard.
 */
int
ProcSetInputFocus(ClientPtr client)
{
    DeviceIntPtr kbd = PickKeyboard(client);

    REQUEST(xSetInputFocusReq);

    REQUEST_SIZE_MATCH(xSetInputFocusReq);

    return SetInputFocus(client, kbd, stuff->focus,
                         stuff->revertTo, stuff->time, FALSE);
}

/**
 * Server-side protocol handling for GetInputFocus request.
 *
 * Sends the current input focus for the client's keyboard back to the
 * client.
 */
int
ProcGetInputFocus(ClientPtr client)
{
    DeviceIntPtr kbd = PickKeyboard(client);
    xGetInputFocusReply rep;
    FocusClassPtr focus = kbd->focus;
    int rc;

    /* REQUEST(xReq); */
    REQUEST_SIZE_MATCH(xReq);

    rc = XaceHook(XACE_DEVICE_ACCESS, client, kbd, DixGetFocusAccess);
    if (rc != Success)
        return rc;

    rep = (xGetInputFocusReply) {
        .type = X_Reply,
        .length = 0,
        .sequenceNumber = client->sequence,
        .revertTo = focus->revert
    };

    if (focus->win == NoneWin)
        rep.focus = None;
    else if (focus->win == PointerRootWin)
        rep.focus = PointerRoot;
    else
        rep.focus = focus->win->drawable.id;

    WriteReplyToClient(client, sizeof(xGetInputFocusReply), &rep);
    return Success;
}

/**
 * Server-side protocol handling for GrabPointer request.
 *
 * Sets an active grab on the client's ClientPointer and returns success
 * status to client.
 */
int
ProcGrabPointer(ClientPtr client)
{
    xGrabPointerReply rep;
    DeviceIntPtr device = PickPointer(client);
    GrabPtr grab;
    GrabMask mask;
    WindowPtr confineTo;
    BYTE status;

    REQUEST(xGrabPointerReq);
    int rc;

    REQUEST_SIZE_MATCH(xGrabPointerReq);
    UpdateCurrentTime();

    if (stuff->eventMask & ~PointerGrabMask) {
        client->errorValue = stuff->eventMask;
        return BadValue;
    }

    if (stuff->confineTo == None)
        confineTo = NullWindow;
    else {
        rc = dixLookupWindow(&confineTo, stuff->confineTo, client,
                             DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }

    grab = device->deviceGrab.grab;

    if (grab && grab->confineTo && !confineTo)
        ConfineCursorToWindow(device, GetCurrentRootWindow(device), FALSE, FALSE);

    mask.core = stuff->eventMask;

    rc = GrabDevice(client, device, stuff->pointerMode, stuff->keyboardMode,
                    stuff->grabWindow, stuff->ownerEvents, stuff->time,
                    &mask, CORE, stuff->cursor, stuff->confineTo, &status);
    if (rc != Success)
        return rc;

    rep = (xGrabPointerReply) {
        .type = X_Reply,
        .status = status,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    WriteReplyToClient(client, sizeof(xGrabPointerReply), &rep);
    return Success;
}

/**
 * Server-side protocol handling for ChangeActivePointerGrab request.
 *
 * Changes properties of the grab hold by the client. If the client does not
 * hold an active grab on the device, nothing happens.
 */
int
ProcChangeActivePointerGrab(ClientPtr client)
{
    DeviceIntPtr device;
    GrabPtr grab;
    CursorPtr newCursor, oldCursor;

    REQUEST(xChangeActivePointerGrabReq);
    TimeStamp time;

    REQUEST_SIZE_MATCH(xChangeActivePointerGrabReq);
    if (stuff->eventMask & ~PointerGrabMask) {
        client->errorValue = stuff->eventMask;
        return BadValue;
    }
    if (stuff->cursor == None)
        newCursor = NullCursor;
    else {
        int rc = dixLookupResourceByType((void **) &newCursor, stuff->cursor,
                                         RT_CURSOR, client, DixUseAccess);

        if (rc != Success) {
            client->errorValue = stuff->cursor;
            return rc;
        }
    }

    device = PickPointer(client);
    grab = device->deviceGrab.grab;

    if (!grab)
        return Success;
    if (!SameClient(grab, client))
        return Success;
    time = ClientTimeToServerTime(stuff->time);
    if ((CompareTimeStamps(time, currentTime) == LATER) ||
        (CompareTimeStamps(time, device->deviceGrab.grabTime) == EARLIER))
        return Success;
    oldCursor = grab->cursor;
    grab->cursor = RefCursor(newCursor);
    PostNewCursor(device);
    if (oldCursor)
        FreeCursor(oldCursor, (Cursor) 0);
    grab->eventMask = stuff->eventMask;
    return Success;
}

/**
 * Server-side protocol handling for UngrabPointer request.
 *
 * Deletes a pointer grab on a device the client has grabbed.
 */
int
ProcUngrabPointer(ClientPtr client)
{
    DeviceIntPtr device = PickPointer(client);
    GrabPtr grab;
    TimeStamp time;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    UpdateCurrentTime();
    grab = device->deviceGrab.grab;

    time = ClientTimeToServerTime(stuff->id);
    if ((CompareTimeStamps(time, currentTime) != LATER) &&
        (CompareTimeStamps(time, device->deviceGrab.grabTime) != EARLIER) &&
        (grab) && SameClient(grab, client))
        (*device->deviceGrab.DeactivateGrab) (device);
    return Success;
}

/**
 * Sets a grab on the given device.
 *
 * Called from ProcGrabKeyboard to work on the client's keyboard.
 * Called from ProcXGrabDevice to work on the device specified by the client.
 *
 * The parameters this_mode and other_mode represent the keyboard_mode and
 * pointer_mode parameters of XGrabKeyboard().
 * See man page for details on all the parameters
 *
 * @@param client Client that owns the grab.
 * @@param dev The device to grab.
 * @@param this_mode GrabModeSync or GrabModeAsync
 * @@param other_mode GrabModeSync or GrabModeAsync
 * @@param status Return code to be returned to the caller.
 *
 * @@returns Success or BadValue or BadAlloc.
 */
int
GrabDevice(ClientPtr client, DeviceIntPtr dev,
           unsigned pointer_mode, unsigned keyboard_mode, Window grabWindow,
           unsigned ownerEvents, Time ctime, GrabMask *mask,
           int grabtype, Cursor curs, Window confineToWin, CARD8 *status)
{
    WindowPtr pWin, confineTo;
    GrabPtr grab;
    TimeStamp time;
    Mask access_mode = DixGrabAccess;
    int rc;
    GrabInfoPtr grabInfo = &dev->deviceGrab;
    CursorPtr cursor;

    UpdateCurrentTime();
    if ((keyboard_mode != GrabModeSync) && (keyboard_mode != GrabModeAsync)) {
        client->errorValue = keyboard_mode;
        return BadValue;
    }
    if ((pointer_mode != GrabModeSync) && (pointer_mode != GrabModeAsync)) {
        client->errorValue = pointer_mode;
        return BadValue;
    }
    if ((ownerEvents != xFalse) && (ownerEvents != xTrue)) {
        client->errorValue = ownerEvents;
        return BadValue;
    }

    rc = dixLookupWindow(&pWin, grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    if (confineToWin == None)
        confineTo = NullWindow;
    else {
        rc = dixLookupWindow(&confineTo, confineToWin, client,
                             DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }

    if (curs == None)
        cursor = NullCursor;
    else {
        rc = dixLookupResourceByType((void **) &cursor, curs, RT_CURSOR,
                                     client, DixUseAccess);
        if (rc != Success) {
            client->errorValue = curs;
            return rc;
        }
        access_mode |= DixForceAccess;
    }

    if (keyboard_mode == GrabModeSync || pointer_mode == GrabModeSync)
        access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
        return rc;

    time = ClientTimeToServerTime(ctime);
    grab = grabInfo->grab;
    if (grab && grab->grabtype != grabtype)
        *status = AlreadyGrabbed;
    else if (grab && !SameClient(grab, client))
        *status = AlreadyGrabbed;
    else if ((!pWin->realized) ||
             (confineTo &&
              !(confineTo->realized && BorderSizeNotEmpty(dev, confineTo))))
        *status = GrabNotViewable;
    else if ((CompareTimeStamps(time, currentTime) == LATER) ||
             (CompareTimeStamps(time, grabInfo->grabTime) == EARLIER))
        *status = GrabInvalidTime;
    else if (grabInfo->sync.frozen &&
             grabInfo->sync.other && !SameClient(grabInfo->sync.other, client))
        *status = GrabFrozen;
    else {
        GrabPtr tempGrab;

        tempGrab = AllocGrab(NULL);
        if (tempGrab == NULL)
            return BadAlloc;

        tempGrab->next = NULL;
        tempGrab->window = pWin;
        tempGrab->resource = client->clientAsMask;
        tempGrab->ownerEvents = ownerEvents;
        tempGrab->keyboardMode = keyboard_mode;
        tempGrab->pointerMode = pointer_mode;
        if (grabtype == CORE)
            tempGrab->eventMask = mask->core;
        else if (grabtype == XI)
            tempGrab->eventMask = mask->xi;
        else
            xi2mask_merge(tempGrab->xi2mask, mask->xi2mask);
        tempGrab->device = dev;
        tempGrab->cursor = RefCursor(cursor);
        tempGrab->confineTo = confineTo;
        tempGrab->grabtype = grabtype;
        (*grabInfo->ActivateGrab) (dev, tempGrab, time, FALSE);
        *status = GrabSuccess;

        FreeGrab(tempGrab);
    }
    return Success;
}

/**
 * Server-side protocol handling for GrabKeyboard request.
 *
 * Grabs the client's keyboard and returns success status to client.
 */
int
ProcGrabKeyboard(ClientPtr client)
{
    xGrabKeyboardReply rep;
    BYTE status;

    REQUEST(xGrabKeyboardReq);
    int result;
    DeviceIntPtr keyboard = PickKeyboard(client);
    GrabMask mask;

    REQUEST_SIZE_MATCH(xGrabKeyboardReq);

    mask.core = KeyPressMask | KeyReleaseMask;

    result = GrabDevice(client, keyboard, stuff->pointerMode,
                        stuff->keyboardMode, stuff->grabWindow,
                        stuff->ownerEvents, stuff->time, &mask, CORE, None,
                        None, &status);

    if (result != Success)
        return result;

    rep = (xGrabKeyboardReply) {
        .type = X_Reply,
        .status = status,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    WriteReplyToClient(client, sizeof(xGrabKeyboardReply), &rep);
    return Success;
}

/**
 * Server-side protocol handling for UngrabKeyboard request.
 *
 * Deletes a possible grab on the client's keyboard.
 */
int
ProcUngrabKeyboard(ClientPtr client)
{
    DeviceIntPtr device = PickKeyboard(client);
    GrabPtr grab;
    TimeStamp time;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    UpdateCurrentTime();

    grab = device->deviceGrab.grab;

    time = ClientTimeToServerTime(stuff->id);
    if ((CompareTimeStamps(time, currentTime) != LATER) &&
        (CompareTimeStamps(time, device->deviceGrab.grabTime) != EARLIER) &&
        (grab) && SameClient(grab, client) && grab->grabtype == CORE)
        (*device->deviceGrab.DeactivateGrab) (device);
    return Success;
}

/**
 * Server-side protocol handling for QueryPointer request.
 *
 * Returns the current state and position of the client's ClientPointer to the
 * client.
 */
int
ProcQueryPointer(ClientPtr client)
{
    xQueryPointerReply rep;
    WindowPtr pWin, t;
    DeviceIntPtr mouse = PickPointer(client);
    DeviceIntPtr keyboard;
    SpritePtr pSprite;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupWindow(&pWin, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, mouse, DixReadAccess);
    if (rc != Success && rc != BadAccess)
        return rc;

    keyboard = GetMaster(mouse, MASTER_KEYBOARD);

    pSprite = mouse->spriteInfo->sprite;
    if (mouse->valuator->motionHintWindow)
        MaybeStopHint(mouse, client);
    rep = (xQueryPointerReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .mask = event_get_corestate(mouse, keyboard),
        .root = (GetCurrentRootWindow(mouse))->drawable.id,
        .rootX = pSprite->hot.x,
        .rootY = pSprite->hot.y,
        .child = None
    };
    if (pSprite->hot.pScreen == pWin->drawable.pScreen) {
        rep.sameScreen = xTrue;
        rep.winX = pSprite->hot.x - pWin->drawable.x;
        rep.winY = pSprite->hot.y - pWin->drawable.y;
        for (t = pSprite->win; t; t = t->parent)
            if (t->parent == pWin) {
                rep.child = t->drawable.id;
                break;
            }
    }
    else {
        rep.sameScreen = xFalse;
        rep.winX = 0;
        rep.winY = 0;
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        rep.rootX += screenInfo.screens[0]->x;
        rep.rootY += screenInfo.screens[0]->y;
        if (stuff->id == rep.root) {
            rep.winX += screenInfo.screens[0]->x;
            rep.winY += screenInfo.screens[0]->y;
        }
    }
#endif

    if (rc == BadAccess) {
        rep.mask = 0;
        rep.child = None;
        rep.rootX = 0;
        rep.rootY = 0;
        rep.winX = 0;
        rep.winY = 0;
    }

    WriteReplyToClient(client, sizeof(xQueryPointerReply), &rep);

    return Success;
}

/**
 * Initializes the device list and the DIX sprite to sane values. Allocates
 * trace memory used for quick window traversal.
 */
void
InitEvents(void)
{
    int i;
    QdEventPtr qe, tmp;

    inputInfo.numDevices = 0;
    inputInfo.devices = (DeviceIntPtr) NULL;
    inputInfo.off_devices = (DeviceIntPtr) NULL;
    inputInfo.keyboard = (DeviceIntPtr) NULL;
    inputInfo.pointer = (DeviceIntPtr) NULL;

    for (i = 0; i < MAXDEVICES; i++) {
        DeviceIntRec dummy;
        memcpy(&event_filters[i], default_filter, sizeof(default_filter));

        dummy.id = i;
        NoticeTime(&dummy, currentTime);
        LastEventTimeToggleResetFlag(i, FALSE);
    }

    syncEvents.replayDev = (DeviceIntPtr) NULL;
    syncEvents.replayWin = NullWindow;
    if (syncEvents.pending.next)
        xorg_list_for_each_entry_safe(qe, tmp, &syncEvents.pending, next)
            free(qe);
    xorg_list_init(&syncEvents.pending);
    syncEvents.playingEvents = FALSE;
    syncEvents.time.months = 0;
    syncEvents.time.milliseconds = 0;   /* hardly matters */
    currentTime.months = 0;
    currentTime.milliseconds = GetTimeInMillis();
    for (i = 0; i < DNPMCOUNT; i++) {
        DontPropagateMasks[i] = 0;
        DontPropagateRefCnts[i] = 0;
    }

    InputEventList = InitEventList(GetMaximumEventsNum());
    if (!InputEventList)
        FatalError("[dix] Failed to allocate input event list.\n");
}

void
CloseDownEvents(void)
{
    FreeEventList(InputEventList, GetMaximumEventsNum());
    InputEventList = NULL;
}

#define SEND_EVENT_BIT 0x80

/**
 * Server-side protocol handling for SendEvent request.
 *
 * Locates the window to send the event to and forwards the event.
 */
int
ProcSendEvent(ClientPtr client)
{
    WindowPtr pWin;
    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */
    DeviceIntPtr dev = PickPointer(client);
    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);
    SpritePtr pSprite = dev->spriteInfo->sprite;

    REQUEST(xSendEventReq);

    REQUEST_SIZE_MATCH(xSendEventReq);

    /* libXext and other extension libraries may set the bit indicating
     * that this event came from a SendEvent request so remove it
     * since otherwise the event type may fail the range checks
     * and cause an invalid BadValue error to be returned.
     *
     * This is safe to do since we later add the SendEvent bit (0x80)
     * back in once we send the event to the client */

    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);

    /* The client's event type must be a core event type or one defined by an
       extension. */

    if (!((stuff->event.u.u.type > X_Reply &&
           stuff->event.u.u.type < LASTEvent) ||
          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&
           stuff->event.u.u.type < (unsigned) lastEvent))) {
        client->errorValue = stuff->event.u.u.type;
        return BadValue;
    }
    /* Generic events can have variable size, but SendEvent request holds
       exactly 32B of event data. */
    if (stuff->event.u.u.type == GenericEvent) {
        client->errorValue = stuff->event.u.u.type;
        return BadValue;
    }
    if (stuff->event.u.u.type == ClientMessage &&
        stuff->event.u.u.detail != 8 &&
        stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {
        client->errorValue = stuff->event.u.u.detail;
        return BadValue;
    }
    if (stuff->eventMask & ~AllEventMasks) {
        client->errorValue = stuff->eventMask;
        return BadValue;
    }

    if (stuff->destination == PointerWindow)
        pWin = pSprite->win;
    else if (stuff->destination == InputFocus) {
        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;

        if (inputFocus == NoneWin)
            return Success;

        /* If the input focus is PointerRootWin, send the event to where
           the pointer is if possible, then perhaps propogate up to root. */
        if (inputFocus == PointerRootWin)
            inputFocus = GetCurrentRootWindow(dev);

        if (IsParent(inputFocus, pSprite->win)) {
            effectiveFocus = inputFocus;
            pWin = pSprite->win;
        }
        else
            effectiveFocus = pWin = inputFocus;
    }
    else
        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);

    if (!pWin)
        return BadWindow;
    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {
        client->errorValue = stuff->propagate;
        return BadValue;
    }
    stuff->event.u.u.type |= SEND_EVENT_BIT;
    if (stuff->propagate) {
        for (; pWin; pWin = pWin->parent) {
            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,
                         &stuff->event, 1))
                return Success;
            if (DeliverEventsToWindow(dev, pWin,
                                      &stuff->event, 1, stuff->eventMask,
                                      NullGrab))
                return Success;
            if (pWin == effectiveFocus)
                return Success;
            stuff->eventMask &= ~wDontPropagateMask(pWin);
            if (!stuff->eventMask)
                break;
        }
    }
    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))
        DeliverEventsToWindow(dev, pWin, &stuff->event,
                              1, stuff->eventMask, NullGrab);
    return Success;
}

/**
 * Server-side protocol handling for UngrabKey request.
 *
 * Deletes a passive grab for the given key. Works on the
 * client's keyboard.
 */
int
ProcUngrabKey(ClientPtr client)
{
    REQUEST(xUngrabKeyReq);
    WindowPtr pWin;
    GrabPtr tempGrab;
    DeviceIntPtr keybd = PickKeyboard(client);
    int rc;

    REQUEST_SIZE_MATCH(xUngrabKeyReq);
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    if (((stuff->key > keybd->key->xkbInfo->desc->max_key_code) ||
         (stuff->key < keybd->key->xkbInfo->desc->min_key_code))
        && (stuff->key != AnyKey)) {
        client->errorValue = stuff->key;
        return BadValue;
    }
    if ((stuff->modifiers != AnyModifier) &&
        (stuff->modifiers & ~AllModifiersMask)) {
        client->errorValue = stuff->modifiers;
        return BadValue;
    }
    tempGrab = AllocGrab(NULL);
    if (!tempGrab)
        return BadAlloc;
    tempGrab->resource = client->clientAsMask;
    tempGrab->device = keybd;
    tempGrab->window = pWin;
    tempGrab->modifiersDetail.exact = stuff->modifiers;
    tempGrab->modifiersDetail.pMask = NULL;
    tempGrab->modifierDevice = keybd;
    tempGrab->type = KeyPress;
    tempGrab->grabtype = CORE;
    tempGrab->detail.exact = stuff->key;
    tempGrab->detail.pMask = NULL;
    tempGrab->next = NULL;

    if (!DeletePassiveGrabFromList(tempGrab))
        rc = BadAlloc;

    FreeGrab(tempGrab);

    return rc;
}

/**
 * Server-side protocol handling for GrabKey request.
 *
 * Creates a grab for the client's keyboard and adds it to the list of passive
 * grabs.
 */
int
ProcGrabKey(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xGrabKeyReq);
    GrabPtr grab;
    DeviceIntPtr keybd = PickKeyboard(client);
    int rc;
    GrabParameters param;
    GrabMask mask;

    REQUEST_SIZE_MATCH(xGrabKeyReq);

    param = (GrabParameters) {
        .grabtype = CORE,
        .ownerEvents = stuff->ownerEvents,
        .this_device_mode = stuff->keyboardMode,
        .other_devices_mode = stuff->pointerMode,
        .modifiers = stuff->modifiers
    };

    rc = CheckGrabValues(client, &param);
    if (rc != Success)
        return rc;

    if (((stuff->key > keybd->key->xkbInfo->desc->max_key_code) ||
         (stuff->key < keybd->key->xkbInfo->desc->min_key_code))
        && (stuff->key != AnyKey)) {
        client->errorValue = stuff->key;
        return BadValue;
    }
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    mask.core = (KeyPressMask | KeyReleaseMask);

    grab = CreateGrab(client->index, keybd, keybd, pWin, CORE, &mask,
                      &param, KeyPress, stuff->key, NullWindow, NullCursor);
    if (!grab)
        return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/**
 * Server-side protocol handling for GrabButton request.
 *
 * Creates a grab for the client's ClientPointer and adds it as a passive grab
 * to the list.
 */
int
ProcGrabButton(ClientPtr client)
{
    WindowPtr pWin, confineTo;

    REQUEST(xGrabButtonReq);
    CursorPtr cursor;
    GrabPtr grab;
    DeviceIntPtr ptr, modifierDevice;
    Mask access_mode = DixGrabAccess;
    GrabMask mask;
    GrabParameters param;
    int rc;

    REQUEST_SIZE_MATCH(xGrabButtonReq);
    if ((stuff->pointerMode != GrabModeSync) &&
        (stuff->pointerMode != GrabModeAsync)) {
        client->errorValue = stuff->pointerMode;
        return BadValue;
    }
    if ((stuff->keyboardMode != GrabModeSync) &&
        (stuff->keyboardMode != GrabModeAsync)) {
        client->errorValue = stuff->keyboardMode;
        return BadValue;
    }
    if ((stuff->modifiers != AnyModifier) &&
        (stuff->modifiers & ~AllModifiersMask)) {
        client->errorValue = stuff->modifiers;
        return BadValue;
    }
    if ((stuff->ownerEvents != xFalse) && (stuff->ownerEvents != xTrue)) {
        client->errorValue = stuff->ownerEvents;
        return BadValue;
    }
    if (stuff->eventMask & ~PointerGrabMask) {
        client->errorValue = stuff->eventMask;
        return BadValue;
    }
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->confineTo == None)
        confineTo = NullWindow;
    else {
        rc = dixLookupWindow(&confineTo, stuff->confineTo, client,
                             DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }
    if (stuff->cursor == None)
        cursor = NullCursor;
    else {
        rc = dixLookupResourceByType((void **) &cursor, stuff->cursor,
                                     RT_CURSOR, client, DixUseAccess);
        if (rc != Success) {
            client->errorValue = stuff->cursor;
            return rc;
        }
        access_mode |= DixForceAccess;
    }

    ptr = PickPointer(client);
    modifierDevice = GetMaster(ptr, MASTER_KEYBOARD);
    if (stuff->pointerMode == GrabModeSync ||
        stuff->keyboardMode == GrabModeSync)
        access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, ptr, access_mode);
    if (rc != Success)
        return rc;

    param = (GrabParameters) {
        .grabtype = CORE,
        .ownerEvents = stuff->ownerEvents,
        .this_device_mode = stuff->keyboardMode,
        .other_devices_mode = stuff->pointerMode,
        .modifiers = stuff->modifiers
    };

    mask.core = stuff->eventMask;

    grab = CreateGrab(client->index, ptr, modifierDevice, pWin,
                      CORE, &mask, &param, ButtonPress,
                      stuff->button, confineTo, cursor);
    if (!grab)
        return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/**
 * Server-side protocol handling for UngrabButton request.
 *
 * Deletes a passive grab on the client's ClientPointer from the list.
 */
int
ProcUngrabButton(ClientPtr client)
{
    REQUEST(xUngrabButtonReq);
    WindowPtr pWin;
    GrabPtr tempGrab;
    int rc;
    DeviceIntPtr ptr;

    REQUEST_SIZE_MATCH(xUngrabButtonReq);
    if ((stuff->modifiers != AnyModifier) &&
        (stuff->modifiers & ~AllModifiersMask)) {
        client->errorValue = stuff->modifiers;
        return BadValue;
    }
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
    if (rc != Success)
        return rc;

    ptr = PickPointer(client);

    tempGrab = AllocGrab(NULL);
    if (!tempGrab)
        return BadAlloc;
    tempGrab->resource = client->clientAsMask;
    tempGrab->device = ptr;
    tempGrab->window = pWin;
    tempGrab->modifiersDetail.exact = stuff->modifiers;
    tempGrab->modifiersDetail.pMask = NULL;
    tempGrab->modifierDevice = GetMaster(ptr, MASTER_KEYBOARD);
    tempGrab->type = ButtonPress;
    tempGrab->detail.exact = stuff->button;
    tempGrab->grabtype = CORE;
    tempGrab->detail.pMask = NULL;
    tempGrab->next = NULL;

    if (!DeletePassiveGrabFromList(tempGrab))
        rc = BadAlloc;

    FreeGrab(tempGrab);
    return rc;
}

/**
 * Deactivate any grab that may be on the window, remove the focus.
 * Delete any XInput extension events from the window too. Does not change the
 * window mask. Use just before the window is deleted.
 *
 * If freeResources is set, passive grabs on the window are deleted.
 *
 * @@param pWin The window to delete events from.
 * @@param freeResources True if resources associated with the window should be
 * deleted.
 */
void
DeleteWindowFromAnyEvents(WindowPtr pWin, Bool freeResources)
{
    WindowPtr parent;
    DeviceIntPtr mouse = inputInfo.pointer;
    DeviceIntPtr keybd = inputInfo.keyboard;
    FocusClassPtr focus;
    OtherClientsPtr oc;
    GrabPtr passive;
    GrabPtr grab;

    /* Deactivate any grabs performed on this window, before making any
       input focus changes. */
    grab = mouse->deviceGrab.grab;
    if (grab && ((grab->window == pWin) || (grab->confineTo == pWin)))
        (*mouse->deviceGrab.DeactivateGrab) (mouse);

    /* Deactivating a keyboard grab should cause focus events. */
    grab = keybd->deviceGrab.grab;
    if (grab && (grab->window == pWin))
        (*keybd->deviceGrab.DeactivateGrab) (keybd);

    /* And now the real devices */
    for (mouse = inputInfo.devices; mouse; mouse = mouse->next) {
        grab = mouse->deviceGrab.grab;
        if (grab && ((grab->window == pWin) || (grab->confineTo == pWin)))
            (*mouse->deviceGrab.DeactivateGrab) (mouse);
    }

    for (keybd = inputInfo.devices; keybd; keybd = keybd->next) {
        if (IsKeyboardDevice(keybd)) {
            focus = keybd->focus;

            /* If the focus window is a root window (ie. has no parent)
               then don't delete the focus from it. */

            if ((pWin == focus->win) && (pWin->parent != NullWindow)) {
                int focusEventMode = NotifyNormal;

                /* If a grab is in progress, then alter the mode of focus events. */

                if (keybd->deviceGrab.grab)
                    focusEventMode = NotifyWhileGrabbed;

                switch (focus->revert) {
                case RevertToNone:
                    DoFocusEvents(keybd, pWin, NoneWin, focusEventMode);
                    focus->win = NoneWin;
                    focus->traceGood = 0;
                    break;
                case RevertToParent:
                    parent = pWin;
                    do {
                        parent = parent->parent;
                        focus->traceGood--;
                    } while (!parent->realized
                    /* This would be a good protocol change -- windows being
                       reparented during SaveSet processing would cause the
                       focus to revert to the nearest enclosing window which
                       will survive the death of the exiting client, instead
                       of ending up reverting to a dying window and thence
                       to None */
#ifdef NOTDEF
                             || wClient(parent)->clientGone
#endif
                        );
                    if (!ActivateFocusInGrab(keybd, pWin, parent))
                        DoFocusEvents(keybd, pWin, parent, focusEventMode);
                    focus->win = parent;
                    focus->revert = RevertToNone;
                    break;
                case RevertToPointerRoot:
                    if (!ActivateFocusInGrab(keybd, pWin, PointerRootWin))
                        DoFocusEvents(keybd, pWin, PointerRootWin,
                                      focusEventMode);
                    focus->win = PointerRootWin;
                    focus->traceGood = 0;
                    break;
                }
            }
        }

        if (IsPointerDevice(keybd)) {
            if (keybd->valuator->motionHintWindow == pWin)
                keybd->valuator->motionHintWindow = NullWindow;
        }
    }

    if (freeResources) {
        if (pWin->dontPropagate)
            DontPropagateRefCnts[pWin->dontPropagate]--;
        while ((oc = wOtherClients(pWin)))
            FreeResource(oc->resource, RT_NONE);
        while ((passive = wPassiveGrabs(pWin)))
            FreeResource(passive->resource, RT_NONE);
    }

    DeleteWindowFromAnyExtEvents(pWin, freeResources);
}

/**
 * Call this whenever some window at or below pWin has changed geometry. If
 * there is a grab on the window, the cursor will be re-confined into the
 * window.
 */
void
CheckCursorConfinement(WindowPtr pWin)
{
    GrabPtr grab;
    WindowPtr confineTo;
    DeviceIntPtr pDev;

#ifdef PANORAMIX
    if (!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
        return;
#endif

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (DevHasCursor(pDev)) {
            grab = pDev->deviceGrab.grab;
            if (grab && (confineTo = grab->confineTo)) {
                if (!BorderSizeNotEmpty(pDev, confineTo))
                    (*pDev->deviceGrab.DeactivateGrab) (pDev);
                else if ((pWin == confineTo) || IsParent(pWin, confineTo))
                    ConfineCursorToWindow(pDev, confineTo, TRUE, TRUE);
            }
        }
    }
}

Mask
EventMaskForClient(WindowPtr pWin, ClientPtr client)
{
    OtherClientsPtr other;

    if (wClient(pWin) == client)
        return pWin->eventMask;
    for (other = wOtherClients(pWin); other; other = other->next) {
        if (SameClient(other, client))
            return other->mask;
    }
    return 0;
}

/**
 * Server-side protocol handling for RecolorCursor request.
 */
int
ProcRecolorCursor(ClientPtr client)
{
    CursorPtr pCursor;
    int rc, nscr;
    ScreenPtr pscr;
    Bool displayed;
    SpritePtr pSprite = PickPointer(client)->spriteInfo->sprite;

    REQUEST(xRecolorCursorReq);

    REQUEST_SIZE_MATCH(xRecolorCursorReq);
    rc = dixLookupResourceByType((void **) &pCursor, stuff->cursor, RT_CURSOR,
                                 client, DixWriteAccess);
    if (rc != Success) {
        client->errorValue = stuff->cursor;
        return rc;
    }

    pCursor->foreRed = stuff->foreRed;
    pCursor->foreGreen = stuff->foreGreen;
    pCursor->foreBlue = stuff->foreBlue;

    pCursor->backRed = stuff->backRed;
    pCursor->backGreen = stuff->backGreen;
    pCursor->backBlue = stuff->backBlue;

    for (nscr = 0; nscr < screenInfo.numScreens; nscr++) {
        pscr = screenInfo.screens[nscr];
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            displayed = (pscr == pSprite->screen);
        else
#endif
            displayed = (pscr == pSprite->hotPhys.pScreen);
        (*pscr->RecolorCursor) (PickPointer(client), pscr, pCursor,
                                (pCursor == pSprite->current) && displayed);
    }
    return Success;
}

/**
 * Write the given events to a client, swapping the byte order if necessary.
 * To swap the byte ordering, a callback is called that has to be set up for
 * the given event type.
 *
 * In the case of DeviceMotionNotify trailed by DeviceValuators, the events
 * can be more than one. Usually it's just one event.
 *
 * Do not modify the event structure passed in. See comment below.
 *
 * @@param pClient Client to send events to.
 * @@param count Number of events.
 * @@param events The event list.
 */
void
WriteEventsToClient(ClientPtr pClient, int count, xEvent *events)
{
#ifdef PANORAMIX
    xEvent eventCopy;
#endif
    xEvent *eventTo, *eventFrom;
    int i, eventlength = sizeof(xEvent);

    if (!pClient || pClient == serverClient || pClient->clientGone)
        return;

    for (i = 0; i < count; i++)
        if ((events[i].u.u.type & 0x7f) != KeymapNotify)
            events[i].u.u.sequenceNumber = pClient->sequence;

    /* Let XKB rewrite the state, as it depends on client preferences. */
    XkbFilterEvents(pClient, count, events);

#ifdef PANORAMIX
    if (!noPanoramiXExtension &&
        (screenInfo.screens[0]->x || screenInfo.screens[0]->y)) {
        switch (events->u.u.type) {
        case MotionNotify:
        case ButtonPress:
        case ButtonRelease:
        case KeyPress:
        case KeyRelease:
        case EnterNotify:
        case LeaveNotify:
            /*
               When multiple clients want the same event DeliverEventsToWindow
               passes the same event structure multiple times so we can't
               modify the one passed to us
             */
            count = 1;          /* should always be 1 */
            memcpy(&eventCopy, events, sizeof(xEvent));
            eventCopy.u.keyButtonPointer.rootX += screenInfo.screens[0]->x;
            eventCopy.u.keyButtonPointer.rootY += screenInfo.screens[0]->y;
            if (eventCopy.u.keyButtonPointer.event ==
                eventCopy.u.keyButtonPointer.root) {
                eventCopy.u.keyButtonPointer.eventX += screenInfo.screens[0]->x;
                eventCopy.u.keyButtonPointer.eventY += screenInfo.screens[0]->y;
            }
            events = &eventCopy;
            break;
        default:
            break;
        }
    }
#endif

    if (EventCallback) {
        EventInfoRec eventinfo;

        eventinfo.client = pClient;
        eventinfo.events = events;
        eventinfo.count = count;
        CallCallbacks(&EventCallback, (void *) &eventinfo);
    }
#ifdef XSERVER_DTRACE
    if (XSERVER_SEND_EVENT_ENABLED()) {
        for (i = 0; i < count; i++) {
            XSERVER_SEND_EVENT(pClient->index, events[i].u.u.type, &events[i]);
        }
    }
#endif
    /* Just a safety check to make sure we only have one GenericEvent, it just
     * makes things easier for me right now. (whot) */
    for (i = 1; i < count; i++) {
        if (events[i].u.u.type == GenericEvent) {
            ErrorF("[dix] TryClientEvents: Only one GenericEvent at a time.\n");
            return;
        }
    }

    if (events->u.u.type == GenericEvent) {
        eventlength += ((xGenericEvent *) events)->length * 4;
    }

    if (pClient->swapped) {
        if (eventlength > swapEventLen) {
            swapEventLen = eventlength;
            swapEvent = realloc(swapEvent, swapEventLen);
            if (!swapEvent) {
                FatalError("WriteEventsToClient: Out of memory.\n");
                return;
            }
        }

        for (i = 0; i < count; i++) {
            eventFrom = &events[i];
            eventTo = swapEvent;

            /* Remember to strip off the leading bit of type in case
               this event was sent with "SendEvent." */
            (*EventSwapVector[eventFrom->u.u.type & 0177])
                (eventFrom, eventTo);

            WriteToClient(pClient, eventlength, eventTo);
        }
    }
    else {
        /* only one GenericEvent, remember? that means either count is 1 and
         * eventlength is arbitrary or eventlength is 32 and count doesn't
         * matter. And we're all set. Woohoo. */
        WriteToClient(pClient, count * eventlength, events);
    }
}

/*
 * Set the client pointer for the given client.
 *
 * A client can have exactly one ClientPointer. Each time a
 * request/reply/event is processed and the choice of devices is ambiguous
 * (e.g. QueryPointer request), the server will pick the ClientPointer (see
 * PickPointer()).
 * If a keyboard is needed, the first keyboard paired with the CP is used.
 */
int
SetClientPointer(ClientPtr client, DeviceIntPtr device)
{
    int rc = XaceHook(XACE_DEVICE_ACCESS, client, device, DixUseAccess);

    if (rc != Success)
        return rc;

    if (!IsMaster(device)) {
        ErrorF("[dix] Need master device for ClientPointer. This is a bug.\n");
        return BadDevice;
    }
    else if (!device->spriteInfo->spriteOwner) {
        ErrorF("[dix] Device %d does not have a sprite. "
               "Cannot be ClientPointer\n", device->id);
        return BadDevice;
    }
    client->clientPtr = device;
    return Success;
}

/* PickPointer will pick an appropriate pointer for the given client.
 *
 * An "appropriate device" is (in order of priority):
 *  1) A device the given client has a core grab on.
 *  2) A device set as ClientPointer for the given client.
 *  3) The first master device.
 */
DeviceIntPtr
PickPointer(ClientPtr client)
{
    DeviceIntPtr it = inputInfo.devices;

    /* First, check if the client currently has a grab on a device. Even
     * keyboards count. */
    for (it = inputInfo.devices; it; it = it->next) {
        GrabPtr grab = it->deviceGrab.grab;

        if (grab && grab->grabtype == CORE && SameClient(grab, client)) {
            it = GetMaster(it, MASTER_POINTER);
            return it;          /* Always return a core grabbed device */
        }
    }

    if (!client->clientPtr) {
        it = inputInfo.devices;
        while (it) {
            if (IsMaster(it) && it->spriteInfo->spriteOwner) {
                client->clientPtr = it;
                break;
            }
            it = it->next;
        }
    }
    return client->clientPtr;
}

/* PickKeyboard will pick an appropriate keyboard for the given client by
 * searching the list of devices for the keyboard device that is paired with
 * the client's pointer.
 */
DeviceIntPtr
PickKeyboard(ClientPtr client)
{
    DeviceIntPtr ptr = PickPointer(client);
    DeviceIntPtr kbd = GetMaster(ptr, MASTER_KEYBOARD);

    if (!kbd) {
        ErrorF("[dix] ClientPointer not paired with a keyboard. This "
               "is a bug.\n");
    }

    return kbd;
}

/* A client that has one or more core grabs does not get core events from
 * devices it does not have a grab on. Legacy applications behave bad
 * otherwise because they are not used to it and the events interfere.
 * Only applies for core events.
 *
 * Return true if a core event from the device would interfere and should not
 * be delivered.
 */
Bool
IsInterferingGrab(ClientPtr client, DeviceIntPtr dev, xEvent *event)
{
    DeviceIntPtr it = inputInfo.devices;

    switch (event->u.u.type) {
    case KeyPress:
    case KeyRelease:
    case ButtonPress:
    case ButtonRelease:
    case MotionNotify:
    case EnterNotify:
    case LeaveNotify:
        break;
    default:
        return FALSE;
    }

    if (dev->deviceGrab.grab && SameClient(dev->deviceGrab.grab, client))
        return FALSE;

    while (it) {
        if (it != dev) {
            if (it->deviceGrab.grab && SameClient(it->deviceGrab.grab, client)
                && !it->deviceGrab.fromPassiveGrab) {
                if ((IsPointerDevice(it) && IsPointerDevice(dev)) ||
                    (IsKeyboardDevice(it) && IsKeyboardDevice(dev)))
                    return TRUE;
            }
        }
        it = it->next;
    }

    return FALSE;
}

/* PointerBarrier events are only delivered to the client that created that
 * barrier */
static Bool
IsWrongPointerBarrierClient(ClientPtr client, DeviceIntPtr dev, xEvent *event)
{
    xXIBarrierEvent *ev = (xXIBarrierEvent*)event;

    if (ev->type != GenericEvent || ev->extension != IReqCode)
        return FALSE;

    if (ev->evtype != XI_BarrierHit && ev->evtype != XI_BarrierLeave)
        return FALSE;

    return client->index != CLIENT_ID(ev->barrier);
}
@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d5358 6
@


1.15
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d4789 2
a4790 2
            focus->trace = realloc(focus->trace,
                                   focus->traceSize * sizeof(WindowPtr));
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d128 1
a128 7

#ifdef XSERVER_DTRACE
#include <sys/types.h>
typedef const char *string;

#include "Xserver-dtrace.h"
#endif
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1066 1
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d583 1
a583 1
        rc = dixLookupResourceByType((pointer *) &win, pWin->drawable.id,
d1165 1
a1165 1
        CallCallbacks(&DeviceEventCallback, (pointer) &eventinfo);
d2674 3
d2838 1
a2838 1
static Bool
d2879 1
a2879 2
    WindowPtr pWin;
    BoxRec box;
d2881 1
a2881 40
    pSprite->spriteTraceGood = 1;       /* root window still there */
    pWin = RootWindow(pSprite)->firstChild;
    while (pWin) {
        if ((pWin->mapped) &&
            (x >= pWin->drawable.x - wBorderWidth(pWin)) &&
            (x < pWin->drawable.x + (int) pWin->drawable.width +
             wBorderWidth(pWin)) &&
            (y >= pWin->drawable.y - wBorderWidth(pWin)) &&
            (y < pWin->drawable.y + (int) pWin->drawable.height +
             wBorderWidth(pWin))
            /* When a window is shaped, a further check
             * is made to see if the point is inside
             * borderSize
             */
            && (!wBoundingShape(pWin) || PointInBorderSize(pWin, x, y))
            && (!wInputShape(pWin) ||
                RegionContainsPoint(wInputShape(pWin),
                                    x - pWin->drawable.x,
                                    y - pWin->drawable.y, &box))
#ifdef ROOTLESS
            /* In rootless mode windows may be offscreen, even when
             * they're in X's stack. (E.g. if the native window system
             * implements some form of virtual desktop system).
             */
            && !pWin->rootlessUnhittable
#endif
            ) {
            if (pSprite->spriteTraceGood >= pSprite->spriteTraceSize) {
                pSprite->spriteTraceSize += 10;
                pSprite->spriteTrace = realloc(pSprite->spriteTrace,
                                               pSprite->spriteTraceSize *
                                               sizeof(WindowPtr));
            }
            pSprite->spriteTrace[pSprite->spriteTraceGood++] = pWin;
            pWin = pWin->firstChild;
        }
        else
            pWin = pWin->nextSib;
    }
    return DeepestSpriteWin(pSprite);
d3240 1
a3240 1
    pSprite->current = RefCursor(pCursor);
d3794 2
d3924 2
a4262 6
        /* XXX: In theory, we could pass the internal events through to
         * everything and only convert just before hitting the wire. We can't
         * do that yet, so DGE is the last stop for internal events. From here
         * onwards, we deal with core/XI events.
         */

d4376 1
a4376 1
OtherClientGone(pointer value, XID id)
d4457 1
a4457 1
        if (!AddResource(others->resource, RT_OTHERCLIENT, (pointer) pWin))
d4944 1
a4944 1
        int rc = dixLookupResourceByType((pointer *) &newCursor, stuff->cursor,
d5015 1
a5015 1
 * @@returns Success or BadValue.
d5061 1
a5061 1
        rc = dixLookupResourceByType((pointer *) &cursor, curs, RT_CURSOR,
d5096 2
d5589 1
a5589 1
        rc = dixLookupResourceByType((pointer *) &cursor, stuff->cursor,
d5843 1
a5843 1
    rc = dixLookupResourceByType((pointer *) &pCursor, stuff->cursor, RT_CURSOR,
d5944 1
a5944 1
        CallCallbacks(&EventCallback, (pointer) &eventinfo);
@


1.11
log
@Update to xserver 1.14.4
@
text
@d1247 3
d4699 1
a4699 1
    if (grab && grab->type == XI2) {
@


1.10
log
@Update to xserver 1.14.3
@
text
@d265 5
d1051 1
a1051 1
MonthChangedOrBadTime(InternalEvent *ev)
d1057 1
a1057 1
    if ((currentTime.milliseconds - ev->any.time) > TIMESLOP)
d1060 11
a1070 1
        ev->any.time = currentTime.milliseconds;
d1074 1
a1074 1
NoticeTime(InternalEvent *ev, DeviceIntPtr dev)
d1076 6
a1081 5
    if (ev->any.time < currentTime.milliseconds)
        MonthChangedOrBadTime(ev);
    currentTime.milliseconds = ev->any.time;
    lastDeviceEventTime[XIAllDevices] = currentTime;
    lastDeviceEventTime[dev->id] = currentTime;
d1088 30
a1117 1
        NoticeTime(ev, dev);
d1141 1
a1141 1
    NoticeTime((InternalEvent *)event, device);
d2150 1
d2170 15
a2184 7
                rc = EVENT_DELIVERED;
                *client_return = client;
                *mask_return = mask;
                /* Success overrides non-success, so if we've been
                 * successful on one client, return that */
            }
            else if (rc == EVENT_NOT_DELIVERED)
d4187 3
d4301 2
a4302 11
        if (sendCore && grab->grabtype == CORE) {
            deliveries = DeliverOneGrabbedEvent(event, thisDev, CORE);
        }

        if (!deliveries) {
            deliveries = DeliverOneGrabbedEvent(event, thisDev, XI2);
        }

        if (!deliveries) {
            deliveries = DeliverOneGrabbedEvent(event, thisDev, XI);
        }
d4307 5
a4311 1
    if (deliveries && !deactivateGrab && event->any.type != ET_Motion) {
d4696 1
a4696 1
    if (grab) {
d5321 1
d5323 4
a5326 1
        lastDeviceEventTime[i] = currentTime;
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d934 1
a934 2
        pSprite->current = cursor;
        pSprite->current->refcnt++;
d1426 1
d1430 5
a1434 5
            CLIENT_BITS(ti->listeners[0].listener) == grab->resource) {
            ti->listeners[0].listener = grab->resource;
            ti->listeners[0].level = grab->grabtype;
            ti->listeners[0].state = LISTENER_IS_OWNER;
            ti->listeners[0].window = grab->window;
d1438 1
a1438 1
                ti->listeners[0].type = LISTENER_POINTER_GRAB;
d1440 4
a1443 2
                ti->listeners[0].type = LISTENER_GRAB;
            ti->listeners[0].grab = grab;
d1468 1
d1491 1
a1491 4
    if (grab->cursor)
        grab->cursor->refcnt++;
    CopyGrab(grabinfo->activeGrab, grab);
    grabinfo->grab = grabinfo->activeGrab;
d1498 2
d1523 1
d1528 6
a1533 1
                    !xi2mask_isset(mouse->deviceGrab.grab->xi2mask, mouse, XI_TouchBegin))
d1535 2
a1536 1
            TouchListenerAcceptReject(mouse, ti, 0, XIRejectTouch);
a1555 2
    if (grab->cursor)
        FreeCursor(grab->cursor, (Cursor) 0);
d1561 2
d1575 1
d1601 1
a1601 2
    CopyGrab(grabinfo->activeGrab, grab);
    grabinfo->grab = grabinfo->activeGrab;
d1606 2
d1649 2
d1755 10
d1997 1
a1997 1
    tempGrab = AllocGrab();
d3217 1
a3217 2
    if (pCursor)
        pCursor->refcnt++;
d3220 1
a3220 1
    pSprite->current = pCursor;
d3299 1
a3299 3
    pCursor = wCursor(win);
    if (pCursor)
        pCursor->refcnt++;
d3901 1
a3901 1
    tempGrab = AllocGrab();
a4858 1
    CursorPtr oldCursor;
a4880 1
    oldCursor = NullCursor;
d4883 2
a4884 6
    if (grab) {
        if (grab->confineTo && !confineTo)
            ConfineCursorToWindow(device, GetCurrentRootWindow(device), FALSE,
                                  FALSE);
        oldCursor = grab->cursor;
    }
a4893 3
    if (oldCursor && status == GrabSuccess)
        FreeCursor(oldCursor, (Cursor) 0);

d4949 1
a4949 3
    grab->cursor = newCursor;
    if (newCursor)
        newCursor->refcnt++;
d5079 1
a5079 1
        tempGrab = AllocGrab();
d5094 1
a5094 1
        tempGrab->cursor = cursor;
d5435 1
a5435 1
    tempGrab = AllocGrab();
d5629 1
a5629 1
    tempGrab = AllocGrab();
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d222 3
a354 2
extern int DeviceMotionNotify;

d704 4
a707 3
CheckPhysLimits(DeviceIntPtr pDev, CursorPtr cursor, Bool generateEvents, Bool confineToScreen, /* unused if PanoramiX on */
                ScreenPtr pScreen)
{                               /* unused if PanoramiX on */
d1060 1
a1060 1
NoticeTime(InternalEvent *ev)
d1065 2
a1066 1
    lastDeviceEventTime = currentTime;
d1070 1
a1070 1
NoticeEventTime(InternalEvent *ev)
d1073 1
a1073 1
        NoticeTime(ev);
d1097 1
a1097 1
    NoticeTime((InternalEvent *) event);
d1441 1
d1510 1
d1516 15
a1553 9

    /* If an explicit grab was deactivated, we must remove it from the head of
     * all the touches' listener lists. */
    for (i = 0; mouse->touch && i < mouse->touch->num_touches; i++) {
        TouchPointInfoPtr ti = mouse->touch->touches + i;

        if (ti->active && TouchResourceIsOwner(ti, grab_resource))
            TouchListenerAcceptReject(mouse, ti, 0, XIRejectTouch);
    }
d1569 1
a1569 1
    if (grab->grabtype == XI2 &&
d1573 3
a1575 1
    if (grabinfo->grab)
d1585 2
a1586 1
    DoFocusEvents(keybd, oldWin, grab->window, NotifyGrab);
d1607 1
a1607 2
    WindowPtr focusWin = keybd->focus ? keybd->focus->win
        : keybd->spriteInfo->sprite->win;
a1610 2
    if (focusWin == FollowKeyboardWin)
        focusWin = inputInfo.keyboard->focus->win;
d1621 11
d2041 1
a2041 1
                      xEvent *events, Mask filter, InputClients ** clients)
d2046 1
a2046 1
        *clients = (InputClients *) wOtherClients(win);
d2053 1
a2053 1
        *clients = inputMasks->inputClients;
d2062 1
a2062 1
        *clients = inputMasks->inputClients;
d2090 3
d2127 1
a2127 1
    InputClients *clients;
d2129 1
a2129 1
    if (!GetClientsForDelivery(dev, win, events, filter, &clients))
d2132 1
a2132 1
    return DeliverEventToInputClients(dev, clients, win, events, count, filter,
d2241 1
a2241 1
FilterRawEvents(const ClientPtr client, const GrabPtr grab)
d2257 4
a2260 1
    return (cmp == 0) ? TRUE : SameClient(grab, client);
d2313 1
a2313 1
            if (!FilterRawEvents(rClient(&ic), grab))
d2450 2
d2466 2
a2467 2
            event->event_x = event->root_x - FP1616(pWin->drawable.x, 0);
            event->event_y = event->root_y - FP1616(pWin->drawable.y, 0);
d2867 9
a2875 8
    memset(&event, 0, sizeof(DeviceEvent));
    event.header = ET_Internal;
    event.type = ET_FocusIn;
    event.length = sizeof(DeviceEvent);
    event.time = GetTimeInMillis();
    event.deviceid = dev->id;
    event.sourceid = dev->id;
    event.detail.button = 0;
d2905 9
a2913 8
    memset(&event, 0, sizeof(DeviceEvent));
    event.header = ET_Internal;
    event.type = ET_Enter;
    event.length = sizeof(DeviceEvent);
    event.time = GetTimeInMillis();
    event.deviceid = dev->id;
    event.sourceid = dev->id;
    event.detail.button = 0;
d3228 12
a4360 1
     /*NOTREACHED*/ return -1;  /* make compiler happy */
d4383 4
a4386 6
    if (check & (pWin->eventMask | wOtherEventMasks(pWin))) {   /* It is illegal for two different
                                                                   clients to select on any of the
                                                                   events for AtMostOneClient. However,
                                                                   it is OK, for some client to
                                                                   continue selecting on one of those
                                                                   events.  */
d4439 1
a4439 1
    int i, free;
d4450 1
a4450 1
        for (i = DNPMCOUNT, free = 0; --i > 0;) {
d4452 1
a4452 1
                free = i;
d4456 2
a4457 2
        if (!i && free) {
            i = free;
d4492 4
a4495 1
    xEvent event;
a4514 3
    memset(&event, 0, sizeof(xEvent));
    event.u.u.type = type;
    event.u.u.detail = detail;
d4545 3
a4547 1
        xKeymapEvent ke;
d4549 1
d4551 3
a4553 4
        if (XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixReadAccess))
            memset((char *) &ke.map[0], 0, 31);
        else
            memmove((char *) &ke.map[0], (char *) &keybd->key->down[1], 31);
a4554 1
        ke.type = KeymapNotify;
d4572 1
d4596 2
a4597 2
    event->root_x = FP1616(mouse->spriteInfo->sprite->hot.x, 0);
    event->root_y = FP1616(mouse->spriteInfo->sprite->hot.y, 0);
d4614 5
d4645 4
a4648 3
    xEvent event;

    memset(&event, 0, sizeof(xEvent));
a4649 2
    event.u.u.type = type;
    event.u.u.detail = detail;
d4656 3
a4658 1
        xKeymapEvent ke;
d4660 1
d4662 3
a4664 4
        if (XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess))
            memset((char *) &ke.map[0], 0, 31);
        else
            memmove((char *) &ke.map[0], (char *) &dev->key->down[1], 31);
a4665 1
        ke.type = KeymapNotify;
d4807 7
a4813 4
    memset(&rep, 0, sizeof(xGetInputFocusReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d4820 1
a4820 1
    rep.revertTo = focus->revert;
d4840 1
a4861 1
    memset(&rep, 0, sizeof(xGrabPointerReply));
d4876 1
a4876 1
                    &mask, CORE, stuff->cursor, stuff->confineTo, &rep.status);
d4880 1
a4880 1
    if (oldCursor && rep.status == GrabSuccess)
d4883 6
a4888 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
d5055 1
a5055 1
    if (grab && !SameClient(grab, client))
d5105 1
a5113 1
    memset(&rep, 0, sizeof(xGrabKeyboardReply));
d5119 1
a5119 1
                        None, &rep.status);
d5123 7
a5129 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
d5192 10
a5201 9
    memset(&rep, 0, sizeof(xQueryPointerReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.mask = event_get_corestate(mouse, keyboard);
    rep.length = 0;
    rep.root = (GetCurrentRootWindow(mouse))->drawable.id;
    rep.rootX = pSprite->hot.x;
    rep.rootY = pSprite->hot.y;
    rep.child = None;
d5261 1
a5274 1
    lastDeviceEventTime = currentTime;
d5469 7
a5475 6
    memset(&param, 0, sizeof(param));
    param.grabtype = CORE;
    param.ownerEvents = stuff->ownerEvents;
    param.this_device_mode = stuff->keyboardMode;
    param.other_devices_mode = stuff->pointerMode;
    param.modifiers = stuff->modifiers;
d5576 7
a5582 6
    memset(&param, 0, sizeof(param));
    param.grabtype = CORE;
    param.ownerEvents = stuff->ownerEvents;
    param.this_device_mode = stuff->keyboardMode;
    param.other_devices_mode = stuff->pointerMode;
    param.modifiers = stuff->modifiers;
d5686 2
a5687 2
            /* If the focus window is a root window (ie. has no parent) then don't
               delete the focus from it. */
d5709 6
a5714 6
                             /* This would be a good protocol change -- windows being reparented
                                during SaveSet processing would cause the focus to revert to the
                                nearest enclosing window which will survive the death of the exiting
                                client, instead of ending up reverting to a dying window and thence
                                to None
                              */
d5954 1
a5954 1
            WriteToClient(pClient, eventlength, (char *) eventTo);
d5961 1
a5961 1
        WriteToClient(pClient, count * eventlength, (char *) events);
d6091 16
@


1.7
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@a24 1

d132 1
d155 1
d158 1
a158 1
#define NoSuchEvent 0x80000000	/* so doesn't match NoEventMask */
a179 1

d193 1
a193 1
    xGenericEvent* e = (xGenericEvent*)event;
d195 2
a196 1
    return (e->type != GenericEvent || e->extension != IReqCode) ? 0 : e->evtype;
a208 1

d217 4
a220 5
static void CheckVirtualMotion( DeviceIntPtr pDev, QdEventPtr qe, WindowPtr pWin);
static void CheckPhysLimits(DeviceIntPtr pDev,
                            CursorPtr cursor,
                            Bool generateEvents,
                            Bool confineToScreen,
d267 1
a267 1
static xEvent* swapEvent = NULL;
d285 1
d318 1
a318 2
            (dev->valuator && dev->button) ||
            (dev->valuator && !dev->key);
d332 1
a332 1
            ((dev->key && dev->kbdfeed) && !IsPointerDevice(dev));
d344 1
a344 1
    return GetMaster(dev, MASTER_KEYBOARD) == NULL;
a346 1

d368 1
a368 1
static Mask filters[MAXDEVICES][128];
d370 36
a405 37
static const Mask default_filter[128] =
{
	NoSuchEvent,		       /* 0 */
	NoSuchEvent,		       /* 1 */
	KeyPressMask,		       /* KeyPress */
	KeyReleaseMask,		       /* KeyRelease */
	ButtonPressMask,	       /* ButtonPress */
	ButtonReleaseMask,	       /* ButtonRelease */
	PointerMotionMask,	       /* MotionNotify (initial state) */
	EnterWindowMask,	       /* EnterNotify */
	LeaveWindowMask,	       /* LeaveNotify */
	FocusChangeMask,	       /* FocusIn */
	FocusChangeMask,	       /* FocusOut */
	KeymapStateMask,	       /* KeymapNotify */
	ExposureMask,		       /* Expose */
	CantBeFiltered,		       /* GraphicsExpose */
	CantBeFiltered,		       /* NoExpose */
	VisibilityChangeMask,	       /* VisibilityNotify */
	SubstructureNotifyMask,	       /* CreateNotify */
	StructureAndSubMask,	       /* DestroyNotify */
	StructureAndSubMask,	       /* UnmapNotify */
	StructureAndSubMask,	       /* MapNotify */
	SubstructureRedirectMask,      /* MapRequest */
	StructureAndSubMask,	       /* ReparentNotify */
	StructureAndSubMask,	       /* ConfigureNotify */
	SubstructureRedirectMask,      /* ConfigureRequest */
	StructureAndSubMask,	       /* GravityNotify */
	ResizeRedirectMask,	       /* ResizeRequest */
	StructureAndSubMask,	       /* CirculateNotify */
	SubstructureRedirectMask,      /* CirculateRequest */
	PropertyChangeMask,	       /* PropertyNotify */
	CantBeFiltered,		       /* SelectionClear */
	CantBeFiltered,		       /* SelectionRequest */
	CantBeFiltered,		       /* SelectionNotify */
	ColormapChangeMask,	       /* ColormapNotify */
	CantBeFiltered,		       /* ClientMessage */
	CantBeFiltered		       /* MappingNotify */
d429 1
a429 1
        return filters[dev ? dev->id : 0][event->u.u.type];
d431 1
a431 1
        return (1 << (evtype % 8));
d437 18
a454 1
 * Return the windows complete XI2 mask for the given XI2 event type.
d456 2
a457 2
Mask
GetWindowXI2Mask(DeviceIntPtr dev, WindowPtr win, xEvent* ev)
a459 1
    int filter;
d465 1
a465 2
    evtype = ((xGenericEvent*)ev)->evtype;
    filter = GetEventFilter(dev, ev);
d467 1
a467 3
    return ((inputMasks->xi2mask[dev->id][evtype/8] & filter) ||
            inputMasks->xi2mask[XIAllDevices][evtype/8] ||
            (inputMasks->xi2mask[XIAllMasterDevices][evtype/8] && IsMaster(dev)));
d471 1
a471 1
GetEventMask(DeviceIntPtr dev, xEvent *event, InputClients* other)
d476 4
a479 7
    if ((evtype = xi2_get_type(event)))
    {
        int byte = evtype / 8;
        return (other->xi2mask[dev->id][byte] |
                other->xi2mask[XIAllDevices][byte] |
                (IsMaster(dev)? other->xi2mask[XIAllMasterDevices][byte] : 0));
    } else if (core_get_type(event) != 0)
d485 2
a486 4

static CARD8 criticalEvents[32] =
{
    0x7c, 0x30, 0x40			/* key, button, expose, and configure events */
d490 2
a491 1
SyntheticMotion(DeviceIntPtr dev, int x, int y) {
d499 2
a500 1
            (syncEvents.playingEvents) ?  syncEvents.time.milliseconds : currentTime.milliseconds);
d508 1
a508 1
pointOnScreen(ScreenPtr pScreen, int x, int y)
a509 11
    return x >= pScreen->x && x < pScreen->x + pScreen->width &&
           y >= pScreen->y && y < pScreen->y + pScreen->height;
}

static Bool
XineramaSetCursorPosition(
    DeviceIntPtr pDev,
    int x,
    int y,
    Bool generateEvent
){
d522 9
a530 12
    if(!pointOnScreen(pScreen, x, y))
    {
	FOR_NSCREENS(i)
	{
	    if(i == pScreen->myNum)
		continue;
	    if(pointOnScreen(screenInfo.screens[i], x, y))
	    {
		pScreen = screenInfo.screens[i];
		break;
	    }
	}
d539 1
a539 1
    return (*pScreen->SetCursorPosition)(pDev, pScreen, x, y, generateEvent);
a541 1

d559 1
a559 1
    (* pScreen->ConstrainCursor)(pDev, pScreen, &newBox);
a561 1

d567 21
a587 19
    if(pWin == screenInfo.screens[0]->root) {
	int i;
	FOR_NSCREENS(i)
	    pSprite->windows[i] = screenInfo.screens[i]->root;
    } else {
	PanoramiXRes *win;
	int rc, i;

	rc = dixLookupResourceByType((pointer *)&win, pWin->drawable.id,
				     XRT_WINDOW, serverClient, DixReadAccess);
	if (rc != Success)
	    return FALSE;

	FOR_NSCREENS(i) {
	    rc = dixLookupWindow(pSprite->windows + i, win->info[i].id,
				 serverClient, DixReadAccess);
	    if (rc != Success)  /* window is being unmapped */
		return FALSE;
	}
d594 1
a594 2
                              WindowPtr pWin,
                              Bool generateEvents)
d600 1
a600 1
    if(!XineramaSetWindowPntrs(pDev, pWin))
d605 1
a605 2
    RegionCopy(&pSprite->Reg1,
            &pSprite->windows[i]->borderSize);
d609 1
a609 1
    while(i--) {
d613 1
a613 1
        if(x || y)
d617 1
a617 1
                &pSprite->windows[i]->borderSize);
d625 1
a625 1
    if(RegionNumRects(&pSprite->Reg1) > 1)
d631 2
a632 1
    pSprite->confineWin = (pWin == screenInfo.screens[0]->root) ? NullWindow : pWin;
d637 1
a637 1
#endif  /* PANORAMIX */
d658 1
a658 1
    filters[deviceid][event] = mask;
d664 2
a665 2
    if (event >= 128)
	FatalError("SetCriticalEvent: bogus event number");
a674 1
    SpritePtr pSprite;
a675 1
    pSprite = pDev->spriteInfo->sprite;
d677 1
a677 1
	return;
d681 16
a696 19
	x += incx;
	if (x >= box.x2)
	{
	    incx = -1;
	    x = *px - 1;
	}
	else if (x < box.x1)
	{
	    incx = 1;
	    x = *px;
	    y += incy;
	    if (y >= box.y2)
	    {
		incy = -1;
		y = *py - 1;
	    }
	    else if (y < box.y1)
		return; /* should never get here! */
	}
d703 3
a705 7
CheckPhysLimits(
    DeviceIntPtr pDev,
    CursorPtr cursor,
    Bool generateEvents,
    Bool confineToScreen, /* unused if PanoramiX on */
    ScreenPtr pScreen)    /* unused if PanoramiX on */
{
d710 1
a710 1
	return;
d724 1
a724 1
                &pSprite->physLimits);
d726 1
a726 1
        (* pScreen->ConstrainCursor)(pDev, pScreen, &pSprite->physLimits);
d731 3
a733 4
	new.x = pSprite->physLimits.x1;
    else
	if (new.x >= pSprite->physLimits.x2)
	    new.x = pSprite->physLimits.x2 - 1;
d735 3
a737 4
	new.y = pSprite->physLimits.y1;
    else
	if (new.y >= pSprite->physLimits.y2)
	    new.y = pSprite->physLimits.y2 - 1;
d739 1
a739 1
	ConfineToShape(pDev, pSprite->hotShape, &new.x, &new.y);
d745 1
a745 2
	(new.x != pSprite->hotPhys.x) || (new.y != pSprite->hotPhys.y))
    {
d748 1
a748 1
            XineramaSetCursorPosition (pDev, new.x, new.y, generateEvents);
d769 1
a769 4
CheckVirtualMotion(
    DeviceIntPtr pDev,
    QdEventPtr qe,
    WindowPtr pWin)
d775 1
a775 2
    if (qe)
    {
d777 17
a793 16
        switch(ev->type)
        {
            case ET_Motion:
            case ET_ButtonPress:
            case ET_ButtonRelease:
            case ET_KeyPress:
            case ET_KeyRelease:
            case ET_ProximityIn:
            case ET_ProximityOut:
                pSprite->hot.pScreen = qe->pScreen;
                pSprite->hot.x = ev->root_x;
                pSprite->hot.y = ev->root_y;
                pWin = pDev->deviceGrab.grab ? pDev->deviceGrab.grab->confineTo : NullWindow;
                break;
            default:
                break;
d796 2
a797 3
    if (pWin)
    {
	BoxRec lims;
d803 1
a803 1
            if(!XineramaSetWindowPntrs(pDev, pWin))
d808 1
a808 2
            RegionCopy(&pSprite->Reg2,
                    &pSprite->windows[i]->borderSize);
d812 1
a812 1
            while(i--) {
d816 1
a816 1
                if(x || y)
d820 1
a820 1
                        &pSprite->windows[i]->borderSize);
d825 2
a826 1
        } else
d829 1
a829 2
            if (pSprite->hot.pScreen != pWin->drawable.pScreen)
            {
d835 9
a843 9
	lims = *RegionExtents(&pWin->borderSize);
	if (pSprite->hot.x < lims.x1)
	    pSprite->hot.x = lims.x1;
	else if (pSprite->hot.x >= lims.x2)
	    pSprite->hot.x = lims.x2 - 1;
	if (pSprite->hot.y < lims.y1)
	    pSprite->hot.y = lims.y1;
	else if (pSprite->hot.y >= lims.y2)
	    pSprite->hot.y = lims.y2 - 1;
d846 1
a846 2
        if (!noPanoramiXExtension)
        {
d850 2
a851 1
        } else
d861 5
a865 6
	if (qe && ev)
	{
	    qe->pScreen = pSprite->hot.pScreen;
	    ev->root_x = pSprite->hot.x;
	    ev->root_y = pSprite->hot.y;
	}
d868 1
a868 1
    if (noPanoramiXExtension) /* No typo. Only set the root win if disabled */
d874 2
a875 1
ConfineCursorToWindow(DeviceIntPtr pDev, WindowPtr pWin, Bool generateEvents, Bool confineToScreen)
d879 3
a881 4
    if (syncEvents.playingEvents)
    {
	CheckVirtualMotion(pDev, (QdEventPtr)NULL, pWin);
	SyntheticMotion(pDev, pSprite->hot.x, pSprite->hot.y);
d883 1
a883 2
    else
    {
d885 1
a885 1
        if(!noPanoramiXExtension) {
d890 3
a892 3
	pSprite->hotLimits = *RegionExtents(&pWin->borderSize);
	pSprite->hotShape = wBoundingShape(pWin) ? &pWin->borderSize
					       : NullRegion;
d917 5
a921 6
    if (cursor != pSprite->current)
    {
	if ((pSprite->current->bits->xhot != cursor->bits->xhot) ||
		(pSprite->current->bits->yhot != cursor->bits->yhot))
	    CheckPhysLimits(pDev, cursor, FALSE, pSprite->confined,
			    (ScreenPtr)NULL);
d930 4
a933 4
        (*pScreen->DisplayCursor)(pDev, pScreen, cursor);
	FreeCursor(pSprite->current, (Cursor)0);
	pSprite->current = cursor;
	pSprite->current->refcnt++;
d944 2
a945 1
	if (b == a) return TRUE;
d959 2
a960 2
    SpritePtr   pSprite = pDev->spriteInfo->sprite;
    CursorPtr   pCursor;
d963 10
a972 12
	return;
    if (grab)
    {
	if (grab->cursor)
	{
	    ChangeToCursor(pDev, grab->cursor);
	    return;
	}
	if (IsParent(grab->window, pSprite->win))
	    win = pSprite->win;
	else
	    win = grab->window;
d975 3
a977 5
	win = pSprite->win;
    for (; win; win = win->parent)
    {
	if (win->optional)
        {
d981 1
a981 2
            if (pCursor)
            {
d985 1
a985 1
	}
a988 1

d1024 1
d1033 5
a1037 4
    if(!noPanoramiXExtension) {
	return pDev->spriteInfo->sprite->screen->myNum;
    } else {
	return 0;
d1040 1
a1040 1
#endif /* PANORAMIX */
d1042 1
a1042 1
#define TIMESLOP (5 * 60 * 1000) /* 5 minutes */
d1052 1
a1052 1
	currentTime.months++;
d1070 1
a1070 1
	NoticeTime(ev);
d1085 4
a1088 4
    QdEventPtr	tail = *syncEvents.pendtail;
    QdEventPtr	qe;
    SpritePtr	pSprite = device->spriteInfo->sprite;
    int		eventlen;
d1091 4
a1094 1
    NoticeTime((InternalEvent*)event);
d1099 4
a1102 1
	AccessXCancelRepeatKey(device->key->xkbInfo, event->detail.key);
d1104 11
a1114 3
    if (DeviceEventCallback)
    {
	DeviceEventInfoRec eventinfo;
d1116 3
a1118 15
	/*  The RECORD spec says that the root window field of motion events
	 *  must be valid.  At this point, it hasn't been filled in yet, so
	 *  we do it here.  The long expression below is necessary to get
	 *  the current root window; the apparently reasonable alternative
	 *  GetCurrentRootWindow()->drawable.id doesn't give you the right
	 *  answer on the first motion event after a screen change because
	 *  the data that GetCurrentRootWindow relies on hasn't been
	 *  updated yet.
	 */
	if (ev->any.type == ET_Motion)
	    ev->device_event.root = pSprite->hotPhys.pScreen->root->drawable.id;

	eventinfo.event = ev;
	eventinfo.device = device;
	CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
d1121 1
a1121 2
    if (event->type == ET_Motion)
    {
d1123 10
a1132 10
	if(!noPanoramiXExtension) {
	    event->root_x += pSprite->screen->x - screenInfo.screens[0]->x;
	    event->root_y += pSprite->screen->y - screenInfo.screens[0]->y;
	}
#endif
	pSprite->hotPhys.x = event->root_x;
	pSprite->hotPhys.y = event->root_y;
	/* do motion compression, but not if from different devices */
	if (tail &&
	    (tail->event->any.type == ET_Motion) &&
d1134 1
a1134 2
	    (tail->pScreen == pSprite->hotPhys.pScreen))
	{
d1136 7
a1142 6
	    tailev->root_x = pSprite->hotPhys.x;
	    tailev->root_y = pSprite->hotPhys.y;
	    tailev->time = event->time;
	    tail->months = currentTime.months;
	    return;
	}
d1149 2
a1150 2
	return;
    qe->next = (QdEventPtr)NULL;
d1154 1
a1154 1
    qe->event = (InternalEvent *)(qe + 1);
d1156 1
a1156 3
    if (tail)
	syncEvents.pendtail = &tail->next;
    *syncEvents.pendtail = qe;
d1168 1
a1168 1
static void
d1171 2
a1172 1
    QdEventPtr *prev, qe;
d1176 4
a1179 6
    prev = &syncEvents.pending;
    while ( (qe = *prev) )
    {
	if (!qe->device->deviceGrab.sync.frozen)
	{
	    *prev = qe->next;
d1181 3
a1183 5
	    if (*syncEvents.pendtail == *prev)
		syncEvents.pendtail = prev;
	    if (qe->event->any.type == ET_Motion)
		CheckVirtualMotion(pDev, qe, NullWindow);
	    syncEvents.time.months = qe->months;
d1186 4
a1189 4
	   /* Translate back to the sprite screen since processInputProc
	      will translate from sprite screen to screen 0 upon reentry
	      to the DIX layer */
	    if(!noPanoramiXExtension) {
d1191 16
a1206 16
                switch(ev->type)
                {
                    case ET_Motion:
                    case ET_ButtonPress:
                    case ET_ButtonRelease:
                    case ET_KeyPress:
                    case ET_KeyRelease:
                    case ET_ProximityIn:
                    case ET_ProximityOut:
                        ev->root_x += screenInfo.screens[0]->x -
                            pDev->spriteInfo->sprite->screen->x;
                        ev->root_y += screenInfo.screens[0]->y -
                            pDev->spriteInfo->sprite->screen->y;
                        break;
                    default:
                        break;
d1209 1
a1209 1
	    }
d1211 11
a1221 12
	    (*qe->device->public.processInputProc)(qe->event, qe->device);
	    free(qe);
	    for (dev = inputInfo.devices; dev && dev->deviceGrab.sync.frozen; dev = dev->next)
		;
	    if (!dev)
		break;
	    /* Playing the event may have unfrozen another device. */
	    /* So to play it safe, restart at the head of the queue */
	    prev = &syncEvents.pending;
	}
	else
	    prev = &qe->next;
d1238 1
a1238 1
	dev->public.processInputProc = dev->public.enqueueInputProc;
d1240 1
a1240 1
	dev->public.processInputProc = dev->public.realInputProc;
d1260 5
a1264 4
	FreezeThaw(dev, dev->deviceGrab.sync.other ||
                (dev->deviceGrab.sync.state >= FROZEN));
    if (syncEvents.playingEvents || (!replayDev && !syncEvents.pending))
	return;
d1266 2
a1267 3
    if (replayDev)
    {
        DeviceEvent* event = replayDev->deviceGrab.sync.event;
d1269 1
a1269 1
	syncEvents.replayDev = (DeviceIntPtr)NULL;
d1273 11
a1283 4
        if (!CheckDeviceGrabs(replayDev, event, syncEvents.replayWin))
        {
            if (replayDev->focus && !IsPointerEvent((InternalEvent*)event))
                DeliverFocusedEvent(replayDev, (InternalEvent*)event, w);
d1285 1
a1285 1
                DeliverDeviceEvents(w, (InternalEvent*)event, NullGrab,
d1289 5
a1293 7
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (!dev->deviceGrab.sync.frozen)
	{
	    PlayReleasedEvents();
	    break;
	}
d1296 2
a1297 4
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
        if (DevHasCursor(dev))
        {
d1299 2
a1300 3
              so do it now */
            if ((grab = dev->deviceGrab.grab) && grab->confineTo)
            {
d1302 1
a1302 1
                        dev->spriteInfo->sprite->hotPhys.pScreen)
d1309 2
a1310 2
                        dev->spriteInfo->sprite->hotPhys.pScreen->root,
                        TRUE, FALSE);
d1318 1
a1318 1
ScreenRestructured (ScreenPtr pScreen)
d1323 1
a1323 2
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
d1329 1
a1329 2
        if ((grab = pDev->deviceGrab.grab) && grab->confineTo)
        {
d1331 3
a1333 2
                    != pDev->spriteInfo->sprite->hotPhys.pScreen)
                pDev->spriteInfo->sprite->hotPhys.x = pDev->spriteInfo->sprite->hotPhys.y = 0;
d1338 2
a1339 2
                    pDev->spriteInfo->sprite->hotPhys.pScreen->root,
                    TRUE, FALSE);
d1351 7
a1357 8
	thisDev->deviceGrab.sync.state = FROZEN_NO_EVENT;
    else
    {	/* free both if same client owns both */
	thisDev->deviceGrab.sync.state = THAWED;
	if (thisDev->deviceGrab.sync.other &&
	    (CLIENT_BITS(thisDev->deviceGrab.sync.other->resource) ==
	     CLIENT_BITS(grab->resource)))
	    thisDev->deviceGrab.sync.other = NullGrab;
d1360 1
a1360 2
    if (IsMaster(thisDev))
    {
d1364 1
a1364 2
        else
        {	/* free both if same client owns both */
d1366 2
a1367 2
                    (CLIENT_BITS(dev->deviceGrab.sync.other->resource) ==
                     CLIENT_BITS(grab->resource)))
d1404 1
a1404 2
    if (master)
    {
d1406 33
a1438 1
	dev->saved_master_id = 0;
d1463 1
a1463 2
                        grabinfo->grab->window
                        : mouse->spriteInfo->sprite->win;
d1467 1
a1467 1
    if (grab->grabtype == GRABTYPE_XI2 &&
d1471 4
a1474 5
    if (grab->confineTo)
    {
	if (grab->confineTo->drawable.pScreen
                != mouse->spriteInfo->sprite->hotPhys.pScreen)
	    mouse->spriteInfo->sprite->hotPhys.x =
d1476 1
a1476 1
	ConfineCursorToWindow(mouse, grab->confineTo, FALSE, TRUE);
d1483 1
a1483 1
	grabinfo->grabTime = time;
d1485 3
a1487 3
	grab->cursor->refcnt++;
    grabinfo->activeGrab = *grab;
    grabinfo->grab = &grabinfo->activeGrab;
d1491 3
a1493 1
    CheckGrabForSyncs(mouse,(Bool)grab->pointerMode, (Bool)grab->keyboardMode);
d1508 4
d1518 3
a1520 4
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (dev->deviceGrab.sync.other == grab)
	    dev->deviceGrab.sync.other = NullGrab;
d1525 1
a1525 1
	ConfineCursorToWindow(mouse, GetCurrentRootWindow(mouse), FALSE, FALSE);
d1528 1
a1528 1
	FreeCursor(grab->cursor, (Cursor)0);
d1530 1
a1530 1
    if (!wasImplicit && grab->grabtype == GRABTYPE_XI2)
d1534 9
d1551 2
a1552 1
ActivateKeyboardGrab(DeviceIntPtr keybd, GrabPtr grab, TimeStamp time, Bool passive)
d1558 2
a1559 3
    if (grab->grabtype == GRABTYPE_XI2 &&
        !(passive & ImplicitGrabMask) &&
        !IsMaster(keybd))
d1563 1
a1563 1
	oldWin = grabinfo->grab->window;
d1565 1
a1565 1
	oldWin = keybd->focus->win;
d1567 1
a1567 1
	oldWin = keybd->spriteInfo->sprite->win;
d1569 1
a1569 1
	oldWin = keybd->focus->win;
d1571 1
a1571 1
	keybd->valuator->motionHintWindow = NullWindow;
d1574 1
a1574 1
	grabinfo->grabTime = syncEvents.time;
d1576 3
a1578 3
	grabinfo->grabTime = time;
    grabinfo->activeGrab = *grab;
    grabinfo->grab = &grabinfo->activeGrab;
d1581 2
a1582 1
    CheckGrabForSyncs(keybd, (Bool)grab->keyboardMode, (Bool)grab->pointerMode);
d1594 1
a1594 1
                                           : keybd->spriteInfo->sprite->win;
d1599 1
a1599 1
	focusWin = inputInfo.keyboard->focus->win;
d1601 1
a1601 1
	keybd->valuator->motionHintWindow = NullWindow;
d1606 3
a1608 4
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (dev->deviceGrab.sync.other == grab)
	    dev->deviceGrab.sync.other = NullGrab;
d1612 1
a1612 1
    if (!wasImplicit && grab->grabtype == GRABTYPE_XI2)
d1619 1
a1619 4
AllowSome(ClientPtr client,
          TimeStamp time,
          DeviceIntPtr thisDev,
          int newState)
d1624 1
a1624 2
    GrabInfoPtr devgrabinfo,
                grabinfo = &thisDev->deviceGrab;
d1631 1
a1631 2
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
d1634 12
a1645 13
	if (dev == thisDev)
	    continue;
	if (devgrabinfo->grab && SameClient(devgrabinfo->grab, client))
	{
	    if (!(thisGrabbed || otherGrabbed) ||
		(CompareTimeStamps(devgrabinfo->grabTime, grabTime) == LATER))
		grabTime = devgrabinfo->grabTime;
	    otherGrabbed = TRUE;
	    if (grabinfo->sync.other == devgrabinfo->grab)
		thisSynced = TRUE;
	    if (devgrabinfo->sync.state >= FROZEN)
		othersFrozen = TRUE;
	}
d1648 1
a1648 1
	return;
d1650 69
a1718 81
	(CompareTimeStamps(time, grabTime) == EARLIER))
	return;
    switch (newState)
    {
	case THAWED:		       /* Async */
	    if (thisGrabbed)
		grabinfo->sync.state = THAWED;
	    if (thisSynced)
		grabinfo->sync.other = NullGrab;
	    ComputeFreezes();
	    break;
	case FREEZE_NEXT_EVENT:		/* Sync */
	    if (thisGrabbed)
	    {
		grabinfo->sync.state = FREEZE_NEXT_EVENT;
		if (thisSynced)
		    grabinfo->sync.other = NullGrab;
		ComputeFreezes();
	    }
	    break;
	case THAWED_BOTH:		/* AsyncBoth */
	    if (othersFrozen)
	    {
		for (dev = inputInfo.devices; dev; dev = dev->next)
		{
                    devgrabinfo = &dev->deviceGrab;
		    if (devgrabinfo->grab
                            && SameClient(devgrabinfo->grab, client))
			devgrabinfo->sync.state = THAWED;
		    if (devgrabinfo->sync.other &&
                            SameClient(devgrabinfo->sync.other, client))
			devgrabinfo->sync.other = NullGrab;
		}
		ComputeFreezes();
	    }
	    break;
	case FREEZE_BOTH_NEXT_EVENT:	/* SyncBoth */
	    if (othersFrozen)
	    {
		for (dev = inputInfo.devices; dev; dev = dev->next)
		{
                    devgrabinfo = &dev->deviceGrab;
		    if (devgrabinfo->grab
                            && SameClient(devgrabinfo->grab, client))
			devgrabinfo->sync.state = FREEZE_BOTH_NEXT_EVENT;
		    if (devgrabinfo->sync.other
                            && SameClient(devgrabinfo->sync.other, client))
			devgrabinfo->sync.other = NullGrab;
		}
		ComputeFreezes();
	    }
	    break;
	case NOT_GRABBED:		/* Replay */
	    if (thisGrabbed && grabinfo->sync.state == FROZEN_WITH_EVENT)
	    {
		if (thisSynced)
		    grabinfo->sync.other = NullGrab;
		syncEvents.replayDev = thisDev;
		syncEvents.replayWin = grabinfo->grab->window;
		(*grabinfo->DeactivateGrab)(thisDev);
		syncEvents.replayDev = (DeviceIntPtr)NULL;
	    }
	    break;
	case THAW_OTHERS:		/* AsyncOthers */
	    if (othersFrozen)
	    {
		for (dev = inputInfo.devices; dev; dev = dev->next)
		{
		    if (dev == thisDev)
			continue;
                    devgrabinfo = &dev->deviceGrab;
		    if (devgrabinfo->grab
                            && SameClient(devgrabinfo->grab, client))
			devgrabinfo->sync.state = THAWED;
		    if (devgrabinfo->sync.other
                            && SameClient(devgrabinfo->sync.other, client))
			devgrabinfo->sync.other = NullGrab;
		}
		ComputeFreezes();
	    }
	    break;
d1730 4
a1733 3
    TimeStamp		time;
    DeviceIntPtr	mouse = NULL;
    DeviceIntPtr	keybd = NULL;
d1742 28
a1769 29
    switch (stuff->mode)
    {
	case ReplayPointer:
	    AllowSome(client, time, mouse, NOT_GRABBED);
	    break;
	case SyncPointer:
	    AllowSome(client, time, mouse, FREEZE_NEXT_EVENT);
	    break;
	case AsyncPointer:
	    AllowSome(client, time, mouse, THAWED);
	    break;
	case ReplayKeyboard:
	    AllowSome(client, time, keybd, NOT_GRABBED);
	    break;
	case SyncKeyboard:
	    AllowSome(client, time, keybd, FREEZE_NEXT_EVENT);
	    break;
	case AsyncKeyboard:
	    AllowSome(client, time, keybd, THAWED);
	    break;
	case SyncBoth:
	    AllowSome(client, time, keybd, FREEZE_BOTH_NEXT_EVENT);
	    break;
	case AsyncBoth:
	    AllowSome(client, time, keybd, THAWED_BOTH);
	    break;
	default:
	    client->errorValue = stuff->mode;
	    return BadValue;
d1781 1
a1781 1
    Bool    done;
d1787 8
a1794 9
	done = TRUE;
	for (dev = inputInfo.devices; dev; dev = dev->next)
	{
	    if (dev->deviceGrab.grab && SameClient(dev->deviceGrab.grab, client))
	    {
		(*dev->deviceGrab.DeactivateGrab)(dev);
		done = FALSE;
	    }
	}
d1828 2
a1829 2
TryClientEvents (ClientPtr client, DeviceIntPtr dev, xEvent *pEvents,
                 int count, Mask mask, Mask filter, GrabPtr grab)
d1847 2
a1848 3
    if (filter != CantBeFiltered && !(mask & filter))
    {
 #ifdef DEBUG_EVENTS
d1850 1
a1850 1
 #endif
d1854 1
a1854 2
    if (grab && !SameClient(grab, client))
    {
d1858 1
a1858 1
        return -1; /* don't send, but notify caller */
d1862 2
a1863 4
    if (type == MotionNotify)
    {
        if (mask & PointerMotionHintMask)
        {
d1865 1
a1865 2
                    pEvents->u.keyButtonPointer.event)
            {
d1870 1
a1870 1
                return 1; /* don't send, but pretend we did */
d1874 1
a1874 2
        else
        {
d1878 2
a1879 3
    else if (type == DeviceMotionNotify)
    {
        if (MaybeSendDeviceMotionNotifyHint((deviceKeyButtonPointer*)pEvents,
d1882 4
a1885 6
    } else if (type == KeyPress)
    {
        if (EventIsKeyRepeat(pEvents))
        {
            if (!_XkbWantsDetectableAutoRepeat(client))
            {
d1887 1
d1893 2
a1894 2
            } else
            {
d1901 6
a1906 7
    } else if (type == DeviceKeyPress)
    {
        if (EventIsKeyRepeat(pEvents))
        {
            if (!_XkbWantsDetectableAutoRepeat(client))
            {
                deviceKeyButtonPointer release = *(deviceKeyButtonPointer *)pEvents;
d1921 1
a1921 2
    if (BitIsOn(criticalEvents, type))
    {
d1938 1
a1938 1
    GrabRec tempGrab;
d1941 1
a1941 1
    GrabType grabtype;
d1944 1
a1944 1
        grabtype = GRABTYPE_CORE;
d1946 1
a1946 1
        grabtype = GRABTYPE_XI;
d1948 1
a1948 1
        grabtype = GRABTYPE_XI2;
d1952 15
a1966 13
    memset(&tempGrab, 0, sizeof(GrabRec));
    tempGrab.next = NULL;
    tempGrab.device = dev;
    tempGrab.resource = client->clientAsMask;
    tempGrab.window = win;
    tempGrab.ownerEvents = (deliveryMask & OwnerGrabButtonMask) ? TRUE : FALSE;
    tempGrab.eventMask = deliveryMask;
    tempGrab.keyboardMode = GrabModeAsync;
    tempGrab.pointerMode = GrabModeAsync;
    tempGrab.confineTo = NullWindow;
    tempGrab.cursor = NullCursor;
    tempGrab.type = type;
    tempGrab.grabtype = grabtype;
d1970 1
a1970 1
    tempGrab.deviceMask = (inputMasks) ? inputMasks->inputEvents[dev->id]: 0;
d1973 1
a1973 2
        memcpy(tempGrab.xi2mask, inputMasks->xi2mask,
               sizeof(tempGrab.xi2mask));
d1975 3
a1977 2
    (*dev->deviceGrab.ActivateGrab)(dev, &tempGrab,
                                    currentTime, TRUE | ImplicitGrabMask);
a1980 7
enum EventDeliveryState {
    EVENT_DELIVERED,     /**< Event has been delivered to a client  */
    EVENT_NOT_DELIVERED, /**< Event was not delivered to any client */
    EVENT_SKIP,          /**< Event can be discarded by the caller  */
    EVENT_REJECTED,      /**< Event was rejected for delivery to the client */
};

d1986 1
a1986 2
                     xEvent *events, int count, Mask filter,
                     GrabPtr grab)
d1990 1
a1990 1
            !((wOtherEventMasks(win)|win->eventMask) & filter))
d1996 1
a1996 2
    if (!XaceHook(XACE_RECEIVE_ACCESS, wClient(win), win, events, count))
    {
d2000 1
a2009 1

d2019 1
a2019 1
                      xEvent *events, Mask filter, InputClients **clients)
d2024 2
a2025 3
        *clients = (InputClients *)wOtherClients(win);
    else if (xi2_get_type(events) != 0)
    {
d2027 1
d2029 1
a2029 1
        if (!GetWindowXI2Mask(dev, win, events))
d2032 2
a2033 1
    } else {
d2035 1
d2037 1
a2037 2
        if (!inputMasks ||
            !(inputMasks->inputEvents[dev->id] & filter))
d2044 1
a2044 1
out:
d2053 1
a2053 1
DeliverEventToInputClients(DeviceIntPtr dev, InputClients *inputclients,
d2061 1
a2061 2
    for (; inputclients; inputclients = inputclients->next)
    {
d2070 6
a2075 9
        if (XaceHook(XACE_RECEIVE_ACCESS, client, win,
                    events, count))
            /* do nothing */;
        else if ( (attempt = TryClientEvents(client, dev,
                        events, count,
                        mask, filter, grab)) )
        {
            if (attempt > 0)
            {
d2081 2
a2082 1
            } else if (rc == EVENT_NOT_DELIVERED)
a2089 1

a2111 1

d2136 1
a2136 1
        *pEvents, int count, Mask filter, GrabPtr grab)
d2140 2
a2141 2
    Mask deliveryMask = 0; /* If a grab occurs due to a button press, then
		              this mask is the mask of the grab. */
d2145 1
a2145 2
    if ((filter == CantBeFiltered) || core_get_type(pEvents) != 0)
    {
d2150 14
a2163 15
        switch(rc)
        {
            case EVENT_SKIP:
                return 0;
            case EVENT_REJECTED:
                nondeliveries--;
                break;
            case EVENT_DELIVERED:
                /* We delivered to the owner, with our event mask */
                deliveries++;
                client = wClient(pWin);
                deliveryMask = pWin->eventMask;
                break;
            case EVENT_NOT_DELIVERED:
                break;
d2168 1
a2168 2
    if (filter != CantBeFiltered)
    {
d2174 11
a2184 12
        switch(rc)
        {
            case EVENT_SKIP:
                return 0;
            case EVENT_REJECTED:
                nondeliveries--;
                break;
            case EVENT_DELIVERED:
                deliveries++;
                break;
            case EVENT_NOT_DELIVERED:
                break;
d2188 1
a2188 2
    if (deliveries)
    {
d2193 3
a2195 2
        if (!grab && ActivateImplicitGrab(pDev, client, pWin, pEvents, deliveryMask))
            /* grab activated */;
d2199 4
a2202 4
                CheckDeviceGrabAndHintWindow (pWin, type,
                                              (deviceKeyButtonPointer*) pEvents,
                                              grab, client, deliveryMask);
	return deliveries;
d2207 10
a2216 2
void
DeliverRawEvent(RawDeviceEvent *ev, DeviceIntPtr device)
d2218 40
a2257 1
    GrabPtr grab = device->deviceGrab.grab;
d2260 3
a2262 5
        DeliverGrabbedEvent((InternalEvent*)ev, device, FALSE);
    else { /* deliver to all root windows */
        xEvent *xi;
        int i;
        int filter;
d2264 3
a2266 7
        i = EventToXI2((InternalEvent*)ev, (xEvent**)&xi);
        if (i != Success)
        {
            ErrorF("[Xi] %s: XI2 conversion failed in %s (%d)\n",
                    __func__, device->name, i);
            return;
        }
d2268 3
a2270 1
        filter = GetEventFilter(device, xi);
d2272 17
a2288 4
        for (i = 0; i < screenInfo.numScreens; i++)
            DeliverEventsToWindow(device, screenInfo.screens[i]->root, xi, 1,
                                  filter, NullGrab);
        free(xi);
d2290 2
d2301 3
a2303 6
XineramaTryClientEventsResult(
    ClientPtr client,
    GrabPtr grab,
    Mask mask,
    Mask filter
){
d2305 5
a2309 4
        ((filter == CantBeFiltered) || (mask & filter)))
    {
        if (grab && !SameClient(grab, client)) return -1;
	else return 1;
d2330 1
a2330 3

    if (pWin->eventMask & filter)
    {
d2332 1
a2332 1
	    return 0;
d2334 8
a2341 8
	if(!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
	    return XineramaTryClientEventsResult(
			wClient(pWin), NullGrab, pWin->eventMask, filter);
#endif
	if (XaceHook(XACE_RECEIVE_ACCESS, wClient(pWin), pWin, pEvents, count))
	    return 1; /* don't send, but pretend we did */
	return TryClientEvents(wClient(pWin), NULL, pEvents, count,
			       pWin->eventMask, filter, NullGrab);
d2343 2
a2344 4
    for (other = wOtherClients(pWin); other; other = other->next)
    {
	if (other->mask & filter)
	{
d2346 1
a2346 1
		return 0;
d2348 10
a2357 10
	    if(!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
	      return XineramaTryClientEventsResult(
			rClient(other), NullGrab, other->mask, filter);
#endif
	    if (XaceHook(XACE_RECEIVE_ACCESS, rClient(other), pWin, pEvents,
			 count))
		return 1; /* don't send, but pretend we did */
	    return TryClientEvents(rClient(other), NULL, pEvents, count,
				   other->mask, filter, NullGrab);
	}
d2362 2
a2363 1
static Window FindChildForEvent(SpritePtr pSprite, WindowPtr event)
d2372 1
a2372 2
    while (w)
    {
d2376 1
a2376 2
        if (w == event)
        {
d2381 1
a2381 2
        if (w->parent == event)
        {
d2399 2
a2400 6
FixUpEventFromWindow(
    SpritePtr pSprite,
    xEvent *xE,
    WindowPtr pWin,
    Window child,
    Bool calcChild)
d2407 2
a2408 3
    if ((evtype = xi2_get_type(xE)))
    {
        xXIDeviceEvent* event = (xXIDeviceEvent*)xE;
d2410 15
a2424 13
        switch (evtype)
        {
            case XI_RawKeyPress:
            case XI_RawKeyRelease:
            case XI_RawButtonPress:
            case XI_RawButtonRelease:
            case XI_RawMotion:
            case XI_DeviceChanged:
            case XI_HierarchyChanged:
            case XI_PropertyEvent:
                return;
            default:
                break;
d2429 7
a2435 2
        if (pSprite->hot.pScreen == pWin->drawable.pScreen)
        {
d2439 2
a2440 2
        } else
        {
d2448 1
a2448 1
            ((xXIEnterEvent*)event)->same_screen =
d2451 2
a2452 2
    } else
    {
d2455 1
a2455 2
        if (pSprite->hot.pScreen == pWin->drawable.pScreen)
        {
d2458 2
a2459 4
            XE_KBPTR.eventX =
                XE_KBPTR.rootX - pWin->drawable.x;
            XE_KBPTR.eventY =
                XE_KBPTR.rootY - pWin->drawable.y;
d2461 1
a2461 2
        else
        {
d2477 1
a2477 1
 * @@param[in] event The event that is to be sent.
d2484 1
a2484 1
EventIsDeliverable(DeviceIntPtr dev, InternalEvent* event, WindowPtr win)
a2489 1
    xEvent ev;
d2491 32
a2522 36
    /* XXX: this makes me gag */
    type = GetXI2Type(event);
    ev.u.u.type = GenericEvent; /* GetEventFilter only cares about type and evtype*/
    ((xGenericEvent*)&ev)->extension = IReqCode;
    ((xGenericEvent*)&ev)->evtype = type;
    filter = GetEventFilter(dev, &ev);
    if (type && inputMasks &&
        ((inputMasks->xi2mask[XIAllDevices][type/8] & filter) ||
         ((inputMasks->xi2mask[XIAllMasterDevices][type/8] & filter) && IsMaster(dev)) ||
         (inputMasks->xi2mask[dev->id][type/8] & filter)))
        rc |= EVENT_XI2_MASK;

    type = GetXIType(event);
    ev.u.u.type = type;
    filter = GetEventFilter(dev, &ev);

    /* Check for XI mask */
    if (type && inputMasks &&
        (inputMasks->deliverableEvents[dev->id] & filter) &&
        (inputMasks->inputEvents[dev->id] & filter))
        rc |= EVENT_XI1_MASK;

    /* Check for XI DontPropagate mask */
    if (type && inputMasks &&
        (inputMasks->dontPropagateMask[dev->id] & filter))
        rc |= EVENT_DONT_PROPAGATE_MASK;

    /* Check for core mask */
    type = GetCoreType(event);
    if (type && (win->deliverableEvents & filter) &&
        ((wOtherEventMasks(win) | win->eventMask) & filter))
        rc |= EVENT_CORE_MASK;

    /* Check for core DontPropagate mask */
    if (type && (filter & wDontPropagateMask(win)))
        rc |= EVENT_DONT_PROPAGATE_MASK;
d2527 50
a2599 1
    SpritePtr pSprite = dev->spriteInfo->sprite;
a2600 1
    Mask filter;
d2602 1
a2602 2
    xEvent *xE = NULL, *core = NULL;
    int rc, mask, count = 0;
d2606 2
a2607 4
    while (pWin)
    {
        if ((mask = EventIsDeliverable(dev, event, pWin)))
        {
d2609 5
a2613 17
            if (mask & EVENT_XI2_MASK)
            {
                xEvent *xi2 = NULL;
                rc = EventToXI2(event, &xi2);
                if (rc == Success)
                {
                    /* XXX: XACE */
                    filter = GetEventFilter(dev, xi2);
                    FixUpEventFromWindow(pSprite, xi2, pWin, child, FALSE);
                    deliveries = DeliverEventsToWindow(dev, pWin, xi2, 1,
                                                       filter, grab);
                    free(xi2);
                    if (deliveries > 0)
                        goto unwind;
                } else if (rc != BadMatch)
                    ErrorF("[dix] %s: XI2 conversion failed in DDE (%d).\n",
                            dev->name, rc);
d2617 4
a2620 15
            if (mask & EVENT_XI1_MASK)
            {
                rc = EventToXI(event, &xE, &count);
                if (rc == Success) {
                    if (XaceHook(XACE_SEND_ACCESS, NULL, dev, pWin, xE, count) == Success) {
                        filter = GetEventFilter(dev, xE);
                        FixUpEventFromWindow(pSprite, xE, pWin, child, FALSE);
                        deliveries = DeliverEventsToWindow(dev, pWin, xE, count,
                                                           filter, grab);
                        if (deliveries > 0)
                            goto unwind;
                    }
                } else if (rc != BadMatch)
                    ErrorF("[dix] %s: XI conversion failed in DDE (%d, %d). Skipping delivery.\n",
                            dev->name, event->any.type, rc);
d2624 5
a2628 15
            if ((mask & EVENT_CORE_MASK) && IsMaster(dev) && dev->coreEvents)
            {
                rc = EventToCore(event, &core, &count);
                if (rc == Success) {
                    if (XaceHook(XACE_SEND_ACCESS, NULL, dev, pWin, core, count) == Success) {
                        filter = GetEventFilter(dev, core);
                        FixUpEventFromWindow(pSprite, core, pWin, child, FALSE);
                        deliveries = DeliverEventsToWindow(dev, pWin, core,
                                                           count, filter, grab);
                        if (deliveries > 0)
                            goto unwind;
                    }
                } else if (rc != BadMatch)
                        ErrorF("[dix] %s: Core conversion failed in DDE (%d, %d).\n",
                                dev->name, event->any.type, rc);
d2631 6
a2636 6
            if ((deliveries < 0) || (pWin == stopAt) ||
                (mask & EVENT_DONT_PROPAGATE_MASK))
            {
                deliveries = 0;
                goto unwind;
            }
a2642 3
unwind:
    free(core);
    free(xE);
d2660 1
a2660 2
DeliverEvents(WindowPtr pWin, xEvent *xE, int count,
              WindowPtr otherParent)
d2663 1
a2663 1
    int     deliveries;
d2666 2
a2667 2
    if(!noPanoramiXExtension && pWin->drawable.pScreen->myNum)
	return count;
d2671 1
a2671 1
	return 0;
d2675 25
a2699 1
    switch (xE->u.u.type)
d2701 4
a2704 12
        case DestroyNotify:
        case UnmapNotify:
        case MapNotify:
        case MapRequest:
        case ReparentNotify:
        case ConfigureNotify:
        case ConfigureRequest:
        case GravityNotify:
        case CirculateNotify:
        case CirculateRequest:
            xE->u.destroyNotify.event = pWin->drawable.id;
            break;
a2705 18

    switch (xE->u.u.type)
    {
        case DestroyNotify:
        case UnmapNotify:
        case MapNotify:
        case ReparentNotify:
        case ConfigureNotify:
        case GravityNotify:
        case CirculateNotify:
            break;
        default:
        {
            Mask filter;
            filter = GetEventFilter(&dummy, xE);
            return DeliverEventsToWindow(&dummy, pWin, xE, count, filter,
                                         NullGrab);
        }
d2710 6
a2715 8
    if (pWin->parent)
    {
	xE->u.destroyNotify.event = pWin->parent->drawable.id;
	deliveries += DeliverEventsToWindow(&dummy, pWin->parent, xE, count,
					    SubstructureNotifyMask, NullGrab);
	if (xE->u.u.type == ReparentNotify)
	{
	    xE->u.destroyNotify.event = otherParent->drawable.id;
d2717 4
a2720 3
                    otherParent, xE, count, SubstructureNotifyMask,
						NullGrab);
	}
a2724 1

d2730 2
a2731 2
    if(RegionContainsPoint(&pWin->borderSize, x, y, &box))
	return TRUE;
d2734 13
a2746 12
    if(!noPanoramiXExtension &&
            XineramaSetWindowPntrs(inputInfo.pointer, pWin)) {
	SpritePtr pSprite = inputInfo.pointer->spriteInfo->sprite;
	int i;

	FOR_NSCREENS_FORWARD_SKIP(i) {
	   if(RegionContainsPoint(&pSprite->windows[i]->borderSize,
				  x + screenInfo.screens[0]->x - screenInfo.screens[i]->x,
				  y + screenInfo.screens[0]->y - screenInfo.screens[i]->y,
				  &box))
		return TRUE;
	}
d2766 2
a2767 2
    WindowPtr  pWin;
    BoxRec		box;
d2769 1
a2769 1
    pSprite->spriteTraceGood = 1;	/* root window still there */
d2771 17
a2787 18
    while (pWin)
    {
	if ((pWin->mapped) &&
	    (x >= pWin->drawable.x - wBorderWidth (pWin)) &&
	    (x < pWin->drawable.x + (int)pWin->drawable.width +
	     wBorderWidth(pWin)) &&
	    (y >= pWin->drawable.y - wBorderWidth (pWin)) &&
	    (y < pWin->drawable.y + (int)pWin->drawable.height +
	     wBorderWidth (pWin))
	    /* When a window is shaped, a further check
	     * is made to see if the point is inside
	     * borderSize
	     */
	    && (!wBoundingShape(pWin) || PointInBorderSize(pWin, x, y))
	    && (!wInputShape(pWin) ||
		RegionContainsPoint(wInputShape(pWin),
				    x - pWin->drawable.x,
				    y - pWin->drawable.y, &box))
d2789 18
a2806 19
    /* In rootless mode windows may be offscreen, even when
     * they're in X's stack. (E.g. if the native window system
     * implements some form of virtual desktop system).
     */
		&& !pWin->rootlessUnhittable
#endif
	    )
	{
	    if (pSprite->spriteTraceGood >= pSprite->spriteTraceSize)
	    {
		pSprite->spriteTraceSize += 10;
		pSprite->spriteTrace = realloc(pSprite->spriteTrace,
		                    pSprite->spriteTraceSize*sizeof(WindowPtr));
	    }
	    pSprite->spriteTrace[pSprite->spriteTraceGood++] = pWin;
	    pWin = pWin->firstChild;
	}
	else
	    pWin = pWin->nextSib;
d2824 1
a2824 2
    if (dev->deviceGrab.grab)
    {
d2831 1
a2831 1
        (*dev->deviceGrab.DeactivateGrab)(dev);
d2864 1
a2864 2
    if (dev->deviceGrab.grab)
    {
d2871 1
a2871 1
        (*dev->deviceGrab.DeactivateGrab)(dev);
d2906 1
a2906 1
    verify_internal_event((InternalEvent *)ev);
d2910 1
a2910 2
    if (ev && !syncEvents.playingEvents)
    {
d2913 11
a2923 9
        switch (ev->type)
        {
            case ET_ButtonPress:
            case ET_ButtonRelease:
            case ET_Motion:
                break;
            default:
                /* all other events return FALSE */
                return FALSE;
a2925 1

d2927 1
a2927 2
        if (!noPanoramiXExtension)
        {
d2933 2
a2934 1
        } else
d2937 1
a2937 2
            if (pSprite->hot.pScreen != pSprite->hotPhys.pScreen)
            {
d2954 7
a2960 7
	if (pSprite->hotShape)
	    ConfineToShape(pDev, pSprite->hotShape, &pSprite->hot.x, &pSprite->hot.y);
	pSprite->hotPhys = pSprite->hot;

	if ((pSprite->hotPhys.x != ev->root_x) ||
	    (pSprite->hotPhys.y != ev->root_y))
	{
d2962 5
a2966 5
            if (!noPanoramiXExtension)
            {
                XineramaSetCursorPosition(
                        pDev, pSprite->hotPhys.x, pSprite->hotPhys.y, FALSE);
            } else
d2969 8
a2976 3
                (*pSprite->hotPhys.pScreen->SetCursorPosition)(
                        pDev, pSprite->hotPhys.pScreen,
                        pSprite->hotPhys.x, pSprite->hotPhys.y, FALSE);
d2978 1
a2978 1
	}
d2980 2
a2981 2
	ev->root_x = pSprite->hot.x;
	ev->root_y = pSprite->hot.y;
d2986 1
a2986 2
    if (newSpriteWin != prevSpriteWin)
    {
d2988 1
d2991 3
a2993 2
            sourceid = pDev->id; /* when from WindowsRestructured */
        } else
d2996 1
a2996 1
	if (prevSpriteWin != NullWindow) {
d3019 2
a3020 2
    while(pDev)
    {
d3033 2
a3034 1
void ReinitializeRootWindow(WindowPtr win, int xoff, int yoff)
d3036 1
a3036 1
    GrabPtr   grab;
d3040 2
a3041 1
    if (noPanoramiXExtension) return;
d3044 2
a3045 4
    while(pDev)
    {
        if (DevHasCursor(pDev))
        {
d3047 2
a3048 2
            pSprite->hot.x        -= xoff;
            pSprite->hot.y        -= yoff;
d3050 2
a3051 2
            pSprite->hotPhys.x    -= xoff;
            pSprite->hotPhys.y    -= yoff;
d3066 1
a3066 1
                        != pSprite->hotPhys.pScreen)
d3069 5
a3073 5
            } else
                ConfineCursorToWindow(
                        pDev,
                        pSprite->hotPhys.pScreen->root,
                        TRUE, FALSE);
d3103 1
a3103 2
    if (!pDev->spriteInfo->sprite)
    {
d3106 1
a3106 1
        pDev->spriteInfo->sprite = (SpritePtr)calloc(1, sizeof(SpriteRec));
d3116 1
a3116 2
        for (it = inputInfo.devices; it; it = it->next)
        {
d3127 1
a3127 1
    pScreen = (pWin) ? pWin->drawable.pScreen : (ScreenPtr)NULL;
d3130 1
a3130 2
    if (pScreen)
    {
d3140 6
a3145 7
    if (pWin)
    {
	pCursor = wCursor(pWin);
	pSprite->spriteTrace = (WindowPtr *)calloc(1, 32*sizeof(WindowPtr));
	if (!pSprite->spriteTrace)
	    FatalError("Failed to allocate spriteTrace");
	pSprite->spriteTraceSize = 32;
d3147 2
a3148 2
	RootWindow(pDev->spriteInfo->sprite) = pWin;
	pSprite->spriteTraceGood = 1;
d3150 2
a3151 2
	pSprite->pEnqueueScreen = pScreen;
	pSprite->pDequeueScreen = pSprite->pEnqueueScreen;
d3153 2
a3154 1
    } else {
d3156 5
a3160 5
	pSprite->spriteTrace = NULL;
	pSprite->spriteTraceSize = 0;
	pSprite->spriteTraceGood = 0;
	pSprite->pEnqueueScreen = screenInfo.screens[0];
	pSprite->pDequeueScreen = pSprite->pEnqueueScreen;
d3163 1
a3163 1
	pCursor->refcnt++;
d3165 1
a3165 1
	FreeCursor(pSprite->current, None);
d3168 4
a3171 5
    if (pScreen)
    {
        (*pScreen->RealizeCursor) ( pDev, pScreen, pSprite->current);
        (*pScreen->CursorLimits) ( pDev, pScreen, pSprite->current,
                                   &pSprite->hotLimits, &pSprite->physLimits);
d3174 1
a3174 2
        (*pScreen->ConstrainCursor) (pDev, pScreen,
                                     &pSprite->physLimits);
d3176 1
a3176 2
                                       pSprite->hot.y,
                                       FALSE);
d3180 1
a3180 1
    if(!noPanoramiXExtension) {
d3183 1
a3183 1
        pSprite->hotLimits.x2 = PanoramiXPixWidth  - screenInfo.screens[0]->x;
d3217 1
d3219 1
a3219 1
        return ;
d3235 1
a3235 1
	pCursor->refcnt++;
d3237 1
a3237 1
	FreeCursor(pSprite->current, 0);
d3244 1
a3244 2
                              &pSprite->hotLimits,
                              &pSprite->physLimits);
d3250 1
a3250 1
    if(!noPanoramiXExtension) {
d3253 1
a3253 1
        pSprite->hotLimits.x2 = PanoramiXPixWidth  - screenInfo.screens[0]->x;
d3273 1
a3273 1
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
d3281 7
a3287 1
    SpritePtr pSprite = pDev->spriteInfo->sprite;
d3292 26
a3317 23
    if(!noPanoramiXExtension) {
	pSprite->hotPhys.x += newScreen->x - screenInfo.screens[0]->x;
	pSprite->hotPhys.y += newScreen->y - screenInfo.screens[0]->y;
	if (newScreen != pSprite->screen) {
	    pSprite->screen = newScreen;
	    /* Make sure we tell the DDX to update its copy of the screen */
	    if(pSprite->confineWin)
		XineramaConfineCursorToWindow(pDev,
                        pSprite->confineWin, TRUE);
	    else
		XineramaConfineCursorToWindow(pDev, screenInfo.screens[0]->root, TRUE);
	    /* if the pointer wasn't confined, the DDX won't get
	       told of the pointer warp so we reposition it here */
	    if(!syncEvents.playingEvents)
		(*pSprite->screen->SetCursorPosition)(
                                                      pDev,
                                                      pSprite->screen,
		    pSprite->hotPhys.x + screenInfo.screens[0]->x -
			pSprite->screen->x,
		    pSprite->hotPhys.y + screenInfo.screens[0]->y -
			pSprite->screen->y, FALSE);
	}
    } else
d3320 1
a3320 1
	ConfineCursorToWindow(pDev, newScreen->root, TRUE, FALSE);
d3326 1
a3326 5
XineramaPointInWindowIsVisible(
    WindowPtr pWin,
    int x,
    int y
)
d3331 2
a3332 1
    if (!pWin->realized) return FALSE;
d3337 2
a3338 1
    if(!XineramaSetWindowPntrs(inputInfo.pointer, pWin)) return FALSE;
d3344 10
a3353 9
	pWin = inputInfo.pointer->spriteInfo->sprite->windows[i];
	x = xoff - screenInfo.screens[i]->x;
	y = yoff - screenInfo.screens[i]->y;

	if(RegionContainsPoint(&pWin->borderClip, x, y, &box)
	   && (!wInputShape(pWin) ||
	       RegionContainsPoint(wInputShape(pWin),
				   x - pWin->drawable.x,
				   y - pWin->drawable.y, &box)))
d3364 3
a3366 3
    WindowPtr	dest = NULL;
    int		x, y, rc;
    SpritePtr   pSprite = PickPointer(client)->spriteInfo->sprite;
a3369 1

d3371 3
a3373 3
	rc = dixLookupWindow(&dest, stuff->dstWid, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d3378 3
a3380 4
    if (stuff->srcWid != None)
    {
	int     winX, winY;
	XID	winID = stuff->srcWid;
d3383 18
a3400 18
	rc = dixLookupWindow(&source, winID, client, DixReadAccess);
	if (rc != Success)
	    return rc;

	winX = source->drawable.x;
	winY = source->drawable.y;
	if(source == screenInfo.screens[0]->root) {
	    winX -= screenInfo.screens[0]->x;
	    winY -= screenInfo.screens[0]->y;
	}
	if (x < winX + stuff->srcX ||
	    y < winY + stuff->srcY ||
	    (stuff->srcWidth != 0 &&
	     winX + stuff->srcX + (int)stuff->srcWidth < x) ||
	    (stuff->srcHeight != 0 &&
	     winY + stuff->srcY + (int)stuff->srcHeight < y) ||
	    !XineramaPointInWindowIsVisible(source, x, y))
	    return Success;
d3403 6
a3408 6
	x = dest->drawable.x;
	y = dest->drawable.y;
	if(dest == screenInfo.screens[0]->root) {
	    x -= screenInfo.screens[0]->x;
	    y -= screenInfo.screens[0]->y;
	}
d3415 1
a3415 1
	x = pSprite->physLimits.x1;
d3417 1
a3417 1
	x = pSprite->physLimits.x2 - 1;
d3419 1
a3419 1
	y = pSprite->physLimits.y1;
d3421 1
a3421 1
	y = pSprite->physLimits.y2 - 1;
d3423 1
a3423 1
	ConfineToShape(PickPointer(client), pSprite->hotShape, &x, &y);
a3431 1

d3439 3
a3441 3
    WindowPtr	dest = NULL;
    int		x, y, rc;
    ScreenPtr	newScreen;
d3443 1
a3443 1
    SpritePtr   pSprite;
d3452 4
a3455 4
	    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixWriteAccess);
	    if (rc != Success)
		return rc;
	}
d3463 2
a3464 2
    if(!noPanoramiXExtension)
	return XineramaWarpPointer(client);
d3468 3
a3470 3
	rc = dixLookupWindow(&dest, stuff->dstWid, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;
d3475 3
a3477 4
    if (stuff->srcWid != None)
    {
	int     winX, winY;
	XID	winID = stuff->srcWid;
d3480 20
a3499 15
	rc = dixLookupWindow(&source, winID, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	winX = source->drawable.x;
	winY = source->drawable.y;
	if (source->drawable.pScreen != pSprite->hotPhys.pScreen ||
	    x < winX + stuff->srcX ||
	    y < winY + stuff->srcY ||
	    (stuff->srcWidth != 0 &&
	     winX + stuff->srcX + (int)stuff->srcWidth < x) ||
	    (stuff->srcHeight != 0 &&
	     winY + stuff->srcY + (int)stuff->srcHeight < y) ||
	    !PointInWindowIsVisible(source, x, y))
	    return Success;
d3501 2
a3502 7
    if (dest)
    {
	x = dest->drawable.x;
	y = dest->drawable.y;
	newScreen = dest->drawable.pScreen;
    } else
	newScreen = pSprite->hotPhys.pScreen;
d3508 1
a3508 1
	x = 0;
d3510 1
a3510 1
	x = newScreen->width - 1;
d3512 1
a3512 1
	y = 0;
d3514 1
a3514 1
	y = newScreen->height - 1;
d3516 12
a3527 13
    if (newScreen == pSprite->hotPhys.pScreen)
    {
	if (x < pSprite->physLimits.x1)
	    x = pSprite->physLimits.x1;
	else if (x >= pSprite->physLimits.x2)
	    x = pSprite->physLimits.x2 - 1;
	if (y < pSprite->physLimits.y1)
	    y = pSprite->physLimits.y1;
	else if (y >= pSprite->physLimits.y2)
	    y = pSprite->physLimits.y2 - 1;
	if (pSprite->hotShape)
	    ConfineToShape(dev, pSprite->hotShape, &x, &y);
        (*newScreen->SetCursorPosition)(dev, newScreen, x, y, TRUE);
d3529 2
a3530 3
    else if (!PointerConfinedToScreen(dev))
    {
	NewCurrentScreen(dev, newScreen, x, y);
d3538 2
a3539 2
     if(RegionNotEmpty(&pWin->borderSize))
	return TRUE;
d3542 2
a3543 2
     if(!noPanoramiXExtension && XineramaSetWindowPntrs(pDev, pWin)) {
	int i;
d3545 6
a3550 5
	FOR_NSCREENS_FORWARD_SKIP(i) {
	    if(RegionNotEmpty(&pDev->spriteInfo->sprite->windows[i]->borderSize))
		return TRUE;
	}
     }
d3552 1
a3552 1
     return FALSE;
d3556 2
a3557 4
 * "CheckPassiveGrabsOnWindow" checks to see if the event passed in causes a
 * passive grab set on the window to be activated.
 * If activate is true and a passive grab is found, it will be activated,
 * and the event will be delivered to the client.
d3559 2
a3560 2
 * @@param pWin The window that may be subject to a passive grab.
 * @@param device Device that caused the event.
d3562 4
a3565 2
 * @@param checkCore Check for core grabs too.
 * @@param activate If a grab is found, activate it and deliver the event.
d3567 3
a3569 8

GrabPtr
CheckPassiveGrabsOnWindow(
    WindowPtr pWin,
    DeviceIntPtr device,
    InternalEvent *event,
    BOOL checkCore,
    BOOL activate)
d3572 16
a3587 7
    GrabPtr grab = wPassiveGrabs(pWin);
    GrabRec tempGrab;
    GrabInfoPtr grabinfo;
#define CORE_MATCH      0x1
#define XI_MATCH        0x2
#define XI2_MATCH        0x4
    int match = 0;
d3589 3
a3591 17
    if (!grab)
	return NULL;
    /* Fill out the grab details, but leave the type for later before
     * comparing */
    switch (event->any.type)
    {
        case ET_KeyPress:
        case ET_KeyRelease:
            tempGrab.detail.exact = event->device_event.detail.key;
            break;
        case ET_ButtonPress:
        case ET_ButtonRelease:
            tempGrab.detail.exact = event->device_event.detail.button;
            break;
        default:
            tempGrab.detail.exact = 0;
            break;
a3592 11
    tempGrab.window = pWin;
    tempGrab.device = device;
    tempGrab.detail.pMask = NULL;
    tempGrab.modifiersDetail.pMask = NULL;
    tempGrab.next = NULL;
    for (; grab; grab = grab->next)
    {
	DeviceIntPtr	gdev;
	XkbSrvInfoPtr	xkbi = NULL;
	xEvent *xE = NULL;
        int count, rc;
d3594 25
a3618 15
	gdev= grab->modifierDevice;
        if (grab->grabtype == GRABTYPE_CORE)
        {
            if (IsPointerDevice(device))
                gdev = GetPairedDevice(device);
            else
                gdev = device;
        } else if (grab->grabtype == GRABTYPE_XI2)
        {
            /* if the device is an attached slave device, gdev must be the
             * attached master keyboard. Since the slave may have been
             * reattached after the grab, the modifier device may not be the
             * same. */
            if (!IsMaster(grab->device) && !IsFloating(device))
                gdev = GetMaster(device, MASTER_KEYBOARD);
d3620 4
d3625 2
d3628 13
a3640 10
        if (gdev && gdev->key)
            xkbi= gdev->key->xkbInfo;
	tempGrab.modifierDevice = grab->modifierDevice;
        tempGrab.modifiersDetail.exact = xkbi ? xkbi->state.grab_mods : 0;

        /* Check for XI2 and XI grabs first */
        tempGrab.type = GetXI2Type(event);
        tempGrab.grabtype = GRABTYPE_XI2;
        if (GrabMatchesSecond(&tempGrab, grab, FALSE))
            match = XI2_MATCH;
d3642 17
a3658 6
        if (!match)
        {
            tempGrab.grabtype = GRABTYPE_XI;
            if ((tempGrab.type = GetXIType(event)) &&
                (GrabMatchesSecond(&tempGrab, grab, FALSE)))
                match = XI_MATCH;
d3660 4
d3665 107
a3771 8
        /* Check for a core grab (ignore the device when comparing) */
        if (!match && checkCore)
        {
            tempGrab.grabtype = GRABTYPE_CORE;
            if ((tempGrab.type = GetCoreType(event)) &&
                (GrabMatchesSecond(&tempGrab, grab, TRUE)))
                match = CORE_MATCH;
        }
d3773 2
a3774 4
        if (!match || (grab->confineTo &&
                       (!grab->confineTo->realized ||
                        !BorderSizeNotEmpty(device, grab->confineTo))))
            continue;
d3776 5
a3780 6
        grabinfo = &device->deviceGrab;
        /* In some cases a passive core grab may exist, but the client
         * already has a core grab on some other device. In this case we
         * must not get the grab, otherwise we may never ungrab the
         * device.
         */
d3782 4
a3785 4
        if (grab->grabtype == GRABTYPE_CORE)
        {
            DeviceIntPtr other;
            BOOL interfering = FALSE;
d3787 5
a3791 12
            /* A passive grab may have been created for a different device
               than it is assigned to at this point in time.
               Update the grab's device and modifier device to reflect the
               current state.
               Since XGrabDeviceButton requires to specify the
               modifierDevice explicitly, we don't override this choice.
               */
            if (tempGrab.type < GenericEvent)
            {
                grab->device = device;
                grab->modifierDevice = GetMaster(device, MASTER_KEYBOARD);
            }
d3793 11
a3803 16
            for (other = inputInfo.devices; other; other = other->next)
            {
                GrabPtr othergrab = other->deviceGrab.grab;
                if (othergrab && othergrab->grabtype == GRABTYPE_CORE &&
                    SameClient(grab, rClient(othergrab)) &&
                    ((IsPointerDevice(grab->device) &&
                     IsPointerDevice(othergrab->device)) ||
                     (IsKeyboardDevice(grab->device) &&
                      IsKeyboardDevice(othergrab->device))))
                {
                    interfering = TRUE;
                    break;
                }
            }
            if (interfering)
                continue;
d3806 19
a3824 10
        if (!activate)
        {
            return grab;
        }
        else if (!GetXIType(event) && !GetCoreType(event))
        {
            ErrorF("Event type %d in CheckPassiveGrabsOnWindow is neither"
                   " XI 1.x nor core\n", event->any.type);
            return NULL;
        }
d3826 7
a3832 8
        /* The only consumers of corestate are Xi 1.x and core events, which
         * are guaranteed to come from DeviceEvents. */
        if (match & (XI_MATCH | CORE_MATCH))
        {
            event->device_event.corestate &= 0x1f00;
            event->device_event.corestate |= tempGrab.modifiersDetail.exact &
                                              (~0x1f00);
        }
d3834 2
a3835 32
        if (match & CORE_MATCH)
        {
            rc = EventToCore(event, &xE, &count);
            if (rc != Success)
            {
                if (rc != BadMatch)
                    ErrorF("[dix] %s: core conversion failed in CPGFW "
                            "(%d, %d).\n", device->name, event->any.type, rc);
                continue;
            }
        } else if (match & XI2_MATCH)
        {
            rc = EventToXI2(event, &xE);
            if (rc != Success)
            {
                if (rc != BadMatch)
                    ErrorF("[dix] %s: XI2 conversion failed in CPGFW "
                            "(%d, %d).\n", device->name, event->any.type, rc);
                continue;
            }
            count = 1;
        } else
        {
            rc = EventToXI(event, &xE, &count);
            if (rc != Success)
            {
                if (rc != BadMatch)
                    ErrorF("[dix] %s: XI conversion failed in CPGFW "
                            "(%d, %d).\n", device->name, event->any.type, rc);
                continue;
            }
        }
d3837 1
a3837 1
        (*grabinfo->ActivateGrab)(device, grab, currentTime, TRUE);
d3839 22
a3860 3
        if (xE)
        {
            FixUpEventFromWindow(pSprite, xE, grab->window, None, TRUE);
d3862 3
a3864 5
            /* XXX: XACE? */
            TryClientEvents(rClient(grab), device, xE, count,
                            GetEventFilter(device, xE),
                            GetEventFilter(device, xE), grab);
        }
d3866 2
a3867 7
        if (grabinfo->sync.state == FROZEN_NO_EVENT)
        {
            if (!grabinfo->sync.event)
                grabinfo->sync.event = calloc(1, sizeof(DeviceEvent));
            *grabinfo->sync.event = event->device_event;
            grabinfo->sync.state = FROZEN_WITH_EVENT;
        }
d3869 1
a3869 2
        free(xE);
        return grab;
d3871 3
a3873 4
    return NULL;
#undef CORE_MATCH
#undef XI_MATCH
#undef XI2_MATCH
d3907 2
a3908 1
    FocusClassPtr focus = IsPointerEvent((InternalEvent*)event) ? NULL : device->focus;
d3912 1
a3912 2
    if (event->type != ET_ButtonPress &&
        event->type != ET_KeyPress)
d3915 2
a3916 3
    if (event->type == ET_ButtonPress
        && (device->button->buttonsDown != 1))
	return FALSE;
d3922 1
a3922 2
    if (ancestor)
    {
d3930 14
a3943 17
    if (focus)
    {
	for (; i < focus->traceGood; i++)
	{
	    pWin = focus->trace[i];
	    if (CheckPassiveGrabsOnWindow(pWin, device, (InternalEvent *) event,
                                          sendCore, TRUE))
	    {
		ret = TRUE;
		goto out;
	    }
	}

	if ((focus->win == NoneWin) ||
	    (i >= device->spriteInfo->sprite->spriteTraceGood) ||
	    (pWin && pWin != device->spriteInfo->sprite->spriteTrace[i-1]))
	    goto out;
d3946 7
a3952 9
    for (; i < device->spriteInfo->sprite->spriteTraceGood; i++)
    {
	pWin = device->spriteInfo->sprite->spriteTrace[i];
	if (CheckPassiveGrabsOnWindow(pWin, device, (InternalEvent *) event,
	                              sendCore, TRUE))
	{
	    ret = TRUE;
	    goto out;
	}
d3955 1
a3955 1
out:
d3983 1
a3983 1
	focus = inputInfo.keyboard->focus->win;
d3985 4
a3988 5
	return;
    if (focus == PointerRootWin)
    {
	DeliverDeviceEvents(window, event, NullGrab, NullWindow, keybd);
	return;
d3990 3
a3992 4
    if ((focus == window) || IsParent(focus, window))
    {
	if (DeliverDeviceEvents(window, event, NullGrab, focus, keybd))
	    return;
d3996 1
a3996 2
    ptr = GetPairedDevice(keybd);

d3999 1
a3999 2
    if (rc == Success)
    {
d4002 1
d4008 5
a4012 3
    } else if (rc != BadMatch)
        ErrorF("[dix] %s: XI2 conversion failed in DFE (%d, %d). Skipping delivery.\n",
               keybd->name, event->any.type, rc);
d4016 1
a4016 2
        XaceHook(XACE_SEND_ACCESS, NULL, keybd, focus, xE, count) == Success)
    {
d4019 1
a4019 2
                GetEventFilter(keybd, xE),
                NullGrab);
d4023 5
a4027 3
    } else if (rc != BadMatch)
        ErrorF("[dix] %s: XI conversion failed in DFE (%d, %d). Skipping delivery.\n",
               keybd->name, event->any.type, rc);
d4029 1
a4029 2
    if (sendCore)
    {
d4032 2
a4033 1
            if (XaceHook(XACE_SEND_ACCESS, NULL, keybd, focus, core, count) == Success) {
d4036 4
a4039 3
                deliveries = DeliverEventsToWindow(keybd, focus, core, count,
                                                   GetEventFilter(keybd, core),
                                                   NullGrab);
d4041 5
a4045 3
        } else if (rc != BadMatch)
            ErrorF("[dix] %s: core conversion failed DFE (%d, %d). Skipping delivery.\n",
                    keybd->name, event->any.type, rc);
d4048 1
a4048 1
unwind:
d4055 66
a4139 4
    int rc, count = 0;
    xEvent *xi = NULL;
    xEvent *xi2 = NULL;
    xEvent *core = NULL;
d4144 2
a4145 3
    if (grab->ownerEvents)
    {
	WindowPtr focus;
d4153 9
a4161 10
        else if (thisDev->focus)
	{
	    focus = thisDev->focus->win;
	    if (focus == FollowKeyboardWin)
		focus = inputInfo.keyboard->focus->win;
	}
	else
	    focus = PointerRootWin;
	if (focus == PointerRootWin)
	    deliveries = DeliverDeviceEvents(pSprite->win, event, grab,
d4163 7
a4169 7
	else if (focus && (focus == pSprite->win ||
                    IsParent(focus, pSprite->win)))
	    deliveries = DeliverDeviceEvents(pSprite->win, event, grab, focus,
					     thisDev);
	else if (focus)
	    deliveries = DeliverDeviceEvents(focus, event, grab, focus,
					     thisDev);
d4171 1
a4171 4
    if (!deliveries)
    {
        Mask mask;

a4177 2
        mask = grab->eventMask;

d4180 2
a4181 20
        if (sendCore && grab->grabtype == GRABTYPE_CORE)
        {
            rc = EventToCore(event, &core, &count);
            if (rc == Success)
            {
                FixUpEventFromWindow(pSprite, core, grab->window, None, TRUE);
                if (XaceHook(XACE_SEND_ACCESS, 0, thisDev,
                            grab->window, core, count) ||
                        XaceHook(XACE_RECEIVE_ACCESS, rClient(grab),
                            grab->window, core, count))
                    deliveries = 1; /* don't send, but pretend we did */
                else if (!IsInterferingGrab(rClient(grab), thisDev, core))
                {
                    deliveries = TryClientEvents(rClient(grab), thisDev,
                            core, count, mask,
                            GetEventFilter(thisDev, core),
                            grab);
                }
            } else if (rc != BadMatch)
                ErrorF("[dix] DeliverGrabbedEvent. Core conversion failed.\n");
d4184 2
a4185 17
        if (!deliveries)
        {
            rc = EventToXI2(event, &xi2);
            if (rc == Success)
            {
                int evtype = xi2_get_type(xi2);
                mask = grab->xi2mask[XIAllDevices][evtype/8] |
                    grab->xi2mask[XIAllMasterDevices][evtype/8] |
                    grab->xi2mask[thisDev->id][evtype/8];
                /* try XI2 event */
                FixUpEventFromWindow(pSprite, xi2, grab->window, None, TRUE);
                /* XXX: XACE */
                deliveries = TryClientEvents(rClient(grab), thisDev, xi2, 1, mask,
                        GetEventFilter(thisDev, xi2), grab);
            } else if (rc != BadMatch)
                ErrorF("[dix] %s: XI2 conversion failed in DGE (%d, %d). Skipping delivery.\n",
                        thisDev->name, event->any.type, rc);
d4188 2
a4189 31
        if (!deliveries)
        {
            rc = EventToXI(event, &xi, &count);
            if (rc == Success)
            {
                /* try XI event */
                if (grabinfo->fromPassiveGrab  &&
                        grabinfo->implicitGrab)
                    mask = grab->deviceMask;
                else
                    mask = grab->eventMask;

                FixUpEventFromWindow(pSprite, xi, grab->window, None, TRUE);

                if (XaceHook(XACE_SEND_ACCESS, 0, thisDev,
                            grab->window, xi, count) ||
                        XaceHook(XACE_RECEIVE_ACCESS, rClient(grab),
                            grab->window, xi, count))
                    deliveries = 1; /* don't send, but pretend we did */
                else
                {
                    deliveries =
                        TryClientEvents(rClient(grab), thisDev,
                                xi, count,
                                mask,
                                GetEventFilter(thisDev, xi),
                                grab);
                }
            } else if (rc != BadMatch)
                ErrorF("[dix] %s: XI conversion failed in DGE (%d, %d). Skipping delivery.\n",
                        thisDev->name, event->any.type, rc);
d4195 11
a4205 14
    if (deliveries && !deactivateGrab && event->any.type != ET_Motion)
    {
	switch (grabinfo->sync.state)
	{
	case FREEZE_BOTH_NEXT_EVENT:
	    dev = GetPairedDevice(thisDev);
	    if (dev)
	    {
		FreezeThaw(dev, TRUE);
		if ((dev->deviceGrab.sync.state == FREEZE_BOTH_NEXT_EVENT) &&
		    (CLIENT_BITS(grab->resource) ==
		     CLIENT_BITS(dev->deviceGrab.grab->resource)))
		    dev->deviceGrab.sync.state = FROZEN_NO_EVENT;
		else
d4207 8
a4214 10
	    }
	    /* fall through */
	case FREEZE_NEXT_EVENT:
	    grabinfo->sync.state = FROZEN_WITH_EVENT;
	    FreezeThaw(thisDev, TRUE);
	    if (!grabinfo->sync.event)
		grabinfo->sync.event = calloc(1, sizeof(InternalEvent));
	    *grabinfo->sync.event = event->device_event;
	    break;
	}
a4216 4
    free(core);
    free(xi);
    free(xi2);

d4225 1
a4225 1
FixKeyState (DeviceEvent *event, DeviceIntPtr keybd)
d4230 1
a4230 1
	DebugF("FixKeyState: Key %d %s\n",key,
d4266 22
a4287 26
    while (1)
    {
	if (pChild->optional)
	{
	    pChild->optional->otherEventMasks = 0;
	    for (others = wOtherClients(pChild); others; others = others->next)
	    {
		pChild->optional->otherEventMasks |= others->mask;
	    }
	}
	pChild->deliverableEvents = pChild->eventMask|
				    wOtherEventMasks(pChild);
	if (pChild->parent)
	    pChild->deliverableEvents |=
		(pChild->parent->deliverableEvents &
		 ~wDontPropagateMask(pChild) & PropagateMask);
	if (pChild->firstChild)
	{
	    pChild = pChild->firstChild;
	    continue;
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
d4299 1
a4299 1
    WindowPtr pWin = (WindowPtr)value;
d4302 13
a4314 16
    for (other = wOtherClients(pWin); other; other = other->next)
    {
	if (other->resource == id)
	{
	    if (prev)
		prev->next = other->next;
	    else
	    {
		if (!(pWin->optional->otherClients = other->next))
		    CheckWindowOptionalNeed (pWin);
	    }
	    free(other);
	    RecalculateDeliverableEvents(pWin);
	    return Success;
	}
	prev = other;
d4317 1
a4317 2
    /*NOTREACHED*/
    return -1; /* make compiler happy */
d4324 1
a4324 1
    OtherClients * others;
d4328 3
a4330 4
    if (mask & ~AllEventMasks)
    {
	client->errorValue = mask;
	return BadValue;
d4334 4
a4337 4
	rc = XaceHook(XACE_RESOURCE_ACCESS, client, pWin->drawable.id,
		      RT_WINDOW, pWin, RT_NONE, NULL, DixManageAccess);
	if (rc != Success)
	    return rc;
d4340 16
a4355 14
    if (check & (pWin->eventMask|wOtherEventMasks(pWin)))
    {				       /* It is illegal for two different
				          clients to select on any of the
				          events for AtMostOneClient. However,
				          it is OK, for some client to
				          continue selecting on one of those
				          events.  */
	if ((wClient(pWin) != client) && (check & pWin->eventMask))
	    return BadAccess;
	for (others = wOtherClients (pWin); others; others = others->next)
	{
	    if (!SameClient(others, client) && (check & others->mask))
		return BadAccess;
	}
d4357 29
a4385 40
    if (wClient (pWin) == client)
    {
	check = pWin->eventMask;
	pWin->eventMask = mask;
    }
    else
    {
	for (others = wOtherClients (pWin); others; others = others->next)
	{
	    if (SameClient(others, client))
	    {
		check = others->mask;
		if (mask == 0)
		{
		    FreeResource(others->resource, RT_NONE);
		    return Success;
		}
		else
		    others->mask = mask;
		goto maskSet;
	    }
	}
	check = 0;
	if (!pWin->optional && !MakeWindowOptional (pWin))
	    return BadAlloc;
	others = malloc(sizeof(OtherClients));
	if (!others)
	    return BadAlloc;
	others->mask = mask;
	others->resource = FakeClientID(client->index);
	others->next = pWin->optional->otherClients;
	pWin->optional->otherClients = others;
	if (!AddResource(others->resource, RT_OTHERCLIENT, (pointer)pWin))
	    return BadAlloc;
    }
maskSet:
    if ((mask & PointerMotionHintMask) && !(check & PointerMotionHintMask))
    {
        for (dev = inputInfo.devices; dev; dev = dev->next)
        {
d4400 3
a4402 4
    if (mask & ~PropagateMask)
    {
	client->errorValue = mask;
	return BadValue;
d4405 1
a4405 1
	DontPropagateRefCnts[pWin->dontPropagate]--;
d4407 12
a4418 15
	i = 0;
    else
    {
	for (i = DNPMCOUNT, free = 0; --i > 0; )
	{
	    if (!DontPropagateRefCnts[i])
		free = i;
	    else if (mask == DontPropagateMasks[i])
		break;
	}
	if (!i && free)
	{
	    i = free;
	    DontPropagateMasks[i] = mask;
	}
d4420 8
a4427 10
    if (i || !mask)
    {
	pWin->dontPropagate = i;
	if (i)
	    DontPropagateRefCnts[i]++;
	if (pWin->optional)
	{
	    pWin->optional->dontPropagateMask = mask;
	    *checkOptional = TRUE;
	}
d4429 7
a4435 9
    else
    {
	if (!pWin->optional && !MakeWindowOptional (pWin))
	{
	    if (pWin->dontPropagate)
		DontPropagateRefCnts[pWin->dontPropagate]++;
	    return BadAlloc;
	}
	pWin->dontPropagate = 0;
d4447 9
a4455 13
CoreEnterLeaveEvent(
    DeviceIntPtr mouse,
    int type,
    int mode,
    int detail,
    WindowPtr pWin,
    Window child)
{
    xEvent              event;
    WindowPtr		focus;
    DeviceIntPtr        keybd;
    GrabPtr	        grab = mouse->deviceGrab.grab;
    Mask		mask;
d4457 1
a4457 1
    keybd = GetPairedDevice(mouse);
d4460 6
a4465 7
	(detail != NotifyInferior))
	mouse->valuator->motionHintWindow = NullWindow;
    if (grab)
    {
	mask = (pWin == grab->window) ? grab->eventMask : 0;
	if (grab->ownerEvents)
	    mask |= EventMaskForClient(pWin, rClient(grab));
d4467 2
a4468 3
    else
    {
	mask = pWin->eventMask | wOtherEventMasks(pWin);
d4483 2
a4484 1
    event.u.enterLeave.state = mouse->button ? (mouse->button->state & 0x1f00) : 0;
d4487 1
a4487 1
                XkbGrabStateFromRec(&keybd->key->xkbInfo->state);
d4491 1
a4491 2
            ((pWin == focus) || (focus == PointerRootWin) ||
             IsParent(focus, pWin)))
d4494 1
a4494 2
    if ((mask & GetEventFilter(mouse, &event)))
    {
d4500 1
a4500 2
                                  GetEventFilter(mouse, &event),
                                  NullGrab);
d4503 1
a4503 2
    if ((type == EnterNotify) && (mask & KeymapStateMask))
    {
d4506 1
d4508 1
a4508 1
            memset((char *)&ke.map[0], 0, 31);
d4510 1
a4510 1
            memmove((char *)&ke.map[0], (char *)&keybd->key->down[1], 31);
d4514 1
a4514 1
            TryClientEvents(rClient(grab), keybd, (xEvent *)&ke, 1,
d4517 1
a4517 1
            DeliverEventsToWindow(mouse, pWin, (xEvent *)&ke, 1,
d4523 10
a4532 14
DeviceEnterLeaveEvent(
    DeviceIntPtr mouse,
    int sourceid,
    int type,
    int mode,
    int detail,
    WindowPtr pWin,
    Window child)
{
    GrabPtr             grab = mouse->deviceGrab.grab;
    xXIEnterEvent       *event;
    int                 filter;
    int                 btlen, len, i;
    DeviceIntPtr        kbd;
d4543 12
a4554 12
    event->type         = GenericEvent;
    event->extension    = IReqCode;
    event->evtype       = type;
    event->length       = (len - sizeof(xEvent))/4;
    event->buttons_len  = btlen;
    event->detail       = detail;
    event->time         = currentTime.milliseconds;
    event->deviceid     = mouse->id;
    event->sourceid     = sourceid;
    event->mode         = mode;
    event->root_x       = FP1616(mouse->spriteInfo->sprite->hot.x, 0);
    event->root_y       = FP1616(mouse->spriteInfo->sprite->hot.y, 0);
d4561 1
a4561 2
    if (kbd && kbd->key)
    {
d4571 1
a4571 1
    FixUpEventFromWindow(mouse->spriteInfo->sprite, (xEvent*)event, pWin,
d4574 1
a4574 1
    filter = GetEventFilter(mouse, (xEvent*)event);
d4576 1
a4576 2
    if (grab)
    {
d4578 7
a4584 7
        mask = grab->xi2mask[XIAllDevices][type/8] |
               grab->xi2mask[XIAllMasterDevices][type/8] |
               grab->xi2mask[mouse->id][type/8];
        TryClientEvents(rClient(grab), mouse, (xEvent*)event, 1, mask,
                        filter, grab);
    } else {
        if (!GetWindowXI2Mask(mouse, pWin, (xEvent*)event))
d4586 1
a4586 1
        DeliverEventsToWindow(mouse, pWin, (xEvent*)event, 1, filter,
d4590 1
a4590 1
out:
d4608 1
a4608 2
            ((pWin->eventMask | wOtherEventMasks(pWin)) & KeymapStateMask))
    {
d4611 1
d4613 1
a4613 1
            memset((char *)&ke.map[0], 0, 31);
d4615 1
a4615 1
            memmove((char *)&ke.map[0], (char *)&dev->key->down[1], 31);
d4618 2
a4619 2
        DeliverEventsToWindow(dev, pWin, (xEvent *)&ke, 1,
                KeymapStateMask, NullGrab);
d4641 3
a4643 7
SetInputFocus(
    ClientPtr client,
    DeviceIntPtr dev,
    Window focusID,
    CARD8 revertTo,
    Time ctime,
    Bool followOK)
d4649 1
a4649 2
    DeviceIntPtr keybd; /* used for FollowKeyboard or FollowKeyboardWin */

d4653 5
a4657 6
	(revertTo != RevertToPointerRoot) &&
	(revertTo != RevertToNone) &&
	((revertTo != RevertToFollowKeyboard) || !followOK))
    {
	client->errorValue = revertTo;
	return BadValue;
d4661 1
a4661 4
    if (IsKeyboardDevice(dev))
        keybd = dev;
    else
        keybd = GetPairedDevice(dev);
d4664 3
a4666 4
	focusWin = (WindowPtr)(long)focusID;
    else if ((focusID == FollowKeyboard) && followOK)
    {
	focusWin = keybd->focus->win;
d4669 7
a4675 7
	rc = dixLookupWindow(&focusWin, focusID, client, DixSetAttrAccess);
	if (rc != Success)
	    return rc;
	/* It is a match error to try to set the input focus to an
	unviewable window. */
	if(!focusWin->realized)
	    return BadMatch;
d4679 1
a4679 1
	return Success;
d4683 2
a4684 2
	(CompareTimeStamps(time, focus->time) == EARLIER))
	return Success;
d4686 1
a4686 2
    if (focus->win == FollowKeyboardWin)
    {
d4689 2
a4690 2
    } else
    {
d4697 1
a4697 1
	focus->win = FollowKeyboardWin;
d4699 1
a4699 1
	focus->win = focusWin;
d4701 2
a4702 3
	focus->traceGood = 0;
    else
    {
d4704 1
a4704 1
	WindowPtr pWin;
d4706 8
a4713 8
        for (pWin = focusWin; pWin; pWin = pWin->parent) depth++;
        if (depth > focus->traceSize)
        {
	    focus->traceSize = depth+1;
	    focus->trace = realloc(focus->trace,
				    focus->traceSize * sizeof(WindowPtr));
	}
	focus->traceGood = depth;
d4715 1
a4715 1
	    focus->trace[depth] = pWin;
d4729 1
d4735 1
a4735 1
			 stuff->revertTo, stuff->time, FALSE);
d4751 1
d4757 1
a4757 1
	return rc;
d4764 1
a4764 1
	rep.focus = None;
d4766 3
a4768 2
	rep.focus = PointerRoot;
    else rep.focus = focus->win->drawable.id;
d4789 1
a4790 1
    TimeStamp time;
d4796 2
a4797 3
    if (stuff->eventMask & ~PointerGrabMask)
    {
	client->errorValue = stuff->eventMask;
d4802 6
a4807 7
	confineTo = NullWindow;
    else
    {
	rc = dixLookupWindow(&confineTo, stuff->confineTo, client,
			     DixSetAttrAccess);
	if (rc != Success)
	    return rc;
d4814 1
a4814 2
    if (grab)
    {
d4825 1
a4825 2
                    &mask, GRABTYPE_CORE, stuff->cursor,
                    stuff->confineTo, &rep.status);
d4830 1
a4830 1
        FreeCursor (oldCursor, (Cursor)0);
a4831 1
    time = ClientTimeToServerTime(stuff->time);
d4849 1
a4849 1
    GrabPtr      grab;
d4851 1
d4856 2
a4857 3
    if (stuff->eventMask & ~PointerGrabMask)
    {
	client->errorValue = stuff->eventMask;
d4861 9
a4869 10
	newCursor = NullCursor;
    else
    {
	int rc = dixLookupResourceByType((pointer *)&newCursor, stuff->cursor,
					 RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = stuff->cursor;
	    return rc;
	}
d4876 1
a4876 1
	return Success;
d4878 1
a4878 1
	return Success;
d4881 2
a4882 2
	     (CompareTimeStamps(time, device->deviceGrab.grabTime) == EARLIER))
	return Success;
d4886 1
a4886 1
	newCursor->refcnt++;
d4889 1
a4889 1
	FreeCursor(oldCursor, (Cursor)0);
d4905 1
d4914 3
a4916 3
	    (CompareTimeStamps(time, device->deviceGrab.grabTime) != EARLIER) &&
	    (grab) && SameClient(grab, client))
	(*device->deviceGrab.DeactivateGrab)(device);
d4953 2
a4954 3
    if ((keyboard_mode != GrabModeSync) && (keyboard_mode != GrabModeAsync))
    {
	client->errorValue = keyboard_mode;
d4957 2
a4958 3
    if ((pointer_mode != GrabModeSync) && (pointer_mode != GrabModeAsync))
    {
	client->errorValue = pointer_mode;
d4961 2
a4962 3
    if ((ownerEvents != xFalse) && (ownerEvents != xTrue))
    {
	client->errorValue = ownerEvents;
d4968 1
a4968 1
	return rc;
d4971 6
a4976 7
	confineTo = NullWindow;
    else
    {
	rc = dixLookupWindow(&confineTo, confineToWin, client,
			     DixSetAttrAccess);
	if (rc != Success)
	    return rc;
d4980 9
a4988 11
	cursor = NullCursor;
    else
    {
	rc = dixLookupResourceByType((pointer *)&cursor, curs, RT_CURSOR,
			       client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = curs;
	    return rc;
	}
	access_mode |= DixForceAccess;
d4992 1
a4992 1
	access_mode |= DixFreezeAccess;
d4995 1
a4995 1
	return rc;
d5002 1
a5002 1
	*status = AlreadyGrabbed;
d5005 2
a5006 3
                !(confineTo->realized
                    && BorderSizeNotEmpty(dev, confineTo))))
	*status = GrabNotViewable;
d5008 2
a5009 2
	     (CompareTimeStamps(time, grabInfo->grabTime) == EARLIER))
	*status = GrabInvalidTime;
d5011 6
a5016 5
	     grabInfo->sync.other && !SameClient(grabInfo->sync.other, client))
	*status = GrabFrozen;
    else
    {
	GrabRec tempGrab;
d5018 18
a5035 2
        /* Otherwise segfaults happen on grabbed MPX devices */
        memset(&tempGrab, 0, sizeof(GrabRec));
d5037 1
a5037 18
        tempGrab.next = NULL;
	tempGrab.window = pWin;
	tempGrab.resource = client->clientAsMask;
	tempGrab.ownerEvents = ownerEvents;
	tempGrab.keyboardMode = keyboard_mode;
	tempGrab.pointerMode = pointer_mode;
	if (grabtype == GRABTYPE_CORE)
	    tempGrab.eventMask = mask->core;
	else if (grabtype == GRABTYPE_XI)
	    tempGrab.eventMask = mask->xi;
	else
	    memcpy(tempGrab.xi2mask, mask->xi2mask, sizeof(tempGrab.xi2mask));
	tempGrab.device = dev;
	tempGrab.cursor = cursor;
	tempGrab.confineTo = confineTo;
	tempGrab.grabtype = grabtype;
	(*grabInfo->ActivateGrab)(dev, &tempGrab, time, FALSE);
	*status = GrabSuccess;
d5051 1
d5063 3
a5065 3
            stuff->keyboardMode, stuff->grabWindow, stuff->ownerEvents,
            stuff->time, &mask, GRABTYPE_CORE, None, None,
            &rep.status);
d5068 1
a5068 1
	return result;
d5087 1
d5097 3
a5099 3
	(CompareTimeStamps(time, device->deviceGrab.grabTime) != EARLIER) &&
	(grab) && SameClient(grab, client) && grab->grabtype == GRABTYPE_CORE)
	(*device->deviceGrab.DeactivateGrab)(device);
d5118 1
d5124 1
a5124 1
	return rc;
d5127 1
a5127 1
	return rc;
d5129 1
a5129 1
    keyboard = GetPairedDevice(mouse);
d5133 1
a5133 1
	MaybeStopHint(mouse, client);
d5137 1
a5137 2
    rep.mask = mouse->button ? (mouse->button->state) : 0;
    rep.mask |= XkbStateFieldFromRec(&keyboard->key->xkbInfo->state);
d5143 9
a5151 11
    if (pSprite->hot.pScreen == pWin->drawable.pScreen)
    {
	rep.sameScreen = xTrue;
	rep.winX = pSprite->hot.x - pWin->drawable.x;
	rep.winY = pSprite->hot.y - pWin->drawable.y;
	for (t = pSprite->win; t; t = t->parent)
	    if (t->parent == pWin)
	    {
		rep.child = t->drawable.id;
		break;
	    }
d5153 4
a5156 5
    else
    {
	rep.sameScreen = xFalse;
	rep.winX = 0;
	rep.winY = 0;
d5160 7
a5166 7
    if(!noPanoramiXExtension) {
	rep.rootX += screenInfo.screens[0]->x;
	rep.rootY += screenInfo.screens[0]->y;
	if(stuff->id == rep.root) {
	    rep.winX += screenInfo.screens[0]->x;
	    rep.winY += screenInfo.screens[0]->y;
	}
d5171 6
a5176 6
	rep.mask = 0;
	rep.child = None;
	rep.rootX = 0;
	rep.rootY = 0;
	rep.winX = 0;
	rep.winY = 0;
d5192 1
d5195 7
a5201 7
    inputInfo.devices = (DeviceIntPtr)NULL;
    inputInfo.off_devices = (DeviceIntPtr)NULL;
    inputInfo.keyboard = (DeviceIntPtr)NULL;
    inputInfo.pointer = (DeviceIntPtr)NULL;
    for (i = 0; i < MAXDEVICES; i++)
    {
        memcpy(&filters[i], default_filter, sizeof(default_filter));
d5204 1
a5204 1
    syncEvents.replayDev = (DeviceIntPtr)NULL;
d5206 4
a5209 7
    while (syncEvents.pending)
    {
	QdEventPtr next = syncEvents.pending->next;
	free(syncEvents.pending);
	syncEvents.pending = next;
    }
    syncEvents.pendtail = &syncEvents.pending;
d5212 1
a5212 1
    syncEvents.time.milliseconds = 0;	/* hardly matters */
d5216 3
a5218 4
    for (i = 0; i < DNPMCOUNT; i++)
    {
	DontPropagateMasks[i] = 0;
	DontPropagateRefCnts[i] = 0;
d5244 1
a5244 1
    WindowPtr effectiveFocus = NullWindow; /* only set if dest==InputFocus */
d5246 1
a5246 1
    DeviceIntPtr keybd = GetPairedDevice(dev);
d5248 1
d5264 1
a5264 1
	extension. */
d5266 6
a5271 7
    if ( ! ((stuff->event.u.u.type > X_Reply &&
	     stuff->event.u.u.type < LASTEvent) ||
	    (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&
	     stuff->event.u.u.type < (unsigned)lastEvent)))
    {
	client->errorValue = stuff->event.u.u.type;
	return BadValue;
d5274 4
a5277 6
	stuff->event.u.u.detail != 8 &&
	stuff->event.u.u.detail != 16 &&
	stuff->event.u.u.detail != 32)
    {
	client->errorValue = stuff->event.u.u.detail;
	return BadValue;
d5279 3
a5281 4
    if (stuff->eventMask & ~AllEventMasks)
    {
	client->errorValue = stuff->eventMask;
	return BadValue;
d5285 18
a5302 20
	pWin = pSprite->win;
    else if (stuff->destination == InputFocus)
    {
	WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;

	if (inputFocus == NoneWin)
	    return Success;

	/* If the input focus is PointerRootWin, send the event to where
	the pointer is if possible, then perhaps propogate up to root. */
	if (inputFocus == PointerRootWin)
	    inputFocus = GetCurrentRootWindow(dev);

	if (IsParent(inputFocus, pSprite->win))
	{
	    effectiveFocus = inputFocus;
	    pWin = pSprite->win;
	}
	else
	    effectiveFocus = pWin = inputFocus;
d5305 1
a5305 1
	dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);
d5308 4
a5311 5
	return BadWindow;
    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue))
    {
	client->errorValue = stuff->propagate;
	return BadValue;
d5314 5
a5318 7
    if (stuff->propagate)
    {
	for (;pWin; pWin = pWin->parent)
	{
	    if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,
			 &stuff->event, 1))
		return Success;
d5320 9
a5328 8
                        &stuff->event, 1, stuff->eventMask, NullGrab))
		return Success;
	    if (pWin == effectiveFocus)
		return Success;
	    stuff->eventMask &= ~wDontPropagateMask(pWin);
	    if (!stuff->eventMask)
		break;
	}
d5332 1
a5332 1
                                    1, stuff->eventMask, NullGrab);
d5347 1
a5347 1
    GrabRec tempGrab;
d5354 1
a5354 1
	return rc;
d5357 3
a5359 4
	 (stuff->key < keybd->key->xkbInfo->desc->min_key_code))
	&& (stuff->key != AnyKey))
    {
	client->errorValue = stuff->key;
d5363 3
a5365 4
	(stuff->modifiers & ~AllModifiersMask))
    {
	client->errorValue = stuff->modifiers;
	return BadValue;
d5367 19
a5385 11
    tempGrab.resource = client->clientAsMask;
    tempGrab.device = keybd;
    tempGrab.window = pWin;
    tempGrab.modifiersDetail.exact = stuff->modifiers;
    tempGrab.modifiersDetail.pMask = NULL;
    tempGrab.modifierDevice = keybd;
    tempGrab.type = KeyPress;
    tempGrab.grabtype = GRABTYPE_CORE;
    tempGrab.detail.exact = stuff->key;
    tempGrab.detail.pMask = NULL;
    tempGrab.next = NULL;
d5387 1
a5387 3
    if (!DeletePassiveGrabFromList(&tempGrab))
	return BadAlloc;
    return Success;
d5400 1
d5411 1
a5411 1
    param.grabtype = GRABTYPE_CORE;
d5422 3
a5424 4
	 (stuff->key < keybd->key->xkbInfo->desc->min_key_code))
	&& (stuff->key != AnyKey))
    {
	client->errorValue = stuff->key;
d5429 1
a5429 2
	return rc;

d5433 1
a5433 1
    grab = CreateGrab(client->index, keybd, keybd, pWin, GRABTYPE_CORE, &mask,
d5436 1
a5436 1
	return BadAlloc;
a5439 1

d5450 1
d5462 2
a5463 3
	(stuff->pointerMode != GrabModeAsync))
    {
	client->errorValue = stuff->pointerMode;
d5467 2
a5468 3
	(stuff->keyboardMode != GrabModeAsync))
    {
	client->errorValue = stuff->keyboardMode;
d5472 3
a5474 4
	(stuff->modifiers & ~AllModifiersMask))
    {
	client->errorValue = stuff->modifiers;
	return BadValue;
d5476 3
a5478 4
    if ((stuff->ownerEvents != xFalse) && (stuff->ownerEvents != xTrue))
    {
	client->errorValue = stuff->ownerEvents;
	return BadValue;
d5480 2
a5481 3
    if (stuff->eventMask & ~PointerGrabMask)
    {
	client->errorValue = stuff->eventMask;
d5486 1
a5486 1
	return rc;
d5488 1
a5488 1
       confineTo = NullWindow;
d5490 4
a5493 4
	rc = dixLookupWindow(&confineTo, stuff->confineTo, client,
			     DixSetAttrAccess);
	if (rc != Success)
	    return rc;
d5496 9
a5504 11
	cursor = NullCursor;
    else
    {
	rc = dixLookupResourceByType((pointer *)&cursor, stuff->cursor, RT_CURSOR,
			       client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = stuff->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
d5508 1
a5508 1
    modifierDevice = GetPairedDevice(ptr);
d5510 2
a5511 2
	stuff->keyboardMode == GrabModeSync)
	access_mode |= DixFreezeAccess;
d5514 1
a5514 1
	return rc;
d5517 1
a5517 1
    param.grabtype = GRABTYPE_CORE;
d5526 1
a5526 1
                      GRABTYPE_CORE, &mask, &param, ButtonPress,
d5529 1
a5529 1
	return BadAlloc;
d5543 1
a5543 1
    GrabRec tempGrab;
d5549 3
a5551 4
	(stuff->modifiers & ~AllModifiersMask))
    {
	client->errorValue = stuff->modifiers;
	return BadValue;
d5555 1
a5555 1
	return rc;
d5559 14
a5572 11
    tempGrab.resource = client->clientAsMask;
    tempGrab.device = ptr;
    tempGrab.window = pWin;
    tempGrab.modifiersDetail.exact = stuff->modifiers;
    tempGrab.modifiersDetail.pMask = NULL;
    tempGrab.modifierDevice = GetPairedDevice(ptr);
    tempGrab.type = ButtonPress;
    tempGrab.detail.exact = stuff->button;
    tempGrab.grabtype = GRABTYPE_CORE;
    tempGrab.detail.pMask = NULL;
    tempGrab.next = NULL;
d5574 5
a5578 3
    if (!DeletePassiveGrabFromList(&tempGrab))
	return BadAlloc;
    return Success;
d5595 7
a5601 8
    WindowPtr		parent;
    DeviceIntPtr	mouse = inputInfo.pointer;
    DeviceIntPtr	keybd = inputInfo.keyboard;
    FocusClassPtr	focus;
    OtherClientsPtr	oc;
    GrabPtr		passive;
    GrabPtr             grab;

d5604 1
a5604 1
	input focus changes. */
d5606 2
a5607 4
    if (grab &&
	((grab->window == pWin) || (grab->confineTo == pWin)))
	(*mouse->deviceGrab.DeactivateGrab)(mouse);

d5612 1
a5612 1
	(*keybd->deviceGrab.DeactivateGrab)(keybd);
d5615 1
a5615 2
    for (mouse = inputInfo.devices; mouse; mouse = mouse->next)
    {
d5618 1
a5618 1
            (*mouse->deviceGrab.DeactivateGrab)(mouse);
d5621 2
a5622 5

    for (keybd = inputInfo.devices; keybd; keybd = keybd->next)
    {
        if (IsKeyboardDevice(keybd))
        {
d5628 1
a5628 2
            if ((pWin == focus->win) && (pWin->parent != NullWindow))
            {
d5636 18
a5653 20
                switch (focus->revert)
                {
                    case RevertToNone:
                        DoFocusEvents(keybd, pWin, NoneWin, focusEventMode);
                        focus->win = NoneWin;
                        focus->traceGood = 0;
                        break;
                    case RevertToParent:
                        parent = pWin;
                        do
                        {
                            parent = parent->parent;
                            focus->traceGood--;
                        } while (!parent->realized
                                /* This would be a good protocol change -- windows being reparented
                                   during SaveSet processing would cause the focus to revert to the
                                   nearest enclosing window which will survive the death of the exiting
                                   client, instead of ending up reverting to a dying window and thence
                                   to None
                                 */
d5655 1
a5655 1
				 || wClient(parent)->clientGone
d5657 13
a5669 12
                                );
                        if (!ActivateFocusInGrab(keybd, pWin, parent))
                            DoFocusEvents(keybd, pWin, parent, focusEventMode);
                        focus->win = parent;
                        focus->revert = RevertToNone;
                        break;
                    case RevertToPointerRoot:
                        if (!ActivateFocusInGrab(keybd, pWin, PointerRootWin))
                            DoFocusEvents(keybd, pWin, PointerRootWin, focusEventMode);
                        focus->win = PointerRootWin;
                        focus->traceGood = 0;
                        break;
d5674 1
a5674 2
        if (IsPointerDevice(keybd))
        {
d5680 8
a5687 9
    if (freeResources)
    {
	if (pWin->dontPropagate)
	    DontPropagateRefCnts[pWin->dontPropagate]--;
	while ( (oc = wOtherClients(pWin)) )
	    FreeResource(oc->resource, RT_NONE);
	while ( (passive = wPassiveGrabs(pWin)) )
	    FreeResource(passive->resource, RT_NONE);
     }
d5705 2
a5706 1
    if(!noPanoramiXExtension && pWin->drawable.pScreen->myNum) return;
d5709 2
a5710 4
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
        {
d5712 1
a5712 2
            if (grab && (confineTo = grab->confineTo))
            {
d5714 1
a5714 1
                    (*pDev->deviceGrab.DeactivateGrab)(pDev);
d5725 1
a5725 1
    OtherClientsPtr	other;
d5727 5
a5731 6
    if (wClient (pWin) == client)
	return pWin->eventMask;
    for (other = wOtherClients(pWin); other; other = other->next)
    {
	if (SameClient(other, client))
	    return other->mask;
d5743 5
a5747 4
    int		rc, nscr;
    ScreenPtr	pscr;
    Bool	displayed;
    SpritePtr   pSprite = PickPointer(client)->spriteInfo->sprite;
d5751 5
a5755 6
    rc = dixLookupResourceByType((pointer *)&pCursor, stuff->cursor, RT_CURSOR,
			   client, DixWriteAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->cursor;
	return rc;
d5766 2
a5767 3
    for (nscr = 0; nscr < screenInfo.numScreens; nscr++)
    {
	pscr = screenInfo.screens[nscr];
d5769 7
a5775 7
	if(!noPanoramiXExtension)
	    displayed = (pscr == pSprite->screen);
	else
#endif
	    displayed = (pscr == pSprite->hotPhys.pScreen);
	( *pscr->RecolorCursor)(PickPointer(client), pscr, pCursor,
				(pCursor == pSprite->current) && displayed);
d5798 1
a5798 1
    xEvent    eventCopy;
d5800 2
a5801 3
    xEvent    *eventTo, *eventFrom;
    int       i,
              eventlength = sizeof(xEvent);
d5804 1
a5804 1
	return;
d5807 2
a5808 2
	if ((events[i].u.u.type & 0x7f) != KeymapNotify)
	    events[i].u.u.sequenceNumber = pClient->sequence;
d5814 29
a5842 30
    if(!noPanoramiXExtension &&
       (screenInfo.screens[0]->x || screenInfo.screens[0]->y))
    {
	switch(events->u.u.type) {
	case MotionNotify:
	case ButtonPress:
	case ButtonRelease:
	case KeyPress:
	case KeyRelease:
	case EnterNotify:
	case LeaveNotify:
	/*
	   When multiple clients want the same event DeliverEventsToWindow
	   passes the same event structure multiple times so we can't
	   modify the one passed to us
        */
	    count = 1;  /* should always be 1 */
	    memcpy(&eventCopy, events, sizeof(xEvent));
	    eventCopy.u.keyButtonPointer.rootX += screenInfo.screens[0]->x;
	    eventCopy.u.keyButtonPointer.rootY += screenInfo.screens[0]->y;
	    if(eventCopy.u.keyButtonPointer.event ==
	       eventCopy.u.keyButtonPointer.root)
	    {
		eventCopy.u.keyButtonPointer.eventX += screenInfo.screens[0]->x;
		eventCopy.u.keyButtonPointer.eventY += screenInfo.screens[0]->y;
	    }
	    events = &eventCopy;
	    break;
	default: break;
	}
d5846 7
a5852 7
    if (EventCallback)
    {
	EventInfoRec eventinfo;
	eventinfo.client = pClient;
	eventinfo.events = events;
	eventinfo.count = count;
	CallCallbacks(&EventCallback, (pointer)&eventinfo);
d5856 3
a5858 4
	for (i = 0; i < count; i++)
	{
	    XSERVER_SEND_EVENT(pClient->index, events[i].u.u.type, &events[i]);
	}
d5863 2
a5864 4
    for (i = 1; i < count; i++)
    {
        if (events[i].u.u.type == GenericEvent)
        {
d5870 2
a5871 3
    if (events->u.u.type == GenericEvent)
    {
        eventlength += ((xGenericEvent*)events)->length * 4;
d5874 2
a5875 4
    if(pClient->swapped)
    {
        if (eventlength > swapEventLen)
        {
d5878 1
a5878 2
            if (!swapEvent)
            {
d5884 2
a5885 3
	for(i = 0; i < count; i++)
	{
	    eventFrom = &events[i];
d5888 4
a5891 4
	    /* Remember to strip off the leading bit of type in case
	       this event was sent with "SendEvent." */
	    (*EventSwapVector[eventFrom->u.u.type & 0177])
		(eventFrom, eventTo);
d5893 2
a5894 2
	    WriteToClient(pClient, eventlength, (char *)eventTo);
	}
d5896 1
a5896 2
    else
    {
d5900 1
a5900 1
	WriteToClient(pClient, count * eventlength, (char *) events);
d5917 1
d5919 1
a5919 1
	return rc;
d5921 1
a5921 2
    if (!IsMaster(device))
    {
d5924 2
a5925 2
    } else if (!device->spriteInfo->spriteOwner)
    {
d5927 1
a5927 1
                "Cannot be ClientPointer\n", device->id);
d5948 1
a5948 2
    for(it = inputInfo.devices; it; it = it->next)
    {
d5950 2
a5951 2
        if (grab && grab->grabtype == GRABTYPE_CORE && SameClient(grab, client))
        {
d5953 1
a5953 1
            return it; /* Always return a core grabbed device */
d5957 1
a5957 2
    if (!client->clientPtr)
    {
d5959 2
a5960 4
        while (it)
        {
            if (IsMaster(it) && it->spriteInfo->spriteOwner)
            {
d5980 1
a5980 2
    if (!kbd)
    {
d5982 1
a5982 1
                "is a bug.\n");
d5997 1
a5997 1
IsInterferingGrab(ClientPtr client, DeviceIntPtr dev, xEvent* event)
d6001 11
a6011 12
    switch(event->u.u.type)
    {
        case KeyPress:
        case KeyRelease:
        case ButtonPress:
        case ButtonRelease:
        case MotionNotify:
        case EnterNotify:
        case LeaveNotify:
            break;
        default:
            return FALSE;
d6017 2
a6018 4
    while(it)
    {
        if (it != dev)
        {
d6020 1
a6020 2
                        && !it->deviceGrab.fromPassiveGrab)
            {
d6022 1
a6022 1
                        (IsKeyboardDevice(it) && IsKeyboardDevice(dev)))
a6030 1

@


1.6
log
@Update to xserver 1.11.2
@
text
@d1359 1
a1359 1
        if (!DevHasCursor(pDev))
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d78 1
a78 1
 * Copyright  2003-2005 Sun Microsystems, Inc.  All rights reserved.
d115 1
a141 1
#include "exglobals.h"
d180 17
a196 6
#define CORE_EVENT(event) \
    (!((event)->u.u.type & EXTENSION_EVENT_BASE) && \
      (event)->u.u.type != GenericEvent)
#define XI2_EVENT(event) \
    (((event)->u.u.type == GenericEvent) && \
    ((xGenericEvent*)(event))->extension == IReqCode)
a208 2
#define rClient(obj) (clients[CLIENT_ID((obj)->resource)])

a222 4
static Bool CheckPassiveGrabsOnWindow(WindowPtr pWin,
                                      DeviceIntPtr device,
                                      DeviceEvent *event,
                                      BOOL checkCore);
d266 1
a266 1
#define RootWindow(dev) dev->spriteInfo->sprite->spriteTrace[0]
d342 6
a347 5
static WindowPtr XYToWindow(
    DeviceIntPtr pDev,
    int x,
    int y
);
d360 2
a361 2
 * One set of filters for each device, but only the first layer
 * is initialized. The rest is memcpy'd in InitEvents.
d370 3
a372 1
static Mask filters[MAXDEVICES][128] = {
d409 1
a409 1
}};
d429 2
d433 3
a435 3
    else if (XI2_EVENT(event))
        return (1 << (((xXIDeviceEvent*)event)->evtype % 8));
    ErrorF("[dix] Unknown device type %d. No filter\n", event->u.u.type);
d449 1
a449 1
    if (!inputMasks || !XI2_EVENT(ev))
d460 1
a460 1
static Mask
d463 2
d466 1
a466 1
    if (XI2_EVENT(event))
d468 1
a468 1
        int byte = ((xGenericEvent*)event)->evtype / 8;
d472 1
a472 1
    } else if (CORE_EVENT(event))
d578 1
a578 1
	for (i = 0; i < PanoramiXNumScreens; i++)
d589 1
a589 1
	for(i = 0; i < PanoramiXNumScreens; i++) {
d896 1
a896 1
        RootWindow(pDev) = pSprite->hot.pScreen->root;
d1029 1
a1029 1
    return RootWindow(dev);
a1290 1
    int i;
d1307 10
a1316 22
        w = XYToWindow(replayDev, event->root_x, event->root_y);
	for (i = 0; i < replayDev->spriteInfo->sprite->spriteTraceGood; i++)
	{
	    if (syncEvents.replayWin ==
		replayDev->spriteInfo->sprite->spriteTrace[i])
	    {
		if (!CheckDeviceGrabs(replayDev, event, i+1)) {
		    if (replayDev->focus && !IsPointerEvent((InternalEvent*)event))
			DeliverFocusedEvent(replayDev, (InternalEvent*)event, w);
		    else
			DeliverDeviceEvents(w, (InternalEvent*)event, NullGrab,
                                            NullWindow, replayDev);
		}
		goto playmore;
	    }
	}
	/* must not still be in the same stack */
	if (replayDev->focus && !IsPointerEvent((InternalEvent*)event))
	    DeliverFocusedEvent(replayDev, (InternalEvent*)event, w);
	else
	    DeliverDeviceEvents(w, (InternalEvent*)event, NullGrab,
                                NullWindow, replayDev);
a1317 1
playmore:
d1424 1
a1424 1
    if (!dev->u.master)
d1427 1
a1427 1
    dev->saved_master_id = dev->u.master->id;
d1529 1
a1529 1
	ConfineCursorToWindow(mouse, RootWindow(mouse), FALSE, FALSE);
d1958 189
d2165 3
a2167 1
 * @@return Number of events delivered to various clients.
a2173 2
    int attempt;
    InputClients *other;
a2178 1

d2180 1
a2180 1
    if ((filter == CantBeFiltered) || CORE_EVENT(pEvents))
d2182 3
a2184 4
	/* if nobody ever wants to see this event, skip some work */
	if (filter != CantBeFiltered &&
	    !((wOtherEventMasks(pWin)|pWin->eventMask) & filter))
	    return 0;
d2186 3
a2188 1
        if (IsInterferingGrab(wClient(pWin), pDev, pEvents))
d2190 12
a2201 15

	if (XaceHook(XACE_RECEIVE_ACCESS, wClient(pWin), pWin, pEvents, count))
	    /* do nothing */;
        else if ( (attempt = TryClientEvents(wClient(pWin), pDev, pEvents,
                                             count, pWin->eventMask,
                                             filter, grab)) )
	{
	    if (attempt > 0)
	    {
		deliveries++;
		client = wClient(pWin);
		deliveryMask = pWin->eventMask;
	    } else
		nondeliveries--;
	}
d2207 1
a2207 15
        if (CORE_EVENT(pEvents))
            other = (InputClients *)wOtherClients(pWin);
        else if (XI2_EVENT(pEvents))
        {
            OtherInputMasks *inputMasks = wOtherInputMasks(pWin);
            /* Has any client selected for the event? */
            if (!GetWindowXI2Mask(pDev, pWin, pEvents))
                return 0;
            other = inputMasks->inputClients;
        } else {
            OtherInputMasks *inputMasks = wOtherInputMasks(pWin);
            /* Has any client selected for the event? */
            if (!inputMasks ||
                !(inputMasks->inputEvents[pDev->id] & filter))
                return 0;
d2209 2
a2210 2
            other = inputMasks->inputClients;
        }
d2212 1
a2212 1
        for (; other; other = other->next)
d2214 10
a2223 21
            Mask mask;
            if (IsInterferingGrab(rClient(other), pDev, pEvents))
                continue;

            mask = GetEventMask(pDev, pEvents, other);

            if (XaceHook(XACE_RECEIVE_ACCESS, rClient(other), pWin,
                        pEvents, count))
                /* do nothing */;
            else if ( (attempt = TryClientEvents(rClient(other), pDev,
                            pEvents, count,
                            mask, filter, grab)) )
            {
                if (attempt > 0)
                {
                    deliveries++;
                    client = rClient(other);
                    deliveryMask = mask;
                } else
                    nondeliveries--;
            }
d2226 2
a2227 8
    /*
     * Note that since core events are delivered first, an implicit grab may
     * be activated on a core grab, stopping the XI events.
     */
    if ((type == DeviceButtonPress || type == ButtonPress ||
        ((XI2_EVENT(pEvents) && ((xGenericEvent*)pEvents)->evtype == XI_ButtonPress)))
            && deliveries
            && (!grab))
d2229 28
a2256 2
	GrabRec tempGrab;
        OtherInputMasks *inputMasks;
d2258 2
a2259 17
        memset(&tempGrab, 0, sizeof(GrabRec));
        tempGrab.next = NULL;
	tempGrab.device = pDev;
	tempGrab.resource = client->clientAsMask;
	tempGrab.window = pWin;
	tempGrab.ownerEvents = (deliveryMask & OwnerGrabButtonMask) ? TRUE : FALSE;
	tempGrab.eventMask = deliveryMask;
	tempGrab.keyboardMode = GrabModeAsync;
	tempGrab.pointerMode = GrabModeAsync;
	tempGrab.confineTo = NullWindow;
	tempGrab.cursor = NullCursor;
        tempGrab.type = type;
        if (type == ButtonPress)
            tempGrab.grabtype = GRABTYPE_CORE;
        else if (type == DeviceButtonPress)
            tempGrab.grabtype = GRABTYPE_XI;
        else
d2261 3
a2263 2
            tempGrab.type = ((xGenericEvent*)pEvents)->evtype;
            tempGrab.grabtype = GRABTYPE_XI2;
d2266 1
a2266 3
        /* get the XI and XI2 device mask */
        inputMasks = wOtherInputMasks(pWin);
        tempGrab.deviceMask = (inputMasks) ? inputMasks->inputEvents[pDev->id]: 0;
d2268 4
a2271 16
        if (inputMasks)
            memcpy(tempGrab.xi2mask, inputMasks->xi2mask,
                    sizeof(tempGrab.xi2mask));

	(*pDev->deviceGrab.ActivateGrab)(pDev, &tempGrab,
                                        currentTime, TRUE | ImplicitGrabMask);
    }
    else if ((type == MotionNotify) && deliveries)
	pDev->valuator->motionHintWindow = pWin;
    else
    {
	if ((type == DeviceMotionNotify || type == DeviceButtonPress) &&
	    deliveries)
	    CheckDeviceGrabAndHintWindow (pWin, type,
					  (deviceKeyButtonPointer*) pEvents,
					  grab, client, deliveryMask);
a2272 3
    if (deliveries)
	return deliveries;
    return nondeliveries;
d2349 1
a2349 1
static Window FindChildForEvent(DeviceIntPtr dev, WindowPtr event)
d2351 1
a2351 2
    SpritePtr pSprite = dev->spriteInfo->sprite;
    WindowPtr w = pSprite->spriteTrace[pSprite->spriteTraceGood-1];
d2389 1
a2389 1
    DeviceIntPtr pDev,
d2395 1
a2395 1
    SpritePtr pSprite = pDev->spriteInfo->sprite;
d2398 1
a2398 1
        child = FindChildForEvent(pDev, pWin);
d2400 1
a2400 1
    if (XI2_EVENT(xE))
d2404 14
a2417 9
        if (event->evtype == XI_RawKeyPress ||
            event->evtype == XI_RawKeyRelease ||
            event->evtype == XI_RawButtonPress ||
            event->evtype == XI_RawButtonRelease ||
            event->evtype == XI_RawMotion ||
            event->evtype == XI_DeviceChanged ||
            event->evtype == XI_HierarchyChanged ||
            event->evtype == XI_PropertyEvent)
            return;
d2419 1
a2419 1
        event->root = RootWindow(pDev)->drawable.id;
d2440 1
a2440 1
        XE_KBPTR.root = RootWindow(pDev)->drawable.id;
a2461 11
 * Return masks for EventIsDeliverable.
 * @@defgroup EventIsDeliverable return flags
 * @@{
 */
#define XI_MASK                 (1 << 0) /**< XI mask set on window */
#define CORE_MASK               (1 << 1) /**< Core mask set on window */
#define DONT_PROPAGATE_MASK     (1 << 2) /**< DontPropagate mask set on window */
#define XI2_MASK                (1 << 3) /**< XI2 mask set on window */
/* @@} */

/**
d2471 2
a2472 2
 * @@return Bitmask of ::XI2_MASK, ::XI_MASK, ::CORE_MASK, and
 * ::DONT_PROPAGATE_MASK.
d2474 1
a2474 1
static int
d2493 1
a2493 1
        rc |= XI2_MASK;
d2503 1
a2503 1
        rc |= XI_MASK;
d2508 1
a2508 1
        rc |= DONT_PROPAGATE_MASK;
d2514 1
a2514 1
        rc |= CORE_MASK;
d2518 1
a2518 1
        rc |= DONT_PROPAGATE_MASK;
d2546 1
d2550 1
a2550 2
    xEvent core;
    xEvent *xE = NULL;
d2553 1
a2553 1
    CHECKEVENT(event);
d2560 1
a2560 1
            if (mask & XI2_MASK)
d2568 1
a2568 1
                    FixUpEventFromWindow(dev, xi2, pWin, child, FALSE);
d2580 1
a2580 1
            if (mask & XI_MASK)
d2586 1
a2586 1
                        FixUpEventFromWindow(dev, xE, pWin, child, FALSE);
d2598 1
a2598 1
            if ((mask & CORE_MASK) && IsMaster(dev) && dev->coreEvents)
d2600 1
a2600 1
                rc = EventToCore(event, &core);
d2602 5
a2606 5
                    if (XaceHook(XACE_SEND_ACCESS, NULL, dev, pWin, &core, 1) == Success) {
                        filter = GetEventFilter(dev, &core);
                        FixUpEventFromWindow(dev, &core, pWin, child, FALSE);
                        deliveries = DeliverEventsToWindow(dev, pWin, &core, 1,
                                                           filter, grab);
d2616 1
a2616 1
                (mask & DONT_PROPAGATE_MASK))
d2628 1
a2632 4
#undef XI_MASK
#undef CORE_MASK
#undef DONT_PROPAGATE_MASK

d2650 1
a2650 1
    Mask filter;
a2651 1
    DeviceIntRec dummy;
d2662 36
a2697 5
    filter = GetEventFilter(&dummy, xE);
    if ((filter & SubstructureNotifyMask) && (xE->u.u.type != CreateNotify))
	xE->u.destroyNotify.event = pWin->drawable.id;
    if (filter != StructureAndSubMask)
	return DeliverEventsToWindow(&dummy, pWin, xE, count, filter, NullGrab);
d2731 1
a2731 1
	for(i = 1; i < PanoramiXNumScreens; i++) {
d2754 2
a2755 2
static WindowPtr
XYToWindow(DeviceIntPtr pDev, int x, int y)
a2758 1
    SpritePtr pSprite;
a2759 1
    pSprite = pDev->spriteInfo->sprite;
d2761 1
a2761 1
    pWin = RootWindow(pDev)->firstChild;
d2801 1
a2801 1
    return pSprite->spriteTrace[pSprite->spriteTraceGood-1];
d2817 1
a2817 3
    if (dev->deviceGrab.grab &&
        dev->deviceGrab.fromPassiveGrab &&
        dev->deviceGrab.grab->type == XI_Enter)
d2819 3
a2821 1
        if (dev->deviceGrab.grab->window == win ||
d2839 2
a2840 1
    rc = CheckPassiveGrabsOnWindow(win, dev, &event, FALSE);
d2858 1
a2858 3
    if (dev->deviceGrab.grab &&
        dev->deviceGrab.fromPassiveGrab &&
        dev->deviceGrab.grab->type == XI_Enter)
d2860 3
a2862 1
        if (dev->deviceGrab.grab->window == win ||
d2877 2
a2878 1
    rc = CheckPassiveGrabsOnWindow(win, dev, &event, FALSE);
a2880 1

d2901 1
a2901 1
    CHECKEVENT(ev);
d2935 2
a2936 1
                RootWindow(pDev) = pSprite->hot.pScreen->root;
d2975 1
a2975 1
    newSpriteWin = XYToWindow(pDev, pSprite->hot.x, pSprite->hot.y);
d3011 1
a3011 1
        if (IsMaster(pDev) || !pDev->u.master)
d3141 1
a3141 1
	RootWindow(pDev) = pWin;
d3332 1
a3332 1
    for(i = 1; i < PanoramiXNumScreens; i++) {
d3442 1
a3442 1
        if ((tmp == dev) || (!IsMaster(tmp) && tmp->u.master == dev)) {
d3449 2
a3450 2
    if (dev->u.lastSlave)
        dev = dev->u.lastSlave;
d3539 1
a3539 1
	for(i = 1; i < PanoramiXNumScreens; i++) {
d3551 2
a3552 1
 * If a passive grab is activated, the event will be delivered to the client.
d3558 1
d3561 1
a3561 1
static Bool
d3565 3
a3567 2
    DeviceEvent *event,
    BOOL checkCore)
d3569 1
a3577 3
    if (device->deviceGrab.grab)
        return FALSE;

d3579 1
a3579 1
	return FALSE;
d3582 14
a3597 1
    tempGrab.detail.exact = event->detail.key;
d3605 2
d3621 1
a3621 1
            if (!IsMaster(grab->device) && device->u.master)
d3632 1
a3632 1
        tempGrab.type = GetXI2Type((InternalEvent*)event);
a3636 1
        tempGrab.detail.exact = event->detail.key;
a3638 1
            tempGrab.type = GetXIType((InternalEvent*)event);
d3640 2
a3641 1
            if (GrabMatchesSecond(&tempGrab, grab, FALSE))
d3649 1
a3649 1
            if ((tempGrab.type = GetCoreType((InternalEvent*)event)) &&
d3654 16
a3669 16
        if (match && (!grab->confineTo ||
	     (grab->confineTo->realized &&
				BorderSizeNotEmpty(device, grab->confineTo))))
	{
            int rc, count = 0;
            xEvent *xE = NULL;
            xEvent core;

            event->corestate &= 0x1f00;
            event->corestate |= tempGrab.modifiersDetail.exact & (~0x1f00);
            grabinfo = &device->deviceGrab;
            /* In some cases a passive core grab may exist, but the client
             * already has a core grab on some other device. In this case we
             * must not get the grab, otherwise we may never ungrab the
             * device.
             */
d3671 8
a3678 1
            if (grab->grabtype == GRABTYPE_CORE)
d3680 3
a3682 2
                DeviceIntPtr other;
                BOOL interfering = FALSE;
d3684 9
a3692 8
                /* A passive grab may have been created for a different device
                   than it is assigned to at this point in time.
                   Update the grab's device and modifier device to reflect the
                   current state.
                   Since XGrabDeviceButton requires to specify the
                   modifierDevice explicitly, we don't override this choice.
                   */
                if (tempGrab.type < GenericEvent)
d3694 2
a3695 2
                    grab->device = device;
                    grab->modifierDevice = GetPairedDevice(device);
d3697 4
d3702 10
a3711 17
                for (other = inputInfo.devices; other; other = other->next)
                {
                    GrabPtr othergrab = other->deviceGrab.grab;
                    if (othergrab && othergrab->grabtype == GRABTYPE_CORE &&
                        SameClient(grab, rClient(othergrab)) &&
                        ((IsPointerDevice(grab->device) &&
                         IsPointerDevice(othergrab->device)) ||
                         (IsKeyboardDevice(grab->device) &&
                          IsKeyboardDevice(othergrab->device))))
                    {
                        interfering = TRUE;
                        break;
                    }
                }
                if (interfering)
                    continue;
            }
d3713 8
d3722 4
a3725 1
            if (match & CORE_MATCH)
d3727 9
a3735 11
                rc = EventToCore((InternalEvent*)event, &core);
                if (rc != Success)
                {
                    if (rc != BadMatch)
                        ErrorF("[dix] %s: core conversion failed in CPGFW "
                                "(%d, %d).\n", device->name, event->type, rc);
                    continue;
                }
                xE = &core;
                count = 1;
            } else if (match & XI2_MATCH)
d3737 10
a3746 10
                rc = EventToXI2((InternalEvent*)event, &xE);
                if (rc != Success)
                {
                    if (rc != BadMatch)
                        ErrorF("[dix] %s: XI2 conversion failed in CPGFW "
                                "(%d, %d).\n", device->name, event->type, rc);
                    continue;
                }
                count = 1;
            } else
d3748 4
a3751 8
                rc = EventToXI((InternalEvent*)event, &xE, &count);
                if (rc != Success)
                {
                    if (rc != BadMatch)
                        ErrorF("[dix] %s: XI conversion failed in CPGFW "
                                "(%d, %d).\n", device->name, event->type, rc);
                    continue;
                }
d3753 1
d3755 1
a3755 1
	    (*grabinfo->ActivateGrab)(device, grab, currentTime, TRUE);
d3757 3
a3759 3
            if (xE)
            {
                FixUpEventFromWindow(device, xE, grab->window, None, TRUE);
d3761 5
a3765 4
                TryClientEvents(rClient(grab), device, xE, count,
                                       GetEventFilter(device, xE),
                                       GetEventFilter(device, xE), grab);
            }
d3767 7
a3773 7
	    if (grabinfo->sync.state == FROZEN_NO_EVENT)
	    {
                if (!grabinfo->sync.event)
                    grabinfo->sync.event = calloc(1, sizeof(InternalEvent));
                *grabinfo->sync.event = *event;
		grabinfo->sync.state = FROZEN_WITH_EVENT;
            }
d3775 2
a3776 4
            if (match & (XI_MATCH | XI2_MATCH))
                free(xE); /* on core match xE == &core */
	    return TRUE;
	}
d3778 1
a3778 1
    return FALSE;
d3811 1
a3811 1
CheckDeviceGrabs(DeviceIntPtr device, DeviceEvent *event, int checkFirst)
d3817 1
d3827 12
a3838 1
    i = checkFirst;
d3845 6
a3850 3
	    if (pWin->optional &&
	        CheckPassiveGrabsOnWindow(pWin, device, event, sendCore))
		return TRUE;
d3855 2
a3856 3
	    ((i > checkFirst) &&
             (pWin != device->spriteInfo->sprite->spriteTrace[i-1])))
	    return FALSE;
d3862 6
a3867 3
	if (pWin->optional &&
	    CheckPassiveGrabsOnWindow(pWin, device, event, sendCore))
	    return TRUE;
d3870 4
a3873 1
    return FALSE;
d3893 1
a3893 2
    xEvent core;
    xEvent *xE = NULL, *xi2 = NULL;
d3921 1
a3921 1
        FixUpEventFromWindow(ptr, xi2, focus, None, FALSE);
d3934 1
a3934 1
        FixUpEventFromWindow(ptr, xE, focus, None, FALSE);
d3947 1
a3947 1
        rc = EventToCore(event, &core);
d3949 5
a3953 4
            if (XaceHook(XACE_SEND_ACCESS, NULL, keybd, focus, &core, 1) == Success) {
                FixUpEventFromWindow(keybd, &core, focus, None, FALSE);
                deliveries = DeliverEventsToWindow(keybd, focus, &core, 1,
                                                   GetEventFilter(keybd, &core),
d3962 1
d3974 2
d3977 1
a3977 1
void
d3990 1
d4040 1
a4040 3
            xEvent core;

            rc = EventToCore(event, &core);
d4043 1
a4043 2
                FixUpEventFromWindow(thisDev, &core, grab->window,
                        None, TRUE);
d4045 1
a4045 1
                            grab->window, &core, 1) ||
d4047 1
a4047 1
                            grab->window, &core, 1))
d4049 1
a4049 1
                else if (!IsInterferingGrab(rClient(grab), thisDev, &core))
d4052 2
a4053 2
                            &core, 1, mask,
                            GetEventFilter(thisDev, &core),
d4065 1
a4065 1
                int evtype = ((xGenericEvent*)xi2)->evtype;
d4070 1
a4070 1
                FixUpEventFromWindow(thisDev, xi2, grab->window, None, TRUE);
d4091 1
a4091 2
                FixUpEventFromWindow(thisDev, xi, grab->window,
                        None, TRUE);
d4120 2
a4121 1
	    for (dev = inputInfo.devices; dev; dev = dev->next)
a4122 2
		if (dev == thisDev)
		    continue;
d4142 1
d4145 2
d4439 1
a4439 1
    FixUpEventFromWindow(mouse, &event, pWin, None, FALSE);
d4527 1
a4527 1
    kbd = (IsMaster(mouse) || mouse->u.master) ? GetPairedDevice(mouse) : NULL;
d4539 2
a4540 1
    FixUpEventFromWindow(mouse, (xEvent*)event, pWin, None, FALSE);
d4797 2
a4798 1
            ConfineCursorToWindow(device, RootWindow(device), FALSE, FALSE);
d5127 1
a5127 1
    rep.root = (RootWindow(mouse))->drawable.id;
d5189 1
a5189 4
    /* The mask for pointer motion events may have changed in the last server
     * generation. See comment above definition of filters. */
    filters[0][PointerMotionMask] = MotionNotify;
    for (i = 1; i < MAXDEVICES; i++)
d5191 1
a5191 1
        memcpy(&filters[i], filters[0], sizeof(filters[0]));
d5215 1
a5215 2
    InputEventListLen = GetMaximumEventsNum();
    InputEventList = InitEventList(InputEventListLen);
d5223 1
a5223 2
    FreeEventList(InputEventList, InputEventListLen);
    InputEventListLen = 0;
d5227 2
d5246 10
d5293 1
a5293 1
	    inputFocus = pSprite->spriteTrace[0]; /* Root window! */
d5313 1
a5313 1
    stuff->event.u.u.type |= 0x80;
d5375 1
a5375 1
    tempGrab.modifierDevice = GetPairedDevice(keybd);
d5987 1
a5987 1
        DeviceIntPtr it = inputInfo.devices;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d334 1
a334 1
    return (dev->type == MASTER_POINTER || dev->type == MASTER_KEYBOARD);
d489 7
a502 1
    BoxRec box;
d511 2
a512 2
    x += panoramiXdataPtr[0].x;
    y += panoramiXdataPtr[0].y;
d514 1
a514 2
    if(!POINT_IN_REGION(pScreen, &XineramaScreenRegions[pScreen->myNum],
								x, y, &box))
d520 1
a520 1
	    if(POINT_IN_REGION(pScreen, &XineramaScreenRegions[i], x, y, &box))
d529 4
a532 4
    pSprite->hotPhys.x = x - panoramiXdataPtr[0].x;
    pSprite->hotPhys.y = y - panoramiXdataPtr[0].y;
    x -= panoramiXdataPtr[pScreen->myNum].x;
    y -= panoramiXdataPtr[pScreen->myNum].y;
d550 4
a553 4
    newBox.x1 += panoramiXdataPtr[0].x - panoramiXdataPtr[pScreen->myNum].x;
    newBox.x2 += panoramiXdataPtr[0].x - panoramiXdataPtr[pScreen->myNum].x;
    newBox.y1 += panoramiXdataPtr[0].y - panoramiXdataPtr[pScreen->myNum].y;
    newBox.y2 += panoramiXdataPtr[0].y - panoramiXdataPtr[pScreen->myNum].y;
d564 4
a567 3
    if(pWin == WindowTable[0]) {
	    memcpy(pSprite->windows, WindowTable,
				PanoramiXNumScreens*sizeof(WindowPtr));
d601 1
a601 1
    REGION_COPY(pSprite->screen, &pSprite->Reg1,
d603 2
a604 2
    off_x = panoramiXdataPtr[i].x;
    off_y = panoramiXdataPtr[i].y;
d607 2
a608 2
        x = off_x - panoramiXdataPtr[i].x;
        y = off_y - panoramiXdataPtr[i].y;
d611 1
a611 1
            REGION_TRANSLATE(pSprite->screen, &pSprite->Reg1, x, y);
d613 1
a613 1
        REGION_UNION(pSprite->screen, &pSprite->Reg1, &pSprite->Reg1,
d616 2
a617 2
        off_x = panoramiXdataPtr[i].x;
        off_y = panoramiXdataPtr[i].y;
d620 1
a620 1
    pSprite->hotLimits = *REGION_EXTENTS(pSprite->screen, &pSprite->Reg1);
d622 1
a622 1
    if(REGION_NUM_RECTS(&pSprite->Reg1) > 1)
d628 1
a628 1
    pSprite->confineWin = (pWin == WindowTable[0]) ? NullWindow : pWin;
d674 1
a674 1
    if (POINT_IN_REGION(pSprite->hot.pScreen, shape, x, y, &box))
d676 1
a676 1
    box = *REGION_EXTENTS(pSprite->hot.pScreen, shape);
d698 1
a698 1
    } while (!POINT_IN_REGION(pSprite->hot.pScreen, shape, x, y, &box));
d820 1
a820 1
            REGION_COPY(pSprite->screen, &pSprite->Reg2,
d822 2
a823 2
            off_x = panoramiXdataPtr[i].x;
            off_y = panoramiXdataPtr[i].y;
d826 2
a827 2
                x = off_x - panoramiXdataPtr[i].x;
                y = off_y - panoramiXdataPtr[i].y;
d830 1
a830 1
                    REGION_TRANSLATE(pSprite->screen, &pSprite->Reg2, x, y);
d832 1
a832 1
                REGION_UNION(pSprite->screen, &pSprite->Reg2, &pSprite->Reg2,
d835 2
a836 2
                off_x = panoramiXdataPtr[i].x;
                off_y = panoramiXdataPtr[i].y;
d848 1
a848 1
	lims = *REGION_EXTENTS(pWin->drawable.pScreen, &pWin->borderSize);
d861 1
a861 1
            if (REGION_NUM_RECTS(&pSprite->Reg2) > 1)
d884 1
a884 1
        RootWindow(pDev) = WindowTable[pSprite->hot.pScreen->myNum];
a889 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d905 1
a905 1
	pSprite->hotLimits = *REGION_EXTENTS( pScreen, &pWin->borderSize);
d909 1
a909 1
                        confineToScreen, pScreen);
d1131 1
a1131 1
	    ev->device_event.root = WindowTable[pSprite->hotPhys.pScreen->myNum]->drawable.id;
d1142 2
a1143 4
            event->root_x += panoramiXdataPtr[pSprite->screen->myNum].x -
			      panoramiXdataPtr[0].x;
	    event->root_y += panoramiXdataPtr[pSprite->screen->myNum].y -
			      panoramiXdataPtr[0].y;
d1165 1
a1165 1
    qe = xalloc(sizeof(QdEventRec) + eventlen);
d1223 4
a1226 4
                        ev->root_x += panoramiXdataPtr[0].x -
                            panoramiXdataPtr[pDev->spriteInfo->sprite->screen->myNum].x;
                        ev->root_y += panoramiXdataPtr[0].y -
                            panoramiXdataPtr[pDev->spriteInfo->sprite->screen->myNum].y;
d1235 1
a1235 1
	    xfree(qe);
d1345 1
a1345 1
                        WindowTable[dev->spriteInfo->sprite->hotPhys.pScreen->myNum],
d1375 1
a1375 1
                    WindowTable[pDev->spriteInfo->sprite->hotPhys.pScreen->myNum],
a1413 4
/* Only ever used if a grab is called on an attached slave device. */
static int GrabPrivateKeyIndex;
static DevPrivateKey GrabPrivateKey = &GrabPrivateKeyIndex;

d1415 1
a1415 1
 * Save the device's master device in the devPrivates. This needs to be done
a1425 1
    intptr_t id;
d1429 1
a1429 1
    id = dev->u.master->id;
a1430 1
    dixSetPrivate(&dev->devPrivates, GrabPrivateKey, (void *)id);
a1436 2
    int id;
    void *p;
d1442 1
a1442 4

    p = dixLookupPrivate(&dev->devPrivates, GrabPrivateKey);
    id = (intptr_t) p; /* silence gcc warnings */
    dixLookupDevice(&master, id, serverClient, DixUseAccess);
d1447 1
a1447 1
        dixSetPrivate(&dev->devPrivates, GrabPrivateKey, NULL);
a1846 1
    int i;
a1912 1
                release.u.u.sequenceNumber = client->sequence;
a1932 1
                release.sequenceNumber = client->sequence;
a1945 8
    type &= 0177;
    if (type != KeymapNotify)
    {
        /* all extension events must have a sequence number */
        for (i = 0; i < count; i++)
            pEvents[i].u.u.sequenceNumber = client->sequence;
    }

d2430 1
a2430 1
                    xfree(xi2);
d2487 1
a2487 1
    xfree(xE);
a2552 1
    SpritePtr pSprite = inputInfo.pointer->spriteInfo->sprite;
d2554 1
a2554 1
    if(POINT_IN_REGION(pWin->drawable.pScreen, &pWin->borderSize, x, y, &box))
d2560 1
d2564 4
a2567 5
	   if(POINT_IN_REGION(pSprite->screen,
			&pSprite->windows[i]->borderSize,
			x + panoramiXdataPtr[0].x - panoramiXdataPtr[i].x,
			y + panoramiXdataPtr[0].y - panoramiXdataPtr[i].y,
			&box))
d2611 3
a2613 4
		POINT_IN_REGION(pWin->drawable.pScreen,
				wInputShape(pWin),
				x - pWin->drawable.x,
				y - pWin->drawable.y, &box))
d2626 1
a2626 1
		pSprite->spriteTrace = xrealloc(pSprite->spriteTrace,
d2760 2
a2761 4
            ev->root_x += panoramiXdataPtr[pSprite->screen->myNum].x -
                                       panoramiXdataPtr[0].x;
            ev->root_y += panoramiXdataPtr[pSprite->screen->myNum].y -
                                       panoramiXdataPtr[0].y;
d2768 1
a2768 1
                RootWindow(pDev) = WindowTable[pSprite->hot.pScreen->myNum];
d2851 1
a2851 1
 * that if the 0th screen (i.e., WindowTable[0]) is moved to an origin
d2880 4
a2883 4
            if (REGION_NOTEMPTY(pSprite->screen, &pSprite->Reg1))
                REGION_TRANSLATE(pSprite->screen, &pSprite->Reg1,    xoff, yoff);
            if (REGION_NOTEMPTY(pSprite->screen, &pSprite->Reg2))
                REGION_TRANSLATE(pSprite->screen, &pSprite->Reg2,    xoff, yoff);
d2894 1
a2894 1
                        WindowTable[pSprite->hotPhys.pScreen->myNum],
d2929 1
a2929 1
        pDev->spriteInfo->sprite = (SpritePtr)xcalloc(1, sizeof(SpriteRec));
d2968 1
a2968 1
	pSprite->spriteTrace = (WindowPtr *)xcalloc(1, 32*sizeof(WindowPtr));
d3009 4
a3012 4
        pSprite->hotLimits.x1 = -panoramiXdataPtr[0].x;
        pSprite->hotLimits.y1 = -panoramiXdataPtr[0].y;
        pSprite->hotLimits.x2 = PanoramiXPixWidth  - panoramiXdataPtr[0].x;
        pSprite->hotLimits.y2 = PanoramiXPixHeight - panoramiXdataPtr[0].y;
d3018 2
a3019 2
        REGION_NULL(pScreen, &pSprite->Reg1);
        REGION_NULL(pScreen, &pSprite->Reg2);
d3053 1
a3053 1
    win = WindowTable[pScreen->myNum];
d3079 4
a3082 4
        pSprite->hotLimits.x1 = -panoramiXdataPtr[0].x;
        pSprite->hotLimits.y1 = -panoramiXdataPtr[0].y;
        pSprite->hotLimits.x2 = PanoramiXPixWidth  - panoramiXdataPtr[0].x;
        pSprite->hotLimits.y2 = PanoramiXPixHeight - panoramiXdataPtr[0].y;
d3115 2
a3116 4
	pSprite->hotPhys.x += panoramiXdataPtr[newScreen->myNum].x -
			    panoramiXdataPtr[0].x;
	pSprite->hotPhys.y += panoramiXdataPtr[newScreen->myNum].y -
			    panoramiXdataPtr[0].y;
d3124 1
a3124 1
		XineramaConfineCursorToWindow(pDev, WindowTable[0], TRUE);
d3131 4
a3134 4
		    pSprite->hotPhys.x + panoramiXdataPtr[0].x -
			panoramiXdataPtr[pSprite->screen->myNum].x,
		    pSprite->hotPhys.y + panoramiXdataPtr[0].y -
			panoramiXdataPtr[pSprite->screen->myNum].y, FALSE);
d3139 1
a3139 2
	ConfineCursorToWindow(pDev, WindowTable[newScreen->myNum],
                TRUE, FALSE);
a3150 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d3156 1
a3156 1
    if (POINT_IN_REGION(pScreen, &pWin->borderClip, x, y, &box))
d3161 2
a3162 2
    xoff = x + panoramiXdataPtr[0].x;
    yoff = y + panoramiXdataPtr[0].y;
d3166 2
a3167 3
	pScreen = pWin->drawable.pScreen;
	x = xoff - panoramiXdataPtr[i].x;
	y = yoff - panoramiXdataPtr[i].y;
d3169 1
a3169 1
	if(POINT_IN_REGION(pScreen, &pWin->borderClip, x, y, &box)
d3171 3
a3173 4
	       POINT_IN_REGION(pWin->drawable.pScreen,
			       wInputShape(pWin),
			       x - pWin->drawable.x,
			       y - pWin->drawable.y, &box)))
d3211 3
a3213 3
	if(source == WindowTable[0]) {
	    winX -= panoramiXdataPtr[0].x;
	    winY -= panoramiXdataPtr[0].y;
d3227 3
a3229 3
	if(dest == WindowTable[0]) {
	    x -= panoramiXdataPtr[0].x;
	    y -= panoramiXdataPtr[0].y;
d3364 1
a3364 1
     if(REGION_NOTEMPTY(pDev->spriteInfo->sprite->hotPhys.pScreen, &pWin->borderSize))
d3372 1
a3372 2
	    if(REGION_NOTEMPTY(pDev->spriteInfo->sprite->screen,
                        &pDev->spriteInfo->sprite->windows[i]->borderSize))
d3574 1
a3574 1
                    grabinfo->sync.event = xcalloc(1, sizeof(InternalEvent));
d3580 1
a3580 1
                xfree(xE); /* on core match xE == &core */
d3748 2
a3749 4
    if (xE)
        xfree(xE);
    if (xi2)
        xfree(xi2);
d3923 1
a3923 1
		grabinfo->sync.event = xcalloc(1, sizeof(InternalEvent));
d3929 2
a3930 4
    if (xi)
        xfree(xi);
    if (xi2)
        xfree(xi2);
d3940 1
a3940 7
    int             key, bit;
    BYTE   *kptr;
    KeyClassPtr keyc = keybd->key;

    key = event->detail.key;
    kptr = &keyc->down[key >> 3];
    bit = 1 << (key & 7);
d3948 1
a3948 1
	    *kptr |= bit;
d3950 1
a3950 1
	    *kptr &= ~bit;
d4030 1
a4030 1
	    xfree(other);
d4032 1
a4032 1
	    return(Success);
d4102 1
a4102 1
	others = xalloc(sizeof(OtherClients));
d4255 1
a4255 1
            bzero((char *)&ke.map[0], 31);
d4293 1
a4293 1
    event = xcalloc(1, len);
d4343 1
a4343 1
    xfree(event);
d4365 1
a4365 1
            bzero((char *)&ke.map[0], 31);
d4437 1
a4437 1
	    return(BadMatch);
d4474 1
a4474 1
	    focus->trace = xrealloc(focus->trace,
d4634 1
a4634 1
	    return (rc == BadValue) ? BadCursor : rc;
d4757 1
a4757 1
	    return (rc == BadValue) ? BadCursor : rc;
d4934 2
a4935 2
	rep.rootX += panoramiXdataPtr[0].x;
	rep.rootY += panoramiXdataPtr[0].y;
d4937 2
a4938 2
	    rep.winX += panoramiXdataPtr[0].x;
	    rep.winY += panoramiXdataPtr[0].y;
d4954 1
a4954 1
    return(Success);
d4984 1
a4984 1
	xfree(syncEvents.pending);
d5158 2
a5159 2
	return(BadAlloc);
    return(Success);
a5279 1
	if (!cursor)
d5282 1
a5282 1
	    return (rc == BadValue) ? BadCursor : rc;
d5353 2
a5354 2
	return(BadAlloc);
    return(Success);
d5545 1
a5545 1
	return (rc == BadValue) ? BadCursor : rc;
d5568 1
a5568 1
    return (Success);
d5595 7
d5607 1
a5607 1
       (panoramiXdataPtr[0].x || panoramiXdataPtr[0].y))
d5624 2
a5625 2
	    eventCopy.u.keyButtonPointer.rootX += panoramiXdataPtr[0].x;
	    eventCopy.u.keyButtonPointer.rootY += panoramiXdataPtr[0].y;
d5629 2
a5630 2
		eventCopy.u.keyButtonPointer.eventX += panoramiXdataPtr[0].x;
		eventCopy.u.keyButtonPointer.eventY += panoramiXdataPtr[0].y;
d5676 1
a5676 1
            swapEvent = Xrealloc(swapEvent, swapEventLen);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d77 22
a98 3
/*****************************************************************

Copyright 2003-2005 Sun Microsystems, Inc.
d100 1
a100 30
All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, provided that the above
copyright notice(s) and this permission notice appear in all copies of
the Software and that both the above copyright notice(s) and this
permission notice appear in supporting documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.

******************************************************************/

/** @@file
a109 1
#include <X11/keysym.h>
a111 2
#define NEED_EVENTS
#define NEED_REPLIES
a124 1
#ifdef XKB
d126 1
a126 4
#include <xkbsrv.h>
extern Bool XkbFilterEvents(ClientPtr, int, xEvent *);
#endif

d136 1
d138 1
d152 1
d154 1
d156 1
a156 3
/**
 * Extension events type numbering starts at EXTENSION_EVENT_BASE.
 */
d176 10
a185 1
#define AllEventMasks (lastEventMask|(lastEventMask-1))
a191 7
/*
 * The following relies on the fact that the Button<n>MotionMasks are equal
 * to the corresponding Button<n>Masks from the current modifier/button state.
 */
#define Motion_Filter(class) (PointerMotionMask | \
			      (class)->state | (class)->motionMask)

d200 2
a201 2
_X_EXPORT CallbackListPtr EventCallback;
_X_EXPORT CallbackListPtr DeviceEventCallback;
d208 13
d226 1
a226 2
 *     "core pointer" or inputInfo.pointer. There is exactly one core pointer,
 *     but multiple devices may send core events. The VCP is the first master
d241 12
d254 3
a256 1
_X_EXPORT InputInfo inputInfo;
d259 2
a260 25
 * syncEvents is the global structure for queued events.
 * Devices can be frozen through GrabModeSync pointer grabs. If this is the
 * case, events from these devices are added to "pending" instead of being
 * processed normally. When the device is unfrozen, events in "pending" are
 * replayed and processed as if they would come from the device directly.
 *
 * pending ... list of queued events
 * pendtail ... last event in list
 * replayDev ... The device to replay events for. Only set in AllowEvents, in
 *               which case it is set to the device specified in the request.
 * replayWin ... the window the events are supposed to be replayed on. This
 *               window may be set to the grab's window (but only when
 *               Replay{Pointer|Keyboard} is given in the XAllowEvents
 *               request.
 * playingEvents ... flag to indicate whether we're in the process of
 *                   replaying events. Only set in ComputeFreezes().
 */
static struct {
    QdEventPtr		pending, *pendtail;
    DeviceIntPtr	replayDev;	/* kludgy rock to put flag for */
    WindowPtr		replayWin;	/*   ComputeFreezes            */
    Bool		playingEvents;
    TimeStamp		time;
} syncEvents;

d266 6
d274 1
d277 1
a277 1
_X_EXPORT int
d296 2
a297 2
 * True if device owns a cursor, false if device shares a cursor sprite with
 * another device.
d299 1
a299 1
_X_EXPORT Bool
d306 1
a306 1
 * Return true if a device is a pointer, check is the same as used by XI to
d309 1
a309 1
_X_EXPORT Bool
d312 3
a314 1
    return (dev->valuator && dev->button);
d318 1
a318 1
 * Return true if a device is a keyboard, check is the same as used by XI to
d324 1
a324 1
_X_EXPORT Bool
d327 8
a334 1
    return (dev->key && dev->kbdfeed) && !IsPointerDevice(dev);
a347 2
static Mask lastEventMask;

d350 1
d352 3
a354 1
 * Event filters. One set of filters for each device, but only the first layer
d356 7
a363 1
#define CantBeFiltered NoEventMask
d403 25
d430 1
a430 3
 * same principle as filters, but one set of filters for each extension.
 * The extension is responsible for setting the filters by calling
 * SetGenericFilter().
d432 34
a465 1
static Mask* generic_filters[MAXEXTENSIONS];
d472 13
a487 7
#define SyntheticMotion(dev, x, y) \
    PostSyntheticMotion(dev, x, y, noPanoramiXExtension ? 0 : \
                              dev->spriteInfo->sprite->screen->myNum, \
                        syncEvents.playingEvents ? \
                          syncEvents.time.milliseconds : \
                          currentTime.milliseconds);

a552 43
static void
XineramaCheckPhysLimits(
    DeviceIntPtr pDev,
    CursorPtr cursor,
    Bool generateEvents
){
    HotSpot new;
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    if (!cursor)
	return;

    new = pSprite->hotPhys;

    /* I don't care what the DDX has to say about it */
    pSprite->physLimits = pSprite->hotLimits;

    /* constrain the pointer to those limits */
    if (new.x < pSprite->physLimits.x1)
	new.x = pSprite->physLimits.x1;
    else
	if (new.x >= pSprite->physLimits.x2)
	    new.x = pSprite->physLimits.x2 - 1;
    if (new.y < pSprite->physLimits.y1)
	new.y = pSprite->physLimits.y1;
    else
	if (new.y >= pSprite->physLimits.y2)
	    new.y = pSprite->physLimits.y2 - 1;

    if (pSprite->hotShape)  /* more work if the shape is a mess */
	ConfineToShape(pDev, pSprite->hotShape, &new.x, &new.y);

    if((new.x != pSprite->hotPhys.x) || (new.y != pSprite->hotPhys.y))
    {
	XineramaSetCursorPosition (pDev, new.x, new.y, generateEvents);
	if (!generateEvents)
	    SyntheticMotion(pDev, new.x, new.y);
    }

    /* Tell DDX what the limits are */
    XineramaConstrainCursor(pDev);
}

d564 1
a564 1
	int i;
d566 3
a568 3
	win = (PanoramiXRes*)LookupIDByType(pWin->drawable.id, XRT_WINDOW);

	if(!win)
d572 3
a574 2
	   pSprite->windows[i] = LookupIDByType(win->info[i].id, RT_WINDOW);
	   if(!pSprite->windows[i])  /* window is being unmapped */
a581 146
XineramaCheckVirtualMotion(
   DeviceIntPtr pDev,
   QdEventPtr qe,
   WindowPtr pWin)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    if (qe)
    {
	pSprite->hot.pScreen = qe->pScreen;  /* should always be Screen 0 */
	pSprite->hot.x = qe->event->u.keyButtonPointer.rootX;
	pSprite->hot.y = qe->event->u.keyButtonPointer.rootY;
	pWin = pDev->deviceGrab.grab ? pDev->deviceGrab.grab->confineTo :
					 NullWindow;
    }
    if (pWin)
    {
	int x, y, off_x, off_y, i;
	BoxRec lims;

	if(!XineramaSetWindowPntrs(pDev, pWin))
	    return;

	i = PanoramiXNumScreens - 1;

	REGION_COPY(pSprite->screen, &pSprite->Reg2,
					&pSprite->windows[i]->borderSize);
	off_x = panoramiXdataPtr[i].x;
	off_y = panoramiXdataPtr[i].y;

	while(i--) {
	    x = off_x - panoramiXdataPtr[i].x;
	    y = off_y - panoramiXdataPtr[i].y;

	    if(x || y)
		REGION_TRANSLATE(pSprite->screen, &pSprite->Reg2, x, y);

	    REGION_UNION(pSprite->screen, &pSprite->Reg2, &pSprite->Reg2,
					&pSprite->windows[i]->borderSize);

	    off_x = panoramiXdataPtr[i].x;
	    off_y = panoramiXdataPtr[i].y;
	}

	lims = *REGION_EXTENTS(pSprite->screen, &pSprite->Reg2);

        if (pSprite->hot.x < lims.x1)
            pSprite->hot.x = lims.x1;
        else if (pSprite->hot.x >= lims.x2)
            pSprite->hot.x = lims.x2 - 1;
        if (pSprite->hot.y < lims.y1)
            pSprite->hot.y = lims.y1;
        else if (pSprite->hot.y >= lims.y2)
            pSprite->hot.y = lims.y2 - 1;

	if (REGION_NUM_RECTS(&pSprite->Reg2) > 1)
	    ConfineToShape(pDev, &pSprite->Reg2,
                    &pSprite->hot.x, &pSprite->hot.y);

	if (qe)
	{
	    qe->pScreen = pSprite->hot.pScreen;
	    qe->event->u.keyButtonPointer.rootX = pSprite->hot.x;
	    qe->event->u.keyButtonPointer.rootY = pSprite->hot.y;
	}
    }
}


static Bool
XineramaCheckMotion(xEvent *xE, DeviceIntPtr pDev)
{
    WindowPtr prevSpriteWin;
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    prevSpriteWin = pSprite->win;

    if (xE && !syncEvents.playingEvents)
    {
        /* GetPointerEvents() guarantees that pointer events have the correct
           rootX/Y set already. */
        switch(xE->u.u.type)
        {
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                break;
            default:
                if (xE->u.u.type == DeviceButtonPress ||
                        xE->u.u.type == DeviceButtonRelease ||
                        xE->u.u.type == DeviceMotionNotify)
                    break;
                /* all other events return FALSE */
                return FALSE;
        }

	/* Motion events entering DIX get translated to Screen 0
	   coordinates.  Replayed events have already been
	   translated since they've entered DIX before */
	XE_KBPTR.rootX += panoramiXdataPtr[pSprite->screen->myNum].x -
			  panoramiXdataPtr[0].x;
	XE_KBPTR.rootY += panoramiXdataPtr[pSprite->screen->myNum].y -
			  panoramiXdataPtr[0].y;
	pSprite->hot.x = XE_KBPTR.rootX;
	pSprite->hot.y = XE_KBPTR.rootY;
	if (pSprite->hot.x < pSprite->physLimits.x1)
	    pSprite->hot.x = pSprite->physLimits.x1;
	else if (pSprite->hot.x >= pSprite->physLimits.x2)
	    pSprite->hot.x = pSprite->physLimits.x2 - 1;
	if (pSprite->hot.y < pSprite->physLimits.y1)
	    pSprite->hot.y = pSprite->physLimits.y1;
	else if (pSprite->hot.y >= pSprite->physLimits.y2)
	    pSprite->hot.y = pSprite->physLimits.y2 - 1;

	if (pSprite->hotShape)
	    ConfineToShape(pDev, pSprite->hotShape, &pSprite->hot.x, &pSprite->hot.y);

	pSprite->hotPhys = pSprite->hot;
	if ((pSprite->hotPhys.x != XE_KBPTR.rootX) ||
	    (pSprite->hotPhys.y != XE_KBPTR.rootY))
	{
	    XineramaSetCursorPosition(
			pDev, pSprite->hotPhys.x, pSprite->hotPhys.y, FALSE);
	}
	XE_KBPTR.rootX = pSprite->hot.x;
	XE_KBPTR.rootY = pSprite->hot.y;
    }

    pSprite->win = XYToWindow(pDev, pSprite->hot.x, pSprite->hot.y);

    if (pSprite->win != prevSpriteWin)
    {
	if (prevSpriteWin != NullWindow) {
	    if (!xE)
		UpdateCurrentTimeIf();
            DoEnterLeaveEvents(pDev, prevSpriteWin, pSprite->win,
                               NotifyNormal);
        }
	PostNewCursor(pDev);
        return FALSE;
    }
    return TRUE;
}


static void
d588 1
a588 8
    if (syncEvents.playingEvents)
    {
	XineramaCheckVirtualMotion(pDev, (QdEventPtr)NULL, pWin);
	SyntheticMotion(pDev, pSprite->hot.x, pSprite->hot.y);
    }
    else
    {
	int x, y, off_x, off_y, i;
d590 2
a591 2
	if(!XineramaSetWindowPntrs(pDev, pWin))
	    return;
d593 1
a593 1
	i = PanoramiXNumScreens - 1;
d595 4
a598 4
	REGION_COPY(pSprite->screen, &pSprite->Reg1,
					&pSprite->windows[i]->borderSize);
	off_x = panoramiXdataPtr[i].x;
	off_y = panoramiXdataPtr[i].y;
d600 3
a602 3
	while(i--) {
	    x = off_x - panoramiXdataPtr[i].x;
	    y = off_y - panoramiXdataPtr[i].y;
d604 2
a605 2
	    if(x || y)
		REGION_TRANSLATE(pSprite->screen, &pSprite->Reg1, x, y);
d607 2
a608 2
	    REGION_UNION(pSprite->screen, &pSprite->Reg1, &pSprite->Reg1,
					&pSprite->windows[i]->borderSize);
d610 3
a612 3
	    off_x = panoramiXdataPtr[i].x;
	    off_y = panoramiXdataPtr[i].y;
	}
d614 1
a614 1
	pSprite->hotLimits = *REGION_EXTENTS(pSprite->screen, &pSprite->Reg1);
d616 4
a619 4
	if(REGION_NUM_RECTS(&pSprite->Reg1) > 1)
	   pSprite->hotShape = &pSprite->Reg1;
	else
	   pSprite->hotShape = NullRegion;
d621 2
a622 13
	pSprite->confined = FALSE;
	pSprite->confineWin = (pWin == WindowTable[0]) ? NullWindow : pWin;

        XineramaCheckPhysLimits(pDev, pSprite->current,
                                generateEvents);
    }
}


static void
XineramaChangeToCursor(DeviceIntPtr pDev, CursorPtr cursor)
{
    SpritePtr pSprite = pDev->spriteInfo->sprite;
d624 1
a624 10
    if (cursor != pSprite->current)
    {
	if ((pSprite->current->bits->xhot != cursor->bits->xhot) ||
		(pSprite->current->bits->yhot != cursor->bits->yhot))
	    XineramaCheckPhysLimits(pDev, cursor, FALSE);
	(*pSprite->screen->DisplayCursor)(pDev, pSprite->screen, cursor);
	FreeCursor(pSprite->current, (Cursor)0);
	pSprite->current = cursor;
	pSprite->current->refcnt++;
    }
a626 8
#else
#define SyntheticMotion(dev, x, y) \
     PostSyntheticMotion(dev, x, y, \
                         0, \
                         syncEvents.playingEvents ? \
                           syncEvents.time.milliseconds : \
                           currentTime.milliseconds);

d629 14
a645 1
    int coretype;
a647 2
    if ((event < LASTEvent) || (event >= 128))
	FatalError("SetMaskForEvent: bogus event number");
a648 5

    /* Need to change the mask for the core events too */
    coretype = XItoCoreType(event);
    if (coretype)
        filters[deviceid][coretype] = mask;
d651 1
a651 1
_X_EXPORT void
d702 2
a703 2
    Bool confineToScreen,
    ScreenPtr pScreen)
d711 4
a714 2
    if (pScreen)
	new.pScreen = pScreen;
d716 13
a728 5
	pScreen = new.pScreen;
    (*pScreen->CursorLimits) (pDev, pScreen, cursor, &pSprite->hotLimits,
			      &pSprite->physLimits);
    pSprite->confined = confineToScreen;
    (* pScreen->ConstrainCursor)(pDev, pScreen, &pSprite->physLimits);
d741 5
a745 1
    if ((pScreen != pSprite->hotPhys.pScreen) ||
d748 11
a758 4
	if (pScreen != pSprite->hotPhys.pScreen)
	    pSprite->hotPhys = new;
        (*pScreen->SetCursorPosition)
            (pDev, pScreen, new.x, new.y, generateEvents);
d760 1
a760 1
	    SyntheticMotion(pDev, new.x, new.y);
d762 6
d777 2
a779 6
#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
	XineramaCheckVirtualMotion(pDev, qe, pWin);
	return;
    }
#endif
d782 18
a799 4
	pSprite->hot.pScreen = qe->pScreen;
	pSprite->hot.x = qe->event->u.keyButtonPointer.rootX;
	pSprite->hot.y = qe->event->u.keyButtonPointer.rootY;
	pWin = pDev->deviceGrab.grab ? pDev->deviceGrab.grab->confineTo : NullWindow;
d805 37
a841 5
	if (pSprite->hot.pScreen != pWin->drawable.pScreen)
	{
	    pSprite->hot.pScreen = pWin->drawable.pScreen;
	    pSprite->hot.x = pSprite->hot.y = 0;
	}
d851 18
a868 4
	if (wBoundingShape(pWin))
	    ConfineToShape(pDev, &pWin->borderSize,
                    &pSprite->hot.x, &pSprite->hot.y);
	if (qe)
d871 2
a872 2
	    qe->event->u.keyButtonPointer.rootX = pSprite->hot.x;
	    qe->event->u.keyButtonPointer.rootY = pSprite->hot.y;
d875 4
a878 1
    RootWindow(pDev) = WindowTable[pSprite->hot.pScreen->myNum];
a886 7
#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
	XineramaConfineCursorToWindow(pDev, pWin, generateEvents);
	return;
    }
#endif

d894 6
d908 1
a908 1
_X_EXPORT Bool
d925 1
a925 7

#ifdef PANORAMIX
    if(!noPanoramiXExtension) {
	XineramaChangeToCursor(pDev, cursor);
	return;
    }
#endif
d933 9
a941 3
        (*pSprite->hotPhys.pScreen->DisplayCursor) (pDev,
                                                   pSprite->hotPhys.pScreen,
                                                   cursor);
d1009 1
a1009 1
_X_EXPORT WindowPtr
d1018 1
a1018 1
_X_EXPORT WindowPtr
d1027 1
a1027 1
_X_EXPORT CursorPtr
d1036 1
a1036 1
_X_EXPORT void
d1045 1
a1045 1
_X_EXPORT int
d1059 1
a1059 1
MonthChangedOrBadTime(xEvent *xE)
d1065 1
a1065 1
    if ((currentTime.milliseconds - XE_KBPTR.time) > TIMESLOP)
d1068 1
a1068 1
	XE_KBPTR.time = currentTime.milliseconds;
d1071 8
a1078 5
#define NoticeTime(xE) { \
    if ((xE)->u.keyButtonPointer.time < currentTime.milliseconds) \
	MonthChangedOrBadTime(xE); \
    currentTime.milliseconds = (xE)->u.keyButtonPointer.time; \
    lastDeviceEventTime = currentTime; }
d1081 1
a1081 1
NoticeEventTime(xEvent *xE)
d1084 1
a1084 1
	NoticeTime(xE);
d1097 1
a1097 1
EnqueueEvent(xEvent *xE, DeviceIntPtr device, int count)
d1103 1
d1105 1
a1106 3
    NoticeTime(xE);

#ifdef XKB
d1109 2
a1110 3
	(xE->u.u.type == KeyRelease || xE->u.u.type == DeviceKeyRelease))
	AccessXCancelRepeatKey(device->key->xkbInfo, xE->u.u.detail);
#endif
d1115 1
d1125 5
a1129 5
	if (xE->u.u.type == DeviceMotionNotify)
	    XE_KBPTR.root =
		WindowTable[pSprite->hotPhys.pScreen->myNum]->drawable.id;
	eventinfo.events = xE;
	eventinfo.count = count;
d1132 2
a1133 1
    if (xE->u.u.type == DeviceMotionNotify)
d1137 1
a1137 1
	    XE_KBPTR.rootX += panoramiXdataPtr[pSprite->screen->myNum].x -
d1139 1
a1139 1
	    XE_KBPTR.rootY += panoramiXdataPtr[pSprite->screen->myNum].y -
d1143 2
a1144 2
	pSprite->hotPhys.x = XE_KBPTR.rootX;
	pSprite->hotPhys.y = XE_KBPTR.rootY;
d1147 1
a1147 1
	    (tail->event->u.u.type == DeviceMotionNotify) &&
d1151 4
a1154 3
	    tail->event->u.keyButtonPointer.rootX = pSprite->hotPhys.x;
	    tail->event->u.keyButtonPointer.rootY = pSprite->hotPhys.y;
	    tail->event->u.keyButtonPointer.time = XE_KBPTR.time;
d1160 1
a1160 3
    eventlen = count * sizeof(xEvent);
    if (xE->u.u.type == GenericEvent) /* count is 1 for GenericEvents */
	eventlen += ((xGenericEvent*)xE)->length * 4;
d1162 1
a1162 1
    qe = (QdEventPtr)xalloc(sizeof(QdEventRec) + eventlen);
d1169 2
a1170 13
    qe->event = (xEvent *)(qe + 1);
    qe->evcount = count;
    if (xE->u.u.type == GenericEvent)
    {
	memcpy(qe->event, xE, eventlen);
    } else
    {
	xEvent	*qxE;
	for (qxE = qe->event; --count >= 0; qxE++, xE++)
	{
	    *qxE = *xE;
	}
    }
a1190 1
    static CARD32 lastKnownMillis = 0; /* Hack, see comment below */
d1201 1
a1201 1
	    if (qe->event->u.u.type == DeviceMotionNotify)
d1204 1
a1204 11
            /* XXX: Hack! We can't reliably get the time from GenericEvents,
               since we don't know which struct it may be. So we store the time
               when we know it, and re-use it when we can't get it. */
            if (qe->event->u.u.type == GenericEvent)
            {
                syncEvents.time.milliseconds = lastKnownMillis;
            } else
            {
                syncEvents.time.milliseconds = qe->event->u.keyButtonPointer.time;
                lastKnownMillis = syncEvents.time.milliseconds;
            }
a1208 1
            /* XXX: we can't do that for generic events */
d1210 19
a1228 6
		qe->event->u.keyButtonPointer.rootX +=
			panoramiXdataPtr[0].x -
			panoramiXdataPtr[pDev->spriteInfo->sprite->screen->myNum].x;
		qe->event->u.keyButtonPointer.rootY +=
			panoramiXdataPtr[0].y -
			panoramiXdataPtr[pDev->spriteInfo->sprite->screen->myNum].y;
d1231 1
a1231 2
	    (*qe->device->public.processInputProc)(qe->event, qe->device,
						   qe->evcount);
a1270 3
 *
 * Since the events in the EQ are always XI events, we need to emulate core
 * events here.
a1277 2
    xEvent *xE;
    int count;
d1289 2
a1290 2
	xE = replayDev->deviceGrab.sync.event;
	count = replayDev->deviceGrab.sync.evcount;
d1293 1
a1293 1
        w = XYToWindow(replayDev, XE_KBPTR.rootX, XE_KBPTR.rootY);
d1299 3
a1301 3
		if (!CheckDeviceGrabs(replayDev, xE, i+1, count)) {
		    if (replayDev->focus && !IsPointerEvent(xE))
			DeliverFocusedEvent(replayDev, xE, w, count);
d1303 2
a1304 2
			DeliverDeviceEvents(w, xE, NullGrab, NullWindow,
					        replayDev, count);
d1310 2
a1311 2
	if (replayDev->focus && !IsPointerEvent(xE))
	    DeliverFocusedEvent(replayDev, xE, w, count);
d1313 2
a1314 1
	    DeliverDeviceEvents(w, xE, NullGrab, NullWindow, replayDev, count);
d1395 1
a1395 6
    /*
        XXX: Direct slave grab won't freeze the paired master device.
        The correct thing to do would be to freeze all SDs attached to the
        paired master device.
     */
    if (thisDev->isMaster)
d1411 48
d1484 5
d1497 1
a1497 1
    DoEnterLeaveEvents(mouse, oldWin, grab->window, NotifyGrab);
d1523 2
a1530 7
    /* make sure the potential XGE event mask is freed too*/
    if (grab->genericMasks)
    {
        xfree(grab->genericMasks);
        grab->genericMasks = NULL;
    }

d1536 1
a1536 1
    DoEnterLeaveEvents(mouse, grab->window,
d1544 3
d1561 6
d1574 1
a1574 1
	oldWin = inputInfo.keyboard->focus->win;
d1585 1
d1599 2
a1608 5
    if (grab->genericMasks)
    {
        xfree(grab->genericMasks);
        grab->genericMasks = NULL;
    }
d1617 3
d1627 1
a1627 2
          int newState,
          Bool core)
d1638 1
a1638 1
    othersFrozen = TRUE;
d1654 2
a1655 2
	    if (devgrabinfo->sync.state < FROZEN)
		othersFrozen = FALSE;
a1656 2
	else if (!devgrabinfo->sync.other || !SameClient(devgrabinfo->sync.other, client))
	    othersFrozen = FALSE;
d1731 1
a1731 1
                    devgrabinfo = (core) ? &dev->deviceGrab : &dev->deviceGrab;
d1767 1
a1767 1
	    AllowSome(client, time, mouse, NOT_GRABBED, True);
d1770 1
a1770 1
	    AllowSome(client, time, mouse, FREEZE_NEXT_EVENT, True);
d1773 1
a1773 1
	    AllowSome(client, time, mouse, THAWED, True);
d1776 1
a1776 1
	    AllowSome(client, time, keybd, NOT_GRABBED, True);
d1779 1
a1779 1
	    AllowSome(client, time, keybd, FREEZE_NEXT_EVENT, True);
d1782 1
a1782 1
	    AllowSome(client, time, keybd, THAWED, True);
d1785 1
a1785 1
	    AllowSome(client, time, keybd, FREEZE_BOTH_NEXT_EVENT, True);
d1788 1
a1788 1
	    AllowSome(client, time, keybd, THAWED_BOTH, True);
d1851 1
a1851 1
_X_EXPORT int
d1859 9
a1867 2
    ErrorF("[dix] Event([%d, %d], mask=0x%x), client=%d",
	pEvents->u.u.type, pEvents->u.u.detail, mask, client->index);
d1869 12
a1880 2
    if ((client) && (client != serverClient) && (!client->clientGone) &&
	((filter == CantBeFiltered) || (mask & filter)))
a1881 10
	if (grab && !SameClient(grab, client))
	    return -1; /* don't send, but notify caller */
	type = pEvents->u.u.type;
	if (type == MotionNotify)
	{
	    if (mask & PointerMotionHintMask)
	    {
		if (WID(dev->valuator->motionHintWindow) ==
		    pEvents->u.keyButtonPointer.event)
		{
d1883 1
a1883 2
		    ErrorF("[dix] \n");
	    ErrorF("[dix] motionHintWindow == keyButtonPointer.event\n");
d1885 2
a1886 23
		    return 1; /* don't send, but pretend we did */
		}
		pEvents->u.u.detail = NotifyHint;
	    }
	    else
	    {
		pEvents->u.u.detail = NotifyNormal;
	    }
	}
	else
	{
	    if ((type == DeviceMotionNotify) &&
		MaybeSendDeviceMotionNotifyHint
			((deviceKeyButtonPointer*)pEvents, mask) != 0)
		return 1;
	}
	type &= 0177;
	if (type != KeymapNotify)
	{
	    /* all extension events must have a sequence number */
	    for (i = 0; i < count; i++)
		pEvents[i].u.u.sequenceNumber = client->sequence;
	}
d1888 46
a1933 6
	if (BitIsOn(criticalEvents, type))
	{
	    if (client->smart_priority < SMART_MAX_PRIORITY)
		client->smart_priority++;
	    SetCriticalOutputPending();
	}
d1935 15
a1949 1
	WriteEventsToClient(client, count, pEvents);
d1951 1
a1951 1
	ErrorF("[dix]  delivered\n");
d1953 10
a1962 1
	return 1;
d1964 2
a1965 1
    else
d1967 6
d1974 1
a1974 1
	ErrorF("[dix] \n");
d1976 1
a1976 2
	return 0;
    }
a1995 1
 * @@param mskidx Mask index, depending on device that caused event.
d2001 1
a2001 1
        *pEvents, int count, Mask filter, GrabPtr grab, int mskidx)
d2011 3
a2013 3
    /* CantBeFiltered means only window owner gets the event */
    if ((filter == CantBeFiltered) ||
            (!(type & EXTENSION_EVENT_BASE) && type != GenericEvent))
d2020 1
a2020 2
        if (!(type & EXTENSION_EVENT_BASE) &&
            IsInterferingGrab(wClient(pWin), pDev, pEvents))
d2038 2
d2042 3
a2044 2
        /* Handle generic events */
        if (type == GenericEvent)
d2046 3
a2048 5
            GenericMaskPtr gmask;
            /* We don't do more than one GenericEvent at a time. */
            if (count > 1)
            {
                ErrorF("[dix] Do not send more than one GenericEvent at a time!\n");
d2050 6
a2055 5
            }

            /* if we get here, filter should be set to the GE specific mask.
               check if any client wants it */
            if (!GEDeviceMaskIsSet(pWin, pDev, GEEXT(pEvents), filter))
d2058 1
a2058 18
            /* run through all clients, deliver event */
            for (gmask = GECLIENT(pWin); gmask; gmask = gmask->next)
            {
                if (gmask->eventMask[GEEXTIDX(pEvents)] & filter)
                {
                    if (XaceHook(XACE_RECEIVE_ACCESS, rClient(gmask), pWin,
                                pEvents, count))
                        /* do nothing */;
                    else if (TryClientEvents(rClient(gmask), pDev,
                             pEvents, count,
                             gmask->eventMask[GEEXTIDX(pEvents)],
                             filter, grab) > 0)
                    {
                        deliveries++;
                    } else
                        nondeliveries--;
                }
            }
a2059 5
        else {
            /* Traditional event */
            if (type & EXTENSION_EVENT_BASE)
            {
                OtherInputMasks *inputMasks;
d2061 14
a2074 9
                inputMasks = wOtherInputMasks(pWin);
                if (!inputMasks ||
                        !(inputMasks->inputEvents[mskidx] & filter))
                    return 0;
                other = inputMasks->inputClients;
            }
            else
                other = (InputClients *)wOtherClients(pWin);
            for (; other; other = other->next)
d2076 1
a2076 12
                /* core event? check for grab interference */
                if (!(type & EXTENSION_EVENT_BASE) &&
                        IsInterferingGrab(rClient(other), pDev, pEvents))
                    continue;

                if (XaceHook(XACE_RECEIVE_ACCESS, rClient(other), pWin,
                             pEvents, count))
                    /* do nothing */;
                else if ( (attempt = TryClientEvents(rClient(other), pDev,
                                                     pEvents, count,
                                                     other->mask[mskidx],
                                                     filter, grab)) )
d2078 5
a2082 8
                    if (attempt > 0)
                    {
                        deliveries++;
                        client = rClient(other);
                        deliveryMask = other->mask[mskidx];
                    } else
                        nondeliveries--;
                }
d2090 2
a2091 1
    if ((type == DeviceButtonPress || type == ButtonPress)
d2098 1
d2109 10
a2118 1
        tempGrab.coreGrab = (type == ButtonPress);
d2120 1
a2120 1
        /* get the XI device mask */
d2124 4
a2127 15
        /* get the XGE event mask. */
        tempGrab.genericMasks = NULL;
        if (pWin->optional && pWin->optional->geMasks)
        {
            GenericClientMasksPtr gemasks = pWin->optional->geMasks;
            GenericMaskPtr geclient = gemasks->geClients;
            while(geclient && rClient(geclient) != client)
                geclient = geclient->next;
            if (geclient)
            {
                tempGrab.genericMasks = xcalloc(1, sizeof(GenericMaskRec));
                *tempGrab.genericMasks = *geclient;
                tempGrab.genericMasks->next = NULL;
            }
        }
d2135 2
a2136 5
	if (((type == DeviceMotionNotify)
#ifdef XKB
	     || (type == DeviceButtonPress)
#endif
	    ) && deliveries)
d2220 31
d2259 1
a2259 1
static void
d2264 90
a2353 2
    Window child,
    Bool calcChild)
d2355 5
a2359 17
    SpritePtr pSprite = pDev->spriteInfo->sprite;

    if (xE->u.u.type == GenericEvent) /* just a safety barrier */
        return;

    if (calcChild)
    {
        WindowPtr w= pSprite->spriteTrace[pSprite->spriteTraceGood-1];
	/* If the search ends up past the root should the child field be
		set to none or should the value in the argument be passed
		through. It probably doesn't matter since everyone calls
		this function with child == None anyway. */

        while (w)
        {
            /* If the source window is same as event window, child should be
		none.  Don't bother going all all the way back to the root. */
d2361 36
a2396 5
	    if (w == pWin)
	    {
		child = None;
		break;
	    }
d2398 1
a2398 26
	    if (w->parent == pWin)
	    {
		child = w->drawable.id;
		break;
            }
	    w = w->parent;
        }
    }
    XE_KBPTR.root = RootWindow(pDev)->drawable.id;
    XE_KBPTR.event = pWin->drawable.id;
    if (pSprite->hot.pScreen == pWin->drawable.pScreen)
    {
	XE_KBPTR.sameScreen = xTrue;
	XE_KBPTR.child = child;
	XE_KBPTR.eventX =
	XE_KBPTR.rootX - pWin->drawable.x;
	XE_KBPTR.eventY =
	XE_KBPTR.rootY - pWin->drawable.y;
    }
    else
    {
	XE_KBPTR.sameScreen = xFalse;
	XE_KBPTR.child = None;
	XE_KBPTR.eventX = 0;
	XE_KBPTR.eventY = 0;
    }
d2402 2
a2403 2
 * Deliver events caused by input devices. Called for both core input events
 * and XI events.
d2412 1
a2412 1
 * @@param xE Events to deliver.
a2415 1
 * @@param count number of events in xE.
d2421 2
a2422 2
DeliverDeviceEvents(WindowPtr pWin, xEvent *xE, GrabPtr grab,
                    WindowPtr stopAt, DeviceIntPtr dev, int count)
d2425 1
a2425 2
    int type = xE->u.u.type;
    Mask filter = filters[dev->id][type];
a2426 2
    OtherInputMasks *inputMasks;
    int mskidx = dev->id;
d2428 2
d2431 1
a2431 2
    if (XaceHook(XACE_SEND_ACCESS, NULL, dev, pWin, xE, count))
	return 0;
d2433 1
a2433 5
    /* handle generic events */
    /* XXX: Generic events aren't quite handled correctly yet. They should
     * eventually fit in with the rest of the stuff
     */
    if (type == GenericEvent)
d2435 1
a2435 4
        WindowPtr win = pWin;
        xGenericEvent* ge = (xGenericEvent*)xE;

        if (count > 1)
d2437 19
a2455 4
            ErrorF("[dix] Do not send more than one GenericEvent at a time!\n");
            return 0;
        }
        filter = generic_filters[GEEXTIDX(xE)][ge->evtype];
d2457 2
a2458 3
        while(win)
        {
            if (GEDeviceMaskIsSet(win, dev, GEEXT(xE), filter))
d2460 13
a2472 6
                if (GEExtensions[GEEXTIDX(xE)].evfill)
                    GEExtensions[GEEXTIDX(xE)].evfill(ge, dev, win, grab);
                deliveries = DeliverEventsToWindow(dev, win, xE, count,
                        filter, grab, 0);
                if (deliveries > 0)
                    return deliveries;
d2475 2
a2476 10
            win = win->parent;
        }
    }

    while (pWin && type != GenericEvent)
    {
        if (!dev->isMaster)
        {
            inputMasks = wOtherInputMasks(pWin);
            if (inputMasks && (filter & inputMasks->deliverableEvents[mskidx]))
d2478 13
a2490 9

                if (inputMasks && (inputMasks->inputEvents[mskidx] & filter))
                {
                    FixUpEventFromWindow(dev, xE, pWin, child, FALSE);
                    deliveries = DeliverEventsToWindow(dev, pWin, xE, count,
                            filter, grab, mskidx);
                    if (deliveries > 0)
                        return deliveries;
                }
d2494 1
a2494 8
                    (inputMasks && (filter & inputMasks->dontPropagateMask[mskidx])))
                return 0;
        } else
        {
            core = *xE;
            core.u.u.type = XItoCoreType(xE->u.u.type);

            if (core.u.u.type && filter & pWin->deliverableEvents)
d2496 2
a2497 8
                if ((wOtherEventMasks(pWin)|pWin->eventMask) & filter)
                {
                    FixUpEventFromWindow(dev, &core, pWin, child, FALSE);
                    deliveries = DeliverEventsToWindow(dev, pWin, &core, 1,
                            filter, grab, 0);
                    if (deliveries > 0)
                        return deliveries;
                }
a2498 4

            if ((deliveries < 0) || (pWin == stopAt) ||
                (filter & wDontPropagateMask(pWin)))
                return 0;
d2505 3
a2507 1
    return 0;
d2510 4
d2527 1
a2527 1
_X_EXPORT int
d2533 1
d2542 3
a2544 3
    /* We don't know a device here. However, this should only ever be called
       for a non-device event so we are safe to use 0*/
    filter = filters[0][xE->u.u.type];
d2548 3
a2550 3
	return DeliverEventsToWindow(inputInfo.pointer, pWin, xE, count, filter, NullGrab, 0);
    deliveries = DeliverEventsToWindow(inputInfo.pointer, pWin, xE, count, StructureNotifyMask,
				       NullGrab, 0);
d2554 2
a2555 3
	deliveries += DeliverEventsToWindow(inputInfo.pointer, pWin->parent, xE, count,
					    SubstructureNotifyMask, NullGrab,
					    0);
d2559 1
a2559 1
            deliveries += DeliverEventsToWindow(inputInfo.pointer,
d2561 1
a2561 1
						NullGrab, 0);
d2660 79
d2750 1
a2750 1
CheckMotion(xEvent *xE, DeviceIntPtr pDev)
d2752 1
a2752 2
    INT16     *rootX, *rootY;
    WindowPtr prevSpriteWin;
d2755 2
d2759 1
a2759 6
#ifdef PANORAMIX
    if(!noPanoramiXExtension)
	return XineramaCheckMotion(xE, pDev);
#endif

    if (xE && !syncEvents.playingEvents)
d2763 1
a2763 1
        switch(xE->u.u.type)
d2765 3
a2767 5
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                rootX = &XE_KBPTR.rootX;
                rootY = &XE_KBPTR.rootY;
a2769 8
                if (xE->u.u.type == DeviceButtonPress ||
                        xE->u.u.type == DeviceButtonRelease ||
                        xE->u.u.type == DeviceMotionNotify)
                {
                    rootX = &((deviceKeyButtonPointer*)xE)->root_x;
                    rootY = &((deviceKeyButtonPointer*)xE)->root_y;
                    break;
                }
d2774 3
a2776 1
        if (pSprite->hot.pScreen != pSprite->hotPhys.pScreen)
d2778 15
a2792 2
            pSprite->hot.pScreen = pSprite->hotPhys.pScreen;
            RootWindow(pDev) = WindowTable[pSprite->hot.pScreen->myNum];
d2794 3
a2796 2
        pSprite->hot.x = *rootX;
        pSprite->hot.y = *rootY;
d2809 2
a2810 2
	if ((pSprite->hotPhys.x != *rootX) ||
	    (pSprite->hotPhys.y != *rootY))
d2812 12
a2823 3
	    (*pSprite->hotPhys.pScreen->SetCursorPosition)(
                pDev, pSprite->hotPhys.pScreen,
		pSprite->hotPhys.x, pSprite->hotPhys.y, FALSE);
d2826 2
a2827 2
	*rootX = pSprite->hot.x;
	*rootY = pSprite->hot.y;
d2830 3
a2832 10
    pSprite->win = XYToWindow(pDev, pSprite->hot.x, pSprite->hot.y);
#ifdef notyet
    if (!(pSprite->win->deliverableEvents &
	  Motion_Filter(pDev->button))
	!syncEvents.playingEvents)
    {
	/* XXX Do PointerNonInterestBox here */
    }
#endif
    if (pSprite->win != prevSpriteWin)
d2834 7
d2842 3
a2844 4
	    if (!xE)
		UpdateCurrentTimeIf();
            DoEnterLeaveEvents(pDev, prevSpriteWin, pSprite->win,
                               NotifyNormal);
d2846 5
a2850 1
	PostNewCursor(pDev);
d2866 1
a2866 1
        if (pDev->isMaster || !pDev->u.master)
a2926 11
 * Called from main() with the root window on the first screen. Used to do a
 * lot more when MPX wasn't around yet. Things change.
 *
 * Should delete this now? -ds
 */
void
DefineInitialRootWindow(WindowPtr win)
{
}

/**
d2946 1
d2990 1
a2990 2
        pSprite->current = wCursor(pWin);
        pSprite->current->refcnt++;
d3003 1
a3003 1
        pSprite->current = NullCursor;
d3010 5
d3067 1
d3083 6
a3088 2
    pSprite->current = wCursor (win);
    pSprite->current->refcnt++;
d3129 1
a3129 1
_X_EXPORT void
d3294 1
a3294 1
    DeviceIntPtr dev;
d3300 4
a3303 3
    /* XXX XACE ??*/
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev->coreEvents || dev == inputInfo.pointer) && dev->button) {
a3309 1
    dev = PickPointer(client);
d3417 2
a3418 4
 * @@param xE List of events (multiple ones for DeviceMotionNotify)
 * @@param count number of elements in xE.
 * @@param store The event that will be stored on the device (always XI)
 * @@param scount number of elements in store.
d3425 2
a3426 4
    xEvent *xE,
    int count,
    xEvent *store,
    int scount)
d3431 7
a3437 1
    xEvent *dxE;
d3441 2
d3445 1
a3445 2
    tempGrab.type = xE->u.u.type;
    tempGrab.detail.exact = xE->u.u.detail;
a3450 1
#ifdef XKB
d3455 1
a3455 1
        if (grab->coreGrab)
d3461 8
d3470 2
a3473 1
#endif
d3475 27
a3501 22
	if ((device == grab->modifierDevice) &&
	    ((xE->u.u.type == KeyPress) || (xE->u.u.type == DeviceKeyPress)))
	    tempGrab.modifiersDetail.exact =
#ifdef XKB
                (noXkbExtension) ?
                        ((gdev) ? gdev->key->prev_state : 0) :
                        ((xkbi) ?  xkbi->state.grab_mods : 0);
#else
                (gdev) ? gdev->key->prev_state : 0;
#endif
	else
	    tempGrab.modifiersDetail.exact =
#ifdef XKB
                (noXkbExtension) ?
                        ((gdev) ? gdev->key->state : 0) :
                        ((xkbi) ? xkbi->state.grab_mods : 0);
#else
                (gdev) ? gdev->key->state : 0;
#endif
            /* ignore the device for core events when comparing grabs */
	if (GrabMatchesSecond(&tempGrab, grab, (xE->u.u.type < LASTEvent)) &&
	    (!grab->confineTo ||
d3505 6
a3510 7
#ifdef XKB
	    if (!noXkbExtension) {
		XE_KBPTR.state &= 0x1f00;
		XE_KBPTR.state |=
				tempGrab.modifiersDetail.exact&(~0x1f00);
	    }
#endif
a3511 13
            /* A passive grab may have been created for a different device
               than it is assigned to at this point in time.
               Update the grab's device and modifier device to reflect the
               current state.
               Since XGrabDeviceButton requires to specify the
               modifierDevice explicitly, we don't override this choice.
             */
            if (xE->u.u.type < LASTEvent)
            {
                grab->device = device;
                grab->modifierDevice = GetPairedDevice(device);
            }

d3518 1
a3518 1
            if (grab->coreGrab)
d3522 14
d3539 1
a3539 1
                    if (othergrab && othergrab->coreGrab &&
d3555 35
d3592 3
a3594 1
	    FixUpEventFromWindow(device, xE, grab->window, None, TRUE);
d3596 4
a3599 3
	    (void) TryClientEvents(rClient(grab), device, xE, count,
				   filters[device->id][xE->u.u.type],
				   filters[device->id][xE->u.u.type],  grab);
d3603 3
a3605 9
		if (grabinfo->sync.evcount < scount)
		{
		    grabinfo->sync.event = xrealloc(grabinfo->sync.event,
						    scount * sizeof(xEvent));
		}
		grabinfo->sync.evcount = scount;
                /* we always store the XI event, never the core event */
		for (dxE = grabinfo->sync.event; --scount >= 0; dxE++, store++)
		    *dxE = *store;
d3608 3
d3615 3
d3647 1
a3647 2
CheckDeviceGrabs(DeviceIntPtr device, xEvent *xE,
                 int checkFirst, int count)
d3651 2
a3652 7
    FocusClassPtr focus = IsPointerEvent(xE) ? NULL : device->focus;
    xEvent core;
    BOOL sendCore = (device->isMaster && device->coreEvents);

    if ((xE->u.u.type == DeviceButtonPress)
            && (device->button->buttonsDown != 1))
	return FALSE;
d3654 2
a3655 3
    if (xE->u.u.type < EXTENSION_EVENT_BASE)
    {
        ErrorF("[dix] Core event passed into CheckDeviceGrabs.\n");
a3656 1
    }
d3658 3
a3660 8

    if (sendCore)
    {
        core = *xE;
        core.u.u.type = XItoCoreType(xE->u.u.type);
        if(!core.u.u.type) /* probably a Proximity event, can't grab for those */
            return FALSE;
    }
a3668 1
            /* XI grabs have precendence */
d3670 1
a3670 3
	       (CheckPassiveGrabsOnWindow(pWin, device, xE, count, xE, count)
                || (sendCore && CheckPassiveGrabsOnWindow(pWin, device, &core,
                        1, xE, count))))
d3685 1
a3685 3
	    (CheckPassiveGrabsOnWindow(pWin, device, xE, count, xE, count) ||
             (sendCore && CheckPassiveGrabsOnWindow(pWin, device, &core, 1,
                                                    xE, count))))
d3694 4
a3697 2
 * focus. Event is delivered to the keyboard's focus window, the root window
 * or to the window owning the input focus.
d3700 1
a3700 1
 * @@param xE The event list.
a3701 1
 * @@param count number of events in xE.
d3704 1
a3704 1
DeliverFocusedEvent(DeviceIntPtr keybd, xEvent *xE, WindowPtr window, int count)
d3706 1
a3706 1
    DeviceIntPtr pointer;
d3708 1
a3708 1
    BOOL sendCore = (keybd->isMaster && keybd->coreEvents);
d3710 2
d3720 1
a3720 1
	DeliverDeviceEvents(window, xE, NullGrab, NullWindow, keybd, count);
d3725 1
a3725 1
	if (DeliverDeviceEvents(window, xE, NullGrab, focus, keybd, count))
a3727 3
    pointer = GetPairedDevice(keybd);
    if (XaceHook(XACE_SEND_ACCESS, NULL, keybd, focus, xE, count))
	return;
d3729 2
a3730 5
    if (sendCore)
    {
        core = *xE;
        core.u.u.type = XItoCoreType(xE->u.u.type);
    }
a3731 5
    /* just deliver it to the focus window */
    FixUpEventFromWindow(pointer, xE, focus, None, FALSE);
    deliveries = DeliverEventsToWindow(keybd, focus, xE, count,
                                       filters[keybd->id][xE->u.u.type],
                                       NullGrab, keybd->id);
d3733 28
a3760 2
    if (deliveries > 0)
        return;
d3762 1
a3762 1
    if (sendCore && core.u.u.type)
d3764 11
a3774 4
        FixUpEventFromWindow(keybd, &core, focus, None, FALSE);
        deliveries = DeliverEventsToWindow(keybd, focus, &core, 1,
                                           filters[keybd->id][xE->u.u.type],
                                           NullGrab, 0);
d3776 7
d3793 2
a3794 2
DeliverGrabbedEvent(xEvent *xE, DeviceIntPtr thisDev,
                    Bool deactivateGrab, int count)
a3799 1
    xEvent *dxE, core;
d3802 3
d3817 1
a3817 6
        if (xE->u.u.type == DeviceButtonPress ||
                xE->u.u.type == DeviceButtonRelease ||
                xE->u.u.type == DeviceMotionNotify ||
                xE->u.u.type == ProximityIn ||
                xE->u.u.type == ProximityOut)
        {
d3819 1
a3819 1
        } else if (thisDev->focus)
d3828 2
a3829 2
	    deliveries = DeliverDeviceEvents(pSprite->win, xE, grab,
                                             NullWindow, thisDev, count);
d3832 2
a3833 2
	    deliveries = DeliverDeviceEvents(pSprite->win, xE, grab, focus,
					     thisDev, count);
d3835 2
a3836 2
	    deliveries = DeliverDeviceEvents(focus, xE, grab, focus,
					     thisDev, count);
d3840 13
d3854 1
a3854 1
            Mask mask = grab->eventMask;
d3856 2
a3857 1
            if (thisDev->isMaster)
d3859 13
a3871 18
                core = *xE;
                core.u.u.type = XItoCoreType(xE->u.u.type);
                if(core.u.u.type) {
                    FixUpEventFromWindow(thisDev, &core, grab->window,
                            None, TRUE);
                    if (XaceHook(XACE_SEND_ACCESS, 0, thisDev,
                                grab->window, &core, 1) ||
                            XaceHook(XACE_RECEIVE_ACCESS, rClient(grab),
                                grab->window, &core, 1))
                        deliveries = 1; /* don't send, but pretend we did */
                    else if (!IsInterferingGrab(rClient(grab), thisDev,
                                &core))
                    {
                        deliveries = TryClientEvents(rClient(grab), thisDev,
                                &core, 1, mask,
                                filters[thisDev->id][core.u.u.type],
                                grab);
                    }
d3873 27
a3899 1
            } else
d3903 1
a3903 2
                        grabinfo->implicitGrab &&
                        (xE->u.u.type & EXTENSION_EVENT_BASE))
d3905 4
a3908 1
                FixUpEventFromWindow(thisDev, xE, grab->window,
d3912 1
a3912 1
                            grab->window, xE, count) ||
d3914 1
a3914 1
                            grab->window, xE, count))
d3920 1
a3920 1
                                xE, count,
d3922 1
a3922 1
                                filters[thisDev->id][xE->u.u.type],
d3925 4
d3930 1
a3930 4
            }
        }
        if (deliveries && (xE->u.u.type == MotionNotify
                    || xE->u.u.type == DeviceMotionNotify))
d3933 1
a3933 2
    if (deliveries && !deactivateGrab &&
       (xE->u.u.type != MotionNotify && xE->u.u.type != DeviceMotionNotify))
d3943 1
a3943 1
		if ((grabinfo->sync.state == FREEZE_BOTH_NEXT_EVENT) &&
d3945 2
a3946 2
		     CLIENT_BITS(grab->resource)))
		    grabinfo->sync.state = FROZEN_NO_EVENT;
d3948 1
a3948 1
		    grabinfo->sync.other = grab;
d3954 3
a3956 79
	    if (grabinfo->sync.evcount < count)
	    {
		grabinfo->sync.event = xrealloc(grabinfo->sync.event,
						count * sizeof(xEvent));
	    }
	    grabinfo->sync.evcount = count;
	    for (dxE = grabinfo->sync.event; --count >= 0; dxE++, xE++)
		*dxE = *xE;
	    break;
	}
    }
}

/**
 * Main keyboard event processing function for core keyboard events.
 * Updates the events fields from the current pointer state and delivers the
 * event.
 *
 * For key events, xE will always be a single event.
 *
 * @@param xE Event list
 * @@param keybd The device that caused an event.
 * @@param count Number of elements in xE.
 */
void
#ifdef XKB
CoreProcessKeyboardEvent (xEvent *xE, DeviceIntPtr keybd, int count)
#else
ProcessKeyboardEvent (xEvent *xE, DeviceIntPtr keybd, int count)
#endif
{
    int             key, bit;
    BYTE            *kptr;
    CARD8           modifiers;
    GrabPtr         grab;
    GrabInfoPtr     grabinfo;
    Bool            deactivateGrab = FALSE;
    KeyClassPtr     keyc = keybd->key;

    grabinfo = &keybd->deviceGrab;
    grab = grabinfo->grab;

    if (!syncEvents.playingEvents)
    {
	NoticeTime(xE);
	if (DeviceEventCallback)
	{
	    DeviceEventInfoRec eventinfo;
	    eventinfo.events = xE;
	    eventinfo.count = count;
	    CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
	}
    }
    /* ProcessOtherEvent already updated the keyboard's state, so we need to
     * access prev_state here! */
    XE_KBPTR.state = (keyc->prev_state | GetPairedDevice(keybd)->button->state);
    XE_KBPTR.rootX = keybd->spriteInfo->sprite->hot.x;
    XE_KBPTR.rootY = keybd->spriteInfo->sprite->hot.y;
    key = xE->u.u.detail;
    kptr = &keyc->down[key >> 3];
    bit = 1 << (key & 7);
    modifiers = keyc->modifierMap[key];

    switch (xE->u.u.type)
    {
	case KeyPress:
            /* We MUST NOT change the device itself here.  All device state
             * changes must be performed in ProcessOtherEvents. We're dealing
             * with the same device struct, so if we change it in POE and
             * here, we've just screwed up the state by setting it twice.
             *
             * Devices may not send core events but always send XI events, so
             * the state must be changed in POE, not here.
             */
	    if (!grab && CheckDeviceGrabs(keybd, xE, 0, count))
	    {
		grabinfo->activatingKey = key;
		return;
	    }
d3958 1
a3958 9
	case KeyRelease:
	    if (!(*kptr & bit)) /* guard against duplicates */
		return;
            /* No device state changes, see comment for KeyPress */
	    if (grabinfo->fromPassiveGrab && (key == grabinfo->activatingKey))
		deactivateGrab = TRUE;
	    break;
	default:
	    FatalError("Impossible keyboard event");
a3959 6
    if (grab)
	DeliverGrabbedEvent(xE, keybd, deactivateGrab, count);
    else
	DeliverFocusedEvent(keybd, xE, keybd->spriteInfo->sprite->win, count);
    if (deactivateGrab)
        (*grabinfo->DeactivateGrab)(keybd);
d3961 4
a3964 1
    XaceHook(XACE_KEY_AVAIL, xE, keybd, count);
a3966 1
#ifdef XKB
d3972 1
a3972 1
FixKeyState (xEvent *xE, DeviceIntPtr keybd)
d3978 1
a3978 1
    key = xE->u.u.detail;
d3982 1
a3982 3
    if (((xE->u.u.type==KeyPress)||(xE->u.u.type==KeyRelease)||
         (xE->u.u.type==DeviceKeyPress)||(xE->u.u.type==DeviceKeyRelease))
            ) {
d3984 1
a3984 1
               (((xE->u.u.type==KeyPress)||(xE->u.u.type==DeviceKeyPress))?"down":"up"));
d3987 1
a3987 1
    if (xE->u.u.type == KeyPress || xE->u.u.type == DeviceKeyPress)
d3989 1
a3989 1
    else if (xE->u.u.type == KeyRelease || xE->u.u.type == DeviceKeyRelease)
a3993 103
#endif

/**
 * Main pointer event processing function for core pointer events.
 * For motion events: update the sprite.
 * For all other events: Update the event fields based on the current sprite
 * state.
 *
 * For core pointer events, xE will always be a single event.
 *
 * @@param xE Event list
 * @@param mouse The device that caused an event.
 * @@param count Number of elements in xE.
 */
void
#ifdef XKB
CoreProcessPointerEvent (xEvent *xE, DeviceIntPtr mouse, int count)
#else
ProcessPointerEvent (xEvent *xE, DeviceIntPtr mouse, int count)
#endif
{
    GrabPtr	        grab = mouse->deviceGrab.grab;
    Bool                deactivateGrab = FALSE;
    ButtonClassPtr      butc = mouse->button;
    SpritePtr           pSprite = mouse->spriteInfo->sprite;

#ifdef XKB
    XkbSrvInfoPtr xkbi= GetPairedDevice(mouse)->key->xkbInfo;
#endif

    if (!syncEvents.playingEvents)
	NoticeTime(xE)
    XE_KBPTR.state = (butc->state | (
#ifdef XKB
			(noXkbExtension ?
				inputInfo.keyboard->key->state :
				xkbi->state.grab_mods)
#else
			inputInfo.keyboard->key->state
#endif
				    ));
    {
	NoticeTime(xE);
	if (DeviceEventCallback)
	{
	    DeviceEventInfoRec eventinfo;
	    /* see comment in EnqueueEvents regarding the next three lines */
	    if (xE->u.u.type == MotionNotify)
		XE_KBPTR.root =
		    WindowTable[pSprite->hotPhys.pScreen->myNum]->drawable.id;
	    eventinfo.events = xE;
	    eventinfo.count = count;
	    CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
	}
    }
    /* We need to call CheckMotion for each event. It doesn't really give us
       any benefit for relative devices, but absolute devices may not send
       button events to the right position otherwise. */
    if (!CheckMotion(xE, mouse) && xE->u.u.type == MotionNotify)
            return;
    if (xE->u.u.type != MotionNotify)
    {
	int  key;

	XE_KBPTR.rootX = pSprite->hot.x;
	XE_KBPTR.rootY = pSprite->hot.y;

	key = xE->u.u.detail;
	switch (xE->u.u.type)
	{
	case ButtonPress:
            /*
             * We rely on the fact that ButtonMotionMask is the same as
             * DeviceButtonMotionMask, so setting the motionMask
             * to this value ensures correctness for both XI and core events.
             */
	    if (xE->u.u.detail == 0)
		return;
            filters[mouse->id][Motion_Filter(butc)] = MotionNotify;
	    if (!grab)
		if (CheckDeviceGrabs(mouse, xE, 0, count))
		    return;
	    break;
	case ButtonRelease:
	    if (xE->u.u.detail == 0)
		return;
            filters[mouse->id][Motion_Filter(butc)] = MotionNotify;
	    if (!butc->buttonsDown && mouse->deviceGrab.fromPassiveGrab)
		deactivateGrab = TRUE;
	    break;
	default:
	    FatalError("bogus pointer event from ddx. Type %d\n", xE->u.u.type);
	}
    }

    if (grab)
	DeliverGrabbedEvent(xE, mouse, deactivateGrab, count);
    else
	DeliverDeviceEvents(pSprite->win, xE, NullGrab, NullWindow,
			    mouse, count);
    if (deactivateGrab)
        (*mouse->deviceGrab.DeactivateGrab)(mouse);
}
d4008 1
a4008 1
 * otherEventMask.
d4013 1
a4013 2
RecalculateDeliverableEvents(pWin)
    WindowPtr pWin;
d4142 1
a4142 1
	others = (OtherClients *) xalloc(sizeof(OtherClients));
d4256 1
d4268 3
a4270 5
#ifdef XKB
    if (!noXkbExtension) {
        event.u.enterLeave.state = mouse->button->state & 0x1f00;
        if (keybd)
            event.u.enterLeave.state |=
a4271 6
    } else
#endif
    {
        event.u.enterLeave.state = (keybd) ? keybd->key->state : 0;
        event.u.enterLeave.state |= mouse->button->state;
    }
d4279 1
a4279 1
    if ((mask & filters[mouse->id][type]))
d4283 1
a4283 1
                                  filters[mouse->id][type], grab);
d4286 2
a4287 1
                                  filters[mouse->id][type], NullGrab, 0);
d4293 1
a4293 2
        ClientPtr client = grab ? rClient(grab)
            : clients[CLIENT_ID(pWin->drawable.id)];
d4305 75
a4379 1
                                  KeymapStateMask, NullGrab, 0);
d4381 3
d4391 1
d4396 3
a4398 2
    (void)DeliverEventsToWindow(dev, pWin, &event, 1,
            filters[dev->id][type], NullGrab, 0);
d4403 1
a4403 1
        ClientPtr client = clients[CLIENT_ID(pWin->drawable.id)];
d4410 2
a4411 2
        (void)DeliverEventsToWindow(dev, pWin, (xEvent *)&ke, 1,
                KeymapStateMask, NullGrab, 0);
d4489 8
a4496 3
	DoFocusEvents(dev, keybd->focus->win, focusWin, mode);
    else
	DoFocusEvents(dev, focus->win, focusWin, mode);
d4530 1
a4530 2
ProcSetInputFocus(client)
    ClientPtr client;
d4561 1
d4587 3
a4589 2
    WindowPtr pWin, confineTo;
    CursorPtr cursor, oldCursor;
a4591 1
    Mask access_mode = DixGrabAccess;
d4596 1
a4596 17
    if ((stuff->pointerMode != GrabModeSync) &&
	(stuff->pointerMode != GrabModeAsync))
    {
	client->errorValue = stuff->pointerMode;
        return BadValue;
    }
    if ((stuff->keyboardMode != GrabModeSync) &&
	(stuff->keyboardMode != GrabModeAsync))
    {
	client->errorValue = stuff->keyboardMode;
        return BadValue;
    }
    if ((stuff->ownerEvents != xFalse) && (stuff->ownerEvents != xTrue))
    {
	client->errorValue = stuff->ownerEvents;
        return BadValue;
    }
d4602 1
a4602 3
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
	return rc;
d4612 6
a4617 3
    if (stuff->cursor == None)
	cursor = NullCursor;
    else
d4619 3
a4621 8
	rc = dixLookupResourceByType((pointer *)&cursor, stuff->cursor, RT_CURSOR,
			       client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = stuff->cursor;
	    return (rc == BadValue) ? BadCursor : rc;
	}
	access_mode |= DixForceAccess;
d4623 7
a4629 4
    if (stuff->pointerMode == GrabModeSync ||
	stuff->keyboardMode == GrabModeSync)
	access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, device, access_mode);
d4631 4
a4634 1
	return rc;
a4635 1
	/* at this point, some sort of reply is guaranteed. */
a4639 50

    grab = device->deviceGrab.grab;
    /* check for
       1. other client has a grab on the device already.
       2. window is viewable
       3. other client has this device as frozen "other" device
       4. times are screwed.
     */
    if ((grab) && !SameClient(grab, client))
	rep.status = AlreadyGrabbed;
    else if ((!pWin->realized) ||
             (confineTo &&
                !(confineTo->realized
                    && BorderSizeNotEmpty(device, confineTo))))
	rep.status = GrabNotViewable;
    else if (device->deviceGrab.sync.frozen &&
	     device->deviceGrab.sync.other &&
             !SameClient(device->deviceGrab.sync.other, client))
	rep.status = GrabFrozen;
    else if ((CompareTimeStamps(time, currentTime) == LATER) ||
	     (CompareTimeStamps(time, device->deviceGrab.grabTime) == EARLIER))
	rep.status = GrabInvalidTime;
    else
    {
	GrabRec tempGrab;

	oldCursor = NullCursor;
	if (grab)
	{
	    if (grab->confineTo && !confineTo)
		ConfineCursorToWindow(device, RootWindow(device), FALSE, FALSE);
	    oldCursor = grab->cursor;
	}
        tempGrab.next = NULL;
	tempGrab.cursor = cursor;
	tempGrab.resource = client->clientAsMask;
	tempGrab.ownerEvents = stuff->ownerEvents;
	tempGrab.eventMask = stuff->eventMask;
	tempGrab.confineTo = confineTo;
	tempGrab.window = pWin;
	tempGrab.keyboardMode = stuff->keyboardMode;
	tempGrab.pointerMode = stuff->pointerMode;
	tempGrab.device = device;
        tempGrab.coreGrab = True;
        tempGrab.genericMasks = NULL;
	(*device->deviceGrab.ActivateGrab)(device, &tempGrab, time, FALSE);
	if (oldCursor)
	    FreeCursor (oldCursor, (Cursor)0);
	rep.status = GrabSuccess;
    }
d4745 3
a4747 3
           unsigned this_mode, unsigned other_mode, Window grabWindow,
           unsigned ownerEvents, Time ctime, Mask mask, CARD8 *status,
           Bool coreGrab)
d4749 1
a4749 1
    WindowPtr pWin;
d4755 1
d4758 1
a4758 1
    if ((this_mode != GrabModeSync) && (this_mode != GrabModeAsync))
d4760 1
a4760 1
	client->errorValue = this_mode;
d4763 1
a4763 1
    if ((other_mode != GrabModeSync) && (other_mode != GrabModeAsync))
d4765 1
a4765 1
	client->errorValue = other_mode;
d4777 26
a4802 1
    if (this_mode == GrabModeSync || other_mode == GrabModeSync)
d4810 2
d4814 4
a4817 1
    else if (!pWin->realized)
d4836 8
a4843 3
	tempGrab.keyboardMode = this_mode;
	tempGrab.pointerMode = other_mode;
	tempGrab.eventMask = mask;
d4845 3
a4847 4
        tempGrab.cursor = NULL;
        tempGrab.coreGrab = coreGrab;
        tempGrab.genericMasks = NULL;

d4866 1
d4870 7
a4876 4
    result = GrabDevice(client, keyboard, stuff->keyboardMode,
            stuff->pointerMode, stuff->grabWindow,
            stuff->ownerEvents, stuff->time,
            KeyPressMask | KeyReleaseMask, &rep.status, TRUE);
d4908 1
a4908 1
	(grab) && SameClient(grab, client) && grab->coreGrab)
d4925 1
d4935 1
a4935 1
    if (rc != Success)
d4938 2
d4943 1
d4946 2
a4947 1
    rep.mask = mouse->button->state | inputInfo.keyboard->key->state;
d4983 9
d5011 2
a5012 1
    lastEventMask = OwnerGrabButtonMask;
d5049 3
a5051 6
    int len;
    EventListPtr list;

    len = GetEventList(&list);
    while(len--)
        xfree(list[len].event);
d5064 3
a5066 1
    SpritePtr pSprite = PickPointer(client)->spriteInfo->sprite;
d5100 1
a5100 1
	WindowPtr inputFocus = inputInfo.keyboard->focus->win;
d5136 2
a5137 2
            if (DeliverEventsToWindow(PickPointer(client), pWin,
                        &stuff->event, 1, stuff->eventMask, NullGrab, 0))
d5147 2
a5148 2
        (void)DeliverEventsToWindow(PickPointer(client), pWin, &stuff->event,
                                    1, stuff->eventMask, NullGrab, 0);
d5168 1
a5168 1
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
d5172 2
a5173 2
    if (((stuff->key > keybd->key->curKeySyms.maxKeyCode) ||
	 (stuff->key < keybd->key->curKeySyms.minKeyCode))
d5190 1
a5190 1
    tempGrab.modifierDevice = inputInfo.keyboard;
d5192 1
d5216 2
d5220 14
a5233 19
    if ((stuff->ownerEvents != xTrue) && (stuff->ownerEvents != xFalse))
    {
	client->errorValue = stuff->ownerEvents;
	return(BadValue);
    }
    if ((stuff->pointerMode != GrabModeSync) &&
	(stuff->pointerMode != GrabModeAsync))
    {
	client->errorValue = stuff->pointerMode;
        return BadValue;
    }
    if ((stuff->keyboardMode != GrabModeSync) &&
	(stuff->keyboardMode != GrabModeAsync))
    {
	client->errorValue = stuff->keyboardMode;
        return BadValue;
    }
    if (((stuff->key > keybd->key->curKeySyms.maxKeyCode) ||
	 (stuff->key < keybd->key->curKeySyms.minKeyCode))
a5238 6
    if ((stuff->modifiers != AnyModifier) &&
	(stuff->modifiers & ~AllModifiersMask))
    {
	client->errorValue = stuff->modifiers;
	return BadValue;
    }
d5243 5
a5247 5
    grab = CreateGrab(client->index, keybd, pWin,
	(Mask)(KeyPressMask | KeyReleaseMask), (Bool)stuff->ownerEvents,
	(Bool)stuff->keyboardMode, (Bool)stuff->pointerMode,
	keybd, stuff->modifiers, KeyPress, stuff->key,
	NullWindow, NullCursor);
d5269 2
d5337 12
a5348 5
    grab = CreateGrab(client->index, ptr, pWin,
        (Mask)stuff->eventMask, (Bool)stuff->ownerEvents,
        (Bool) stuff->keyboardMode, (Bool)stuff->pointerMode,
        modifierDevice, stuff->modifiers, ButtonPress,
        stuff->button, confineTo, cursor);
d5366 1
d5378 3
d5382 1
a5382 1
    tempGrab.device = PickPointer(client);
d5386 1
a5386 1
    tempGrab.modifierDevice = inputInfo.keyboard;
d5389 1
d5482 1
a5482 1
                                || clients[CLIENT_ID(parent->drawable.id)]->clientGone
d5485 2
a5486 1
                        DoFocusEvents(keybd, pWin, parent, focusEventMode);
d5491 2
a5492 1
                        DoFocusEvents(keybd, pWin, PointerRootWin, focusEventMode);
d5525 1
a5525 1
_X_EXPORT void
d5544 1
a5544 1
                    (*inputInfo.pointer->deviceGrab.DeactivateGrab)(pDev);
d5626 1
a5626 1
_X_EXPORT void
d5636 2
a5637 4
#ifdef XKB
    if ((!noXkbExtension)&&(!XkbFilterEvents(pClient, count, events)))
	return;
#endif
d5728 1
a5728 1
	    (void)WriteToClient(pClient, eventlength, (char *)eventTo);
d5736 1
a5736 1
	(void)WriteToClient(pClient, count * eventlength, (char *) events);
d5741 1
a5741 2
 * Set the client pointer for the given client. Second parameter setter could
 * be used in the future to determine access rights. Unused for now.
d5749 2
a5750 2
_X_EXPORT Bool
SetClientPointer(ClientPtr client, ClientPtr setter, DeviceIntPtr device)
d5752 5
a5756 1
    if (!device->isMaster)
d5759 1
a5759 1
        return FALSE;
d5764 1
a5764 1
        return FALSE;
d5767 1
a5767 1
    return TRUE;
d5777 1
a5777 1
_X_EXPORT DeviceIntPtr
d5787 1
a5787 1
        if (grab && grab->coreGrab && SameClient(grab, client))
d5789 1
a5789 2
            if (!IsPointerDevice(it))
                it = GetPairedDevice(it);
d5799 1
a5799 1
            if (it->isMaster && it->spriteInfo->spriteOwner)
d5814 1
a5814 1
_X_EXPORT DeviceIntPtr
d5818 1
a5818 1
    DeviceIntPtr kbd = ptr->spriteInfo->paired;
a5841 3
    if (dev->deviceGrab.grab && SameClient(dev->deviceGrab.grab, client))
        return FALSE;

d5856 3
a5874 83
}

/**
 * Set the filters for a extension.
 * The filters array needs to contain the Masks that are applicable for each
 * event type for the given extension.
 * e.g. if generic event type 2 should be let through for windows with
 * MyExampleMask set, make sure that filters[2] == MyExampleMask.
 */
_X_EXPORT void
SetGenericFilter(int extension, Mask* filters)
{
    generic_filters[extension & 0x7f] = filters;
}


/**
 * Grab a device for XI events and XGE events.
 * grabmode is used to ungrab a device.
 */
_X_EXPORT int
ExtGrabDevice(ClientPtr client,
              DeviceIntPtr dev,
              int device_mode,
              WindowPtr grabWindow,
              WindowPtr confineTo,
              TimeStamp ctime,
              Bool ownerEvents,
              CursorPtr cursor,
              Mask xi_mask,
              GenericMaskPtr ge_masks)
{
    GrabInfoPtr grabinfo;
    GrabRec     newGrab;

    UpdateCurrentTime();

    grabinfo = &dev->deviceGrab;

    if (grabinfo->grab && !SameClient(grabinfo->grab, client))
        return AlreadyGrabbed;

    if (!grabWindow->realized)
        return GrabNotViewable;

    if ((CompareTimeStamps(ctime, currentTime) == LATER) ||
            (CompareTimeStamps(ctime, grabinfo->grabTime) == EARLIER))
        return GrabInvalidTime;

    if (grabinfo->sync.frozen && grabinfo->sync.other &&
            !SameClient(grabinfo->sync.other, client))
        return GrabFrozen;

    memset(&newGrab, 0, sizeof(GrabRec));
    newGrab.window         = grabWindow;
    newGrab.resource       = client->clientAsMask;
    newGrab.ownerEvents    = ownerEvents;
    newGrab.device         = dev;
    newGrab.cursor         = cursor;
    newGrab.confineTo      = confineTo;
    newGrab.eventMask      = xi_mask;
    newGrab.genericMasks   = NULL;
    newGrab.next           = NULL;

    if (ge_masks)
    {
        newGrab.genericMasks  = xcalloc(1, sizeof(GenericMaskRec));
        *newGrab.genericMasks = *ge_masks;
        newGrab.genericMasks->next = NULL;
    }

    if (IsPointerDevice(dev))
    {
        newGrab.keyboardMode = GrabModeAsync;
        newGrab.pointerMode  = device_mode;
    } else
    {
        newGrab.keyboardMode = device_mode;
        newGrab.pointerMode  = GrabModeAsync;
    }

    (*grabinfo->ActivateGrab)(dev, &newGrab, ctime, FALSE);
    return GrabSuccess;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d30 2
a31 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d33 1
a33 1
both that copyright notice and this permission notice appear in 
d36 1
a36 1
software without specific, written prior permission.  
a151 13
#ifdef XEVIE
extern WindowPtr *WindowTable;
extern int       xevieFlag;
extern int       xevieClientIndex;
extern DeviceIntPtr     xeviemouse;
extern DeviceIntPtr     xeviekb;
extern Mask      xevieMask;
extern Mask      xevieFilters[128];
extern int       xevieEventSent;
extern int       xevieKBEventSent;
int    xeviegrabState = 0;
#endif

d153 1
d162 7
a171 2
#define EXTENSION_EVENT_BASE  64

d192 6
d221 1
d223 2
a224 2
 * Main input device struct. 
 *     inputInfo.pointer 
d227 3
a229 3
 *     but multiple devices may send core events. If a device generates core
 *     events, those events will appear to originate from the core pointer.
 * 
d233 1
a233 1
 * 
d235 1
a235 2
 *     linked list containing all devices including VCK and VCP. The VCK will
 *     always be the first entry, the VCP the second entry in the device list.
d245 18
d271 47
d319 11
a329 46
 * The window trace information is used to avoid having to compute all the
 * windows between the root and the current pointer window each time a button
 * or key goes down. The grabs on each of those windows must be checked.
 * 
 * @@see XYToWindow() for a documentation on how the array is set up.
 */
static WindowPtr *spriteTrace = (WindowPtr *)NULL;
#define ROOT spriteTrace[0]
static int spriteTraceSize = 0;
static int spriteTraceGood;

/**
 * DIX sprite information. This is the sprite as seen from the DIX. It does
 * not represent the actual sprite rendered to the screen.
 * 
 */
static  struct {
    CursorPtr	current;
    BoxRec	hotLimits;	/* logical constraints of hot spot */
    Bool	confined;	/* confined to screen */
#if defined(SHAPE) || defined(PANORAMIX)
    RegionPtr	hotShape;	/* additional logical shape constraint */
#endif
    BoxRec	physLimits;	/* physical constraints of hot spot */
    WindowPtr	win;		/* window of logical position */
    HotSpot	hot;		/* logical pointer position */
    HotSpot	hotPhys;	/* physical pointer position */
#ifdef PANORAMIX
    ScreenPtr	screen;		/* all others are in Screen 0 coordinates */
    RegionRec   Reg1;	        /* Region 1 for confining motion */
    RegionRec   Reg2;		/* Region 2 for confining virtual motion */
    WindowPtr   windows[MAXSCREENS];
    WindowPtr	confineWin;	/* confine window */ 
#endif
} sprite;			/* info about the cursor sprite */

#ifdef XEVIE
_X_EXPORT WindowPtr xeviewin;
_X_EXPORT HotSpot xeviehot;
#endif

static void DoEnterLeaveEvents(
    WindowPtr fromWin,
    WindowPtr toWin,
    int mode
);
d332 1
a343 1
#ifdef XINPUT
a344 1
#endif
d346 4
d351 1
a351 1
static Mask filters[128] =
d388 9
a396 1
};
d400 1
a400 1
    0x7c				/* key and button events */
d404 1
a404 2
static void ConfineToShape(RegionPtr shape, int *px, int *py);
static void PostNewCursor(void);
d406 3
a408 3
#define SyntheticMotion(x, y) \
    PostSyntheticMotion(x, y, noPanoramiXExtension ? 0 : \
                              sprite.screen->myNum, \
d415 3
a417 2
    int x, 
    int y, 
d423 1
d426 1
a426 1
       to send the message too and what the coordinates relative to 
d429 1
a429 1
    pScreen = sprite.screen;
d434 1
a434 1
								x, y, &box)) 
d436 1
a436 1
	FOR_NSCREENS(i) 
d438 1
a438 1
	    if(i == pScreen->myNum) 
d448 3
a450 3
    sprite.screen = pScreen;
    sprite.hotPhys.x = x - panoramiXdataPtr[0].x;
    sprite.hotPhys.y = y - panoramiXdataPtr[0].y;
d454 1
a454 1
    return (*pScreen->SetCursorPosition)(pScreen, x, y, generateEvent);
d459 1
a459 1
XineramaConstrainCursor(void)
d461 6
a466 2
    ScreenPtr pScreen = sprite.screen;
    BoxRec newBox = sprite.physLimits;
d475 1
a475 1
    (* pScreen->ConstrainCursor)(pScreen, &newBox);
d480 1
d485 1
d489 2
a490 2
 
    new = sprite.hotPhys;
d493 1
a493 1
    sprite.physLimits = sprite.hotLimits;
d496 2
a497 2
    if (new.x < sprite.physLimits.x1)
	new.x = sprite.physLimits.x1;
d499 4
a502 4
	if (new.x >= sprite.physLimits.x2)
	    new.x = sprite.physLimits.x2 - 1;
    if (new.y < sprite.physLimits.y1)
	new.y = sprite.physLimits.y1;
d504 2
a505 2
	if (new.y >= sprite.physLimits.y2)
	    new.y = sprite.physLimits.y2 - 1;
d507 2
a508 2
    if (sprite.hotShape)  /* more work if the shape is a mess */
	ConfineToShape(sprite.hotShape, &new.x, &new.y);
d510 1
a510 1
    if((new.x != sprite.hotPhys.x) || (new.y != sprite.hotPhys.y))
d512 1
a512 1
	XineramaSetCursorPosition (new.x, new.y, generateEvents);
d514 1
a514 1
	    SyntheticMotion(new.x, new.y);
d518 1
a518 1
    XineramaConstrainCursor();
d523 1
a523 1
XineramaSetWindowPntrs(WindowPtr pWin)
d525 2
d528 1
a528 1
	    memcpy(sprite.windows, WindowTable, 
d540 2
a541 2
	   sprite.windows[i] = LookupIDByType(win->info[i].id, RT_WINDOW);
	   if(!sprite.windows[i])  /* window is being unmapped */
d550 1
d552 3
a554 2
   WindowPtr pWin
){
d558 4
a561 4
	sprite.hot.pScreen = qe->pScreen;  /* should always be Screen 0 */
	sprite.hot.x = qe->event->u.keyButtonPointer.rootX;
	sprite.hot.y = qe->event->u.keyButtonPointer.rootY;
	pWin = inputInfo.pointer->grab ? inputInfo.pointer->grab->confineTo :
d569 1
a569 1
	if(!XineramaSetWindowPntrs(pWin))
d573 3
a575 3
	
	REGION_COPY(sprite.screen, &sprite.Reg2, 
					&sprite.windows[i]->borderSize); 
d584 4
a587 4
		REGION_TRANSLATE(sprite.screen, &sprite.Reg2, x, y);
		
	    REGION_UNION(sprite.screen, &sprite.Reg2, &sprite.Reg2, 
					&sprite.windows[i]->borderSize);
d593 1
a593 10
	lims = *REGION_EXTENTS(sprite.screen, &sprite.Reg2);

        if (sprite.hot.x < lims.x1)
            sprite.hot.x = lims.x1;
        else if (sprite.hot.x >= lims.x2)
            sprite.hot.x = lims.x2 - 1;
        if (sprite.hot.y < lims.y1)
            sprite.hot.y = lims.y1;
        else if (sprite.hot.y >= lims.y2)
            sprite.hot.y = lims.y2 - 1;
d595 12
a606 2
	if (REGION_NUM_RECTS(&sprite.Reg2) > 1) 
	    ConfineToShape(&sprite.Reg2, &sprite.hot.x, &sprite.hot.y);
d610 3
a612 3
	    qe->pScreen = sprite.hot.pScreen;
	    qe->event->u.keyButtonPointer.rootX = sprite.hot.x;
	    qe->event->u.keyButtonPointer.rootY = sprite.hot.y;
a614 4
#ifdef XEVIE
    xeviehot.x = sprite.hot.x;
    xeviehot.y = sprite.hot.y;
#endif
d619 1
a619 1
XineramaCheckMotion(xEvent *xE)
d621 4
a624 1
    WindowPtr prevSpriteWin = sprite.win;
d628 17
d646 1
a646 1
	   coordinates.  Replayed events have already been 
d648 1
a648 1
	XE_KBPTR.rootX += panoramiXdataPtr[sprite.screen->myNum].x -
d650 1
a650 1
	XE_KBPTR.rootY += panoramiXdataPtr[sprite.screen->myNum].y -
d652 17
a668 17
	sprite.hot.x = XE_KBPTR.rootX;
	sprite.hot.y = XE_KBPTR.rootY;
	if (sprite.hot.x < sprite.physLimits.x1)
	    sprite.hot.x = sprite.physLimits.x1;
	else if (sprite.hot.x >= sprite.physLimits.x2)
	    sprite.hot.x = sprite.physLimits.x2 - 1;
	if (sprite.hot.y < sprite.physLimits.y1)
	    sprite.hot.y = sprite.physLimits.y1;
	else if (sprite.hot.y >= sprite.physLimits.y2)
	    sprite.hot.y = sprite.physLimits.y2 - 1;

	if (sprite.hotShape) 
	    ConfineToShape(sprite.hotShape, &sprite.hot.x, &sprite.hot.y);

	sprite.hotPhys = sprite.hot;
	if ((sprite.hotPhys.x != XE_KBPTR.rootX) ||
	    (sprite.hotPhys.y != XE_KBPTR.rootY))
d671 1
a671 1
			sprite.hotPhys.x, sprite.hotPhys.y, FALSE);
d673 2
a674 2
	XE_KBPTR.rootX = sprite.hot.x;
	XE_KBPTR.rootY = sprite.hot.y;
d677 1
a677 6
#ifdef XEVIE
    xeviehot.x = sprite.hot.x;
    xeviehot.y = sprite.hot.y;
    xeviewin =
#endif
    sprite.win = XYToWindow(sprite.hot.x, sprite.hot.y);
d679 1
a679 1
    if (sprite.win != prevSpriteWin)
d684 4
a687 3
	    DoEnterLeaveEvents(prevSpriteWin, sprite.win, NotifyNormal);
	}
	PostNewCursor();
d695 3
a697 1
XineramaConfineCursorToWindow(WindowPtr pWin, Bool generateEvents)
d699 1
d703 2
a704 2
	XineramaCheckVirtualMotion((QdEventPtr)NULL, pWin);
	SyntheticMotion(sprite.hot.x, sprite.hot.y);
d710 1
a710 1
	if(!XineramaSetWindowPntrs(pWin))
d714 3
a716 3
	
	REGION_COPY(sprite.screen, &sprite.Reg1, 
					&sprite.windows[i]->borderSize); 
d725 4
a728 4
		REGION_TRANSLATE(sprite.screen, &sprite.Reg1, x, y);
		
	    REGION_UNION(sprite.screen, &sprite.Reg1, &sprite.Reg1, 
					&sprite.windows[i]->borderSize);
d734 1
a734 1
	sprite.hotLimits = *REGION_EXTENTS(sprite.screen, &sprite.Reg1);
d736 2
a737 2
	if(REGION_NUM_RECTS(&sprite.Reg1) > 1)
	   sprite.hotShape = &sprite.Reg1;
d739 1
a739 4
	   sprite.hotShape = NullRegion;
	
	sprite.confined = FALSE;
	sprite.confineWin = (pWin == WindowTable[0]) ? NullWindow : pWin;
d741 5
a745 1
	XineramaCheckPhysLimits(sprite.current, generateEvents);
d751 1
a751 1
XineramaChangeToCursor(CursorPtr cursor)
d753 3
a755 1
    if (cursor != sprite.current)
d757 7
a763 7
	if ((sprite.current->bits->xhot != cursor->bits->xhot) ||
		(sprite.current->bits->yhot != cursor->bits->yhot))
	    XineramaCheckPhysLimits(cursor, FALSE);
    	(*sprite.screen->DisplayCursor)(sprite.screen, cursor);
	FreeCursor(sprite.current, (Cursor)0);
	sprite.current = cursor;
	sprite.current->refcnt++;
d768 2
a769 2
#define SyntheticMotion(x, y) \
     PostSyntheticMotion(x, y, \
d778 1
a778 1
SetMaskForEvent(Mask mask, int event)
d780 3
d785 6
a790 1
    filters[event] = mask;
d801 2
a802 3
#ifdef SHAPE
static void
ConfineToShape(RegionPtr shape, int *px, int *py)
d807 1
d809 2
a810 1
    if (POINT_IN_REGION(sprite.hot.pScreen, shape, x, y, &box))
d812 1
a812 1
    box = *REGION_EXTENTS(sprite.hot.pScreen, shape);
d834 1
a834 1
    } while (!POINT_IN_REGION(sprite.hot.pScreen, shape, x, y, &box));
a837 1
#endif
d841 1
d848 1
d852 1
a852 1
    new = sprite.hotPhys;
d857 6
a862 6
    (*pScreen->CursorLimits) (pScreen, cursor, &sprite.hotLimits,
			      &sprite.physLimits);
    sprite.confined = confineToScreen;
    (* pScreen->ConstrainCursor)(pScreen, &sprite.physLimits);
    if (new.x < sprite.physLimits.x1)
	new.x = sprite.physLimits.x1;
d864 4
a867 4
	if (new.x >= sprite.physLimits.x2)
	    new.x = sprite.physLimits.x2 - 1;
    if (new.y < sprite.physLimits.y1)
	new.y = sprite.physLimits.y1;
d869 13
a881 14
	if (new.y >= sprite.physLimits.y2)
	    new.y = sprite.physLimits.y2 - 1;
#ifdef SHAPE
    if (sprite.hotShape)
	ConfineToShape(sprite.hotShape, &new.x, &new.y); 
#endif
    if ((pScreen != sprite.hotPhys.pScreen) ||
	(new.x != sprite.hotPhys.x) || (new.y != sprite.hotPhys.y))
    {
	if (pScreen != sprite.hotPhys.pScreen)
	    sprite.hotPhys = new;
	(*pScreen->SetCursorPosition) (pScreen, new.x, new.y, generateEvents);
	if (!generateEvents)
	    SyntheticMotion(new.x, new.y);
d887 1
d891 2
d895 1
a895 1
	XineramaCheckVirtualMotion(qe, pWin);
d901 4
a904 5
	sprite.hot.pScreen = qe->pScreen;
	sprite.hot.x = qe->event->u.keyButtonPointer.rootX;
	sprite.hot.y = qe->event->u.keyButtonPointer.rootY;
	pWin = inputInfo.pointer->grab ? inputInfo.pointer->grab->confineTo :
					 NullWindow;
d910 1
a910 1
	if (sprite.hot.pScreen != pWin->drawable.pScreen)
d912 2
a913 2
	    sprite.hot.pScreen = pWin->drawable.pScreen;
	    sprite.hot.x = sprite.hot.y = 0;
d916 8
a923 9
	if (sprite.hot.x < lims.x1)
	    sprite.hot.x = lims.x1;
	else if (sprite.hot.x >= lims.x2)
	    sprite.hot.x = lims.x2 - 1;
	if (sprite.hot.y < lims.y1)
	    sprite.hot.y = lims.y1;
	else if (sprite.hot.y >= lims.y2)
	    sprite.hot.y = lims.y2 - 1;
#ifdef SHAPE
d925 2
a926 2
	    ConfineToShape(&pWin->borderSize, &sprite.hot.x, &sprite.hot.y);
#endif
d929 3
a931 3
	    qe->pScreen = sprite.hot.pScreen;
	    qe->event->u.keyButtonPointer.rootX = sprite.hot.x;
	    qe->event->u.keyButtonPointer.rootY = sprite.hot.y;
d934 1
a934 5
#ifdef XEVIE
    xeviehot.x = sprite.hot.x;
    xeviehot.y = sprite.hot.y;
#endif
    ROOT = WindowTable[sprite.hot.pScreen->myNum];
d938 1
a938 1
ConfineCursorToWindow(WindowPtr pWin, Bool generateEvents, Bool confineToScreen)
d941 1
d945 1
a945 1
	XineramaConfineCursorToWindow(pWin, generateEvents);
d947 1
a947 1
    }	
d952 2
a953 2
	CheckVirtualMotion((QdEventPtr)NULL, pWin);
	SyntheticMotion(sprite.hot.x, sprite.hot.y);
d957 2
a958 3
	sprite.hotLimits = *REGION_EXTENTS( pScreen, &pWin->borderSize);
#ifdef SHAPE
	sprite.hotShape = wBoundingShape(pWin) ? &pWin->borderSize
d960 2
a961 3
#endif
	CheckPhysLimits(sprite.current, generateEvents, confineToScreen,
			pScreen);
d966 1
a966 1
PointerConfinedToScreen(void)
d968 1
a968 1
    return sprite.confined;
d979 1
a979 1
ChangeToCursor(CursorPtr cursor)
d981 2
d985 1
a985 1
	XineramaChangeToCursor(cursor);
d990 1
a990 1
    if (cursor != sprite.current)
d992 3
a994 3
	if ((sprite.current->bits->xhot != cursor->bits->xhot) ||
		(sprite.current->bits->yhot != cursor->bits->yhot))
	    CheckPhysLimits(cursor, FALSE, sprite.confined,
d996 6
a1001 5
	(*sprite.hotPhys.pScreen->DisplayCursor) (sprite.hotPhys.pScreen,
						  cursor);
	FreeCursor(sprite.current, (Cursor)0);
	sprite.current = cursor;
	sprite.current->refcnt++;
d1006 1
a1006 1
 * @@returns true if b is a descendent of a 
d1019 1
a1019 1
 * Called whenever a cursor may have changed shape or position.  
d1022 1
a1022 1
PostNewCursor(void)
d1025 3
a1027 1
    GrabPtr grab = inputInfo.pointer->grab;
d1035 1
a1035 1
	    ChangeToCursor(grab->cursor);
d1038 2
a1039 2
	if (IsParent(grab->window, sprite.win))
	    win = sprite.win;
d1044 1
a1044 1
	win = sprite.win;
d1046 11
a1056 4
	if (win->optional && win->optional->cursor != NullCursor)
	{
	    ChangeToCursor(win->optional->cursor);
	    return;
d1058 1
d1061 1
d1063 2
a1064 1
 * @@return root window of current active screen.
d1067 1
a1067 1
GetCurrentRootWindow(void)
d1069 1
a1069 1
    return ROOT;
d1076 1
a1076 1
GetSpriteWindow(void)
d1078 1
a1078 1
    return sprite.win;
d1085 1
a1085 1
GetSpriteCursor(void)
d1087 1
a1087 1
    return sprite.current;
d1094 1
a1094 1
GetSpritePosition(int *px, int *py)
d1096 3
a1098 2
    *px = sprite.hotPhys.x;
    *py = sprite.hotPhys.y;
d1103 1
a1103 1
XineramaGetCursorScreen(void)
d1106 1
a1106 1
	return sprite.screen->myNum;
d1145 5
d1153 5
a1157 3
    QdEventPtr tail = *syncEvents.pendtail;
    QdEventPtr qe;
    xEvent		*qxE;
d1163 2
a1164 2
    if (device->key != NULL && device->key->xkbInfo != NULL && 
	xE->u.u.type == KeyRelease)
d1180 1
a1180 1
	if (xE->u.u.type == MotionNotify)
d1182 1
a1182 1
		WindowTable[sprite.hotPhys.pScreen->myNum]->drawable.id;
d1187 1
a1187 1
    if (xE->u.u.type == MotionNotify)
d1191 1
a1191 1
	    XE_KBPTR.rootX += panoramiXdataPtr[sprite.screen->myNum].x -
d1193 1
a1193 1
	    XE_KBPTR.rootY += panoramiXdataPtr[sprite.screen->myNum].y -
d1197 2
a1198 2
	sprite.hotPhys.x = XE_KBPTR.rootX;
	sprite.hotPhys.y = XE_KBPTR.rootY;
d1201 1
a1201 1
	    (tail->event->u.u.type == MotionNotify) &&
d1203 1
a1203 1
	    (tail->pScreen == sprite.hotPhys.pScreen))
d1205 2
a1206 2
	    tail->event->u.keyButtonPointer.rootX = sprite.hotPhys.x;
	    tail->event->u.keyButtonPointer.rootY = sprite.hotPhys.y;
d1212 6
a1217 1
    qe = (QdEventPtr)xalloc(sizeof(QdEventRec) + (count * sizeof(xEvent)));
d1222 1
a1222 1
    qe->pScreen = sprite.hotPhys.pScreen;
d1226 11
a1236 2
    for (qxE = qe->event; --count >= 0; qxE++, xE++)
	*qxE = *xE;
d1242 9
d1256 2
d1262 1
a1262 1
	if (!qe->device->sync.frozen)
d1265 1
d1268 2
a1269 2
	    if (qe->event->u.u.type == MotionNotify)
		CheckVirtualMotion(qe, NullWindow);
d1271 11
a1281 1
	    syncEvents.time.milliseconds = qe->event->u.keyButtonPointer.time;
d1286 1
d1288 6
a1293 6
		qe->event->u.keyButtonPointer.rootX += 
			panoramiXdataPtr[0].x - 
			panoramiXdataPtr[sprite.screen->myNum].x;
		qe->event->u.keyButtonPointer.rootY += 
			panoramiXdataPtr[0].y - 
			panoramiXdataPtr[sprite.screen->myNum].y;
d1299 1
a1299 1
	    for (dev = inputInfo.devices; dev && dev->sync.frozen; dev = dev->next)
d1309 1
a1309 1
    } 
d1312 8
d1323 1
a1323 1
    dev->sync.frozen = frozen;
d1330 11
d1353 2
a1354 1
	FreezeThaw(dev, dev->sync.other || (dev->sync.state >= FROZEN));
d1360 2
a1361 2
	xE = replayDev->sync.event;
	count = replayDev->sync.evcount;
d1364 2
a1365 2
        w = XYToWindow( XE_KBPTR.rootX, XE_KBPTR.rootY);
	for (i = 0; i < spriteTraceGood; i++)
d1367 2
a1368 1
	    if (syncEvents.replayWin == spriteTrace[i])
d1371 1
a1371 1
		    if (replayDev->focus)
d1381 1
a1381 1
	if (replayDev->focus)
d1389 1
a1389 1
	if (!dev->sync.frozen)
d1396 1
a1396 2
    /* the following may have been skipped during replay, so do it now */
    if ((grab = inputInfo.pointer->grab) && grab->confineTo)
d1398 18
a1415 3
	if (grab->confineTo->drawable.pScreen != sprite.hotPhys.pScreen)
	    sprite.hotPhys.x = sprite.hotPhys.y = 0;
	ConfineCursorToWindow(grab->confineTo, TRUE, TRUE);
a1416 4
    else
	ConfineCursorToWindow(WindowTable[sprite.hotPhys.pScreen->myNum],
			      TRUE, FALSE);
    PostNewCursor();
d1424 1
d1426 1
a1426 1
    if ((grab = inputInfo.pointer->grab) && grab->confineTo)
d1428 16
a1443 3
	if (grab->confineTo->drawable.pScreen != sprite.hotPhys.pScreen)
	    sprite.hotPhys.x = sprite.hotPhys.y = 0;
	ConfineCursorToWindow(grab->confineTo, TRUE, TRUE);
a1444 3
    else
	ConfineCursorToWindow(WindowTable[sprite.hotPhys.pScreen->myNum],
			      TRUE, FALSE);
d1451 1
a1451 1
    GrabPtr grab = thisDev->grab;
d1455 1
a1455 1
	thisDev->sync.state = FROZEN_NO_EVENT;
d1458 3
a1460 3
	thisDev->sync.state = THAWED;
	if (thisDev->sync.other &&
	    (CLIENT_BITS(thisDev->sync.other->resource) ==
d1462 1
a1462 1
	    thisDev->sync.other = NullGrab;
d1464 7
a1470 1
    for (dev = inputInfo.devices; dev; dev = dev->next)
d1472 10
a1481 12
	if (dev != thisDev)
	{
	    if (otherMode == GrabModeSync)
		dev->sync.other = grab;
	    else
	    {	/* free both if same client owns both */
		if (dev->sync.other &&
		    (CLIENT_BITS(dev->sync.other->resource) ==
		     CLIENT_BITS(grab->resource)))
		    dev->sync.other = NullGrab;
	    }
	}
d1488 8
a1495 6
 * core pointer events to be delivered to the grabbing client only. Can cause
 * the cursor to change if a grab cursor is set.
 * 
 * As a pointer grab can only be issued on the core devices, mouse is always
 * inputInfo.pointer. Extension devices are set up for ActivateKeyboardGrab().
 * 
d1499 1
a1499 1
 * explicitely by a client. 
d1502 1
a1502 1
ActivatePointerGrab(DeviceIntPtr mouse, GrabPtr grab, 
d1505 5
a1509 2
    WindowPtr oldWin = (mouse->grab) ? mouse->grab->window
				     : sprite.win;
d1513 5
a1517 3
	if (grab->confineTo->drawable.pScreen != sprite.hotPhys.pScreen)
	    sprite.hotPhys.x = sprite.hotPhys.y = 0;
	ConfineCursorToWindow(grab->confineTo, FALSE, TRUE);
d1519 1
a1519 1
    DoEnterLeaveEvents(oldWin, grab->window, NotifyGrab);
d1522 1
a1522 1
	mouse->grabTime = syncEvents.time;
d1524 1
a1524 1
	mouse->grabTime = time;
d1527 5
a1531 4
    mouse->activeGrab = *grab;
    mouse->grab = &mouse->activeGrab;
    mouse->fromPassiveGrab = autoGrab;
    PostNewCursor();
d1538 1
a1538 2
 * As a pointer grab can only be issued on the core devices, mouse is always
 * inputInfo.pointer. Extension devices are set up for ActivateKeyboardGrab().
d1543 1
a1543 1
    GrabPtr grab = mouse->grab;
d1547 11
a1557 3
    mouse->grab = NullGrab;
    mouse->sync.state = NOT_GRABBED;
    mouse->fromPassiveGrab = FALSE;
d1560 2
a1561 2
	if (dev->sync.other == grab)
	    dev->sync.other = NullGrab;
d1563 2
a1564 1
    DoEnterLeaveEvents(grab->window, sprite.win, NotifyUngrab);
d1566 2
a1567 2
	ConfineCursorToWindow(ROOT, FALSE, FALSE);
    PostNewCursor();
d1570 1
d1575 1
a1575 1
 * Activate a keyboard grab on the given device. 
d1582 1
d1585 2
a1586 2
    if (keybd->grab)
	oldWin = keybd->grab->window;
d1590 1
a1590 1
	oldWin = sprite.win;
d1597 1
a1597 1
	keybd->grabTime = syncEvents.time;
d1599 4
a1602 4
	keybd->grabTime = time;
    keybd->activeGrab = *grab;
    keybd->grab = &keybd->activeGrab;
    keybd->fromPassiveGrab = passive;
d1607 1
a1607 1
 * Delete keyboard grab for the given device. 
d1612 1
a1612 1
    GrabPtr grab = keybd->grab;
d1615 1
a1615 1
					       : sprite.win;
d1621 9
a1629 3
    keybd->grab = NullGrab;
    keybd->sync.state = NOT_GRABBED;
    keybd->fromPassiveGrab = FALSE;
d1632 2
a1633 2
	if (dev->sync.other == grab)
	    dev->sync.other = NullGrab;
d1636 1
d1641 5
a1645 1
AllowSome(ClientPtr client, TimeStamp time, DeviceIntPtr thisDev, int newState)
d1650 2
d1653 1
a1653 1
    thisGrabbed = thisDev->grab && SameClient(thisDev->grab, client);
d1657 1
a1657 1
    grabTime = thisDev->grabTime;
d1660 2
d1664 1
a1664 1
	if (dev->grab && SameClient(dev->grab, client))
d1667 2
a1668 2
		(CompareTimeStamps(dev->grabTime, grabTime) == LATER))
		grabTime = dev->grabTime;
d1670 1
a1670 1
	    if (thisDev->sync.other == dev->grab)
d1672 1
a1672 1
	    if (dev->sync.state < FROZEN)
d1675 1
a1675 1
	else if (!dev->sync.other || !SameClient(dev->sync.other, client))
d1678 1
a1678 1
    if (!((thisGrabbed && thisDev->sync.state >= FROZEN) || thisSynced))
d1685 1
a1685 1
	case THAWED:	 	       /* Async */
d1687 1
a1687 1
		thisDev->sync.state = THAWED;
d1689 1
a1689 1
		thisDev->sync.other = NullGrab;
d1695 1
a1695 1
		thisDev->sync.state = FREEZE_NEXT_EVENT;
d1697 1
a1697 1
		    thisDev->sync.other = NullGrab;
d1706 7
a1712 4
		    if (dev->grab && SameClient(dev->grab, client))
			dev->sync.state = THAWED;
		    if (dev->sync.other && SameClient(dev->sync.other, client))
			dev->sync.other = NullGrab;
d1722 7
a1728 4
		    if (dev->grab && SameClient(dev->grab, client))
			dev->sync.state = FREEZE_BOTH_NEXT_EVENT;
		    if (dev->sync.other && SameClient(dev->sync.other, client))
			dev->sync.other = NullGrab;
d1734 1
a1734 1
	    if (thisGrabbed && thisDev->sync.state == FROZEN_WITH_EVENT)
d1737 1
a1737 1
		    thisDev->sync.other = NullGrab;
d1739 2
a1740 2
		syncEvents.replayWin = thisDev->grab->window;
		(*thisDev->DeactivateGrab)(thisDev);
d1751 7
a1757 4
		    if (dev->grab && SameClient(dev->grab, client))
			dev->sync.state = THAWED;
		    if (dev->sync.other && SameClient(dev->sync.other, client))
			dev->sync.other = NullGrab;
d1768 1
a1768 1
 * Release some events from a frozen device. Only applicable for core devices.
d1774 2
a1775 2
    DeviceIntPtr	mouse = inputInfo.pointer;
    DeviceIntPtr	keybd = inputInfo.keyboard;
d1780 4
d1787 1
a1787 1
	    AllowSome(client, time, mouse, NOT_GRABBED);
d1789 2
a1790 2
	case SyncPointer: 
	    AllowSome(client, time, mouse, FREEZE_NEXT_EVENT);
d1792 2
a1793 2
	case AsyncPointer: 
	    AllowSome(client, time, mouse, THAWED);
d1795 2
a1796 2
	case ReplayKeyboard: 
	    AllowSome(client, time, keybd, NOT_GRABBED);
d1798 2
a1799 2
	case SyncKeyboard: 
	    AllowSome(client, time, keybd, FREEZE_NEXT_EVENT);
d1801 2
a1802 2
	case AsyncKeyboard: 
	    AllowSome(client, time, keybd, THAWED);
d1805 1
a1805 1
	    AllowSome(client, time, keybd, FREEZE_BOTH_NEXT_EVENT);
d1808 1
a1808 1
	    AllowSome(client, time, keybd, THAWED_BOTH);
d1810 1
a1810 1
	default: 
d1830 4
a1833 4
    	done = TRUE;
    	for (dev = inputInfo.devices; dev; dev = dev->next)
    	{
	    if (dev->grab && SameClient(dev->grab, client))
d1835 2
a1836 2
	    	(*dev->DeactivateGrab)(dev);
	    	done = FALSE;
d1838 1
a1838 1
    	}
d1854 2
a1855 2
 * client. 
 * An event is only delivered if 
d1858 1
a1858 1
 * 
d1861 1
d1866 1
a1866 1
 * @@param grab Possible grab on the device that caused the event. 
d1872 2
a1873 2
TryClientEvents (ClientPtr client, xEvent *pEvents, int count, Mask mask, 
                 Mask filter, GrabPtr grab)
d1879 1
a1879 1
    ErrorF("Event([%d, %d], mask=0x%x), client=%d",
d1892 1
a1892 1
		if (WID(inputInfo.pointer->valuator->motionHintWindow) ==
d1896 2
a1897 2
		    ErrorF("\n");
	    ErrorF("motionHintWindow == keyButtonPointer.event\n");
a1907 1
#ifdef XINPUT
a1914 1
#endif
a1924 1
#ifdef SMART_SCHEDULE
a1926 1
#endif
d1932 1
a1932 1
	ErrorF(  " delivered\n");
d1939 1
a1939 1
	ErrorF("\n");
d1950 4
d1956 1
a1956 1
 * 
d1961 1
a1961 1
 * @@param grab Possible grab on the device that caused the event. 
d1967 2
a1968 2
DeliverEventsToWindow(WindowPtr pWin, xEvent *pEvents, int count, 
                      Mask filter, GrabPtr grab, int mskidx)
d1979 2
a1980 1
    if ((filter == CantBeFiltered) || !(type & EXTENSION_EVENT_BASE))
d1986 5
d1993 3
a1995 2
	else if ( (attempt = TryClientEvents(wClient(pWin), pEvents, count,
					     pWin->eventMask, filter, grab)) )
d2008 10
a2017 3
	if (type & EXTENSION_EVENT_BASE)
	{
	    OtherInputMasks *inputMasks;
d2019 63
a2081 25
	    inputMasks = wOtherInputMasks(pWin);
	    if (!inputMasks ||
		!(inputMasks->inputEvents[mskidx] & filter))
		return 0;
	    other = inputMasks->inputClients;
	}
	else
	    other = (InputClients *)wOtherClients(pWin);
	for (; other; other = other->next)
	{
	    if (XaceHook(XACE_RECEIVE_ACCESS, rClient(other), pWin, pEvents,
			 count))
		/* do nothing */;
	    else if ( (attempt = TryClientEvents(rClient(other), pEvents, count,
					  other->mask[mskidx], filter, grab)) )
	    {
		if (attempt > 0)
		{
		    deliveries++;
		    client = rClient(other);
		    deliveryMask = other->mask[mskidx];
		} else
		    nondeliveries--;
	    }
	}
d2083 7
a2089 1
    if ((type == ButtonPress) && deliveries && (!grab))
d2092 1
d2094 2
a2095 1
	tempGrab.device = inputInfo.pointer;
d2104 23
a2126 2
	(*inputInfo.pointer->ActivateGrab)(inputInfo.pointer, &tempGrab,
					   currentTime, TRUE);
d2129 1
a2129 2
	inputInfo.pointer->valuator->motionHintWindow = pWin;
#ifdef XINPUT
a2140 1
#endif
d2152 1
a2152 1
static int 
d2156 1
a2156 1
    Mask mask, 
d2179 1
a2179 1
MaybeDeliverEventsToClient(WindowPtr pWin, xEvent *pEvents, 
d2190 1
a2190 1
	if(!noPanoramiXExtension && pWin->drawable.pScreen->myNum) 
d2196 1
a2196 1
	return TryClientEvents(wClient(pWin), pEvents, count,
d2206 1
a2206 1
	    if(!noPanoramiXExtension && pWin->drawable.pScreen->myNum) 
d2213 1
a2213 1
	    return TryClientEvents(rClient(other), pEvents, count,
d2230 1
d2236 5
d2243 4
a2246 4
        WindowPtr w=spriteTrace[spriteTraceGood-1];
	/* If the search ends up past the root should the child field be 
	 	set to none or should the value in the argument be passed 
		through. It probably doesn't matter since everyone calls 
d2249 1
a2249 1
        while (w) 
d2254 4
a2257 4
 	    if (w == pWin)
	    { 
   		child = None;
 		break;
d2259 1
a2259 1
	    
d2265 2
a2266 2
 	    w = w->parent;
        } 	    
d2268 1
a2268 1
    XE_KBPTR.root = ROOT->drawable.id;
d2270 1
a2270 1
    if (sprite.hot.pScreen == pWin->drawable.pScreen)
d2289 8
a2296 6
 * Deliver events caused by input devices. Called for all core input events
 * and XI events. No filtering of events happens before DeliverDeviceEvents(),
 * it will be called for any event that comes out of the event queue.
 * 
 * For all core events, dev is either inputInfo.pointer or inputInfo.keyboard.
 * For all extension events, dev is the device that caused the event.
d2305 2
d2309 1
a2309 1
DeliverDeviceEvents(WindowPtr pWin, xEvent *xE, GrabPtr grab, 
d2314 1
a2314 1
    Mask filter = filters[type];
d2316 3
d2323 5
a2327 1
    if (type & EXTENSION_EVENT_BASE)
d2329 21
a2349 2
	OtherInputMasks *inputMasks;
	int mskidx = dev->id;
d2351 2
a2352 23
	inputMasks = wOtherInputMasks(pWin);
	if (inputMasks && !(filter & inputMasks->deliverableEvents[mskidx]))
	    return 0;
	while (pWin)
	{
	    if (inputMasks && (inputMasks->inputEvents[mskidx] & filter))
	    {
		FixUpEventFromWindow(xE, pWin, child, FALSE);
		deliveries = DeliverEventsToWindow(pWin, xE, count, filter,
						   grab, mskidx);
		if (deliveries > 0)
		    return deliveries;
	    }
	    if ((deliveries < 0) ||
		(pWin == stopAt) ||
		(inputMasks &&
		 (filter & inputMasks->dontPropagateMask[mskidx])))
		return 0;
	    child = pWin->drawable.id;
	    pWin = pWin->parent;
	    if (pWin)
		inputMasks = wOtherInputMasks(pWin);
	}
d2354 2
a2355 1
    else
d2357 43
a2399 19
	if (!(filter & pWin->deliverableEvents))
	    return 0;
	while (pWin)
	{
	    if ((wOtherEventMasks(pWin)|pWin->eventMask) & filter)
	    {
		FixUpEventFromWindow(xE, pWin, child, FALSE);
		deliveries = DeliverEventsToWindow(pWin, xE, count, filter,
						   grab, 0);
		if (deliveries > 0)
		    return deliveries;
	    }
	    if ((deliveries < 0) ||
		(pWin == stopAt) ||
		(filter & wDontPropagateMask(pWin)))
		return 0;
	    child = pWin->drawable.id;
	    pWin = pWin->parent;
	}
d2401 1
d2408 1
a2408 1
 * propagate up the tree or extension events 
d2419 1
a2419 1
DeliverEvents(WindowPtr pWin, xEvent *xE, int count, 
d2432 3
a2434 1
    filter = filters[xE->u.u.type];
d2438 2
a2439 2
	return DeliverEventsToWindow(pWin, xE, count, filter, NullGrab, 0);
    deliveries = DeliverEventsToWindow(pWin, xE, count, StructureNotifyMask,
d2444 1
a2444 1
	deliveries += DeliverEventsToWindow(pWin->parent, xE, count,
d2450 2
a2451 2
	    deliveries += DeliverEventsToWindow(otherParent, xE, count,
						SubstructureNotifyMask,
d2459 1
a2459 1
static Bool 
d2463 1
d2469 2
a2470 1
    if(!noPanoramiXExtension && XineramaSetWindowPntrs(pWin)) {
d2474 4
a2477 4
	   if(POINT_IN_REGION(sprite.screen, 
			&sprite.windows[i]->borderSize, 
			x + panoramiXdataPtr[0].x - panoramiXdataPtr[i].x, 
			y + panoramiXdataPtr[0].y - panoramiXdataPtr[i].y, 
d2497 2
a2498 2
static WindowPtr 
XYToWindow(int x, int y)
d2502 1
d2504 3
a2506 2
    spriteTraceGood = 1;	/* root window still there */
    pWin = ROOT->firstChild;
a2515 1
#ifdef SHAPE
d2526 6
d2535 1
a2535 1
	    if (spriteTraceGood >= spriteTraceSize)
d2537 3
a2539 5
		spriteTraceSize += 10;
		Must_have_memory = TRUE; /* XXX */
		spriteTrace = (WindowPtr *)xrealloc(
		    spriteTrace, spriteTraceSize*sizeof(WindowPtr));
		Must_have_memory = FALSE; /* XXX */
d2541 1
a2541 1
	    spriteTrace[spriteTraceGood++] = pWin;
d2547 1
a2547 1
    return spriteTrace[spriteTraceGood-1];
d2555 5
d2561 2
a2562 2
static Bool
CheckMotion(xEvent *xE)
d2564 5
a2568 1
    WindowPtr prevSpriteWin = sprite.win;
d2572 1
a2572 1
	return XineramaCheckMotion(xE);
d2577 48
a2624 4
	if (sprite.hot.pScreen != sprite.hotPhys.pScreen)
	{
	    sprite.hot.pScreen = sprite.hotPhys.pScreen;
	    ROOT = WindowTable[sprite.hot.pScreen->myNum];
d2626 3
a2628 28
	sprite.hot.x = XE_KBPTR.rootX;
	sprite.hot.y = XE_KBPTR.rootY;
	if (sprite.hot.x < sprite.physLimits.x1)
	    sprite.hot.x = sprite.physLimits.x1;
	else if (sprite.hot.x >= sprite.physLimits.x2)
	    sprite.hot.x = sprite.physLimits.x2 - 1;
	if (sprite.hot.y < sprite.physLimits.y1)
	    sprite.hot.y = sprite.physLimits.y1;
	else if (sprite.hot.y >= sprite.physLimits.y2)
	    sprite.hot.y = sprite.physLimits.y2 - 1;
#ifdef SHAPE
	if (sprite.hotShape)
	    ConfineToShape(sprite.hotShape, &sprite.hot.x, &sprite.hot.y);
#endif
#ifdef XEVIE
        xeviehot.x = sprite.hot.x;
        xeviehot.y = sprite.hot.y;
#endif
	sprite.hotPhys = sprite.hot;
	if ((sprite.hotPhys.x != XE_KBPTR.rootX) ||
	    (sprite.hotPhys.y != XE_KBPTR.rootY))
	{
	    (*sprite.hotPhys.pScreen->SetCursorPosition)(
		sprite.hotPhys.pScreen,
		sprite.hotPhys.x, sprite.hotPhys.y, FALSE);
	}
	XE_KBPTR.rootX = sprite.hot.x;
	XE_KBPTR.rootY = sprite.hot.y;
d2631 1
a2631 4
#ifdef XEVIE
    xeviewin =
#endif
    sprite.win = XYToWindow(sprite.hot.x, sprite.hot.y);
d2633 2
a2634 2
    if (!(sprite.win->deliverableEvents &
	  Motion_Filter(inputInfo.pointer->button))
d2640 1
a2640 1
    if (sprite.win != prevSpriteWin)
d2645 4
a2648 3
	    DoEnterLeaveEvents(prevSpriteWin, sprite.win, NotifyNormal);
	}
	PostNewCursor();
d2658 1
a2658 1
_X_EXPORT void
d2661 7
a2667 1
    (void) CheckMotion((xEvent *)NULL);
d2679 2
d2683 38
a2720 25
    
    sprite.hot.x        -= xoff;
    sprite.hot.y        -= yoff;

    sprite.hotPhys.x    -= xoff;
    sprite.hotPhys.y    -= yoff;

    sprite.hotLimits.x1 -= xoff; 
    sprite.hotLimits.y1 -= yoff;
    sprite.hotLimits.x2 -= xoff;
    sprite.hotLimits.y2 -= yoff;

    if (REGION_NOTEMPTY(sprite.screen, &sprite.Reg1))
        REGION_TRANSLATE(sprite.screen, &sprite.Reg1,    xoff, yoff);
    if (REGION_NOTEMPTY(sprite.screen, &sprite.Reg2))
        REGION_TRANSLATE(sprite.screen, &sprite.Reg2,    xoff, yoff);

    /* FIXME: if we call ConfineCursorToWindow, must we do anything else? */
    if ((grab = inputInfo.pointer->grab) && grab->confineTo) {
	if (grab->confineTo->drawable.pScreen != sprite.hotPhys.pScreen)
	    sprite.hotPhys.x = sprite.hotPhys.y = 0;
	ConfineCursorToWindow(grab->confineTo, TRUE, TRUE);
    } else
	ConfineCursorToWindow(WindowTable[sprite.hotPhys.pScreen->myNum],
			      TRUE, FALSE);
d2725 4
a2728 2
 * Set the given window to sane values, display the cursor in the center of
 * the screen. Called from main() with the root window on the first screen.
d2733 1
a2733 1
    ScreenPtr pScreen = win->drawable.pScreen;
d2735 72
a2806 20
    sprite.hotPhys.pScreen = pScreen;
    sprite.hotPhys.x = pScreen->width / 2;
    sprite.hotPhys.y = pScreen->height / 2;
    sprite.hot = sprite.hotPhys;
    sprite.hotLimits.x2 = pScreen->width;
    sprite.hotLimits.y2 = pScreen->height;
#ifdef XEVIE
    xeviewin =
#endif
    sprite.win = win;
    sprite.current = wCursor (win);
    sprite.current->refcnt++;
    spriteTraceGood = 1;
    ROOT = win;
    (*pScreen->CursorLimits) (
	pScreen, sprite.current, &sprite.hotLimits, &sprite.physLimits);
    sprite.confined = FALSE;
    (*pScreen->ConstrainCursor) (pScreen, &sprite.physLimits);
    (*pScreen->SetCursorPosition) (pScreen, sprite.hot.x, sprite.hot.y, FALSE);
    (*pScreen->DisplayCursor) (pScreen, sprite.current);
d2808 26
d2836 11
a2846 13
	sprite.hotLimits.x1 = -panoramiXdataPtr[0].x;
	sprite.hotLimits.y1 = -panoramiXdataPtr[0].y;
	sprite.hotLimits.x2 = PanoramiXPixWidth  - panoramiXdataPtr[0].x;
	sprite.hotLimits.y2 = PanoramiXPixHeight - panoramiXdataPtr[0].y;
	sprite.physLimits = sprite.hotLimits;
	sprite.confineWin = NullWindow;
#ifdef SHAPE
        sprite.hotShape = NullRegion;
#endif
	sprite.screen = pScreen;
	/* gotta UNINIT these someplace */
	REGION_NULL(pScreen, &sprite.Reg1);
	REGION_NULL(pScreen, &sprite.Reg2);
d2867 1
a2867 1
UpdateSpriteForScreen(ScreenPtr pScreen)
d2869 1
d2873 6
d2881 17
a2897 19
    sprite.hotPhys.pScreen = pScreen;
    sprite.hot = sprite.hotPhys;
    sprite.hotLimits.x2 = pScreen->width;
    sprite.hotLimits.y2 = pScreen->height;
#ifdef XEVIE
    xeviewin =
#endif
    sprite.win = win;
    sprite.current = wCursor (win);
    sprite.current->refcnt++;
    spriteTraceGood = 1;
    ROOT = win;
    (*pScreen->CursorLimits) (pScreen,
                              sprite.current,
                              &sprite.hotLimits,
                              &sprite.physLimits);
    sprite.confined = FALSE;
    (*pScreen->ConstrainCursor) (pScreen, &sprite.physLimits);
    (*pScreen->DisplayCursor) (pScreen, sprite.current);
d2901 6
a2906 6
        sprite.hotLimits.x1 = -panoramiXdataPtr[0].x;
        sprite.hotLimits.y1 = -panoramiXdataPtr[0].y;
        sprite.hotLimits.x2 = PanoramiXPixWidth  - panoramiXdataPtr[0].x;
        sprite.hotLimits.y2 = PanoramiXPixHeight - panoramiXdataPtr[0].y;
        sprite.physLimits = sprite.hotLimits;
        sprite.screen = pScreen;
d2921 5
a2925 1
    PostNewCursor();
d2929 1
a2929 1
NewCurrentScreen(ScreenPtr newScreen, int x, int y)
d2931 4
a2934 2
    sprite.hotPhys.x = x;
    sprite.hotPhys.y = y;
d2937 1
a2937 1
	sprite.hotPhys.x += panoramiXdataPtr[newScreen->myNum].x - 
d2939 1
a2939 1
	sprite.hotPhys.y += panoramiXdataPtr[newScreen->myNum].y - 
d2941 2
a2942 2
	if (newScreen != sprite.screen) {
	    sprite.screen = newScreen;
d2944 3
a2946 2
	    if(sprite.confineWin)
		XineramaConfineCursorToWindow(sprite.confineWin, TRUE);
d2948 2
a2949 2
		XineramaConfineCursorToWindow(WindowTable[0], TRUE);
	    /* if the pointer wasn't confined, the DDX won't get 
d2952 7
a2958 5
		(*sprite.screen->SetCursorPosition)(sprite.screen,
		    sprite.hotPhys.x + panoramiXdataPtr[0].x - 
			panoramiXdataPtr[sprite.screen->myNum].x,
		    sprite.hotPhys.y + panoramiXdataPtr[0].y - 
			panoramiXdataPtr[sprite.screen->myNum].y, FALSE);
d2960 1
a2960 1
    } else 
d2962 3
a2964 2
    if (newScreen != sprite.hotPhys.pScreen)
	ConfineCursorToWindow(WindowTable[newScreen->myNum], TRUE, FALSE);
a2983 2
    
    if(!XineramaSetWindowPntrs(pWin)) return FALSE;
d2985 4
a2988 2
    xoff = x + panoramiXdataPtr[0].x;  
    yoff = y + panoramiXdataPtr[0].y;  
d2991 1
a2991 1
	pWin = sprite.windows[i];
d3000 1
a3000 1
			       x - pWin->drawable.x, 
d3014 1
d3024 2
a3025 2
    x = sprite.hotPhys.x;
    y = sprite.hotPhys.y;
d3030 1
a3030 1
 	XID 	winID = stuff->srcWid;
d3032 1
a3032 1
	
d3059 1
a3059 1
    } 
d3064 10
a3073 10
    if (x < sprite.physLimits.x1)
	x = sprite.physLimits.x1;
    else if (x >= sprite.physLimits.x2)
	x = sprite.physLimits.x2 - 1;
    if (y < sprite.physLimits.y1)
	y = sprite.physLimits.y1;
    else if (y >= sprite.physLimits.y2)
	y = sprite.physLimits.y2 - 1;
    if (sprite.hotShape)
	ConfineToShape(sprite.hotShape, &x, &y);
d3075 1
a3075 1
    XineramaSetCursorPosition(x, y, TRUE);
d3094 2
d3099 1
d3107 6
d3123 2
a3124 2
    x = sprite.hotPhys.x;
    y = sprite.hotPhys.y;
d3129 1
a3129 1
 	XID 	winID = stuff->srcWid;
d3131 1
a3131 1
	
d3138 1
a3138 1
	if (source->drawable.pScreen != sprite.hotPhys.pScreen ||
d3148 1
a3148 1
    if (dest) 
d3153 2
a3154 2
    } else 
	newScreen = sprite.hotPhys.pScreen;
d3168 1
a3168 1
    if (newScreen == sprite.hotPhys.pScreen)
d3170 11
a3180 13
	if (x < sprite.physLimits.x1)
	    x = sprite.physLimits.x1;
	else if (x >= sprite.physLimits.x2)
	    x = sprite.physLimits.x2 - 1;
	if (y < sprite.physLimits.y1)
	    y = sprite.physLimits.y1;
	else if (y >= sprite.physLimits.y2)
	    y = sprite.physLimits.y2 - 1;
#if defined(SHAPE)
	if (sprite.hotShape)
	    ConfineToShape(sprite.hotShape, &x, &y);
#endif
	(*newScreen->SetCursorPosition)(newScreen, x, y, TRUE);
d3182 1
a3182 1
    else if (!PointerConfinedToScreen())
d3184 1
a3184 1
	NewCurrentScreen(newScreen, x, y);
d3189 2
a3190 2
static Bool 
BorderSizeNotEmpty(WindowPtr pWin)
d3192 1
a3192 1
     if(REGION_NOTEMPTY(sprite.hotPhys.pScreen, &pWin->borderSize))
d3196 1
a3196 1
     if(!noPanoramiXExtension && XineramaSetWindowPntrs(pWin)) {
d3200 2
a3201 1
	    if(REGION_NOTEMPTY(sprite.screen, &sprite.windows[i]->borderSize))
d3209 1
a3209 1
/** 
d3211 1
a3211 1
 * passive grab set on the window to be activated. 
d3213 1
a3213 1
 * 
d3217 3
a3219 1
 * @@count number of elements in xE.
d3227 3
a3229 1
    int count)
d3233 1
d3244 1
d3249 1
a3249 1
	XkbSrvInfoPtr	xkbi;
d3252 9
a3260 1
	xkbi= gdev->key->xkbInfo;
d3264 1
a3264 5
	    ((xE->u.u.type == KeyPress)
#if defined(XINPUT) && defined(XKB)
	     || (xE->u.u.type == DeviceKeyPress)
#endif
	     ))
d3267 3
a3269 1
		(noXkbExtension?gdev->key->prev_state:xkbi->state.grab_mods);
d3271 1
a3271 1
		grab->modifierDevice->key->prev_state;
d3276 3
a3278 1
		(noXkbExtension ? gdev->key->state : xkbi->state.grab_mods);
d3280 1
a3280 1
		grab->modifierDevice->key->state;
d3282 2
a3283 1
	if (GrabMatchesSecond(&tempGrab, grab) &&
d3285 2
a3286 2
	     (grab->confineTo->realized && 
				BorderSizeNotEmpty(grab->confineTo))))
d3295 41
a3335 7
	    (*device->ActivateGrab)(device, grab, currentTime, TRUE);
 
	    FixUpEventFromWindow(xE, grab->window, None, TRUE);

	    (void) TryClientEvents(rClient(grab), xE, count,
				   filters[xE->u.u.type],
				   filters[xE->u.u.type],  grab);
d3337 10
a3346 1
	    if (device->sync.state == FROZEN_NO_EVENT)
d3348 1
a3348 1
		if (device->sync.evcount < count)
d3350 2
a3351 5
		    Must_have_memory = TRUE; /* XXX */
		    device->sync.event = (xEvent *)xrealloc(device->sync.event,
							    count*
							    sizeof(xEvent));
		    Must_have_memory = FALSE; /* XXX */
d3353 6
a3358 5
		device->sync.evcount = count;
		for (dxE = device->sync.event; --count >= 0; dxE++, xE++)
		    *dxE = *xE;
	    	device->sync.state = FROZEN_WITH_EVENT;
            }	
d3367 1
a3367 1
 * a passive grab to be activated.  
d3374 1
a3374 1
 * activated.  
d3382 3
d3386 1
a3386 1
 * @@param xE The event to handle (most likely {Device}ButtonPress).
d3392 1
a3392 1
CheckDeviceGrabs(DeviceIntPtr device, xEvent *xE, 
d3397 3
a3399 1
    FocusClassPtr focus = device->focus;
d3401 2
a3402 5
    if (((xE->u.u.type == ButtonPress)
#if defined(XINPUT) && defined(XKB)
	 || (xE->u.u.type == DeviceButtonPress)
#endif
	 ) && (device->button->buttonsDown != 1))
d3405 15
d3427 1
d3429 3
a3431 1
		CheckPassiveGrabsOnWindow(pWin, device, xE, count))
d3434 1
a3434 1
  
d3436 3
a3438 2
	    (i >= spriteTraceGood) ||
	    ((i > checkFirst) && (pWin != spriteTrace[i-1])))
d3442 1
a3442 1
    for (; i < spriteTraceGood; i++)
d3444 1
a3444 1
	pWin = spriteTrace[i];
d3446 3
a3448 1
	    CheckPassiveGrabsOnWindow(pWin, device, xE, count))
d3468 1
d3470 3
a3472 1
    int mskidx = 0;
d3488 1
d3491 7
d3499 15
a3513 5
    FixUpEventFromWindow(xE, focus, None, FALSE);
    if (xE->u.u.type & EXTENSION_EVENT_BASE)
	mskidx = keybd->id;
    (void)DeliverEventsToWindow(focus, xE, count, filters[xE->u.u.type],
				NullGrab, mskidx);
d3524 1
a3524 1
DeliverGrabbedEvent(xEvent *xE, DeviceIntPtr thisDev, 
d3527 2
a3528 1
    GrabPtr grab = thisDev->grab;
d3531 6
a3536 1
    xEvent *dxE;
d3542 12
a3553 1
	if (thisDev->focus)
d3562 5
a3566 4
	    deliveries = DeliverDeviceEvents(sprite.win, xE, grab, NullWindow,
					     thisDev, count);
	else if (focus && (focus == sprite.win || IsParent(focus, sprite.win)))
	    deliveries = DeliverDeviceEvents(sprite.win, xE, grab, focus,
d3574 59
a3632 22
	FixUpEventFromWindow(xE, grab->window, None, TRUE);
	if (XaceHook(XACE_SEND_ACCESS, 0, thisDev, grab->window, xE, count) ||
	    XaceHook(XACE_RECEIVE_ACCESS, rClient(grab), grab->window, xE,
		     count))
	    deliveries = 1; /* don't send, but pretend we did */
	else
	    deliveries = TryClientEvents(rClient(grab), xE, count,
					 (Mask)grab->eventMask,
					 filters[xE->u.u.type], grab);
	if (deliveries && (xE->u.u.type == MotionNotify
#ifdef XINPUT
			   || xE->u.u.type == DeviceMotionNotify
#endif
			   ))
	    thisDev->valuator->motionHintWindow = grab->window;
    }
    if (deliveries && !deactivateGrab && (xE->u.u.type != MotionNotify
#ifdef XINPUT
					  && xE->u.u.type != DeviceMotionNotify
#endif
					  ))
	switch (thisDev->sync.state)
d3640 4
a3643 4
		if ((dev->sync.state == FREEZE_BOTH_NEXT_EVENT) &&
		    (CLIENT_BITS(dev->grab->resource) ==
		     CLIENT_BITS(thisDev->grab->resource)))
		    dev->sync.state = FROZEN_NO_EVENT;
d3645 1
a3645 1
		    dev->sync.other = thisDev->grab;
d3649 1
a3649 1
	    thisDev->sync.state = FROZEN_WITH_EVENT;
d3651 1
a3651 1
	    if (thisDev->sync.evcount < count)
d3653 2
a3654 4
		Must_have_memory = TRUE; /* XXX */
		thisDev->sync.event = (xEvent *)xrealloc(thisDev->sync.event,
							 count*sizeof(xEvent));
		Must_have_memory = FALSE; /* XXX */
d3656 2
a3657 2
	    thisDev->sync.evcount = count;
	    for (dxE = thisDev->sync.event; --count >= 0; dxE++, xE++)
d3661 1
d3665 1
a3665 1
 * Main keyboard event processing function for core keyboard events. 
d3683 4
a3686 5
    BYTE   *kptr;
    int    i;
    CARD8  modifiers;
    CARD16 mask;
    GrabPtr         grab = keybd->grab;
d3688 1
a3688 3
    KeyClassPtr keyc = keybd->key;
#ifdef XEVIE
    static Window           rootWin = 0;
d3690 2
a3691 36
    if(!xeviegrabState && xevieFlag && clients[xevieClientIndex] &&
          (xevieMask & xevieFilters[xE->u.u.type])) {
      key = xE->u.u.detail;
      kptr = &keyc->down[key >> 3];
      bit = 1 << (key & 7);
      if((xE->u.u.type == KeyPress &&  (*kptr & bit)) ||
         (xE->u.u.type == KeyRelease && !(*kptr & bit)))
      {} else {
#ifdef XKB
        if(!noXkbExtension)
	    xevieKBEventSent = 1;
#endif
        if(!xevieKBEventSent)
        {
          xeviekb = keybd;
          if(!rootWin) {
	      rootWin = GetCurrentRootWindow()->drawable.id;
          }
          xE->u.keyButtonPointer.event = xeviewin->drawable.id;
          xE->u.keyButtonPointer.root = rootWin;
          xE->u.keyButtonPointer.child = (xeviewin->firstChild) ? xeviewin->firstChild->
drawable.id:0;
          xE->u.keyButtonPointer.rootX = xeviehot.x;
          xE->u.keyButtonPointer.rootY = xeviehot.y;
          xE->u.keyButtonPointer.state = keyc->state;
          WriteToClient(clients[xevieClientIndex], sizeof(xEvent), (char *)xE);
#ifdef XKB
          if(noXkbExtension)
#endif
            return;
        } else {
	    xevieKBEventSent = 0;
        }
      }
    }
#endif
d3704 5
a3708 12
#ifdef XEVIE
    /* fix for bug5094030: don't change the state bit if the event is from XEvIE client */
    if(!(!xeviegrabState && xevieFlag && clients[xevieClientIndex] &&
	 (xevieMask & xevieFilters[xE->u.u.type]
#ifdef XKB
	  && !noXkbExtension
#endif
    )))
#endif
    XE_KBPTR.state = (keyc->state | inputInfo.pointer->button->state);
    XE_KBPTR.rootX = sprite.hot.x;
    XE_KBPTR.rootY = sprite.hot.y;
a3712 10
#if defined(XKB) && defined(XEVIE)
    if(!noXkbExtension && !xeviegrabState &&
       xevieFlag && clients[xevieClientIndex] &&
       (xevieMask & xevieFilters[xE->u.u.type])) {
	switch(xE->u.u.type) {
	  case KeyPress: *kptr &= ~bit; break;
	  case KeyRelease: *kptr |= bit; break;
	}
    }
#endif
d3716 9
a3724 26
	case KeyPress: 
	    if (*kptr & bit) /* allow ddx to generate multiple downs */
	    {   
		if (!modifiers)
		{
		    xE->u.u.type = KeyRelease;
		    (*keybd->public.processInputProc)(xE, keybd, count);
		    xE->u.u.type = KeyPress;
		    /* release can have side effects, don't fall through */
		    (*keybd->public.processInputProc)(xE, keybd, count);
		}
		return;
	    }
	    inputInfo.pointer->valuator->motionHintWindow = NullWindow;
	    *kptr |= bit;
	    keyc->prev_state = keyc->state;
	    for (i = 0, mask = 1; modifiers; i++, mask <<= 1)
	    {
		if (mask & modifiers)
		{
		    /* This key affects modifier "i" */
		    keyc->modifierKeyCount[i]++;
		    keyc->state |= mask;
		    modifiers &= ~mask;
		}
	    }
d3727 1
a3727 1
		keybd->activatingKey = key;
d3731 1
a3731 1
	case KeyRelease: 
d3734 2
a3735 15
	    inputInfo.pointer->valuator->motionHintWindow = NullWindow;
	    *kptr &= ~bit;
	    keyc->prev_state = keyc->state;
	    for (i = 0, mask = 1; modifiers; i++, mask <<= 1)
	    {
		if (mask & modifiers) {
		    /* This key affects modifier "i" */
		    if (--keyc->modifierKeyCount[i] <= 0) {
			keyc->state &= ~mask;
			keyc->modifierKeyCount[i] = 0;
		    }
		    modifiers &= ~mask;
		}
	    }
	    if (keybd->fromPassiveGrab && (key == keybd->activatingKey))
d3738 1
a3738 1
	default: 
d3744 1
a3744 1
	DeliverFocusedEvent(keybd, xE, sprite.win, count);
d3746 1
a3746 1
        (*keybd->DeactivateGrab)(keybd);
d3753 1
a3753 1
   this is only used when the pressing of keys does not cause 
d3783 2
a3784 2
/** 
 * Main pointer event processing function for core pointer events. 
d3802 1
a3802 1
    GrabPtr	grab = mouse->grab;
d3804 3
a3806 1
    ButtonClassPtr butc = mouse->button;
d3808 1
a3808 13
    XkbSrvInfoPtr xkbi= inputInfo.keyboard->key->xkbInfo;
#endif
#ifdef XEVIE
    if(xevieFlag && clients[xevieClientIndex] && !xeviegrabState &&
       (xevieMask & xevieFilters[xE->u.u.type])) {
      if(xevieEventSent)
        xevieEventSent = 0;
      else {
        xeviemouse = mouse;
        WriteToClient(clients[xevieClientIndex], sizeof(xEvent), (char *)xE);
        return;
      }
    }
d3830 1
a3830 1
		    WindowTable[sprite.hotPhys.pScreen->myNum]->drawable.id;
d3836 5
a3843 2
	BYTE *kptr;
	int           bit;
d3845 2
a3846 2
	XE_KBPTR.rootX = sprite.hot.x;
	XE_KBPTR.rootY = sprite.hot.y;
a3848 2
	kptr = &butc->down[key >> 3];
	bit = 1 << (key & 7);
d3851 6
a3856 6
	case ButtonPress: 
	    mouse->valuator->motionHintWindow = NullWindow;
	    if (!(*kptr & bit))
		butc->buttonsDown++;
	    butc->motionMask = ButtonMotionMask;
	    *kptr |= bit;
d3859 1
a3859 3
	    if (xE->u.u.detail <= 5)
		butc->state |= (Button1Mask >> 1) << xE->u.u.detail;
	    filters[MotionNotify] = Motion_Filter(butc);
d3864 1
a3864 7
	case ButtonRelease: 
	    mouse->valuator->motionHintWindow = NullWindow;
	    if (*kptr & bit)
		--butc->buttonsDown;
	    if (!butc->buttonsDown)
		butc->motionMask = 0;
	    *kptr &= ~bit;
d3867 2
a3868 4
	    if (xE->u.u.detail <= 5)
		butc->state &= ~((Button1Mask >> 1) << xE->u.u.detail);
	    filters[MotionNotify] = Motion_Filter(butc);
	    if (!butc->state && mouse->fromPassiveGrab)
d3871 2
a3872 2
	default: 
	    FatalError("bogus pointer event from ddx: %d", xE->u.u.type);
d3875 1
a3875 2
    else if (!CheckMotion(xE))
	return;
d3879 1
a3879 1
	DeliverDeviceEvents(sprite.win, xE, NullGrab, NullWindow,
d3882 1
a3882 1
        (*mouse->DeactivateGrab)(mouse);
d3977 1
d4043 9
a4051 6
maskSet: 
    if ((inputInfo.pointer->valuator->motionHintWindow == pWin) &&
	(mask & PointerMotionHintMask) &&
	!(check & PointerMotionHintMask) &&
	!inputInfo.pointer->grab)
	inputInfo.pointer->valuator->motionHintWindow = NullWindow;
d4057 1
a4057 1
EventSuppressForWindow(WindowPtr pWin, ClientPtr client, 
d4113 2
a4114 1
 * @@return The window that is the first ancestor of both a and b.
d4116 3
a4118 16
static WindowPtr 
CommonAncestor(
    WindowPtr a,
    WindowPtr b)
{
    for (b = b->parent; b; b = b->parent)
	if (IsParent(b, a)) return b;
    return NullWindow;
}

/**
 * Assembles an EnterNotify or LeaveNotify and sends it event to the client. 
 * The core devices are used to fill in the event fields.
 */
static void
EnterLeaveEvent(
d4125 1
a4125 2
    xEvent		event;
    DeviceIntPtr keybd = inputInfo.keyboard;
d4127 2
a4128 2
    DeviceIntPtr mouse = inputInfo.pointer;
    GrabPtr	grab = mouse->grab;
d4131 2
d4146 12
a4157 13
    if (mask & filters[type])
    {
	event.u.u.type = type;
	event.u.u.detail = detail;
	event.u.enterLeave.time = currentTime.milliseconds;
	event.u.enterLeave.rootX = sprite.hot.x;
	event.u.enterLeave.rootY = sprite.hot.y;
	/* Counts on the same initial structure of crossing & button events! */
	FixUpEventFromWindow(&event, pWin, None, FALSE);
	/* Enter/Leave events always set child */
	event.u.enterLeave.child = child;
	event.u.enterLeave.flags = event.u.keyButtonPointer.sameScreen ?
					    ELFlagSameScreen : 0;
d4159 7
a4165 21
	if (!noXkbExtension) {
	    event.u.enterLeave.state = mouse->button->state & 0x1f00;
	    event.u.enterLeave.state |= 
			XkbGrabStateFromRec(&keybd->key->xkbInfo->state);
	} else
#endif
	event.u.enterLeave.state = keybd->key->state | mouse->button->state;
	event.u.enterLeave.mode = mode;
	focus = keybd->focus->win;
	if ((focus != NoneWin) &&
	    ((pWin == focus) || (focus == PointerRootWin) ||
	     IsParent(focus, pWin)))
	    event.u.enterLeave.flags |= ELFlagFocus;
	if (grab)
	    (void)TryClientEvents(rClient(grab), &event, 1, mask,
				  filters[type], grab);
	else
	    (void)DeliverEventsToWindow(pWin, &event, 1, filters[type],
					NullGrab, 0);
    }
    if ((type == EnterNotify) && (mask & KeymapStateMask))
d4167 2
a4168 15
	xKeymapEvent ke;
	ClientPtr client = grab ? rClient(grab)
				: clients[CLIENT_ID(pWin->drawable.id)];
	if (XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixReadAccess))
	    bzero((char *)&ke.map[0], 31);
	else
	    memmove((char *)&ke.map[0], (char *)&keybd->key->down[1], 31);

	ke.type = KeymapNotify;
	if (grab)
	    (void)TryClientEvents(rClient(grab), (xEvent *)&ke, 1, mask,
				  KeymapStateMask, grab);
	else
	    (void)DeliverEventsToWindow(pWin, (xEvent *)&ke, 1,
					KeymapStateMask, NullGrab, 0);
d4170 15
a4184 33
}

/**
 * Send enter notifies to all parent windows up to ancestor.
 * This function recurses.
 */
static void
EnterNotifies(WindowPtr ancestor, WindowPtr child, int mode, int detail)
{
    WindowPtr	parent = child->parent;

    if (ancestor == parent)
	return;
    EnterNotifies(ancestor, parent, mode, detail);
    EnterLeaveEvent(EnterNotify, mode, detail, parent, child->drawable.id);
}


/**
 * Send leave notifies to all parent windows up to ancestor.
 * This function recurses.
 */
static void
LeaveNotifies(WindowPtr child, WindowPtr ancestor, int mode, int detail)
{
    WindowPtr  pWin;

    if (ancestor == child)
	return;
    for (pWin = child->parent; pWin != ancestor; pWin = pWin->parent)
    {
	EnterLeaveEvent(LeaveNotify, mode, detail, pWin, child->drawable.id);
	child = pWin;
a4185 1
}
d4187 1
a4187 13
/**
 * Figure out if enter/leave events are necessary and send them to the
 * appropriate windows.
 * 
 * @@param fromWin Window the sprite moved out of.
 * @@param toWin Window the sprite moved into.
 */
static void
DoEnterLeaveEvents(WindowPtr fromWin, WindowPtr toWin, int mode)
{
    if (fromWin == toWin)
	return;
    if (IsParent(fromWin, toWin))
d4189 15
a4203 18
	EnterLeaveEvent(LeaveNotify, mode, NotifyInferior, fromWin, None);
	EnterNotifies(fromWin, toWin, mode, NotifyVirtual);
	EnterLeaveEvent(EnterNotify, mode, NotifyAncestor, toWin, None);
    }
    else if (IsParent(toWin, fromWin))
    {
	EnterLeaveEvent(LeaveNotify, mode, NotifyAncestor, fromWin, None);
	LeaveNotifies(fromWin, toWin, mode, NotifyVirtual);
	EnterLeaveEvent(EnterNotify, mode, NotifyInferior, toWin, None);
    }
    else
    { /* neither fromWin nor toWin is descendent of the other */
	WindowPtr common = CommonAncestor(toWin, fromWin);
	/* common == NullWindow ==> different screens */
	EnterLeaveEvent(LeaveNotify, mode, NotifyNonlinear, fromWin, None);
	LeaveNotifies(fromWin, common, mode, NotifyNonlinearVirtual);
	EnterNotifies(common, toWin, mode, NotifyNonlinearVirtual);
	EnterLeaveEvent(EnterNotify, mode, NotifyNonlinear, toWin, None);
d4207 2
a4208 2
static void
FocusEvent(DeviceIntPtr dev, int type, int mode, int detail, WindowPtr pWin)
a4211 7
#ifdef XINPUT
    if (dev != inputInfo.keyboard)
    {
	DeviceFocusEvent(dev, type, mode, detail, pWin);
	return;
    }
#endif
d4216 2
a4217 2
    (void)DeliverEventsToWindow(pWin, &event, 1, filters[type], NullGrab,
				0);
d4219 1
a4219 112
	((pWin->eventMask | wOtherEventMasks(pWin)) & KeymapStateMask))
    {
	xKeymapEvent ke;
	ClientPtr client = clients[CLIENT_ID(pWin->drawable.id)];
	if (XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess))
	    bzero((char *)&ke.map[0], 31);
	else
	    memmove((char *)&ke.map[0], (char *)&dev->key->down[1], 31);

	ke.type = KeymapNotify;
	(void)DeliverEventsToWindow(pWin, (xEvent *)&ke, 1,
				    KeymapStateMask, NullGrab, 0);
    }
}

 /*
  * recursive because it is easier
  * no-op if child not descended from ancestor
  */
static Bool
FocusInEvents(
    DeviceIntPtr dev,
    WindowPtr ancestor, WindowPtr child, WindowPtr skipChild,
    int mode, int detail,
    Bool doAncestor)
{
    if (child == NullWindow)
	return ancestor == NullWindow;
    if (ancestor == child)
    {
	if (doAncestor)
	    FocusEvent(dev, FocusIn, mode, detail, child);
	return TRUE;
    }
    if (FocusInEvents(dev, ancestor, child->parent, skipChild, mode, detail,
		      doAncestor))
    {
	if (child != skipChild)
	    FocusEvent(dev, FocusIn, mode, detail, child);
	return TRUE;
    }
    return FALSE;
}

/* dies horribly if ancestor is not an ancestor of child */
static void
FocusOutEvents(
    DeviceIntPtr dev,
    WindowPtr child, WindowPtr ancestor,
    int mode, int detail,
    Bool doAncestor)
{
    WindowPtr  pWin;

    for (pWin = child; pWin != ancestor; pWin = pWin->parent)
	FocusEvent(dev, FocusOut, mode, detail, pWin);
    if (doAncestor)
	FocusEvent(dev, FocusOut, mode, detail, ancestor);
}

void
DoFocusEvents(DeviceIntPtr dev, WindowPtr fromWin, WindowPtr toWin, int mode)
{
    int     out, in;		       /* for holding details for to/from
				          PointerRoot/None */
    int     i;

    if (fromWin == toWin)
	return;
    out = (fromWin == NoneWin) ? NotifyDetailNone : NotifyPointerRoot;
    in = (toWin == NoneWin) ? NotifyDetailNone : NotifyPointerRoot;
 /* wrong values if neither, but then not referenced */

    if ((toWin == NullWindow) || (toWin == PointerRootWin))
    {
	if ((fromWin == NullWindow) || (fromWin == PointerRootWin))
   	{
	    if (fromWin == PointerRootWin)
		FocusOutEvents(dev, sprite.win, ROOT, mode, NotifyPointer,
			       TRUE);
	    /* Notify all the roots */
#ifdef PANORAMIX
 	    if ( !noPanoramiXExtension )
	        FocusEvent(dev, FocusOut, mode, out, WindowTable[0]);
	    else 
#endif
	        for (i=0; i<screenInfo.numScreens; i++)
	            FocusEvent(dev, FocusOut, mode, out, WindowTable[i]);
	}
	else
	{
	    if (IsParent(fromWin, sprite.win))
	      FocusOutEvents(dev, sprite.win, fromWin, mode, NotifyPointer,
			     FALSE);
	    FocusEvent(dev, FocusOut, mode, NotifyNonlinear, fromWin);
	    /* next call catches the root too, if the screen changed */
	    FocusOutEvents(dev, fromWin->parent, NullWindow, mode,
			   NotifyNonlinearVirtual, FALSE);
	}
	/* Notify all the roots */
#ifdef PANORAMIX
	if ( !noPanoramiXExtension )
	    FocusEvent(dev, FocusIn, mode, in, WindowTable[0]);
	else 
#endif
	    for (i=0; i<screenInfo.numScreens; i++)
	        FocusEvent(dev, FocusIn, mode, in, WindowTable[i]);
	if (toWin == PointerRootWin)
	    (void)FocusInEvents(dev, ROOT, sprite.win, NullWindow, mode,
				NotifyPointer, TRUE);
    }
    else
d4221 10
a4230 70
	if ((fromWin == NullWindow) || (fromWin == PointerRootWin))
	{
	    if (fromWin == PointerRootWin)
		FocusOutEvents(dev, sprite.win, ROOT, mode, NotifyPointer,
			       TRUE);
#ifdef PANORAMIX
 	    if ( !noPanoramiXExtension )
	        FocusEvent(dev, FocusOut, mode, out, WindowTable[0]);
	    else 
#endif
	        for (i=0; i<screenInfo.numScreens; i++)
	            FocusEvent(dev, FocusOut, mode, out, WindowTable[i]);
	    if (toWin->parent != NullWindow)
	      (void)FocusInEvents(dev, ROOT, toWin, toWin, mode,
				  NotifyNonlinearVirtual, TRUE);
	    FocusEvent(dev, FocusIn, mode, NotifyNonlinear, toWin);
	    if (IsParent(toWin, sprite.win))
    	       (void)FocusInEvents(dev, toWin, sprite.win, NullWindow, mode,
				   NotifyPointer, FALSE);
	}
	else
	{
	    if (IsParent(toWin, fromWin))
	    {
		FocusEvent(dev, FocusOut, mode, NotifyAncestor, fromWin);
		FocusOutEvents(dev, fromWin->parent, toWin, mode,
			       NotifyVirtual, FALSE);
		FocusEvent(dev, FocusIn, mode, NotifyInferior, toWin);
		if ((IsParent(toWin, sprite.win)) &&
			(sprite.win != fromWin) &&
			(!IsParent(fromWin, sprite.win)) &&
			(!IsParent(sprite.win, fromWin)))
		    (void)FocusInEvents(dev, toWin, sprite.win, NullWindow,
					mode, NotifyPointer, FALSE);
	    }
	    else
		if (IsParent(fromWin, toWin))
		{
		    if ((IsParent(fromWin, sprite.win)) &&
			    (sprite.win != fromWin) &&
			    (!IsParent(toWin, sprite.win)) &&
			    (!IsParent(sprite.win, toWin)))
			FocusOutEvents(dev, sprite.win, fromWin, mode,
				       NotifyPointer, FALSE);
		    FocusEvent(dev, FocusOut, mode, NotifyInferior, fromWin);
		    (void)FocusInEvents(dev, fromWin, toWin, toWin, mode,
					NotifyVirtual, FALSE);
		    FocusEvent(dev, FocusIn, mode, NotifyAncestor, toWin);
		}
		else
		{
		/* neither fromWin or toWin is child of other */
		    WindowPtr common = CommonAncestor(toWin, fromWin);
		/* common == NullWindow ==> different screens */
		    if (IsParent(fromWin, sprite.win))
			FocusOutEvents(dev, sprite.win, fromWin, mode,
				       NotifyPointer, FALSE);
		    FocusEvent(dev, FocusOut, mode, NotifyNonlinear, fromWin);
		    if (fromWin->parent != NullWindow)
		      FocusOutEvents(dev, fromWin->parent, common, mode,
				     NotifyNonlinearVirtual, FALSE);
		    if (toWin->parent != NullWindow)
		      (void)FocusInEvents(dev, common, toWin, toWin, mode,
					  NotifyNonlinearVirtual, FALSE);
		    FocusEvent(dev, FocusIn, mode, NotifyNonlinear, toWin);
		    if (IsParent(toWin, sprite.win))
			(void)FocusInEvents(dev, toWin, sprite.win, NullWindow,
					    mode, NotifyPointer, FALSE);
		}
	}
d4237 1
a4237 1
 * 
d4244 1
a4244 1
 * @@param dev Focus device. 
d4264 2
d4277 6
d4286 3
a4288 1
	focusWin = inputInfo.keyboard->focus->win;
d4293 1
a4293 1
 	/* It is a match error to try to set the input focus to an 
d4306 1
a4306 1
    mode = (dev->grab) ? NotifyWhileGrabbed : NotifyNormal;
d4308 1
a4308 1
	DoFocusEvents(dev, inputInfo.keyboard->focus->win, focusWin, mode);
d4328 2
a4329 5
	    Must_have_memory = TRUE; /* XXX */
	    focus->trace = (WindowPtr *)xrealloc(focus->trace,
						 focus->traceSize *
						 sizeof(WindowPtr));
	    Must_have_memory = FALSE; /* XXX */
d4332 1
a4332 1
        for (pWin = focusWin, depth--; pWin; pWin = pWin->parent, depth--) 
d4347 1
d4352 1
a4352 1
    return SetInputFocus(client, inputInfo.keyboard, stuff->focus,
d4358 2
a4359 2
 * 
 * Sends the current input focus for the virtual core keyboard back to the
d4365 1
d4367 1
a4367 1
    FocusClassPtr focus = inputInfo.keyboard->focus;
d4372 1
a4372 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard,
		  DixGetFocusAccess);
d4390 1
a4390 1
 * Server-side protocol handling for Grabpointer request.
d4392 2
a4393 2
 * Sets an active grab on the inputInfo.pointer and returns success status to
 * client.
d4399 1
a4399 1
    DeviceIntPtr device = inputInfo.pointer;
d4437 1
a4437 1
    else 
d4448 1
a4448 1
	rc = dixLookupResource((pointer *)&cursor, stuff->cursor, RT_CURSOR,
d4469 8
a4476 1
    grab = device->grab;
d4481 2
a4482 1
                !(confineTo->realized && BorderSizeNotEmpty(confineTo))))
d4484 3
a4486 2
    else if (device->sync.frozen &&
	     device->sync.other && !SameClient(device->sync.other, client))
d4489 1
a4489 1
	     (CompareTimeStamps(time, device->grabTime) == EARLIER))
d4497 1
a4497 1
 	{
d4499 1
a4499 1
		ConfineCursorToWindow(ROOT, FALSE, FALSE);
d4502 1
d4512 3
a4514 1
	(*device->ActivateGrab)(device, &tempGrab, time, FALSE);
d4527 1
a4527 3
 * hold an active grab on the device, nothing happens. 
 *
 * Works on the core pointer only.
d4532 2
a4533 2
    DeviceIntPtr device = inputInfo.pointer;
    GrabPtr grab = device->grab;
d4548 2
a4549 2
	int rc = dixLookupResource((pointer *)&newCursor, stuff->cursor,
				   RT_CURSOR, client, DixUseAccess);
d4556 4
d4566 1
a4566 1
	     (CompareTimeStamps(time, device->grabTime) == EARLIER))
d4572 1
a4572 1
    PostNewCursor();
d4582 1
a4582 1
 * Deletes the pointer grab on the core pointer device.
d4587 1
a4587 1
    DeviceIntPtr device = inputInfo.pointer;
d4594 2
a4595 1
    grab = device->grab;
d4598 1
a4598 1
	    (CompareTimeStamps(time, device->grabTime) != EARLIER) &&
d4600 1
a4600 1
	(*device->DeactivateGrab)(device);
d4606 2
a4607 2
 * 
 * Called from ProcGrabKeyboard to work on the inputInfo.keyboard.
d4609 1
a4609 1
 * 
d4611 1
a4611 1
 * pointer_mode parameters of XGrabKeyboard(). 
d4613 1
a4613 1
 * 
d4615 1
a4615 1
 * @@param dev The device to grab. 
d4619 1
a4619 1
 * 
d4623 4
a4626 3
GrabDevice(ClientPtr client, DeviceIntPtr dev, 
           unsigned this_mode, unsigned other_mode, Window grabWindow, 
           unsigned ownerEvents, Time ctime, Mask mask, CARD8 *status)
d4633 1
d4662 1
a4662 1
    grab = dev->grab;
d4668 1
a4668 1
	     (CompareTimeStamps(time, dev->grabTime) == EARLIER))
d4670 2
a4671 2
    else if (dev->sync.frozen &&
	     dev->sync.other && !SameClient(dev->sync.other, client))
d4677 4
d4688 5
a4692 1
	(*dev->ActivateGrab)(dev, &tempGrab, time, FALSE);
d4701 1
a4701 1
 * Grabs the inputInfo.keyboad and returns success status to client.
d4709 1
d4713 4
a4716 4
    result = GrabDevice(client, inputInfo.keyboard, stuff->keyboardMode,
			stuff->pointerMode, stuff->grabWindow,
			stuff->ownerEvents, stuff->time,
			KeyPressMask | KeyReleaseMask, &rep.status);
d4730 1
a4730 1
 * Deletes a possible grab on the inputInfo.keyboard.
d4735 1
a4735 1
    DeviceIntPtr device = inputInfo.keyboard;
d4742 3
a4744 1
    grab = device->grab;
d4747 3
a4749 3
	(CompareTimeStamps(time, device->grabTime) != EARLIER) &&
	(grab) && SameClient(grab, client))
	(*device->DeactivateGrab)(device);
d4756 2
a4757 1
 * Returns the current state and position of the core pointer to the client. 
d4764 2
a4765 1
    DeviceIntPtr mouse = inputInfo.pointer;
d4777 1
d4784 3
a4786 3
    rep.root = (ROOT)->drawable.id;
    rep.rootX = sprite.hot.x;
    rep.rootY = sprite.hot.y;
d4788 1
a4788 1
    if (sprite.hot.pScreen == pWin->drawable.pScreen)
d4791 3
a4793 3
	rep.winX = sprite.hot.x - pWin->drawable.x;
	rep.winY = sprite.hot.y - pWin->drawable.y;
	for (t = sprite.win; t; t = t->parent)
d4820 1
a4820 1
    return(Success);    
a4831 1
    sprite.hot.pScreen = sprite.hotPhys.pScreen = (ScreenPtr)NULL;
d4837 3
a4839 1
    if (spriteTraceSize == 0)
d4841 1
a4841 4
	spriteTraceSize = 32;
	spriteTrace = (WindowPtr *)xalloc(32*sizeof(WindowPtr));
	if (!spriteTrace)
	    FatalError("failed to allocate spriteTrace");
d4843 1
a4843 13
    spriteTraceGood = 0;
    lastEventMask = OwnerGrabButtonMask;
    filters[MotionNotify] = PointerMotionMask;
#ifdef XEVIE
    xeviewin =
#endif
    sprite.win = NullWindow;
    sprite.current = NullCursor;
    sprite.hotLimits.x1 = 0;
    sprite.hotLimits.y1 = 0;
    sprite.hotLimits.x2 = 0;
    sprite.hotLimits.y2 = 0;
    sprite.confined = FALSE;
d4864 5
d4874 6
a4879 3
  xfree(spriteTrace);
  spriteTrace = NULL;
  spriteTraceSize = 0;
d4885 1
a4885 1
 * Locates the window to send the event to and forwards the event. 
d4892 1
d4901 1
a4901 1
	     stuff->event.u.u.type < LASTEvent) || 
d4923 1
a4923 1
	pWin = sprite.win;
d4933 2
a4934 2
   	if (inputFocus == PointerRootWin)
	    inputFocus = ROOT;
d4936 1
a4936 1
	if (IsParent(inputFocus, sprite.win))
d4939 1
a4939 1
	    pWin = sprite.win;
d4962 2
a4963 2
	    if (DeliverEventsToWindow(pWin, &stuff->event, 1, stuff->eventMask,
				      NullGrab, 0))
d4973 2
a4974 2
	(void)DeliverEventsToWindow(pWin, &stuff->event, 1, stuff->eventMask,
				    NullGrab, 0);
d4981 2
a4982 2
 * Deletes a passive grab for the given key. Only works on the
 * inputInfo.keyboard.
d4990 1
a4990 1
    DeviceIntPtr keybd = inputInfo.keyboard;
d5020 1
d5030 2
a5031 2
 * Creates a grab for the inputInfo.keyboard and adds it to the list of
 * passive grabs. 
d5039 1
a5039 1
    DeviceIntPtr keybd = inputInfo.keyboard;
d5077 1
a5077 1
    grab = CreateGrab(client->index, keybd, pWin, 
d5080 1
a5080 1
	keybd, stuff->modifiers, KeyPress, stuff->key, 
d5091 2
a5092 2
 * Creates a grab for the inputInfo.pointer and adds it as a passive grab to
 * the list.
d5101 1
d5149 1
a5149 1
	rc = dixLookupResource((pointer *)&cursor, stuff->cursor, RT_CURSOR,
d5159 3
d5165 1
a5165 1
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.pointer, access_mode);
d5169 1
a5169 1
    grab = CreateGrab(client->index, inputInfo.pointer, pWin, 
d5172 1
a5172 1
        inputInfo.keyboard, stuff->modifiers, ButtonPress,
d5182 1
a5182 1
 * Deletes a passive grab on the inputInfo.pointer from the list.
d5203 1
a5203 1
    tempGrab.device = inputInfo.pointer;
d5211 1
d5235 1
a5235 1
    FocusClassPtr	focus = keybd->focus;
d5238 1
d5243 4
a5247 3
    if (mouse->grab &&
	((mouse->grab->window == pWin) || (mouse->grab->confineTo == pWin)))
	(*mouse->DeactivateGrab)(mouse);
d5250 11
a5261 2
    if (keybd->grab && (keybd->grab->window == pWin))
	(*keybd->DeactivateGrab)(keybd);
d5263 1
a5263 4
    /* If the focus window is a root window (ie. has no parent) then don't 
	delete the focus from it. */
    
    if ((pWin == focus->win) && (pWin->parent != NullWindow))
d5265 3
a5267 3
	int focusEventMode = NotifyNormal;

 	/* If a grab is in progress, then alter the mode of focus events. */
d5269 2
a5270 2
	if (keybd->grab)
	    focusEventMode = NotifyWhileGrabbed;
d5272 29
a5300 20
	switch (focus->revert)
	{
	case RevertToNone:
	    DoFocusEvents(keybd, pWin, NoneWin, focusEventMode);
	    focus->win = NoneWin;
	    focus->traceGood = 0;
	    break;
	case RevertToParent:
	    parent = pWin;
	    do
	    {
		parent = parent->parent;
		focus->traceGood--;
	    } while (!parent->realized
/* This would be a good protocol change -- windows being reparented
   during SaveSet processing would cause the focus to revert to the
   nearest enclosing window which will survive the death of the exiting
   client, instead of ending up reverting to a dying window and thence
   to None
 */
d5302 1
a5302 1
 	      || clients[CLIENT_ID(parent->drawable.id)]->clientGone
d5304 19
a5322 11
		);
	    DoFocusEvents(keybd, pWin, parent, focusEventMode);
	    focus->win = parent;
	    focus->revert = RevertToNone;
	    break;
	case RevertToPointerRoot:
	    DoFocusEvents(keybd, pWin, PointerRootWin, focusEventMode);
	    focus->win = PointerRootWin;
	    focus->traceGood = 0;
	    break;
	}
a5324 3
    if (mouse->valuator->motionHintWindow == pWin)
	mouse->valuator->motionHintWindow = NullWindow;

d5334 1
a5334 1
#ifdef XINPUT
a5335 1
#endif
d5346 1
a5346 1
    GrabPtr grab = inputInfo.pointer->grab;
d5348 1
d5354 1
a5354 1
    if (grab && (confineTo = grab->confineTo))
d5356 11
a5366 4
	if (!BorderSizeNotEmpty(confineTo))
	    (*inputInfo.pointer->DeactivateGrab)(inputInfo.pointer);
	else if ((pWin == confineTo) || IsParent(pWin, confineTo))
	    ConfineCursorToWindow(confineTo, TRUE, TRUE);
d5394 2
a5395 1
    Bool 	displayed;
d5399 1
a5399 1
    rc = dixLookupResource((pointer *)&pCursor, stuff->cursor, RT_CURSOR,
d5420 1
a5420 1
	    displayed = (pscr == sprite.screen);
d5423 3
a5425 3
	    displayed = (pscr == sprite.hotPhys.pScreen);
	( *pscr->RecolorCursor)(pscr, pCursor,
				(pCursor == sprite.current) && displayed);
d5436 1
a5436 1
 * can be more than one. Usually it's just one event. 
d5439 1
a5439 1
 * 
d5450 3
a5452 2
    xEvent    eventTo, *eventFrom;
    int       i;
d5460 2
a5461 2
    if(!noPanoramiXExtension && 
       (panoramiXdataPtr[0].x || panoramiXdataPtr[0].y)) 
d5471 1
a5471 1
	/* 
d5473 2
a5474 2
	   passes the same event structure multiple times so we can't 
	   modify the one passed to us 
d5480 2
a5481 2
	    if(eventCopy.u.keyButtonPointer.event == 
	       eventCopy.u.keyButtonPointer.root) 
d5508 17
a5524 1
#endif	
d5527 11
d5541 2
d5546 3
a5548 2
		(eventFrom, &eventTo);
	    (void)WriteToClient(pClient, sizeof(xEvent), (char *)&eventTo);
d5553 209
a5761 1
	(void)WriteToClient(pClient, count * sizeof(xEvent), (char *) events);
d5763 13
d5777 1
@


1.1
log
@Initial revision
@
text
@d110 4
d120 1
d139 2
a140 1
#include <X11/extensions/XKBsrv.h>
a143 1
#ifdef XACE
d145 5
a162 1
xEvent *xeviexE;
d166 1
d168 1
d174 3
a176 1

d222 22
a243 3
#ifdef DEBUG
static debug_events = 0;
#endif
d258 2
d266 5
d307 3
a363 1

a364 1
static void SyntheticMotion(int x, int y);
d367 7
d697 7
a722 24
static void
SyntheticMotion(int x, int y)
{
    xEvent xE;

#ifdef PANORAMIX
    /* Translate back to the sprite screen since processInputProc
       will translate from sprite screen to screen 0 upon reentry
       to the DIX layer */
    if(!noPanoramiXExtension) {
	x += panoramiXdataPtr[0].x - panoramiXdataPtr[sprite.screen->myNum].x;
	y += panoramiXdataPtr[0].y - panoramiXdataPtr[sprite.screen->myNum].y;
    }
#endif
    xE.u.keyButtonPointer.rootX = x;
    xE.u.keyButtonPointer.rootY = y;
    if (syncEvents.playingEvents)
	xE.u.keyButtonPointer.time = syncEvents.time.milliseconds;
    else
	xE.u.keyButtonPointer.time = currentTime.milliseconds;
    xE.u.u.type = MotionNotify;
    (*inputInfo.pointer->public.processInputProc)(&xE, inputInfo.pointer, 1);
}

d808 2
a809 2
    register QdEventPtr qe,
    register WindowPtr pWin)
d891 1
a891 1
PointerConfinedToScreen()
d896 7
d927 3
a929 1
/* returns true if b is a descendent of a */
d931 1
a931 1
IsParent(register WindowPtr a, register WindowPtr b)
d938 5
d946 2
a947 2
    register    WindowPtr win;
    register    GrabPtr grab = inputInfo.pointer->grab;
d973 3
d977 1
a977 1
GetCurrentRootWindow()
d982 3
d986 1
a986 1
GetSpriteWindow()
d991 3
d995 1
a995 1
GetSpriteCursor()
d1000 3
d1012 1
a1012 1
XineramaGetCursorScreen()
d1025 1
a1025 1
MonthChangedOrBadTime(register xEvent *xE)
d1044 1
a1044 1
NoticeEventTime(register xEvent *xE)
d1057 2
a1058 2
    register QdEventPtr tail = *syncEvents.pendtail;
    register QdEventPtr qe;
d1101 1
a1101 1
	/* do motion compression */
d1104 1
d1133 2
a1134 2
    register QdEventPtr *prev, qe;
    register DeviceIntPtr dev;
d1178 1
a1178 1
FreezeThaw(register DeviceIntPtr dev, Bool frozen)
d1187 2
a1188 2
void
ComputeFreezes()
d1190 2
a1191 2
    register DeviceIntPtr replayDev = syncEvents.replayDev;
    register int i;
d1193 1
a1193 1
    register xEvent *xE;
d1196 1
a1196 1
    register DeviceIntPtr dev;
d1271 2
a1272 2
void
CheckGrabForSyncs(register DeviceIntPtr thisDev, Bool thisMode, Bool otherMode)
d1274 2
a1275 2
    register GrabPtr grab = thisDev->grab;
    register DeviceIntPtr dev;
d1305 13
d1319 1
a1319 1
ActivatePointerGrab(register DeviceIntPtr mouse, register GrabPtr grab, 
d1346 6
d1353 1
a1353 1
DeactivatePointerGrab(register DeviceIntPtr mouse)
d1355 2
a1356 2
    register GrabPtr grab = mouse->grab;
    register DeviceIntPtr dev;
d1376 5
d1382 1
a1382 1
ActivateKeyboardGrab(register DeviceIntPtr keybd, GrabPtr grab, TimeStamp time, Bool passive)
d1407 3
d1411 1
a1411 1
DeactivateKeyboardGrab(register DeviceIntPtr keybd)
d1413 3
a1415 3
    register GrabPtr grab = keybd->grab;
    register DeviceIntPtr dev;
    register WindowPtr focusWin = keybd->focus ? keybd->focus->win
d1439 1
a1439 1
    register DeviceIntPtr dev;
d1542 5
d1548 1
a1548 1
ProcAllowEvents(register ClientPtr client)
d1590 3
d1596 1
a1596 1
    register DeviceIntPtr dev;
d1619 24
d1650 2
a1651 3
#ifdef DEBUG
    if (debug_events) ErrorF(
	"Event([%d, %d], mask=0x%x), client=%d",
d1667 3
a1669 3
#ifdef DEBUG
		    if (debug_events) ErrorF("\n");
	    fprintf(stderr,"motionHintWindow == keyButtonPointer.event\n");
d1707 2
a1708 2
#ifdef DEBUG
	if (debug_events) ErrorF(  " delivered\n");
d1714 2
a1715 2
#ifdef DEBUG
	if (debug_events) ErrorF("\n");
d1721 17
d1739 1
a1739 1
DeliverEventsToWindow(register WindowPtr pWin, xEvent *pEvents, int count, 
d1744 1
a1744 1
    register InputClients *other;
d1757 4
a1760 2
	if ( (attempt = TryClientEvents(wClient(pWin), pEvents, count,
				      pWin->eventMask, filter, grab)) )
d1787 4
a1790 1
	    if ( (attempt = TryClientEvents(rClient(other), pEvents, count,
d1862 9
d1872 1
a1872 1
MaybeDeliverEventsToClient(register WindowPtr pWin, xEvent *pEvents, 
d1875 1
a1875 1
    register OtherClients *other;
d1887 2
d1903 3
d1913 8
d1975 16
d1992 2
a1993 2
DeliverDeviceEvents(register WindowPtr pWin, register xEvent *xE, GrabPtr grab, 
                    register WindowPtr stopAt, DeviceIntPtr dev, int count)
d2000 3
d2005 1
a2005 1
	register OtherInputMasks *inputMasks;
d2057 13
a2069 1
/* not useful for events that propagate up the tree or extension events */
d2071 2
a2072 2
DeliverEvents(register WindowPtr pWin, register xEvent *xE, int count, 
              register WindowPtr otherParent)
d2134 11
d2148 1
a2148 1
    register WindowPtr  pWin;
d2193 6
d2271 4
d2276 1
a2276 1
WindowsRestructured()
d2320 4
d2325 1
a2325 1
DefineInitialRootWindow(register WindowPtr win)
d2327 1
a2327 1
    register ScreenPtr pScreen = win->drawable.pScreen;
d2369 55
d2516 1
a2516 1
    int		x, y;
d2521 4
a2524 5
    if (stuff->dstWid != None)
    {
	dest = SecurityLookupWindow(stuff->dstWid, client, SecurityReadAccess);
	if (!dest)
	    return BadWindow;
d2535 3
a2537 2
	source = SecurityLookupWindow(winID, client, SecurityReadAccess);
	if (!source) return BadWindow;
d2585 4
d2593 1
a2593 1
    int		x, y;
d2595 1
a2595 1

a2596 1

d2599 7
d2611 4
a2614 5
    if (stuff->dstWid != None)
    {
	dest = SecurityLookupWindow(stuff->dstWid, client, SecurityReadAccess);
	if (!dest)
	    return BadWindow;
d2625 3
a2627 2
	source = SecurityLookupWindow(winID, client, SecurityReadAccess);
	if (!source) return BadWindow;
d2703 10
a2712 2
/* "CheckPassiveGrabsOnWindow" checks to see if the event passed in causes a
	passive grab set on the window to be activated. */
d2717 2
a2718 2
    register DeviceIntPtr device,
    register xEvent *xE,
d2721 1
a2721 1
    register GrabPtr grab = wPassiveGrabs(pWin);
d2723 1
a2723 1
    register xEvent *dxE;
a2766 4
#ifdef XACE
	    if (!XaceHook(XACE_DEVICE_ACCESS, wClient(pWin), device, FALSE))
		return FALSE;
#endif
d2804 20
a2823 10
"CheckDeviceGrabs" handles both keyboard and pointer events that may cause
a passive grab to be activated.  If the event is a keyboard event, the
ancestors of the focus window are traced down and tried to see if they have
any passive grabs to be activated.  If the focus window itself is reached and
it's descendants contain they pointer, the ancestors of the window that the
pointer is in are then traced down starting at the focus window, otherwise no
grabs are activated.  If the event is a pointer event, the ancestors of the
window that the pointer is in are traced down starting at the root until
CheckPassiveGrabs causes a passive grab to activate or all the windows are
tried. PRH
d2827 1
a2827 1
CheckDeviceGrabs(register DeviceIntPtr device, register xEvent *xE, 
d2830 3
a2832 3
    register int i;
    register WindowPtr pWin = NULL;
    register FocusClassPtr focus = device->focus;
d2870 10
d2900 2
d2910 7
d2918 1
a2918 1
DeliverGrabbedEvent(register xEvent *xE, register DeviceIntPtr thisDev, 
d2921 1
a2921 1
    register GrabPtr grab = thisDev->grab;
d2923 2
a2924 2
    register DeviceIntPtr dev;
    register xEvent *dxE;
d2951 8
a2958 3
	deliveries = TryClientEvents(rClient(grab), xE, count,
				     (Mask)grab->eventMask,
				     filters[xE->u.u.type], grab);
d3004 11
d3017 1
a3017 1
CoreProcessKeyboardEvent (register xEvent *xE, register DeviceIntPtr keybd, int count)
d3019 1
a3019 1
ProcessKeyboardEvent (register xEvent *xE, register DeviceIntPtr keybd, int count)
d3023 4
a3026 4
    register BYTE   *kptr;
    register int    i;
    register CARD8  modifiers;
    register CARD16 mask;
d3029 1
a3029 1
    register KeyClassPtr keyc = keybd->key;
a3107 7
#ifdef DEBUG
    if ((xkbDebugFlags&0x4)&&
	((xE->u.u.type==KeyPress)||(xE->u.u.type==KeyRelease))) {
	ErrorF("CoreProcessKbdEvent: Key %d %s\n",key,
			(xE->u.u.type==KeyPress?"down":"up"));
    }
#endif
a3171 1
#ifdef XACE
a3172 1
#endif
d3178 1
a3178 1
   CoreProcessKeyEvent to be called, as in for example Mouse Keys.
d3181 1
a3181 1
FixKeyState (register xEvent *xE, register DeviceIntPtr keybd)
d3184 2
a3185 2
    register BYTE   *kptr;
    register KeyClassPtr keyc = keybd->key;
d3190 6
a3195 5
#ifdef DEBUG
    if ((xkbDebugFlags&0x4)&&
	((xE->u.u.type==KeyPress)||(xE->u.u.type==KeyRelease))) {
	ErrorF("FixKeyState: Key %d %s\n",key,
			(xE->u.u.type==KeyPress?"down":"up"));
d3197 2
a3198 4
#endif
    switch (xE->u.u.type)
    {
	case KeyPress: 
d3200 1
a3200 2
	    break;
	case KeyRelease: 
d3202 2
a3203 4
	    break;
	default: 
	    FatalError("Impossible keyboard event");
    }
d3207 12
d3221 1
a3221 1
CoreProcessPointerEvent (register xEvent *xE, register DeviceIntPtr mouse, int count)
d3223 1
a3223 1
ProcessPointerEvent (register xEvent *xE, register DeviceIntPtr mouse, int count)
d3226 1
a3226 1
    register GrabPtr	grab = mouse->grab;
d3228 1
a3228 1
    register ButtonClassPtr butc = mouse->button;
d3272 2
a3273 2
	register int  key;
	register BYTE *kptr;
d3315 1
a3315 1
	    FatalError("bogus pointer event from ddx");
d3331 2
d3334 12
d3348 1
a3348 1
    register WindowPtr pWin;
d3350 2
a3351 2
    register OtherClients *others;
    register WindowPtr pChild;
d3390 2
a3391 2
    register OtherClientsPtr other, prev;
    register WindowPtr pWin = (WindowPtr)value;
d3417 1
a3417 1
EventSelectForWindow(register WindowPtr pWin, register ClientPtr client, Mask mask)
d3421 1
d3428 7
a3453 4
#ifdef SGIMISC
	pWin->eventMask =
	    (mask & ~SGIMiscSpecialDestroyMask) | (pWin->eventMask & SGIMiscSpecialDestroyMask);
#else
a3454 1
#endif
a3462 3
#ifdef SGIMISC
		mask = (mask & ~SGIMiscSpecialDestroyMask) | (others->mask & SGIMiscSpecialDestroyMask);
#endif
d3497 1
a3497 1
EventSuppressForWindow(register WindowPtr pWin, register ClientPtr client, 
d3500 1
a3500 1
    register int i, free;
d3552 3
d3557 2
a3558 2
    register WindowPtr a,
    register WindowPtr b)
d3565 4
d3574 1
a3574 1
    register WindowPtr pWin,
d3578 1
a3578 1
    register DeviceIntPtr keybd = inputInfo.keyboard;
d3580 2
a3581 2
    register DeviceIntPtr mouse = inputInfo.pointer;
    register GrabPtr	grab = mouse->grab;
a3633 2

#ifdef XACE
d3636 1
a3636 2
	if (!XaceHook(XACE_DEVICE_ACCESS, client, keybd, FALSE))
	{
a3637 1
	}
d3639 2
a3640 2
#endif
	memmove((char *)&ke.map[0], (char *)&keybd->key->down[1], 31);
d3651 4
d3666 5
d3674 1
a3674 1
    register WindowPtr  pWin;
d3685 7
d3721 1
a3721 1
FocusEvent(DeviceIntPtr dev, int type, int mode, int detail, register WindowPtr pWin)
a3741 1
#ifdef XACE
d3743 1
a3743 2
	if (!XaceHook(XACE_DEVICE_ACCESS, client, dev, FALSE))
	{
a3744 1
	}
d3746 2
a3747 2
#endif
	memmove((char *)&ke.map[0], (char *)&dev->key->down[1], 31);
d3791 1
a3791 1
    register WindowPtr  pWin;
d3925 17
d3951 3
a3953 3
    register FocusClassPtr focus;
    register WindowPtr focusWin;
    int mode;
d3970 4
a3973 5
    else if (!(focusWin = SecurityLookupWindow(focusID, client,
					       SecurityReadAccess)))
	return BadWindow;
    else
    {
a3975 1

d3979 4
d4003 1
a4003 1
	register WindowPtr pWin;
d4022 5
d4034 1
a4034 4
#ifdef XACE
    if (!XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
	return Success;
#endif
d4039 6
d4049 2
d4052 6
a4057 1
    FocusClassPtr focus = inputInfo.keyboard->focus;
a4058 1
    REQUEST_SIZE_MATCH(xReq);
d4072 6
d4088 2
d4115 3
a4117 3
    pWin = SecurityLookupWindow(stuff->grabWindow, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4122 4
a4125 4
	confineTo = SecurityLookupWindow(stuff->confineTo, client,
					 SecurityReadAccess);
	if (!confineTo)
	    return BadWindow;
d4131 3
a4133 3
	cursor = (CursorPtr)SecurityLookupIDByType(client, stuff->cursor,
						RT_CURSOR, SecurityReadAccess);
	if (!cursor)
d4136 1
a4136 1
	    return BadCursor;
d4138 1
d4140 7
d4194 8
d4206 1
a4206 1
    register GrabPtr grab = device->grab;
d4221 3
a4223 3
	newCursor = (CursorPtr)SecurityLookupIDByType(client, stuff->cursor,
						RT_CURSOR, SecurityReadAccess);
	if (!newCursor)
d4226 1
a4226 1
	    return BadCursor;
d4248 5
d4272 18
d4291 1
a4291 1
GrabDevice(register ClientPtr client, register DeviceIntPtr dev, 
d4295 2
a4296 2
    register WindowPtr pWin;
    register GrabPtr grab;
d4298 2
d4317 10
a4326 3
    pWin = SecurityLookupWindow(grabWindow, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4356 5
d4369 1
a4369 8
#ifdef XACE
    if (!XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
    {
	result = Success;
	rep.status = AlreadyGrabbed;
    }
    else
#endif
d4374 1
d4384 5
d4408 5
d4418 2
d4421 8
a4428 1
    DeviceIntPtr mouse = inputInfo.pointer;
a4429 4
    REQUEST_SIZE_MATCH(xResourceReq);
    pWin = SecurityLookupWindow(stuff->id, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4475 4
d4480 1
a4480 1
InitEvents()
d4540 5
d4602 2
a4603 2
	pWin = SecurityLookupWindow(stuff->destination, client,
				    SecurityReadAccess);
d4616 3
d4629 1
a4629 1
    else
d4635 6
d4648 1
d4651 3
a4653 3
    pWin = SecurityLookupWindow(stuff->grabWindow, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4683 6
d4696 1
d4729 3
a4731 3
    pWin = SecurityLookupWindow(stuff->grabWindow, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4740 1
a4740 1
    return AddPassiveGrabToList(grab);
d4744 6
d4757 2
d4789 3
a4791 3
    pWin = SecurityLookupWindow(stuff->grabWindow, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4795 4
a4798 4
	confineTo = SecurityLookupWindow(stuff->confineTo, client,
					 SecurityReadAccess);
	if (!confineTo)
	    return BadWindow;
d4804 3
a4806 2
	cursor = (CursorPtr)SecurityLookupIDByType(client, stuff->cursor,
						RT_CURSOR, SecurityReadAccess);
d4810 1
a4810 1
	    return BadCursor;
d4812 1
d4814 6
a4819 1

d4828 1
a4828 1
    return AddPassiveGrabToList(grab);
d4831 5
d4842 1
d4851 3
a4853 3
    pWin = SecurityLookupWindow(stuff->grabWindow, client, SecurityReadAccess);
    if (!pWin)
	return BadWindow;
d4869 11
d4969 3
a4971 1
 * Call this whenever some window at or below pWin has changed geometry 
d4995 1
a4995 1
    register OtherClientsPtr	other;
d5007 3
d5014 1
a5014 1
    int		nscr;
d5020 3
a5022 3
    pCursor = (CursorPtr)SecurityLookupIDByType(client, stuff->cursor,
					RT_CURSOR, SecurityWriteAccess);
    if ( !pCursor) 
d5025 1
a5025 1
	return (BadCursor);
d5051 14
d5121 8
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a109 4
/** @@file
 * This file handles event delivery and a big part of the server-side protocol
 * handling (the parts for input devices).
 */
a115 1
#include <X11/keysym.h>
d134 1
a134 2
#include <X11/extensions/XKBproto.h>
#include <xkbsrv.h>
d138 1
a139 5

#ifdef XSERVER_DTRACE
#include <sys/types.h>
typedef const char *string;
#include "Xserver-dtrace.h"
d153 1
a156 1
#include "exglobals.h"
a157 1
#include "exglobals.h"
d163 1
a163 3
/**
 * Extension events type numbering starts at EXTENSION_EVENT_BASE.
 */
d209 3
a211 22
/**
 * Main input device struct. 
 *     inputInfo.pointer 
 *     is the core pointer. Referred to as "virtual core pointer", "VCP",
 *     "core pointer" or inputInfo.pointer. There is exactly one core pointer,
 *     but multiple devices may send core events. If a device generates core
 *     events, those events will appear to originate from the core pointer.
 * 
 *     inputInfo.keyboard
 *     is the core keyboard ("virtual core keyboard", "VCK", "core keyboard").
 *     See inputInfo.pointer.
 * 
 *     inputInfo.devices
 *     linked list containing all devices including VCK and VCP. The VCK will
 *     always be the first entry, the VCP the second entry in the device list.
 *
 *     inputInfo.off_devices
 *     Devices that have not been initialized and are thus turned off.
 *
 *     inputInfo.numDevices
 *     Total number of devices.
 */
a225 2
 * 
 * @@see XYToWindow() for a documentation on how the array is set up.
a231 5
/**
 * DIX sprite information. This is the sprite as seen from the DIX. It does
 * not represent the actual sprite rendered to the screen.
 * 
 */
a267 3
/**
 * Max event opcode.
 */
d322 1
d324 1
a326 7
#define SyntheticMotion(x, y) \
    PostSyntheticMotion(x, y, noPanoramiXExtension ? 0 : \
                              sprite.screen->myNum, \
                        syncEvents.playingEvents ? \
                          syncEvents.time.milliseconds : \
                          currentTime.milliseconds);

a649 7
#else
#define SyntheticMotion(x, y) \
     PostSyntheticMotion(x, y, \
                         0, \
                         syncEvents.playingEvents ? \
                           syncEvents.time.milliseconds : \
                           currentTime.milliseconds);
d669 24
d778 2
a779 2
    QdEventPtr qe,
    WindowPtr pWin)
d861 1
a861 1
PointerConfinedToScreen(void)
a865 7
/**
 * Update the sprite cursor to the given cursor.
 *
 * ChangeToCursor() will display the new cursor and free the old cursor (if
 * applicable). If the provided cursor is already the updated cursor, nothing
 * happens.
 */
d890 1
a890 3
/**
 * @@returns true if b is a descendent of a 
 */
d892 1
a892 1
IsParent(WindowPtr a, WindowPtr b)
a898 5
/**
 * Update the cursor displayed on the screen.
 *
 * Called whenever a cursor may have changed shape or position.  
 */
d902 2
a903 2
    WindowPtr win;
    GrabPtr grab = inputInfo.pointer->grab;
a928 3
/**
 * @@return root window of current active screen.
 */
d930 1
a930 1
GetCurrentRootWindow(void)
a934 3
/**
 * @@return window underneath the cursor sprite.
 */
d936 1
a936 1
GetSpriteWindow(void)
a940 3
/**
 * @@return current sprite cursor.
 */
d942 1
a942 1
GetSpriteCursor(void)
a946 3
/**
 * Set x/y current sprite position in screen coordinates.
 */
d956 1
a956 1
XineramaGetCursorScreen(void)
d969 1
a969 1
MonthChangedOrBadTime(xEvent *xE)
d988 1
a988 1
NoticeEventTime(xEvent *xE)
d1001 2
a1002 2
    QdEventPtr tail = *syncEvents.pendtail;
    QdEventPtr qe;
d1076 2
a1077 2
    QdEventPtr *prev, qe;
    DeviceIntPtr dev;
d1121 1
a1121 1
FreezeThaw(DeviceIntPtr dev, Bool frozen)
d1131 1
a1131 1
ComputeFreezes(void)
d1133 2
a1134 2
    DeviceIntPtr replayDev = syncEvents.replayDev;
    int i;
d1136 1
a1136 1
    xEvent *xE;
d1139 1
a1139 1
    DeviceIntPtr dev;
d1215 1
a1215 1
CheckGrabForSyncs(DeviceIntPtr thisDev, Bool thisMode, Bool otherMode)
d1217 2
a1218 2
    GrabPtr grab = thisDev->grab;
    DeviceIntPtr dev;
a1247 13
/**
 * Activate a pointer grab on the given device. A pointer grab will cause all
 * core pointer events to be delivered to the grabbing client only. Can cause
 * the cursor to change if a grab cursor is set.
 * 
 * As a pointer grab can only be issued on the core devices, mouse is always
 * inputInfo.pointer. Extension devices are set up for ActivateKeyboardGrab().
 * 
 * @@param mouse The device to grab.
 * @@param grab The grab structure, needs to be setup.
 * @@param autoGrab True if the grab was caused by a button down event and not
 * explicitely by a client. 
 */
d1249 1
a1249 1
ActivatePointerGrab(DeviceIntPtr mouse, GrabPtr grab, 
a1275 6
/**
 * Delete grab on given device, update the sprite.
 *
 * As a pointer grab can only be issued on the core devices, mouse is always
 * inputInfo.pointer. Extension devices are set up for ActivateKeyboardGrab().
 */
d1277 1
a1277 1
DeactivatePointerGrab(DeviceIntPtr mouse)
d1279 2
a1280 2
    GrabPtr grab = mouse->grab;
    DeviceIntPtr dev;
a1299 5
/**
 * Activate a keyboard grab on the given device. 
 *
 * Extension devices have ActivateKeyboardGrab() set as their grabbing proc.
 */
d1301 1
a1301 1
ActivateKeyboardGrab(DeviceIntPtr keybd, GrabPtr grab, TimeStamp time, Bool passive)
a1325 3
/**
 * Delete keyboard grab for the given device. 
 */
d1327 1
a1327 1
DeactivateKeyboardGrab(DeviceIntPtr keybd)
d1329 3
a1331 3
    GrabPtr grab = keybd->grab;
    DeviceIntPtr dev;
    WindowPtr focusWin = keybd->focus ? keybd->focus->win
d1355 1
a1355 1
    DeviceIntPtr dev;
a1457 5
/**
 * Server-side protocol handling for AllowEvents request.
 *
 * Release some events from a frozen device. Only applicable for core devices.
 */
d1459 1
a1459 1
ProcAllowEvents(ClientPtr client)
a1500 3
/**
 * Deactivate grabs from any device that has been grabbed by the client.
 */
d1504 1
a1504 1
    DeviceIntPtr dev;
a1526 24
/**
 * Deliver the given events to the given client.
 *
 * More than one event may be delivered at a time. This is the case with
 * DeviceMotionNotifies which may be followed by DeviceValuator events.
 *
 * TryClientEvents() is the last station before actually writing the events to
 * the socket. Anything that is not filtered here, will get delivered to the
 * client. 
 * An event is only delivered if 
 *   - mask and filter match up.
 *   - no other client has a grab on the device that caused the event.
 * 
 *
 * @@param client The target client to deliver to.
 * @@param pEvents The events to be delivered.
 * @@param count Number of elements in pEvents.
 * @@param mask Event mask as set by the window.
 * @@param filter Mask based on event type.
 * @@param grab Possible grab on the device that caused the event. 
 *
 * @@return 1 if event was delivered, 0 if not or -1 if grab was not set by the
 * client.
 */
d1534 3
a1536 2
#ifdef DEBUG_EVENTS
    ErrorF("Event([%d, %d], mask=0x%x), client=%d",
d1552 3
a1554 3
#ifdef DEBUG_EVENTS
		    ErrorF("\n");
	    ErrorF("motionHintWindow == keyButtonPointer.event\n");
d1592 2
a1593 2
#ifdef DEBUG_EVENTS
	ErrorF(  " delivered\n");
d1599 2
a1600 2
#ifdef DEBUG_EVENTS
	ErrorF("\n");
a1605 17
/**
 * Deliver events to a window. At this point, we do not yet know if the event
 * actually needs to be delivered. May activate a grab if the event is a
 * button press.
 *
 * More than one event may be delivered at a time. This is the case with
 * DeviceMotionNotifies which may be followed by DeviceValuator events.
 * 
 * @@param pWin The window that would get the event.
 * @@param pEvents The events to be delivered.
 * @@param count Number of elements in pEvents.
 * @@param filter Mask based on event type.
 * @@param grab Possible grab on the device that caused the event. 
 * @@param mskidx Mask index, depending on device that caused event.
 *
 * @@return Number of events delivered to various clients.
 */
d1607 1
a1607 1
DeliverEventsToWindow(WindowPtr pWin, xEvent *pEvents, int count, 
d1612 1
a1612 1
    InputClients *other;
a1724 9
/**
 * Try to deliver events to the interested parties.
 *
 * @@param pWin The window that would get the event.
 * @@param pEvents The events to be delivered.
 * @@param count Number of elements in pEvents.
 * @@param filter Mask based on event type.
 * @@param dontClient Don't deliver to the dontClient.
 */
d1726 1
a1726 1
MaybeDeliverEventsToClient(WindowPtr pWin, xEvent *pEvents, 
d1729 1
a1729 1
    OtherClients *other;
a1761 8
/**
 * Adjust event fields to comply with the window properties.
 *
 * @@param xE Event to be modified in place
 * @@param pWin The window to get the information from.
 * @@param child Child window setting for event (if applicable)
 * @@param calcChild If True, calculate the child window.
 */
a1815 16
/**
 * Deliver events caused by input devices. Called for all core input events
 * and XI events. No filtering of events happens before DeliverDeviceEvents(),
 * it will be called for any event that comes out of the event queue.
 * 
 * For all core events, dev is either inputInfo.pointer or inputInfo.keyboard.
 * For all extension events, dev is the device that caused the event.
 *
 * @@param pWin Window to deliver event to.
 * @@param xE Events to deliver.
 * @@param grab Possible grab on a device.
 * @@param stopAt Don't recurse up to the root window.
 * @@param dev The device that is responsible for the event.
 * @@param count number of events in xE.
 *
 */
d1817 2
a1818 2
DeliverDeviceEvents(WindowPtr pWin, xEvent *xE, GrabPtr grab, 
                    WindowPtr stopAt, DeviceIntPtr dev, int count)
d1827 1
a1827 1
	OtherInputMasks *inputMasks;
d1879 1
a1879 13
/**
 * Deliver event to a window and it's immediate parent. Used for most window
 * events (CreateNotify, ConfigureNotify, etc.). Not useful for events that
 * propagate up the tree or extension events 
 *
 * In case of a ReparentNotify event, the event will be delivered to the
 * otherParent as well.
 *
 * @@param pWin Window to deliver events to.
 * @@param xE Events to deliver.
 * @@param count number of events in xE.
 * @@param otherParent Used for ReparentNotify events.
 */
d1881 2
a1882 2
DeliverEvents(WindowPtr pWin, xEvent *xE, int count, 
              WindowPtr otherParent)
a1943 11
/**
 * Traversed from the root window to the window at the position x/y. While
 * traversing, it sets up the traversal history in the spriteTrace array.
 * After completing, the spriteTrace history is set in the following way:
 *   spriteTrace[0] ... root window
 *   spriteTrace[1] ... top level window that encloses x/y
 *       ...
 *   spriteTrace[spriteTraceGood - 1] ... window at x/y
 *
 * @@returns the window at the given coordinates.
 */
d1947 1
a1947 1
    WindowPtr  pWin;
a1991 6
/**
 * Update the sprite coordinates based on the event. Update the cursor
 * position, then update the event with the new coordinates that may have been
 * changed. If the window underneath the sprite has changed, change to new
 * cursor and send enter/leave events.
 */
a2063 4
/**
 * Windows have restructured, we need to update the sprite position and the
 * sprite's cursor.
 */
d2065 1
a2065 1
WindowsRestructured(void)
a2108 4
/**
 * Set the given window to sane values, display the cursor in the center of
 * the screen. Called from main() with the root window on the first screen.
 */
d2110 1
a2110 1
DefineInitialRootWindow(WindowPtr win)
d2112 1
a2112 1
    ScreenPtr pScreen = win->drawable.pScreen;
d2246 1
a2246 1
    int		x, y, rc;
d2251 5
a2255 4
    if (stuff->dstWid != None) {
	rc = dixLookupWindow(&dest, stuff->dstWid, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d2266 2
a2267 3
	rc = dixLookupWindow(&source, winID, client, DixReadAccess);
	if (rc != Success)
	    return rc;
a2314 4
/**
 * Server-side protocol handling for WarpPointer request.
 * Warps the cursor position to the coordinates given in the request.
 */
d2319 1
a2319 1
    int		x, y, rc;
d2331 5
a2335 4
    if (stuff->dstWid != None) {
	rc = dixLookupWindow(&dest, stuff->dstWid, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d2346 2
a2347 3
	rc = dixLookupWindow(&source, winID, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d2423 2
a2424 10
/** 
 * "CheckPassiveGrabsOnWindow" checks to see if the event passed in causes a
 * passive grab set on the window to be activated. 
 * If a passive grab is activated, the event will be delivered to the client.
 * 
 * @@param pWin The window that may be subject to a passive grab.
 * @@param device Device that caused the event.
 * @@param xE List of events (multiple ones for DeviceMotionNotify)
 * @@count number of elements in xE.
 */
d2429 2
a2430 2
    DeviceIntPtr device,
    xEvent *xE,
d2433 1
a2433 1
    GrabPtr grab = wPassiveGrabs(pWin);
d2435 1
a2435 1
    xEvent *dxE;
d2479 1
d2482 1
d2520 10
a2529 20
 * CheckDeviceGrabs handles both keyboard and pointer events that may cause
 * a passive grab to be activated.  
 *
 * If the event is a keyboard event, the ancestors of the focus window are
 * traced down and tried to see if they have any passive grabs to be
 * activated.  If the focus window itself is reached and it's descendants
 * contain the pointer, the ancestors of the window that the pointer is in
 * are then traced down starting at the focus window, otherwise no grabs are
 * activated.  
 * If the event is a pointer event, the ancestors of the window that the
 * pointer is in are traced down starting at the root until CheckPassiveGrabs
 * causes a passive grab to activate or all the windows are
 * tried. PRH
 *
 * If a grab is activated, the event has been sent to the client already!
 *
 * @@param device The device that caused the event.
 * @@param xE The event to handle (most likely {Device}ButtonPress).
 * @@param count Number of events in list.
 * @@return TRUE if a grab has been activated or false otherwise.
d2533 1
a2533 1
CheckDeviceGrabs(DeviceIntPtr device, xEvent *xE, 
d2536 3
a2538 3
    int i;
    WindowPtr pWin = NULL;
    FocusClassPtr focus = device->focus;
a2575 10
/**
 * Called for keyboard events to deliver event to whatever client owns the
 * focus. Event is delivered to the keyboard's focus window, the root window
 * or to the window owning the input focus.
 *
 * @@param keybd The keyboard originating the event.
 * @@param xE The event list.
 * @@param window Window underneath the sprite.
 * @@param count number of events in xE.
 */
a2603 7
/**
 * Deliver an event from a device that is currently grabbed. Uses
 * DeliverDeviceEvents() for further delivery if a ownerEvents is set on the
 * grab. If not, TryClientEvents() is used.
 *
 * @@param deactivateGrab True if the device's grab should be deactivated.
 */
d2605 1
a2605 1
DeliverGrabbedEvent(xEvent *xE, DeviceIntPtr thisDev, 
d2608 1
a2608 1
    GrabPtr grab = thisDev->grab;
d2610 2
a2611 2
    DeviceIntPtr dev;
    xEvent *dxE;
a2685 11
/**
 * Main keyboard event processing function for core keyboard events. 
 * Updates the events fields from the current pointer state and delivers the
 * event.
 *
 * For key events, xE will always be a single event.
 *
 * @@param xE Event list
 * @@param keybd The device that caused an event.
 * @@param count Number of elements in xE.
 */
d2688 1
a2688 1
CoreProcessKeyboardEvent (xEvent *xE, DeviceIntPtr keybd, int count)
d2690 1
a2690 1
ProcessKeyboardEvent (xEvent *xE, DeviceIntPtr keybd, int count)
d2694 4
a2697 4
    BYTE   *kptr;
    int    i;
    CARD8  modifiers;
    CARD16 mask;
d2700 1
a2700 1
    KeyClassPtr keyc = keybd->key;
d2779 7
d2850 1
d2852 1
d2861 1
a2861 1
FixKeyState (xEvent *xE, DeviceIntPtr keybd)
d2864 2
a2865 2
    BYTE   *kptr;
    KeyClassPtr keyc = keybd->key;
d2870 4
a2873 3

    if (((xE->u.u.type==KeyPress)||(xE->u.u.type==KeyRelease))) {
	DebugF("FixKeyState: Key %d %s\n",key,
d2876 1
a2876 1

a2890 12
/** 
 * Main pointer event processing function for core pointer events. 
 * For motion events: update the sprite.
 * For all other events: Update the event fields based on the current sprite
 * state.
 *
 * For core pointer events, xE will always be a single event.
 *
 * @@param xE Event list
 * @@param mouse The device that caused an event.
 * @@param count Number of elements in xE.
 */
d2893 1
a2893 1
CoreProcessPointerEvent (xEvent *xE, DeviceIntPtr mouse, int count)
d2895 1
a2895 1
ProcessPointerEvent (xEvent *xE, DeviceIntPtr mouse, int count)
d2898 1
a2898 1
    GrabPtr	grab = mouse->grab;
d2900 1
a2900 1
    ButtonClassPtr butc = mouse->button;
d2944 2
a2945 2
	int  key;
	BYTE *kptr;
a3003 12
/**
 * Recalculate which events may be deliverable for the given window.
 * Recalculated mask is used for quicker determination which events may be
 * delivered to a window.
 *
 * The otherEventMasks on a WindowOptional is the combination of all event
 * masks set by all clients on the window.
 * deliverableEventMask is the combination of the eventMask and the
 * otherEventMask.
 *
 * Traverses to siblings and parents of the window.
 */
d3006 1
a3006 1
    WindowPtr pWin;
d3008 2
a3009 2
    OtherClients *others;
    WindowPtr pChild;
d3048 2
a3049 2
    OtherClientsPtr other, prev;
    WindowPtr pWin = (WindowPtr)value;
d3075 1
a3075 1
EventSelectForWindow(WindowPtr pWin, ClientPtr client, Mask mask)
d3104 4
d3109 1
d3118 3
d3155 1
a3155 1
EventSuppressForWindow(WindowPtr pWin, ClientPtr client, 
d3158 1
a3158 1
    int i, free;
a3209 3
/**
 * @@return The window that is the first ancestor of both a and b.
 */
d3212 2
a3213 2
    WindowPtr a,
    WindowPtr b)
a3219 4
/**
 * Assembles an EnterNotify or LeaveNotify and sends it event to the client. 
 * The core devices are used to fill in the event fields.
 */
d3225 1
a3225 1
    WindowPtr pWin,
d3229 1
a3229 1
    DeviceIntPtr keybd = inputInfo.keyboard;
d3231 2
a3232 2
    DeviceIntPtr mouse = inputInfo.pointer;
    GrabPtr	grab = mouse->grab;
d3285 2
d3289 4
a3292 2
	if (XaceHook(XACE_DEVICE_ACCESS, client, keybd, FALSE))
	    memmove((char *)&ke.map[0], (char *)&keybd->key->down[1], 31);
d3294 2
a3295 2
	    bzero((char *)&ke.map[0], 31);

a3305 4
/**
 * Send enter notifies to all parent windows up to ancestor.
 * This function recurses.
 */
a3316 5

/**
 * Send leave notifies to all parent windows up to ancestor.
 * This function recurses.
 */
d3320 1
a3320 1
    WindowPtr  pWin;
a3330 7
/**
 * Figure out if enter/leave events are necessary and send them to the
 * appropriate windows.
 * 
 * @@param fromWin Window the sprite moved out of.
 * @@param toWin Window the sprite moved into.
 */
d3360 1
a3360 1
FocusEvent(DeviceIntPtr dev, int type, int mode, int detail, WindowPtr pWin)
d3381 1
d3383 4
a3386 2
	if (XaceHook(XACE_DEVICE_ACCESS, client, dev, FALSE))
	    memmove((char *)&ke.map[0], (char *)&dev->key->down[1], 31);
d3388 2
a3389 2
	    bzero((char *)&ke.map[0], 31);

d3433 1
a3433 1
    WindowPtr  pWin;
a3566 17
/**
 * Set the input focus to the given window. Subsequent keyboard events will be
 * delivered to the given window.
 * 
 * Usually called from ProcSetInputFocus as result of a client request. If so,
 * the device is the inputInfo.keyboard.
 * If called from ProcXSetInputFocus as result of a client xinput request, the
 * device is set to the device specified by the client.
 *
 * @@param client Client that requested input focus change.
 * @@param dev Focus device. 
 * @@param focusID The window to obtain the focus. Can be PointerRoot or None.
 * @@param revertTo Specifies where the focus reverts to when window becomes
 * unviewable.
 * @@param ctime Specifies the time.
 * @@param followOK True if pointer is allowed to follow the keyboard.
 */
d3576 3
a3578 3
    FocusClassPtr focus;
    WindowPtr focusWin;
    int mode, rc;
d3595 5
a3599 4
    else {
	rc = dixLookupWindow(&focusWin, focusID, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d3602 1
d3626 1
a3626 1
	WindowPtr pWin;
a3644 5
/**
 * Server-side protocol handling for SetInputFocus request.
 *
 * Sets the input focus for the virtual core keyboard.
 */
d3652 1
a3652 1

d3655 1
a3655 1

a3659 6
/**
 * Server-side protocol handling for GetInputFocus request.
 * 
 * Sends the current input focus for the virtual core keyboard back to the
 * client.
 */
a3680 6
/**
 * Server-side protocol handling for Grabpointer request.
 *
 * Sets an active grab on the inputInfo.pointer and returns success status to
 * client.
 */
a3690 1
    int rc;
d3716 3
a3718 3
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
    if (rc != Success)
	return rc;
d3723 4
a3726 4
	rc = dixLookupWindow(&confineTo, stuff->confineTo, client,
			     DixReadAccess);
	if (rc != Success)
	    return rc;
d3733 1
a3733 1
						RT_CURSOR, DixReadAccess);
a3786 8
/**
 * Server-side protocol handling for ChangeActivePointerGrab request.
 *
 * Changes properties of the grab hold by the client. If the client does not
 * hold an active grab on the device, nothing happens. 
 *
 * Works on the core pointer only.
 */
d3791 1
a3791 1
    GrabPtr grab = device->grab;
d3807 1
a3807 1
						RT_CURSOR, DixReadAccess);
a3832 5
/**
 * Server-side protocol handling for UngrabPointer request.
 *
 * Deletes the pointer grab on the core pointer device.
 */
a3851 18
/**
 * Sets a grab on the given device.
 * 
 * Called from ProcGrabKeyboard to work on the inputInfo.keyboard.
 * Called from ProcXGrabDevice to work on the device specified by the client.
 * 
 * The parameters this_mode and other_mode represent the keyboard_mode and
 * pointer_mode parameters of XGrabKeyboard(). 
 * See man page for details on all the parameters
 * 
 * @@param client Client that owns the grab.
 * @@param dev The device to grab. 
 * @@param this_mode GrabModeSync or GrabModeAsync
 * @@param other_mode GrabModeSync or GrabModeAsync
 * @@param status Return code to be returned to the caller.
 * 
 * @@returns Success or BadValue.
 */
d3853 1
a3853 1
GrabDevice(ClientPtr client, DeviceIntPtr dev, 
d3857 2
a3858 2
    WindowPtr pWin;
    GrabPtr grab;
a3859 1
    int rc;
d3877 3
a3879 3
    rc = dixLookupWindow(&pWin, grabWindow, client, DixReadAccess);
    if (rc != Success)
	return rc;
a3908 5
/**
 * Server-side protocol handling for GrabKeyboard request.
 *
 * Grabs the inputInfo.keyboad and returns success status to client.
 */
d3917 3
a3919 7

    if (XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
	result = GrabDevice(client, inputInfo.keyboard, stuff->keyboardMode,
			    stuff->pointerMode, stuff->grabWindow,
			    stuff->ownerEvents, stuff->time,
			    KeyPressMask | KeyReleaseMask, &rep.status);
    else {
d3923 6
a3928 1

a3937 5
/**
 * Server-side protocol handling for UngrabKeyboard request.
 *
 * Deletes a possible grab on the inputInfo.keyboard.
 */
a3956 5
/**
 * Server-side protocol handling for QueryPointer request.
 *
 * Returns the current state and position of the core pointer to the client. 
 */
a3963 1
    int rc;
d3966 3
a3968 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
	return rc;
a4013 4
/**
 * Initializes the device list and the DIX sprite to sane values. Allocates
 * trace memory used for quick window traversal.
 */
d4015 1
a4015 1
InitEvents(void)
a4074 5
/**
 * Server-side protocol handling for SendEvent request.
 *
 * Locates the window to send the event to and forwards the event. 
 */
d4132 2
a4133 2
	dixLookupWindow(&pWin, stuff->destination, client, DixReadAccess);

a4161 6
/**
 * Server-side protocol handling for UngrabKey request.
 *
 * Deletes a passive grab for the given key. Only works on the
 * inputInfo.keyboard.
 */
a4168 1
    int rc;
d4171 3
a4173 3
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
    if (rc != Success)
	return rc;
a4202 6
/**
 * Server-side protocol handling for GrabKey request.
 *
 * Creates a grab for the inputInfo.keyboard and adds it to the list of
 * passive grabs. 
 */
a4209 1
    int rc;
d4242 3
a4244 3
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
    if (rc != Success)
	return rc;
a4256 6
/**
 * Server-side protocol handling for GrabButton request.
 *
 * Creates a grab for the inputInfo.pointer and adds it as a passive grab to
 * the list.
 */
a4263 1
    int rc;
d4294 3
a4296 3
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
    if (rc != Success)
	return rc;
d4300 4
a4303 4
	rc = dixLookupWindow(&confineTo, stuff->confineTo, client,
			     DixReadAccess);
	if (rc != Success)
	    return rc;
d4310 1
a4310 1
						RT_CURSOR, DixReadAccess);
a4328 5
/**
 * Server-side protocol handling for UngrabButton request.
 *
 * Deletes a passive grab on the inputInfo.pointer from the list.
 */
a4334 1
    int rc;
d4343 3
a4345 3
    rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixReadAccess);
    if (rc != Success)
	return rc;
a4360 11
/**
 * Deactivate any grab that may be on the window, remove the focus.
 * Delete any XInput extension events from the window too. Does not change the
 * window mask. Use just before the window is deleted.
 *
 * If freeResources is set, passive grabs on the window are deleted.
 *
 * @@param pWin The window to delete events from.
 * @@param freeResources True if resources associated with the window should be
 * deleted.
 */
d4450 1
a4450 3
 * Call this whenever some window at or below pWin has changed geometry. If
 * there is a grab on the window, the cursor will be re-confined into the
 * window.
d4474 1
a4474 1
    OtherClientsPtr	other;
a4485 3
/**
 * Server-side protocol handling for RecolorCursor request.
 */
d4497 1
a4497 1
					RT_CURSOR, DixWriteAccess);
a4526 14
/**
 * Write the given events to a client, swapping the byte order if necessary.
 * To swap the byte ordering, a callback is called that has to be set up for
 * the given event type.
 *
 * In the case of DeviceMotionNotify trailed by DeviceValuators, the events
 * can be more than one. Usually it's just one event. 
 *
 * Do not modify the event structure passed in. See comment below.
 * 
 * @@param pClient Client to send events to.
 * @@param count Number of events.
 * @@param events The event list.
 */
a4582 8
#ifdef XSERVER_DTRACE
    if (XSERVER_SEND_EVENT_ENABLED()) {
	for (i = 0; i < count; i++)
	{
	    XSERVER_SEND_EVENT(pClient->index, events[i].u.u.type, &events[i]);
	}
    }
#endif	
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@d1101 1
a1101 1
	/* do motion compression, but not if from different devices */
a1103 1
            (tail->device == device) &&
d3098 1
a3098 1
   the device's processInputProc to be called, as in for example Mouse Keys.
d3111 1
a3111 3
    if (((xE->u.u.type==KeyPress)||(xE->u.u.type==KeyRelease)||
         (xE->u.u.type==DeviceKeyPress)||(xE->u.u.type==DeviceKeyRelease))
            ) {
d3113 1
a3113 1
               (((xE->u.u.type==KeyPress)||(xE->u.u.type==DeviceKeyPress))?"down":"up"));
d3116 3
a3118 1
    if (xE->u.u.type == KeyPress || xE->u.u.type == DeviceKeyPress)
d3120 2
a3121 1
    else if (xE->u.u.type == KeyRelease || xE->u.u.type == DeviceKeyRelease)
d3123 4
a3126 2
    else
        FatalError("Impossible keyboard event");
@


