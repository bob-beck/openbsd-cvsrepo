head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.29.21.26.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright © 2001 Keith Packard
 *
 * Partly based on code that is Copyright © The XFree86 Project Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/** @@file
 * This file covers the initialization and teardown of EXA, and has various
 * functions not responsible for performing rendering, pixmap migration, or
 * memory management.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "exa_priv.h"
#include "exa.h"

DevPrivateKeyRec exaScreenPrivateKeyRec;

#ifdef MITSHM
static ShmFuncs exaShmFuncs = { NULL, NULL };
#endif

/**
 * exaGetPixmapOffset() returns the offset (in bytes) within the framebuffer of
 * the beginning of the given pixmap.
 *
 * Note that drivers are free to, and often do, munge this offset as necessary
 * for handing to the hardware -- for example, translating it into a different
 * aperture.  This function may need to be extended in the future if we grow
 * support for having multiple card-accessible offscreen, such as an AGP memory
 * pool alongside the framebuffer pool.
 */
unsigned long
exaGetPixmapOffset(PixmapPtr pPix)
{
    ExaScreenPriv(pPix->drawable.pScreen);
    ExaPixmapPriv(pPix);

    return (CARD8 *) pExaPixmap->fb_ptr - pExaScr->info->memoryBase;
}

void *
exaGetPixmapDriverPrivate(PixmapPtr pPix)
{
    ExaPixmapPriv(pPix);

    return pExaPixmap->driverPriv;
}

/**
 * exaGetPixmapPitch() returns the pitch (in bytes) of the given pixmap.
 *
 * This is a helper to make driver code more obvious, due to the rather obscure
 * naming of the pitch field in the pixmap.
 */
unsigned long
exaGetPixmapPitch(PixmapPtr pPix)
{
    return pPix->devKind;
}

/**
 * exaGetPixmapSize() returns the size in bytes of the given pixmap in video
 * memory. Only valid when the pixmap is currently in framebuffer.
 */
unsigned long
exaGetPixmapSize(PixmapPtr pPix)
{
    ExaPixmapPrivPtr pExaPixmap;

    pExaPixmap = ExaGetPixmapPriv(pPix);
    if (pExaPixmap != NULL)
        return pExaPixmap->fb_size;
    return 0;
}

/**
 * exaGetDrawablePixmap() returns a backing pixmap for a given drawable.
 *
 * @@param pDrawable the drawable being requested.
 *
 * This function returns the backing pixmap for a drawable, whether it is a
 * redirected window, unredirected window, or already a pixmap.  Note that
 * coordinate translation is needed when drawing to the backing pixmap of a
 * redirected window, and the translation coordinates are provided by calling
 * exaGetOffscreenPixmap() on the drawable.
 */
PixmapPtr
exaGetDrawablePixmap(DrawablePtr pDrawable)
{
    if (pDrawable->type == DRAWABLE_WINDOW)
        return pDrawable->pScreen->GetWindowPixmap((WindowPtr) pDrawable);
    else
        return (PixmapPtr) pDrawable;
}

/**
 * Sets the offsets to add to coordinates to make them address the same bits in
 * the backing drawable. These coordinates are nonzero only for redirected
 * windows.
 */
void
exaGetDrawableDeltas(DrawablePtr pDrawable, PixmapPtr pPixmap, int *xp, int *yp)
{
#ifdef COMPOSITE
    if (pDrawable->type == DRAWABLE_WINDOW) {
        *xp = -pPixmap->screen_x;
        *yp = -pPixmap->screen_y;
        return;
    }
#endif

    *xp = 0;
    *yp = 0;
}

/**
 * exaPixmapDirty() marks a pixmap as dirty, allowing for
 * optimizations in pixmap migration when no changes have occurred.
 */
void
exaPixmapDirty(PixmapPtr pPix, int x1, int y1, int x2, int y2)
{
    BoxRec box;
    RegionRec region;

    box.x1 = max(x1, 0);
    box.y1 = max(y1, 0);
    box.x2 = min(x2, pPix->drawable.width);
    box.y2 = min(y2, pPix->drawable.height);

    if (box.x1 >= box.x2 || box.y1 >= box.y2)
        return;

    RegionInit(&region, &box, 1);
    DamageDamageRegion(&pPix->drawable, &region);
    RegionUninit(&region);
}

static int
exaLog2(int val)
{
    int bits;

    if (val <= 0)
        return 0;
    for (bits = 0; val != 0; bits++)
        val >>= 1;
    return bits - 1;
}

void
exaSetAccelBlock(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
                 int w, int h, int bpp)
{
    pExaPixmap->accel_blocked = 0;

    if (pExaScr->info->maxPitchPixels) {
        int max_pitch = pExaScr->info->maxPitchPixels * bits_to_bytes(bpp);

        if (pExaPixmap->fb_pitch > max_pitch)
            pExaPixmap->accel_blocked |= EXA_RANGE_PITCH;
    }

    if (pExaScr->info->maxPitchBytes &&
        pExaPixmap->fb_pitch > pExaScr->info->maxPitchBytes)
        pExaPixmap->accel_blocked |= EXA_RANGE_PITCH;

    if (w > pExaScr->info->maxX)
        pExaPixmap->accel_blocked |= EXA_RANGE_WIDTH;

    if (h > pExaScr->info->maxY)
        pExaPixmap->accel_blocked |= EXA_RANGE_HEIGHT;
}

void
exaSetFbPitch(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
              int w, int h, int bpp)
{
    if (pExaScr->info->flags & EXA_OFFSCREEN_ALIGN_POT && w != 1)
        pExaPixmap->fb_pitch = bits_to_bytes((1 << (exaLog2(w - 1) + 1)) * bpp);
    else
        pExaPixmap->fb_pitch = bits_to_bytes(w * bpp);

    pExaPixmap->fb_pitch = EXA_ALIGN(pExaPixmap->fb_pitch,
                                     pExaScr->info->pixmapPitchAlign);
}

/**
 * Returns TRUE if the pixmap is not movable.  This is the case where it's a
 * pixmap which has no private (almost always bad) or it's a scratch pixmap created by
 * some X Server internal component (the score says it's pinned).
 */
Bool
exaPixmapIsPinned(PixmapPtr pPix)
{
    ExaPixmapPriv(pPix);

    if (pExaPixmap == NULL)
        EXA_FatalErrorDebugWithRet(("EXA bug: exaPixmapIsPinned was called on a non-exa pixmap.\n"), TRUE);

    return pExaPixmap->score == EXA_PIXMAP_SCORE_PINNED;
}

/**
 * exaPixmapHasGpuCopy() is used to determine if a pixmap is in offscreen
 * memory, meaning that acceleration could probably be done to it, and that it
 * will need to be wrapped by PrepareAccess()/FinishAccess() when accessing it
 * with the CPU.
 *
 * Note that except for UploadToScreen()/DownloadFromScreen() (which explicitly
 * deal with moving pixmaps in and out of system memory), EXA will give drivers
 * pixmaps as arguments for which exaPixmapHasGpuCopy() is TRUE.
 *
 * @@return TRUE if the given drawable is in framebuffer memory.
 */
Bool
exaPixmapHasGpuCopy(PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;

    ExaScreenPriv(pScreen);

    if (!(pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS))
        return FALSE;

    return (*pExaScr->pixmap_has_gpu_copy) (pPixmap);
}

/**
 * exaDrawableIsOffscreen() is a convenience wrapper for exaPixmapHasGpuCopy().
 */
Bool
exaDrawableIsOffscreen(DrawablePtr pDrawable)
{
    return exaPixmapHasGpuCopy(exaGetDrawablePixmap(pDrawable));
}

/**
 * Returns the pixmap which backs a drawable, and the offsets to add to
 * coordinates to make them address the same bits in the backing drawable.
 */
PixmapPtr
exaGetOffscreenPixmap(DrawablePtr pDrawable, int *xp, int *yp)
{
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    exaGetDrawableDeltas(pDrawable, pPixmap, xp, yp);

    if (exaPixmapHasGpuCopy(pPixmap))
        return pPixmap;
    else
        return NULL;
}

/**
 * Returns TRUE if the pixmap GPU copy is being accessed.
 */
Bool
ExaDoPrepareAccess(PixmapPtr pPixmap, int index)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;

    ExaScreenPriv(pScreen);
    ExaPixmapPriv(pPixmap);
    Bool has_gpu_copy, ret;
    int i;

    if (!(pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS))
        return FALSE;

    if (pExaPixmap == NULL)
        EXA_FatalErrorDebugWithRet(("EXA bug: ExaDoPrepareAccess was called on a non-exa pixmap.\n"), FALSE);

    /* Handle repeated / nested calls. */
    for (i = 0; i < EXA_NUM_PREPARE_INDICES; i++) {
        if (pExaScr->access[i].pixmap == pPixmap) {
            pExaScr->access[i].count++;
            return pExaScr->access[i].retval;
        }
    }

    /* If slot for this index is taken, find an empty slot */
    if (pExaScr->access[index].pixmap) {
        for (index = EXA_NUM_PREPARE_INDICES - 1; index >= 0; index--)
            if (!pExaScr->access[index].pixmap)
                break;
    }

    /* Access to this pixmap hasn't been prepared yet, so data pointer should be NULL. */
    if (pPixmap->devPrivate.ptr != NULL) {
        EXA_FatalErrorDebug(("EXA bug: pPixmap->devPrivate.ptr was %p, but should have been NULL.\n", pPixmap->devPrivate.ptr));
    }

    has_gpu_copy = exaPixmapHasGpuCopy(pPixmap);

    if (has_gpu_copy && pExaPixmap->fb_ptr) {
        pPixmap->devPrivate.ptr = pExaPixmap->fb_ptr;
        ret = TRUE;
    }
    else {
        pPixmap->devPrivate.ptr = pExaPixmap->sys_ptr;
        ret = FALSE;
    }

    /* Store so we can handle repeated / nested calls. */
    pExaScr->access[index].pixmap = pPixmap;
    pExaScr->access[index].count = 1;

    if (!has_gpu_copy)
        goto out;

    exaWaitSync(pScreen);

    if (pExaScr->info->PrepareAccess == NULL)
        goto out;

    if (index >= EXA_PREPARE_AUX_DEST &&
        !(pExaScr->info->flags & EXA_SUPPORTS_PREPARE_AUX)) {
        if (pExaPixmap->score == EXA_PIXMAP_SCORE_PINNED)
            FatalError("Unsupported AUX indices used on a pinned pixmap.\n");
        exaMoveOutPixmap(pPixmap);
        ret = FALSE;
        goto out;
    }

    if (!(*pExaScr->info->PrepareAccess) (pPixmap, index)) {
        if (pExaPixmap->score == EXA_PIXMAP_SCORE_PINNED &&
            !(pExaScr->info->flags & EXA_MIXED_PIXMAPS))
            FatalError("Driver failed PrepareAccess on a pinned pixmap.\n");
        exaMoveOutPixmap(pPixmap);
        ret = FALSE;
        goto out;
    }

    ret = TRUE;

 out:
    pExaScr->access[index].retval = ret;
    return ret;
}

/**
 * exaPrepareAccess() is EXA's wrapper for the driver's PrepareAccess() handler.
 *
 * It deals with waiting for synchronization with the card, determining if
 * PrepareAccess() is necessary, and working around PrepareAccess() failure.
 */
void
exaPrepareAccess(DrawablePtr pDrawable, int index)
{
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    ExaScreenPriv(pDrawable->pScreen);

    if (pExaScr->prepare_access_reg)
        pExaScr->prepare_access_reg(pPixmap, index, NULL);
    else
        (void) ExaDoPrepareAccess(pPixmap, index);
}

/**
 * exaFinishAccess() is EXA's wrapper for the driver's FinishAccess() handler.
 *
 * It deals with calling the driver's FinishAccess() only if necessary.
 */
void
exaFinishAccess(DrawablePtr pDrawable, int index)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    ExaScreenPriv(pScreen);
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPixmap);
    int i;

    if (!(pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS))
        return;

    if (pExaPixmap == NULL)
        EXA_FatalErrorDebugWithRet(("EXA bug: exaFinishAccesss was called on a non-exa pixmap.\n"),);

    /* Handle repeated / nested calls. */
    for (i = 0; i < EXA_NUM_PREPARE_INDICES; i++) {
        if (pExaScr->access[i].pixmap == pPixmap) {
            if (--pExaScr->access[i].count > 0)
                return;
            break;
        }
    }

    /* Catch unbalanced Prepare/FinishAccess calls. */
    if (i == EXA_NUM_PREPARE_INDICES)
        EXA_FatalErrorDebugWithRet(("EXA bug: FinishAccess called without PrepareAccess for pixmap 0x%p.\n", pPixmap),);

    pExaScr->access[i].pixmap = NULL;

    /* We always hide the devPrivate.ptr. */
    pPixmap->devPrivate.ptr = NULL;

    /* Only call FinishAccess if PrepareAccess was called and succeeded. */
    if (!pExaScr->info->FinishAccess || !pExaScr->access[i].retval)
        return;

    if (i >= EXA_PREPARE_AUX_DEST &&
        !(pExaScr->info->flags & EXA_SUPPORTS_PREPARE_AUX)) {
        ErrorF("EXA bug: Trying to call driver FinishAccess hook with "
               "unsupported index EXA_PREPARE_AUX*\n");
        return;
    }

    (*pExaScr->info->FinishAccess) (pPixmap, i);
}

/**
 * Helper for things common to all schemes when a pixmap is destroyed
 */
void
exaDestroyPixmap(PixmapPtr pPixmap)
{
    ExaScreenPriv(pPixmap->drawable.pScreen);
    int i;

    /* Finish access if it was prepared (e.g. pixmap created during
     * software fallback)
     */
    for (i = 0; i < EXA_NUM_PREPARE_INDICES; i++) {
        if (pExaScr->access[i].pixmap == pPixmap) {
            exaFinishAccess(&pPixmap->drawable, i);
            pExaScr->access[i].pixmap = NULL;
            break;
        }
    }
}

/**
 * Here begins EXA's GC code.
 * Do not ever access the fb/mi layer directly.
 */

static void
 exaValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable);

static void
 exaDestroyGC(GCPtr pGC);

static void
 exaChangeGC(GCPtr pGC, unsigned long mask);

static void
 exaCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);

static void
 exaChangeClip(GCPtr pGC, int type, void *pvalue, int nrects);

static void
 exaCopyClip(GCPtr pGCDst, GCPtr pGCSrc);

static void
 exaDestroyClip(GCPtr pGC);

const GCFuncs exaGCFuncs = {
    exaValidateGC,
    exaChangeGC,
    exaCopyGC,
    exaDestroyGC,
    exaChangeClip,
    exaDestroyClip,
    exaCopyClip
};

static void
exaValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
{
    /* fbValidateGC will do direct access to pixmaps if the tiling has changed.
     * Do a few smart things so fbValidateGC can do it's work.
     */

    ScreenPtr pScreen = pDrawable->pScreen;

    ExaScreenPriv(pScreen);
    ExaGCPriv(pGC);
    PixmapPtr pTile = NULL;
    Bool finish_current_tile = FALSE;

    /* Either of these conditions is enough to trigger access to a tile pixmap. */
    /* With pGC->tileIsPixel == 1, you run the risk of dereferencing an invalid tile pixmap pointer. */
    if (pGC->fillStyle == FillTiled ||
        ((changes & GCTile) && !pGC->tileIsPixel)) {
        pTile = pGC->tile.pixmap;

        /* Sometimes tile pixmaps are swapped, you need access to:
         * - The current tile if it depth matches.
         * - Or the rotated tile if that one matches depth and !(changes & GCTile).
         * - Or the current tile pixmap and a newly created one.
         */
        if (pTile && pTile->drawable.depth != pDrawable->depth &&
            !(changes & GCTile)) {
            PixmapPtr pRotatedTile = fbGetRotatedPixmap(pGC);

            if (pRotatedTile &&
                pRotatedTile->drawable.depth == pDrawable->depth)
                pTile = pRotatedTile;
            else
                finish_current_tile = TRUE;     /* CreatePixmap will be called. */
        }
    }

    if (pGC->stipple)
        exaPrepareAccess(&pGC->stipple->drawable, EXA_PREPARE_MASK);
    if (pTile)
        exaPrepareAccess(&pTile->drawable, EXA_PREPARE_SRC);

    /* Calls to Create/DestroyPixmap have to be identified as special. */
    pExaScr->fallback_counter++;
    swap(pExaGC, pGC, funcs);
    (*pGC->funcs->ValidateGC) (pGC, changes, pDrawable);
    swap(pExaGC, pGC, funcs);
    pExaScr->fallback_counter--;

    if (pTile)
        exaFinishAccess(&pTile->drawable, EXA_PREPARE_SRC);
    if (finish_current_tile && pGC->tile.pixmap)
        exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_AUX_DEST);
    if (pGC->stipple)
        exaFinishAccess(&pGC->stipple->drawable, EXA_PREPARE_MASK);
}

/* Is exaPrepareAccessGC() needed? */
static void
exaDestroyGC(GCPtr pGC)
{
    ExaGCPriv(pGC);
    swap(pExaGC, pGC, funcs);
    (*pGC->funcs->DestroyGC) (pGC);
    swap(pExaGC, pGC, funcs);
}

static void
exaChangeGC(GCPtr pGC, unsigned long mask)
{
    ExaGCPriv(pGC);
    swap(pExaGC, pGC, funcs);
    (*pGC->funcs->ChangeGC) (pGC, mask);
    swap(pExaGC, pGC, funcs);
}

static void
exaCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    ExaGCPriv(pGCDst);
    swap(pExaGC, pGCDst, funcs);
    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    swap(pExaGC, pGCDst, funcs);
}

static void
exaChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
{
    ExaGCPriv(pGC);
    swap(pExaGC, pGC, funcs);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    swap(pExaGC, pGC, funcs);
}

static void
exaCopyClip(GCPtr pGCDst, GCPtr pGCSrc)
{
    ExaGCPriv(pGCDst);
    swap(pExaGC, pGCDst, funcs);
    (*pGCDst->funcs->CopyClip) (pGCDst, pGCSrc);
    swap(pExaGC, pGCDst, funcs);
}

static void
exaDestroyClip(GCPtr pGC)
{
    ExaGCPriv(pGC);
    swap(pExaGC, pGC, funcs);
    (*pGC->funcs->DestroyClip) (pGC);
    swap(pExaGC, pGC, funcs);
}

/**
 * exaCreateGC makes a new GC and hooks up its funcs handler, so that
 * exaValidateGC() will get called.
 */
static int
exaCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;

    ExaScreenPriv(pScreen);
    ExaGCPriv(pGC);
    Bool ret;

    swap(pExaScr, pScreen, CreateGC);
    if ((ret = (*pScreen->CreateGC) (pGC))) {
        wrap(pExaGC, pGC, funcs, &exaGCFuncs);
        wrap(pExaGC, pGC, ops, &exaOps);
    }
    swap(pExaScr, pScreen, CreateGC);

    return ret;
}

static Bool
exaChangeWindowAttributes(WindowPtr pWin, unsigned long mask)
{
    Bool ret;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    ExaScreenPriv(pScreen);

    if ((mask & CWBackPixmap) && pWin->backgroundState == BackgroundPixmap)
        exaPrepareAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);

    if ((mask & CWBorderPixmap) && pWin->borderIsPixel == FALSE)
        exaPrepareAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_MASK);

    pExaScr->fallback_counter++;
    swap(pExaScr, pScreen, ChangeWindowAttributes);
    ret = pScreen->ChangeWindowAttributes(pWin, mask);
    swap(pExaScr, pScreen, ChangeWindowAttributes);
    pExaScr->fallback_counter--;

    if ((mask & CWBackPixmap) && pWin->backgroundState == BackgroundPixmap)
        exaFinishAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);
    if ((mask & CWBorderPixmap) && pWin->borderIsPixel == FALSE)
        exaFinishAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_MASK);

    return ret;
}

static RegionPtr
exaBitmapToRegion(PixmapPtr pPix)
{
    RegionPtr ret;
    ScreenPtr pScreen = pPix->drawable.pScreen;

    ExaScreenPriv(pScreen);

    exaPrepareAccess(&pPix->drawable, EXA_PREPARE_SRC);
    swap(pExaScr, pScreen, BitmapToRegion);
    ret = (*pScreen->BitmapToRegion) (pPix);
    swap(pExaScr, pScreen, BitmapToRegion);
    exaFinishAccess(&pPix->drawable, EXA_PREPARE_SRC);

    return ret;
}

static Bool
exaCreateScreenResources(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    PixmapPtr pScreenPixmap;
    Bool b;

    swap(pExaScr, pScreen, CreateScreenResources);
    b = pScreen->CreateScreenResources(pScreen);
    swap(pExaScr, pScreen, CreateScreenResources);

    if (!b)
        return FALSE;

    pScreenPixmap = pScreen->GetScreenPixmap(pScreen);

    if (pScreenPixmap) {
        ExaPixmapPriv(pScreenPixmap);

        exaSetAccelBlock(pExaScr, pExaPixmap,
                         pScreenPixmap->drawable.width,
                         pScreenPixmap->drawable.height,
                         pScreenPixmap->drawable.bitsPerPixel);
    }

    return TRUE;
}

static void
ExaBlockHandler(ScreenPtr pScreen, void *pTimeout,
                void *pReadmask)
{
    ExaScreenPriv(pScreen);

    /* Move any deferred results from a software fallback to the driver pixmap */
    if (pExaScr->deferred_mixed_pixmap)
        exaMoveInPixmap_mixed(pExaScr->deferred_mixed_pixmap);

    unwrap(pExaScr, pScreen, BlockHandler);
    (*pScreen->BlockHandler) (pScreen, pTimeout, pReadmask);
    wrap(pExaScr, pScreen, BlockHandler, ExaBlockHandler);

    /* The rest only applies to classic EXA */
    if (pExaScr->info->flags & EXA_HANDLES_PIXMAPS)
        return;

    /* Try and keep the offscreen memory area tidy every now and then (at most
     * once per second) when the server has been idle for at least 100ms.
     */
    if (pExaScr->numOffscreenAvailable > 1) {
        CARD32 now = GetTimeInMillis();

        pExaScr->nextDefragment = now +
            max(100, (INT32) (pExaScr->lastDefragment + 1000 - now));
        AdjustWaitForDelay(pTimeout, pExaScr->nextDefragment - now);
    }
}

static void
ExaWakeupHandler(ScreenPtr pScreen, unsigned long result,
                 void *pReadmask)
{
    ExaScreenPriv(pScreen);

    unwrap(pExaScr, pScreen, WakeupHandler);
    (*pScreen->WakeupHandler) (pScreen, result, pReadmask);
    wrap(pExaScr, pScreen, WakeupHandler, ExaWakeupHandler);

    if (result == 0 && pExaScr->numOffscreenAvailable > 1) {
        CARD32 now = GetTimeInMillis();

        if ((int) (now - pExaScr->nextDefragment) > 0) {
            ExaOffscreenDefragment(pScreen);
            pExaScr->lastDefragment = now;
        }
    }
}

/**
 * exaCloseScreen() unwraps its wrapped screen functions and tears down EXA's
 * screen private, before calling down to the next CloseSccreen.
 */
static Bool
exaCloseScreen(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    if (ps->Glyphs == exaGlyphs)
        exaGlyphsFini(pScreen);

    if (pScreen->BlockHandler == ExaBlockHandler)
        unwrap(pExaScr, pScreen, BlockHandler);
    if (pScreen->WakeupHandler == ExaWakeupHandler)
        unwrap(pExaScr, pScreen, WakeupHandler);
    unwrap(pExaScr, pScreen, CreateGC);
    unwrap(pExaScr, pScreen, CloseScreen);
    unwrap(pExaScr, pScreen, GetImage);
    unwrap(pExaScr, pScreen, GetSpans);
    if (pExaScr->SavedCreatePixmap)
        unwrap(pExaScr, pScreen, CreatePixmap);
    if (pExaScr->SavedDestroyPixmap)
        unwrap(pExaScr, pScreen, DestroyPixmap);
    if (pExaScr->SavedModifyPixmapHeader)
        unwrap(pExaScr, pScreen, ModifyPixmapHeader);
    unwrap(pExaScr, pScreen, CopyWindow);
    unwrap(pExaScr, pScreen, ChangeWindowAttributes);
    unwrap(pExaScr, pScreen, BitmapToRegion);
    unwrap(pExaScr, pScreen, CreateScreenResources);
    if (pExaScr->SavedSharePixmapBacking)
        unwrap(pExaScr, pScreen, SharePixmapBacking);
    if (pExaScr->SavedSetSharedPixmapBacking)
        unwrap(pExaScr, pScreen, SetSharedPixmapBacking);
    unwrap(pExaScr, ps, Composite);
    if (pExaScr->SavedGlyphs)
        unwrap(pExaScr, ps, Glyphs);
    unwrap(pExaScr, ps, Trapezoids);
    unwrap(pExaScr, ps, Triangles);
    unwrap(pExaScr, ps, AddTraps);

    free(pExaScr);

    return (*pScreen->CloseScreen) (pScreen);
}

/**
 * This function allocates a driver structure for EXA drivers to fill in.  By
 * having EXA allocate the structure, the driver structure can be extended
 * without breaking ABI between EXA and the drivers.  The driver's
 * responsibility is to check beforehand that the EXA module has a matching
 * major number and sufficient minor.  Drivers are responsible for freeing the
 * driver structure using free().
 *
 * @@return a newly allocated, zero-filled driver structure
 */
ExaDriverPtr
exaDriverAlloc(void)
{
    return calloc(1, sizeof(ExaDriverRec));
}

/**
 * @@param pScreen screen being initialized
 * @@param pScreenInfo EXA driver record
 *
 * exaDriverInit sets up EXA given a driver record filled in by the driver.
 * pScreenInfo should have been allocated by exaDriverAlloc().  See the
 * comments in _ExaDriver for what must be filled in and what is optional.
 *
 * @@return TRUE if EXA was successfully initialized.
 */
Bool
exaDriverInit(ScreenPtr pScreen, ExaDriverPtr pScreenInfo)
{
    ExaScreenPrivPtr pExaScr;
    PictureScreenPtr ps;

    if (!pScreenInfo)
        return FALSE;

    if (pScreenInfo->exa_major != EXA_VERSION_MAJOR ||
        pScreenInfo->exa_minor > EXA_VERSION_MINOR) {
        LogMessage(X_ERROR, "EXA(%d): driver's EXA version requirements "
                   "(%d.%d) are incompatible with EXA version (%d.%d)\n",
                   pScreen->myNum,
                   pScreenInfo->exa_major, pScreenInfo->exa_minor,
                   EXA_VERSION_MAJOR, EXA_VERSION_MINOR);
        return FALSE;
    }

    if (!pScreenInfo->CreatePixmap && !pScreenInfo->CreatePixmap2) {
        if (!pScreenInfo->memoryBase) {
            LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memoryBase "
                       "must be non-zero\n", pScreen->myNum);
            return FALSE;
        }

        if (!pScreenInfo->memorySize) {
            LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memorySize must be "
                       "non-zero\n", pScreen->myNum);
            return FALSE;
        }

        if (pScreenInfo->offScreenBase > pScreenInfo->memorySize) {
            LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::offScreenBase must "
                       "be <= ExaDriverRec::memorySize\n", pScreen->myNum);
            return FALSE;
        }
    }

    if (!pScreenInfo->PrepareSolid) {
        LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::PrepareSolid must be "
                   "non-NULL\n", pScreen->myNum);
        return FALSE;
    }

    if (!pScreenInfo->PrepareCopy) {
        LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::PrepareCopy must be "
                   "non-NULL\n", pScreen->myNum);
        return FALSE;
    }

    if (!pScreenInfo->WaitMarker) {
        LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::WaitMarker must be "
                   "non-NULL\n", pScreen->myNum);
        return FALSE;
    }

    /* If the driver doesn't set any max pitch values, we'll just assume
     * that there's a limitation by pixels, and that it's the same as
     * maxX.
     *
     * We want maxPitchPixels or maxPitchBytes to be set so we can check
     * pixmaps against the max pitch in exaCreatePixmap() -- it matters
     * whether a pixmap is rejected because of its pitch or
     * because of its width.
     */
    if (!pScreenInfo->maxPitchPixels && !pScreenInfo->maxPitchBytes) {
        pScreenInfo->maxPitchPixels = pScreenInfo->maxX;
    }

    ps = GetPictureScreenIfSet(pScreen);

    if (!dixRegisterPrivateKey(&exaScreenPrivateKeyRec, PRIVATE_SCREEN, 0)) {
        LogMessage(X_WARNING, "EXA(%d): Failed to register screen private\n",
                   pScreen->myNum);
        return FALSE;
    }

    pExaScr = calloc(sizeof(ExaScreenPrivRec), 1);
    if (!pExaScr) {
        LogMessage(X_WARNING, "EXA(%d): Failed to allocate screen private\n",
                   pScreen->myNum);
        return FALSE;
    }

    pExaScr->info = pScreenInfo;

    dixSetPrivate(&pScreen->devPrivates, exaScreenPrivateKey, pExaScr);

    pExaScr->migration = ExaMigrationAlways;

    exaDDXDriverInit(pScreen);

    if (!dixRegisterScreenSpecificPrivateKey
        (pScreen, &pExaScr->gcPrivateKeyRec, PRIVATE_GC, sizeof(ExaGCPrivRec))) {
        LogMessage(X_WARNING, "EXA(%d): Failed to allocate GC private\n",
                   pScreen->myNum);
        return FALSE;
    }

    /*
     * Replace various fb screen functions
     */
    if ((pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS) &&
        (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS) ||
         (pExaScr->info->flags & EXA_MIXED_PIXMAPS)))
        wrap(pExaScr, pScreen, BlockHandler, ExaBlockHandler);
    if ((pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS) &&
        !(pExaScr->info->flags & EXA_HANDLES_PIXMAPS))
        wrap(pExaScr, pScreen, WakeupHandler, ExaWakeupHandler);
    wrap(pExaScr, pScreen, CreateGC, exaCreateGC);
    wrap(pExaScr, pScreen, CloseScreen, exaCloseScreen);
    wrap(pExaScr, pScreen, GetImage, exaGetImage);
    wrap(pExaScr, pScreen, GetSpans, ExaCheckGetSpans);
    wrap(pExaScr, pScreen, CopyWindow, exaCopyWindow);
    wrap(pExaScr, pScreen, ChangeWindowAttributes, exaChangeWindowAttributes);
    wrap(pExaScr, pScreen, BitmapToRegion, exaBitmapToRegion);
    wrap(pExaScr, pScreen, CreateScreenResources, exaCreateScreenResources);

    if (ps) {
        wrap(pExaScr, ps, Composite, exaComposite);
        if (pScreenInfo->PrepareComposite) {
            wrap(pExaScr, ps, Glyphs, exaGlyphs);
        }
        else {
            wrap(pExaScr, ps, Glyphs, ExaCheckGlyphs);
        }
        wrap(pExaScr, ps, Trapezoids, exaTrapezoids);
        wrap(pExaScr, ps, Triangles, exaTriangles);
        wrap(pExaScr, ps, AddTraps, ExaCheckAddTraps);
    }

#ifdef MITSHM
    /*
     * Don't allow shared pixmaps.
     */
    ShmRegisterFuncs(pScreen, &exaShmFuncs);
#endif
    /*
     * Hookup offscreen pixmaps
     */
    if (pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS) {
        if (!dixRegisterScreenSpecificPrivateKey
            (pScreen, &pExaScr->pixmapPrivateKeyRec, PRIVATE_PIXMAP,
             sizeof(ExaPixmapPrivRec))) {
            LogMessage(X_WARNING,
                       "EXA(%d): Failed to allocate pixmap private\n",
                       pScreen->myNum);
            return FALSE;
        }
        if (pExaScr->info->flags & EXA_HANDLES_PIXMAPS) {
            if (pExaScr->info->flags & EXA_MIXED_PIXMAPS) {
                wrap(pExaScr, pScreen, CreatePixmap, exaCreatePixmap_mixed);
                wrap(pExaScr, pScreen, DestroyPixmap, exaDestroyPixmap_mixed);
                wrap(pExaScr, pScreen, ModifyPixmapHeader,
                     exaModifyPixmapHeader_mixed);
                wrap(pExaScr, pScreen, SharePixmapBacking, exaSharePixmapBacking_mixed);
                wrap(pExaScr, pScreen, SetSharedPixmapBacking, exaSetSharedPixmapBacking_mixed);

                pExaScr->do_migration = exaDoMigration_mixed;
                pExaScr->pixmap_has_gpu_copy = exaPixmapHasGpuCopy_mixed;
                pExaScr->do_move_in_pixmap = exaMoveInPixmap_mixed;
                pExaScr->do_move_out_pixmap = NULL;
                pExaScr->prepare_access_reg = exaPrepareAccessReg_mixed;
            }
            else {
                wrap(pExaScr, pScreen, CreatePixmap, exaCreatePixmap_driver);
                wrap(pExaScr, pScreen, DestroyPixmap, exaDestroyPixmap_driver);
                wrap(pExaScr, pScreen, ModifyPixmapHeader,
                     exaModifyPixmapHeader_driver);
                pExaScr->do_migration = NULL;
                pExaScr->pixmap_has_gpu_copy = exaPixmapHasGpuCopy_driver;
                pExaScr->do_move_in_pixmap = NULL;
                pExaScr->do_move_out_pixmap = NULL;
                pExaScr->prepare_access_reg = NULL;
            }
        }
        else {
            wrap(pExaScr, pScreen, CreatePixmap, exaCreatePixmap_classic);
            wrap(pExaScr, pScreen, DestroyPixmap, exaDestroyPixmap_classic);
            wrap(pExaScr, pScreen, ModifyPixmapHeader,
                 exaModifyPixmapHeader_classic);
            pExaScr->do_migration = exaDoMigration_classic;
            pExaScr->pixmap_has_gpu_copy = exaPixmapHasGpuCopy_classic;
            pExaScr->do_move_in_pixmap = exaMoveInPixmap_classic;
            pExaScr->do_move_out_pixmap = exaMoveOutPixmap_classic;
            pExaScr->prepare_access_reg = exaPrepareAccessReg_classic;
        }
        if (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS)) {
            LogMessage(X_INFO, "EXA(%d): Offscreen pixmap area of %lu bytes\n",
                       pScreen->myNum,
                       pExaScr->info->memorySize -
                       pExaScr->info->offScreenBase);
        }
        else {
            LogMessage(X_INFO, "EXA(%d): Driver allocated offscreen pixmaps\n",
                       pScreen->myNum);

        }
    }
    else
        LogMessage(X_INFO, "EXA(%d): No offscreen pixmaps\n", pScreen->myNum);

    if (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS)) {
        DBG_PIXMAP(("============== %ld < %ld\n", pExaScr->info->offScreenBase,
                    pExaScr->info->memorySize));
        if (pExaScr->info->offScreenBase < pExaScr->info->memorySize) {
            if (!exaOffscreenInit(pScreen)) {
                LogMessage(X_WARNING,
                           "EXA(%d): Offscreen pixmap setup failed\n",
                           pScreen->myNum);
                return FALSE;
            }
        }
    }

    if (ps->Glyphs == exaGlyphs)
        exaGlyphsInit(pScreen);

    LogMessage(X_INFO, "EXA(%d): Driver registered support for the following"
               " operations:\n", pScreen->myNum);
    assert(pScreenInfo->PrepareSolid != NULL);
    LogMessage(X_INFO, "        Solid\n");
    assert(pScreenInfo->PrepareCopy != NULL);
    LogMessage(X_INFO, "        Copy\n");
    if (pScreenInfo->PrepareComposite != NULL) {
        LogMessage(X_INFO, "        Composite (RENDER acceleration)\n");
    }
    if (pScreenInfo->UploadToScreen != NULL) {
        LogMessage(X_INFO, "        UploadToScreen\n");
    }
    if (pScreenInfo->DownloadFromScreen != NULL) {
        LogMessage(X_INFO, "        DownloadFromScreen\n");
    }

    return TRUE;
}

/**
 * exaDriverFini tears down EXA on a given screen.
 *
 * @@param pScreen screen being torn down.
 */
void
exaDriverFini(ScreenPtr pScreen)
{
    /*right now does nothing */
}

/**
 * exaMarkSync() should be called after any asynchronous drawing by the hardware.
 *
 * @@param pScreen screen which drawing occurred on
 *
 * exaMarkSync() sets a flag to indicate that some asynchronous drawing has
 * happened and a WaitSync() will be necessary before relying on the contents of
 * offscreen memory from the CPU's perspective.  It also calls an optional
 * driver MarkSync() callback, the return value of which may be used to do partial
 * synchronization with the hardware in the future.
 */
void
exaMarkSync(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);

    pExaScr->info->needsSync = TRUE;
    if (pExaScr->info->MarkSync != NULL) {
        pExaScr->info->lastMarker = (*pExaScr->info->MarkSync) (pScreen);
    }
}

/**
 * exaWaitSync() ensures that all drawing has been completed.
 *
 * @@param pScreen screen being synchronized.
 *
 * Calls down into the driver to ensure that all previous drawing has completed.
 * It should always be called before relying on the framebuffer contents
 * reflecting previous drawing, from a CPU perspective.
 */
void
exaWaitSync(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);

    if (pExaScr->info->needsSync && !pExaScr->swappedOut) {
        (*pExaScr->info->WaitMarker) (pScreen, pExaScr->info->lastMarker);
        pExaScr->info->needsSync = FALSE;
    }
}

/**
 * Performs migration of the pixmaps according to the operation information
 * provided in pixmaps and can_accel and the migration scheme chosen in the
 * config file.
 */
void
exaDoMigration(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel)
{
    ScreenPtr pScreen = pixmaps[0].pPix->drawable.pScreen;

    ExaScreenPriv(pScreen);

    if (!(pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS))
        return;

    if (pExaScr->do_migration)
        (*pExaScr->do_migration) (pixmaps, npixmaps, can_accel);
}

void
exaMoveInPixmap(PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;

    ExaScreenPriv(pScreen);

    if (!(pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS))
        return;

    if (pExaScr->do_move_in_pixmap)
        (*pExaScr->do_move_in_pixmap) (pPixmap);
}

void
exaMoveOutPixmap(PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;

    ExaScreenPriv(pScreen);

    if (!(pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS))
        return;

    if (pExaScr->do_move_out_pixmap)
        (*pExaScr->do_move_out_pixmap) (pPixmap);
}
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d722 1
a722 1
    /* Try and keep the offscreen memory area tidy every now and then (at most 
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d478 1
a478 1
 exaChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects);
d582 1
a582 1
exaChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
d623 2
a624 2
        wrap(pExaGC, pGC, funcs, (GCFuncs *) &exaGCFuncs);
        wrap(pExaGC, pGC, ops, (GCOps *) &exaOps);
d705 2
a706 2
ExaBlockHandler(ScreenPtr pScreen, pointer pTimeout,
                pointer pReadmask)
d736 1
a736 1
                 pointer pReadmask)
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a40 2
DevPrivateKeyRec exaPixmapPrivateKeyRec;
DevPrivateKeyRec exaGCPrivateKeyRec;
a483 3
 exaCopyClip(GCPtr pGCDst, GCPtr pGCSrc);

static void
d623 2
a624 2
        wrap(pExaGC, pGC, funcs, (GCFuncs *) & exaGCFuncs);
        wrap(pExaGC, pGC, ops, (GCOps *) & exaOps);
d705 1
a705 1
ExaBlockHandler(int screenNum, pointer blockData, pointer pTimeout,
a707 2
    ScreenPtr pScreen = screenInfo.screens[screenNum];

d715 1
a715 1
    (*pScreen->BlockHandler) (screenNum, blockData, pTimeout, pReadmask);
d735 1
a735 1
ExaWakeupHandler(int screenNum, pointer wakeupData, unsigned long result,
a737 2
    ScreenPtr pScreen = screenInfo.screens[screenNum];

d741 1
a741 1
    (*pScreen->WakeupHandler) (screenNum, wakeupData, result, pReadmask);
d759 1
a759 1
exaCloseScreen(int i, ScreenPtr pScreen)
d785 4
d798 1
a798 1
    return (*pScreen->CloseScreen) (i, pScreen);
d920 2
a921 2
    if (!dixRegisterPrivateKey
        (&exaGCPrivateKeyRec, PRIVATE_GC, sizeof(ExaGCPrivRec))) {
d969 2
a970 2
        if (!dixRegisterPrivateKey
            (&exaPixmapPrivateKeyRec, PRIVATE_PIXMAP,
d983 3
@


1.10
log
@Update to xserver 1.11.2
@
text
@d61 2
a62 2
    ExaScreenPriv (pPix->drawable.pScreen);
    ExaPixmapPriv (pPix);
d64 1
a64 1
    return (CARD8 *)pExaPixmap->fb_ptr - pExaScr->info->memoryBase;
d98 1
a98 1
	return pExaPixmap->fb_size;
d116 4
a119 4
     if (pDrawable->type == DRAWABLE_WINDOW)
	return pDrawable->pScreen->GetWindowPixmap ((WindowPtr) pDrawable);
     else
	return (PixmapPtr) pDrawable;
d128 1
a128 2
exaGetDrawableDeltas (DrawablePtr pDrawable, PixmapPtr pPixmap,
		      int *xp, int *yp)
d132 3
a134 3
	*xp = -pPixmap->screen_x;
	*yp = -pPixmap->screen_y;
	return;
d147 1
a147 1
exaPixmapDirty (PixmapPtr pPix, int x1, int y1, int x2, int y2)
d158 1
a158 1
	return;
d171 1
a171 1
	return 0;
d173 1
a173 1
	val >>= 1;
d220 1
a220 1
exaPixmapIsPinned (PixmapPtr pPix)
d222 1
a222 1
    ExaPixmapPriv (pPix);
d225 1
a225 1
	EXA_FatalErrorDebugWithRet(("EXA bug: exaPixmapIsPinned was called on a non-exa pixmap.\n"), TRUE);
d245 2
a246 1
    ScreenPtr	pScreen = pPixmap->drawable.pScreen;
d250 1
a250 1
	return FALSE;
d252 1
a252 1
    return (*pExaScr->pixmap_has_gpu_copy)(pPixmap);
d259 1
a259 1
exaDrawableIsOffscreen (DrawablePtr pDrawable)
d261 1
a261 1
    return exaPixmapHasGpuCopy (exaGetDrawablePixmap (pDrawable));
d269 1
a269 1
exaGetOffscreenPixmap (DrawablePtr pDrawable, int *xp, int *yp)
d271 1
a271 1
    PixmapPtr	pPixmap = exaGetDrawablePixmap (pDrawable);
d273 1
a273 1
    exaGetDrawableDeltas (pDrawable, pPixmap, xp, yp);
d275 2
a276 2
    if (exaPixmapHasGpuCopy (pPixmap))
	return pPixmap;
d278 1
a278 1
	return NULL;
d288 2
a289 1
    ExaScreenPriv (pScreen);
d295 1
a295 1
	return FALSE;
d298 1
a298 1
	EXA_FatalErrorDebugWithRet(("EXA bug: ExaDoPrepareAccess was called on a non-exa pixmap.\n"), FALSE);
d302 4
a305 4
	if (pExaScr->access[i].pixmap == pPixmap) {
	    pExaScr->access[i].count++;
	    return pExaScr->access[i].retval;
	}
d310 3
a312 3
	for (index = EXA_NUM_PREPARE_INDICES - 1; index >= 0; index--)
	    if (!pExaScr->access[index].pixmap)
		break;
d317 1
a317 2
	EXA_FatalErrorDebug(("EXA bug: pPixmap->devPrivate.ptr was %p, but should have been NULL.\n",
			     pPixmap->devPrivate.ptr));
d323 6
a328 5
	pPixmap->devPrivate.ptr = pExaPixmap->fb_ptr;
	ret = TRUE;
    } else {
	pPixmap->devPrivate.ptr = pExaPixmap->sys_ptr;
	ret = FALSE;
d336 1
a336 1
	goto out;
d338 1
a338 1
    exaWaitSync (pScreen);
d341 1
a341 1
	goto out;
d344 6
a349 6
	!(pExaScr->info->flags & EXA_SUPPORTS_PREPARE_AUX)) {
	if (pExaPixmap->score == EXA_PIXMAP_SCORE_PINNED)
	    FatalError("Unsupported AUX indices used on a pinned pixmap.\n");
	exaMoveOutPixmap (pPixmap);
	ret = FALSE;
	goto out;
d353 6
a358 6
	if (pExaPixmap->score == EXA_PIXMAP_SCORE_PINNED &&
	    !(pExaScr->info->flags & EXA_MIXED_PIXMAPS))
	    FatalError("Driver failed PrepareAccess on a pinned pixmap.\n");
	exaMoveOutPixmap (pPixmap);
	ret = FALSE;
	goto out;
d363 1
a363 1
out:
d378 1
d382 1
a382 1
	pExaScr->prepare_access_reg(pPixmap, index, NULL);
d384 1
a384 1
	(void)ExaDoPrepareAccess(pPixmap, index);
d395 6
a400 4
    ScreenPtr	    pScreen = pDrawable->pScreen;
    ExaScreenPriv  (pScreen);
    PixmapPtr	    pPixmap = exaGetDrawablePixmap (pDrawable);
    ExaPixmapPriv  (pPixmap);
d404 1
a404 1
	return;
d407 1
a407 1
	EXA_FatalErrorDebugWithRet(("EXA bug: exaFinishAccesss was called on a non-exa pixmap.\n"),);
d411 5
a415 5
	if (pExaScr->access[i].pixmap == pPixmap) {
	    if (--pExaScr->access[i].count > 0)
		return;
	    break;
	}
d420 1
a420 2
      EXA_FatalErrorDebugWithRet(("EXA bug: FinishAccess called without PrepareAccess for pixmap 0x%p.\n",
				  pPixmap),);
d429 1
a429 1
	return;
d432 4
a435 4
	!(pExaScr->info->flags & EXA_SUPPORTS_PREPARE_AUX)) {
	ErrorF("EXA bug: Trying to call driver FinishAccess hook with "
	       "unsupported index EXA_PREPARE_AUX*\n");
	return;
a440 1

d454 5
a458 5
	if (pExaScr->access[i].pixmap == pPixmap) {
	    exaFinishAccess(&pPixmap->drawable, i);
	    pExaScr->access[i].pixmap = NULL;
	    break;
	}
a461 1

d468 1
a468 3
exaValidateGC(GCPtr pGC,
		unsigned long changes,
		DrawablePtr pDrawable);
d471 1
a471 1
exaDestroyGC(GCPtr pGC);
d474 1
a474 2
exaChangeGC (GCPtr pGC,
		unsigned long mask);
d477 1
a477 3
exaCopyGC (GCPtr pGCSrc,
	      unsigned long mask,
	      GCPtr	 pGCDst);
d480 1
a480 4
exaChangeClip (GCPtr pGC,
		int type,
		pointer pvalue,
		int nrects);
d483 1
a483 1
exaCopyClip(GCPtr pGCDst, GCPtr pGCSrc);
d486 1
a486 1
exaCopyClip(GCPtr pGCDst, GCPtr pGCSrc);
d489 1
a489 1
exaDestroyClip(GCPtr pGC);
d502 1
a502 3
exaValidateGC(GCPtr pGC,
		unsigned long changes,
		DrawablePtr pDrawable)
d509 1
d517 19
a535 15
    if (pGC->fillStyle == FillTiled || ((changes & GCTile) && !pGC->tileIsPixel)) {
	pTile = pGC->tile.pixmap;

	/* Sometimes tile pixmaps are swapped, you need access to:
	 * - The current tile if it depth matches.
	 * - Or the rotated tile if that one matches depth and !(changes & GCTile).
	 * - Or the current tile pixmap and a newly created one.
	 */
	if (pTile && pTile->drawable.depth != pDrawable->depth && !(changes & GCTile)) {
	    PixmapPtr pRotatedTile = fbGetRotatedPixmap(pGC);
	    if (pRotatedTile && pRotatedTile->drawable.depth == pDrawable->depth)
		pTile = pRotatedTile;
	    else
		finish_current_tile = TRUE; /* CreatePixmap will be called. */
	}
d541 1
a541 1
	exaPrepareAccess(&pTile->drawable, EXA_PREPARE_SRC);
d546 1
a546 1
    (*pGC->funcs->ValidateGC)(pGC, changes, pDrawable);
d551 1
a551 1
	exaFinishAccess(&pTile->drawable, EXA_PREPARE_SRC);
d553 1
a553 1
	exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_AUX_DEST);
d555 1
a555 1
	exaFinishAccess(&pGC->stipple->drawable, EXA_PREPARE_MASK);
d564 1
a564 1
    (*pGC->funcs->DestroyGC)(pGC);
d569 1
a569 2
exaChangeGC (GCPtr pGC,
		unsigned long mask)
d578 1
a578 3
exaCopyGC (GCPtr pGCSrc,
	      unsigned long mask,
	      GCPtr	 pGCDst)
d587 1
a587 4
exaChangeClip (GCPtr pGC,
		int type,
		pointer pvalue,
		int nrects)
d600 1
a600 1
    (*pGCDst->funcs->CopyClip)(pGCDst, pGCSrc);
d609 1
a609 1
    (*pGC->funcs->DestroyClip)(pGC);
d618 1
a618 1
exaCreateGC (GCPtr pGC)
d621 1
d628 2
a629 2
	wrap(pExaGC, pGC, funcs, (GCFuncs *) &exaGCFuncs);
	wrap(pExaGC, pGC, ops, (GCOps *) &exaOps);
d641 1
d644 2
a645 2
    if ((mask & CWBackPixmap) && pWin->backgroundState == BackgroundPixmap) 
	exaPrepareAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);
d648 1
a648 1
	exaPrepareAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_MASK);
d656 2
a657 2
    if ((mask & CWBackPixmap) && pWin->backgroundState == BackgroundPixmap) 
	exaFinishAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);
d659 1
a659 1
	exaFinishAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_MASK);
d669 1
d674 1
a674 1
    ret = (*pScreen->BitmapToRegion)(pPix);
d711 1
a711 1
		pointer pReadmask)
d714 1
d719 1
a719 1
	exaMoveInPixmap_mixed(pExaScr->deferred_mixed_pixmap);
d727 1
a727 1
	return;
d733 1
a733 1
	CARD32 now = GetTimeInMillis();
d735 3
a737 3
	pExaScr->nextDefragment = now +
	    max(100, (INT32)(pExaScr->lastDefragment + 1000 - now));
	AdjustWaitForDelay(pTimeout, pExaScr->nextDefragment - now);
d743 1
a743 1
		 pointer pReadmask)
d746 1
d754 1
a754 1
	CARD32 now = GetTimeInMillis();
d756 4
a759 4
	if ((int)(now - pExaScr->nextDefragment) > 0) {
	    ExaOffscreenDefragment(pScreen);
	    pExaScr->lastDefragment = now;
	}
d771 1
a771 1
    PictureScreenPtr	ps = GetPictureScreenIfSet(pScreen);
d774 1
a774 1
	exaGlyphsFini(pScreen);
d777 1
a777 1
	unwrap(pExaScr, pScreen, BlockHandler);
d779 1
a779 1
	unwrap(pExaScr, pScreen, WakeupHandler);
d785 1
a785 1
	unwrap(pExaScr, pScreen, CreatePixmap);
d787 1
a787 1
	unwrap(pExaScr, pScreen, DestroyPixmap);
d789 1
a789 1
	unwrap(pExaScr, pScreen, ModifyPixmapHeader);
d796 1
a796 1
	unwrap(pExaScr, ps, Glyphs);
d833 1
a833 2
exaDriverInit (ScreenPtr		pScreen,
               ExaDriverPtr	pScreenInfo)
d839 1
a839 1
	return FALSE;
d842 7
a848 8
	pScreenInfo->exa_minor > EXA_VERSION_MINOR)
    {
	LogMessage(X_ERROR, "EXA(%d): driver's EXA version requirements "
		   "(%d.%d) are incompatible with EXA version (%d.%d)\n",
		   pScreen->myNum,
		   pScreenInfo->exa_major, pScreenInfo->exa_minor,
		   EXA_VERSION_MAJOR, EXA_VERSION_MINOR);
	return FALSE;
d852 17
a868 17
	if (!pScreenInfo->memoryBase) {
	    LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memoryBase "
		       "must be non-zero\n", pScreen->myNum);
	    return FALSE;
	}

	if (!pScreenInfo->memorySize) {
	    LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memorySize must be "
		       "non-zero\n", pScreen->myNum);
	    return FALSE;
	}

	if (pScreenInfo->offScreenBase > pScreenInfo->memorySize) {
	    LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::offScreenBase must "
		       "be <= ExaDriverRec::memorySize\n", pScreen->myNum);
	    return FALSE;
	}
d872 3
a874 3
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::PrepareSolid must be "
		   "non-NULL\n", pScreen->myNum);
	return FALSE;
d878 3
a880 3
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::PrepareCopy must be "
		   "non-NULL\n", pScreen->myNum);
	return FALSE;
d884 3
a886 3
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::WaitMarker must be "
		   "non-NULL\n", pScreen->myNum);
	return FALSE;
d898 1
a898 2
    if (!pScreenInfo->maxPitchPixels && !pScreenInfo->maxPitchBytes)
    {
d906 2
a907 2
		   pScreen->myNum);
	return FALSE;
d910 1
a910 1
    pExaScr = calloc (sizeof (ExaScreenPrivRec), 1);
d913 2
a914 2
		   pScreen->myNum);
	return FALSE;
d925 5
a929 5
    if (!dixRegisterPrivateKey(&exaGCPrivateKeyRec, PRIVATE_GC, sizeof(ExaGCPrivRec))) {
	LogMessage(X_WARNING,
	       "EXA(%d): Failed to allocate GC private\n",
	       pScreen->myNum);
	return FALSE;
d936 3
a938 3
	(!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS) ||
	 (pExaScr->info->flags & EXA_MIXED_PIXMAPS)))
	wrap(pExaScr, pScreen, BlockHandler, ExaBlockHandler);
d940 2
a941 2
	!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS))
	wrap(pExaScr, pScreen, WakeupHandler, ExaWakeupHandler);
d952 10
a961 9
	wrap(pExaScr, ps, Composite, exaComposite);
	if (pScreenInfo->PrepareComposite) {
	    wrap(pExaScr, ps, Glyphs, exaGlyphs);
	} else {
	    wrap(pExaScr, ps, Glyphs, ExaCheckGlyphs);
	}
	wrap(pExaScr, ps, Trapezoids, exaTrapezoids);
	wrap(pExaScr, ps, Triangles, exaTriangles);
	wrap(pExaScr, ps, AddTraps, ExaCheckAddTraps);
d973 4
a976 3
    if (pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS)
    {
	if (!dixRegisterPrivateKey(&exaPixmapPrivateKeyRec, PRIVATE_PIXMAP, sizeof(ExaPixmapPrivRec))) {
d978 44
a1021 3
		       "EXA(%d): Failed to allocate pixmap private\n",
		       pScreen->myNum);
	    return FALSE;
d1023 3
a1025 37
	if (pExaScr->info->flags & EXA_HANDLES_PIXMAPS) {
	    if (pExaScr->info->flags & EXA_MIXED_PIXMAPS) {
		wrap(pExaScr, pScreen, CreatePixmap, exaCreatePixmap_mixed);
		wrap(pExaScr, pScreen, DestroyPixmap, exaDestroyPixmap_mixed);
		wrap(pExaScr, pScreen, ModifyPixmapHeader, exaModifyPixmapHeader_mixed);
		pExaScr->do_migration = exaDoMigration_mixed;
		pExaScr->pixmap_has_gpu_copy = exaPixmapHasGpuCopy_mixed;
		pExaScr->do_move_in_pixmap = exaMoveInPixmap_mixed;
		pExaScr->do_move_out_pixmap = NULL;
		pExaScr->prepare_access_reg = exaPrepareAccessReg_mixed;
	    } else {
		wrap(pExaScr, pScreen, CreatePixmap, exaCreatePixmap_driver);
		wrap(pExaScr, pScreen, DestroyPixmap, exaDestroyPixmap_driver);
		wrap(pExaScr, pScreen, ModifyPixmapHeader, exaModifyPixmapHeader_driver);
		pExaScr->do_migration = NULL;
		pExaScr->pixmap_has_gpu_copy = exaPixmapHasGpuCopy_driver;
		pExaScr->do_move_in_pixmap = NULL;
		pExaScr->do_move_out_pixmap = NULL;
		pExaScr->prepare_access_reg = NULL;
	    }
	} else {
	    wrap(pExaScr, pScreen, CreatePixmap, exaCreatePixmap_classic);
	    wrap(pExaScr, pScreen, DestroyPixmap, exaDestroyPixmap_classic);
	    wrap(pExaScr, pScreen, ModifyPixmapHeader, exaModifyPixmapHeader_classic);
	    pExaScr->do_migration = exaDoMigration_classic;
	    pExaScr->pixmap_has_gpu_copy = exaPixmapHasGpuCopy_classic;
	    pExaScr->do_move_in_pixmap = exaMoveInPixmap_classic;
	    pExaScr->do_move_out_pixmap = exaMoveOutPixmap_classic;
	    pExaScr->prepare_access_reg = exaPrepareAccessReg_classic;
	}
	if (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS)) {
	    LogMessage(X_INFO, "EXA(%d): Offscreen pixmap area of %lu bytes\n",
		       pScreen->myNum,
		       pExaScr->info->memorySize - pExaScr->info->offScreenBase);
	} else {
	    LogMessage(X_INFO, "EXA(%d): Driver allocated offscreen pixmaps\n",
		       pScreen->myNum);
d1027 1
a1027 1
	}
d1033 10
a1042 9
	DBG_PIXMAP(("============== %ld < %ld\n", pExaScr->info->offScreenBase,
		    pExaScr->info->memorySize));
	if (pExaScr->info->offScreenBase < pExaScr->info->memorySize) {
	    if (!exaOffscreenInit (pScreen)) {
		LogMessage(X_WARNING, "EXA(%d): Offscreen pixmap setup failed\n",
			   pScreen->myNum);
		return FALSE;
	    }
	}
d1046 1
a1046 1
	exaGlyphsInit(pScreen);
d1049 1
a1049 1
	       " operations:\n", pScreen->myNum);
d1055 1
a1055 1
	LogMessage(X_INFO, "        Composite (RENDER acceleration)\n");
d1058 1
a1058 1
	LogMessage(X_INFO, "        UploadToScreen\n");
d1061 1
a1061 1
	LogMessage(X_INFO, "        DownloadFromScreen\n");
d1073 1
a1073 1
exaDriverFini (ScreenPtr pScreen)
d1075 1
a1075 1
    /*right now does nothing*/
d1089 2
a1090 1
void exaMarkSync(ScreenPtr pScreen)
d1096 1
a1096 1
        pExaScr->info->lastMarker = (*pExaScr->info->MarkSync)(pScreen);
d1109 2
a1110 1
void exaWaitSync(ScreenPtr pScreen)
d1115 1
a1115 1
        (*pExaScr->info->WaitMarker)(pScreen, pExaScr->info->lastMarker);
d1126 1
a1126 1
exaDoMigration (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel)
d1129 1
d1133 1
a1133 1
	return;
d1136 1
a1136 1
	(*pExaScr->do_migration)(pixmaps, npixmaps, can_accel);
d1140 1
a1140 1
exaMoveInPixmap (PixmapPtr pPixmap)
d1143 1
d1147 1
a1147 1
	return;
d1150 1
a1150 1
	(*pExaScr->do_move_in_pixmap)(pPixmap);
d1154 1
a1154 1
exaMoveOutPixmap (PixmapPtr pPixmap)
d1157 1
d1161 1
a1161 1
	return;
d1164 1
a1164 1
	(*pExaScr->do_move_out_pixmap)(pPixmap);
@


1.9
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d2 1
a2 1
 * Copyright  2001 Keith Packard
d4 1
a4 1
 * Partly based on code that is Copyright  The XFree86 Project Inc.
@


1.8
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d424 2
a425 1
    if (!pExaScr->info->FinishAccess || !exaPixmapHasGpuCopy(pPixmap))
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d162 1
a162 2
    DamageRegionAppend(&pPix->drawable, &region);
    DamageRegionProcessPending(&pPix->drawable);
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d40 3
a42 6
static int exaScreenPrivateKeyIndex;
DevPrivateKey exaScreenPrivateKey = &exaScreenPrivateKeyIndex;
static int exaPixmapPrivateKeyIndex;
DevPrivateKey exaPixmapPrivateKey = &exaPixmapPrivateKeyIndex;
static int exaGCPrivateKeyIndex;
DevPrivateKey exaGCPrivateKey = &exaGCPrivateKeyIndex;
d161 1
a161 1
    REGION_INIT(pScreen, &region, &box, 1);
d164 1
a164 1
    REGION_UNINIT(pScreen, &region);
d438 23
d681 1
a681 1
    ret = pScreen->BitmapToRegion(pPix);
a775 1
#ifdef RENDER
a776 1
#endif
d799 6
a804 10
#ifdef RENDER
    if (ps) {
	unwrap(pExaScr, ps, Composite);
	if (pExaScr->SavedGlyphs)
	    unwrap(pExaScr, ps, Glyphs);
	unwrap(pExaScr, ps, Trapezoids);
	unwrap(pExaScr, ps, Triangles);
	unwrap(pExaScr, ps, AddTraps);
    }
#endif
d806 1
a806 1
    xfree (pExaScr);
d817 1
a817 1
 * driver structure using xfree().
d824 1
a824 1
    return xcalloc(1, sizeof(ExaDriverRec));
a841 1
#ifdef RENDER
a842 1
#endif
a909 1
#ifdef RENDER
a910 1
#endif
d912 7
a918 1
    pExaScr = xcalloc (sizeof (ExaScreenPrivRec), 1);
d933 1
a933 1
    if (!dixRequestPrivate(exaGCPrivateKey, sizeof(ExaGCPrivRec))) {
a958 1
#ifdef RENDER
d961 1
a961 1
	if (pScreenInfo->PrepareComposite)
d963 3
a969 1
#endif
d982 1
a982 1
	if (!dixRequestPrivate(exaPixmapPrivateKey, sizeof(ExaPixmapPrivRec))) {
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d44 2
a50 11
static _X_INLINE void*
ExaGetPixmapAddress(PixmapPtr p)
{
    ExaPixmapPriv(p);

    if (pExaPixmap->offscreen && pExaPixmap->fb_ptr)
	return pExaPixmap->fb_ptr;
    else
	return pExaPixmap->sys_ptr;
}

d65 1
d67 1
a67 2
    return ((unsigned long)ExaGetPixmapAddress(pPix) -
	    (unsigned long)pExaScr->info->memoryBase);
d123 1
a123 1
}	
a152 1
    ExaPixmapPriv(pPix);
a153 1
    RegionPtr pDamageReg;
a155 3
    if (!pExaPixmap || !pExaPixmap->pDamage)
	return;
	
a163 2
    pDamageReg = DamageRegion(pExaPixmap->pDamage);

d165 2
a166 1
    REGION_UNION(pScreen, pDamageReg, pDamageReg, &region);
a169 33
static Bool
exaDestroyPixmap (PixmapPtr pPixmap)
{
    ScreenPtr	pScreen = pPixmap->drawable.pScreen;
    ExaScreenPriv(pScreen);

    if (pPixmap->refcnt == 1)
    {
	ExaPixmapPriv (pPixmap);

	if (pExaPixmap->driverPriv) {
	    pExaScr->info->DestroyPixmap(pScreen, pExaPixmap->driverPriv);
	    pExaPixmap->driverPriv = NULL;
	}

	if (pExaPixmap->area)
	{
	    DBG_PIXMAP(("-- 0x%p (0x%x) (%dx%d)\n",
                        (void*)pPixmap->drawable.id,
			 ExaGetPixmapPriv(pPixmap)->area->offset,
			 pPixmap->drawable.width,
			 pPixmap->drawable.height));
	    /* Free the offscreen area */
	    exaOffscreenFree (pPixmap->drawable.pScreen, pExaPixmap->area);
	    pPixmap->devPrivate.ptr = pExaPixmap->sys_ptr;
	    pPixmap->devKind = pExaPixmap->sys_pitch;
	}
	REGION_UNINIT(pPixmap->drawable.pScreen, &pExaPixmap->validSys);
	REGION_UNINIT(pPixmap->drawable.pScreen, &pExaPixmap->validFB);
    }
    return fbDestroyPixmap (pPixmap);
}

d182 1
a182 1
static void
d189 1
a189 1
        int max_pitch = pExaScr->info->maxPitchPixels * (bpp + 7) / 8;
d206 1
a206 1
static void
d211 1
a211 1
        pExaPixmap->fb_pitch = (1 << (exaLog2(w - 1) + 1)) * bpp / 8;
d213 1
a213 1
        pExaPixmap->fb_pitch = w * bpp / 8;
d220 6
a225 123
 * exaCreatePixmap() creates a new pixmap.
 *
 * If width and height are 0, this won't be a full-fledged pixmap and it will
 * get ModifyPixmapHeader() called on it later.  So, we mark it as pinned, because
 * ModifyPixmapHeader() would break migration.  These types of pixmaps are used
 * for scratch pixmaps, or to represent the visible screen.
 */
static PixmapPtr
exaCreatePixmap(ScreenPtr pScreen, int w, int h, int depth,
		unsigned usage_hint)
{
    PixmapPtr		pPixmap;
    ExaPixmapPrivPtr	pExaPixmap;
    int                 driver_alloc = 0;
    int			bpp;
    ExaScreenPriv(pScreen);

    if (w > 32767 || h > 32767)
	return NullPixmap;

    if (!pExaScr->info->CreatePixmap) {
        pPixmap = fbCreatePixmap (pScreen, w, h, depth, usage_hint);
    } else {
        driver_alloc = 1;
        pPixmap = fbCreatePixmap(pScreen, 0, 0, depth, usage_hint);
    }

    if (!pPixmap)
        return NULL;

    pExaPixmap = ExaGetPixmapPriv(pPixmap);
    pExaPixmap->driverPriv = NULL;

    bpp = pPixmap->drawable.bitsPerPixel;

    if (driver_alloc) {
        size_t paddedWidth, datasize;

	paddedWidth = ((w * bpp + FB_MASK) >> FB_SHIFT) * sizeof(FbBits);
        if (paddedWidth / 4 > 32767 || h > 32767)
            return NullPixmap;

        exaSetFbPitch(pExaScr, pExaPixmap, w, h, bpp);

        if (paddedWidth < pExaPixmap->fb_pitch)
            paddedWidth = pExaPixmap->fb_pitch;

        datasize = h * paddedWidth;

	/* Set this before driver hooks, to allow for !offscreen pixmaps.
	 * !offscreen pixmaps have a valid pointer at all times.
	 */
	pPixmap->devPrivate.ptr = NULL;

        pExaPixmap->driverPriv = pExaScr->info->CreatePixmap(pScreen, datasize, 0);
        if (!pExaPixmap->driverPriv) {
             fbDestroyPixmap(pPixmap);
             return NULL;
        }

        (*pScreen->ModifyPixmapHeader)(pPixmap, w, h, 0, 0,
                                       paddedWidth, NULL);
        pExaPixmap->score = EXA_PIXMAP_SCORE_PINNED;
        pExaPixmap->fb_ptr = NULL;
        pExaPixmap->pDamage = NULL;
        pExaPixmap->sys_ptr = pPixmap->devPrivate.ptr;

    } else {
        pExaPixmap->driverPriv = NULL;
        /* Scratch pixmaps may have w/h equal to zero, and may not be
	 * migrated.
	 */
        if (!w || !h)
	    pExaPixmap->score = EXA_PIXMAP_SCORE_PINNED;
        else
            pExaPixmap->score = EXA_PIXMAP_SCORE_INIT;

        pExaPixmap->sys_ptr = pPixmap->devPrivate.ptr;
        pExaPixmap->sys_pitch = pPixmap->devKind;

        pPixmap->devPrivate.ptr = NULL;
        pExaPixmap->offscreen = FALSE;

        pExaPixmap->fb_ptr = NULL;
        exaSetFbPitch(pExaScr, pExaPixmap, w, h, bpp);
        pExaPixmap->fb_size = pExaPixmap->fb_pitch * h;

        if (pExaPixmap->fb_pitch > 131071) {
	     fbDestroyPixmap(pPixmap);
	     return NULL;
        }

	/* Set up damage tracking */
	pExaPixmap->pDamage = DamageCreate (NULL, NULL,
					    DamageReportNone, TRUE,
					    pScreen, pPixmap);

	if (pExaPixmap->pDamage == NULL) {
	    fbDestroyPixmap (pPixmap);
	    return NULL;
	}

	DamageRegister (&pPixmap->drawable, pExaPixmap->pDamage);
	/* This ensures that pending damage reflects the current operation. */
	/* This is used by exa to optimize migration. */
	DamageSetReportAfterOp (pExaPixmap->pDamage, TRUE);
    }
 
    pExaPixmap->area = NULL;

    /* None of the pixmap bits are valid initially */
    REGION_NULL(pScreen, &pExaPixmap->validSys);
    REGION_NULL(pScreen, &pExaPixmap->validFB);

    exaSetAccelBlock(pExaScr, pExaPixmap,
                     w, h, bpp);

    return pPixmap;
}

static Bool
exaModifyPixmapHeader(PixmapPtr pPixmap, int width, int height, int depth,
		      int bitsPerPixel, int devKind, pointer pPixData)
d227 1
a227 3
    ExaScreenPrivPtr pExaScr;
    ExaPixmapPrivPtr pExaPixmap;
    Bool ret;
d229 2
a230 2
    if (!pPixmap)
        return FALSE;
d232 1
a232 28
    pExaScr = ExaGetScreenPriv(pPixmap->drawable.pScreen);
    pExaPixmap = ExaGetPixmapPriv(pPixmap);

    if (pExaPixmap) {
        if (pPixData)
            pExaPixmap->sys_ptr = pPixData;

        if (devKind > 0)
            pExaPixmap->sys_pitch = devKind;

        if (width > 0 && height > 0 && bitsPerPixel > 0) {
            exaSetFbPitch(pExaScr, pExaPixmap,
                          width, height, bitsPerPixel);

            exaSetAccelBlock(pExaScr, pExaPixmap,
                             width, height, bitsPerPixel);
        }
    }


    if (pExaScr->info->ModifyPixmapHeader) {
	ret = pExaScr->info->ModifyPixmapHeader(pPixmap, width, height, depth,
						bitsPerPixel, devKind, pPixData);
	if (ret == TRUE)
	    return ret;
    }
    return pExaScr->SavedModifyPixmapHeader(pPixmap, width, height, depth,
					    bitsPerPixel, devKind, pPixData);
d236 1
a236 1
 * exaPixmapIsOffscreen() is used to determine if a pixmap is in offscreen
d243 1
a243 1
 * pixmaps as arguments for which exaPixmapIsOffscreen() is TRUE.
d248 1
a248 1
exaPixmapIsOffscreen(PixmapPtr p)
d250 1
a250 1
    ScreenPtr	pScreen = p->drawable.pScreen;
a251 3
    ExaPixmapPriv(p);
    void *save_ptr;
    Bool ret;
d253 2
a254 13
    save_ptr = p->devPrivate.ptr;

    if (!save_ptr && pExaPixmap && !(pExaScr->info->flags & EXA_HANDLES_PIXMAPS))
	p->devPrivate.ptr = ExaGetPixmapAddress(p);

    if (pExaScr->info->PixmapIsOffscreen)
	ret = pExaScr->info->PixmapIsOffscreen(p);
    else
       ret = ((unsigned long) ((CARD8 *) p->devPrivate.ptr -
			       (CARD8 *) pExaScr->info->memoryBase) <
	      pExaScr->info->memorySize);

    p->devPrivate.ptr = save_ptr;
d256 1
a256 1
    return ret;
d260 1
a260 1
 * exaDrawableIsOffscreen() is a convenience wrapper for exaPixmapIsOffscreen().
d265 1
a265 1
    return exaPixmapIsOffscreen (exaGetDrawablePixmap (pDrawable));
d279 1
a279 1
    if (exaPixmapIsOffscreen (pPixmap))
d285 5
a289 2
void
ExaDoPrepareAccess(DrawablePtr pDrawable, int index)
d291 34
a324 4
    ScreenPtr	    pScreen = pDrawable->pScreen;
    ExaScreenPriv  (pScreen);
    PixmapPtr	    pPixmap = exaGetDrawablePixmap (pDrawable);
    Bool	    offscreen = exaPixmapIsOffscreen(pPixmap);
d326 6
a331 3
    /* Unhide pixmap pointer */
    if (pPixmap->devPrivate.ptr == NULL && !(pExaScr->info->flags & EXA_HANDLES_PIXMAPS)) {
	pPixmap->devPrivate.ptr = ExaGetPixmapAddress(pPixmap);
d334 6
a339 2
    if (!offscreen)
	return;
d341 1
a341 1
    exaWaitSync (pDrawable->pScreen);
d344 1
a344 1
	return;
d346 1
a346 1
    if (index >= EXA_PREPARE_AUX0 &&
d348 2
d351 2
a352 1
	return;
d356 3
a358 3
	ExaPixmapPriv (pPixmap);
	if (pExaPixmap->score == EXA_PIXMAP_SCORE_PINNED)
	    FatalError("Driver failed PrepareAccess on a pinned pixmap\n");
d360 2
a362 6
}

void
exaPrepareAccessReg(DrawablePtr pDrawable, int index, RegionPtr pReg)
{
    ExaMigrationRec pixmaps[1];
d364 1
a364 4
    pixmaps[0].as_dst = index == EXA_PREPARE_DEST;
    pixmaps[0].as_src = index != EXA_PREPARE_DEST;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
    pixmaps[0].pReg = pReg;
d366 3
a368 3
    exaDoMigration(pixmaps, 1, FALSE);

    ExaDoPrepareAccess(pDrawable, index);
d380 7
a386 1
    exaPrepareAccessReg(pDrawable, index, NULL);
d401 7
d409 7
a415 3
    /* Rehide pixmap pointer if we're doing that. */
    if (pExaPixmap && !(pExaScr->info->flags & EXA_HANDLES_PIXMAPS)) {
	pPixmap->devPrivate.ptr = NULL;
d418 9
a426 2
    if (pExaScr->info->FinishAccess == NULL)
	return;
d428 1
a428 1
    if (!exaPixmapIsOffscreen (pPixmap))
d431 1
a431 1
    if (index >= EXA_PREPARE_AUX0 &&
d438 1
a438 1
    (*pExaScr->info->FinishAccess) (pPixmap, index);
d442 2
a443 2
 * exaValidateGC() sets the ops to EXA's implementations, which may be
 * accelerated or may sync the card and fall back to fb.
d445 13
d459 33
a491 1
exaValidateGC (GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
d494 1
a494 2
     * Preempt fbValidateGC by doing its work and masking the change out, so
     * that we can do the Prepare/FinishAccess.
d496 23
a518 34
#ifdef FB_24_32BIT
    if ((changes & GCTile) && fbGetRotatedPixmap(pGC)) {
	(*pGC->pScreen->DestroyPixmap) (fbGetRotatedPixmap(pGC));
	fbGetRotatedPixmap(pGC) = 0;
    }
	
    if (pGC->fillStyle == FillTiled) {
	PixmapPtr	pOldTile, pNewTile;

	pOldTile = pGC->tile.pixmap;
	if (pOldTile->drawable.bitsPerPixel != pDrawable->bitsPerPixel)
	{
	    pNewTile = fbGetRotatedPixmap(pGC);
	    if (!pNewTile ||
		pNewTile ->drawable.bitsPerPixel != pDrawable->bitsPerPixel)
	    {
		if (pNewTile)
		    (*pGC->pScreen->DestroyPixmap) (pNewTile);
		/* fb24_32ReformatTile will do direct access of a newly-
		 * allocated pixmap.  This isn't a problem yet, since we don't
		 * put pixmaps in FB until at least one accelerated EXA op.
		 */
		exaPrepareAccess(&pOldTile->drawable, EXA_PREPARE_SRC);
		pNewTile = fb24_32ReformatTile (pOldTile,
						pDrawable->bitsPerPixel);
		exaPixmapDirty(pNewTile, 0, 0, pNewTile->drawable.width, pNewTile->drawable.height);
		exaFinishAccess(&pOldTile->drawable, EXA_PREPARE_SRC);
	    }
	    if (pNewTile)
	    {
		fbGetRotatedPixmap(pGC) = pOldTile;
		pGC->tile.pixmap = pNewTile;
		changes |= GCTile;
	    }
a520 17
#endif
    if (changes & GCTile) {
	if (!pGC->tileIsPixel && FbEvenTile (pGC->tile.pixmap->drawable.width *
					     pDrawable->bitsPerPixel))
	{
	    exaPrepareAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
	    fbPadPixmap (pGC->tile.pixmap);
	    exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
	    exaPixmapDirty(pGC->tile.pixmap, 0, 0,
			   pGC->tile.pixmap->drawable.width,
			   pGC->tile.pixmap->drawable.height);
	}
	/* Mask out the GCTile change notification, now that we've done FB's
	 * job for it.
	 */
	changes &= ~GCTile;
    }
d522 62
a583 3
    exaPrepareAccessGC(pGC);
    fbValidateGC (pGC, changes, pDrawable);
    exaFinishAccessGC(pGC);
d585 7
a591 1
    pGC->ops = (GCOps *) &exaOps;
d594 8
a601 9
static GCFuncs	exaGCFuncs = {
    exaValidateGC,
    miChangeGC,
    miCopyGC,
    miDestroyGC,
    miChangeClip,
    miDestroyClip,
    miCopyClip
};
d610 4
a613 2
    if (!fbCreateGC (pGC))
	return FALSE;
d615 6
a620 1
    pGC->funcs = &exaGCFuncs;
d622 1
a622 1
    return TRUE;
d629 2
d633 1
a633 1
        exaPrepareAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);
d636 1
a636 1
        exaPrepareAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_MASK);
d638 5
a642 1
    ret = fbChangeWindowAttributes(pWin, mask);
d644 2
d647 1
a647 4
        exaFinishAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_MASK);

    if ((mask & CWBackPixmap) && pWin->backgroundState == BackgroundPixmap) 
        exaFinishAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);
d655 11
a665 5
  RegionPtr ret;
  exaPrepareAccess(&pPix->drawable, EXA_PREPARE_SRC);
  ret = fbPixmapToRegion(pPix);
  exaFinishAccess(&pPix->drawable, EXA_PREPARE_SRC);
  return ret;
d675 1
a675 1
    pScreen->CreateScreenResources = pExaScr->SavedCreateScreenResources;
d677 1
a677 1
    pScreen->CreateScreenResources = exaCreateScreenResources;
d696 52
d763 18
a780 10
    pScreen->CreateGC = pExaScr->SavedCreateGC;
    pScreen->CloseScreen = pExaScr->SavedCloseScreen;
    pScreen->GetImage = pExaScr->SavedGetImage;
    pScreen->GetSpans = pExaScr->SavedGetSpans;
    pScreen->CreatePixmap = pExaScr->SavedCreatePixmap;
    pScreen->DestroyPixmap = pExaScr->SavedDestroyPixmap;
    pScreen->CopyWindow = pExaScr->SavedCopyWindow;
    pScreen->ChangeWindowAttributes = pExaScr->SavedChangeWindowAttributes;
    pScreen->BitmapToRegion = pExaScr->SavedBitmapToRegion;
    pScreen->CreateScreenResources = pExaScr->SavedCreateScreenResources;
d783 6
a788 5
	ps->Composite = pExaScr->SavedComposite;
	ps->Glyphs = pExaScr->SavedGlyphs;
	ps->Trapezoids = pExaScr->SavedTrapezoids;
	ps->Triangles = pExaScr->SavedTriangles;
	ps->AddTraps = pExaScr->SavedAddTraps;
d846 1
a846 1
    if (!pScreenInfo->CreatePixmap) {
a902 1

d917 7
d927 15
a941 23
    pExaScr->SavedCloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = exaCloseScreen;

    pExaScr->SavedCreateGC = pScreen->CreateGC;
    pScreen->CreateGC = exaCreateGC;

    pExaScr->SavedGetImage = pScreen->GetImage;
    pScreen->GetImage = exaGetImage;

    pExaScr->SavedGetSpans = pScreen->GetSpans;
    pScreen->GetSpans = ExaCheckGetSpans;

    pExaScr->SavedCopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = exaCopyWindow;

    pExaScr->SavedChangeWindowAttributes = pScreen->ChangeWindowAttributes;
    pScreen->ChangeWindowAttributes = exaChangeWindowAttributes;

    pExaScr->SavedBitmapToRegion = pScreen->BitmapToRegion;
    pScreen->BitmapToRegion = exaBitmapToRegion;

    pExaScr->SavedCreateScreenResources = pScreen->CreateScreenResources;
    pScreen->CreateScreenResources = exaCreateScreenResources;
d945 6
a950 16
        pExaScr->SavedComposite = ps->Composite;
	ps->Composite = exaComposite;

	if (pScreenInfo->PrepareComposite) {
	    pExaScr->SavedGlyphs = ps->Glyphs;
	    ps->Glyphs = exaGlyphs;
	}
	
	pExaScr->SavedTriangles = ps->Triangles;
	ps->Triangles = exaTriangles;

	pExaScr->SavedTrapezoids = ps->Trapezoids;
	ps->Trapezoids = exaTrapezoids;

	pExaScr->SavedAddTraps = ps->AddTraps;
	ps->AddTraps = ExaCheckAddTraps;
d971 31
a1001 9
        pExaScr->SavedCreatePixmap = pScreen->CreatePixmap;
	pScreen->CreatePixmap = exaCreatePixmap;

        pExaScr->SavedDestroyPixmap = pScreen->DestroyPixmap;
	pScreen->DestroyPixmap = exaDestroyPixmap;

	pExaScr->SavedModifyPixmapHeader = pScreen->ModifyPixmapHeader;
	pScreen->ModifyPixmapHeader = exaModifyPixmapHeader;
	if (!pExaScr->info->CreatePixmap) {
d1014 1
a1014 1
    if (!pExaScr->info->CreatePixmap) {
d1097 44
@


1.4
log
@Set default migration strategy to "greedy". ok oga@@.
@
text
@a37 2
#include <X11/fonts/fontstruct.h>
#include "dixfontstr.h"
a38 1
#include "cw.h"
d40 4
a43 2
DevPrivateKey exaScreenPrivateKey = &exaScreenPrivateKey;
DevPrivateKey exaPixmapPrivateKey = &exaPixmapPrivateKey;
d167 1
a167 1
    if (!pExaPixmap)
d317 5
d332 3
d359 15
a377 12
    /* Set up damage tracking */
    pExaPixmap->pDamage = DamageCreate (NULL, NULL, DamageReportNone, TRUE,
					pScreen, pPixmap);

    if (pExaPixmap->pDamage == NULL) {
	fbDestroyPixmap (pPixmap);
	return NULL;
    }

    DamageRegister (&pPixmap->drawable, pExaPixmap->pDamage);
    DamageSetReportAfterOp (pExaPixmap->pDamage, TRUE);

d514 6
d579 7
d686 2
a687 2
void
exaPrepareAccessWindow(WindowPtr pWin)
d689 3
a691 1
    if (pWin->backgroundState == BackgroundPixmap) 
d694 2
a695 3
    if (pWin->borderIsPixel == FALSE)
        exaPrepareAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_SRC);
}
d697 1
a697 5
void
exaFinishAccessWindow(WindowPtr pWin)
{
    if (pWin->backgroundState == BackgroundPixmap) 
        exaFinishAccess(&pWin->background.pixmap->drawable, EXA_PREPARE_SRC);
d699 2
a700 3
    if (pWin->borderIsPixel == FALSE)
        exaFinishAccess(&pWin->border.pixmap->drawable, EXA_PREPARE_SRC);
}
d702 2
a703 4
static Bool
exaChangeWindowAttributes(WindowPtr pWin, unsigned long mask)
{
    Bool ret;
a704 3
    exaPrepareAccessWindow(pWin);
    ret = fbChangeWindowAttributes(pWin, mask);
    exaFinishAccessWindow(pWin);
d758 3
d774 1
d776 1
d903 1
a903 1
    pExaScr->migration = ExaMigrationGreedy;
d939 5
d1004 3
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d884 1
a884 1
    pExaScr->migration = ExaMigrationAlways;
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a34 4
#ifdef MITSHM
#include "shmint.h"
#endif

d43 17
a59 3
static int exaGeneration;
int exaScreenPrivateIndex;
int exaPixmapPrivateIndex;
a74 2
    ExaPixmapPriv (pPix);
    void *ptr;
d76 8
a83 5
    /* Return the offscreen pointer if we've hidden the data. */
    if (pPix->devPrivate.ptr == NULL)
	ptr = pExaPixmap->fb_ptr;
    else
	ptr = pPix->devPrivate.ptr;
d85 1
a85 1
    return ((unsigned long)ptr - (unsigned long)pExaScr->info->memoryBase);
d189 3
d195 6
d213 2
a214 1
	REGION_UNINIT(pPixmap->drawable.pScreen, &pExaPixmap->validReg);
d231 37
d277 2
a278 1
exaCreatePixmap(ScreenPtr pScreen, int w, int h, int depth)
d282 1
d289 7
a295 1
    pPixmap = fbCreatePixmap (pScreen, w, h, depth);
d297 2
a298 1
	return NULL;
d300 1
d304 8
a311 5
    /* Glyphs have w/h equal to zero, and may not be migrated. See exaGlyphs. */
    if (!w || !h)
	pExaPixmap->score = EXA_PIXMAP_SCORE_PINNED;
    else
	pExaPixmap->score = EXA_PIXMAP_SCORE_INIT;
d313 2
a314 1
    pExaPixmap->area = NULL;
d316 1
a316 2
    pExaPixmap->sys_ptr = pPixmap->devPrivate.ptr;
    pExaPixmap->sys_pitch = pPixmap->devKind;
d318 5
a322 8
    pExaPixmap->fb_ptr = NULL;
    if (pExaScr->info->flags & EXA_OFFSCREEN_ALIGN_POT && w != 1)
	pExaPixmap->fb_pitch = (1 << (exaLog2(w - 1) + 1)) * bpp / 8;
    else
	pExaPixmap->fb_pitch = w * bpp / 8;
    pExaPixmap->fb_pitch = EXA_ALIGN(pExaPixmap->fb_pitch,
				     pExaScr->info->pixmapPitchAlign);
    pExaPixmap->fb_size = pExaPixmap->fb_pitch * h;
d324 28
a351 3
    if (pExaPixmap->fb_pitch > 131071) {
	fbDestroyPixmap(pPixmap);
	return NULL;
d353 2
d369 5
a373 1
    REGION_NULL(pScreen, &pExaPixmap->validReg);
d378 41
d436 5
d442 2
a443 4
    /* If the devPrivate.ptr is NULL, it's offscreen but we've hidden the data.
     */
    if (p->devPrivate.ptr == NULL)
	return TRUE;
d446 7
a452 1
	return pExaScr->info->PixmapIsOffscreen(p);
d454 1
a454 3
    return ((unsigned long) ((CARD8 *) p->devPrivate.ptr -
			     (CARD8 *) pExaScr->info->memoryBase) <
	    pExaScr->info->memorySize);
a482 6
/**
 * exaPrepareAccess() is EXA's wrapper for the driver's PrepareAccess() handler.
 *
 * It deals with waiting for synchronization with the card, determining if
 * PrepareAccess() is necessary, and working around PrepareAccess() failure.
 */
d484 1
a484 1
exaPrepareAccess(DrawablePtr pDrawable, int index)
d488 2
a489 1
    PixmapPtr	    pPixmap;
d491 4
a494 1
    pPixmap = exaGetDrawablePixmap (pDrawable);
d496 1
a496 3
    if (exaPixmapIsOffscreen (pPixmap))
	exaWaitSync (pDrawable->pScreen);
    else
d499 1
a499 6
    /* Unhide pixmap pointer */
    if (pPixmap->devPrivate.ptr == NULL) {
	ExaPixmapPriv (pPixmap);

	pPixmap->devPrivate.ptr = pExaPixmap->fb_ptr;
    }
d506 1
a506 1
	if (pExaPixmap->score != EXA_PIXMAP_SCORE_PINNED)
d512 27
d549 2
a550 6
    PixmapPtr	    pPixmap;
    ExaPixmapPrivPtr pExaPixmap;

    pPixmap = exaGetDrawablePixmap (pDrawable);

    pExaPixmap = ExaGetPixmapPriv(pPixmap);
d553 2
a554 4
    if (pExaPixmap != NULL && pExaScr->hideOffscreenPixmapData &&
	pExaPixmap->fb_ptr == pPixmap->devPrivate.ptr)
    {
	pPixmap->devPrivate.ptr = pExaPixmap->fb_ptr;
d618 1
a618 4
	    /* XXX This fixes corruption with tiled pixmaps, but may just be a
	     * workaround for broken drivers
	     */
	    exaMoveOutPixmap(pGC->tile.pixmap);
d620 1
d631 1
d633 1
d663 69
a747 2
    pScreen->PaintWindowBackground = pExaScr->SavedPaintWindowBackground;
    pScreen->PaintWindowBorder = pExaScr->SavedPaintWindowBorder;
d751 3
a756 1
	ps->Glyphs = pExaScr->SavedGlyphs;
d758 1
d805 8
a812 3
    if (!pScreenInfo->memoryBase) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memoryBase must be "
		   "non-zero\n", pScreen->myNum);
d816 12
a827 5
    if (!pScreenInfo->memorySize) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memorySize must be "
		   "non-zero\n", pScreen->myNum);
	return FALSE;
    }
d829 5
a833 4
    if (pScreenInfo->offScreenBase > pScreenInfo->memorySize) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::offScreenBase must be <= "
		   "ExaDriverRec::memorySize\n", pScreen->myNum);
	return FALSE;
d854 10
a863 2
    if (pScreenInfo->exa_major != EXA_VERSION_MAJOR ||
	pScreenInfo->exa_minor > EXA_VERSION_MINOR)
d865 1
a865 6
	LogMessage(X_ERROR, "EXA(%d): driver's EXA version requirements "
		   "(%d.%d) are incompatible with EXA version (%d.%d)\n",
		   pScreen->myNum,
		   pScreenInfo->exa_major, pScreenInfo->exa_minor,
		   EXA_VERSION_MAJOR, EXA_VERSION_MINOR);
	return FALSE;
a870 6
    if (exaGeneration != serverGeneration)
    {
	exaScreenPrivateIndex = AllocateScreenPrivateIndex();
	exaPixmapPrivateIndex = AllocatePixmapPrivateIndex();
	exaGeneration = serverGeneration;
    }
d882 1
a882 1
    pScreen->devPrivates[exaScreenPrivateIndex].ptr = (pointer) pExaScr;
d901 1
a901 1
    pScreen->GetSpans = exaGetSpans;
d906 5
a910 2
    pExaScr->SavedPaintWindowBackground = pScreen->PaintWindowBackground;
    pScreen->PaintWindowBackground = exaPaintWindow;
d912 2
a913 2
    pExaScr->SavedPaintWindowBorder = pScreen->PaintWindowBorder;
    pScreen->PaintWindowBorder = exaPaintWindow;
a914 2
    pScreen->BackingStoreFuncs.SaveAreas = ExaCheckSaveAreas;
    pScreen->BackingStoreFuncs.RestoreAreas = ExaCheckRestoreAreas;
d920 2
a921 8
	pExaScr->SavedRasterizeTrapezoid = ps->RasterizeTrapezoid;
	ps->RasterizeTrapezoid = exaRasterizeTrapezoid;

	pExaScr->SavedAddTriangles = ps->AddTriangles;
	ps->AddTriangles = exaAddTriangles;

	pExaScr->SavedGlyphs = ps->Glyphs;
	ps->Glyphs = exaGlyphs;
d925 3
d932 2
a933 3
    /* Re-register with the MI funcs, which don't allow shared pixmaps.
     * Shared pixmaps are almost always a performance loss for us, but this
     * still allows for SHM PutImage.
d935 1
a935 1
    ShmRegisterFuncs(pScreen, NULL);
d940 1
a940 2
    if ((pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS) &&
	pExaScr->info->offScreenBase < pExaScr->info->memorySize)
d942 1
a942 2
	if (!AllocatePixmapPrivate(pScreen, exaPixmapPrivateIndex,
				   sizeof (ExaPixmapPrivRec))) {
d954 11
a964 3
	LogMessage(X_INFO, "EXA(%d): Offscreen pixmap area of %d bytes\n",
		   pScreen->myNum,
		   pExaScr->info->memorySize - pExaScr->info->offScreenBase);
a966 1
    {
a967 3
	if (!AllocatePixmapPrivate(pScreen, exaPixmapPrivateIndex, 0))
	    return FALSE;
    }
d969 10
a978 8
    DBG_PIXMAP(("============== %ld < %ld\n", pExaScr->info->offScreenBase,
                pExaScr->info->memorySize));
    if (pExaScr->info->offScreenBase < pExaScr->info->memorySize) {
	if (!exaOffscreenInit (pScreen)) {
            LogMessage(X_WARNING, "EXA(%d): Offscreen pixmap setup failed\n",
                       pScreen->myNum);
            return FALSE;
        }
@


1.1
log
@Initial revision
@
text
@d35 4
d125 22
a146 1
 * exaDrawableDirty() marks a pixmap backing a drawable as dirty, allowing for
d150 1
a150 1
exaDrawableDirty (DrawablePtr pDrawable)
d152 17
a168 1
    ExaPixmapPrivPtr pExaPixmap;
d170 3
a172 3
    pExaPixmap = ExaGetPixmapPriv(exaGetDrawablePixmap (pDrawable));
    if (pExaPixmap != NULL)
	pExaPixmap->dirty = TRUE;
d193 1
d256 1
a256 1
    if (pExaPixmap->fb_pitch > 32767) {
d261 14
a274 1
    pExaPixmap->dirty = FALSE;
d302 3
a321 1
 * These coordinates are nonzero only for redirected windows.
d326 3
a328 2
    PixmapPtr	pPixmap;
    int		x, y;
a329 18
    if (pDrawable->type == DRAWABLE_WINDOW) {
	pPixmap = (*pDrawable->pScreen->GetWindowPixmap) ((WindowPtr) pDrawable);
#ifdef COMPOSITE
	x = -pPixmap->screen_x;
	y = -pPixmap->screen_y;
#else
	x = 0;
	y = 0;
#endif
    }
    else
    {
	pPixmap = (PixmapPtr) pDrawable;
	x = 0;
	y = 0;
    }
    *xp = x;
    *yp = y;
d377 1
a377 2
 * It deals with marking drawables as dirty, and calling the driver's
 * FinishAccess() only if necessary.
a386 3
    if (index == EXA_PREPARE_DEST)
	exaDrawableDirty (pDrawable);

d412 1
a412 1
exaValidateGC (GCPtr pGC, Mask changes, DrawablePtr pDrawable)
d443 1
d459 4
a462 1
	    exaPrepareAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
d464 3
a466 1
	    exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
d529 1
d573 39
d645 1
a645 1
    pExaScr->migration = ExaMigrationSmart;
d688 3
d694 6
a699 2
#ifdef COMPOSITE
    miDisableCompositeWrapper(pScreen);
a700 1

@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a34 4
#ifdef MITSHM
#include "shmint.h"
#endif

d121 1
a121 22
 * Sets the offsets to add to coordinates to make them address the same bits in
 * the backing drawable. These coordinates are nonzero only for redirected
 * windows.
 */
void
exaGetDrawableDeltas (DrawablePtr pDrawable, PixmapPtr pPixmap,
		      int *xp, int *yp)
{
#ifdef COMPOSITE
    if (pDrawable->type == DRAWABLE_WINDOW) {
	*xp = -pPixmap->screen_x;
	*yp = -pPixmap->screen_y;
	return;
    }
#endif

    *xp = 0;
    *yp = 0;
}

/**
 * exaPixmapDirty() marks a pixmap as dirty, allowing for
d125 1
a125 1
exaPixmapDirty (PixmapPtr pPix, int x1, int y1, int x2, int y2)
d127 1
a127 4
    ExaPixmapPriv(pPix);
    BoxRec box;
    RegionPtr pDamageReg;
    RegionRec region;
d129 3
a131 16
    if (!pExaPixmap)
	return;
	
    box.x1 = max(x1, 0);
    box.y1 = max(y1, 0);
    box.x2 = min(x2, pPix->drawable.width);
    box.y2 = min(y2, pPix->drawable.height);

    if (box.x1 >= box.x2 || box.y1 >= box.y2)
	return;

    pDamageReg = DamageRegion(pExaPixmap->pDamage);

    REGION_INIT(pScreen, &region, &box, 1);
    REGION_UNION(pScreen, pDamageReg, pDamageReg, &region);
    REGION_UNINIT(pScreen, &region);
a151 1
	REGION_UNINIT(pPixmap->drawable.pScreen, &pExaPixmap->validReg);
d219 1
a219 14
    /* Set up damage tracking */
    pExaPixmap->pDamage = DamageCreate (NULL, NULL, DamageReportNone, TRUE,
					pScreen, pPixmap);

    if (pExaPixmap->pDamage == NULL) {
	fbDestroyPixmap (pPixmap);
	return NULL;
    }

    DamageRegister (&pPixmap->drawable, pExaPixmap->pDamage);
    DamageSetReportAfterOp (pExaPixmap->pDamage, TRUE);

    /* None of the pixmap bits are valid initially */
    REGION_NULL(pScreen, &pExaPixmap->validReg);
a246 3
    if (pExaScr->info->PixmapIsOffscreen)
	return pExaScr->info->PixmapIsOffscreen(p);

d264 1
d269 2
a270 3
    PixmapPtr	pPixmap = exaGetDrawablePixmap (pDrawable);

    exaGetDrawableDeltas (pDrawable, pPixmap, xp, yp);
d272 18
d337 2
a338 1
 * It deals with calling the driver's FinishAccess() only if necessary.
d348 3
d376 1
a376 1
exaValidateGC (GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
a406 1
		exaPixmapDirty(pNewTile, 0, 0, pNewTile->drawable.width, pNewTile->drawable.height);
d422 1
a422 4
	    /* XXX This fixes corruption with tiled pixmaps, but may just be a
	     * workaround for broken drivers
	     */
	    exaMoveOutPixmap(pGC->tile.pixmap);
d424 1
a424 3
	    exaPixmapDirty(pGC->tile.pixmap, 0, 0,
			   pGC->tile.pixmap->drawable.width,
			   pGC->tile.pixmap->drawable.height);
a486 1
	ps->Trapezoids = pExaScr->SavedTrapezoids;
a529 39
    if (!pScreenInfo)
	return FALSE;

    if (!pScreenInfo->memoryBase) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memoryBase must be "
		   "non-zero\n", pScreen->myNum);
	return FALSE;
    }

    if (!pScreenInfo->memorySize) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::memorySize must be "
		   "non-zero\n", pScreen->myNum);
	return FALSE;
    }

    if (pScreenInfo->offScreenBase > pScreenInfo->memorySize) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::offScreenBase must be <= "
		   "ExaDriverRec::memorySize\n", pScreen->myNum);
	return FALSE;
    }

    if (!pScreenInfo->PrepareSolid) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::PrepareSolid must be "
		   "non-NULL\n", pScreen->myNum);
	return FALSE;
    }

    if (!pScreenInfo->PrepareCopy) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::PrepareCopy must be "
		   "non-NULL\n", pScreen->myNum);
	return FALSE;
    }

    if (!pScreenInfo->WaitMarker) {
	LogMessage(X_ERROR, "EXA(%d): ExaDriverRec::WaitMarker must be "
		   "non-NULL\n", pScreen->myNum);
	return FALSE;
    }

d563 1
a563 1
    pExaScr->migration = ExaMigrationAlways;
a605 3

	pExaScr->SavedTrapezoids = ps->Trapezoids;
	ps->Trapezoids = exaTrapezoids;
d609 2
a610 6
#ifdef MITSHM
    /* Re-register with the MI funcs, which don't allow shared pixmaps.
     * Shared pixmaps are almost always a performance loss for us, but this
     * still allows for SHM PutImage.
     */
    ShmRegisterFuncs(pScreen, NULL);
d612 1
@

