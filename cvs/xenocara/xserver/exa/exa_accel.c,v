head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.10
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.31.21.10.06;	author stsp;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.34;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.06.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2001 Keith Packard
 *
 * Partly based on code that is Copyright © The XFree86 Project Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *    Michel Dänzer <michel@@tungstengraphics.com>
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif
#include "exa_priv.h"
#include <X11/fonts/fontstruct.h>
#include "dixfontstr.h"
#include "exa.h"

static void
exaFillSpans(DrawablePtr pDrawable, GCPtr pGC, int n,
             DDXPointPtr ppt, int *pwidth, int fSorted)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    ExaScreenPriv(pScreen);
    RegionPtr pClip = fbGetCompositeClip(pGC);
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPixmap);
    BoxPtr pextent, pbox;
    int nbox;
    int extentX1, extentX2, extentY1, extentY2;
    int fullX1, fullX2, fullY1;
    int partX1, partX2;
    int off_x, off_y;

    if (pExaScr->fallback_counter ||
        pExaScr->swappedOut ||
        pGC->fillStyle != FillSolid || pExaPixmap->accel_blocked) {
        ExaCheckFillSpans(pDrawable, pGC, n, ppt, pwidth, fSorted);
        return;
    }

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[1];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pPixmap;
        pixmaps[0].pReg = NULL;

        exaDoMigration(pixmaps, 1, TRUE);
    }

    if (!(pPixmap = exaGetOffscreenPixmap(pDrawable, &off_x, &off_y)) ||
        !(*pExaScr->info->PrepareSolid) (pPixmap,
                                         pGC->alu,
                                         pGC->planemask, pGC->fgPixel)) {
        ExaCheckFillSpans(pDrawable, pGC, n, ppt, pwidth, fSorted);
        return;
    }

    pextent = RegionExtents(pClip);
    extentX1 = pextent->x1;
    extentY1 = pextent->y1;
    extentX2 = pextent->x2;
    extentY2 = pextent->y2;
    while (n--) {
        fullX1 = ppt->x;
        fullY1 = ppt->y;
        fullX2 = fullX1 + (int) *pwidth;
        ppt++;
        pwidth++;

        if (fullY1 < extentY1 || extentY2 <= fullY1)
            continue;

        if (fullX1 < extentX1)
            fullX1 = extentX1;

        if (fullX2 > extentX2)
            fullX2 = extentX2;

        if (fullX1 >= fullX2)
            continue;

        nbox = RegionNumRects(pClip);
        if (nbox == 1) {
            (*pExaScr->info->Solid) (pPixmap,
                                     fullX1 + off_x, fullY1 + off_y,
                                     fullX2 + off_x, fullY1 + 1 + off_y);
        }
        else {
            pbox = RegionRects(pClip);
            while (nbox--) {
                if (pbox->y1 <= fullY1 && fullY1 < pbox->y2) {
                    partX1 = pbox->x1;
                    if (partX1 < fullX1)
                        partX1 = fullX1;
                    partX2 = pbox->x2;
                    if (partX2 > fullX2)
                        partX2 = fullX2;
                    if (partX2 > partX1) {
                        (*pExaScr->info->Solid) (pPixmap,
                                                 partX1 + off_x, fullY1 + off_y,
                                                 partX2 + off_x,
                                                 fullY1 + 1 + off_y);
                    }
                }
                pbox++;
            }
        }
    }
    (*pExaScr->info->DoneSolid) (pPixmap);
    exaMarkSync(pScreen);
}

static Bool
exaDoPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
              int w, int h, int format, char *bits, int src_stride)
{
    ExaScreenPriv(pDrawable->pScreen);
    PixmapPtr pPix = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPix);
    RegionPtr pClip;
    BoxPtr pbox;
    int nbox;
    int xoff, yoff;
    int bpp = pDrawable->bitsPerPixel;
    Bool ret = TRUE;

    if (pExaScr->fallback_counter || pExaPixmap->accel_blocked ||
        !pExaScr->info->UploadToScreen)
        return FALSE;

    /* If there's a system copy, we want to save the result there */
    if (pExaPixmap->pDamage)
        return FALSE;

    /* Don't bother with under 8bpp, XYPixmaps. */
    if (format != ZPixmap || bpp < 8)
        return FALSE;

    /* Only accelerate copies: no rop or planemask. */
    if (!EXA_PM_IS_SOLID(pDrawable, pGC->planemask) || pGC->alu != GXcopy)
        return FALSE;

    if (pExaScr->swappedOut)
        return FALSE;

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[1];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pPix;
        pixmaps[0].pReg = DamagePendingRegion(pExaPixmap->pDamage);

        exaDoMigration(pixmaps, 1, TRUE);
    }

    pPix = exaGetOffscreenPixmap(pDrawable, &xoff, &yoff);

    if (!pPix)
        return FALSE;

    x += pDrawable->x;
    y += pDrawable->y;

    pClip = fbGetCompositeClip(pGC);
    for (nbox = RegionNumRects(pClip),
         pbox = RegionRects(pClip); nbox--; pbox++) {
        int x1 = x;
        int y1 = y;
        int x2 = x + w;
        int y2 = y + h;
        char *src;
        Bool ok;

        if (x1 < pbox->x1)
            x1 = pbox->x1;
        if (y1 < pbox->y1)
            y1 = pbox->y1;
        if (x2 > pbox->x2)
            x2 = pbox->x2;
        if (y2 > pbox->y2)
            y2 = pbox->y2;
        if (x1 >= x2 || y1 >= y2)
            continue;

        src = bits + (y1 - y) * src_stride + (x1 - x) * (bpp / 8);
        ok = pExaScr->info->UploadToScreen(pPix, x1 + xoff, y1 + yoff,
                                           x2 - x1, y2 - y1, src, src_stride);
        /* We have to fall back completely, and ignore what has already been completed.
         * Messing with the fb layer directly like we used to is completely unacceptable.
         */
        if (!ok) {
            ret = FALSE;
            break;
        }
    }

    if (ret)
        exaMarkSync(pDrawable->pScreen);

    return ret;
}

static void
exaPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
            int w, int h, int leftPad, int format, char *bits)
{
    if (!exaDoPutImage(pDrawable, pGC, depth, x, y, w, h, format, bits,
                       PixmapBytePad(w, pDrawable->depth)))
        ExaCheckPutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format,
                         bits);
}

static Bool inline
exaCopyNtoNTwoDir(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
                  GCPtr pGC, BoxPtr pbox, int nbox, int dx, int dy)
{
    ExaScreenPriv(pDstDrawable->pScreen);
    PixmapPtr pSrcPixmap, pDstPixmap;
    int src_off_x, src_off_y, dst_off_x, dst_off_y;
    int dirsetup;

    /* Need to get both pixmaps to call the driver routines */
    pSrcPixmap = exaGetOffscreenPixmap(pSrcDrawable, &src_off_x, &src_off_y);
    pDstPixmap = exaGetOffscreenPixmap(pDstDrawable, &dst_off_x, &dst_off_y);
    if (!pSrcPixmap || !pDstPixmap)
        return FALSE;

    /*
     * Now the case of a chip that only supports xdir = ydir = 1 or
     * xdir = ydir = -1, but we have xdir != ydir.
     */
    dirsetup = 0;               /* No direction set up yet. */
    for (; nbox; pbox++, nbox--) {
        if (dx >= 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
            /* Do a xdir = ydir = -1 blit instead. */
            if (dirsetup != -1) {
                if (dirsetup != 0)
                    pExaScr->info->DoneCopy(pDstPixmap);
                dirsetup = -1;
                if (!(*pExaScr->info->PrepareCopy) (pSrcPixmap,
                                                    pDstPixmap,
                                                    -1, -1,
                                                    pGC ? pGC->alu : GXcopy,
                                                    pGC ? pGC->planemask :
                                                    FB_ALLONES))
                    return FALSE;
            }
            (*pExaScr->info->Copy) (pDstPixmap,
                                    src_off_x + pbox->x1 + dx,
                                    src_off_y + pbox->y1 + dy,
                                    dst_off_x + pbox->x1,
                                    dst_off_y + pbox->y1,
                                    pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
        }
        else if (dx < 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
            /* Do a xdir = ydir = 1 blit instead. */
            if (dirsetup != 1) {
                if (dirsetup != 0)
                    pExaScr->info->DoneCopy(pDstPixmap);
                dirsetup = 1;
                if (!(*pExaScr->info->PrepareCopy) (pSrcPixmap,
                                                    pDstPixmap,
                                                    1, 1,
                                                    pGC ? pGC->alu : GXcopy,
                                                    pGC ? pGC->planemask :
                                                    FB_ALLONES))
                    return FALSE;
            }
            (*pExaScr->info->Copy) (pDstPixmap,
                                    src_off_x + pbox->x1 + dx,
                                    src_off_y + pbox->y1 + dy,
                                    dst_off_x + pbox->x1,
                                    dst_off_y + pbox->y1,
                                    pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
        }
        else if (dx >= 0) {
            /*
             * xdir = 1, ydir = -1.
             * Perform line-by-line xdir = ydir = 1 blits, going up.
             */
            int i;

            if (dirsetup != 1) {
                if (dirsetup != 0)
                    pExaScr->info->DoneCopy(pDstPixmap);
                dirsetup = 1;
                if (!(*pExaScr->info->PrepareCopy) (pSrcPixmap,
                                                    pDstPixmap,
                                                    1, 1,
                                                    pGC ? pGC->alu : GXcopy,
                                                    pGC ? pGC->planemask :
                                                    FB_ALLONES))
                    return FALSE;
            }
            for (i = pbox->y2 - pbox->y1 - 1; i >= 0; i--)
                (*pExaScr->info->Copy) (pDstPixmap,
                                        src_off_x + pbox->x1 + dx,
                                        src_off_y + pbox->y1 + dy + i,
                                        dst_off_x + pbox->x1,
                                        dst_off_y + pbox->y1 + i,
                                        pbox->x2 - pbox->x1, 1);
        }
        else {
            /*
             * xdir = -1, ydir = 1.
             * Perform line-by-line xdir = ydir = -1 blits, going down.
             */
            int i;

            if (dirsetup != -1) {
                if (dirsetup != 0)
                    pExaScr->info->DoneCopy(pDstPixmap);
                dirsetup = -1;
                if (!(*pExaScr->info->PrepareCopy) (pSrcPixmap,
                                                    pDstPixmap,
                                                    -1, -1,
                                                    pGC ? pGC->alu : GXcopy,
                                                    pGC ? pGC->planemask :
                                                    FB_ALLONES))
                    return FALSE;
            }
            for (i = 0; i < pbox->y2 - pbox->y1; i++)
                (*pExaScr->info->Copy) (pDstPixmap,
                                        src_off_x + pbox->x1 + dx,
                                        src_off_y + pbox->y1 + dy + i,
                                        dst_off_x + pbox->x1,
                                        dst_off_y + pbox->y1 + i,
                                        pbox->x2 - pbox->x1, 1);
        }
    }
    if (dirsetup != 0)
        pExaScr->info->DoneCopy(pDstPixmap);
    exaMarkSync(pDstDrawable->pScreen);
    return TRUE;
}

Bool
exaHWCopyNtoN(DrawablePtr pSrcDrawable,
              DrawablePtr pDstDrawable,
              GCPtr pGC,
              BoxPtr pbox,
              int nbox, int dx, int dy, Bool reverse, Bool upsidedown)
{
    ExaScreenPriv(pDstDrawable->pScreen);
    PixmapPtr pSrcPixmap, pDstPixmap;
    ExaPixmapPrivPtr pSrcExaPixmap, pDstExaPixmap;
    int src_off_x, src_off_y;
    int dst_off_x, dst_off_y;
    RegionPtr srcregion = NULL, dstregion = NULL;
    xRectangle *rects;
    Bool ret = TRUE;

    /* avoid doing copy operations if no boxes */
    if (nbox == 0)
        return TRUE;

    pSrcPixmap = exaGetDrawablePixmap(pSrcDrawable);
    pDstPixmap = exaGetDrawablePixmap(pDstDrawable);

    exaGetDrawableDeltas(pSrcDrawable, pSrcPixmap, &src_off_x, &src_off_y);
    exaGetDrawableDeltas(pDstDrawable, pDstPixmap, &dst_off_x, &dst_off_y);

    rects = xallocarray(nbox, sizeof(xRectangle));

    if (rects) {
        int i;
        int ordering;

        for (i = 0; i < nbox; i++) {
            rects[i].x = pbox[i].x1 + dx + src_off_x;
            rects[i].y = pbox[i].y1 + dy + src_off_y;
            rects[i].width = pbox[i].x2 - pbox[i].x1;
            rects[i].height = pbox[i].y2 - pbox[i].y1;
        }

        /* This must match the RegionCopy() logic for reversing rect order */
        if (nbox == 1 || (dx > 0 && dy > 0) ||
            (pDstDrawable != pSrcDrawable &&
             (pDstDrawable->type != DRAWABLE_WINDOW ||
              pSrcDrawable->type != DRAWABLE_WINDOW)))
            ordering = CT_YXBANDED;
        else
            ordering = CT_UNSORTED;

        srcregion = RegionFromRects(nbox, rects, ordering);
        free(rects);

        if (!pGC || !exaGCReadsDestination(pDstDrawable, pGC->planemask,
                                           pGC->fillStyle, pGC->alu,
                                           pGC->clientClip != NULL)) {
            dstregion = RegionCreate(NullBox, 0);
            RegionCopy(dstregion, srcregion);
            RegionTranslate(dstregion, dst_off_x - dx - src_off_x,
                            dst_off_y - dy - src_off_y);
        }
    }

    pSrcExaPixmap = ExaGetPixmapPriv(pSrcPixmap);
    pDstExaPixmap = ExaGetPixmapPriv(pDstPixmap);

    /* Check whether the accelerator can use this pixmap.
     * If the pitch of the pixmaps is out of range, there's nothing
     * we can do but fall back to software rendering.
     */
    if (pSrcExaPixmap->accel_blocked & EXA_RANGE_PITCH ||
        pDstExaPixmap->accel_blocked & EXA_RANGE_PITCH)
        goto fallback;

    /* If the width or the height of either of the pixmaps
     * is out of range, check whether the boxes are actually out of the
     * addressable range as well. If they aren't, we can still do
     * the copying in hardware.
     */
    if (pSrcExaPixmap->accel_blocked || pDstExaPixmap->accel_blocked) {
        int i;

        for (i = 0; i < nbox; i++) {
            /* src */
            if ((pbox[i].x2 + dx + src_off_x) >= pExaScr->info->maxX ||
                (pbox[i].y2 + dy + src_off_y) >= pExaScr->info->maxY)
                goto fallback;

            /* dst */
            if ((pbox[i].x2 + dst_off_x) >= pExaScr->info->maxX ||
                (pbox[i].y2 + dst_off_y) >= pExaScr->info->maxY)
                goto fallback;
        }
    }

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[2];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pDstPixmap;
        pixmaps[0].pReg = dstregion;
        pixmaps[1].as_dst = FALSE;
        pixmaps[1].as_src = TRUE;
        pixmaps[1].pPix = pSrcPixmap;
        pixmaps[1].pReg = srcregion;

        exaDoMigration(pixmaps, 2, TRUE);
    }

    /* Mixed directions must be handled specially if the card is lame */
    if ((pExaScr->info->flags & EXA_TWO_BITBLT_DIRECTIONS) &&
        reverse != upsidedown) {
        if (exaCopyNtoNTwoDir(pSrcDrawable, pDstDrawable, pGC, pbox, nbox,
                              dx, dy))
            goto out;
        goto fallback;
    }

    if (exaPixmapHasGpuCopy(pDstPixmap)) {
        /* Normal blitting. */
        if (exaPixmapHasGpuCopy(pSrcPixmap)) {
            if (!(*pExaScr->info->PrepareCopy)
                (pSrcPixmap, pDstPixmap, reverse ? -1 : 1, upsidedown ? -1 : 1,
                 pGC ? pGC->alu : GXcopy, pGC ? pGC->planemask : FB_ALLONES)) {
                goto fallback;
            }

            while (nbox--) {
                (*pExaScr->info->Copy) (pDstPixmap,
                                        pbox->x1 + dx + src_off_x,
                                        pbox->y1 + dy + src_off_y,
                                        pbox->x1 + dst_off_x,
                                        pbox->y1 + dst_off_y,
                                        pbox->x2 - pbox->x1,
                                        pbox->y2 - pbox->y1);
                pbox++;
            }

            (*pExaScr->info->DoneCopy) (pDstPixmap);
            exaMarkSync(pDstDrawable->pScreen);
            /* UTS: mainly for SHM PutImage's secondary path.
             *
             * Only taking this path for directly accessible pixmaps.
             */
        }
        else if (!pDstExaPixmap->pDamage && pSrcExaPixmap->sys_ptr) {
            int bpp = pSrcDrawable->bitsPerPixel;
            int src_stride = exaGetPixmapPitch(pSrcPixmap);
            CARD8 *src = NULL;

            if (!pExaScr->info->UploadToScreen)
                goto fallback;

            if (pSrcDrawable->bitsPerPixel != pDstDrawable->bitsPerPixel)
                goto fallback;

            if (pSrcDrawable->bitsPerPixel < 8)
                goto fallback;

            if (pGC &&
                !(pGC->alu == GXcopy &&
                  EXA_PM_IS_SOLID(pSrcDrawable, pGC->planemask)))
                goto fallback;

            while (nbox--) {
                src =
                    pSrcExaPixmap->sys_ptr + (pbox->y1 + dy +
                                              src_off_y) * src_stride +
                    (pbox->x1 + dx + src_off_x) * (bpp / 8);
                if (!pExaScr->info->
                    UploadToScreen(pDstPixmap, pbox->x1 + dst_off_x,
                                   pbox->y1 + dst_off_y, pbox->x2 - pbox->x1,
                                   pbox->y2 - pbox->y1, (char *) src,
                                   src_stride))
                    goto fallback;

                pbox++;
            }
        }
        else
            goto fallback;
    }
    else
        goto fallback;

    goto out;

 fallback:
    ret = FALSE;

 out:
    if (dstregion) {
        RegionUninit(dstregion);
        RegionDestroy(dstregion);
    }
    if (srcregion) {
        RegionUninit(srcregion);
        RegionDestroy(srcregion);
    }

    return ret;
}

void
exaCopyNtoN(DrawablePtr pSrcDrawable,
            DrawablePtr pDstDrawable,
            GCPtr pGC,
            BoxPtr pbox,
            int nbox,
            int dx,
            int dy,
            Bool reverse, Bool upsidedown, Pixel bitplane, void *closure)
{
    ExaScreenPriv(pDstDrawable->pScreen);

    if (pExaScr->fallback_counter ||
        (pExaScr->fallback_flags & EXA_FALLBACK_COPYWINDOW))
        return;

    if (exaHWCopyNtoN
        (pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy, reverse,
         upsidedown))
        return;

    /* This is a CopyWindow, it's cleaner to fallback at the original call. */
    if (pExaScr->fallback_flags & EXA_ACCEL_COPYWINDOW) {
        pExaScr->fallback_flags |= EXA_FALLBACK_COPYWINDOW;
        return;
    }

    /* fallback */
    ExaCheckCopyNtoN(pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy,
                     reverse, upsidedown, bitplane, closure);
}

RegionPtr
exaCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
            int srcx, int srcy, int width, int height, int dstx, int dsty)
{
    ExaScreenPriv(pDstDrawable->pScreen);

    if (pExaScr->fallback_counter || pExaScr->swappedOut) {
        return ExaCheckCopyArea(pSrcDrawable, pDstDrawable, pGC,
                                srcx, srcy, width, height, dstx, dsty);
    }

    return miDoCopy(pSrcDrawable, pDstDrawable, pGC,
                    srcx, srcy, width, height,
                    dstx, dsty, exaCopyNtoN, 0, NULL);
}

static void
exaPolyPoint(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
             DDXPointPtr ppt)
{
    ExaScreenPriv(pDrawable->pScreen);
    int i;
    xRectangle *prect;

    /* If we can't reuse the current GC as is, don't bother accelerating the
     * points.
     */
    if (pExaScr->fallback_counter || pGC->fillStyle != FillSolid) {
        ExaCheckPolyPoint(pDrawable, pGC, mode, npt, ppt);
        return;
    }

    prect = xallocarray(npt, sizeof(xRectangle));
    for (i = 0; i < npt; i++) {
        prect[i].x = ppt[i].x;
        prect[i].y = ppt[i].y;
        if (i > 0 && mode == CoordModePrevious) {
            prect[i].x += prect[i - 1].x;
            prect[i].y += prect[i - 1].y;
        }
        prect[i].width = 1;
        prect[i].height = 1;
    }
    pGC->ops->PolyFillRect(pDrawable, pGC, npt, prect);
    free(prect);
}

/**
 * exaPolylines() checks if it can accelerate the lines as a group of
 * horizontal or vertical lines (rectangles), and uses existing rectangle fill
 * acceleration if so.
 */
static void
exaPolylines(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
             DDXPointPtr ppt)
{
    ExaScreenPriv(pDrawable->pScreen);
    xRectangle *prect;
    int x1, x2, y1, y2;
    int i;

    if (pExaScr->fallback_counter) {
        ExaCheckPolylines(pDrawable, pGC, mode, npt, ppt);
        return;
    }

    /* Don't try to do wide lines or non-solid fill style. */
    if (pGC->lineWidth != 0 || pGC->lineStyle != LineSolid ||
        pGC->fillStyle != FillSolid) {
        ExaCheckPolylines(pDrawable, pGC, mode, npt, ppt);
        return;
    }

    prect = xallocarray(npt - 1, sizeof(xRectangle));
    x1 = ppt[0].x;
    y1 = ppt[0].y;
    /* If we have any non-horizontal/vertical, fall back. */
    for (i = 0; i < npt - 1; i++) {
        if (mode == CoordModePrevious) {
            x2 = x1 + ppt[i + 1].x;
            y2 = y1 + ppt[i + 1].y;
        }
        else {
            x2 = ppt[i + 1].x;
            y2 = ppt[i + 1].y;
        }

        if (x1 != x2 && y1 != y2) {
            free(prect);
            ExaCheckPolylines(pDrawable, pGC, mode, npt, ppt);
            return;
        }

        if (x1 < x2) {
            prect[i].x = x1;
            prect[i].width = x2 - x1 + 1;
        }
        else {
            prect[i].x = x2;
            prect[i].width = x1 - x2 + 1;
        }
        if (y1 < y2) {
            prect[i].y = y1;
            prect[i].height = y2 - y1 + 1;
        }
        else {
            prect[i].y = y2;
            prect[i].height = y1 - y2 + 1;
        }

        x1 = x2;
        y1 = y2;
    }
    pGC->ops->PolyFillRect(pDrawable, pGC, npt - 1, prect);
    free(prect);
}

/**
 * exaPolySegment() checks if it can accelerate the lines as a group of
 * horizontal or vertical lines (rectangles), and uses existing rectangle fill
 * acceleration if so.
 */
static void
exaPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSeg)
{
    ExaScreenPriv(pDrawable->pScreen);
    xRectangle *prect;
    int i;

    /* Don't try to do wide lines or non-solid fill style. */
    if (pExaScr->fallback_counter || pGC->lineWidth != 0 ||
        pGC->lineStyle != LineSolid || pGC->fillStyle != FillSolid) {
        ExaCheckPolySegment(pDrawable, pGC, nseg, pSeg);
        return;
    }

    /* If we have any non-horizontal/vertical, fall back. */
    for (i = 0; i < nseg; i++) {
        if (pSeg[i].x1 != pSeg[i].x2 && pSeg[i].y1 != pSeg[i].y2) {
            ExaCheckPolySegment(pDrawable, pGC, nseg, pSeg);
            return;
        }
    }

    prect = xallocarray(nseg, sizeof(xRectangle));
    for (i = 0; i < nseg; i++) {
        if (pSeg[i].x1 < pSeg[i].x2) {
            prect[i].x = pSeg[i].x1;
            prect[i].width = pSeg[i].x2 - pSeg[i].x1 + 1;
        }
        else {
            prect[i].x = pSeg[i].x2;
            prect[i].width = pSeg[i].x1 - pSeg[i].x2 + 1;
        }
        if (pSeg[i].y1 < pSeg[i].y2) {
            prect[i].y = pSeg[i].y1;
            prect[i].height = pSeg[i].y2 - pSeg[i].y1 + 1;
        }
        else {
            prect[i].y = pSeg[i].y2;
            prect[i].height = pSeg[i].y1 - pSeg[i].y2 + 1;
        }

        /* don't paint last pixel */
        if (pGC->capStyle == CapNotLast) {
            if (prect[i].width == 1)
                prect[i].height--;
            else
                prect[i].width--;
        }
    }
    pGC->ops->PolyFillRect(pDrawable, pGC, nseg, prect);
    free(prect);
}

static Bool exaFillRegionSolid(DrawablePtr pDrawable, RegionPtr pRegion,
                               Pixel pixel, CARD32 planemask, CARD32 alu,
                               Bool hasClientClip);

static void
exaPolyFillRect(DrawablePtr pDrawable, GCPtr pGC, int nrect, xRectangle *prect)
{
    ExaScreenPriv(pDrawable->pScreen);
    RegionPtr pClip = fbGetCompositeClip(pGC);
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPixmap);
    register BoxPtr pbox;
    BoxPtr pextent;
    int extentX1, extentX2, extentY1, extentY2;
    int fullX1, fullX2, fullY1, fullY2;
    int partX1, partX2, partY1, partY2;
    int xoff, yoff;
    int xorg, yorg;
    int n;
    RegionPtr pReg = RegionFromRects(nrect, prect, CT_UNSORTED);

    /* Compute intersection of rects and clip region */
    RegionTranslate(pReg, pDrawable->x, pDrawable->y);
    RegionIntersect(pReg, pClip, pReg);

    if (!RegionNumRects(pReg)) {
        goto out;
    }

    exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);

    if (pExaScr->fallback_counter || pExaScr->swappedOut ||
        pExaPixmap->accel_blocked) {
        goto fallback;
    }

    /* For ROPs where overlaps don't matter, convert rectangles to region and
     * call exaFillRegion{Solid,Tiled}.
     */
    if ((pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled) &&
        (nrect == 1 || pGC->alu == GXcopy || pGC->alu == GXclear ||
         pGC->alu == GXnoop || pGC->alu == GXcopyInverted ||
         pGC->alu == GXset)) {
        if (((pGC->fillStyle == FillSolid || pGC->tileIsPixel) &&
             exaFillRegionSolid(pDrawable, pReg, pGC->fillStyle == FillSolid ?
                                pGC->fgPixel : pGC->tile.pixel, pGC->planemask,
                                pGC->alu, pGC->clientClip != NULL)) ||
            (pGC->fillStyle == FillTiled && !pGC->tileIsPixel &&
             exaFillRegionTiled(pDrawable, pReg, pGC->tile.pixmap, &pGC->patOrg,
                                pGC->planemask, pGC->alu,
                                pGC->clientClip != NULL))) {
            goto out;
        }
    }

    if (pGC->fillStyle != FillSolid &&
        !(pGC->tileIsPixel && pGC->fillStyle == FillTiled)) {
        goto fallback;
    }

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[1];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pPixmap;
        pixmaps[0].pReg = NULL;

        exaDoMigration(pixmaps, 1, TRUE);
    }

    if (!exaPixmapHasGpuCopy(pPixmap) ||
        !(*pExaScr->info->PrepareSolid) (pPixmap,
                                         pGC->alu,
                                         pGC->planemask, pGC->fgPixel)) {
 fallback:
        ExaCheckPolyFillRect(pDrawable, pGC, nrect, prect);
        goto out;
    }

    xorg = pDrawable->x;
    yorg = pDrawable->y;

    pextent = RegionExtents(pClip);
    extentX1 = pextent->x1;
    extentY1 = pextent->y1;
    extentX2 = pextent->x2;
    extentY2 = pextent->y2;
    while (nrect--) {
        fullX1 = prect->x + xorg;
        fullY1 = prect->y + yorg;
        fullX2 = fullX1 + (int) prect->width;
        fullY2 = fullY1 + (int) prect->height;
        prect++;

        if (fullX1 < extentX1)
            fullX1 = extentX1;

        if (fullY1 < extentY1)
            fullY1 = extentY1;

        if (fullX2 > extentX2)
            fullX2 = extentX2;

        if (fullY2 > extentY2)
            fullY2 = extentY2;

        if ((fullX1 >= fullX2) || (fullY1 >= fullY2))
            continue;
        n = RegionNumRects(pClip);
        if (n == 1) {
            (*pExaScr->info->Solid) (pPixmap,
                                     fullX1 + xoff, fullY1 + yoff,
                                     fullX2 + xoff, fullY2 + yoff);
        }
        else {
            pbox = RegionRects(pClip);
            /*
             * clip the rectangle to each box in the clip region
             * this is logically equivalent to calling Intersect(),
             * but rectangles may overlap each other here.
             */
            while (n--) {
                partX1 = pbox->x1;
                if (partX1 < fullX1)
                    partX1 = fullX1;
                partY1 = pbox->y1;
                if (partY1 < fullY1)
                    partY1 = fullY1;
                partX2 = pbox->x2;
                if (partX2 > fullX2)
                    partX2 = fullX2;
                partY2 = pbox->y2;
                if (partY2 > fullY2)
                    partY2 = fullY2;

                pbox++;

                if (partX1 < partX2 && partY1 < partY2) {
                    (*pExaScr->info->Solid) (pPixmap,
                                             partX1 + xoff, partY1 + yoff,
                                             partX2 + xoff, partY2 + yoff);
                }
            }
        }
    }
    (*pExaScr->info->DoneSolid) (pPixmap);
    exaMarkSync(pDrawable->pScreen);

 out:
    RegionUninit(pReg);
    RegionDestroy(pReg);
}

const GCOps exaOps = {
    exaFillSpans,
    ExaCheckSetSpans,
    exaPutImage,
    exaCopyArea,
    ExaCheckCopyPlane,
    exaPolyPoint,
    exaPolylines,
    exaPolySegment,
    miPolyRectangle,
    ExaCheckPolyArc,
    miFillPolygon,
    exaPolyFillRect,
    miPolyFillArc,
    miPolyText8,
    miPolyText16,
    miImageText8,
    miImageText16,
    ExaCheckImageGlyphBlt,
    ExaCheckPolyGlyphBlt,
    ExaCheckPushPixels,
};

void
exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    RegionRec rgnDst;
    int dx, dy;
    PixmapPtr pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);

    ExaScreenPriv(pWin->drawable.pScreen);

    dx = ptOldOrg.x - pWin->drawable.x;
    dy = ptOldOrg.y - pWin->drawable.y;
    RegionTranslate(prgnSrc, -dx, -dy);

    RegionInit(&rgnDst, NullBox, 0);

    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
#ifdef COMPOSITE
    if (pPixmap->screen_x || pPixmap->screen_y)
        RegionTranslate(&rgnDst, -pPixmap->screen_x, -pPixmap->screen_y);
#endif

    if (pExaScr->fallback_counter) {
        pExaScr->fallback_flags |= EXA_FALLBACK_COPYWINDOW;
        goto fallback;
    }

    pExaScr->fallback_flags |= EXA_ACCEL_COPYWINDOW;
    miCopyRegion(&pPixmap->drawable, &pPixmap->drawable,
                 NULL, &rgnDst, dx, dy, exaCopyNtoN, 0, NULL);
    pExaScr->fallback_flags &= ~EXA_ACCEL_COPYWINDOW;

 fallback:
    RegionUninit(&rgnDst);

    if (pExaScr->fallback_flags & EXA_FALLBACK_COPYWINDOW) {
        pExaScr->fallback_flags &= ~EXA_FALLBACK_COPYWINDOW;
        RegionTranslate(prgnSrc, dx, dy);
        ExaCheckCopyWindow(pWin, ptOldOrg, prgnSrc);
    }
}

static Bool
exaFillRegionSolid(DrawablePtr pDrawable, RegionPtr pRegion, Pixel pixel,
                   CARD32 planemask, CARD32 alu, Bool hasClientClip)
{
    ExaScreenPriv(pDrawable->pScreen);
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPixmap);
    int xoff, yoff;
    Bool ret = FALSE;

    exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);
    RegionTranslate(pRegion, xoff, yoff);

    if (pExaScr->fallback_counter || pExaPixmap->accel_blocked)
        goto out;

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[1];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pPixmap;
        pixmaps[0].pReg = exaGCReadsDestination(pDrawable, planemask, FillSolid,
                                                alu,
                                                hasClientClip) ? NULL : pRegion;

        exaDoMigration(pixmaps, 1, TRUE);
    }

    if (exaPixmapHasGpuCopy(pPixmap) &&
        (*pExaScr->info->PrepareSolid) (pPixmap, alu, planemask, pixel)) {
        int nbox;
        BoxPtr pBox;

        nbox = RegionNumRects(pRegion);
        pBox = RegionRects(pRegion);

        while (nbox--) {
            (*pExaScr->info->Solid) (pPixmap, pBox->x1, pBox->y1, pBox->x2,
                                     pBox->y2);
            pBox++;
        }
        (*pExaScr->info->DoneSolid) (pPixmap);
        exaMarkSync(pDrawable->pScreen);

        if (pExaPixmap->pDamage &&
            pExaPixmap->sys_ptr && pDrawable->type == DRAWABLE_PIXMAP &&
            pDrawable->width == 1 && pDrawable->height == 1 &&
            pDrawable->bitsPerPixel != 24) {
            RegionPtr pending_damage = DamagePendingRegion(pExaPixmap->pDamage);

            switch (pDrawable->bitsPerPixel) {
            case 32:
                *(CARD32 *) pExaPixmap->sys_ptr = pixel;
                break;
            case 16:
                *(CARD16 *) pExaPixmap->sys_ptr = pixel;
                break;
            case 8:
            case 4:
            case 1:
                *(CARD8 *) pExaPixmap->sys_ptr = pixel;
            }

            RegionUnion(&pExaPixmap->validSys, &pExaPixmap->validSys, pRegion);
            RegionUnion(&pExaPixmap->validFB, &pExaPixmap->validFB, pRegion);
            RegionSubtract(pending_damage, pending_damage, pRegion);
        }

        ret = TRUE;
    }

 out:
    RegionTranslate(pRegion, -xoff, -yoff);

    return ret;
}

/* Try to do an accelerated tile of the pTile into pRegion of pDrawable.
 * Based on fbFillRegionTiled(), fbTile().
 */
Bool
exaFillRegionTiled(DrawablePtr pDrawable, RegionPtr pRegion, PixmapPtr pTile,
                   DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu,
                   Bool hasClientClip)
{
    ExaScreenPriv(pDrawable->pScreen);
    PixmapPtr pPixmap;
    ExaPixmapPrivPtr pExaPixmap;
    ExaPixmapPrivPtr pTileExaPixmap = ExaGetPixmapPriv(pTile);
    int xoff, yoff;
    int tileWidth, tileHeight;
    int nbox = RegionNumRects(pRegion);
    BoxPtr pBox = RegionRects(pRegion);
    Bool ret = FALSE;
    int i;

    tileWidth = pTile->drawable.width;
    tileHeight = pTile->drawable.height;

    /* If we're filling with a solid color, grab it out and go to
     * FillRegionSolid, saving numerous copies.
     */
    if (tileWidth == 1 && tileHeight == 1)
        return exaFillRegionSolid(pDrawable, pRegion,
                                  exaGetPixmapFirstPixel(pTile), planemask,
                                  alu, hasClientClip);

    pPixmap = exaGetDrawablePixmap(pDrawable);
    pExaPixmap = ExaGetPixmapPriv(pPixmap);

    if (pExaScr->fallback_counter || pExaPixmap->accel_blocked ||
        pTileExaPixmap->accel_blocked)
        return FALSE;

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[2];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pPixmap;
        pixmaps[0].pReg = exaGCReadsDestination(pDrawable, planemask, FillTiled,
                                                alu,
                                                hasClientClip) ? NULL : pRegion;
        pixmaps[1].as_dst = FALSE;
        pixmaps[1].as_src = TRUE;
        pixmaps[1].pPix = pTile;
        pixmaps[1].pReg = NULL;

        exaDoMigration(pixmaps, 2, TRUE);
    }

    pPixmap = exaGetOffscreenPixmap(pDrawable, &xoff, &yoff);

    if (!pPixmap || !exaPixmapHasGpuCopy(pTile))
        return FALSE;

    if ((*pExaScr->info->PrepareCopy) (pTile, pPixmap, 1, 1, alu, planemask)) {
        if (xoff || yoff)
            RegionTranslate(pRegion, xoff, yoff);

        for (i = 0; i < nbox; i++) {
            int height = pBox[i].y2 - pBox[i].y1;
            int dstY = pBox[i].y1;
            int tileY;

            if (alu == GXcopy)
                height = min(height, tileHeight);

            modulus(dstY - yoff - pDrawable->y - pPatOrg->y, tileHeight, tileY);

            while (height > 0) {
                int width = pBox[i].x2 - pBox[i].x1;
                int dstX = pBox[i].x1;
                int tileX;
                int h = tileHeight - tileY;

                if (alu == GXcopy)
                    width = min(width, tileWidth);

                if (h > height)
                    h = height;
                height -= h;

                modulus(dstX - xoff - pDrawable->x - pPatOrg->x, tileWidth,
                        tileX);

                while (width > 0) {
                    int w = tileWidth - tileX;

                    if (w > width)
                        w = width;
                    width -= w;

                    (*pExaScr->info->Copy) (pPixmap, tileX, tileY, dstX, dstY,
                                            w, h);
                    dstX += w;
                    tileX = 0;
                }
                dstY += h;
                tileY = 0;
            }
        }
        (*pExaScr->info->DoneCopy) (pPixmap);

        /* With GXcopy, we only need to do the basic algorithm up to the tile
         * size; then, we can just keep doubling the destination in each
         * direction until it fills the box. This way, the number of copy
         * operations is O(log(rx)) + O(log(ry)) instead of O(rx * ry), where
         * rx/ry is the ratio between box and tile width/height. This can make
         * a big difference if each driver copy incurs a significant constant
         * overhead.
         */
        if (alu != GXcopy)
            ret = TRUE;
        else {
            Bool more_copy = FALSE;

            for (i = 0; i < nbox; i++) {
                int dstX = pBox[i].x1 + tileWidth;
                int dstY = pBox[i].y1 + tileHeight;

                if ((dstX < pBox[i].x2) || (dstY < pBox[i].y2)) {
                    more_copy = TRUE;
                    break;
                }
            }

            if (more_copy == FALSE)
                ret = TRUE;

            if (more_copy && (*pExaScr->info->PrepareCopy) (pPixmap, pPixmap,
                                                            1, 1, alu,
                                                            planemask)) {
                for (i = 0; i < nbox; i++) {
                    int dstX = pBox[i].x1 + tileWidth;
                    int dstY = pBox[i].y1 + tileHeight;
                    int width = min(pBox[i].x2 - dstX, tileWidth);
                    int height = min(pBox[i].y2 - pBox[i].y1, tileHeight);

                    while (dstX < pBox[i].x2) {
                        (*pExaScr->info->Copy) (pPixmap, pBox[i].x1, pBox[i].y1,
                                                dstX, pBox[i].y1, width,
                                                height);
                        dstX += width;
                        width = min(pBox[i].x2 - dstX, width * 2);
                    }

                    width = pBox[i].x2 - pBox[i].x1;
                    height = min(pBox[i].y2 - dstY, tileHeight);

                    while (dstY < pBox[i].y2) {
                        (*pExaScr->info->Copy) (pPixmap, pBox[i].x1, pBox[i].y1,
                                                pBox[i].x1, dstY, width,
                                                height);
                        dstY += height;
                        height = min(pBox[i].y2 - dstY, height * 2);
                    }
                }

                (*pExaScr->info->DoneCopy) (pPixmap);

                ret = TRUE;
            }
        }

        exaMarkSync(pDrawable->pScreen);

        if (xoff || yoff)
            RegionTranslate(pRegion, -xoff, -yoff);
    }

    return ret;
}

/**
 * Accelerates GetImage for solid ZPixmap downloads from framebuffer memory.
 *
 * This is probably the only case we actually care about.  The rest fall through
 * to migration and fbGetImage, which hopefully will result in migration pushing
 * the pixmap out of framebuffer.
 */
void
exaGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
            unsigned int format, unsigned long planeMask, char *d)
{
    ExaScreenPriv(pDrawable->pScreen);
    PixmapPtr pPix = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPix);
    int xoff, yoff;
    Bool ok;

    if (pExaScr->fallback_counter || pExaScr->swappedOut)
        goto fallback;

    /* If there's a system copy, we want to save the result there */
    if (pExaPixmap->pDamage)
        goto fallback;

    pPix = exaGetOffscreenPixmap(pDrawable, &xoff, &yoff);

    if (pPix == NULL || pExaScr->info->DownloadFromScreen == NULL)
        goto fallback;

    /* Only cover the ZPixmap, solid copy case. */
    if (format != ZPixmap || !EXA_PM_IS_SOLID(pDrawable, planeMask))
        goto fallback;

    /* Only try to handle the 8bpp and up cases, since we don't want to think
     * about <8bpp.
     */
    if (pDrawable->bitsPerPixel < 8)
        goto fallback;

    ok = pExaScr->info->DownloadFromScreen(pPix, pDrawable->x + x + xoff,
                                           pDrawable->y + y + yoff, w, h, d,
                                           PixmapBytePad(w, pDrawable->depth));
    if (ok) {
        exaWaitSync(pDrawable->pScreen);
        return;
    }

 fallback:
    ExaCheckGetImage(pDrawable, x, y, w, h, format, planeMask, d);
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d389 1
a389 1
    rects = malloc(nbox * sizeof(xRectangle));
d629 1
a629 1
    prect = malloc(sizeof(xRectangle) * npt);
d670 1
a670 1
    prect = malloc(sizeof(xRectangle) * (npt - 1));
d741 1
a741 1
    prect = malloc(sizeof(xRectangle) * nseg);
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d416 1
a416 1
                                           pGC->clientClipType)) {
d774 1
a774 1
                               unsigned int clientClipType);
d819 1
a819 1
                                pGC->alu, pGC->clientClipType)) ||
d823 1
a823 1
                                pGC->clientClipType))) {
d993 1
a993 1
                   CARD32 planemask, CARD32 alu, unsigned int clientClipType)
d1016 1
a1016 2
                                                clientClipType) ? NULL :
            pRegion;
d1076 1
a1076 1
                   unsigned int clientClipType)
d1098 1
a1098 1
                                  alu, clientClipType);
d1115 1
a1115 2
                                                clientClipType) ? NULL :
            pRegion;
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a1041 1
            ExaPixmapPriv(pPixmap);
@


1.9
log
@Update to xserver 1.11.2
@
text
@d40 1
a40 1
	     DDXPointPtr ppt, int *pwidth, int fSorted)
d42 13
a54 11
    ScreenPtr	    pScreen = pDrawable->pScreen;
    ExaScreenPriv (pScreen);
    RegionPtr	    pClip = fbGetCompositeClip(pGC);
    PixmapPtr	    pPixmap = exaGetDrawablePixmap (pDrawable);
    ExaPixmapPriv (pPixmap);
    BoxPtr	    pextent, pbox;
    int		    nbox;
    int		    extentX1, extentX2, extentY1, extentY2;
    int		    fullX1, fullX2, fullY1;
    int		    partX1, partX2;
    int		    off_x, off_y;
d57 4
a60 6
	pExaScr->swappedOut ||
	pGC->fillStyle != FillSolid ||
	pExaPixmap->accel_blocked)
    {
	ExaCheckFillSpans (pDrawable, pGC, n, ppt, pwidth, fSorted);
	return;
d64 1
a64 1
	ExaMigrationRec pixmaps[1];
d66 14
a79 16
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pPixmap;
	pixmaps[0].pReg = NULL;

	exaDoMigration (pixmaps, 1, TRUE);
    }

    if (!(pPixmap = exaGetOffscreenPixmap (pDrawable, &off_x, &off_y)) ||
	!(*pExaScr->info->PrepareSolid) (pPixmap,
					 pGC->alu,
					 pGC->planemask,
					 pGC->fgPixel))
    {
	ExaCheckFillSpans (pDrawable, pGC, n, ppt, pwidth, fSorted);
	return;
d87 45
a131 49
    while (n--)
    {
	fullX1 = ppt->x;
	fullY1 = ppt->y;
	fullX2 = fullX1 + (int) *pwidth;
	ppt++;
	pwidth++;

	if (fullY1 < extentY1 || extentY2 <= fullY1)
	    continue;

	if (fullX1 < extentX1)
	    fullX1 = extentX1;

	if (fullX2 > extentX2)
	    fullX2 = extentX2;

	if (fullX1 >= fullX2)
	    continue;

	nbox = RegionNumRects (pClip);
	if (nbox == 1)
	{
	    (*pExaScr->info->Solid) (pPixmap,
				     fullX1 + off_x, fullY1 + off_y,
				     fullX2 + off_x, fullY1 + 1 + off_y);
	}
	else
	{
	    pbox = RegionRects(pClip);
	    while(nbox--)
	    {
		if (pbox->y1 <= fullY1 && fullY1 < pbox->y2)
		{
		    partX1 = pbox->x1;
		    if (partX1 < fullX1)
			partX1 = fullX1;
		    partX2 = pbox->x2;
		    if (partX2 > fullX2)
			partX2 = fullX2;
		    if (partX2 > partX1) {
			(*pExaScr->info->Solid) (pPixmap,
						 partX1 + off_x, fullY1 + off_y,
						 partX2 + off_x, fullY1 + 1 + off_y);
		    }
		}
		pbox++;
	    }
	}
d138 2
a139 2
exaDoPutImage (DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
	       int w, int h, int format, char *bits, int src_stride)
d141 3
a143 2
    ExaScreenPriv (pDrawable->pScreen);
    PixmapPtr pPix = exaGetDrawablePixmap (pDrawable);
d152 3
a154 2
    if (pExaScr->fallback_counter || pExaPixmap->accel_blocked || !pExaScr->info->UploadToScreen)
	return FALSE;
d158 1
a158 1
	return FALSE;
d162 1
a162 1
	return FALSE;
d166 1
a166 1
	return FALSE;
d169 1
a169 1
	return FALSE;
d172 1
a172 1
	ExaMigrationRec pixmaps[1];
d174 4
a177 4
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pPix;
	pixmaps[0].pReg = DamagePendingRegion(pExaPixmap->pDamage);
d179 1
a179 1
	exaDoMigration (pixmaps, 1, TRUE);
d182 1
a182 1
    pPix = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff);
d185 1
a185 1
	return FALSE;
d192 29
a220 32
	 pbox = RegionRects(pClip);
	 nbox--;
	 pbox++)
    {
	int x1 = x;
	int y1 = y;
	int x2 = x + w;
	int y2 = y + h;
	char *src;
	Bool ok;

	if (x1 < pbox->x1)
	    x1 = pbox->x1;
	if (y1 < pbox->y1)
	    y1 = pbox->y1;
	if (x2 > pbox->x2)
	    x2 = pbox->x2;
	if (y2 > pbox->y2)
	    y2 = pbox->y2;
	if (x1 >= x2 || y1 >= y2)
	    continue;

	src = bits + (y1 - y) * src_stride + (x1 - x) * (bpp / 8);
	ok = pExaScr->info->UploadToScreen(pPix, x1 + xoff, y1 + yoff,
					   x2 - x1, y2 - y1, src, src_stride);
	/* We have to fall back completely, and ignore what has already been completed.
	 * Messing with the fb layer directly like we used to is completely unacceptable.
	 */
	if (!ok) {
	    ret = FALSE;
	    break;
	}
d224 1
a224 1
	exaMarkSync(pDrawable->pScreen);
d230 2
a231 2
exaPutImage (DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
	     int w, int h, int leftPad, int format, char *bits)
d234 3
a236 3
		       PixmapBytePad(w, pDrawable->depth)))
	ExaCheckPutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format,
			 bits);
d240 2
a241 2
exaCopyNtoNTwoDir (DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
		   GCPtr pGC, BoxPtr pbox, int nbox, int dx, int dy)
d243 1
a243 1
    ExaScreenPriv (pDstDrawable->pScreen);
d249 2
a250 2
    pSrcPixmap = exaGetOffscreenPixmap (pSrcDrawable, &src_off_x, &src_off_y);
    pDstPixmap = exaGetOffscreenPixmap (pDstDrawable, &dst_off_x, &dst_off_y);
d252 1
a252 1
	return FALSE;
d258 1
a258 1
    dirsetup = 0;	/* No direction set up yet. */
d260 96
a355 93
	if (dx >= 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
	    /* Do a xdir = ydir = -1 blit instead. */
	    if (dirsetup != -1) {
		if (dirsetup != 0)
		    pExaScr->info->DoneCopy(pDstPixmap);
		dirsetup = -1;
		if (!(*pExaScr->info->PrepareCopy)(pSrcPixmap,
						   pDstPixmap,
						   -1, -1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    (*pExaScr->info->Copy)(pDstPixmap,
				   src_off_x + pbox->x1 + dx,
				   src_off_y + pbox->y1 + dy,
				   dst_off_x + pbox->x1,
				   dst_off_y + pbox->y1,
				   pbox->x2 - pbox->x1,
				   pbox->y2 - pbox->y1);
	} else if (dx < 0 && (src_off_y + pbox->y1 + dy) != pbox->y1) {
	    /* Do a xdir = ydir = 1 blit instead. */
	    if (dirsetup != 1) {
		if (dirsetup != 0)
		    pExaScr->info->DoneCopy(pDstPixmap);
		dirsetup = 1;
		if (!(*pExaScr->info->PrepareCopy)(pSrcPixmap,
						   pDstPixmap,
						   1, 1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    (*pExaScr->info->Copy)(pDstPixmap,
				   src_off_x + pbox->x1 + dx,
				   src_off_y + pbox->y1 + dy,
				   dst_off_x + pbox->x1,
				   dst_off_y + pbox->y1,
				   pbox->x2 - pbox->x1,
				   pbox->y2 - pbox->y1);
	} else if (dx >= 0) {
	    /*
	     * xdir = 1, ydir = -1.
	     * Perform line-by-line xdir = ydir = 1 blits, going up.
	     */
	    int i;
	    if (dirsetup != 1) {
		if (dirsetup != 0)
		    pExaScr->info->DoneCopy(pDstPixmap);
		dirsetup = 1;
		if (!(*pExaScr->info->PrepareCopy)(pSrcPixmap,
						   pDstPixmap,
						   1, 1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    for (i = pbox->y2 - pbox->y1 - 1; i >= 0; i--)
		(*pExaScr->info->Copy)(pDstPixmap,
				       src_off_x + pbox->x1 + dx,
				       src_off_y + pbox->y1 + dy + i,
				       dst_off_x + pbox->x1,
				       dst_off_y + pbox->y1 + i,
				       pbox->x2 - pbox->x1, 1);
	} else {
	    /*
	     * xdir = -1, ydir = 1.
	     * Perform line-by-line xdir = ydir = -1 blits, going down.
	     */
	    int i;
	    if (dirsetup != -1) {
		if (dirsetup != 0)
		    pExaScr->info->DoneCopy(pDstPixmap);
		dirsetup = -1;
		if (!(*pExaScr->info->PrepareCopy)(pSrcPixmap,
						   pDstPixmap,
						   -1, -1,
						   pGC ? pGC->alu : GXcopy,
						   pGC ? pGC->planemask :
							 FB_ALLONES))
		    return FALSE;
	    }
	    for (i = 0; i < pbox->y2 - pbox->y1; i++)
		(*pExaScr->info->Copy)(pDstPixmap,
				       src_off_x + pbox->x1 + dx,
				       src_off_y + pbox->y1 + dy + i,
				       dst_off_x + pbox->x1,
				       dst_off_y + pbox->y1 + i,
				       pbox->x2 - pbox->x1, 1);
	}
d358 1
a358 1
	pExaScr->info->DoneCopy(pDstPixmap);
d364 5
a368 9
exaHWCopyNtoN (DrawablePtr    pSrcDrawable,
	     DrawablePtr    pDstDrawable,
	     GCPtr	    pGC,
	     BoxPtr	    pbox,
	     int	    nbox,
	     int	    dx,
	     int	    dy,
	     Bool	    reverse,
	     Bool	    upsidedown)
d370 1
a370 1
    ExaScreenPriv (pDstDrawable->pScreen);
d373 2
a374 2
    int	    src_off_x, src_off_y;
    int	    dst_off_x, dst_off_y;
d381 1
a381 1
	return TRUE;
d383 2
a384 2
    pSrcPixmap = exaGetDrawablePixmap (pSrcDrawable);
    pDstPixmap = exaGetDrawablePixmap (pDstDrawable);
d386 2
a387 2
    exaGetDrawableDeltas (pSrcDrawable, pSrcPixmap, &src_off_x, &src_off_y);
    exaGetDrawableDeltas (pDstDrawable, pDstPixmap, &dst_off_x, &dst_off_y);
d392 2
a393 2
	int i;
	int ordering;
d395 27
a421 27
	for (i = 0; i < nbox; i++) {
	    rects[i].x = pbox[i].x1 + dx + src_off_x;
	    rects[i].y = pbox[i].y1 + dy + src_off_y;
	    rects[i].width = pbox[i].x2 - pbox[i].x1;
	    rects[i].height = pbox[i].y2 - pbox[i].y1;
	}

	/* This must match the RegionCopy() logic for reversing rect order */
	if (nbox == 1 || (dx > 0 && dy > 0) ||
	    (pDstDrawable != pSrcDrawable &&
	     (pDstDrawable->type != DRAWABLE_WINDOW ||
	      pSrcDrawable->type != DRAWABLE_WINDOW)))
	    ordering = CT_YXBANDED;
	else
	    ordering = CT_UNSORTED;

	srcregion  = RegionFromRects(nbox, rects, ordering);
	free(rects);

	if (!pGC || !exaGCReadsDestination(pDstDrawable, pGC->planemask,
					   pGC->fillStyle, pGC->alu,
					   pGC->clientClipType)) {
	    dstregion = RegionCreate(NullBox, 0);
	    RegionCopy(dstregion, srcregion);
	    RegionTranslate(dstregion, dst_off_x - dx - src_off_x,
			     dst_off_y - dy - src_off_y);
	}
d424 2
a425 3

    pSrcExaPixmap = ExaGetPixmapPriv (pSrcPixmap);
    pDstExaPixmap = ExaGetPixmapPriv (pDstPixmap);
d433 1
a433 1
	goto fallback;
d457 1
a457 1
	ExaMigrationRec pixmaps[2];
d459 8
a466 8
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pDstPixmap;
	pixmaps[0].pReg = dstregion;
	pixmaps[1].as_dst = FALSE;
	pixmaps[1].as_src = TRUE;
	pixmaps[1].pPix = pSrcPixmap;
	pixmaps[1].pReg = srcregion;
d468 1
a468 1
	exaDoMigration (pixmaps, 2, TRUE);
d473 5
a477 5
	reverse != upsidedown) {
	if (exaCopyNtoNTwoDir(pSrcDrawable, pDstDrawable, pGC, pbox, nbox,
			       dx, dy))
	    goto out;
	goto fallback;
d481 65
a545 56
	/* Normal blitting. */
	if (exaPixmapHasGpuCopy(pSrcPixmap)) {
	    if (!(*pExaScr->info->PrepareCopy) (pSrcPixmap, pDstPixmap, reverse ? -1 : 1,
						upsidedown ? -1 : 1,
						pGC ? pGC->alu : GXcopy,
						pGC ? pGC->planemask : FB_ALLONES)) {
		goto fallback;
	    }

	    while (nbox--)
	    {
		(*pExaScr->info->Copy) (pDstPixmap,
					pbox->x1 + dx + src_off_x,
					pbox->y1 + dy + src_off_y,
					pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
					pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
		pbox++;
	    }

	    (*pExaScr->info->DoneCopy) (pDstPixmap);
	    exaMarkSync (pDstDrawable->pScreen);
	/* UTS: mainly for SHM PutImage's secondary path.
	 *
	 * Only taking this path for directly accessible pixmaps.
	 */
	} else if (!pDstExaPixmap->pDamage && pSrcExaPixmap->sys_ptr) {
	    int bpp = pSrcDrawable->bitsPerPixel;
	    int src_stride = exaGetPixmapPitch(pSrcPixmap);
	    CARD8 *src = NULL;

	    if (!pExaScr->info->UploadToScreen)
		goto fallback;

	    if (pSrcDrawable->bitsPerPixel != pDstDrawable->bitsPerPixel)
		goto fallback;

	    if (pSrcDrawable->bitsPerPixel < 8)
		goto fallback;

	    if (pGC && !(pGC->alu == GXcopy && EXA_PM_IS_SOLID(pSrcDrawable,  pGC->planemask)))
		goto fallback;

	    while (nbox--)
	    {
		src = pSrcExaPixmap->sys_ptr + (pbox->y1 + dy + src_off_y) * src_stride + (pbox->x1 + dx + src_off_x) * (bpp / 8);
		if (!pExaScr->info->UploadToScreen(pDstPixmap, pbox->x1 + dst_off_x,
				pbox->y1 + dst_off_y, pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
				(char *) src, src_stride))
		    goto fallback;

		pbox++;
	    }
	} else
	    goto fallback;
    } else
	goto fallback;
d549 1
a549 1
fallback:
d552 1
a552 1
out:
d554 2
a555 2
	RegionUninit(dstregion);
	RegionDestroy(dstregion);
d558 2
a559 2
	RegionUninit(srcregion);
	RegionDestroy(srcregion);
d566 8
a573 11
exaCopyNtoN (DrawablePtr    pSrcDrawable,
	     DrawablePtr    pDstDrawable,
	     GCPtr	    pGC,
	     BoxPtr	    pbox,
	     int	    nbox,
	     int	    dx,
	     int	    dy,
	     Bool	    reverse,
	     Bool	    upsidedown,
	     Pixel	    bitplane,
	     void	    *closure)
d578 2
a579 2
	    (pExaScr->fallback_flags & EXA_FALLBACK_COPYWINDOW))
	return;
d581 4
a584 2
    if (exaHWCopyNtoN(pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy, reverse, upsidedown))
	return;
d588 2
a589 2
	pExaScr->fallback_flags |= EXA_FALLBACK_COPYWINDOW;
	return;
d593 2
a594 1
    ExaCheckCopyNtoN(pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy, reverse, upsidedown, bitplane, closure);
d599 1
a599 1
	    int srcx, int srcy, int width, int height, int dstx, int dsty)
d601 1
a601 1
    ExaScreenPriv (pDstDrawable->pScreen);
d604 2
a605 2
        return  ExaCheckCopyArea(pSrcDrawable, pDstDrawable, pGC,
                                 srcx, srcy, width, height, dstx, dsty);
d608 3
a610 3
    return  miDoCopy (pSrcDrawable, pDstDrawable, pGC,
                      srcx, srcy, width, height,
                      dstx, dsty, exaCopyNtoN, 0, NULL);
d615 1
a615 1
	     DDXPointPtr ppt)
d617 1
a617 1
    ExaScreenPriv (pDrawable->pScreen);
d625 2
a626 2
	ExaCheckPolyPoint(pDrawable, pGC, mode, npt, ppt);
	return;
d631 8
a638 8
	prect[i].x = ppt[i].x;
	prect[i].y = ppt[i].y;
	if (i > 0 && mode == CoordModePrevious) {
	    prect[i].x += prect[i - 1].x;
	    prect[i].y += prect[i - 1].y;
	}
	prect[i].width = 1;
	prect[i].height = 1;
d651 1
a651 1
	     DDXPointPtr ppt)
d653 1
a653 1
    ExaScreenPriv (pDrawable->pScreen);
d659 2
a660 2
	ExaCheckPolylines(pDrawable, pGC, mode, npt, ppt);
	return;
d665 3
a667 3
	pGC->fillStyle != FillSolid) {
	ExaCheckPolylines(pDrawable, pGC, mode, npt, ppt);
	return;
d675 31
a705 28
	if (mode == CoordModePrevious) {
	    x2 = x1 + ppt[i + 1].x;
	    y2 = y1 + ppt[i + 1].y;
	} else {
	    x2 = ppt[i + 1].x;
	    y2 = ppt[i + 1].y;
	}

	if (x1 != x2 && y1 != y2) {
	    free(prect);
	    ExaCheckPolylines(pDrawable, pGC, mode, npt, ppt);
	    return;
	}

	if (x1 < x2) {
	    prect[i].x = x1;
	    prect[i].width = x2 - x1 + 1;
	} else {
	    prect[i].x = x2;
	    prect[i].width = x1 - x2 + 1;
	}
	if (y1 < y2) {
	    prect[i].y = y1;
	    prect[i].height = y2 - y1 + 1;
	} else {
	    prect[i].y = y2;
	    prect[i].height = y1 - y2 + 1;
	}
d707 2
a708 2
	x1 = x2;
	y1 = y2;
d720 1
a720 2
exaPolySegment (DrawablePtr pDrawable, GCPtr pGC, int nseg,
		xSegment *pSeg)
d722 1
a722 1
    ExaScreenPriv (pDrawable->pScreen);
d728 3
a730 4
	pGC->lineStyle != LineSolid || pGC->fillStyle != FillSolid)
    {
	ExaCheckPolySegment(pDrawable, pGC, nseg, pSeg);
	return;
d735 4
a738 4
	if (pSeg[i].x1 != pSeg[i].x2 && pSeg[i].y1 != pSeg[i].y2) {
	    ExaCheckPolySegment(pDrawable, pGC, nseg, pSeg);
	    return;
	}
d743 24
a766 22
	if (pSeg[i].x1 < pSeg[i].x2) {
	    prect[i].x = pSeg[i].x1;
	    prect[i].width = pSeg[i].x2 - pSeg[i].x1 + 1;
	} else {
	    prect[i].x = pSeg[i].x2;
	    prect[i].width = pSeg[i].x1 - pSeg[i].x2 + 1;
	}
	if (pSeg[i].y1 < pSeg[i].y2) {
	    prect[i].y = pSeg[i].y1;
	    prect[i].height = pSeg[i].y2 - pSeg[i].y1 + 1;
	} else {
	    prect[i].y = pSeg[i].y2;
	    prect[i].height = pSeg[i].y1 - pSeg[i].y2 + 1;
	}

	/* don't paint last pixel */
	if (pGC->capStyle == CapNotLast) {
	    if (prect[i].width == 1)
		prect[i].height--;
	    else
		prect[i].width--;
	}
d772 3
a774 3
static Bool exaFillRegionSolid (DrawablePtr pDrawable, RegionPtr pRegion,
				Pixel pixel, CARD32 planemask, CARD32 alu,
				unsigned int clientClipType);
d777 1
a777 4
exaPolyFillRect(DrawablePtr pDrawable,
		GCPtr	    pGC,
		int	    nrect,
		xRectangle  *prect)
d779 5
a783 4
    ExaScreenPriv (pDrawable->pScreen);
    RegionPtr	    pClip = fbGetCompositeClip(pGC);
    PixmapPtr	    pPixmap = exaGetDrawablePixmap(pDrawable);
    ExaPixmapPriv (pPixmap);
d785 7
a791 7
    BoxPtr	    pextent;
    int		    extentX1, extentX2, extentY1, extentY2;
    int		    fullX1, fullX2, fullY1, fullY2;
    int		    partX1, partX2, partY1, partY2;
    int		    xoff, yoff;
    int		    xorg, yorg;
    int		    n;
d799 1
a799 1
	goto out;
d805 2
a806 3
	    pExaPixmap->accel_blocked)
    {
	goto fallback;
d813 13
a825 13
	(nrect == 1 || pGC->alu == GXcopy || pGC->alu == GXclear ||
	 pGC->alu == GXnoop || pGC->alu == GXcopyInverted ||
	 pGC->alu == GXset)) {
	if (((pGC->fillStyle == FillSolid || pGC->tileIsPixel) &&
	     exaFillRegionSolid(pDrawable, pReg, pGC->fillStyle == FillSolid ?
				pGC->fgPixel : pGC->tile.pixel,	pGC->planemask,
				pGC->alu, pGC->clientClipType)) ||
	    (pGC->fillStyle == FillTiled && !pGC->tileIsPixel &&
	     exaFillRegionTiled(pDrawable, pReg, pGC->tile.pixmap, &pGC->patOrg,
				pGC->planemask, pGC->alu,
				pGC->clientClipType))) {
	    goto out;
	}
d829 2
a830 3
	!(pGC->tileIsPixel && pGC->fillStyle == FillTiled))
    {
	goto fallback;
d834 1
a834 1
	ExaMigrationRec pixmaps[1];
d836 15
a850 17
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pPixmap;
	pixmaps[0].pReg = NULL;

	exaDoMigration (pixmaps, 1, TRUE);
    }

    if (!exaPixmapHasGpuCopy (pPixmap) ||
	!(*pExaScr->info->PrepareSolid) (pPixmap,
					 pGC->alu,
					 pGC->planemask,
					 pGC->fgPixel))
    {
fallback:
	ExaCheckPolyFillRect (pDrawable, pGC, nrect, prect);
	goto out;
d861 57
a917 61
    while (nrect--)
    {
	fullX1 = prect->x + xorg;
	fullY1 = prect->y + yorg;
	fullX2 = fullX1 + (int) prect->width;
	fullY2 = fullY1 + (int) prect->height;
	prect++;

	if (fullX1 < extentX1)
	    fullX1 = extentX1;

	if (fullY1 < extentY1)
	    fullY1 = extentY1;

	if (fullX2 > extentX2)
	    fullX2 = extentX2;

	if (fullY2 > extentY2)
	    fullY2 = extentY2;

	if ((fullX1 >= fullX2) || (fullY1 >= fullY2))
	    continue;
	n = RegionNumRects (pClip);
	if (n == 1)
	{
	    (*pExaScr->info->Solid) (pPixmap,
				     fullX1 + xoff, fullY1 + yoff,
				     fullX2 + xoff, fullY2 + yoff);
	}
	else
	{
	    pbox = RegionRects(pClip);
	    /*
	     * clip the rectangle to each box in the clip region
	     * this is logically equivalent to calling Intersect(),
	     * but rectangles may overlap each other here.
	     */
	    while(n--)
	    {
		partX1 = pbox->x1;
		if (partX1 < fullX1)
		    partX1 = fullX1;
		partY1 = pbox->y1;
		if (partY1 < fullY1)
		    partY1 = fullY1;
		partX2 = pbox->x2;
		if (partX2 > fullX2)
		    partX2 = fullX2;
		partY2 = pbox->y2;
		if (partY2 > fullY2)
		    partY2 = fullY2;

		pbox++;

		if (partX1 < partX2 && partY1 < partY2) {
		    (*pExaScr->info->Solid) (pPixmap,
					     partX1 + xoff, partY1 + yoff,
					     partX2 + xoff, partY2 + yoff);
		}
	    }
	}
d922 1
a922 1
out:
d953 4
a956 3
    RegionRec	rgnDst;
    int		dx, dy;
    PixmapPtr	pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);
d968 1
a968 2
	RegionTranslate(&rgnDst,
			  -pPixmap->screen_x, -pPixmap->screen_y);
d972 2
a973 2
	pExaScr->fallback_flags |= EXA_FALLBACK_COPYWINDOW;
	goto fallback;
d977 2
a978 3
    miCopyRegion (&pPixmap->drawable, &pPixmap->drawable,
		  NULL,
		  &rgnDst, dx, dy, exaCopyNtoN, 0, NULL);
d981 1
a981 1
fallback:
d985 3
a987 3
	pExaScr->fallback_flags &= ~EXA_FALLBACK_COPYWINDOW;
	RegionTranslate(prgnSrc, dx, dy);
	ExaCheckCopyWindow(pWin, ptOldOrg, prgnSrc);
d992 2
a993 2
exaFillRegionSolid (DrawablePtr	pDrawable, RegionPtr pRegion, Pixel pixel,
		    CARD32 planemask, CARD32 alu, unsigned int clientClipType)
d996 3
a998 2
    PixmapPtr pPixmap = exaGetDrawablePixmap (pDrawable);
    ExaPixmapPriv (pPixmap);
d1006 1
a1006 1
	goto out;
d1009 1
a1009 1
	ExaMigrationRec pixmaps[1];
d1011 26
a1036 53
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pPixmap;
	pixmaps[0].pReg = exaGCReadsDestination(pDrawable, planemask, FillSolid,
						alu, clientClipType) ? NULL : pRegion;

	exaDoMigration (pixmaps, 1, TRUE);
    }

    if (exaPixmapHasGpuCopy (pPixmap) &&
	(*pExaScr->info->PrepareSolid) (pPixmap, alu, planemask, pixel))
    {
	int nbox;
	BoxPtr pBox;

	nbox = RegionNumRects (pRegion);
	pBox = RegionRects (pRegion);

	while (nbox--)
	{
	    (*pExaScr->info->Solid) (pPixmap, pBox->x1, pBox->y1, pBox->x2,
				     pBox->y2);
	    pBox++;
	}
	(*pExaScr->info->DoneSolid) (pPixmap);
	exaMarkSync(pDrawable->pScreen);

	if (pExaPixmap->pDamage &&
	    pExaPixmap->sys_ptr && pDrawable->type == DRAWABLE_PIXMAP &&
	    pDrawable->width == 1 && pDrawable->height == 1 &&
	    pDrawable->bitsPerPixel != 24) {
	    ExaPixmapPriv(pPixmap);
	    RegionPtr pending_damage = DamagePendingRegion(pExaPixmap->pDamage);

	    switch (pDrawable->bitsPerPixel) {
	    case 32:
		*(CARD32*)pExaPixmap->sys_ptr = pixel;
		break;
	    case 16:
		*(CARD16*)pExaPixmap->sys_ptr = pixel;
		break;
	    case 8:
	    case 4:
	    case 1:
		*(CARD8*)pExaPixmap->sys_ptr = pixel;
	    }

	    RegionUnion(&pExaPixmap->validSys, &pExaPixmap->validSys,
			 pRegion);
	    RegionUnion(&pExaPixmap->validFB, &pExaPixmap->validFB,
			 pRegion);
	    RegionSubtract(pending_damage, pending_damage, pRegion);
	}
d1038 26
a1063 1
	ret = TRUE;
d1066 1
a1066 1
out:
d1076 3
a1078 3
exaFillRegionTiled (DrawablePtr pDrawable, RegionPtr pRegion, PixmapPtr pTile,
		    DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu,
		    unsigned int clientClipType)
d1086 2
a1087 2
    int nbox = RegionNumRects (pRegion);
    BoxPtr pBox = RegionRects (pRegion);
d1098 3
a1100 3
	return exaFillRegionSolid(pDrawable, pRegion,
				  exaGetPixmapFirstPixel (pTile), planemask,
				  alu, clientClipType);
d1102 2
a1103 2
    pPixmap = exaGetDrawablePixmap (pDrawable);
    pExaPixmap = ExaGetPixmapPriv (pPixmap);
d1106 2
a1107 2
	    pTileExaPixmap->accel_blocked)
	return FALSE;
d1110 1
a1110 1
	ExaMigrationRec pixmaps[2];
d1112 11
a1122 9
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pPixmap;
	pixmaps[0].pReg = exaGCReadsDestination(pDrawable, planemask, FillTiled,
						alu, clientClipType) ? NULL : pRegion;
	pixmaps[1].as_dst = FALSE;
	pixmaps[1].as_src = TRUE;
	pixmaps[1].pPix = pTile;
	pixmaps[1].pReg = NULL;
d1124 1
a1124 1
	exaDoMigration (pixmaps, 2, TRUE);
d1127 1
a1127 1
    pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff);
d1130 1
a1130 1
	return FALSE;
d1132 3
a1134 107
    if ((*pExaScr->info->PrepareCopy) (pTile, pPixmap, 1, 1, alu, planemask))
    {
	if (xoff || yoff)
	    RegionTranslate(pRegion, xoff, yoff);

	for (i = 0; i < nbox; i++)
	{
	    int height = pBox[i].y2 - pBox[i].y1;
	    int dstY = pBox[i].y1;
	    int tileY;

	    if (alu == GXcopy)
		height = min(height, tileHeight);

	    modulus(dstY - yoff - pDrawable->y - pPatOrg->y, tileHeight, tileY);

	    while (height > 0) {
		int width = pBox[i].x2 - pBox[i].x1;
		int dstX = pBox[i].x1;
		int tileX;
		int h = tileHeight - tileY;

		if (alu == GXcopy)
		    width = min(width, tileWidth);

		if (h > height)
		    h = height;
		height -= h;

		modulus(dstX - xoff - pDrawable->x - pPatOrg->x, tileWidth,
			tileX);

		while (width > 0) {
		    int w = tileWidth - tileX;
		    if (w > width)
			w = width;
		    width -= w;

		    (*pExaScr->info->Copy) (pPixmap, tileX, tileY, dstX, dstY,
					    w, h);
		    dstX += w;
		    tileX = 0;
		}
		dstY += h;
		tileY = 0;
	    }
	}
	(*pExaScr->info->DoneCopy) (pPixmap);

	/* With GXcopy, we only need to do the basic algorithm up to the tile
	 * size; then, we can just keep doubling the destination in each
	 * direction until it fills the box. This way, the number of copy
	 * operations is O(log(rx)) + O(log(ry)) instead of O(rx * ry), where
	 * rx/ry is the ratio between box and tile width/height. This can make
	 * a big difference if each driver copy incurs a significant constant
	 * overhead.
	 */
	if (alu != GXcopy)
	    ret = TRUE;
	else {
	    Bool more_copy = FALSE;

	    for (i = 0; i < nbox; i++) {
		int dstX = pBox[i].x1 + tileWidth;
		int dstY = pBox[i].y1 + tileHeight;

		if ((dstX < pBox[i].x2) || (dstY < pBox[i].y2)) {
		    more_copy = TRUE;
		    break;
		}
	    }

	    if (more_copy == FALSE)
		ret = TRUE;

	    if (more_copy && (*pExaScr->info->PrepareCopy) (pPixmap, pPixmap,
							    1, 1, alu, planemask)) {
		for (i = 0; i < nbox; i++)
		{
		    int dstX = pBox[i].x1 + tileWidth;
		    int dstY = pBox[i].y1 + tileHeight;
		    int width = min(pBox[i].x2 - dstX, tileWidth);
		    int height = min(pBox[i].y2 - pBox[i].y1, tileHeight);

		    while (dstX < pBox[i].x2) {
			(*pExaScr->info->Copy) (pPixmap, pBox[i].x1, pBox[i].y1,
						dstX, pBox[i].y1, width, height);
			dstX += width;
			width = min(pBox[i].x2 - dstX, width * 2);
		    }

		    width = pBox[i].x2 - pBox[i].x1;
		    height = min(pBox[i].y2 - dstY, tileHeight);

		    while (dstY < pBox[i].y2) {
			(*pExaScr->info->Copy) (pPixmap, pBox[i].x1, pBox[i].y1,
						pBox[i].x1, dstY, width, height);
			dstY += height;
			height = min(pBox[i].y2 - dstY, height * 2);
		    }
		}

		(*pExaScr->info->DoneCopy) (pPixmap);

		ret = TRUE;
	    }
	}
d1136 104
a1239 1
	exaMarkSync(pDrawable->pScreen);
d1241 4
a1244 2
	if (xoff || yoff)
	    RegionTranslate(pRegion, -xoff, -yoff);
a1249 1

d1258 2
a1259 2
exaGetImage (DrawablePtr pDrawable, int x, int y, int w, int h,
	     unsigned int format, unsigned long planeMask, char *d)
d1261 3
a1263 2
    ExaScreenPriv (pDrawable->pScreen);
    PixmapPtr pPix = exaGetDrawablePixmap (pDrawable);
d1269 1
a1269 1
	goto fallback;
d1273 1
a1273 1
	goto fallback;
d1275 1
a1275 1
    pPix = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff);
d1278 1
a1278 1
	goto fallback;
d1282 1
a1282 1
	goto fallback;
d1288 1
a1288 1
	goto fallback;
d1291 2
a1292 2
					   pDrawable->y + y + yoff, w, h, d,
					   PixmapBytePad(w, pDrawable->depth));
d1294 2
a1295 2
	exaWaitSync(pDrawable->pScreen);
	return;
d1298 1
a1298 1
fallback:
@


1.8
log
@Apply fix from upstream:
  commit e06fa804009798ea95efa8babaabb0228dfdfe65
  EXA: Fix crash with fill using 1x1 tile of depth < 8 (bug #24703).
Fixes http://bugs.freedesktop.org/show_bug.cgi?id=24703
Reported by Barry Grumbine on ports@@
ok matthieu@@
@
text
@d2 1
a2 1
 * Copyright  2001 Keith Packard
d4 1
a4 1
 * Partly based on code that is Copyright  The XFree86 Project Inc.
d26 1
a26 1
 *    Michel Dnzer <michel@@tungstengraphics.com>
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1060 2
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d84 1
a84 1
    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
d109 1
a109 1
	nbox = REGION_NUM_RECTS (pClip);
d118 1
a118 1
	    pbox = REGION_RECTS(pClip);
d195 2
a196 2
    for (nbox = REGION_NUM_RECTS(pClip),
	 pbox = REGION_RECTS(pClip);
d397 1
a397 1
    rects = xalloc(nbox * sizeof(xRectangle));
d410 1
a410 1
	/* This must match the miRegionCopy() logic for reversing rect order */
d419 2
a420 2
	srcregion  = RECTS_TO_REGION(pScreen, nbox, rects, ordering);
	xfree(rects);
d425 3
a427 3
	    dstregion = REGION_CREATE(pScreen, NullBox, 0);
	    REGION_COPY(pScreen, dstregion, srcregion);
	    REGION_TRANSLATE(pScreen, dstregion, dst_off_x - dx - src_off_x,
d554 2
a555 2
	REGION_UNINIT(pScreen, dstregion);
	REGION_DESTROY(pScreen, dstregion);
d558 2
a559 2
	REGION_UNINIT(pScreen, srcregion);
	REGION_DESTROY(pScreen, srcregion);
d629 1
a629 1
    prect = xalloc(sizeof(xRectangle) * npt);
d641 1
a641 1
    xfree(prect);
d670 1
a670 1
    prect = xalloc(sizeof(xRectangle) * (npt - 1));
d684 1
a684 1
	    xfree(prect);
d708 1
a708 1
    xfree(prect);
d740 1
a740 1
    prect = xalloc(sizeof(xRectangle) * nseg);
d766 1
a766 1
    xfree(prect);
d791 1
a791 1
    RegionPtr pReg = RECTS_TO_REGION(pScreen, nrect, prect, CT_UNSORTED);
d794 2
a795 2
    REGION_TRANSLATE(pScreen, pReg, pDrawable->x, pDrawable->y);
    REGION_INTERSECT(pScreen, pReg, pClip, pReg);
d797 1
a797 1
    if (!REGION_NUM_RECTS(pReg)) {
d859 1
a859 1
    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
d886 1
a886 1
	n = REGION_NUM_RECTS (pClip);
d895 1
a895 1
	    pbox = REGION_RECTS(pClip);
d930 2
a931 2
    REGION_UNINIT(pScreen, pReg);
    REGION_DESTROY(pScreen, pReg);
d967 1
a967 1
    REGION_TRANSLATE(pWin->drawable.pScreen, prgnSrc, -dx, -dy);
d969 1
a969 1
    REGION_INIT (pWin->drawable.pScreen, &rgnDst, NullBox, 0);
d971 1
a971 1
    REGION_INTERSECT(pWin->drawable.pScreen, &rgnDst, &pWin->borderClip, prgnSrc);
d974 1
a974 1
	REGION_TRANSLATE (pWin->drawable.pScreen, &rgnDst,
d990 1
a990 1
    REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
d994 1
a994 1
	REGION_TRANSLATE(pWin->drawable.pScreen, prgnSrc, dx, dy);
d1010 1
a1010 1
    REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);
d1033 2
a1034 2
	nbox = REGION_NUM_RECTS (pRegion);
	pBox = REGION_RECTS (pRegion);
d1063 1
a1063 1
	    REGION_UNION(pScreen, &pExaPixmap->validSys, &pExaPixmap->validSys,
d1065 1
a1065 1
	    REGION_UNION(pScreen, &pExaPixmap->validFB, &pExaPixmap->validFB,
d1067 1
a1067 1
	    REGION_SUBTRACT(pScreen, pending_damage, pending_damage, pRegion);
d1074 1
a1074 1
    REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);
d1093 2
a1094 2
    int nbox = REGION_NUM_RECTS (pRegion);
    BoxPtr pBox = REGION_RECTS (pRegion);
d1140 1
a1140 1
	    REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);
d1248 1
a1248 1
	    REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a52 1
    ExaMigrationRec pixmaps[1];
d54 2
a55 6
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pPixmap;
    pixmaps[0].pReg = NULL;

    if (pExaScr->swappedOut ||
d61 10
a70 1
    } else {
d155 1
a155 1
    Bool access_prepared = FALSE;
d157 5
a161 1
    if (pExaPixmap->accel_blocked)
d175 1
a175 1
    if (pExaPixmap->pDamage) {
d178 1
a178 1
 	pixmaps[0].as_dst = TRUE;
d188 1
a188 1
    if (!pPix || !pExaScr->info->UploadToScreen)
d221 2
a222 2
	/* If we fail to accelerate the upload, fall back to using unaccelerated
	 * fb calls.
d225 2
a226 23
	    FbStip *dst;
	    FbStride dst_stride;
	    int	dstBpp;
	    int	dstXoff, dstYoff;

	    if (!access_prepared) {
		ExaDoPrepareAccess(pDrawable, EXA_PREPARE_DEST);

		access_prepared = TRUE;
	    }

	    fbGetStipDrawable(pDrawable, dst, dst_stride, dstBpp,
			      dstXoff, dstYoff);

	    fbBltStip((FbStip *)bits + (y1 - y) * (src_stride / sizeof(FbStip)),
		      src_stride / sizeof(FbStip),
		      (x1 - x) * dstBpp,
		      dst + (y1 + dstYoff) * dst_stride,
		      dst_stride,
		      (x1 + dstXoff) * dstBpp,
		      (x2 - x1) * dstBpp,
		      y2 - y1,
		      GXcopy, FB_ALLONES, dstBpp);
d230 1
a230 3
    if (access_prepared)
	exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    else
d233 1
a233 1
    return TRUE;
d367 2
a368 2
void
exaCopyNtoN (DrawablePtr    pSrcDrawable,
d376 1
a376 3
	     Bool	    upsidedown,
	     Pixel	    bitplane,
	     void	    *closure)
a382 1
    ExaMigrationRec pixmaps[2];
d385 1
d389 1
a389 1
	return;
a431 8
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pDstPixmap;
    pixmaps[0].pReg = dstregion;
    pixmaps[1].as_dst = FALSE;
    pixmaps[1].as_src = TRUE;
    pixmaps[1].pPix = pSrcPixmap;
    pixmaps[1].pReg = srcregion;
d465 14
a478 1
    exaDoMigration (pixmaps, 2, TRUE);
d489 39
a527 8
    if (!exaPixmapIsOffscreen(pSrcPixmap) ||
	!exaPixmapIsOffscreen(pDstPixmap) ||
	!(*pExaScr->info->PrepareCopy) (pSrcPixmap, pDstPixmap, reverse ? -1 : 1,
					upsidedown ? -1 : 1,
					pGC ? pGC->alu : GXcopy,
					pGC ? pGC->planemask : FB_ALLONES)) {
	goto fallback;
    }
d529 2
a530 9
    while (nbox--)
    {
	(*pExaScr->info->Copy) (pDstPixmap,
				pbox->x1 + dx + src_off_x,
				pbox->y1 + dy + src_off_y,
				pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
				pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	pbox++;
    }
d532 14
a545 2
    (*pExaScr->info->DoneCopy) (pDstPixmap);
    exaMarkSync (pDstDrawable->pScreen);
d550 1
a550 9
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrcDrawable, pDstDrawable,
		  exaDrawableLocation(pSrcDrawable),
		  exaDrawableLocation(pDstDrawable)));
    exaPrepareAccessReg (pDstDrawable, EXA_PREPARE_DEST, dstregion);
    exaPrepareAccessReg (pSrcDrawable, EXA_PREPARE_SRC, srcregion);
    fbCopyNtoN (pSrcDrawable, pDstDrawable, pGC, pbox, nbox, dx, dy, reverse,
		upsidedown, bitplane, closure);
    exaFinishAccess (pSrcDrawable, EXA_PREPARE_SRC);
    exaFinishAccess (pDstDrawable, EXA_PREPARE_DEST);
d561 34
d603 1
a603 1
    if (pExaScr->swappedOut) {
d608 1
a608 1
    return  fbDoCopy (pSrcDrawable, pDstDrawable, pGC,
d617 1
d624 1
a624 1
    if (pGC->fillStyle != FillSolid) {
d653 1
d658 5
d720 1
d725 2
a726 2
    if (pGC->lineWidth != 0 || pGC->lineStyle != LineSolid ||
	pGC->fillStyle != FillSolid)
a790 1
    ExaMigrationRec pixmaps[2];
a800 5
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pPixmap;
    pixmaps[0].pReg = NULL;

d803 2
a804 1
    if (pExaScr->swappedOut || pExaPixmap->accel_blocked)
d834 2
a835 1
    exaDoMigration (pixmaps, 1, TRUE);
d837 9
a845 1
    if (!exaPixmapIsOffscreen (pPixmap) ||
d963 1
d978 7
a984 1
    fbCopyRegion (&pPixmap->drawable, &pPixmap->drawable,
d987 1
d989 1
d991 6
a1006 1
    ExaMigrationRec pixmaps[1];
a1008 7
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pPixmap;
    pixmaps[0].pReg = exaGCReadsDestination(pDrawable, planemask, FillSolid,
					    alu, clientClipType)
	? NULL : pRegion;

d1012 1
a1012 2
    if (pExaPixmap->accel_blocked)
    {
d1014 10
a1023 1
    } else {
d1027 1
a1027 1
    if (exaPixmapIsOffscreen (pPixmap) &&
d1045 2
a1046 1
	if (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS) &&
d1050 1
d1065 3
a1092 1
    ExaMigrationRec pixmaps[2];
d1109 1
a1109 11
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);
    pixmaps[0].pReg = exaGCReadsDestination(pDrawable, planemask, FillTiled,
					    alu, clientClipType)
	? NULL : pRegion;
    pixmaps[1].as_dst = FALSE;
    pixmaps[1].as_src = TRUE;
    pixmaps[1].pPix = pTile;
    pixmaps[1].pReg = NULL;

d1112 2
a1113 2
    if (pExaPixmap->accel_blocked || pTileExaPixmap->accel_blocked)
    {
d1115 14
a1128 1
    } else {
d1134 1
a1134 1
    if (!pPixmap || !exaPixmapIsOffscreen(pTile))
d1267 2
a1268 4
    ExaMigrationRec pixmaps[1];
    BoxRec Box;
    RegionRec Reg;
    PixmapPtr pPix;
d1272 2
a1273 13
    pixmaps[0].as_dst = FALSE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = pPix = exaGetDrawablePixmap (pDrawable);
    pixmaps[0].pReg = &Reg;

    exaGetDrawableDeltas (pDrawable, pPix, &xoff, &yoff);

    Box.x1 = pDrawable->y + x + xoff;
    Box.y1 = pDrawable->y + y + yoff;
    Box.x2 = Box.x1 + w;
    Box.y2 = Box.y1 + h;

    REGION_INIT(pScreen, &Reg, &Box, 1);
d1275 2
a1276 1
    if (pExaScr->swappedOut)
a1278 2
    exaDoMigration(pixmaps, 1, FALSE);

d1299 1
a1299 1
	goto out;
d1303 1
a1303 9
    EXA_FALLBACK(("from %p (%c)\n", pDrawable,
		  exaDrawableLocation(pDrawable)));

    exaPrepareAccessReg (pDrawable, EXA_PREPARE_SRC, &Reg);
    fbGetImage (pDrawable, x, y, w, h, format, planeMask, d);
    exaFinishAccess (pDrawable, EXA_PREPARE_SRC);

out:
    REGION_UNINIT(pScreen, &Reg);
@


1.4
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@a36 1
#include "cw.h"
a145 1
    ExaMigrationRec pixmaps[1];
d167 10
a176 5
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pPix;
    pixmaps[0].pReg = DamagePendingRegion(pExaPixmap->pDamage);
    exaDoMigration (pixmaps, 1, TRUE);
d418 1
d427 10
a436 1
	srcregion  = RECTS_TO_REGION(pScreen, nbox, rects, CT_YXBANDED);
d440 2
a441 1
					   pGC->fillStyle, pGC->alu)) {
d462 2
a463 2
     * FIXME: If it cannot, use temporary pixmaps so that the drawing
     * happens within limits.
d465 2
a466 2
    if (pSrcExaPixmap->accel_blocked || pDstExaPixmap->accel_blocked)
    {
d468 20
a487 2
    } else {
	exaDoMigration (pixmaps, 2, TRUE);
d490 2
d712 2
a713 1
				Pixel pixel, CARD32 planemask, CARD32 alu);
d766 1
a766 1
				pGC->alu)) ||
d769 2
a770 1
				pGC->planemask, pGC->alu))) {
a871 126
static void
exaImageGlyphBlt (DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		x,
		  int		y,
		  unsigned int	nglyph,
		  CharInfoPtr	*ppciInit,
		  pointer	pglyphBase)
{
    FbGCPrivPtr	    pPriv = fbGetGCPrivate(pGC);
    CharInfoPtr	    *ppci;
    CharInfoPtr	    pci;
    unsigned char   *pglyph;		/* pointer bits in glyph */
    int		    gWidth, gHeight;	/* width and height of glyph */
    FbStride	    gStride;		/* stride of glyph */
    Bool	    opaque;
    int		    gx, gy;
    void	    (*glyph) (FbBits *,
			      FbStride,
			      int,
			      FbStip *,
			      FbBits,
			      int,
			      int);
    FbBits	    *dst;
    FbStride	    dstStride;
    int		    dstBpp;
    int		    dstXoff, dstYoff;
    FbBits	    depthMask;
    PixmapPtr	    pPixmap = exaGetDrawablePixmap(pDrawable);
    ExaPixmapPriv(pPixmap);
    RegionPtr	    pending_damage = DamagePendingRegion(pExaPixmap->pDamage);
    BoxRec	    extents = *REGION_EXTENTS(pScreen, pending_damage);
    int		    xoff, yoff;

    if (extents.x1 >= extents.x2 || extents.y1 >= extents.y2)
	return;

    depthMask = FbFullMask(pDrawable->depth);

    if ((pGC->planemask & depthMask) != depthMask)
    {
	ExaCheckImageGlyphBlt(pDrawable, pGC, x, y, nglyph, ppciInit, pglyphBase);
	return;
    }

    glyph = NULL;
    switch (pDrawable->bitsPerPixel) {
    case 8:	glyph = fbGlyph8; break;
    case 16:    glyph = fbGlyph16; break;
    case 24:    glyph = fbGlyph24; break;
    case 32:    glyph = fbGlyph32; break;
    }

    x += pDrawable->x;
    y += pDrawable->y;

    exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);
    extents.x1 -= xoff;
    extents.x2 -= xoff;
    extents.y1 -= yoff;
    extents.y2 -= yoff;

    exaPrepareAccessReg (pDrawable, EXA_PREPARE_DEST, pending_damage);

    if (TERMINALFONT (pGC->font) && !glyph)
    {
	opaque = TRUE;
    }
    else
    {
	FbBits fg = fbReplicatePixel (pGC->bgPixel, pDrawable->bitsPerPixel);

	fbSolidBoxClipped (pDrawable,
			   fbGetCompositeClip(pGC),
			   extents.x1,
			   extents.y1,
			   extents.x2,
			   extents.y2,
			   fbAnd (GXcopy, fg, pGC->planemask),
			   fbXor (GXcopy, fg, pGC->planemask));

	opaque = FALSE;
    }

    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));

    exaPrepareAccessGC (pGC);

    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    for (ppci = ppciInit; nglyph; nglyph--, x += pci->metrics.characterWidth)
    {
	pci = *ppci++;
	gWidth = GLYPHWIDTHPIXELS(pci);
	gHeight = GLYPHHEIGHTPIXELS(pci);
	gx = x + pci->metrics.leftSideBearing;
	gy = y - pci->metrics.ascent;

	if (!gWidth || !gHeight || (gx + gWidth) <= extents.x1 ||
	    (gy + gHeight) <= extents.y1 || gx >= extents.x2 ||
	    gy >= extents.y2)
	    continue;

	pglyph = FONTGLYPHBITS(pglyphBase, pci);

	if (glyph && gWidth <= sizeof (FbStip) * 8 &&
	    fbGlyphIn (fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight))
	{
	    (*glyph) (dst + (gy + dstYoff) * dstStride, dstStride, dstBpp,
		      (FbStip *) pglyph, pPriv->fg, gx + dstXoff, gHeight);
	}
	else
	{
	    RegionPtr pClip = fbGetCompositeClip(pGC);

	    gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof (FbStip);
	    fbPutXYImage (pDrawable, pClip, pPriv->fg, pPriv->bg, pPriv->pm,
			  GXcopy, opaque, gx, gy, gWidth, gHeight,
			  (FbStip *) pglyph, gStride, 0);
	}
    }
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
}

d890 1
a890 1
    exaImageGlyphBlt,
d923 2
a924 5
exaFillRegionSolid (DrawablePtr	pDrawable,
		    RegionPtr	pRegion,
		    Pixel	pixel,
		    CARD32	planemask,
		    CARD32	alu)
d937 2
a938 1
					    alu) ? NULL : pRegion;
d1001 3
a1003 6
exaFillRegionTiled (DrawablePtr	pDrawable,
		    RegionPtr	pRegion,
		    PixmapPtr	pTile,
		    DDXPointPtr pPatOrg,
		    CARD32	planemask,
		    CARD32	alu)
d1015 1
d1026 1
a1026 1
				  alu);
d1032 2
a1033 1
					    alu) ? NULL : pRegion;
a1038 3
    exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);
    REGION_TRANSLATE(pScreen, pRegion, xoff, yoff);

d1043 1
a1043 1
	goto out;
d1051 1
a1051 1
	goto out;
d1055 4
a1058 1
	while (nbox--)
d1060 2
a1061 2
	    int height = pBox->y2 - pBox->y1;
	    int dstY = pBox->y1;
d1064 3
d1070 2
a1071 2
		int width = pBox->x2 - pBox->x1;
		int dstX = pBox->x1;
d1075 3
a1098 1
	    pBox++;
d1101 60
d1163 2
a1164 1
	ret = TRUE;
a1165 3

out:
    REGION_TRANSLATE(pScreen, pRegion, -xoff, -yoff);
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d401 4
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d46 2
a47 1
    PixmapPtr	    pPixmap;
d58 2
a59 1
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);
d63 1
a63 2
	pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
a64 1
	exaDoMigration (pixmaps, 1, FALSE);
a76 1
	exaDoMigration (pixmaps, 1, FALSE);
d140 3
a142 3
static void
exaPutImage (DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
	     int w, int h, int leftPad, int format, char *bits)
d145 2
a146 1
    PixmapPtr pPix;
d152 2
a153 1
    int src_stride, bpp = pDrawable->bitsPerPixel;
d155 2
a156 3
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d160 1
a160 1
	goto migrate_and_fallback;
d164 1
a164 1
	goto migrate_and_fallback;
d167 1
a167 1
	goto fallback;
d169 4
a174 3
    if (pExaScr->info->UploadToScreen == NULL)
	goto fallback;

d177 2
a178 2
    if (pPix == NULL)
	goto fallback;
a183 1
    src_stride = PixmapBytePad(w, pDrawable->depth);
d219 5
a223 1
	    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
a236 2

	    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
a237 2

	exaPixmapDirty(pPix, x1 + xoff, y1 + yoff, x2 + xoff, y2 + yoff);
d240 4
a243 1
    return;
d245 2
a246 2
migrate_and_fallback:
    exaDoMigration (pixmaps, 1, FALSE);
d248 8
a255 2
fallback:
    ExaCheckPutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format, bits);
a371 2
	exaPixmapDirty(pDstPixmap, dst_off_x + pbox->x1, dst_off_y + pbox->y1,
		       dst_off_x + pbox->x2, dst_off_y + pbox->y2);
d394 1
d398 32
a429 1
    Bool fallback = FALSE;
d433 2
a434 1
    pixmaps[0].pPix = pDstPixmap = exaGetDrawablePixmap (pDstDrawable);
d437 2
a438 1
    pixmaps[1].pPix = pSrcPixmap = exaGetDrawablePixmap (pSrcDrawable);
d440 6
a445 3
    /* Respect maxX/maxY in a trivial way: don't set up drawing when we might
     * violate the limits.  The proper solution would be a temporary pixmap
     * adjusted so that the drawing happened within limits.
d447 1
a447 4
    if (pSrcPixmap->drawable.width > pExaScr->info->maxX ||
	pSrcPixmap->drawable.height > pExaScr->info->maxY ||
	pDstPixmap->drawable.width > pExaScr->info->maxX ||
	pDstPixmap->drawable.height > pExaScr->info->maxY)
d449 1
a449 1
	fallback = TRUE;
d455 1
a455 1
    if (!fallback && (pExaScr->info->flags & EXA_TWO_BITBLT_DIRECTIONS) &&
d459 2
a460 2
	    return;
	fallback = TRUE;
d463 1
a463 7
    pSrcPixmap = exaGetDrawablePixmap (pSrcDrawable);
    pDstPixmap = exaGetDrawablePixmap (pDstDrawable);

    exaGetDrawableDeltas (pSrcDrawable, pSrcPixmap, &src_off_x, &src_off_y);
    exaGetDrawableDeltas (pDstDrawable, pDstPixmap, &dst_off_x, &dst_off_y);

    if (fallback || !exaPixmapIsOffscreen(pSrcPixmap) ||
d469 1
a469 12
	fallback = TRUE;
	EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrcDrawable, pDstDrawable,
		      exaDrawableLocation(pSrcDrawable),
		      exaDrawableLocation(pDstDrawable)));
	exaDoMigration (pixmaps, 2, FALSE);
	exaPrepareAccess (pDstDrawable, EXA_PREPARE_DEST);
	exaPrepareAccess (pSrcDrawable, EXA_PREPARE_SRC);
	fbCopyNtoN (pSrcDrawable, pDstDrawable, pGC,
		    pbox, nbox, dx, dy, reverse, upsidedown,
		    bitplane, closure);
	exaFinishAccess (pSrcDrawable, EXA_PREPARE_SRC);
	exaFinishAccess (pDstDrawable, EXA_PREPARE_DEST);
d474 5
a478 8
	if (!fallback)
	    (*pExaScr->info->Copy) (pDstPixmap,
				    pbox->x1 + dx + src_off_x,
				    pbox->y1 + dy + src_off_y,
				    pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
				    pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	exaPixmapDirty (pDstPixmap, pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
			pbox->x2  + dst_off_x, pbox->y2 + dst_off_y);
a481 3
    if (fallback)
	return;

d484 23
d540 1
a540 1
    prect = ALLOCATE_LOCAL(sizeof(xRectangle) * npt);
d552 1
a552 1
    DEALLOCATE_LOCAL(prect);
d575 1
a575 1
    prect = ALLOCATE_LOCAL(sizeof(xRectangle) * (npt - 1));
d589 1
a589 1
	    DEALLOCATE_LOCAL(prect);
d613 1
a613 1
    DEALLOCATE_LOCAL(prect);
d644 1
a644 1
    prect = ALLOCATE_LOCAL(sizeof(xRectangle) * nseg);
d660 8
d670 1
a670 1
    DEALLOCATE_LOCAL(prect);
d685 1
d708 2
a709 1
 
d712 1
a712 3
    if (pExaScr->swappedOut ||
	pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
d721 3
a723 2
	(pGC->alu == GXcopy || pGC->alu == GXclear || pGC->alu == GXnoop ||
	 pGC->alu == GXcopyInverted || pGC->alu == GXset)) {
a749 9
	if (pGC->fillStyle == FillTiled && !pGC->tileIsPixel) {
	    pixmaps[1].as_dst = FALSE;
	    pixmaps[1].as_src = TRUE;
	    pixmaps[1].pPix = pGC->tile.pixmap;
	    exaDoMigration (pixmaps, 2, FALSE);
	} else {
	    exaDoMigration (pixmaps, 1, FALSE);
	}

d828 1
a832 91
exaSolidBoxClipped (DrawablePtr	pDrawable,
		    RegionPtr	pClip,
		    FbBits	pm,
		    FbBits	fg,
		    int		x1,
		    int		y1,
		    int		x2,
		    int		y2)
{
    ExaScreenPriv (pDrawable->pScreen);
    PixmapPtr   pPixmap;
    BoxPtr	pbox;
    int		nbox;
    int		xoff, yoff;
    int		partX1, partX2, partY1, partY2;
    ExaMigrationRec pixmaps[1];
    Bool	fallback = FALSE;

    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);

    if (pExaScr->swappedOut ||
	pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
    {
	fallback = TRUE;
    } else {
	exaDoMigration (pixmaps, 1, TRUE);
    }

    exaGetDrawableDeltas (pDrawable, pPixmap, &xoff, &yoff);

    if (fallback || !exaPixmapIsOffscreen(pPixmap) ||
	!(*pExaScr->info->PrepareSolid) (pPixmap, GXcopy, pm, fg))
    {
	EXA_FALLBACK(("to %p (%c)\n", pDrawable,
		      exaDrawableLocation(pDrawable)));
	exaDoMigration (pixmaps, 1, FALSE);
	fallback = TRUE;
	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
	fg = fbReplicatePixel (fg, pDrawable->bitsPerPixel);
	fbSolidBoxClipped (pDrawable, pClip, x1, y1, x2, y2,
			   fbAnd (GXcopy, fg, pm),
			   fbXor (GXcopy, fg, pm));
	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
    }
    for (nbox = REGION_NUM_RECTS(pClip), pbox = REGION_RECTS(pClip);
	 nbox--;
	 pbox++)
    {
	partX1 = pbox->x1;
	if (partX1 < x1)
	    partX1 = x1;

	partX2 = pbox->x2;
	if (partX2 > x2)
	    partX2 = x2;

	if (partX2 <= partX1)
	    continue;

	partY1 = pbox->y1;
	if (partY1 < y1)
	    partY1 = y1;

	partY2 = pbox->y2;
	if (partY2 > y2)
	    partY2 = y2;

	if (partY2 <= partY1)
	    continue;

	if (!fallback) {
	    (*pExaScr->info->Solid) (pPixmap,
				     partX1 + xoff, partY1 + yoff,
				     partX2 + xoff, partY2 + yoff);
	}

	exaPixmapDirty (pPixmap, partX1 + xoff, partY1 + yoff, partX2 + xoff,
			partY2 + yoff);
    }

    if (fallback)
	return;

    (*pExaScr->info->DoneSolid) (pPixmap);
    exaMarkSync(pDrawable->pScreen);
}

static void
a847 1
    int		    n;
d862 4
a865 2
    ExaMigrationRec pixmaps[1];
    int		    xBack, widthBack, yBack, heightBack;
d867 1
a867 14
    for (ppci = ppciInit, n = nglyph, widthBack = 0; n; n--)
	widthBack += (*ppci++)->metrics.characterWidth;

    xBack = x;
    if (widthBack < 0)
    {
	xBack += widthBack;
	widthBack = -widthBack;
    }
    yBack = y - FONTASCENT(pGC->font);
    heightBack = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);

    if (xBack >= pDrawable->width || yBack >= pDrawable->height ||
	(xBack + widthBack) <= 0 || (yBack + heightBack) <= 0)
d870 1
a870 3
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = pPixmap;
a871 1
    depthMask = FbFullMask(pDrawable->depth);
a873 1
	exaDoMigration(pixmaps, 1, FALSE);
d875 1
a875 1
	goto damage;
d877 1
d888 8
a895 2
    xBack += pDrawable->x;
    yBack += pDrawable->y;
d903 11
a913 8
        exaSolidBoxClipped (pDrawable,
			    fbGetCompositeClip(pGC),
			    pGC->planemask,
			    pGC->bgPixel,
			    xBack,
			    yBack,
			    xBack + widthBack,
			    yBack + heightBack);
d918 1
a918 2
    exaDoMigration(pixmaps, 1, FALSE);
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
d931 3
a933 3
	if (!gWidth || !gHeight || (gx + gWidth) <= xBack ||
	    (gy + gHeight) <= yBack || gx >= (xBack + widthBack) ||
	    gy >= (yBack + heightBack))
a955 5

damage:
    exaGetDrawableDeltas(pDrawable, pPixmap, &dstXoff, &dstYoff);
    exaPixmapDirty(pPixmap, xBack + dstXoff, yBack + dstYoff,
		   xBack + dstXoff + widthBack, yBack + dstYoff + heightBack);
d1016 2
a1017 1
    PixmapPtr pPixmap;
d1020 1
a1020 2
    int nbox = REGION_NUM_RECTS (pRegion);
    BoxPtr pBox = REGION_RECTS (pRegion);
d1024 8
a1031 4
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);
 
    if (pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
d1033 1
a1033 1
	goto fallback;
d1038 1
a1038 1
    if ((pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff)) &&
d1041 6
d1049 2
a1050 3
	    (*pExaScr->info->Solid) (pPixmap,
				     pBox->x1 + xoff, pBox->y1 + yoff,
				     pBox->x2 + xoff, pBox->y2 + yoff);
d1055 22
a1076 13
    }
    else
    {
fallback:
	if (alu != GXcopy || planemask != FB_ALLONES)
	    return FALSE;
	EXA_FALLBACK(("to %p (%c)\n", pDrawable,
		      exaDrawableLocation(pDrawable)));
	exaDoMigration (pixmaps, 1, FALSE);
	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
	fbFillRegionSolid (pDrawable, pRegion, 0,
			   fbReplicatePixel (pixel, pDrawable->bitsPerPixel));
	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d1079 4
a1082 1
    return TRUE;
d1098 3
a1100 1
    int xoff, yoff, tileXoff, tileYoff;
d1105 1
d1121 2
d1126 4
d1131 3
a1133 4
    if (pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY ||
	tileWidth > pExaScr->info->maxX ||
	tileHeight > pExaScr->info->maxY)
d1135 1
a1135 1
	goto fallback;
d1142 2
a1143 2
    if (!pPixmap)
	goto fallback;
d1145 1
a1145 6
    if (!exaPixmapIsOffscreen(pTile))
	goto fallback;

    if ((*pExaScr->info->PrepareCopy) (exaGetOffscreenPixmap((DrawablePtr)pTile,
							     &tileXoff, &tileYoff),
				       pPixmap, 0, 0, alu, planemask))
d1153 1
a1153 1
	    modulus(dstY - pDrawable->y - pPatOrg->y, tileHeight, tileY);
d1165 2
a1166 1
		modulus(dstX - pDrawable->x - pPatOrg->x, tileWidth, tileX);
d1174 1
a1174 3
		    (*pExaScr->info->Copy) (pPixmap,
					    tileX + tileXoff, tileY + tileYoff,
					    dstX + xoff, dstY + yoff,
d1186 2
a1187 1
	return TRUE;
d1190 2
a1191 13
fallback:
    if (alu != GXcopy || planemask != FB_ALLONES || pPatOrg->x != 0 ||
	pPatOrg->y != 0)
	return FALSE;
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pTile, pDrawable,
		  exaDrawableLocation(&pTile->drawable),
		  exaDrawableLocation(pDrawable)));
    exaDoMigration (pixmaps, 2, FALSE);
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccess ((DrawablePtr)pTile, EXA_PREPARE_SRC);
    fbFillRegionTiled (pDrawable, pRegion, pTile);
    exaFinishAccess ((DrawablePtr)pTile, EXA_PREPARE_SRC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d1193 1
a1193 1
    return TRUE;
a1195 64
void
exaPaintWindow(WindowPtr pWin, RegionPtr pRegion, int what)
{
    ExaScreenPriv (pWin->drawable.pScreen);
    PixmapPtr pPixmap = exaGetDrawablePixmap((DrawablePtr)pWin);
    int xoff, yoff;
    BoxPtr pBox;
    int nbox = REGION_NUM_RECTS(pRegion);

    if (!nbox)
	return;

    if (!pExaScr->swappedOut) {
	DDXPointRec zeros = { 0, 0 };

        switch (what) {
        case PW_BACKGROUND:
            switch (pWin->backgroundState) {
            case None:
                return;
            case ParentRelative:
                do {
                    pWin = pWin->parent;
                } while (pWin->backgroundState == ParentRelative);
                (*pWin->drawable.pScreen->PaintWindowBackground)(pWin, pRegion,
                                                                 what);
                return;
            case BackgroundPixel:
		exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->background.pixel,
				   FB_ALLONES, GXcopy);
                goto damage;
            case BackgroundPixmap:
                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->background.pixmap,
				   &zeros, FB_ALLONES, GXcopy);
                goto damage;
            }
            break;
        case PW_BORDER:
            if (pWin->borderIsPixel) {
                exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->border.pixel,
				   FB_ALLONES, GXcopy);
                goto damage;
            } else {
                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->border.pixmap,
				   &zeros, FB_ALLONES, GXcopy);
                goto damage;
            }
            break;
        }
    }
    ExaCheckPaintWindow (pWin, pRegion, what);

damage:
    exaGetDrawableDeltas((DrawablePtr)pWin, pPixmap, &xoff, &yoff);

    pBox = REGION_RECTS(pRegion);

    while (nbox--)
    {
	exaPixmapDirty (pPixmap, pBox->x1 + xoff, pBox->y1 + yoff,
			pBox->x2 + xoff, pBox->y2 + yoff);
	pBox++;
    }
}
d1201 2
a1202 2
 * to migration and ExaCheckGetImage, which hopefully will result in migration
 * pushing the pixmap out of framebuffer.
d1210 2
d1216 15
a1230 1
    if (pExaScr->swappedOut || (w == 1 && h == 1))
d1233 6
a1238 2
    if (pExaScr->info->DownloadFromScreen == NULL)
	goto migrate_and_fallback;
d1242 1
a1242 1
	goto migrate_and_fallback;
a1247 4
	goto migrate_and_fallback;

    pPix = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff);
    if (pPix == NULL)
d1250 2
a1251 4
    xoff += pDrawable->x;
    yoff += pDrawable->y;

    ok = pExaScr->info->DownloadFromScreen(pPix, x + xoff, y + yoff, w, h, d,
d1255 1
a1255 1
	return;
a1257 5
migrate_and_fallback:
    pixmaps[0].as_dst = FALSE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
    exaDoMigration (pixmaps, 1, FALSE);
d1259 2
a1260 2
    ExaCheckGetImage (pDrawable, x, y, w, h, format, planeMask, d);
}
d1262 3
a1264 9
/**
 * GetSpans isn't accelerated yet, but performs migration so that we'll
 * hopefully avoid the read-from-framebuffer cost.
 */
void
exaGetSpans (DrawablePtr pDrawable, int wMax, DDXPointPtr ppt, int *pwidth,
	     int nspans, char *pdstStart)
{
    ExaMigrationRec pixmaps[1];
d1266 2
a1267 6
    pixmaps[0].as_dst = FALSE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
    exaDoMigration (pixmaps, 1, FALSE);

    ExaCheckGetSpans (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
@


1.1
log
@Initial revision
@
text
@d23 5
d57 1
a57 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d61 2
a62 2
	pDrawable->width > pExaScr->info->maxX ||
	pDrawable->height > pExaScr->info->maxY)
d77 1
d127 1
a127 1
		    if (partX2 > partX1)
d131 1
a137 1
    exaDrawableDirty (pDrawable);
d154 3
a156 2
    if (pExaScr->swappedOut || pExaScr->info->UploadToScreen == NULL)
	goto migrate_and_fallback;
d166 3
a168 3
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d170 4
d226 2
a227 2
		      (x1 - x) * bpp,
		      dst + (y1 + yoff) * dst_stride,
d229 2
a230 2
		      (x1 + xoff) * bpp,
		      (x2 - x1) * bpp,
d232 1
a232 1
		      GXcopy, FB_ALLONES, bpp);
d236 2
a238 1
    exaDrawableDirty(pDrawable);
a242 3
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d363 2
a368 1
    exaDrawableDirty(pDstDrawable);
d390 1
d394 1
a394 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDstDrawable);
d397 1
a397 1
    pixmaps[1].pPix = exaGetDrawablePixmap (pSrcDrawable);
d403 4
a406 4
    if (pSrcDrawable->width > pExaScr->info->maxX ||
	pSrcDrawable->height > pExaScr->info->maxY ||
	pDstDrawable->width > pExaScr->info->maxX ||
	pDstDrawable->height > pExaScr->info->maxY)
d408 1
a408 2
	exaDoMigration (pixmaps, 2, FALSE);
	goto fallback;
d414 3
a416 2
    if (pExaScr->info->flags & EXA_TWO_BITBLT_DIRECTIONS && (dx*dy) < 0) {
	if (!exaCopyNtoNTwoDir(pSrcDrawable, pDstDrawable, pGC, pbox, nbox,
d418 28
a445 2
	    goto fallback;
	return;
d448 1
a448 6
    if ((pSrcPixmap = exaGetOffscreenPixmap (pSrcDrawable, &src_off_x, &src_off_y)) &&
	(pDstPixmap = exaGetOffscreenPixmap (pDstDrawable, &dst_off_x, &dst_off_y)) &&
	(*pExaScr->info->PrepareCopy) (pSrcPixmap, pDstPixmap,
				       dx, dy,
				       pGC ? pGC->alu : GXcopy,
				       pGC ? pGC->planemask : FB_ALLONES))
d450 1
a450 2
	while (nbox--)
	{
d455 7
a461 7
				    pbox->x2 - pbox->x1,
				    pbox->y2 - pbox->y1);
	    pbox++;
	}
	(*pExaScr->info->DoneCopy) (pDstPixmap);
	exaMarkSync(pDstDrawable->pScreen);
	exaDrawableDirty (pDstDrawable);
a462 1
    }
d464 2
a465 11
fallback:
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrcDrawable, pDstDrawable,
		  exaDrawableLocation(pSrcDrawable),
		  exaDrawableLocation(pDstDrawable)));
    exaPrepareAccess (pDstDrawable, EXA_PREPARE_DEST);
    exaPrepareAccess (pSrcDrawable, EXA_PREPARE_SRC);
    fbCopyNtoN (pSrcDrawable, pDstDrawable, pGC,
		pbox, nbox, dx, dy, reverse, upsidedown,
		bitplane, closure);
    exaFinishAccess (pSrcDrawable, EXA_PREPARE_SRC);
    exaFinishAccess (pDstDrawable, EXA_PREPARE_DEST);
d538 1
a538 1
    for (i = 0; i < npt; i++) {
d624 3
d635 1
a635 1
    PixmapPtr	    pPixmap;
d644 10
a653 1
    ExaMigrationRec pixmaps[1];
d657 1
a657 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d659 2
d662 25
a686 3
	pGC->fillStyle != FillSolid ||
	pDrawable->width > pExaScr->info->maxX ||
	pDrawable->height > pExaScr->info->maxY)
d688 1
a688 5
	exaDoMigration (pixmaps, 1, FALSE);
	ExaCheckPolyFillRect (pDrawable, pGC, nrect, prect);
	return;
    } else {
	exaDoMigration (pixmaps, 1, TRUE);
d691 3
a693 1
    if (!(pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff)) ||
d699 10
d710 1
a710 1
	return;
d755 2
a756 1
	     * this is logically equivalent to calling Intersect()
d775 1
a775 1
		if (partX1 < partX2 && partY1 < partY2)
d779 1
a783 1
    exaDrawableDirty (pDrawable);
d785 3
d807 1
d811 2
a812 2
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
 
d814 2
a815 2
	pDrawable->width > pExaScr->info->maxX ||
	pDrawable->height > pExaScr->info->maxY)
d817 1
a817 2
	exaDoMigration (pixmaps, 1, FALSE);
	goto fallback;
d822 3
a824 1
    if (!(pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff)) ||
a826 1
fallback:
d829 2
a836 1
	return;
d864 8
a871 3
	(*pExaScr->info->Solid) (pPixmap,
				 partX1 + xoff, partY1 + yoff,
				 partX2 + xoff, partY2 + yoff);
d873 4
a877 1
    exaDrawableDirty (pDrawable);
d911 23
d938 1
d940 1
a940 1
	return;
d952 2
a960 17
	int		xBack, widthBack;
	int		yBack, heightBack;

	ppci = ppciInit;
	n = nglyph;
	widthBack = 0;
	while (n--)
	    widthBack += (*ppci++)->metrics.characterWidth;

        xBack = x;
	if (widthBack < 0)
	{
	    xBack += widthBack;
	    widthBack = -widthBack;
	}
	yBack = y - FONTASCENT(pGC->font);
	heightBack = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);
d973 1
d979 1
a979 2
    ppci = ppciInit;
    while (nglyph--)
a981 1
	pglyph = FONTGLYPHBITS(pglyphBase, pci);
d984 17
a1000 1
	if (gWidth && gHeight)
d1002 6
a1007 32
	    gx = x + pci->metrics.leftSideBearing;
	    gy = y - pci->metrics.ascent;
	    if (glyph && gWidth <= sizeof (FbStip) * 8 &&
		fbGlyphIn (fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight))
	    {
		(*glyph) (dst + (gy + dstYoff) * dstStride,
			  dstStride,
			  dstBpp,
			  (FbStip *) pglyph,
			  pPriv->fg,
			  gx + dstXoff,
			  gHeight);
	    }
	    else
	    {
		gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof (FbStip);
		fbPutXYImage (pDrawable,
			      fbGetCompositeClip(pGC),
			      pPriv->fg,
			      pPriv->bg,
			      pPriv->pm,
			      GXcopy,
			      opaque,

			      gx,
			      gy,
			      gWidth, gHeight,

			      (FbStip *) pglyph,
			      gStride,
			      0);
	    }
a1008 1
	x += pci->metrics.characterWidth;
d1012 5
d1069 1
a1069 1
static void
d1072 3
a1074 1
		    Pixel	pixel)
d1080 2
d1085 1
a1085 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d1087 2
a1088 2
    if (pDrawable->width > pExaScr->info->maxX ||
	pDrawable->height > pExaScr->info->maxY)
a1089 1
	exaDoMigration (pixmaps, 1, FALSE);
d1096 1
a1096 1
	(*pExaScr->info->PrepareSolid) (pPixmap, GXcopy, FB_ALLONES, pixel))
a1097 3
	int	nbox = REGION_NUM_RECTS (pRegion);
	BoxPtr	pBox = REGION_RECTS (pRegion);

a1106 1
	exaDrawableDirty (pDrawable);
d1111 2
d1115 1
d1121 2
d1128 1
a1128 1
static void
d1131 4
a1134 1
		    PixmapPtr	pTile)
d1138 1
a1138 1
    int xoff, yoff;
d1141 2
d1150 4
a1153 4
    if (tileWidth == 1 && tileHeight == 1) {
	exaFillRegionSolid(pDrawable, pRegion, exaGetPixmapFirstPixel (pTile));
	return;
    }
d1157 1
a1157 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d1162 2
a1163 2
    if (pDrawable->width > pExaScr->info->maxX ||
	pDrawable->height > pExaScr->info->maxY ||
a1166 1
	exaDoMigration (pixmaps, 2, FALSE);
d1173 1
d1180 3
a1182 2
    if ((*pExaScr->info->PrepareCopy) (pTile, pPixmap, 0, 0, GXcopy,
				       FB_ALLONES))
a1183 3
	int nbox = REGION_NUM_RECTS (pRegion);
	BoxPtr pBox = REGION_RECTS (pRegion);

d1190 2
a1191 1
	    tileY = (dstY - pDrawable->y) % tileHeight;
d1202 2
a1203 1
		tileX = (dstX - pDrawable->x) % tileWidth;
d1211 1
a1211 1
					    tileX, tileY,
d1224 1
a1224 2
	exaDrawableDirty (pDrawable);
	return;
d1228 3
d1234 1
d1240 2
d1248 6
a1253 1
    if (!REGION_NUM_RECTS(pRegion))
d1255 1
d1257 2
d1272 3
a1274 2
                exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->background.pixel);
                return;
d1276 3
a1278 2
                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->background.pixmap);
                return;
d1283 3
a1285 2
                exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->border.pixel);
                return;
d1287 3
a1289 2
                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->border.pixmap);
                return;
d1295 12
d1326 1
a1326 1
    if (pExaScr->swappedOut || pExaScr->info->DownloadFromScreen == NULL)
d1329 3
d1334 1
a1334 1
	goto fallback;
d1340 1
a1340 1
	goto fallback;
a1341 8
    /* Migrate, but assume that we could accelerate the download. It is up to
     * the migration scheme to ensure that this case doesn't result in bad
     * moving of pixmaps.
     */
    pixmaps[0].as_dst = FALSE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
    exaDoMigration (pixmaps, 1, TRUE);
d1356 1
a1356 1
fallback:
d1361 1
a1361 1

@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a22 5
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *    Michel Dnzer <michel@@tungstengraphics.com>
 *
d52 1
a52 1
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);
d56 2
a57 2
	pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
a71 1
	exaDoMigration (pixmaps, 1, FALSE);
d121 1
a121 1
		    if (partX2 > partX1) {
a124 1
		    }
d131 1
d148 2
a149 3
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDrawable);
d159 3
a161 3
    if (pExaScr->swappedOut)
	goto fallback;

a162 4

    if (pExaScr->info->UploadToScreen == NULL)
	goto fallback;

d215 2
a216 2
		      (x1 - x) * dstBpp,
		      dst + (y1 + dstYoff) * dst_stride,
d218 2
a219 2
		      (x1 + dstXoff) * dstBpp,
		      (x2 - x1) * dstBpp,
d221 1
a221 1
		      GXcopy, FB_ALLONES, dstBpp);
a224 2

	exaPixmapDirty(pPix, x1 + xoff, y1 + yoff, x2 + xoff, y2 + yoff);
d226 1
d231 3
a353 2
	exaPixmapDirty(pDstPixmap, dst_off_x + pbox->x1, dst_off_y + pbox->y1,
		       dst_off_x + pbox->x2, dst_off_y + pbox->y2);
d358 1
a379 1
    Bool fallback = FALSE;
d383 1
a383 1
    pixmaps[0].pPix = pDstPixmap = exaGetDrawablePixmap (pDstDrawable);
d386 1
a386 1
    pixmaps[1].pPix = pSrcPixmap = exaGetDrawablePixmap (pSrcDrawable);
d392 4
a395 4
    if (pSrcPixmap->drawable.width > pExaScr->info->maxX ||
	pSrcPixmap->drawable.height > pExaScr->info->maxY ||
	pDstPixmap->drawable.width > pExaScr->info->maxX ||
	pDstPixmap->drawable.height > pExaScr->info->maxY)
d397 2
a398 1
	fallback = TRUE;
d404 2
a405 3
    if (!fallback && (pExaScr->info->flags & EXA_TWO_BITBLT_DIRECTIONS) &&
	reverse != upsidedown) {
	if (exaCopyNtoNTwoDir(pSrcDrawable, pDstDrawable, pGC, pbox, nbox,
d407 2
a408 28
	    return;
	fallback = TRUE;
    }

    pSrcPixmap = exaGetDrawablePixmap (pSrcDrawable);
    pDstPixmap = exaGetDrawablePixmap (pDstDrawable);

    exaGetDrawableDeltas (pSrcDrawable, pSrcPixmap, &src_off_x, &src_off_y);
    exaGetDrawableDeltas (pDstDrawable, pDstPixmap, &dst_off_x, &dst_off_y);

    if (fallback || !exaPixmapIsOffscreen(pSrcPixmap) ||
	!exaPixmapIsOffscreen(pDstPixmap) ||
	!(*pExaScr->info->PrepareCopy) (pSrcPixmap, pDstPixmap, reverse ? -1 : 1,
					upsidedown ? -1 : 1,
					pGC ? pGC->alu : GXcopy,
					pGC ? pGC->planemask : FB_ALLONES)) {
	fallback = TRUE;
	EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrcDrawable, pDstDrawable,
		      exaDrawableLocation(pSrcDrawable),
		      exaDrawableLocation(pDstDrawable)));
	exaDoMigration (pixmaps, 2, FALSE);
	exaPrepareAccess (pDstDrawable, EXA_PREPARE_DEST);
	exaPrepareAccess (pSrcDrawable, EXA_PREPARE_SRC);
	fbCopyNtoN (pSrcDrawable, pDstDrawable, pGC,
		    pbox, nbox, dx, dy, reverse, upsidedown,
		    bitplane, closure);
	exaFinishAccess (pSrcDrawable, EXA_PREPARE_SRC);
	exaFinishAccess (pDstDrawable, EXA_PREPARE_DEST);
d411 6
a416 1
    while (nbox--)
d418 2
a419 1
	if (!fallback)
d424 8
a431 4
				    pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	exaPixmapDirty (pDstPixmap, pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
			pbox->x2  + dst_off_x, pbox->y2 + dst_off_y);
	pbox++;
d434 11
a444 5
    if (fallback)
	return;

    (*pExaScr->info->DoneCopy) (pDstPixmap);
    exaMarkSync (pDstDrawable->pScreen);
a602 3
static Bool exaFillRegionSolid (DrawablePtr pDrawable, RegionPtr pRegion,
				Pixel pixel, CARD32 planemask, CARD32 alu);

d611 1
a611 1
    PixmapPtr	    pPixmap = exaGetDrawablePixmap(pDrawable);
d620 1
a620 10
    ExaMigrationRec pixmaps[2];
    RegionPtr pReg = RECTS_TO_REGION(pScreen, nrect, prect, CT_UNSORTED);

    /* Compute intersection of rects and clip region */
    REGION_TRANSLATE(pScreen, pReg, pDrawable->x, pDrawable->y);
    REGION_INTERSECT(pScreen, pReg, pClip, pReg);

    if (!REGION_NUM_RECTS(pReg)) {
	goto out;
    }
d624 1
a624 1
    pixmaps[0].pPix = pPixmap;
a625 2
    exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);

d627 3
a629 2
	pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
d631 5
a635 18
	goto fallback;
    }

    /* For ROPs where overlaps don't matter, convert rectangles to region and
     * call exaFillRegion{Solid,Tiled}.
     */
    if ((pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled) &&
	(pGC->alu == GXcopy || pGC->alu == GXclear || pGC->alu == GXnoop ||
	 pGC->alu == GXcopyInverted || pGC->alu == GXset)) {
	if (((pGC->fillStyle == FillSolid || pGC->tileIsPixel) &&
	     exaFillRegionSolid(pDrawable, pReg, pGC->fillStyle == FillSolid ?
				pGC->fgPixel : pGC->tile.pixel,	pGC->planemask,
				pGC->alu)) ||
	    (pGC->fillStyle == FillTiled && !pGC->tileIsPixel &&
	     exaFillRegionTiled(pDrawable, pReg, pGC->tile.pixmap, &pGC->patOrg,
				pGC->planemask, pGC->alu))) {
	    goto out;
	}
d638 1
a638 9
    if (pGC->fillStyle != FillSolid &&
	!(pGC->tileIsPixel && pGC->fillStyle == FillTiled))
    {
	goto fallback;
    }

    exaDoMigration (pixmaps, 1, TRUE);

    if (!exaPixmapIsOffscreen (pPixmap) ||
a643 10
fallback:
	if (pGC->fillStyle == FillTiled && !pGC->tileIsPixel) {
	    pixmaps[1].as_dst = FALSE;
	    pixmaps[1].as_src = TRUE;
	    pixmaps[1].pPix = pGC->tile.pixmap;
	    exaDoMigration (pixmaps, 2, FALSE);
	} else {
	    exaDoMigration (pixmaps, 1, FALSE);
	}

d645 1
a645 1
	goto out;
d690 1
a690 2
	     * this is logically equivalent to calling Intersect(),
	     * but rectangles may overlap each other here.
d709 1
a709 1
		if (partX1 < partX2 && partY1 < partY2) {
a712 1
		}
d717 1
a718 3

out:
    REGION_DESTROY(pScreen, pReg);
a737 1
    Bool	fallback = FALSE;
d741 2
a742 2
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);

d744 2
a745 2
	pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
d747 2
a748 1
	fallback = TRUE;
d753 1
a753 3
    exaGetDrawableDeltas (pDrawable, pPixmap, &xoff, &yoff);

    if (fallback || !exaPixmapIsOffscreen(pPixmap) ||
d756 1
a758 2
	exaDoMigration (pixmaps, 1, FALSE);
	fallback = TRUE;
d765 1
d793 3
a795 8
	if (!fallback) {
	    (*pExaScr->info->Solid) (pPixmap,
				     partX1 + xoff, partY1 + yoff,
				     partX2 + xoff, partY2 + yoff);
	}

	exaPixmapDirty (pPixmap, partX1 + xoff, partY1 + yoff, partX2 + xoff,
			partY2 + yoff);
a796 4

    if (fallback)
	return;

d798 1
a831 23
    PixmapPtr	    pPixmap = exaGetDrawablePixmap(pDrawable);
    ExaMigrationRec pixmaps[1];
    int		    xBack, widthBack, yBack, heightBack;

    for (ppci = ppciInit, n = nglyph, widthBack = 0; n; n--)
	widthBack += (*ppci++)->metrics.characterWidth;

    xBack = x;
    if (widthBack < 0)
    {
	xBack += widthBack;
	widthBack = -widthBack;
    }
    yBack = y - FONTASCENT(pGC->font);
    heightBack = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);

    if (xBack >= pDrawable->width || yBack >= pDrawable->height ||
	(xBack + widthBack) <= 0 || (yBack + heightBack) <= 0)
	return;

    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = pPixmap;
a835 1
	exaDoMigration(pixmaps, 1, FALSE);
d837 1
a837 1
	goto damage;
a848 2
    xBack += pDrawable->x;
    yBack += pDrawable->y;
d856 17
a884 1
    exaDoMigration(pixmaps, 1, FALSE);
d890 2
a891 1
    for (ppci = ppciInit; nglyph; nglyph--, x += pci->metrics.characterWidth)
d894 1
d897 1
a897 12
	gx = x + pci->metrics.leftSideBearing;
	gy = y - pci->metrics.ascent;

	if (!gWidth || !gHeight || (gx + gWidth) <= xBack ||
	    (gy + gHeight) <= yBack || gx >= (xBack + widthBack) ||
	    gy >= (yBack + heightBack))
	    continue;

	pglyph = FONTGLYPHBITS(pglyphBase, pci);

	if (glyph && gWidth <= sizeof (FbStip) * 8 &&
	    fbGlyphIn (fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight))
d899 32
a930 11
	    (*glyph) (dst + (gy + dstYoff) * dstStride, dstStride, dstBpp,
		      (FbStip *) pglyph, pPriv->fg, gx + dstXoff, gHeight);
	}
	else
	{
	    RegionPtr pClip = fbGetCompositeClip(pGC);

	    gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof (FbStip);
	    fbPutXYImage (pDrawable, pClip, pPriv->fg, pPriv->bg, pPriv->pm,
			  GXcopy, opaque, gx, gy, gWidth, gHeight,
			  (FbStip *) pglyph, gStride, 0);
d932 1
a935 5

damage:
    exaGetDrawableDeltas(pDrawable, pPixmap, &dstXoff, &dstYoff);
    exaPixmapDirty(pPixmap, xBack + dstXoff, yBack + dstYoff,
		   xBack + dstXoff + widthBack, yBack + dstYoff + heightBack);
d988 1
a988 1
static Bool
d991 1
a991 3
		    Pixel	pixel,
		    CARD32	planemask,
		    CARD32	alu)
a996 2
    int nbox = REGION_NUM_RECTS (pRegion);
    BoxPtr pBox = REGION_RECTS (pRegion);
d1000 1
a1000 1
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);
d1002 2
a1003 2
    if (pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY)
d1005 1
d1012 1
a1012 1
	(*pExaScr->info->PrepareSolid) (pPixmap, alu, planemask, pixel))
d1014 3
d1026 1
a1030 2
	if (alu != GXcopy || planemask != FB_ALLONES)
	    return FALSE;
a1032 1
	exaDoMigration (pixmaps, 1, FALSE);
a1037 2

    return TRUE;
d1043 1
a1043 1
Bool
d1046 1
a1046 4
		    PixmapPtr	pTile,
		    DDXPointPtr pPatOrg,
		    CARD32	planemask,
		    CARD32	alu)
d1050 1
a1050 1
    int xoff, yoff, tileXoff, tileYoff;
a1052 2
    int nbox = REGION_NUM_RECTS (pRegion);
    BoxPtr pBox = REGION_RECTS (pRegion);
d1060 4
a1063 4
    if (tileWidth == 1 && tileHeight == 1)
	return exaFillRegionSolid(pDrawable, pRegion,
				  exaGetPixmapFirstPixel (pTile), planemask,
				  alu);
d1067 1
a1067 1
    pixmaps[0].pPix = pPixmap = exaGetDrawablePixmap (pDrawable);
d1072 2
a1073 2
    if (pPixmap->drawable.width > pExaScr->info->maxX ||
	pPixmap->drawable.height > pExaScr->info->maxY ||
d1077 1
a1083 1

d1090 2
a1091 3
    if ((*pExaScr->info->PrepareCopy) (exaGetOffscreenPixmap((DrawablePtr)pTile,
							     &tileXoff, &tileYoff),
				       pPixmap, 0, 0, alu, planemask))
d1093 3
d1102 1
a1102 1
	    tileY = (dstY - pDrawable->y - pPatOrg->y) % tileHeight;
d1113 1
a1113 1
		tileX = (dstX - pDrawable->x - pPatOrg->x) % tileWidth;
d1121 1
a1121 1
					    tileX + tileXoff, tileY + tileYoff,
d1134 2
a1135 1
	return TRUE;
a1138 2
    if (alu != GXcopy || planemask != FB_ALLONES)
	return FALSE;
a1141 1
    exaDoMigration (pixmaps, 2, FALSE);
a1146 2

    return TRUE;
d1153 1
a1153 6
    PixmapPtr pPixmap = exaGetDrawablePixmap((DrawablePtr)pWin);
    int xoff, yoff;
    BoxPtr pBox;
    int nbox = REGION_NUM_RECTS(pRegion);

    if (!nbox)
a1154 1

a1155 2
	DDXPointRec zeros = { 0, 0 };

d1169 2
a1170 3
		exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->background.pixel,
				   FB_ALLONES, GXcopy);
                goto damage;
d1172 2
a1173 3
                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->background.pixmap,
				   &zeros, FB_ALLONES, GXcopy);
                goto damage;
d1178 2
a1179 3
                exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->border.pixel,
				   FB_ALLONES, GXcopy);
                goto damage;
d1181 2
a1182 3
                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->border.pixmap,
				   &zeros, FB_ALLONES, GXcopy);
                goto damage;
a1187 12

damage:
    exaGetDrawableDeltas((DrawablePtr)pWin, pPixmap, &xoff, &yoff);

    pBox = REGION_RECTS(pRegion);

    while (nbox--)
    {
	exaPixmapDirty (pPixmap, pBox->x1 + xoff, pBox->y1 + yoff,
			pBox->x2 + xoff, pBox->y2 + yoff);
	pBox++;
    }
d1207 1
a1207 1
    if (pExaScr->swappedOut || (w == 1 && h == 1))
a1209 3
    if (pExaScr->info->DownloadFromScreen == NULL)
	goto migrate_and_fallback;

d1212 1
a1212 1
	goto migrate_and_fallback;
d1218 1
a1218 1
	goto migrate_and_fallback;
d1220 8
d1242 1
a1242 1
migrate_and_fallback:
d1247 1
a1247 1
fallback:
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@d1190 1
a1190 2
	    modulus(dstY - pDrawable->y - pPatOrg->y, tileHeight, tileY);

d1201 1
a1201 2
		modulus(dstX - pDrawable->x - pPatOrg->x, tileWidth, tileX);

d1226 1
a1226 2
    if (alu != GXcopy || planemask != FB_ALLONES || pPatOrg->x != 0 ||
	pPatOrg->y != 0)
@


