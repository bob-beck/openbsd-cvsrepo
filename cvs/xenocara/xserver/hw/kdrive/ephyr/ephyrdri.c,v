head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.6
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 *
 * Copyright © 2007 OpenedHand Ltd
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */
#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include <X11/Xdefs.h>
#include <xcb/xf86dri.h>
#include "hostx.h"
#include "ephyrdri.h"
#define _HAVE_XALLOC_DECLS
#include "ephyrlog.h"
#include "dixstruct.h"
#include "pixmapstr.h"

#ifndef TRUE
#define TRUE 1
#endif /*TRUE*/
#ifndef FALSE
#define FALSE 0
#endif /*FALSE*/
    Bool
ephyrDRIQueryDirectRenderingCapable(int a_screen, Bool *a_is_capable)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    Bool is_ok = FALSE;
    xcb_xf86dri_query_direct_rendering_capable_cookie_t cookie;
    xcb_xf86dri_query_direct_rendering_capable_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(a_is_capable, FALSE);
    EPHYR_LOG("enter\n");
    cookie = xcb_xf86dri_query_direct_rendering_capable(conn,
                                                        hostx_get_screen());
    reply = xcb_xf86dri_query_direct_rendering_capable_reply(conn, cookie, NULL);
    if (reply) {
        is_ok = TRUE;
        *a_is_capable = reply->is_capable;
        free(reply);
    }
    EPHYR_LOG("leave. is_capable:%d, is_ok=%d\n", *a_is_capable, is_ok);

    return is_ok;
}

Bool
ephyrDRIOpenConnection(int a_screen,
                       drm_handle_t * a_sarea, char **a_bus_id_string)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    Bool is_ok = FALSE;
    xcb_xf86dri_open_connection_cookie_t cookie;
    xcb_xf86dri_open_connection_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(a_bus_id_string, FALSE);
    EPHYR_LOG("enter. screen:%d\n", a_screen);
    cookie = xcb_xf86dri_open_connection(conn, hostx_get_screen());
    reply = xcb_xf86dri_open_connection_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_sarea = reply->sarea_handle_low;
    if (sizeof(drm_handle_t) == 8) {
        int shift = 32;
        *a_sarea |= ((drm_handle_t) reply->sarea_handle_high) << shift;
    }
    *a_bus_id_string = malloc(reply->bus_id_len + 1);
    if (!*a_bus_id_string)
        goto out;
    memcpy(*a_bus_id_string, xcb_xf86dri_open_connection_bus_id(reply), reply->bus_id_len);
    *a_bus_id_string[reply->bus_id_len] = '\0';
    is_ok = TRUE;
out:
    free(reply);
    EPHYR_LOG("leave. bus_id_string:%s, is_ok:%d\n", *a_bus_id_string, is_ok);
    return is_ok;
}

Bool
ephyrDRIAuthConnection(int a_screen, drm_magic_t a_magic)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();
    xcb_xf86dri_auth_connection_cookie_t cookie;
    xcb_xf86dri_auth_connection_reply_t *reply;
    Bool is_ok = FALSE;

    EPHYR_LOG("enter\n");
    cookie = xcb_xf86dri_auth_connection(conn, screen, a_magic);
    reply = xcb_xf86dri_auth_connection_reply(conn, cookie, NULL);
    is_ok = reply->authenticated;
    free(reply);
    EPHYR_LOG("leave. is_ok:%d\n", is_ok);
    return is_ok;
}

Bool
ephyrDRICloseConnection(int a_screen)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();

    EPHYR_LOG("enter\n");
    xcb_xf86dri_close_connection(conn, screen);
    EPHYR_LOG("leave\n");
    return TRUE;
}

Bool
ephyrDRIGetClientDriverName(int a_screen,
                            int *a_ddx_driver_major_version,
                            int *a_ddx_driver_minor_version,
                            int *a_ddx_driver_patch_version,
                            char **a_client_driver_name)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();
    xcb_xf86dri_get_client_driver_name_cookie_t cookie;
    xcb_xf86dri_get_client_driver_name_reply_t *reply;
    Bool is_ok = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(a_ddx_driver_major_version
                             && a_ddx_driver_minor_version
                             && a_ddx_driver_patch_version
                             && a_client_driver_name, FALSE);
    EPHYR_LOG("enter\n");
    cookie = xcb_xf86dri_get_client_driver_name(conn, screen);
    reply = xcb_xf86dri_get_client_driver_name_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_ddx_driver_major_version = reply->client_driver_major_version;
    *a_ddx_driver_minor_version = reply->client_driver_minor_version;
    *a_ddx_driver_patch_version = reply->client_driver_patch_version;
    *a_client_driver_name = malloc(reply->client_driver_name_len + 1);
    if (!*a_client_driver_name)
        goto out;
    memcpy(*a_client_driver_name,
           xcb_xf86dri_get_client_driver_name_client_driver_name(reply),
           reply->client_driver_name_len);
    (*a_client_driver_name)[reply->client_driver_name_len] = '\0';
    is_ok = TRUE;
    EPHYR_LOG("major:%d, minor:%d, patch:%d, name:%s\n",
              *a_ddx_driver_major_version,
              *a_ddx_driver_minor_version,
              *a_ddx_driver_patch_version, *a_client_driver_name);
 out:
    free(reply);
    EPHYR_LOG("leave:%d\n", is_ok);
    return is_ok;
}

Bool
ephyrDRICreateContext(int a_screen,
                      int a_visual_id,
                      CARD32 ctxt_id, drm_context_t * a_hw_ctxt)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();
    Bool is_ok = FALSE;
    xcb_xf86dri_create_context_cookie_t cookie;
    xcb_xf86dri_create_context_reply_t *reply;

    ctxt_id = xcb_generate_id(conn);

    EPHYR_LOG("enter. screen:%d, visual:%d\n", a_screen, a_visual_id);
    cookie = xcb_xf86dri_create_context(conn, screen, a_visual_id, ctxt_id);
    reply = xcb_xf86dri_create_context_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_hw_ctxt = reply->hw_context;
    is_ok = TRUE;
out:
    free(reply);
    EPHYR_LOG("leave:%d\n", is_ok);
    return is_ok;
}

Bool
ephyrDRIDestroyContext(int a_screen, int a_context_id)
{
    xcb_connection_t *conn = hostx_get_xcbconn ();
    int screen = hostx_get_screen();

    EPHYR_LOG("enter\n");
    xcb_xf86dri_destroy_context(conn, screen, a_context_id);
    EPHYR_LOG("leave\n");
    return TRUE;
}

Bool
ephyrDRICreateDrawable(int a_screen,
                       int a_drawable, drm_drawable_t * a_hw_drawable)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();
    xcb_xf86dri_create_drawable_cookie_t cookie;
    xcb_xf86dri_create_drawable_reply_t *reply;

    EPHYR_LOG("enter\n");
    cookie = xcb_xf86dri_create_drawable(conn, screen, a_drawable);
    reply = xcb_xf86dri_create_drawable_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_hw_drawable = reply->hw_drawable_handle;
    is_ok = TRUE;
out:
    free(reply);
    EPHYR_LOG("leave. is_ok:%d\n", is_ok);
    return is_ok;
}

Bool
ephyrDRIDestroyDrawable(int a_screen, int a_drawable)
{
    EPHYR_LOG("enter\n");
    EPHYR_LOG_ERROR("not implemented yet\n");
    EPHYR_LOG("leave\n");
    return FALSE;
}

Bool
ephyrDRIGetDrawableInfo(int a_screen,
                        int a_drawable,
                        unsigned int *a_index,
                        unsigned int *a_stamp,
                        int *a_x,
                        int *a_y,
                        int *a_w,
                        int *a_h,
                        int *a_num_clip_rects,
                        drm_clip_rect_t ** a_clip_rects,
                        int *a_back_x,
                        int *a_back_y,
                        int *a_num_back_clip_rects,
                        drm_clip_rect_t ** a_back_clip_rects)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();
    xcb_xf86dri_get_drawable_info_cookie_t cookie;
    xcb_xf86dri_get_drawable_info_reply_t *reply = NULL;
    EphyrHostWindowAttributes attrs;

    EPHYR_RETURN_VAL_IF_FAIL(a_x && a_y && a_w && a_h
                             && a_num_clip_rects, FALSE);

    EPHYR_LOG("enter\n");
    memset(&attrs, 0, sizeof(attrs));
    if (!hostx_get_window_attributes(a_drawable, &attrs)) {
        EPHYR_LOG_ERROR("failed to query host window attributes\n");
        goto out;
    }
    cookie = xcb_xf86dri_get_drawable_info(conn, screen, a_drawable);
    reply =  xcb_xf86dri_get_drawable_info_reply(conn, cookie, NULL);
    if (!reply) {
        EPHYR_LOG_ERROR ("XF86DRIGetDrawableInfo ()\n");
        goto out;
    }
    *a_index = reply->drawable_table_index;
    *a_stamp = reply->drawable_table_stamp;
    *a_x = reply->drawable_origin_X;
    *a_y = reply->drawable_origin_Y;
    *a_w = reply->drawable_size_W;
    *a_h = reply->drawable_size_H;
    *a_num_clip_rects = reply->num_clip_rects;
    *a_clip_rects = calloc(*a_num_clip_rects, sizeof(drm_clip_rect_t));
    memcpy(*a_clip_rects, xcb_xf86dri_get_drawable_info_clip_rects(reply),
           *a_num_clip_rects * sizeof(drm_clip_rect_t));
    EPHYR_LOG("host x,y,w,h: (%d,%d,%d,%d)\n", *a_x, *a_y, *a_w, *a_h);
    if (*a_num_clip_rects) {
        free(*a_back_clip_rects);
        *a_back_clip_rects = calloc(*a_num_clip_rects, sizeof(drm_clip_rect_t));
        memmove(*a_back_clip_rects,
                *a_clip_rects, *a_num_clip_rects * sizeof(drm_clip_rect_t));
        *a_num_back_clip_rects = *a_num_clip_rects;
    }
    EPHYR_LOG("num back clip rects:%d, num clip rects:%d\n",
              *a_num_clip_rects, *a_num_back_clip_rects);
    *a_back_x = *a_x;
    *a_back_y = *a_y;
    *a_w = attrs.width;
    *a_h = attrs.height;

    is_ok = TRUE;
 out:
    EPHYR_LOG("leave. index:%d, stamp:%d, x,y:(%d,%d), w,y:(%d,%d)\n",
              *a_index, *a_stamp, *a_x, *a_y, *a_w, *a_h);
    free(reply);
    return is_ok;
}

Bool
ephyrDRIGetDeviceInfo(int a_screen,
                      drm_handle_t * a_frame_buffer,
                      int *a_fb_origin,
                      int *a_fb_size,
                      int *a_fb_stride,
                      int *a_dev_private_size, void **a_dev_private)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn ();
    int screen = hostx_get_screen();
    xcb_xf86dri_get_device_info_cookie_t cookie;
    xcb_xf86dri_get_device_info_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(conn, FALSE);
    EPHYR_LOG("enter\n");
    cookie = xcb_xf86dri_get_device_info(conn, screen);
    reply = xcb_xf86dri_get_device_info_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_frame_buffer = reply->framebuffer_handle_low;
    if (sizeof(drm_handle_t) == 8) {
        int shift = 32;
        *a_frame_buffer |= ((drm_handle_t)reply->framebuffer_handle_high) << shift;
    }
    *a_fb_origin = reply->framebuffer_origin_offset;
    *a_fb_size = reply->framebuffer_size;
    *a_fb_stride = reply->framebuffer_stride;
    *a_dev_private_size = reply->device_private_size;
    *a_dev_private = calloc(reply->device_private_size, 1);
    if (!*a_dev_private)
        goto out;
    memcpy(*a_dev_private,
           xcb_xf86dri_get_device_info_device_private(reply),
           reply->device_private_size);
    is_ok = TRUE;
out:
    free(reply);
    EPHYR_LOG("leave:%d\n", is_ok);
    return is_ok;
}
@


1.4
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d4 2
a5 2
 * 
 * Copyright © 2007 OpenedHand Ltd 
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d32 2
a33 4
#include <X11/Xutil.h>
#include <X11/Xlibint.h>
#include <GL/glx.h>
#include "xf86dri.h"
d50 1
a50 1
    Display *dpy = hostx_get_display();
d52 2
d57 8
a64 2
    is_ok = XF86DRIQueryDirectRenderingCapable(dpy, DefaultScreen(dpy),
                                               a_is_capable);
d74 1
a74 1
    Display *dpy = hostx_get_display();
d76 2
d81 8
a88 8
    is_ok = XF86DRIOpenConnection(dpy, DefaultScreen(dpy),
                                  a_sarea, a_bus_id_string);
    if (*a_bus_id_string) {
        EPHYR_LOG("leave. bus_id_string:%s, is_ok:%d\n",
                  *a_bus_id_string, is_ok);
    }
    else {
        EPHYR_LOG("leave. bus_id_string:null, is_ok:%d\n", is_ok);
d90 9
d105 4
a108 1
    Display *dpy = hostx_get_display();
d112 4
a115 1
    is_ok = XF86DRIAuthConnection(dpy, DefaultScreen(dpy), a_magic);
d123 2
a124 2
    Display *dpy = hostx_get_display();
    Bool is_ok = FALSE;
d127 1
a127 1
    is_ok = XF86DRICloseConnection(dpy, DefaultScreen(dpy));
d129 1
a129 1
    return is_ok;
d139 4
a142 1
    Display *dpy = hostx_get_display();
d150 15
a164 5
    is_ok = XF86DRIGetClientDriverName(dpy, DefaultScreen(dpy),
                                       a_ddx_driver_major_version,
                                       a_ddx_driver_minor_version,
                                       a_ddx_driver_patch_version,
                                       a_client_driver_name);
d169 2
d178 1
a178 1
                      XID *a_returned_ctxt_id, drm_context_t * a_hw_ctxt)
d180 2
a181 1
    Display *dpy = hostx_get_display();
d183 4
a186 1
    Visual v;
d189 8
a196 5
    memset(&v, 0, sizeof(v));
    v.visualid = a_visual_id;
    is_ok = XF86DRICreateContext(dpy,
                                 DefaultScreen(dpy),
                                 &v, a_returned_ctxt_id, a_hw_ctxt);
d204 2
a205 2
    Display *dpy = hostx_get_display();
    Bool is_ok = FALSE;
d208 3
a210 3
    is_ok = XF86DRIDestroyContext(dpy, DefaultScreen(dpy), a_context_id);
    EPHYR_LOG("leave:%d\n", is_ok);
    return is_ok;
d218 4
a221 1
    Display *dpy = hostx_get_display();
d224 8
a231 2
    is_ok = XF86DRICreateDrawable(dpy, DefaultScreen(dpy),
                                  a_drawable, a_hw_drawable);
d262 4
a265 1
    Display *dpy = hostx_get_display();
d277 4
a280 8
    if (!XF86DRIGetDrawableInfo(dpy, DefaultScreen(dpy), a_drawable,
                                a_index, a_stamp,
                                a_x, a_y,
                                a_w, a_h,
                                a_num_clip_rects, a_clip_rects,
                                a_back_x, a_back_y,
                                a_num_back_clip_rects, a_back_clip_rects)) {
        EPHYR_LOG_ERROR("XF86DRIGetDrawableInfo ()\n");
d283 10
d312 1
d325 4
a328 1
    Display *dpy = hostx_get_display();
d330 1
a330 1
    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);
d332 22
a353 3
    is_ok = XF86DRIGetDeviceInfo(dpy, DefaultScreen(dpy), a_frame_buffer,
                                 a_fb_origin, a_fb_size, a_fb_stride,
                                 a_dev_private_size, a_dev_private);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a45 1

d49 2
a50 3

Bool
ephyrDRIQueryDirectRenderingCapable (int a_screen, Bool *a_is_capable)
d52 2
a53 2
    Display *dpy=hostx_get_display () ;
    Bool is_ok=FALSE ;
d55 5
a59 5
    EPHYR_RETURN_VAL_IF_FAIL (a_is_capable, FALSE) ;
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRIQueryDirectRenderingCapable (dpy, DefaultScreen (dpy),
                                                a_is_capable) ;
    EPHYR_LOG ("leave. is_capable:%d, is_ok=%d\n", *a_is_capable, is_ok) ;
d61 1
a61 1
    return is_ok ;
d65 2
a66 3
ephyrDRIOpenConnection (int a_screen,
                        drm_handle_t *a_sarea,
                        char **a_bus_id_string)
d68 2
a69 2
    Display *dpy = hostx_get_display () ;
    Bool is_ok=FALSE ;
d71 4
a74 5
    EPHYR_RETURN_VAL_IF_FAIL (a_bus_id_string, FALSE) ;
    EPHYR_LOG ("enter. screen:%d\n", a_screen) ;
    is_ok = XF86DRIOpenConnection (dpy, DefaultScreen (dpy),
                                   a_sarea,
                                   a_bus_id_string) ;
d76 5
a80 5
        EPHYR_LOG ("leave. bus_id_string:%s, is_ok:%d\n",
                   *a_bus_id_string, is_ok) ;
    } else {
        EPHYR_LOG ("leave. bus_id_string:null, is_ok:%d\n",
                   is_ok) ;
d82 1
a82 1
    return is_ok ;
d86 1
a86 1
ephyrDRIAuthConnection (int a_screen, drm_magic_t a_magic)
d88 2
a89 2
    Display *dpy = hostx_get_display () ;
    Bool is_ok=FALSE ;
d91 4
a94 4
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRIAuthConnection (dpy, DefaultScreen (dpy), a_magic) ;
    EPHYR_LOG ("leave. is_ok:%d\n", is_ok) ;
    return is_ok ;
d98 1
a98 1
ephyrDRICloseConnection (int a_screen)
d100 2
a101 2
    Display *dpy = hostx_get_display () ;
    Bool is_ok=FALSE ;
d103 4
a106 4
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRICloseConnection (dpy, DefaultScreen (dpy)) ;
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d110 5
a114 5
ephyrDRIGetClientDriverName (int a_screen,
                             int *a_ddx_driver_major_version,
                             int *a_ddx_driver_minor_version,
                             int *a_ddx_driver_patch_version,
                             char ** a_client_driver_name)
d116 2
a117 2
    Display *dpy = hostx_get_display () ;
    Bool is_ok=FALSE ;
d119 16
a134 18
    EPHYR_RETURN_VAL_IF_FAIL (a_ddx_driver_major_version
                              && a_ddx_driver_minor_version
                              && a_ddx_driver_patch_version
                              && a_client_driver_name,
                              FALSE);
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRIGetClientDriverName (dpy, DefaultScreen (dpy),
                                        a_ddx_driver_major_version,
                                        a_ddx_driver_minor_version,
                                        a_ddx_driver_patch_version,
                                        a_client_driver_name) ;
    EPHYR_LOG ("major:%d, minor:%d, patch:%d, name:%s\n",
                *a_ddx_driver_major_version,
                *a_ddx_driver_minor_version,
                *a_ddx_driver_patch_version,
                *a_client_driver_name) ;
    EPHYR_LOG ("leave:%d\n", is_ok) ;
    return is_ok ;
d138 3
a140 4
ephyrDRICreateContext (int a_screen,
                       int a_visual_id,
                       XID *a_returned_ctxt_id,
                       drm_context_t *a_hw_ctxt)
d142 2
a143 2
    Display *dpy = hostx_get_display () ;
    Bool is_ok=FALSE ;
d146 8
a153 10
    EPHYR_LOG ("enter. screen:%d, visual:%d\n", a_screen, a_visual_id) ;
    memset (&v, 0, sizeof (v)) ;
    v.visualid = a_visual_id ;
    is_ok = XF86DRICreateContext (dpy,
                                  DefaultScreen (dpy),
                                  &v,
                                  a_returned_ctxt_id,
                                  a_hw_ctxt) ;
    EPHYR_LOG ("leave:%d\n", is_ok) ;
    return is_ok ;
d157 1
a157 2
ephyrDRIDestroyContext (int a_screen,
                        int a_context_id)
d159 2
a160 2
    Display *dpy = hostx_get_display () ;
    Bool is_ok=FALSE ;
d162 4
a165 4
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRIDestroyContext (dpy, DefaultScreen (dpy), a_context_id) ;
    EPHYR_LOG ("leave:%d\n", is_ok) ;
    return is_ok ;
d169 2
a170 3
ephyrDRICreateDrawable (int a_screen,
                        int a_drawable,
                        drm_drawable_t *a_hw_drawable)
d172 2
a173 2
    Bool is_ok=FALSE;
    Display *dpy=hostx_get_display () ;
d175 5
a179 5
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRICreateDrawable (dpy, DefaultScreen (dpy),
                                   a_drawable, a_hw_drawable) ;
    EPHYR_LOG ("leave. is_ok:%d\n", is_ok) ;
    return is_ok ;
d183 6
a188 6
ephyrDRIDestroyDrawable (int a_screen, int a_drawable)
{
    EPHYR_LOG ("enter\n") ;
    EPHYR_LOG_ERROR ("not implemented yet\n") ;
    EPHYR_LOG ("leave\n") ;
    return FALSE ;
d192 26
a217 27
ephyrDRIGetDrawableInfo (int a_screen,
                         int a_drawable,
                         unsigned int *a_index,
                         unsigned int *a_stamp,
                         int *a_x,
                         int *a_y,
                         int *a_w,
                         int *a_h,
                         int *a_num_clip_rects,
                         drm_clip_rect_t **a_clip_rects,
                         int *a_back_x,
                         int *a_back_y,
                         int *a_num_back_clip_rects,
                         drm_clip_rect_t **a_back_clip_rects)
{
    Bool is_ok=FALSE;
    Display *dpy=hostx_get_display ()  ;
    EphyrHostWindowAttributes attrs ;

    EPHYR_RETURN_VAL_IF_FAIL (a_x && a_y && a_w && a_h
                              && a_num_clip_rects,
                              FALSE) ;

    EPHYR_LOG ("enter\n") ;
    memset (&attrs, 0, sizeof (attrs)) ;
    if (!hostx_get_window_attributes (a_drawable, &attrs)) {
        EPHYR_LOG_ERROR ("failed to query host window attributes\n") ;
d220 9
a228 10
    if (!XF86DRIGetDrawableInfo (dpy, DefaultScreen (dpy), a_drawable,
                                 a_index, a_stamp,
                                 a_x, a_y,
                                 a_w, a_h,
                                 a_num_clip_rects, a_clip_rects,
                                 a_back_x, a_back_y,
                                 a_num_back_clip_rects,
                                 a_back_clip_rects)) {
        EPHYR_LOG_ERROR ("XF86DRIGetDrawableInfo ()\n") ;
        goto out ;
d230 1
a230 1
    EPHYR_LOG ("host x,y,w,h: (%d,%d,%d,%d)\n", *a_x, *a_y, *a_w, *a_h) ;
d232 4
a235 6
        free (*a_back_clip_rects) ;
        *a_back_clip_rects = calloc (*a_num_clip_rects,
                                     sizeof (drm_clip_rect_t)) ;
        memmove (*a_back_clip_rects,
                 *a_clip_rects,
                 *a_num_clip_rects * sizeof (drm_clip_rect_t)) ;
d238 4
a241 4
    EPHYR_LOG ("num back clip rects:%d, num clip rects:%d\n",
               *a_num_clip_rects, *a_num_back_clip_rects) ;
    *a_back_x = *a_x ;
    *a_back_y = *a_y ;
d245 5
a249 5
    is_ok = TRUE ;
out:
    EPHYR_LOG ("leave. index:%d, stamp:%d, x,y:(%d,%d), w,y:(%d,%d)\n",
               *a_index, *a_stamp, *a_x, *a_y, *a_w, *a_h) ;
    return is_ok ;
d253 17
a269 18
ephyrDRIGetDeviceInfo (int a_screen,
                       drm_handle_t *a_frame_buffer,
                       int *a_fb_origin,
                       int *a_fb_size,
                       int *a_fb_stride,
                       int *a_dev_private_size,
                       void **a_dev_private)
{
    Bool is_ok = FALSE ;
    Display *dpy = hostx_get_display () ;

    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
    EPHYR_LOG ("enter\n") ;
    is_ok = XF86DRIGetDeviceInfo (dpy, DefaultScreen (dpy), a_frame_buffer,
                                  a_fb_origin, a_fb_size, a_fb_stride,
                                  a_dev_private_size, a_dev_private) ;
    EPHYR_LOG ("leave:%d\n", is_ok) ;
    return is_ok ;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a31 2
#ifdef XEPHYR_DRI

a33 1
/*#define _XF86DRI_SERVER_*/
d35 1
a35 1
#include <X11/dri/xf86dri.h>
d146 1
a146 1
                       unsigned long int *a_returned_ctxt_id,
a286 2
#endif /*EPHYR_DRI*/

@

