head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 *
 * Copyright © 2007 OpenedHand Ltd
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * This file is heavily copied from hw/xfree86/dri/xf86dri.c
 *
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#define _XF86DRI_SERVER_
#include <X11/dri/xf86dri.h>
#include <X11/dri/xf86driproto.h>
#include <xcb/xcb.h>
#include <xcb/shape.h>
#include <xcb/xf86dri.h>
#include "misc.h"
#include "privates.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "servermd.h"
#include "swaprep.h"
#include "ephyrdri.h"
#include "ephyrdriext.h"
#include "hostx.h"
#define _HAVE_XALLOC_DECLS
#include "ephyrlog.h"
#include "protocol-versions.h"

typedef struct {
    int foo;
} EphyrDRIWindowPrivRec;
typedef EphyrDRIWindowPrivRec *EphyrDRIWindowPrivPtr;

typedef struct {
    CreateWindowProcPtr CreateWindow;
    DestroyWindowProcPtr DestroyWindow;
    MoveWindowProcPtr MoveWindow;
    PositionWindowProcPtr PositionWindow;
    ClipNotifyProcPtr ClipNotify;
} EphyrDRIScreenPrivRec;
typedef EphyrDRIScreenPrivRec *EphyrDRIScreenPrivPtr;

static int DRIErrorBase;

static Bool ephyrDRIScreenInit(ScreenPtr a_screen);
static Bool ephyrDRICreateWindow(WindowPtr a_win);
static Bool ephyrDRIDestroyWindow(WindowPtr a_win);
static void ephyrDRIMoveWindow(WindowPtr a_win,
                               int a_x, int a_y,
                               WindowPtr a_siblings, VTKind a_kind);
static Bool ephyrDRIPositionWindow(WindowPtr a_win, int x, int y);
static void ephyrDRIClipNotify(WindowPtr a_win, int a_x, int a_y);

static Bool EphyrMirrorHostVisuals(ScreenPtr a_screen);
static Bool destroyHostPeerWindow(const WindowPtr a_win);
static Bool findWindowPairFromLocal(WindowPtr a_local,
                                    EphyrWindowPair ** a_pair);

static unsigned char DRIReqCode = 0;

static DevPrivateKeyRec ephyrDRIWindowKeyRec;

#define ephyrDRIWindowKey (&ephyrDRIWindowKeyRec)
static DevPrivateKeyRec ephyrDRIScreenKeyRec;

#define ephyrDRIScreenKey (&ephyrDRIScreenKeyRec)

#define GET_EPHYR_DRI_WINDOW_PRIV(win) ((EphyrDRIWindowPrivPtr) \
    dixLookupPrivate(&(win)->devPrivates, ephyrDRIWindowKey))
#define GET_EPHYR_DRI_SCREEN_PRIV(screen) ((EphyrDRIScreenPrivPtr) \
    dixLookupPrivate(&(screen)->devPrivates, ephyrDRIScreenKey))

static Bool
ephyrDRIScreenInit(ScreenPtr a_screen)
{
    Bool is_ok = FALSE;
    EphyrDRIScreenPrivPtr screen_priv = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_screen, FALSE);

    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV(a_screen);
    EPHYR_RETURN_VAL_IF_FAIL(screen_priv, FALSE);

    screen_priv->CreateWindow = a_screen->CreateWindow;
    screen_priv->DestroyWindow = a_screen->DestroyWindow;
    screen_priv->MoveWindow = a_screen->MoveWindow;
    screen_priv->PositionWindow = a_screen->PositionWindow;
    screen_priv->ClipNotify = a_screen->ClipNotify;

    a_screen->CreateWindow = ephyrDRICreateWindow;
    a_screen->DestroyWindow = ephyrDRIDestroyWindow;
    a_screen->MoveWindow = ephyrDRIMoveWindow;
    a_screen->PositionWindow = ephyrDRIPositionWindow;
    a_screen->ClipNotify = ephyrDRIClipNotify;

    is_ok = TRUE;

    return is_ok;
}

static Bool
ephyrDRICreateWindow(WindowPtr a_win)
{
    Bool is_ok = FALSE;
    ScreenPtr screen = NULL;
    EphyrDRIScreenPrivPtr screen_priv = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_win, FALSE);
    screen = a_win->drawable.pScreen;
    EPHYR_RETURN_VAL_IF_FAIL(screen, FALSE);
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV(screen);
    EPHYR_RETURN_VAL_IF_FAIL(screen_priv && screen_priv->CreateWindow, FALSE);

    EPHYR_LOG("enter. win:%p\n", a_win);

    screen->CreateWindow = screen_priv->CreateWindow;
    is_ok = (*screen->CreateWindow) (a_win);
    screen->CreateWindow = ephyrDRICreateWindow;

    if (is_ok) {
        dixSetPrivate(&a_win->devPrivates, ephyrDRIWindowKey, NULL);
    }
    return is_ok;
}

static Bool
ephyrDRIDestroyWindow(WindowPtr a_win)
{
    Bool is_ok = FALSE;
    ScreenPtr screen = NULL;
    EphyrDRIScreenPrivPtr screen_priv = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_win, FALSE);
    screen = a_win->drawable.pScreen;
    EPHYR_RETURN_VAL_IF_FAIL(screen, FALSE);
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV(screen);
    EPHYR_RETURN_VAL_IF_FAIL(screen_priv && screen_priv->DestroyWindow, FALSE);

    screen->DestroyWindow = screen_priv->DestroyWindow;
    if (screen->DestroyWindow) {
        is_ok = (*screen->DestroyWindow) (a_win);
    }
    screen->DestroyWindow = ephyrDRIDestroyWindow;

    if (is_ok) {
        EphyrDRIWindowPrivPtr win_priv = GET_EPHYR_DRI_WINDOW_PRIV(a_win);

        if (win_priv) {
            destroyHostPeerWindow(a_win);
            free(win_priv);
            dixSetPrivate(&a_win->devPrivates, ephyrDRIWindowKey, NULL);
            EPHYR_LOG("destroyed the remote peer window\n");
        }
    }
    return is_ok;
}

static void
ephyrDRIMoveWindow(WindowPtr a_win,
                   int a_x, int a_y, WindowPtr a_siblings, VTKind a_kind)
{
    ScreenPtr screen = NULL;
    EphyrDRIScreenPrivPtr screen_priv = NULL;
    EphyrDRIWindowPrivPtr win_priv = NULL;
    EphyrWindowPair *pair = NULL;
    EphyrBox geo;
    int x = 0, y = 0;           /*coords relative to parent window */

    EPHYR_RETURN_IF_FAIL(a_win);

    EPHYR_LOG("enter\n");
    screen = a_win->drawable.pScreen;
    EPHYR_RETURN_IF_FAIL(screen);
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV(screen);
    EPHYR_RETURN_IF_FAIL(screen_priv && screen_priv->MoveWindow);

    screen->MoveWindow = screen_priv->MoveWindow;
    if (screen->MoveWindow) {
        (*screen->MoveWindow) (a_win, a_x, a_y, a_siblings, a_kind);
    }
    screen->MoveWindow = ephyrDRIMoveWindow;

    EPHYR_LOG("window: %p\n", a_win);
    if (!a_win->parent) {
        EPHYR_LOG("cannot move root window\n");
        return;
    }
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV(a_win);
    if (!win_priv) {
        EPHYR_LOG("not a DRI peered window\n");
        return;
    }
    if (!findWindowPairFromLocal(a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR("failed to get window pair\n");
        return;
    }
    /*compute position relative to parent window */
    x = a_win->drawable.x - a_win->parent->drawable.x;
    y = a_win->drawable.y - a_win->parent->drawable.y;
    /*set the geometry to pass to hostx_set_window_geometry */
    memset(&geo, 0, sizeof(geo));
    geo.x = x;
    geo.y = y;
    geo.width = a_win->drawable.width;
    geo.height = a_win->drawable.height;
    hostx_set_window_geometry(pair->remote, &geo);
}

static Bool
ephyrDRIPositionWindow(WindowPtr a_win, int a_x, int a_y)
{
    Bool is_ok = FALSE;
    ScreenPtr screen = NULL;
    EphyrDRIScreenPrivPtr screen_priv = NULL;
    EphyrDRIWindowPrivPtr win_priv = NULL;
    EphyrWindowPair *pair = NULL;
    EphyrBox geo;

    EPHYR_RETURN_VAL_IF_FAIL(a_win, FALSE);

    EPHYR_LOG("enter\n");
    screen = a_win->drawable.pScreen;
    EPHYR_RETURN_VAL_IF_FAIL(screen, FALSE);
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV(screen);
    EPHYR_RETURN_VAL_IF_FAIL(screen_priv && screen_priv->PositionWindow, FALSE);

    screen->PositionWindow = screen_priv->PositionWindow;
    if (screen->PositionWindow) {
        (*screen->PositionWindow) (a_win, a_x, a_y);
    }
    screen->PositionWindow = ephyrDRIPositionWindow;

    EPHYR_LOG("window: %p\n", a_win);
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV(a_win);
    if (!win_priv) {
        EPHYR_LOG("not a DRI peered window\n");
        is_ok = TRUE;
        goto out;
    }
    if (!findWindowPairFromLocal(a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR("failed to get window pair\n");
        goto out;
    }
    /*set the geometry to pass to hostx_set_window_geometry */
    memset(&geo, 0, sizeof(geo));
    geo.x = a_x;
    geo.y = a_y;
    geo.width = a_win->drawable.width;
    geo.height = a_win->drawable.height;
    hostx_set_window_geometry(pair->remote, &geo);
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave. is_ok:%d\n", is_ok);
    /*do cleanup here */
    return is_ok;
}

static void
ephyrDRIClipNotify(WindowPtr a_win, int a_x, int a_y)
{
    ScreenPtr screen = NULL;
    EphyrDRIScreenPrivPtr screen_priv = NULL;
    EphyrDRIWindowPrivPtr win_priv = NULL;
    EphyrWindowPair *pair = NULL;
    EphyrRect *rects = NULL;
    int i = 0;

    EPHYR_RETURN_IF_FAIL(a_win);

    EPHYR_LOG("enter\n");
    screen = a_win->drawable.pScreen;
    EPHYR_RETURN_IF_FAIL(screen);
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV(screen);
    EPHYR_RETURN_IF_FAIL(screen_priv && screen_priv->ClipNotify);

    screen->ClipNotify = screen_priv->ClipNotify;
    if (screen->ClipNotify) {
        (*screen->ClipNotify) (a_win, a_x, a_y);
    }
    screen->ClipNotify = ephyrDRIClipNotify;

    EPHYR_LOG("window: %p\n", a_win);
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV(a_win);
    if (!win_priv) {
        EPHYR_LOG("not a DRI peered window\n");
        goto out;
    }
    if (!findWindowPairFromLocal(a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR("failed to get window pair\n");
        goto out;
    }
    rects = calloc(RegionNumRects(&a_win->clipList), sizeof(EphyrRect));
    for (i = 0; i < RegionNumRects(&a_win->clipList); i++) {
        memmove(&rects[i],
                &RegionRects(&a_win->clipList)[i], sizeof(EphyrRect));
        rects[i].x1 -= a_win->drawable.x;
        rects[i].x2 -= a_win->drawable.x;
        rects[i].y1 -= a_win->drawable.y;
        rects[i].y2 -= a_win->drawable.y;
    }
    /*
     * push the clipping region of this window
     * to the peer window in the host
     */
    hostx_set_window_bounding_rectangles
        (pair->remote, rects, RegionNumRects(&a_win->clipList));

 out:
    free(rects);
    rects = NULL;

    EPHYR_LOG("leave.\n");
    /*do cleanup here */
}

/**
 * Duplicates a visual of a_screen
 * In screen a_screen, for depth a_depth, find a visual which
 * bitsPerRGBValue and colormap size equal
 * a_bits_per_rgb_values and a_colormap_entries.
 * The ID of that duplicated visual is set to a_new_id.
 * That duplicated visual is then added to the list of visuals
 * of the screen.
 */
static Bool
EphyrDuplicateVisual(unsigned int a_screen,
                     short a_depth,
                     short a_class,
                     short a_bits_per_rgb_values,
                     short a_colormap_entries,
                     unsigned int a_red_mask,
                     unsigned int a_green_mask,
                     unsigned int a_blue_mask, unsigned int a_new_id)
{
    Bool is_ok = FALSE, found_visual = FALSE, found_depth = FALSE;
    ScreenPtr screen = NULL;
    VisualRec new_visual, *new_visuals = NULL;
    int i = 0;

    EPHYR_LOG("enter\n");
    if (a_screen >= screenInfo.numScreens) {
        EPHYR_LOG_ERROR("bad screen number\n");
        goto out;
    }
    memset(&new_visual, 0, sizeof(VisualRec));

    /*get the screen pointed to by a_screen */
    screen = screenInfo.screens[a_screen];
    EPHYR_RETURN_VAL_IF_FAIL(screen, FALSE);

    /*
     * In that screen, first look for an existing visual that has the
     * same characteristics as those passed in parameter
     * to this function and copy it.
     */
    for (i = 0; i < screen->numVisuals; i++) {
        if (screen->visuals[i].bitsPerRGBValue == a_bits_per_rgb_values &&
            screen->visuals[i].ColormapEntries == a_colormap_entries) {
            /*copy the visual found */
            memcpy(&new_visual, &screen->visuals[i], sizeof(new_visual));
            new_visual.vid = a_new_id;
            new_visual.class = a_class;
            new_visual.redMask = a_red_mask;
            new_visual.greenMask = a_green_mask;
            new_visual.blueMask = a_blue_mask;
            found_visual = TRUE;
            EPHYR_LOG("found a visual that matches visual id: %d\n", a_new_id);
            break;
        }
    }
    if (!found_visual) {
        EPHYR_LOG("did not find any visual matching %d\n", a_new_id);
        goto out;
    }
    /*
     * be prepare to extend screen->visuals to add new_visual to it
     */
    new_visuals = calloc(screen->numVisuals + 1, sizeof(VisualRec));
    memmove(new_visuals,
            screen->visuals, screen->numVisuals * sizeof(VisualRec));
    memmove(&new_visuals[screen->numVisuals], &new_visual, sizeof(VisualRec));
    /*
     * Now, in that same screen, update the screen->allowedDepths member.
     * In that array, each element represents the visuals applicable to
     * a given depth. So we need to add an entry matching the new visual
     * that we are going to add to screen->visuals
     */
    for (i = 0; i < screen->numDepths; i++) {
        VisualID *vids = NULL;
        DepthPtr cur_depth = NULL;

        /*find the entry matching a_depth */
        if (screen->allowedDepths[i].depth != a_depth)
            continue;
        cur_depth = &screen->allowedDepths[i];
        /*
         * extend the list of visual IDs in that entry,
         * so to add a_new_id in there.
         */
        vids = reallocarray(cur_depth->vids,
                            cur_depth->numVids + 1, sizeof(VisualID));
        if (!vids) {
            EPHYR_LOG_ERROR("failed to realloc numids\n");
            goto out;
        }
        vids[cur_depth->numVids] = a_new_id;
        /*
         * Okay now commit our change.
         * Do really update screen->allowedDepths[i]
         */
        cur_depth->numVids++;
        cur_depth->vids = vids;
        found_depth = TRUE;
    }
    if (!found_depth) {
        EPHYR_LOG_ERROR("failed to update screen[%d]->allowedDepth\n",
                        a_screen);
        goto out;
    }
    /*
     * Commit our change to screen->visuals
     */
    free(screen->visuals);
    screen->visuals = new_visuals;
    screen->numVisuals++;
    new_visuals = NULL;

    is_ok = TRUE;
 out:
    free(new_visuals);
    new_visuals = NULL;

    EPHYR_LOG("leave\n");
    return is_ok;
}

/**
 * Duplicates the visuals of the host X server.
 * This is necessary to have visuals that have the same
 * ID as those of the host X. It is important to have that for
 * GLX.
 */
static Bool
EphyrMirrorHostVisuals(ScreenPtr a_screen)
{
    Bool is_ok = FALSE;
    EphyrHostVisualInfo *visuals = NULL;
    int nb_visuals = 0, i = 0;

    EPHYR_LOG("enter\n");
    if (!hostx_get_visuals_info(&visuals, &nb_visuals)) {
        EPHYR_LOG_ERROR("failed to get host visuals\n");
        goto out;
    }
    for (i = 0; i < nb_visuals; i++) {
        if (!EphyrDuplicateVisual(a_screen->myNum,
                                  visuals[i].depth,
                                  visuals[i].class,
                                  visuals[i].bits_per_rgb,
                                  visuals[i].colormap_size,
                                  visuals[i].red_mask,
                                  visuals[i].green_mask,
                                  visuals[i].blue_mask, visuals[i].visualid)) {
            EPHYR_LOG_ERROR("failed to duplicate host visual %d\n",
                            (int) visuals[i].visualid);
        }
    }

    is_ok = TRUE;
 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static int
ProcXF86DRIQueryVersion(register ClientPtr client)
{
    xXF86DRIQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_XF86DRI_MAJOR_VERSION,
        .minorVersion = SERVER_XF86DRI_MINOR_VERSION,
        .patchVersion = SERVER_XF86DRI_PATCH_VERSION
    };

    REQUEST_SIZE_MATCH(xXF86DRIQueryVersionReq);

    EPHYR_LOG("enter\n");

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
        swapl(&rep.patchVersion);
    }
    WriteToClient(client, sizeof(xXF86DRIQueryVersionReply), &rep);
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIQueryDirectRenderingCapable(register ClientPtr client)
{
    xXF86DRIQueryDirectRenderingCapableReply rep;
    Bool isCapable;

    REQUEST(xXF86DRIQueryDirectRenderingCapableReq);
    REQUEST_SIZE_MATCH(xXF86DRIQueryDirectRenderingCapableReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    if (!ephyrDRIQueryDirectRenderingCapable(stuff->screen, &isCapable)) {
        return BadValue;
    }

    if (!client->local || client->swapped)
        isCapable = 0;

    rep = (xXF86DRIQueryDirectRenderingCapableReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .isCapable = isCapable
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }

    WriteToClient(client, sizeof(xXF86DRIQueryDirectRenderingCapableReply),
                  &rep);
    EPHYR_LOG("leave\n");

    return Success;
}

static int
ProcXF86DRIOpenConnection(register ClientPtr client)
{
    xXF86DRIOpenConnectionReply rep;
    drm_handle_t hSAREA;
    char *busIdString = NULL;
    CARD32 busIdStringLength = 0;

    REQUEST(xXF86DRIOpenConnectionReq);
    REQUEST_SIZE_MATCH(xXF86DRIOpenConnectionReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    if (!ephyrDRIOpenConnection(stuff->screen, &hSAREA, &busIdString)) {
        return BadValue;
    }

    if (busIdString)
        busIdStringLength = strlen(busIdString);

    rep = (xXF86DRIOpenConnectionReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(SIZEOF(xXF86DRIOpenConnectionReply) -
                                 SIZEOF(xGenericReply) +
                                 pad_to_int32(busIdStringLength)),
        .hSAREALow = (CARD32) (hSAREA & 0xffffffff),
#if defined(LONG64) && !defined(__linux__)
        .hSAREAHigh = (CARD32) (hSAREA >> 32),
#else
        .hSAREAHigh = 0,
#endif
        .busIdStringLength = busIdStringLength
    };

    WriteToClient(client, sizeof(xXF86DRIOpenConnectionReply), &rep);
    if (busIdStringLength)
        WriteToClient(client, busIdStringLength, busIdString);
    free(busIdString);
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIAuthConnection(register ClientPtr client)
{
    xXF86DRIAuthConnectionReply rep;

    REQUEST(xXF86DRIAuthConnectionReq);
    REQUEST_SIZE_MATCH(xXF86DRIAuthConnectionReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    rep = (xXF86DRIAuthConnectionReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .authenticated = 1
    };

    if (!ephyrDRIAuthConnection(stuff->screen, stuff->magic)) {
        ErrorF("Failed to authenticate %lu\n", (unsigned long) stuff->magic);
        rep.authenticated = 0;
    }
    WriteToClient(client, sizeof(xXF86DRIAuthConnectionReply), &rep);
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRICloseConnection(register ClientPtr client)
{
    REQUEST(xXF86DRICloseConnectionReq);
    REQUEST_SIZE_MATCH(xXF86DRICloseConnectionReq);
    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    /*
       DRICloseConnection( screenInfo.screens[stuff->screen]);
     */

    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIGetClientDriverName(register ClientPtr client)
{
    xXF86DRIGetClientDriverNameReply rep =  {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .clientDriverNameLength = 0
    };
    char *clientDriverName;

    REQUEST(xXF86DRIGetClientDriverNameReq);
    REQUEST_SIZE_MATCH(xXF86DRIGetClientDriverNameReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    ephyrDRIGetClientDriverName(stuff->screen,
                                (int *) &rep.ddxDriverMajorVersion,
                                (int *) &rep.ddxDriverMinorVersion,
                                (int *) &rep.ddxDriverPatchVersion,
                                &clientDriverName);
    if (clientDriverName)
        rep.clientDriverNameLength = strlen(clientDriverName);
    rep.length = bytes_to_int32(SIZEOF(xXF86DRIGetClientDriverNameReply) -
                                SIZEOF(xGenericReply) +
                                pad_to_int32(rep.clientDriverNameLength));

    WriteToClient(client, sizeof(xXF86DRIGetClientDriverNameReply), &rep);
    if (rep.clientDriverNameLength)
        WriteToClient(client, rep.clientDriverNameLength, clientDriverName);
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRICreateContext(register ClientPtr client)
{
    xXF86DRICreateContextReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    ScreenPtr pScreen;
    VisualPtr visual;
    int i = 0;

    REQUEST(xXF86DRICreateContextReq);
    REQUEST_SIZE_MATCH(xXF86DRICreateContextReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    pScreen = screenInfo.screens[stuff->screen];
    visual = pScreen->visuals;

    /* Find the requested X visual */
    for (i = 0; i < pScreen->numVisuals; i++, visual++)
        if (visual->vid == stuff->visual)
            break;
    if (i == pScreen->numVisuals) {
        /* No visual found */
        return BadValue;
    }

    if (!ephyrDRICreateContext(stuff->screen,
                               stuff->visual,
                               stuff->context,
                               (drm_context_t *) &rep.hHWContext)) {
        return BadValue;
    }

    WriteToClient(client, sizeof(xXF86DRICreateContextReply), &rep);
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIDestroyContext(register ClientPtr client)
{
    REQUEST(xXF86DRIDestroyContextReq);
    REQUEST_SIZE_MATCH(xXF86DRIDestroyContextReq);
    EPHYR_LOG("enter\n");

    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    if (!ephyrDRIDestroyContext(stuff->screen, stuff->context)) {
        return BadValue;
    }

    EPHYR_LOG("leave\n");
    return Success;
}

static Bool
getWindowVisual(const WindowPtr a_win, VisualPtr * a_visual)
{
    int i = 0, visual_id = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_win
                             && a_win->drawable.pScreen
                             && a_win->drawable.pScreen->visuals, FALSE);

    visual_id = wVisual(a_win);
    for (i = 0; i < a_win->drawable.pScreen->numVisuals; i++) {
        if (a_win->drawable.pScreen->visuals[i].vid == visual_id) {
            *a_visual = &a_win->drawable.pScreen->visuals[i];
            return TRUE;
        }
    }
    return FALSE;
}

#define NUM_WINDOW_PAIRS 256
static EphyrWindowPair window_pairs[NUM_WINDOW_PAIRS];

static Bool
appendWindowPairToList(WindowPtr a_local, int a_remote)
{
    int i = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_local, FALSE);

    EPHYR_LOG("(local,remote):(%p, %d)\n", a_local, a_remote);

    for (i = 0; i < NUM_WINDOW_PAIRS; i++) {
        if (window_pairs[i].local == NULL) {
            window_pairs[i].local = a_local;
            window_pairs[i].remote = a_remote;
            return TRUE;
        }
    }
    return FALSE;
}

static Bool
findWindowPairFromLocal(WindowPtr a_local, EphyrWindowPair ** a_pair)
{
    int i = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_pair && a_local, FALSE);

    for (i = 0; i < NUM_WINDOW_PAIRS; i++) {
        if (window_pairs[i].local == a_local) {
            *a_pair = &window_pairs[i];
            EPHYR_LOG("found (%p, %d)\n", (*a_pair)->local, (*a_pair)->remote);
            return TRUE;
        }
    }
    return FALSE;
}

Bool
findWindowPairFromRemote(int a_remote, EphyrWindowPair ** a_pair)
{
    int i = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_pair, FALSE);

    for (i = 0; i < NUM_WINDOW_PAIRS; i++) {
        if (window_pairs[i].remote == a_remote) {
            *a_pair = &window_pairs[i];
            EPHYR_LOG("found (%p, %d)\n", (*a_pair)->local, (*a_pair)->remote);
            return TRUE;
        }
    }
    return FALSE;
}

static Bool
createHostPeerWindow(const WindowPtr a_win, int *a_peer_win)
{
    Bool is_ok = FALSE;
    VisualPtr visual = NULL;
    EphyrBox geo;

    EPHYR_RETURN_VAL_IF_FAIL(a_win && a_peer_win, FALSE);
    EPHYR_RETURN_VAL_IF_FAIL(a_win->drawable.pScreen, FALSE);

    EPHYR_LOG("enter. a_win '%p'\n", a_win);
    if (!getWindowVisual(a_win, &visual)) {
        EPHYR_LOG_ERROR("failed to get window visual\n");
        goto out;
    }
    if (!visual) {
        EPHYR_LOG_ERROR("failed to create visual\n");
        goto out;
    }
    memset(&geo, 0, sizeof(geo));
    geo.x = a_win->drawable.x;
    geo.y = a_win->drawable.y;
    geo.width = a_win->drawable.width;
    geo.height = a_win->drawable.height;
    if (!hostx_create_window(a_win->drawable.pScreen->myNum,
                             &geo, visual->vid, a_peer_win)) {
        EPHYR_LOG_ERROR("failed to create host peer window\n");
        goto out;
    }
    if (!appendWindowPairToList(a_win, *a_peer_win)) {
        EPHYR_LOG_ERROR("failed to append window to pair list\n");
        goto out;
    }
    is_ok = TRUE;
 out:
    EPHYR_LOG("leave:remote win%d\n", *a_peer_win);
    return is_ok;
}

static Bool
destroyHostPeerWindow(const WindowPtr a_win)
{
    Bool is_ok = FALSE;
    EphyrWindowPair *pair = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_win, FALSE);

    EPHYR_LOG("enter\n");

    if (!findWindowPairFromLocal(a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR("failed to find peer to local window\n");
        goto out;
    }
    hostx_destroy_window(pair->remote);
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static int
ProcXF86DRICreateDrawable(ClientPtr client)
{
    xXF86DRICreateDrawableReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    DrawablePtr drawable = NULL;
    WindowPtr window = NULL;
    EphyrWindowPair *pair = NULL;
    EphyrDRIWindowPrivPtr win_priv = NULL;
    int rc = 0, remote_win = 0;

    REQUEST(xXF86DRICreateDrawableReq);
    REQUEST_SIZE_MATCH(xXF86DRICreateDrawableReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    rc = dixLookupDrawable(&drawable, stuff->drawable, client, 0,
                           DixReadAccess);
    if (rc != Success)
        return rc;
    if (drawable->type != DRAWABLE_WINDOW) {
        EPHYR_LOG_ERROR("non drawable windows are not yet supported\n");
        return BadImplementation;
    }
    EPHYR_LOG("lookedup drawable %p\n", drawable);
    window = (WindowPtr) drawable;
    if (findWindowPairFromLocal(window, &pair) && pair) {
        remote_win = pair->remote;
        EPHYR_LOG("found window '%p' paire with remote '%d'\n",
                  window, remote_win);
    }
    else if (!createHostPeerWindow(window, &remote_win)) {
        EPHYR_LOG_ERROR("failed to create host peer window\n");
        return BadAlloc;
    }

    if (!ephyrDRICreateDrawable(stuff->screen,
                                remote_win,
                                (drm_drawable_t *) &rep.hHWDrawable)) {
        EPHYR_LOG_ERROR("failed to create dri drawable\n");
        return BadValue;
    }

    win_priv = GET_EPHYR_DRI_WINDOW_PRIV(window);
    if (!win_priv) {
        win_priv = calloc(1, sizeof(EphyrDRIWindowPrivRec));
        if (!win_priv) {
            EPHYR_LOG_ERROR("failed to allocate window private\n");
            return BadAlloc;
        }
        dixSetPrivate(&window->devPrivates, ephyrDRIWindowKey, win_priv);
        EPHYR_LOG("paired window '%p' with remote '%d'\n", window, remote_win);
    }

    WriteToClient(client, sizeof(xXF86DRICreateDrawableReply), &rep);
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIDestroyDrawable(register ClientPtr client)
{
    DrawablePtr drawable = NULL;
    WindowPtr window = NULL;
    EphyrWindowPair *pair = NULL;
    int rc = 0;

    REQUEST(xXF86DRIDestroyDrawableReq);
    REQUEST_SIZE_MATCH(xXF86DRIDestroyDrawableReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    rc = dixLookupDrawable(&drawable,
                           stuff->drawable, client, 0, DixReadAccess);
    if (rc != Success)
        return rc;
    if (drawable->type != DRAWABLE_WINDOW) {
        EPHYR_LOG_ERROR("non drawable windows are not yet supported\n");
        return BadImplementation;
    }
    window = (WindowPtr) drawable;
    if (!findWindowPairFromLocal(window, &pair) && pair) {
        EPHYR_LOG_ERROR("failed to find pair window\n");
        return BadImplementation;
    }
    if (!ephyrDRIDestroyDrawable(stuff->screen,
                                 pair->remote /*drawable in host x */ )) {
        EPHYR_LOG_ERROR("failed to destroy dri drawable\n");
        return BadImplementation;
    }
    pair->local = NULL;
    pair->remote = 0;

    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIGetDrawableInfo(register ClientPtr client)
{
    xXF86DRIGetDrawableInfoReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    DrawablePtr drawable;
    WindowPtr window = NULL;
    EphyrWindowPair *pair = NULL;
    int X = 0, Y = 0, W = 0, H = 0, backX = 0, backY = 0, rc = 0, i = 0;
    drm_clip_rect_t *clipRects = NULL;
    drm_clip_rect_t *backClipRects = NULL;

    REQUEST(xXF86DRIGetDrawableInfoReq);
    REQUEST_SIZE_MATCH(xXF86DRIGetDrawableInfoReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    rc = dixLookupDrawable(&drawable, stuff->drawable, client, 0,
                           DixReadAccess);
    if (rc != Success || !drawable) {
        EPHYR_LOG_ERROR("could not get drawable\n");
        return rc;
    }

    if (drawable->type != DRAWABLE_WINDOW) {
        EPHYR_LOG_ERROR("non windows type drawables are not yes supported\n");
        return BadImplementation;
    }
    window = (WindowPtr) drawable;
    memset(&pair, 0, sizeof(pair));
    if (!findWindowPairFromLocal(window, &pair) || !pair) {
        EPHYR_LOG_ERROR("failed to find remote peer drawable\n");
        return BadMatch;
    }
    EPHYR_LOG("clip list of xephyr gl drawable:\n");
    for (i = 0; i < RegionNumRects(&window->clipList); i++) {
        EPHYR_LOG("x1:%d, y1:%d, x2:%d, y2:%d\n",
                  RegionRects(&window->clipList)[i].x1,
                  RegionRects(&window->clipList)[i].y1,
                  RegionRects(&window->clipList)[i].x2,
                  RegionRects(&window->clipList)[i].y2);
    }

    if (!ephyrDRIGetDrawableInfo(stuff->screen,
                                 pair->remote /*the drawable in hostx */ ,
                                 (unsigned int *) &rep.drawableTableIndex,
                                 (unsigned int *) &rep.drawableTableStamp,
                                 (int *) &X,
                                 (int *) &Y,
                                 (int *) &W,
                                 (int *) &H,
                                 (int *) &rep.numClipRects,
                                 &clipRects,
                                 &backX,
                                 &backY,
                                 (int *) &rep.numBackClipRects,
                                 &backClipRects)) {
        return BadValue;
    }
    EPHYR_LOG("num clip rects:%d, num back clip rects:%d\n",
              (int) rep.numClipRects, (int) rep.numBackClipRects);

    rep.drawableX = X;
    rep.drawableY = Y;
    rep.drawableWidth = W;
    rep.drawableHeight = H;
    rep.length = (SIZEOF(xXF86DRIGetDrawableInfoReply) - SIZEOF(xGenericReply));

    rep.backX = backX;
    rep.backY = backY;

    if (rep.numClipRects) {
        if (clipRects) {
            ScreenPtr pScreen = screenInfo.screens[stuff->screen];

            EPHYR_LOG("clip list of host gl drawable:\n");
            for (i = 0; i < rep.numClipRects; i++) {
                clipRects[i].x1 = max(clipRects[i].x1, 0);
                clipRects[i].y1 = max(clipRects[i].y1, 0);
                clipRects[i].x2 = min(clipRects[i].x2,
                                      pScreen->width + clipRects[i].x1);
                clipRects[i].y2 = min(clipRects[i].y2,
                                      pScreen->width + clipRects[i].y1);

                EPHYR_LOG("x1:%d, y1:%d, x2:%d, y2:%d\n",
                          clipRects[i].x1, clipRects[i].y1,
                          clipRects[i].x2, clipRects[i].y2);
            }
        }
        else {
            rep.numClipRects = 0;
        }
    }
    else {
        EPHYR_LOG("got zero host gl drawable clipping rects\n");
    }
    rep.length += sizeof(drm_clip_rect_t) * rep.numClipRects;
    backClipRects = clipRects;
    rep.numBackClipRects = rep.numClipRects;
    if (rep.numBackClipRects)
        rep.length += sizeof(drm_clip_rect_t) * rep.numBackClipRects;
    EPHYR_LOG("num host clip rects:%d\n", (int) rep.numClipRects);
    EPHYR_LOG("num host back clip rects:%d\n", (int) rep.numBackClipRects);

    rep.length = bytes_to_int32(rep.length);

    WriteToClient(client, sizeof(xXF86DRIGetDrawableInfoReply), &rep);

    if (rep.numClipRects) {
        WriteToClient(client,
                      sizeof(drm_clip_rect_t) * rep.numClipRects,
                      clipRects);
    }

    if (rep.numBackClipRects) {
        WriteToClient(client,
                      sizeof(drm_clip_rect_t) * rep.numBackClipRects,
                      backClipRects);
    }
    free(clipRects);
    clipRects = NULL;

    EPHYR_LOG("leave\n");

    return Success;
}

static int
ProcXF86DRIGetDeviceInfo(register ClientPtr client)
{
    xXF86DRIGetDeviceInfoReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    drm_handle_t hFrameBuffer;
    void *pDevPrivate;

    REQUEST(xXF86DRIGetDeviceInfoReq);
    REQUEST_SIZE_MATCH(xXF86DRIGetDeviceInfoReq);

    EPHYR_LOG("enter\n");
    if (stuff->screen >= screenInfo.numScreens) {
        client->errorValue = stuff->screen;
        return BadValue;
    }

    if (!ephyrDRIGetDeviceInfo(stuff->screen,
                               &hFrameBuffer,
                               (int *) &rep.framebufferOrigin,
                               (int *) &rep.framebufferSize,
                               (int *) &rep.framebufferStride,
                               (int *) &rep.devPrivateSize, &pDevPrivate)) {
        return BadValue;
    }

    rep.hFrameBufferLow = (CARD32) (hFrameBuffer & 0xffffffff);
#if defined(LONG64) && !defined(__linux__)
    rep.hFrameBufferHigh = (CARD32) (hFrameBuffer >> 32);
#else
    rep.hFrameBufferHigh = 0;
#endif

    if (rep.devPrivateSize) {
        rep.length = bytes_to_int32(SIZEOF(xXF86DRIGetDeviceInfoReply) -
                                    SIZEOF(xGenericReply) +
                                    pad_to_int32(rep.devPrivateSize));
    }

    WriteToClient(client, sizeof(xXF86DRIGetDeviceInfoReply), &rep);
    if (rep.length) {
        WriteToClient(client, rep.devPrivateSize, pDevPrivate);
    }
    EPHYR_LOG("leave\n");
    return Success;
}

static int
ProcXF86DRIDispatch(register ClientPtr client)
{
    REQUEST(xReq);
    EPHYR_LOG("enter\n");

    switch (stuff->data) {
    case X_XF86DRIQueryVersion:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIQueryVersion(client);
    }
    case X_XF86DRIQueryDirectRenderingCapable:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIQueryDirectRenderingCapable(client);
    }
    }

    if (!client->local)
        return DRIErrorBase + XF86DRIClientNotLocal;

    switch (stuff->data) {
    case X_XF86DRIOpenConnection:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIOpenConnection(client);
    }
    case X_XF86DRICloseConnection:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRICloseConnection(client);
    }
    case X_XF86DRIGetClientDriverName:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIGetClientDriverName(client);
    }
    case X_XF86DRICreateContext:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRICreateContext(client);
    }
    case X_XF86DRIDestroyContext:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIDestroyContext(client);
    }
    case X_XF86DRICreateDrawable:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRICreateDrawable(client);
    }
    case X_XF86DRIDestroyDrawable:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIDestroyDrawable(client);
    }
    case X_XF86DRIGetDrawableInfo:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIGetDrawableInfo(client);
    }
    case X_XF86DRIGetDeviceInfo:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIGetDeviceInfo(client);
    }
    case X_XF86DRIAuthConnection:{
        EPHYR_LOG("leave\n");
        return ProcXF86DRIAuthConnection(client);
    }
        /* {Open,Close}FullScreen are deprecated now */
    default:{
        EPHYR_LOG("leave\n");
        return BadRequest;
    }
    }
}

static int
SProcXF86DRIQueryVersion(register ClientPtr client)
{
    REQUEST(xXF86DRIQueryVersionReq);
    swaps(&stuff->length);
    return ProcXF86DRIQueryVersion(client);
}

static int
SProcXF86DRIQueryDirectRenderingCapable(register ClientPtr client)
{
    REQUEST(xXF86DRIQueryDirectRenderingCapableReq);
    swaps(&stuff->length);
    swapl(&stuff->screen);
    return ProcXF86DRIQueryDirectRenderingCapable(client);
}

static int
SProcXF86DRIDispatch(register ClientPtr client)
{
    REQUEST(xReq);

    EPHYR_LOG("enter\n");
    /*
     * Only local clients are allowed DRI access, but remote clients still need
     * these requests to find out cleanly.
     */
    switch (stuff->data) {
    case X_XF86DRIQueryVersion:{
        EPHYR_LOG("leave\n");
        return SProcXF86DRIQueryVersion(client);
    }
    case X_XF86DRIQueryDirectRenderingCapable:{
        EPHYR_LOG("leave\n");
        return SProcXF86DRIQueryDirectRenderingCapable(client);
    }
    default:{
        EPHYR_LOG("leave\n");
        return DRIErrorBase + XF86DRIClientNotLocal;
    }
    }
}

Bool
ephyrDRIExtensionInit(ScreenPtr a_screen)
{
    Bool is_ok = FALSE;
    ExtensionEntry *extEntry = NULL;
    EphyrDRIScreenPrivPtr screen_priv = NULL;

    EPHYR_LOG("enter\n");
    if (!hostx_has_extension(&xcb_xf86dri_id)) {
        EPHYR_LOG("host does not have DRI extension\n");
        goto out;
    }
    EPHYR_LOG("host X does have DRI extension\n");
    if (!hostx_has_extension(&xcb_shape_id)) {
        EPHYR_LOG("host does not have XShape extension\n");
        goto out;
    }
    EPHYR_LOG("host X does have XShape extension\n");

#ifdef XF86DRI_EVENTS
    EventType = CreateNewResourceType(XF86DRIFreeEvents, "DRIEvents");
    if (!EventType) {
        EPHYR_LOG_ERROR("failed to register DRI event resource type\n");
        goto out;
    }
#endif

    if ((extEntry = AddExtension(XF86DRINAME,
                                 XF86DRINumberEvents,
                                 XF86DRINumberErrors,
                                 ProcXF86DRIDispatch,
                                 SProcXF86DRIDispatch,
                                 NULL, StandardMinorOpcode))) {
        DRIReqCode = (unsigned char) extEntry->base;
        DRIErrorBase = extEntry->errorBase;
    }
    else {
        EPHYR_LOG_ERROR("failed to register DRI extension\n");
        goto out;
    }
    if (!dixRegisterPrivateKey(&ephyrDRIScreenKeyRec, PRIVATE_SCREEN, 0))
        goto out;
    if (!dixRegisterPrivateKey(&ephyrDRIWindowKeyRec, PRIVATE_WINDOW, 0))
        goto out;
    screen_priv = calloc(1, sizeof(EphyrDRIScreenPrivRec));
    if (!screen_priv) {
        EPHYR_LOG_ERROR("failed to allocate screen_priv\n");
        goto out;
    }
    dixSetPrivate(&a_screen->devPrivates, ephyrDRIScreenKey, screen_priv);

    if (!ephyrDRIScreenInit(a_screen)) {
        EPHYR_LOG_ERROR("ephyrDRIScreenInit() failed\n");
        goto out;
    }
    EphyrMirrorHostVisuals(a_screen);
    is_ok = TRUE;
 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d434 2
a435 2
        vids = realloc(cur_depth->vids,
                       (cur_depth->numVids + 1) * sizeof(VisualID));
d1324 1
a1324 1
    if (!host_has_extension(&xcb_xf86dri_id)) {
d1329 1
a1329 1
    if (!host_has_extension(&xcb_shape_id)) {
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d4 2
a5 2
 * 
 * Copyright © 2007 OpenedHand Ltd 
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a1100 1
            int i = 0;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d42 3
a194 1
    Bool is_ok = FALSE;
d219 1
a219 2
        is_ok = TRUE;
        goto out;
d224 1
a224 2
        is_ok = TRUE;
        goto out;
d228 1
a228 1
        goto out;
a239 5
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave. is_ok:%d\n", is_ok);
    /*do cleanup here */
a294 1
    Bool is_ok = FALSE;
a319 1
        is_ok = TRUE;
d339 1
a339 1
    is_ok = hostx_set_window_bounding_rectangles
a340 1
    is_ok = TRUE;
d346 1
a346 1
    EPHYR_LOG("leave. is_ok:%d\n", is_ok);
a721 1
    unsigned long context_id = 0;
a743 1
    context_id = stuff->context;
d746 1
a746 1
                               &context_id,
d1325 1
a1325 1
    if (!hostx_has_dri()) {
d1330 1
a1330 1
    if (!hostx_has_xshape()) {
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d520 8
a527 1
    xXF86DRIQueryVersionReply rep;
a532 6
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_XF86DRI_MAJOR_VERSION;
    rep.minorVersion = SERVER_XF86DRI_MINOR_VERSION;
    rep.patchVersion = SERVER_XF86DRI_PATCH_VERSION;
d540 1
a540 1
    WriteToClient(client, sizeof(xXF86DRIQueryVersionReply), (char *) &rep);
a559 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

a562 1
    rep.isCapable = isCapable;
d564 9
a572 2
    if (!LocalClient(client) || client->swapped)
        rep.isCapable = 0;
d580 1
a580 1
                  (char *) &rep);
d592 1
a606 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.busIdStringLength = 0;
d608 1
a608 5
        rep.busIdStringLength = strlen(busIdString);
    rep.length =
        bytes_to_int32(SIZEOF(xXF86DRIOpenConnectionReply) -
                       SIZEOF(xGenericReply) +
                       pad_to_int32(rep.busIdStringLength));
d610 7
a616 1
    rep.hSAREALow = (CARD32) (hSAREA & 0xffffffff);
d618 1
a618 1
    rep.hSAREAHigh = (CARD32) (hSAREA >> 32);
d620 1
a620 1
    rep.hSAREAHigh = 0;
d622 2
d625 3
a627 3
    WriteToClient(client, sizeof(xXF86DRIOpenConnectionReply), (char *) &rep);
    if (rep.busIdStringLength)
        WriteToClient(client, rep.busIdStringLength, busIdString);
d647 6
a652 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.authenticated = 1;
d658 1
a658 1
    WriteToClient(client, sizeof(xXF86DRIAuthConnectionReply), (char *) &rep);
d685 5
a689 1
    xXF86DRIGetClientDriverNameReply rep;
a705 4

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.clientDriverNameLength = 0;
d712 1
a712 2
    WriteToClient(client,
                  sizeof(xXF86DRIGetClientDriverNameReply), (char *) &rep);
d722 5
a726 1
    xXF86DRICreateContextReply rep;
a740 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

d757 1
a757 1
                               (drm_context_t *) & rep.hHWContext)) {
d761 1
a761 1
    WriteToClient(client, sizeof(xXF86DRICreateContextReply), (char *) &rep);
d925 5
a929 1
    xXF86DRICreateDrawableReply rep;
a944 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

d967 1
a967 1
                                (drm_drawable_t *) & rep.hHWDrawable)) {
d983 1
a983 1
    WriteToClient(client, sizeof(xXF86DRICreateDrawableReply), (char *) &rep);
d1033 5
a1037 1
    xXF86DRIGetDrawableInfoReply rep;
a1048 1
    memset(&rep, 0, sizeof(rep));
a1053 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

d1144 1
a1144 1
    WriteToClient(client, sizeof(xXF86DRIGetDrawableInfoReply), (char *) &rep);
d1149 1
a1149 1
                      (char *) clipRects);
d1155 1
a1155 1
                      (char *) backClipRects);
d1168 5
a1172 1
    xXF86DRIGetDeviceInfoReply rep;
a1184 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

a1200 1
    rep.length = 0;
d1207 1
a1207 1
    WriteToClient(client, sizeof(xXF86DRIGetDeviceInfoReply), (char *) &rep);
d1209 1
a1209 1
        WriteToClient(client, rep.devPrivateSize, (char *) pDevPrivate);
d1232 1
a1232 1
    if (!LocalClient(client))
@


1.6
log
@Update to xserver 1.11.2
@
text
@d62 1
a62 1
typedef EphyrDRIWindowPrivRec* EphyrDRIWindowPrivPtr;
d65 5
a69 5
    CreateWindowProcPtr CreateWindow ;
    DestroyWindowProcPtr DestroyWindow ;
    MoveWindowProcPtr MoveWindow ;
    PositionWindowProcPtr PositionWindow ;
    ClipNotifyProcPtr ClipNotify ;
d71 1
a71 1
typedef EphyrDRIScreenPrivRec* EphyrDRIScreenPrivPtr;
d75 13
a87 18


static Bool ephyrDRIScreenInit (ScreenPtr a_screen) ;
static Bool ephyrDRICreateWindow (WindowPtr a_win) ;
static Bool ephyrDRIDestroyWindow (WindowPtr a_win) ;
static void ephyrDRIMoveWindow (WindowPtr a_win,
                                int a_x, int a_y,
                                WindowPtr a_siblings,
                                VTKind a_kind);
static Bool ephyrDRIPositionWindow (WindowPtr a_win,
                                    int x, int y) ;
static void ephyrDRIClipNotify (WindowPtr a_win,
                                int a_x, int a_y) ;

static Bool EphyrMirrorHostVisuals (ScreenPtr a_screen) ;
static Bool destroyHostPeerWindow (const WindowPtr a_win) ;
static Bool findWindowPairFromLocal (WindowPtr a_local,
                                     EphyrWindowPair **a_pair);
d92 1
d95 1
d104 1
a104 1
ephyrDRIScreenInit (ScreenPtr a_screen)
d106 2
a107 2
    Bool is_ok=FALSE ;
    EphyrDRIScreenPrivPtr screen_priv=NULL ;
d109 1
a109 1
    EPHYR_RETURN_VAL_IF_FAIL (a_screen, FALSE) ;
d111 2
a112 2
    screen_priv=GET_EPHYR_DRI_SCREEN_PRIV (a_screen) ;
    EPHYR_RETURN_VAL_IF_FAIL (screen_priv, FALSE) ;
d114 5
a118 5
    screen_priv->CreateWindow = a_screen->CreateWindow ;
    screen_priv->DestroyWindow = a_screen->DestroyWindow ;
    screen_priv->MoveWindow = a_screen->MoveWindow ;
    screen_priv->PositionWindow = a_screen->PositionWindow ;
    screen_priv->ClipNotify = a_screen->ClipNotify ;
d120 5
a124 5
    a_screen->CreateWindow = ephyrDRICreateWindow ;
    a_screen->DestroyWindow = ephyrDRIDestroyWindow ;
    a_screen->MoveWindow = ephyrDRIMoveWindow ;
    a_screen->PositionWindow = ephyrDRIPositionWindow ;
    a_screen->ClipNotify = ephyrDRIClipNotify ;
d126 1
a126 1
    is_ok = TRUE ;
d128 1
a128 1
    return is_ok ;
d132 1
a132 1
ephyrDRICreateWindow (WindowPtr a_win)
d134 15
a148 17
    Bool is_ok=FALSE ;
    ScreenPtr screen=NULL ;
    EphyrDRIScreenPrivPtr screen_priv =NULL;

    EPHYR_RETURN_VAL_IF_FAIL (a_win, FALSE) ;
    screen = a_win->drawable.pScreen ;
    EPHYR_RETURN_VAL_IF_FAIL (screen, FALSE) ;
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV (screen) ;
    EPHYR_RETURN_VAL_IF_FAIL (screen_priv
                              && screen_priv->CreateWindow,
                              FALSE) ;

    EPHYR_LOG ("enter. win:%p\n", a_win) ;

    screen->CreateWindow = screen_priv->CreateWindow ;
    is_ok = (*screen->CreateWindow) (a_win) ;
    screen->CreateWindow = ephyrDRICreateWindow ;
d151 1
a151 1
	dixSetPrivate(&a_win->devPrivates, ephyrDRIWindowKey, NULL);
d153 1
a153 1
    return is_ok ;
d157 1
a157 1
ephyrDRIDestroyWindow (WindowPtr a_win)
d159 9
a167 11
    Bool is_ok=FALSE ;
    ScreenPtr screen=NULL ;
    EphyrDRIScreenPrivPtr screen_priv =NULL;

    EPHYR_RETURN_VAL_IF_FAIL (a_win, FALSE) ;
    screen = a_win->drawable.pScreen ;
    EPHYR_RETURN_VAL_IF_FAIL (screen, FALSE) ;
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV (screen) ;
    EPHYR_RETURN_VAL_IF_FAIL (screen_priv
                              && screen_priv->DestroyWindow,
                              FALSE) ;
d169 1
a169 1
    screen->DestroyWindow = screen_priv->DestroyWindow ;
d171 1
a171 1
        is_ok = (*screen->DestroyWindow) (a_win) ;
d173 1
a173 1
    screen->DestroyWindow = ephyrDRIDestroyWindow ;
d176 2
a177 1
        EphyrDRIWindowPrivPtr win_priv=GET_EPHYR_DRI_WINDOW_PRIV (a_win) ;
d179 4
a182 4
            destroyHostPeerWindow (a_win) ;
            free(win_priv) ;
	    dixSetPrivate(&a_win->devPrivates, ephyrDRIWindowKey, NULL);
            EPHYR_LOG ("destroyed the remote peer window\n") ;
d185 1
a185 1
    return is_ok ;
d189 8
a196 10
ephyrDRIMoveWindow (WindowPtr a_win,
                    int a_x, int a_y,
                    WindowPtr a_siblings,
                    VTKind a_kind)
{
    Bool is_ok=FALSE ;
    ScreenPtr screen=NULL ;
    EphyrDRIScreenPrivPtr screen_priv =NULL;
    EphyrDRIWindowPrivPtr win_priv=NULL ;
    EphyrWindowPair *pair=NULL ;
d198 1
a198 1
    int x=0,y=0;/*coords relative to parent window*/
d200 1
a200 1
    EPHYR_RETURN_IF_FAIL (a_win) ;
d202 5
a206 6
    EPHYR_LOG ("enter\n") ;
    screen = a_win->drawable.pScreen ;
    EPHYR_RETURN_IF_FAIL (screen) ;
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV (screen) ;
    EPHYR_RETURN_IF_FAIL (screen_priv
                          && screen_priv->MoveWindow) ;
d208 1
a208 1
    screen->MoveWindow = screen_priv->MoveWindow ;
d210 1
a210 1
        (*screen->MoveWindow) (a_win, a_x, a_y, a_siblings, a_kind) ;
d212 1
a212 1
    screen->MoveWindow = ephyrDRIMoveWindow ;
d214 1
a214 1
    EPHYR_LOG ("window: %p\n", a_win) ;
d216 3
a218 3
        EPHYR_LOG ("cannot move root window\n") ;
        is_ok = TRUE ;
        goto out ;
d220 1
a220 1
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV (a_win) ;
d222 23
a244 23
        EPHYR_LOG ("not a DRI peered window\n") ;
        is_ok = TRUE ;
        goto out ;
    }
    if (!findWindowPairFromLocal (a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR ("failed to get window pair\n") ;
        goto out ;
    }
    /*compute position relative to parent window*/
    x = a_win->drawable.x - a_win->parent->drawable.x ;
    y = a_win->drawable.y - a_win->parent->drawable.y ;
    /*set the geometry to pass to hostx_set_window_geometry*/
    memset (&geo, 0, sizeof (geo)) ;
    geo.x = x ;
    geo.y = y ;
    geo.width = a_win->drawable.width ;
    geo.height = a_win->drawable.height ;
    hostx_set_window_geometry (pair->remote, &geo) ;
    is_ok = TRUE ;

out:
    EPHYR_LOG ("leave. is_ok:%d\n", is_ok) ;
    /*do cleanup here*/
d248 1
a248 2
ephyrDRIPositionWindow (WindowPtr a_win,
                        int a_x, int a_y)
d250 5
a254 5
    Bool is_ok=FALSE ;
    ScreenPtr screen=NULL ;
    EphyrDRIScreenPrivPtr screen_priv =NULL;
    EphyrDRIWindowPrivPtr win_priv=NULL ;
    EphyrWindowPair *pair=NULL ;
d257 1
a257 1
    EPHYR_RETURN_VAL_IF_FAIL (a_win, FALSE) ;
d259 5
a263 7
    EPHYR_LOG ("enter\n") ;
    screen = a_win->drawable.pScreen ;
    EPHYR_RETURN_VAL_IF_FAIL (screen, FALSE) ;
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV (screen) ;
    EPHYR_RETURN_VAL_IF_FAIL (screen_priv
                              && screen_priv->PositionWindow,
                              FALSE) ;
d265 1
a265 1
    screen->PositionWindow = screen_priv->PositionWindow ;
d267 1
a267 1
        (*screen->PositionWindow) (a_win, a_x, a_y) ;
d269 1
a269 1
    screen->PositionWindow = ephyrDRIPositionWindow ;
d271 2
a272 2
    EPHYR_LOG ("window: %p\n", a_win) ;
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV (a_win) ;
d274 21
a294 21
        EPHYR_LOG ("not a DRI peered window\n") ;
        is_ok = TRUE ;
        goto out ;
    }
    if (!findWindowPairFromLocal (a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR ("failed to get window pair\n") ;
        goto out ;
    }
    /*set the geometry to pass to hostx_set_window_geometry*/
    memset (&geo, 0, sizeof (geo)) ;
    geo.x = a_x ;
    geo.y = a_y ;
    geo.width = a_win->drawable.width ;
    geo.height = a_win->drawable.height ;
    hostx_set_window_geometry (pair->remote, &geo) ;
    is_ok = TRUE ;

out:
    EPHYR_LOG ("leave. is_ok:%d\n", is_ok) ;
    /*do cleanup here*/
    return is_ok ;
d298 1
a298 2
ephyrDRIClipNotify (WindowPtr a_win,
                    int a_x, int a_y)
d300 15
a314 15
    Bool is_ok=FALSE ;
    ScreenPtr screen=NULL ;
    EphyrDRIScreenPrivPtr screen_priv =NULL;
    EphyrDRIWindowPrivPtr win_priv=NULL ;
    EphyrWindowPair *pair=NULL ;
    EphyrRect *rects=NULL;
    int i=0 ;

    EPHYR_RETURN_IF_FAIL (a_win) ;

    EPHYR_LOG ("enter\n") ;
    screen = a_win->drawable.pScreen ;
    EPHYR_RETURN_IF_FAIL (screen) ;
    screen_priv = GET_EPHYR_DRI_SCREEN_PRIV (screen) ;
    EPHYR_RETURN_IF_FAIL (screen_priv && screen_priv->ClipNotify) ;
d316 1
a316 1
    screen->ClipNotify = screen_priv->ClipNotify ;
d318 1
a318 1
        (*screen->ClipNotify) (a_win, a_x, a_y) ;
d320 1
a320 1
    screen->ClipNotify = ephyrDRIClipNotify ;
d322 2
a323 2
    EPHYR_LOG ("window: %p\n", a_win) ;
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV (a_win) ;
d325 12
a336 14
        EPHYR_LOG ("not a DRI peered window\n") ;
        is_ok = TRUE ;
        goto out ;
    }
    if (!findWindowPairFromLocal (a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR ("failed to get window pair\n") ;
        goto out ;
    }
    rects = calloc(RegionNumRects (&a_win->clipList),
                     sizeof (EphyrRect)) ;
    for (i=0; i < RegionNumRects (&a_win->clipList); i++) {
        memmove (&rects[i],
                 &RegionRects (&a_win->clipList)[i],
                 sizeof (EphyrRect)) ;
d347 2
a348 8
                                (pair->remote,
                                 rects,
                                 RegionNumRects (&a_win->clipList)) ;
    is_ok = TRUE ;

out:
    free(rects) ;
    rects = NULL ;
d350 6
a355 2
    EPHYR_LOG ("leave. is_ok:%d\n", is_ok) ;
    /*do cleanup here*/
d368 13
a380 14
EphyrDuplicateVisual (unsigned int a_screen,
                      short a_depth,
                      short a_class,
                      short a_bits_per_rgb_values,
                      short a_colormap_entries,
                      unsigned int a_red_mask,
                      unsigned int a_green_mask,
                      unsigned int a_blue_mask,
                      unsigned int a_new_id)
{
    Bool is_ok = FALSE, found_visual=FALSE, found_depth=FALSE ;
    ScreenPtr screen=NULL ;
    VisualRec new_visual, *new_visuals=NULL ;
    int i=0 ;
d382 1
a382 1
    EPHYR_LOG ("enter\n") ; 
d384 1
a384 1
        EPHYR_LOG_ERROR ("bad screen number\n") ;
d387 1
a387 1
    memset (&new_visual, 0, sizeof (VisualRec)) ;
d389 3
a391 3
    /*get the screen pointed to by a_screen*/
    screen = screenInfo.screens[a_screen] ;
    EPHYR_RETURN_VAL_IF_FAIL (screen, FALSE) ;
d398 1
a398 1
    for (i=0; i < screen->numVisuals; i++) {
d400 10
a409 11
            screen->visuals[i].ColormapEntries == a_colormap_entries ) {
            /*copy the visual found*/
            memcpy (&new_visual, &screen->visuals[i], sizeof (new_visual)) ;
            new_visual.vid = a_new_id ;
            new_visual.class = a_class ;
            new_visual.redMask = a_red_mask ;
            new_visual.greenMask = a_green_mask ;
            new_visual.blueMask = a_blue_mask ;
            found_visual = TRUE ;
            EPHYR_LOG ("found a visual that matches visual id: %d\n",
                       a_new_id) ;
d414 2
a415 2
        EPHYR_LOG ("did not find any visual matching %d\n", a_new_id) ;
        goto out ;
d420 4
a423 7
    new_visuals = calloc(screen->numVisuals+1, sizeof (VisualRec)) ;
    memmove (new_visuals,
             screen->visuals,
             screen->numVisuals*sizeof (VisualRec)) ;
    memmove (&new_visuals[screen->numVisuals],
             &new_visual,
             sizeof (VisualRec)) ;
d430 5
a434 4
    for (i=0; i<screen->numDepths; i++) {
        VisualID *vids=NULL;
        DepthPtr cur_depth=NULL ;
        /*find the entry matching a_depth*/
d436 1
a436 1
            continue ;
d443 1
a443 1
                         (cur_depth->numVids+1)*sizeof (VisualID));
d445 2
a446 2
            EPHYR_LOG_ERROR ("failed to realloc numids\n") ;
            goto out ;
d448 1
a448 1
        vids[cur_depth->numVids] = a_new_id ;
d453 3
a455 3
        cur_depth->numVids++ ;
        cur_depth->vids = vids ;
        found_depth=TRUE;
d458 3
a460 3
        EPHYR_LOG_ERROR ("failed to update screen[%d]->allowedDepth\n",
                         a_screen) ;
        goto out ;
d465 9
a473 9
    free(screen->visuals) ;
    screen->visuals = new_visuals ;
    screen->numVisuals++ ;
    new_visuals = NULL ;

    is_ok = TRUE ;
out:
    free(new_visuals) ;
    new_visuals = NULL ;
d475 2
a476 2
    EPHYR_LOG ("leave\n") ; 
    return is_ok ;
d486 1
a486 1
EphyrMirrorHostVisuals (ScreenPtr a_screen)
d488 20
a507 21
    Bool is_ok=FALSE;
    EphyrHostVisualInfo  *visuals=NULL;
    int nb_visuals=0, i=0;

    EPHYR_LOG ("enter\n") ;
    if (!hostx_get_visuals_info (&visuals, &nb_visuals)) {
        EPHYR_LOG_ERROR ("failed to get host visuals\n") ;
        goto out ;
    }
    for (i=0; i<nb_visuals; i++) {
        if (!EphyrDuplicateVisual (a_screen->myNum,
                                   visuals[i].depth,
                                   visuals[i].class,
                                   visuals[i].bits_per_rgb,
                                   visuals[i].colormap_size,
                                   visuals[i].red_mask,
                                   visuals[i].green_mask,
                                   visuals[i].blue_mask,
                                   visuals[i].visualid)) {
            EPHYR_LOG_ERROR ("failed to duplicate host visual %d\n",
                             (int)visuals[i].visualid) ;
d511 3
a513 3
    is_ok = TRUE ;
out:
    EPHYR_LOG ("leave\n") ;
a516 1

d518 1
a518 1
ProcXF86DRIQueryVersion (register ClientPtr client)
d521 1
a521 1
    register int n;
d524 1
a524 1
    EPHYR_LOG ("enter\n") ;
d533 5
a537 5
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
	swapl(&rep.patchVersion, n);
d539 2
a540 2
    WriteToClient(client, sizeof(xXF86DRIQueryVersionReply), (char *)&rep);
    EPHYR_LOG ("leave\n") ;
d545 1
a545 1
ProcXF86DRIQueryDirectRenderingCapable (register ClientPtr client)
d547 1
a547 1
    xXF86DRIQueryDirectRenderingCapableReply	rep;
d549 1
a549 1
    register int n;
d553 1
a553 1
    EPHYR_LOG ("enter\n") ;
d555 2
a556 2
	client->errorValue = stuff->screen;
	return BadValue;
d563 1
a563 1
    if (!ephyrDRIQueryDirectRenderingCapable (stuff->screen, &isCapable)) {
d569 1
a569 1
	rep.isCapable = 0;
d572 2
a573 2
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
d576 3
a578 2
    WriteToClient(client, sizeof(xXF86DRIQueryDirectRenderingCapableReply), (char *)&rep);
    EPHYR_LOG ("leave\n") ;
d584 1
a584 1
ProcXF86DRIOpenConnection (register ClientPtr client)
d587 3
a589 2
    drm_handle_t			hSAREA;
    char*			busIdString = NULL;
d593 1
a593 1
    EPHYR_LOG ("enter\n") ;
d595 2
a596 2
	client->errorValue = stuff->screen;
	return BadValue;
d599 1
a599 3
    if (!ephyrDRIOpenConnection(stuff->screen,
                                &hSAREA,
                                &busIdString)) {
d607 5
a611 3
	rep.busIdStringLength = strlen(busIdString);
    rep.length = bytes_to_int32(SIZEOF(xXF86DRIOpenConnectionReply) - SIZEOF(xGenericReply) +
                  pad_to_int32(rep.busIdStringLength));
d613 1
a613 1
    rep.hSAREALow  = (CARD32)(hSAREA & 0xffffffff);
d615 1
a615 1
    rep.hSAREAHigh = (CARD32)(hSAREA >> 32);
d620 1
a620 1
    WriteToClient(client, sizeof(xXF86DRIOpenConnectionReply), (char *)&rep);
d624 1
a624 1
    EPHYR_LOG ("leave\n") ;
d629 1
a629 1
ProcXF86DRIAuthConnection  (register ClientPtr client)
d632 1
d636 1
a636 1
    EPHYR_LOG ("enter\n") ;
d638 2
a639 2
	client->errorValue = stuff->screen;
	return BadValue;
d647 2
a648 2
    if (!ephyrDRIAuthConnection (stuff->screen, stuff->magic)) {
        ErrorF("Failed to authenticate %lu\n", (unsigned long)stuff->magic);
d651 2
a652 2
    WriteToClient(client, sizeof(xXF86DRIAuthConnectionReply), (char *)&rep);
    EPHYR_LOG ("leave\n") ;
d657 1
a657 1
ProcXF86DRICloseConnection (register ClientPtr client)
d661 1
a661 1
    EPHYR_LOG ("enter\n") ;
d668 2
a669 2
    DRICloseConnection( screenInfo.screens[stuff->screen]);
    */
d671 1
a671 1
    EPHYR_LOG ("leave\n") ;
d676 1
a676 1
ProcXF86DRIGetClientDriverName (register ClientPtr client)
d678 3
a680 2
    xXF86DRIGetClientDriverNameReply	rep;
    char* clientDriverName;
d684 1
a684 1
    EPHYR_LOG ("enter\n") ;
d686 2
a687 2
	client->errorValue = stuff->screen;
	return BadValue;
d690 5
a694 5
    ephyrDRIGetClientDriverName (stuff->screen,
                                 (int *)&rep.ddxDriverMajorVersion,
                                 (int *)&rep.ddxDriverMinorVersion,
                                 (int *)&rep.ddxDriverPatchVersion,
                                 &clientDriverName);
d700 1
a700 1
	rep.clientDriverNameLength = strlen(clientDriverName);
d702 2
a703 2
			SIZEOF(xGenericReply) +
			pad_to_int32(rep.clientDriverNameLength));
d705 2
a706 2
    WriteToClient(client, 
	sizeof(xXF86DRIGetClientDriverNameReply), (char *)&rep);
d708 2
a709 4
	WriteToClient(client, 
                      rep.clientDriverNameLength, 
                      clientDriverName);
    EPHYR_LOG ("leave\n") ;
d714 1
a714 1
ProcXF86DRICreateContext (register ClientPtr client)
d716 1
a716 1
    xXF86DRICreateContextReply	rep;
d719 3
a721 2
    int i=0;
    unsigned long context_id=0;
d725 1
a725 1
    EPHYR_LOG ("enter\n") ;
d727 2
a728 2
	client->errorValue = stuff->screen;
	return BadValue;
d740 2
a741 2
	if (visual->vid == stuff->visual)
	    break;
d743 2
a744 2
	/* No visual found */
	return BadValue;
d747 5
a751 5
    context_id = stuff->context ;
    if (!ephyrDRICreateContext (stuff->screen,
                                stuff->visual,
                                &context_id,
                                (drm_context_t *)&rep.hHWContext)) {
d755 2
a756 2
    WriteToClient(client, sizeof(xXF86DRICreateContextReply), (char *)&rep);
    EPHYR_LOG ("leave\n") ;
d761 1
a761 1
ProcXF86DRIDestroyContext (register ClientPtr client)
d765 1
a765 1
    EPHYR_LOG ("enter\n") ;
d772 3
a774 3
   if (!ephyrDRIDestroyContext (stuff->screen, stuff->context)) {
       return BadValue;
   }
d776 1
a776 1
    EPHYR_LOG ("leave\n") ;
d781 1
a781 2
getWindowVisual (const WindowPtr a_win,
                 VisualPtr *a_visual)
d783 5
a787 5
    int i=0, visual_id=0 ;
    EPHYR_RETURN_VAL_IF_FAIL (a_win
                              && a_win->drawable.pScreen
                              && a_win->drawable.pScreen->visuals,
                              FALSE) ;
d789 2
a790 2
    visual_id = wVisual (a_win) ;
    for (i=0; i < a_win->drawable.pScreen->numVisuals; i++) {
d792 2
a793 2
            *a_visual = &a_win->drawable.pScreen->visuals[i] ;
            return TRUE ;
d796 1
a796 1
    return FALSE ;
a798 1

d800 1
a800 1
static EphyrWindowPair window_pairs[NUM_WINDOW_PAIRS] ;
d803 1
a803 2
appendWindowPairToList (WindowPtr a_local,
                        int a_remote)
d805 1
a805 1
    int i=0 ;
d807 1
a807 1
    EPHYR_RETURN_VAL_IF_FAIL (a_local, FALSE) ;
d809 1
a809 1
    EPHYR_LOG ("(local,remote):(%p, %d)\n", a_local, a_remote) ;
d811 1
a811 1
    for (i=0; i < NUM_WINDOW_PAIRS; i++) {
d813 3
a815 3
            window_pairs[i].local = a_local ;
            window_pairs[i].remote = a_remote ;
            return TRUE ;
d818 1
a818 1
    return FALSE ;
d822 1
a822 2
findWindowPairFromLocal (WindowPtr a_local,
                         EphyrWindowPair **a_pair)
d824 1
a824 1
    int i=0 ;
d826 1
a826 1
    EPHYR_RETURN_VAL_IF_FAIL (a_pair && a_local, FALSE) ;
d828 1
a828 1
    for (i=0; i < NUM_WINDOW_PAIRS; i++) {
d830 3
a832 5
            *a_pair = &window_pairs[i] ;
            EPHYR_LOG ("found (%p, %d)\n",
                       (*a_pair)->local,
                       (*a_pair)->remote) ;
            return TRUE ;
d835 1
a835 1
    return FALSE ;
d839 1
a839 2
findWindowPairFromRemote (int a_remote,
                          EphyrWindowPair **a_pair)
d841 1
a841 1
    int i=0 ;
d843 1
a843 1
    EPHYR_RETURN_VAL_IF_FAIL (a_pair, FALSE) ;
d845 1
a845 1
    for (i=0; i < NUM_WINDOW_PAIRS; i++) {
d847 3
a849 5
            *a_pair = &window_pairs[i] ;
            EPHYR_LOG ("found (%p, %d)\n",
                       (*a_pair)->local,
                       (*a_pair)->remote) ;
            return TRUE ;
d852 1
a852 1
    return FALSE ;
d856 1
a856 2
createHostPeerWindow (const WindowPtr a_win,
                      int *a_peer_win)
d858 11
a868 12
    Bool is_ok=FALSE ;
    VisualPtr visual=NULL;
    EphyrBox geo ;

    EPHYR_RETURN_VAL_IF_FAIL (a_win && a_peer_win, FALSE) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_win->drawable.pScreen,
                              FALSE) ;

    EPHYR_LOG ("enter. a_win '%p'\n", a_win) ;
    if (!getWindowVisual (a_win, &visual)) {
        EPHYR_LOG_ERROR ("failed to get window visual\n") ;
        goto out ;
d871 16
a886 2
        EPHYR_LOG_ERROR ("failed to create visual\n") ;
        goto out ;
d888 4
a891 18
    memset (&geo, 0, sizeof (geo)) ;
    geo.x = a_win->drawable.x ;
    geo.y = a_win->drawable.y ;
    geo.width = a_win->drawable.width ;
    geo.height = a_win->drawable.height ;
    if (!hostx_create_window (a_win->drawable.pScreen->myNum,
                              &geo, visual->vid, a_peer_win)) {
        EPHYR_LOG_ERROR ("failed to create host peer window\n") ;
        goto out ;
    }
    if (!appendWindowPairToList (a_win, *a_peer_win)) {
        EPHYR_LOG_ERROR ("failed to append window to pair list\n") ;
        goto out ;
    }
    is_ok = TRUE ;
out:
    EPHYR_LOG ("leave:remote win%d\n", *a_peer_win) ;
    return is_ok ;
d895 1
a895 1
destroyHostPeerWindow (const WindowPtr a_win)
d897 4
a900 3
    Bool is_ok = FALSE ;
    EphyrWindowPair *pair=NULL ;
    EPHYR_RETURN_VAL_IF_FAIL (a_win, FALSE) ;
d902 1
a902 1
    EPHYR_LOG ("enter\n") ;
d904 2
a905 2
    if (!findWindowPairFromLocal (a_win, &pair) || !pair) {
        EPHYR_LOG_ERROR ("failed to find peer to local window\n") ;
d908 2
a909 2
    hostx_destroy_window (pair->remote) ;
    is_ok = TRUE ;
d911 2
a912 2
out:
    EPHYR_LOG ("leave\n") ;
d917 1
a917 1
ProcXF86DRICreateDrawable (ClientPtr client)
d919 7
a925 6
    xXF86DRICreateDrawableReply	rep;
    DrawablePtr drawable=NULL;
    WindowPtr window=NULL ;
    EphyrWindowPair *pair=NULL ;
    EphyrDRIWindowPrivPtr win_priv=NULL;
    int rc=0, remote_win=0;
d929 1
a929 1
    EPHYR_LOG ("enter\n") ;
d939 2
a940 2
    rc = dixLookupDrawable (&drawable, stuff->drawable, client, 0,
                            DixReadAccess);
d944 2
a945 2
        EPHYR_LOG_ERROR ("non drawable windows are not yet supported\n") ;
        return BadImplementation ;
d947 16
a962 15
    EPHYR_LOG ("lookedup drawable %p\n", drawable) ;
    window = (WindowPtr)drawable;
    if (findWindowPairFromLocal (window, &pair) && pair) {
        remote_win = pair->remote ;
        EPHYR_LOG ("found window '%p' paire with remote '%d'\n",
                   window, remote_win) ;
    } else if (!createHostPeerWindow (window, &remote_win)) {
        EPHYR_LOG_ERROR ("failed to create host peer window\n") ;
        return BadAlloc ;
    }

    if (!ephyrDRICreateDrawable (stuff->screen,
                                 remote_win,
                                 (drm_drawable_t *)&rep.hHWDrawable)) {
        EPHYR_LOG_ERROR ("failed to create dri drawable\n") ;
d966 1
a966 1
    win_priv = GET_EPHYR_DRI_WINDOW_PRIV (window) ;
d968 1
a968 1
        win_priv = calloc(1, sizeof (EphyrDRIWindowPrivRec)) ;
d970 2
a971 2
            EPHYR_LOG_ERROR ("failed to allocate window private\n") ;
            return BadAlloc ;
d973 2
a974 3
	dixSetPrivate(&window->devPrivates, ephyrDRIWindowKey, win_priv);
        EPHYR_LOG ("paired window '%p' with remote '%d'\n",
                   window, remote_win) ;
d977 2
a978 2
    WriteToClient(client, sizeof(xXF86DRICreateDrawableReply), (char *)&rep);
    EPHYR_LOG ("leave\n") ;
d983 1
a983 1
ProcXF86DRIDestroyDrawable (register ClientPtr client)
d985 5
a989 4
    DrawablePtr drawable=NULL;
    WindowPtr window=NULL;
    EphyrWindowPair *pair=NULL;
    int rc=0;
d993 1
a993 1
    EPHYR_LOG ("enter\n") ;
d1000 1
a1000 4
                           stuff->drawable,
                           client,
                           0,
                           DixReadAccess);
d1004 2
a1005 2
        EPHYR_LOG_ERROR ("non drawable windows are not yet supported\n") ;
        return BadImplementation ;
d1007 3
a1009 3
    window = (WindowPtr)drawable;
    if (!findWindowPairFromLocal (window, &pair) && pair) {
        EPHYR_LOG_ERROR ("failed to find pair window\n") ;
d1013 2
a1014 2
                                 pair->remote/*drawable in host x*/)) {
        EPHYR_LOG_ERROR ("failed to destroy dri drawable\n") ;
d1017 2
a1018 2
    pair->local=NULL ;
    pair->remote=0;
d1020 1
a1020 1
    EPHYR_LOG ("leave\n") ;
d1025 1
a1025 1
ProcXF86DRIGetDrawableInfo (register ClientPtr client)
d1029 6
a1034 5
    WindowPtr window=NULL;
    EphyrWindowPair *pair=NULL;
    int X=0, Y=0, W=0, H=0, backX=0, backY=0, rc=0, i=0;
    drm_clip_rect_t *clipRects=NULL;
    drm_clip_rect_t *backClipRects=NULL;
d1038 2
a1039 2
    EPHYR_LOG ("enter\n") ;
    memset (&rep, 0, sizeof (rep)) ;
d1052 1
a1052 1
        EPHYR_LOG_ERROR ("could not get drawable\n") ;
d1057 2
a1058 2
        EPHYR_LOG_ERROR ("non windows type drawables are not yes supported\n") ;
        return BadImplementation ;
d1060 29
a1088 29
    window = (WindowPtr)drawable ;
    memset (&pair, 0, sizeof (pair)) ;
    if (!findWindowPairFromLocal (window, &pair) || !pair) {
        EPHYR_LOG_ERROR ("failed to find remote peer drawable\n") ;
        return BadMatch ;
    }
    EPHYR_LOG ("clip list of xephyr gl drawable:\n") ;
    for (i=0; i < RegionNumRects (&window->clipList); i++) {
        EPHYR_LOG ("x1:%d, y1:%d, x2:%d, y2:%d\n",
                   RegionRects (&window->clipList)[i].x1,
                   RegionRects (&window->clipList)[i].y1,
                   RegionRects (&window->clipList)[i].x2,
                   RegionRects (&window->clipList)[i].y2) ;
    }

    if (!ephyrDRIGetDrawableInfo (stuff->screen,
                                  pair->remote/*the drawable in hostx*/,
                                  (unsigned int*)&rep.drawableTableIndex,
                                  (unsigned int*)&rep.drawableTableStamp,
                                  (int*)&X,
                                  (int*)&Y,
                                  (int*)&W,
                                  (int*)&H,
                                  (int*)&rep.numClipRects,
                                  &clipRects,
                                  &backX,
                                  &backY,
                                  (int*)&rep.numBackClipRects,
                                  &backClipRects)) {
d1091 2
a1092 2
    EPHYR_LOG ("num clip rects:%d, num back clip rects:%d\n",
               (int)rep.numClipRects, (int)rep.numBackClipRects) ;
d1098 1
a1098 2
    rep.length = (SIZEOF(xXF86DRIGetDrawableInfoReply) -
                  SIZEOF(xGenericReply));
a1102 1

d1106 3
a1108 2
            int i=0;
            EPHYR_LOG ("clip list of host gl drawable:\n") ;
d1110 10
a1119 10
                clipRects[i].x1 = max (clipRects[i].x1, 0);
                clipRects[i].y1 = max (clipRects[i].y1, 0);
                clipRects[i].x2 = min (clipRects[i].x2,
                                       pScreen->width + clipRects[i].x1) ;
                clipRects[i].y2 = min (clipRects[i].y2,
                                       pScreen->width + clipRects[i].y1) ;

                EPHYR_LOG ("x1:%d, y1:%d, x2:%d, y2:%d\n",
                           clipRects[i].x1, clipRects[i].y1,
                           clipRects[i].x2, clipRects[i].y2) ;
d1121 2
a1122 1
        } else {
d1125 3
a1127 2
    } else {
        EPHYR_LOG ("got zero host gl drawable clipping rects\n") ;
d1130 2
a1131 2
    backClipRects = clipRects ;
    rep.numBackClipRects = rep.numClipRects ;
d1134 2
a1135 2
    EPHYR_LOG ("num host clip rects:%d\n", (int)rep.numClipRects) ;
    EPHYR_LOG ("num host back clip rects:%d\n", (int)rep.numBackClipRects) ;
d1139 1
a1139 1
    WriteToClient(client, sizeof(xXF86DRIGetDrawableInfoReply), (char *)&rep);
d1144 1
a1144 1
                      (char *)clipRects);
d1150 1
a1150 1
                      (char *)backClipRects);
d1153 1
a1153 1
    clipRects = NULL ;
d1155 1
a1155 1
    EPHYR_LOG ("leave\n") ;
d1161 1
a1161 1
ProcXF86DRIGetDeviceInfo (register ClientPtr client)
d1163 1
a1163 1
    xXF86DRIGetDeviceInfoReply	rep;
d1166 1
d1170 1
a1170 1
    EPHYR_LOG ("enter\n") ;
d1180 6
a1185 7
    if (!ephyrDRIGetDeviceInfo (stuff->screen,
                &hFrameBuffer,
                (int*)&rep.framebufferOrigin,
                (int*)&rep.framebufferSize,
                (int*)&rep.framebufferStride,
                (int*)&rep.devPrivateSize,
                &pDevPrivate)) {
d1189 1
a1189 1
    rep.hFrameBufferLow  = (CARD32)(hFrameBuffer & 0xffffffff);
d1191 1
a1191 1
    rep.hFrameBufferHigh = (CARD32)(hFrameBuffer >> 32);
d1199 2
a1200 2
                SIZEOF(xGenericReply) +
                pad_to_int32(rep.devPrivateSize));
d1203 1
a1203 1
    WriteToClient(client, sizeof(xXF86DRIGetDeviceInfoReply), (char *)&rep);
d1205 1
a1205 1
        WriteToClient(client, rep.devPrivateSize, (char *)pDevPrivate);
d1207 1
a1207 1
    EPHYR_LOG ("leave\n") ;
d1212 1
a1212 1
ProcXF86DRIDispatch (register ClientPtr	client)
d1215 1
a1215 1
    EPHYR_LOG ("enter\n") ;
d1217 9
a1225 10
    switch (stuff->data)
    {
        case X_XF86DRIQueryVersion: {
                EPHYR_LOG ("leave\n") ;
                return ProcXF86DRIQueryVersion(client);
        }
        case X_XF86DRIQueryDirectRenderingCapable: {
                EPHYR_LOG ("leave\n") ;
                return ProcXF86DRIQueryDirectRenderingCapable(client);
        }
d1231 46
a1276 47
    switch (stuff->data)
    {
        case X_XF86DRIOpenConnection: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIOpenConnection(client);
        }
        case X_XF86DRICloseConnection: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRICloseConnection(client);
        }
        case X_XF86DRIGetClientDriverName: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIGetClientDriverName(client);
        }
        case X_XF86DRICreateContext: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRICreateContext(client);
        }
        case X_XF86DRIDestroyContext: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIDestroyContext(client);
        }
        case X_XF86DRICreateDrawable: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRICreateDrawable(client);
        }
        case X_XF86DRIDestroyDrawable: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIDestroyDrawable(client);
        }
        case X_XF86DRIGetDrawableInfo: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIGetDrawableInfo(client);
        }
        case X_XF86DRIGetDeviceInfo: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIGetDeviceInfo(client);
        }
        case X_XF86DRIAuthConnection: {
            EPHYR_LOG ("leave\n") ;
            return ProcXF86DRIAuthConnection(client);
        }
            /* {Open,Close}FullScreen are deprecated now */
        default: {
            EPHYR_LOG ("leave\n") ;
            return BadRequest;
        }
d1281 1
a1281 1
SProcXF86DRIQueryVersion (register ClientPtr	client)
a1282 1
    register int n;
d1284 1
a1284 1
    swaps(&stuff->length, n);
d1289 1
a1289 1
SProcXF86DRIQueryDirectRenderingCapable (register ClientPtr client)
a1290 1
    register int n;
d1292 2
a1293 2
    swaps(&stuff->length, n);
    swapl(&stuff->screen, n);
d1298 1
a1298 1
SProcXF86DRIDispatch (register ClientPtr client)
d1302 1
a1302 1
    EPHYR_LOG ("enter\n") ;
d1307 13
a1319 14
    switch (stuff->data)
    {
        case X_XF86DRIQueryVersion: {
            EPHYR_LOG ("leave\n") ;
            return SProcXF86DRIQueryVersion(client);
        }
        case X_XF86DRIQueryDirectRenderingCapable: {
            EPHYR_LOG ("leave\n") ;
            return SProcXF86DRIQueryDirectRenderingCapable(client);
        }
        default: {
            EPHYR_LOG ("leave\n") ;
            return DRIErrorBase + XF86DRIClientNotLocal;
        }
d1324 1
a1324 1
ephyrDRIExtensionInit (ScreenPtr a_screen)
d1326 8
a1333 13
    Bool is_ok=FALSE ;
    ExtensionEntry* extEntry=NULL;
    EphyrDRIScreenPrivPtr screen_priv=NULL ;

    EPHYR_LOG ("enter\n") ;
    if (!hostx_has_dri ()) {
        EPHYR_LOG ("host does not have DRI extension\n") ;
        goto out ;
    }
    EPHYR_LOG ("host X does have DRI extension\n") ;
    if (!hostx_has_xshape ()) {
        EPHYR_LOG ("host does not have XShape extension\n") ;
        goto out ;
d1335 6
a1340 1
    EPHYR_LOG ("host X does have XShape extension\n") ;
d1343 1
a1343 1
    EventType = CreateNewResourceType (XF86DRIFreeEvents, "DRIEvents");
d1345 2
a1346 2
        EPHYR_LOG_ERROR ("failed to register DRI event resource type\n") ;
        goto out ;
d1351 11
a1361 11
				 XF86DRINumberEvents,
				 XF86DRINumberErrors,
				 ProcXF86DRIDispatch,
				 SProcXF86DRIDispatch,
				 NULL,
				 StandardMinorOpcode))) {
	DRIReqCode = (unsigned char)extEntry->base;
	DRIErrorBase = extEntry->errorBase;
    } else {
        EPHYR_LOG_ERROR ("failed to register DRI extension\n") ;
        goto out ;
d1364 1
a1364 1
        goto out ;
d1366 2
a1367 2
        goto out ;
    screen_priv = calloc(1, sizeof (EphyrDRIScreenPrivRec)) ;
d1369 2
a1370 2
        EPHYR_LOG_ERROR ("failed to allocate screen_priv\n") ;
        goto out ;
d1374 9
a1382 9
    if (!ephyrDRIScreenInit (a_screen)) {
        EPHYR_LOG_ERROR ("ephyrDRIScreenInit() failed\n") ;
        goto out ;
    }
    EphyrMirrorHostVisuals (a_screen) ;
    is_ok=TRUE ;
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
@


1.5
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d75 1
a75 17
static DISPATCH_PROC(ProcXF86DRIQueryVersion);
static DISPATCH_PROC(ProcXF86DRIQueryDirectRenderingCapable);
static DISPATCH_PROC(ProcXF86DRIOpenConnection);
static DISPATCH_PROC(ProcXF86DRICloseConnection);
static DISPATCH_PROC(ProcXF86DRIGetClientDriverName);
static DISPATCH_PROC(ProcXF86DRICreateContext);
static DISPATCH_PROC(ProcXF86DRIDestroyContext);
static DISPATCH_PROC(ProcXF86DRICreateDrawable);
static DISPATCH_PROC(ProcXF86DRIDestroyDrawable);
static DISPATCH_PROC(ProcXF86DRIGetDrawableInfo);
static DISPATCH_PROC(ProcXF86DRIGetDeviceInfo);
static DISPATCH_PROC(ProcXF86DRIDispatch);
static DISPATCH_PROC(ProcXF86DRIAuthConnection);

static DISPATCH_PROC(SProcXF86DRIQueryVersion);
static DISPATCH_PROC(SProcXF86DRIQueryDirectRenderingCapable);
static DISPATCH_PROC(SProcXF86DRIDispatch);
a105 59

Bool
ephyrDRIExtensionInit (ScreenPtr a_screen)
{
    Bool is_ok=FALSE ;
    ExtensionEntry* extEntry=NULL;
    EphyrDRIScreenPrivPtr screen_priv=NULL ;

    EPHYR_LOG ("enter\n") ;
    if (!hostx_has_dri ()) {
        EPHYR_LOG ("host does not have DRI extension\n") ;
        goto out ;
    }
    EPHYR_LOG ("host X does have DRI extension\n") ;
    if (!hostx_has_xshape ()) {
        EPHYR_LOG ("host does not have XShape extension\n") ;
        goto out ;
    }
    EPHYR_LOG ("host X does have XShape extension\n") ;

#ifdef XF86DRI_EVENTS
    EventType = CreateNewResourceType (XF86DRIFreeEvents, "DRIEvents");
    if (!EventType) {
        EPHYR_LOG_ERROR ("failed to register DRI event resource type\n") ;
        goto out ;
    }
#endif

    if ((extEntry = AddExtension(XF86DRINAME,
				 XF86DRINumberEvents,
				 XF86DRINumberErrors,
				 ProcXF86DRIDispatch,
				 SProcXF86DRIDispatch,
				 NULL,
				 StandardMinorOpcode))) {
	DRIReqCode = (unsigned char)extEntry->base;
	DRIErrorBase = extEntry->errorBase;
    } else {
        EPHYR_LOG_ERROR ("failed to register DRI extension\n") ;
        goto out ;
    }
    screen_priv = calloc(1, sizeof (EphyrDRIScreenPrivRec)) ;
    if (!screen_priv) {
        EPHYR_LOG_ERROR ("failed to allocate screen_priv\n") ;
        goto out ;
    }
    dixSetPrivate(&a_screen->devPrivates, ephyrDRIScreenKey, screen_priv);

    if (!ephyrDRIScreenInit (a_screen)) {
        EPHYR_LOG_ERROR ("ephyrDRIScreenInit() failed\n") ;
        goto out ;
    }
    EphyrMirrorHostVisuals (a_screen) ;
    is_ok=TRUE ;
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
}

d1355 62
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d476 1
a476 1
    if (a_screen > screenInfo.numScreens) {
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d112 4
a115 4
static int ephyrDRIWindowKeyIndex;
static DevPrivateKey ephyrDRIWindowKey = &ephyrDRIWindowKeyIndex;
static int ephyrDRIScreenKeyIndex;
static DevPrivateKey ephyrDRIScreenKey = &ephyrDRIScreenKeyIndex;
d163 1
a163 1
    screen_priv = xcalloc (1, sizeof (EphyrDRIScreenPrivRec)) ;
d261 1
a261 1
            xfree (win_priv) ;
d421 1
a421 1
    rects = xcalloc (REGION_NUM_RECTS (&a_win->clipList),
d423 1
a423 1
    for (i=0; i < REGION_NUM_RECTS (&a_win->clipList); i++) {
d425 1
a425 1
                 &REGION_RECTS (&a_win->clipList)[i],
d439 1
a439 1
                                 REGION_NUM_RECTS (&a_win->clipList)) ;
d443 1
a443 1
    xfree (rects) ;
d514 1
a514 1
    new_visuals = xcalloc (screen->numVisuals+1, sizeof (VisualRec)) ;
d538 1
a538 1
        vids = xrealloc (cur_depth->vids,
d561 1
a561 1
    xfree (screen->visuals) ;
d568 1
a568 1
    xfree (new_visuals) ;
d639 1
a639 1
    return (client->noClientException);
d677 1
a677 1
    return (client->noClientException);
d685 1
a685 1
    char*			busIdString;
d719 1
d721 1
a721 1
    return (client->noClientException);
d748 1
a748 1
    return (client->noClientException);
d767 1
a767 1
    return (client->noClientException);
d806 1
a806 1
    return (client->noClientException);
d852 1
a852 1
    return (client->noClientException);
d872 1
a872 1
    return (client->noClientException);
d1071 1
a1071 1
        win_priv = xcalloc (1, sizeof (EphyrDRIWindowPrivRec)) ;
d1083 1
a1083 1
    return (client->noClientException);
d1127 1
a1127 1
    return (client->noClientException);
d1172 1
a1172 1
    for (i=0; i < REGION_NUM_RECTS (&window->clipList); i++) {
d1174 4
a1177 4
                   REGION_RECTS (&window->clipList)[i].x1,
                   REGION_RECTS (&window->clipList)[i].y1,
                   REGION_RECTS (&window->clipList)[i].x2,
                   REGION_RECTS (&window->clipList)[i].y2) ;
d1256 1
a1256 1
    xfree(clipRects);
d1261 1
a1261 1
    return (client->noClientException);
d1312 1
a1312 1
    return (client->noClientException);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a36 2
#define NEED_REPLIES
#define NEED_EVENTS
d41 1
a41 1
#include <X11/dri/xf86dristr.h>
d57 1
a57 1

d143 5
a147 1
    EventType = CreateNewResourceType (XF86DRIFreeEvents);
d443 3
a445 4
    if (rects) {
        xfree (rects) ;
        rects = NULL ;
    }
d568 3
a570 4
    if (new_visuals) {
        xfree (new_visuals) ;
        new_visuals = NULL ;
    }
d620 1
a623 1
    REQUEST_SIZE_MATCH(xXF86DRIQueryVersionReq);
d627 3
a629 3
    rep.majorVersion = XF86DRI_MAJOR_VERSION;
    rep.minorVersion = XF86DRI_MINOR_VERSION;
    rep.patchVersion = XF86DRI_PATCH_VERSION;
d648 2
a651 2
    REQUEST(xXF86DRIQueryDirectRenderingCapableReq);
    REQUEST_SIZE_MATCH(xXF86DRIQueryDirectRenderingCapableReq);
d686 2
a689 2
    REQUEST(xXF86DRIOpenConnectionReq);
    REQUEST_SIZE_MATCH(xXF86DRIOpenConnectionReq);
d706 2
a707 2
    rep.length = (SIZEOF(xXF86DRIOpenConnectionReply) - SIZEOF(xGenericReply) +
                  ((rep.busIdStringLength + 3) & ~3)) >> 2;
d727 2
a730 2
    REQUEST(xXF86DRIAuthConnectionReq);
    REQUEST_SIZE_MATCH(xXF86DRIAuthConnectionReq);
a752 1
    EPHYR_LOG ("enter\n") ;
d755 1
d774 2
a777 2
    REQUEST(xXF86DRIGetClientDriverNameReq);
    REQUEST_SIZE_MATCH(xXF86DRIGetClientDriverNameReq);
d794 1
a794 1
    rep.length = (SIZEOF(xXF86DRIGetClientDriverNameReply) - 
d796 1
a796 1
			((rep.clientDriverNameLength + 3) & ~3)) >> 2;
d816 2
a819 2
    REQUEST(xXF86DRICreateContextReq);
    REQUEST_SIZE_MATCH(xXF86DRICreateContextReq);
d857 2
a860 2
    REQUEST(xXF86DRIDestroyContextReq);
    REQUEST_SIZE_MATCH(xXF86DRIDestroyContextReq);
d1029 2
a1032 2
    REQUEST(xXF86DRICreateDrawableReq);
    REQUEST_SIZE_MATCH(xXF86DRICreateDrawableReq);
a1087 1
    REQUEST(xXF86DRIDestroyDrawableReq);
d1091 2
a1093 1
    int rc=0;
d1139 2
a1143 2
    REQUEST(xXF86DRIGetDrawableInfoReq);
    REQUEST_SIZE_MATCH(xXF86DRIGetDrawableInfoReq);
d1240 1
a1240 1
    rep.length = ((rep.length + 3) & ~3) >> 2;
d1255 3
a1257 4
    if (clipRects) {
        xfree(clipRects);
        clipRects = NULL ;
    }
d1269 2
a1272 2
    REQUEST(xXF86DRIGetDeviceInfoReq);
    REQUEST_SIZE_MATCH(xXF86DRIGetDeviceInfoReq);
d1301 1
a1301 1
        rep.length = (SIZEOF(xXF86DRIGetDeviceInfoReply) - 
d1303 1
a1303 1
                ((rep.devPrivateSize + 3) & ~3)) >> 2;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a34 2
#ifdef XEPHYR_DRI

a94 2
static void XF86DRIResetProc(ExtensionEntry* extEntry);

d114 4
a117 2
static DevPrivateKey ephyrDRIWindowKey = &ephyrDRIWindowKey;
static DevPrivateKey ephyrDRIScreenKey = &ephyrDRIScreenKey;
d153 1
a153 1
				 XF86DRIResetProc,
d222 1
a222 2
    EPHYR_LOG ("enter. win:%#x\n",
               (unsigned int)a_win) ;
d296 1
a296 1
    EPHYR_LOG ("window: %#x\n", (unsigned int)a_win) ;
d356 1
a356 1
    EPHYR_LOG ("window: %#x\n", (unsigned int)a_win) ;
d408 1
a408 1
    EPHYR_LOG ("window: %#x\n", (unsigned int)a_win) ;
a614 8
/*ARGSUSED*/
static void
XF86DRIResetProc (
    ExtensionEntry* extEntry
)
{
}

d906 1
a906 1
    EPHYR_LOG ("(local,remote):(%#x, %d)\n", (unsigned int)a_local, a_remote) ;
d929 2
a930 2
            EPHYR_LOG ("found (%#x, %d)\n",
                       (unsigned int)(*a_pair)->local,
d970 1
a970 1
    EPHYR_LOG ("enter. a_win '%#x'\n", (unsigned int)a_win) ;
d1050 1
a1050 1
    EPHYR_LOG ("lookedup drawable %#x\n", (unsigned int)drawable) ;
d1054 2
a1055 2
        EPHYR_LOG ("found window '%#x' paire with remote '%d'\n",
                   (unsigned int)window, remote_win) ;
d1076 2
a1077 2
        EPHYR_LOG ("paired window '%#x' with remote '%d'\n",
                   (unsigned int)window, remote_win) ;
a1430 2

#endif /*XEPHYR_DRI*/
@

