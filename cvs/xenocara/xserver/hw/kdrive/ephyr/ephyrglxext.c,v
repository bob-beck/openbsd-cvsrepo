head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 *
 * Copyright © 2007 OpenedHand Ltd
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */
#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include <xcb/glx.h>
#include "extnsionst.h"
#include "ephyrglxext.h"
#include "ephyrhostglx.h"
#define _HAVE_XALLOC_DECLS
#include "ephyrlog.h"
#include <GL/glxproto.h>
#include "glx/glxserver.h"
#include "glx/indirect_table.h"
#include "glx/indirect_util.h"
#include "glx/unpack.h"
#include "hostx.h"

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

int ephyrGLXQueryVersion(__GLXclientState * cl, GLbyte * pc);
int ephyrGLXQueryVersionSwap(__GLXclientState * cl, GLbyte * pc);
int ephyrGLXGetVisualConfigs(__GLXclientState * cl, GLbyte * pc);
int ephyrGLXGetVisualConfigsSwap(__GLXclientState * cl, GLbyte * pc);
int ephyrGLXClientInfo(__GLXclientState * cl, GLbyte * pc);
int ephyrGLXClientInfoSwap(__GLXclientState * cl, GLbyte * pc);
int ephyrGLXQueryServerString(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXQueryServerStringSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXGetFBConfigsSGIX(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXGetFBConfigsSGIXSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXCreateContext(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXCreateContextSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXCreateNewContext(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXCreateNewContextSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXDestroyContext(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXDestroyContextSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXMakeCurrent(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXMakeCurrentSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXMakeCurrentReadSGI(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXMakeCurrentReadSGISwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXMakeContextCurrent(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXMakeContextCurrentSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXGetString(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXGetStringSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXGetIntegerv(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXGetIntegervSwap(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXIsDirect(__GLXclientState * a_cl, GLbyte * a_pc);
int ephyrGLXIsDirectSwap(__GLXclientState * a_cl, GLbyte * a_pc);

Bool
ephyrHijackGLXExtension(void)
{
    const void *(*dispatch_functions)[2];

    if (!hostx_has_extension(&xcb_glx_id)) {
        EPHYR_LOG("host X does not have GLX\n");
        return FALSE;
    }
    EPHYR_LOG("host X does have GLX\n");

    if (!Single_dispatch_info.dispatch_functions) {
        EPHYR_LOG_ERROR("could not get dispatch functions table\n");
        return FALSE;
    }
    /*
     * hijack some single entry point dispatch functions
     */
    dispatch_functions = Single_dispatch_info.dispatch_functions;
    EPHYR_RETURN_VAL_IF_FAIL(dispatch_functions, FALSE);

    dispatch_functions[X_GLXQueryVersion][0] = ephyrGLXQueryVersion;
    dispatch_functions[X_GLXQueryVersion][1] = ephyrGLXQueryVersionSwap;

    dispatch_functions[X_GLXGetVisualConfigs][0] = ephyrGLXGetVisualConfigs;
    dispatch_functions[X_GLXGetVisualConfigs][1] = ephyrGLXGetVisualConfigsSwap;
    dispatch_functions[X_GLXClientInfo][0] = ephyrGLXClientInfo;
    dispatch_functions[X_GLXClientInfo][1] = ephyrGLXClientInfoSwap;

    dispatch_functions[X_GLXQueryServerString][0] = ephyrGLXQueryServerString;
    dispatch_functions[X_GLXQueryServerString][1] =
        ephyrGLXQueryServerStringSwap;

    dispatch_functions[X_GLXCreateContext][0] = ephyrGLXCreateContext;
    dispatch_functions[X_GLXCreateContext][1] = ephyrGLXCreateContextSwap;

    dispatch_functions[X_GLXCreateNewContext][0] = ephyrGLXCreateNewContext;
    dispatch_functions[X_GLXCreateNewContext][1] = ephyrGLXCreateNewContextSwap;

    dispatch_functions[X_GLXDestroyContext][0] = ephyrGLXDestroyContext;
    dispatch_functions[X_GLXDestroyContext][1] = ephyrGLXDestroyContextSwap;

    dispatch_functions[X_GLXMakeCurrent][0] = ephyrGLXMakeCurrent;
    dispatch_functions[X_GLXMakeCurrent][1] = ephyrGLXMakeCurrentSwap;

    dispatch_functions[X_GLXIsDirect][0] = ephyrGLXIsDirect;
    dispatch_functions[X_GLXIsDirect][1] = ephyrGLXIsDirectSwap;

    dispatch_functions[73][0] = ephyrGLXGetString;
    dispatch_functions[73][1] = ephyrGLXGetStringSwap;

    dispatch_functions[61][0] = ephyrGLXGetIntegerv;
    dispatch_functions[61][1] = ephyrGLXGetIntegervSwap;

    dispatch_functions[X_GLXMakeContextCurrent][0] =
        ephyrGLXMakeContextCurrent;
    dispatch_functions[X_GLXMakeContextCurrent][1] =
        ephyrGLXMakeContextCurrentSwap;

    /*
     * hijack some vendor priv entry point dispatch functions
     */
    dispatch_functions = VendorPriv_dispatch_info.dispatch_functions;
    dispatch_functions[92][0] = ephyrGLXGetFBConfigsSGIX;
    dispatch_functions[92][1] = ephyrGLXGetFBConfigsSGIXSwap;

    dispatch_functions[89][0] = ephyrGLXMakeCurrentReadSGI;
    dispatch_functions[89][1] = ephyrGLXMakeCurrentReadSGISwap;

    EPHYR_LOG("hijacked glx entry points to forward requests to host X\n");


    return TRUE;
}

/*********************
 * implementation of
 * hijacked GLX entry
 * points
 ********************/

int
ephyrGLXQueryVersion(__GLXclientState * a_cl, GLbyte * a_pc)
{
    ClientPtr client = a_cl->client;
    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) a_pc;
    xGLXQueryVersionReply reply;
    int major, minor;
    int res = BadImplementation;

    EPHYR_LOG("enter\n");

    major = req->majorVersion;
    minor = req->minorVersion;

    if (!ephyrHostGLXQueryVersion(&major, &minor)) {
        EPHYR_LOG_ERROR("ephyrHostGLXQueryVersion() failed\n");
        goto out;
    }
    EPHYR_LOG("major:%d, minor:%d\n", major, minor);
    reply = (xGLXQueryVersionReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = major,
        .minorVersion = minor
    };

    if (client->swapped) {
        __glXSwapQueryVersionReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXQueryVersionReply, &reply);
    }

    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXQueryVersionSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) a_pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->majorVersion);
    __GLX_SWAP_INT(&req->minorVersion);
    return ephyrGLXQueryVersion(a_cl, a_pc);
}

static int
ephyrGLXGetVisualConfigsReal(__GLXclientState * a_cl,
                             GLbyte * a_pc, Bool a_do_swap)
{
    xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) a_pc;
    ClientPtr client = a_cl->client;
    xGLXGetVisualConfigsReply reply;
    int32_t *props_buf = NULL, num_visuals = 0,
        num_props = 0, res = BadImplementation, i = 0,
        props_per_visual_size = 0, props_buf_size = 0;
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    EPHYR_LOG("enter\n");

    if (!ephyrHostGLXGetVisualConfigs(req->screen,
                                      &num_visuals,
                                      &num_props,
                                      &props_buf_size, &props_buf)) {
        EPHYR_LOG_ERROR("ephyrHostGLXGetVisualConfigs() failed\n");
        goto out;
    }
    EPHYR_LOG("num_visuals:%d, num_props:%d\n", num_visuals, num_props);

    reply = (xGLXGetVisualConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = (num_visuals * __GLX_SIZE_CARD32 * num_props) >> 2,
        .numVisuals = num_visuals,
        .numProps = num_props
    };

    if (a_do_swap) {
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.numVisuals);
        __GLX_SWAP_INT(&reply.numProps);
        __GLX_SWAP_INT_ARRAY(props_buf, num_props);
    }
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, &reply);
    props_per_visual_size = props_buf_size / num_visuals;
    for (i = 0; i < num_visuals; i++) {
        WriteToClient(client,
                      props_per_visual_size,
                      (char *) props_buf + i * props_per_visual_size);
    }
    res = Success;

 out:
    EPHYR_LOG("leave\n");
    free(props_buf);
    props_buf = NULL;

    return res;
}

static int
ephyrGLXGetFBConfigsSGIXReal(__GLXclientState * a_cl,
                             GLbyte * a_pc, Bool a_do_swap)
{
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) a_pc;
    ClientPtr client = a_cl->client;
    xGLXGetVisualConfigsReply reply;
    int32_t *props_buf = NULL, num_visuals = 0,
        num_props = 0, res = BadImplementation, i = 0,
        props_per_visual_size = 0, props_buf_size = 0;
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    EPHYR_LOG("enter\n");

    if (!ephyrHostGLXVendorPrivGetFBConfigsSGIX(req->screen,
                                                &num_visuals,
                                                &num_props,
                                                &props_buf_size, &props_buf)) {
        EPHYR_LOG_ERROR("ephyrHostGLXGetVisualConfigs() failed\n");
        goto out;
    }
    EPHYR_LOG("num_visuals:%d, num_props:%d\n", num_visuals, num_props);

    reply = (xGLXGetVisualConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = props_buf_size >> 2,
        .numVisuals = num_visuals,
        .numProps = num_props
    };

    if (a_do_swap) {
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.numVisuals);
        __GLX_SWAP_INT(&reply.numProps);
        __GLX_SWAP_INT_ARRAY(props_buf, num_props);
    }
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, &reply);
    props_per_visual_size = props_buf_size / num_visuals;
    for (i = 0; i < num_visuals; i++) {
        WriteToClient(client,
                      props_per_visual_size,
                      &((char *) props_buf)[i * props_per_visual_size]);
    }
    res = Success;

 out:
    EPHYR_LOG("leave\n");
    free(props_buf);
    props_buf = NULL;

    return res;
}

int
ephyrGLXGetVisualConfigs(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetVisualConfigsReal(a_cl, a_pc, FALSE);
}

int
ephyrGLXGetVisualConfigsSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetVisualConfigsReal(a_cl, a_pc, TRUE);
}

int
ephyrGLXClientInfo(__GLXclientState * a_cl, GLbyte * a_pc)
{
    int res = BadImplementation;
    xGLXClientInfoReq *req = (xGLXClientInfoReq *) a_pc;

    EPHYR_LOG("enter\n");
    if (!ephyrHostGLXSendClientInfo(req->major, req->minor, (char *) req + 1)) {
        EPHYR_LOG_ERROR("failed to send client info to host\n");
        goto out;
    }
    res = Success;

 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXClientInfoSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXClientInfoReq *req = (xGLXClientInfoReq *) a_pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->major);
    __GLX_SWAP_INT(&req->minor);
    __GLX_SWAP_INT(&req->numbytes);

    return ephyrGLXClientInfo(a_cl, a_pc);
}

int
ephyrGLXQueryServerString(__GLXclientState * a_cl, GLbyte * a_pc)
{
    int res = BadImplementation;
    ClientPtr client = a_cl->client;
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *) a_pc;
    xGLXQueryServerStringReply reply;
    char *server_string = NULL;
    int length = 0;

    EPHYR_LOG("enter\n");
    if (!ephyrHostGLXQueryServerString(req->screen,
                                       req->name,
                                       &server_string)) {
        EPHYR_LOG_ERROR("failed to query string from host\n");
        goto out;
    }
    EPHYR_LOG("string: %s\n", server_string);
    length = strlen(server_string) + 1;
    reply = (xGLXQueryServerStringReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = __GLX_PAD(length) >> 2,
        .n = length
    };

    WriteToClient(client, sz_xGLXQueryServerStringReply, &reply);
    WriteToClient(client, (int) (reply.length << 2), server_string);

    res = Success;

 out:
    EPHYR_LOG("leave\n");
    free(server_string);
    server_string = NULL;

    return res;
}

int
ephyrGLXQueryServerStringSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    EPHYR_LOG_ERROR("not yet implemented\n");
    return BadImplementation;
}

int
ephyrGLXGetFBConfigsSGIX(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetFBConfigsSGIXReal(a_cl, a_pc, FALSE);
}

int
ephyrGLXGetFBConfigsSGIXSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetFBConfigsSGIXReal(a_cl, a_pc, TRUE);
}

static int
ephyrGLXCreateContextReal(xGLXCreateContextReq * a_req, Bool a_do_swap)
{
    int res = BadImplementation;
    EphyrHostWindowAttributes host_w_attrs;

    __GLX_DECLARE_SWAP_VARIABLES;

    EPHYR_RETURN_VAL_IF_FAIL(a_req, BadValue);
    EPHYR_LOG("enter\n");

    if (a_do_swap) {
        __GLX_SWAP_SHORT(&a_req->length);
        __GLX_SWAP_INT(&a_req->context);
        __GLX_SWAP_INT(&a_req->visual);
        __GLX_SWAP_INT(&a_req->screen);
        __GLX_SWAP_INT(&a_req->shareList);
    }

    EPHYR_LOG("context creation requested. localid:%d, "
              "screen:%d, visual:%d, direct:%d\n",
              (int) a_req->context, (int) a_req->screen,
              (int) a_req->visual, (int) a_req->isDirect);

    memset(&host_w_attrs, 0, sizeof(host_w_attrs));
    if (!hostx_get_window_attributes(hostx_get_window(a_req->screen),
                                     &host_w_attrs)) {
        EPHYR_LOG_ERROR("failed to get host window attrs\n");
        goto out;
    }

    EPHYR_LOG("host window visual id: %d\n", host_w_attrs.visualid);

    if (!ephyrHostGLXCreateContext(a_req->screen,
                                   host_w_attrs.visualid,
                                   a_req->context,
                                   a_req->shareList, 0,
                                   a_req->isDirect, X_GLXCreateContext)) {
        EPHYR_LOG_ERROR("ephyrHostGLXCreateContext() failed\n");
        goto out;
    }
    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

static int
ephyrGLXCreateNewContextReal(xGLXCreateNewContextReq * a_req, Bool a_do_swap)
{
    int res = BadImplementation;

    __GLX_DECLARE_SWAP_VARIABLES;

    EPHYR_RETURN_VAL_IF_FAIL(a_req, BadValue);
    EPHYR_LOG("enter\n");

    if (a_do_swap) {
        __GLX_SWAP_SHORT(&a_req->length);
        __GLX_SWAP_INT(&a_req->context);
        __GLX_SWAP_INT(&a_req->fbconfig);
        __GLX_SWAP_INT(&a_req->screen);
        __GLX_SWAP_INT(&a_req->renderType);
        __GLX_SWAP_INT(&a_req->shareList);
    }

    EPHYR_LOG("context creation requested. localid:%d, "
              "screen:%d, fbconfig:%d, renderType:%d, direct:%d\n",
              (int) a_req->context, (int) a_req->screen,
              (int) a_req->fbconfig, (int) a_req->renderType,
              (int) a_req->isDirect);

    if (!ephyrHostGLXCreateContext(a_req->screen,
                                   a_req->fbconfig,
                                   a_req->context,
                                   a_req->shareList, a_req->renderType,
                                   a_req->isDirect, X_GLXCreateNewContext)) {
        EPHYR_LOG_ERROR("ephyrHostGLXCreateNewContext() failed\n");
        goto out;
    }
    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXCreateContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;

    return ephyrGLXCreateContextReal(req, FALSE);
}

int
ephyrGLXCreateContextSwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;

    return ephyrGLXCreateContextReal(req, TRUE);
}

int
ephyrGLXCreateNewContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;

    return ephyrGLXCreateNewContextReal(req, FALSE);
}

int
ephyrGLXCreateNewContextSwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;

    return ephyrGLXCreateNewContextReal(req, TRUE);
}

static int
ephyrGLXDestroyContextReal(__GLXclientState * a_cl,
                           GLbyte * a_pc, Bool a_do_swap)
{
    int res = BadImplementation;
    ClientPtr client = a_cl->client;
    xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) a_pc;

    EPHYR_LOG("enter. id:%d\n", (int) req->context);
    if (!ephyrHostDestroyContext(req->context)) {
        EPHYR_LOG_ERROR("ephyrHostDestroyContext() failed\n");
        client->errorValue = req->context;
        goto out;
    }
    res = Success;

 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXDestroyContext(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXDestroyContextReal(a_cl, a_pc, FALSE);
}

int
ephyrGLXDestroyContextSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXDestroyContextReal(a_cl, a_pc, TRUE);
}

static int
ephyrGLXMakeCurrentReal(__GLXclientState * a_cl, GLXDrawable write,
                        GLXDrawable read, GLXContextTag ctx,
                        GLXContextTag old_ctx, Bool a_do_swap)
{
    int res = BadImplementation;
    xGLXMakeCurrentReply reply;
    DrawablePtr drawableR = NULL, drawableW = NULL;
    GLXContextTag new_ctx = 0;

    EPHYR_LOG("enter\n");
    res = dixLookupDrawable(&drawableW, write, a_cl->client, 0, DixReadAccess);
    EPHYR_RETURN_VAL_IF_FAIL(drawableW, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(drawableW->pScreen, BadValue);
    EPHYR_LOG("screen nummber requested:%d\n", drawableW->pScreen->myNum);

    if (read != write) {
        res = dixLookupDrawable(&drawableR, read, a_cl->client, 0,
                                DixReadAccess);
        EPHYR_RETURN_VAL_IF_FAIL(drawableR, BadValue);
        EPHYR_RETURN_VAL_IF_FAIL(drawableR->pScreen, BadValue);
    }
    else {
        drawableR = drawableW;
    }

    if (!ephyrHostGLXMakeCurrent(hostx_get_window(drawableW->pScreen->myNum),
                                 hostx_get_window(drawableR->pScreen->myNum),
                                 ctx, old_ctx, (int *) &new_ctx)) {
        EPHYR_LOG_ERROR("ephyrHostGLXMakeCurrent() failed\n");
        goto out;
    }
    reply = (xGLXMakeCurrentReply) {
        .type = X_Reply,
        .sequenceNumber = a_cl->client->sequence,
        .length = 0,
        .contextTag = new_ctx
    };
    if (a_do_swap) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.contextTag);
    }
    WriteToClient(a_cl->client, sz_xGLXMakeCurrentReply, &reply);

    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXMakeCurrent(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) a_pc;
    return ephyrGLXMakeCurrentReal(a_cl, req->drawable, req->drawable,
                                   req->context, req->oldContextTag, FALSE);
}

int
ephyrGLXMakeCurrentSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) a_pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return ephyrGLXMakeCurrentReal(a_cl, req->drawable, req->drawable,
                                   req->context, req->oldContextTag, TRUE);
}

int
ephyrGLXMakeCurrentReadSGI(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) a_pc;

    return ephyrGLXMakeCurrentReal(a_cl, req->drawable, req->readable,
                                   req->context, req->oldContextTag, FALSE);
}

int
ephyrGLXMakeCurrentReadSGISwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) a_pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->readable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return ephyrGLXMakeCurrentReal(a_cl, req->drawable, req->readable,
                                   req->context, req->oldContextTag, TRUE);
}

int
ephyrGLXMakeContextCurrent(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) a_pc;

    return ephyrGLXMakeCurrentReal(a_cl, req->drawable, req->readdrawable,
                                   req->context, req->oldContextTag, FALSE);
}

int
ephyrGLXMakeContextCurrentSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) a_pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->readdrawable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return ephyrGLXMakeCurrentReal(a_cl, req->drawable, req->readdrawable,
                                   req->context, req->oldContextTag, TRUE);
}

static int
ephyrGLXGetStringReal(__GLXclientState * a_cl, GLbyte * a_pc, Bool a_do_swap)
{
    ClientPtr client = NULL;
    int context_tag = 0, name = 0, res = BadImplementation, length = 0;
    char *string = NULL;

    __GLX_DECLARE_SWAP_VARIABLES;

    EPHYR_RETURN_VAL_IF_FAIL(a_cl && a_pc, BadValue);

    EPHYR_LOG("enter\n");

    client = a_cl->client;

    if (a_do_swap) {
        __GLX_SWAP_INT(a_pc + 4);
        __GLX_SWAP_INT(a_pc + __GLX_SINGLE_HDR_SIZE);
    }
    context_tag = __GLX_GET_SINGLE_CONTEXT_TAG(a_pc);
    a_pc += __GLX_SINGLE_HDR_SIZE;
    name = *(GLenum *) (a_pc + 0);
    EPHYR_LOG("context_tag:%d, name:%d\n", context_tag, name);
    if (!ephyrHostGLXGetString(context_tag, name, &string)) {
        EPHYR_LOG_ERROR("failed to get string from server\n");
        goto out;
    }
    if (string) {
        length = strlen(string) + 1;
        EPHYR_LOG("got string:'%s', size:%d\n", string, length);
    }
    else {
        EPHYR_LOG("got string: string (null)\n");
    }
    __GLX_BEGIN_REPLY(length);
    __GLX_PUT_SIZE(length);
    __GLX_SEND_HEADER();
    if (a_do_swap) {
        __GLX_SWAP_REPLY_SIZE();
        __GLX_SWAP_REPLY_HEADER();
    }
    WriteToClient(client, length, string);

    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXGetString(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetStringReal(a_cl, a_pc, FALSE);
}

int
ephyrGLXGetStringSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetStringReal(a_cl, a_pc, TRUE);
}

static int
ephyrGLXGetIntegervReal(__GLXclientState * a_cl, GLbyte * a_pc, Bool a_do_swap)
{
    int res = BadImplementation;
    xGLXSingleReq *const req = (xGLXSingleReq *) a_pc;
    GLenum int_name;
    int value = 0;
    GLint answer_buf_room[200];
    GLint *buf = NULL;

    EPHYR_LOG("enter\n");

    a_pc += __GLX_SINGLE_HDR_SIZE;

    int_name = *(GLenum *) (a_pc + 0);
    if (!ephyrHostGetIntegerValue(req->contextTag, int_name, &value)) {
        EPHYR_LOG_ERROR("ephyrHostGetIntegerValue() failed\n");
        goto out;
    }
    buf = __glXGetAnswerBuffer(a_cl, sizeof(value),
                               answer_buf_room, sizeof(answer_buf_room), 4);

    if (!buf) {
        EPHYR_LOG_ERROR("failed to allocate reply buffer\n");
        res = BadAlloc;
        goto out;
    }
    __glXSendReply(a_cl->client, buf, 1, sizeof(value), GL_FALSE, 0);
    res = Success;

 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXGetIntegerv(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetIntegervReal(a_cl, a_pc, FALSE);
}

int
ephyrGLXGetIntegervSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXGetIntegervReal(a_cl, a_pc, TRUE);
}

static int
ephyrGLXIsDirectReal(__GLXclientState * a_cl, GLbyte * a_pc, Bool a_do_swap)
{
    int res = BadImplementation;
    ClientPtr client = a_cl->client;
    xGLXIsDirectReq *req = (xGLXIsDirectReq *) a_pc;
    xGLXIsDirectReply reply;
    int is_direct = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_cl && a_pc, FALSE);

    EPHYR_LOG("enter\n");

    if (!ephyrHostIsContextDirect(req->context, (int *) &is_direct)) {
        EPHYR_LOG_ERROR("ephyrHostIsContextDirect() failed\n");
        goto out;
    }
    reply = (xGLXIsDirectReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .isDirect = is_direct
    };

    WriteToClient(client, sz_xGLXIsDirectReply, &reply);
    res = Success;

 out:
    EPHYR_LOG("leave\n");
    return res;
}

int
ephyrGLXIsDirect(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXIsDirectReal(a_cl, a_pc, FALSE);
}

int
ephyrGLXIsDirectSwap(__GLXclientState * a_cl, GLbyte * a_pc)
{
    return ephyrGLXIsDirectReal(a_cl, a_pc, TRUE);
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d87 1
a87 1
    if (!host_has_extension(&xcb_glx_id)) {
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d4 2
a5 2
 * 
 * Copyright © 2007 OpenedHand Ltd 
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d32 1
d87 1
a87 1
    if (!hostx_has_glx()) {
d384 3
a386 4
    if (!ephyrHostGLXGetStringFromServer(req->screen,
                                         req->name,
                                         EPHYR_HOST_GLX_QueryServerString,
                                         &server_string)) {
d727 1
a727 3
    if (!ephyrHostGLXGetStringFromServer(context_tag,
                                         name,
                                         EPHYR_HOST_GLX_GetString, &string)) {
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d64 2
d70 4
d117 3
d135 5
d146 4
d152 1
d181 7
a187 5
    reply.majorVersion = major;
    reply.minorVersion = minor;
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d193 1
a193 1
        WriteToClient(client, sz_xGLXQueryVersionReply, (char *) &reply);
d239 7
a245 5
    reply.numVisuals = num_visuals;
    reply.numProps = num_props;
    reply.length = (num_visuals * __GLX_SIZE_CARD32 * num_props) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d254 1
a254 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *) &reply);
d295 7
a301 5
    reply.numVisuals = num_visuals;
    reply.numProps = num_props;
    reply.length = props_buf_size >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d310 1
a310 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *) &reply);
d379 1
a379 1
    char *server_string = NULL, *buf = NULL;
d392 6
a397 10
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = __GLX_PAD(length) >> 2;
    reply.n = length;
    buf = calloc(reply.length << 2, 1);
    if (!buf) {
        EPHYR_LOG_ERROR("failed to allocate string\n;");
        return BadAlloc;
    }
    memcpy(buf, server_string, length);
d399 1
a399 1
    WriteToClient(client, sz_xGLXQueryServerStringReply, (char *) &reply);
a408 3
    free(buf);
    buf = NULL;

d467 2
a468 1
                                   a_req->shareList, a_req->isDirect)) {
d478 39
d533 16
d583 3
a585 1
ephyrGLXMakeCurrentReal(__GLXclientState * a_cl, GLbyte * a_pc, Bool a_do_swap)
a587 1
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) a_pc;
d589 2
a590 2
    DrawablePtr drawable = NULL;
    int rc = 0;
d593 18
a610 11
    rc = dixLookupDrawable(&drawable,
                           req->drawable, a_cl->client, 0, DixReadAccess);
    EPHYR_RETURN_VAL_IF_FAIL(drawable, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(drawable->pScreen, BadValue);
    EPHYR_LOG("screen nummber requested:%d\n", drawable->pScreen->myNum);

    memset(&reply, 0, sizeof(reply));
    if (!ephyrHostGLXMakeCurrent(hostx_get_window(drawable->pScreen->myNum),
                                 req->context,
                                 req->oldContextTag,
                                 (int *) &reply.contextTag)) {
d614 6
a619 3
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = a_cl->client->sequence;
d626 1
a626 1
    WriteToClient(a_cl->client, sz_xGLXMakeCurrentReply, (char *) &reply);
d637 3
a639 1
    return ephyrGLXMakeCurrentReal(a_cl, a_pc, FALSE);
d645 57
a701 1
    return ephyrGLXMakeCurrentReal(a_cl, a_pc, TRUE);
d747 1
a747 1
    WriteToClient(client, length, (char *) string);
a826 1
    memset(&reply, 0, sizeof(reply));
d831 8
a838 5
    reply.isDirect = is_direct;
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    WriteToClient(client, sz_xGLXIsDirectReply, (char *) &reply);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a43 1

d52 22
a73 23

int ephyrGLXQueryVersion (__GLXclientState *cl, GLbyte *pc) ;
int ephyrGLXQueryVersionSwap (__GLXclientState *cl, GLbyte *pc) ;
int ephyrGLXGetVisualConfigs (__GLXclientState *cl, GLbyte *pc) ;
int ephyrGLXGetVisualConfigsSwap (__GLXclientState *cl, GLbyte *pc) ;
int ephyrGLXClientInfo(__GLXclientState *cl, GLbyte *pc) ;
int ephyrGLXClientInfoSwap(__GLXclientState *cl, GLbyte *pc) ;
int ephyrGLXQueryServerString(__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXQueryServerStringSwap(__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXGetFBConfigsSGIX (__GLXclientState *a_cl, GLbyte *a_pc);
int ephyrGLXGetFBConfigsSGIXSwap (__GLXclientState *a_cl, GLbyte *a_pc);
int ephyrGLXCreateContext (__GLXclientState *a_cl, GLbyte *a_pc);
int ephyrGLXCreateContextSwap (__GLXclientState *a_cl, GLbyte *a_pc);
int ephyrGLXDestroyContext (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXDestroyContextSwap (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXMakeCurrent (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXMakeCurrentSwap (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXGetString (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXGetStringSwap (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXGetIntegerv (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXGetIntegervSwap (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXIsDirect (__GLXclientState *a_cl, GLbyte *a_pc) ;
int ephyrGLXIsDirectSwap (__GLXclientState *a_cl, GLbyte *a_pc) ;
d76 1
a76 1
ephyrHijackGLXExtension (void)
d80 3
a82 3
    if (!hostx_has_glx ()) {
        EPHYR_LOG ("host X does not have GLX\n") ;
        return FALSE ;
d84 1
a84 1
    EPHYR_LOG ("host X does have GLX\n") ;
d87 2
a88 2
        EPHYR_LOG_ERROR ("could not get dispatch functions table\n") ;
        return FALSE ;
d93 2
a94 2
    dispatch_functions = Single_dispatch_info.dispatch_functions ;
    EPHYR_RETURN_VAL_IF_FAIL (dispatch_functions, FALSE) ;
d96 2
a97 2
    dispatch_functions[X_GLXQueryVersion][0] = ephyrGLXQueryVersion ;
    dispatch_functions[X_GLXQueryVersion][1] = ephyrGLXQueryVersionSwap ;
d99 4
a102 4
    dispatch_functions[X_GLXGetVisualConfigs][0] = ephyrGLXGetVisualConfigs ;
    dispatch_functions[X_GLXGetVisualConfigs][1] = ephyrGLXGetVisualConfigsSwap ;
    dispatch_functions[X_GLXClientInfo][0] = ephyrGLXClientInfo ;
    dispatch_functions[X_GLXClientInfo][1] = ephyrGLXClientInfoSwap ;
d104 1
a104 1
    dispatch_functions[X_GLXQueryServerString][0] = ephyrGLXQueryServerString ;
d106 1
a106 1
                                                ephyrGLXQueryServerStringSwap ;
d108 2
a109 2
    dispatch_functions[X_GLXCreateContext][0] = ephyrGLXCreateContext ;
    dispatch_functions[X_GLXCreateContext][1] = ephyrGLXCreateContextSwap ;
d111 2
a112 2
    dispatch_functions[X_GLXDestroyContext][0] = ephyrGLXDestroyContext ;
    dispatch_functions[X_GLXDestroyContext][1] = ephyrGLXDestroyContextSwap ;
d114 2
a115 2
    dispatch_functions[X_GLXMakeCurrent][0] = ephyrGLXMakeCurrent ;
    dispatch_functions[X_GLXMakeCurrent][1] = ephyrGLXMakeCurrentSwap ;
d117 2
a118 2
    dispatch_functions[X_GLXIsDirect][0] = ephyrGLXIsDirect ;
    dispatch_functions[X_GLXIsDirect][1] = ephyrGLXIsDirectSwap ;
d120 2
a121 2
    dispatch_functions[73][0] = ephyrGLXGetString ;
    dispatch_functions[73][1] = ephyrGLXGetStringSwap ;
d123 2
a124 2
    dispatch_functions[61][0] = ephyrGLXGetIntegerv ;
    dispatch_functions[61][1] = ephyrGLXGetIntegervSwap ;
d129 1
a129 1
    dispatch_functions = VendorPriv_dispatch_info.dispatch_functions ;
d132 1
a132 1
    EPHYR_LOG ("hijacked glx entry points to forward requests to host X\n") ;
d134 1
a134 1
    return TRUE ;
d144 1
a144 1
ephyrGLXQueryVersion(__GLXclientState *a_cl, GLbyte *a_pc)
d150 1
a150 1
    int res = BadImplementation ;
d152 1
a152 1
    EPHYR_LOG ("enter\n") ;
d154 2
a155 2
    major = req->majorVersion ;
    minor = req->minorVersion ;
d157 10
a166 11
    if (!ephyrHostGLXQueryVersion (&major, &minor)) {
        EPHYR_LOG_ERROR ("ephyrHostGLXQueryVersion() failed\n") ;
        goto out ;
    }
    EPHYR_LOG ("major:%d, minor:%d\n",
                major, minor);
    reply.majorVersion = major ;
    reply.minorVersion = minor ;
    reply.length = 0 ;
    reply.type = X_Reply ;
    reply.sequenceNumber = client->sequence ;
d170 3
a172 2
    } else {
        WriteToClient(client, sz_xGLXQueryVersionReply, (char *)&reply);
d175 3
a177 3
    res = Success ;
out:
    EPHYR_LOG ("leave\n") ;
d182 1
a182 1
ephyrGLXQueryVersionSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d185 1
d188 4
a191 4
    __GLX_SWAP_SHORT (&req->length);
    __GLX_SWAP_INT (&req->majorVersion);
    __GLX_SWAP_INT (&req->minorVersion);
    return ephyrGLXQueryVersion (a_cl, a_pc) ;
d195 2
a196 3
ephyrGLXGetVisualConfigsReal (__GLXclientState *a_cl,
                              GLbyte *a_pc,
                              Bool a_do_swap)
d201 3
a203 4
    int32_t *props_buf=NULL, num_visuals=0,
            num_props=0, res=BadImplementation, i=0,
            props_per_visual_size=0,
            props_buf_size=0;
d207 1
a207 1
    EPHYR_LOG ("enter\n") ;
d209 6
a214 7
    if (!ephyrHostGLXGetVisualConfigs (req->screen,
                                       &num_visuals,
                                       &num_props,
                                       &props_buf_size,
                                       &props_buf)) {
        EPHYR_LOG_ERROR ("ephyrHostGLXGetVisualConfigs() failed\n") ;
        goto out ;
d216 1
a216 1
    EPHYR_LOG ("num_visuals:%d, num_props:%d\n", num_visuals, num_props) ;
d220 1
a220 1
    reply.length = (num_visuals *__GLX_SIZE_CARD32 * num_props) >> 2;
d229 8
a236 1
        __GLX_SWAP_INT_ARRAY (props_buf, num_props) ;
d238 6
a243 13
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char*)&reply);
    props_per_visual_size = props_buf_size/num_visuals ;
    for (i=0; i < num_visuals; i++) {
        WriteToClient (client,
                       props_per_visual_size,
                       (char*)props_buf +i*props_per_visual_size);
    }
    res = Success ;

out:
    EPHYR_LOG ("leave\n") ;
    free(props_buf) ;
    props_buf = NULL ;
d245 1
a245 1
    return res ;
d249 2
a250 3
ephyrGLXGetFBConfigsSGIXReal (__GLXclientState *a_cl,
                              GLbyte *a_pc,
                              Bool a_do_swap)
d252 1
a252 1
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *)a_pc;
d255 3
a257 4
    int32_t *props_buf=NULL, num_visuals=0,
            num_props=0, res=BadImplementation, i=0,
            props_per_visual_size=0,
            props_buf_size=0;
d261 1
a261 1
    EPHYR_LOG ("enter\n") ;
d263 6
a268 7
    if (!ephyrHostGLXVendorPrivGetFBConfigsSGIX (req->screen,
                                                 &num_visuals,
                                                 &num_props,
                                                 &props_buf_size,
                                                 &props_buf)) {
        EPHYR_LOG_ERROR ("ephyrHostGLXGetVisualConfigs() failed\n") ;
        goto out ;
d270 1
a270 1
    EPHYR_LOG ("num_visuals:%d, num_props:%d\n", num_visuals, num_props) ;
d283 1
a283 1
        __GLX_SWAP_INT_ARRAY (props_buf, num_props) ;
d285 6
a290 6
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char*)&reply);
    props_per_visual_size = props_buf_size/num_visuals ;
    for (i=0; i < num_visuals; i++) {
        WriteToClient (client,
                       props_per_visual_size,
                       &((char*)props_buf)[i*props_per_visual_size]);
d292 1
a292 1
    res = Success ;
d294 4
a297 4
out:
    EPHYR_LOG ("leave\n") ;
    free(props_buf) ;
    props_buf = NULL ;
d299 1
a299 1
    return res ;
d303 1
a303 1
ephyrGLXGetVisualConfigs (__GLXclientState *a_cl, GLbyte *a_pc)
d305 1
a305 1
    return ephyrGLXGetVisualConfigsReal (a_cl, a_pc, FALSE) ;
d309 1
a309 1
ephyrGLXGetVisualConfigsSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d311 1
a311 1
    return ephyrGLXGetVisualConfigsReal (a_cl, a_pc, TRUE) ;
a313 1

d315 1
a315 1
ephyrGLXClientInfo(__GLXclientState *a_cl, GLbyte *a_pc)
d317 1
a317 1
    int res=BadImplementation ;
d320 4
a323 4
    EPHYR_LOG ("enter\n") ;
    if (!ephyrHostGLXSendClientInfo (req->major, req->minor, (char*)req+1)) {
        EPHYR_LOG_ERROR ("failed to send client info to host\n") ;
        goto out ;
d325 1
a325 1
    res = Success ;
d327 3
a329 3
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d333 1
a333 1
ephyrGLXClientInfoSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d335 2
a336 1
    xGLXClientInfoReq *req = (xGLXClientInfoReq *)a_pc;
d339 4
a342 4
    __GLX_SWAP_SHORT (&req->length);
    __GLX_SWAP_INT (&req->major);
    __GLX_SWAP_INT (&req->minor);
    __GLX_SWAP_INT (&req->numbytes);
d344 1
a344 1
    return ephyrGLXClientInfo (a_cl, a_pc) ;
d348 1
a348 1
ephyrGLXQueryServerString(__GLXclientState *a_cl, GLbyte *a_pc)
d350 1
a350 1
    int res = BadImplementation ;
d354 2
a355 2
    char *server_string=NULL, *buf=NULL;
    int length=0 ;
d357 14
a370 14
    EPHYR_LOG ("enter\n") ;
    if (!ephyrHostGLXGetStringFromServer (req->screen,
                                          req->name,
                                          EPHYR_HOST_GLX_QueryServerString,
                                          &server_string)) {
        EPHYR_LOG_ERROR ("failed to query string from host\n") ;
        goto out ;
    }
    EPHYR_LOG ("string: %s\n", server_string) ;
    length= strlen (server_string) + 1;
    reply.type = X_Reply ;
    reply.sequenceNumber = client->sequence ;
    reply.length = __GLX_PAD (length) >> 2 ;
    reply.n = length ;
d373 1
a373 1
        EPHYR_LOG_ERROR ("failed to allocate string\n;");
d376 1
a376 1
    memcpy (buf, server_string, length);
d378 2
a379 2
    WriteToClient(client, sz_xGLXQueryServerStringReply, (char*)&reply);
    WriteToClient(client, (int)(reply.length << 2), server_string);
d381 1
a381 1
    res = Success ;
d383 3
a385 3
out:
    EPHYR_LOG ("leave\n") ;
    free(server_string) ;
d391 1
a391 1
    return res ;
d395 1
a395 1
ephyrGLXQueryServerStringSwap(__GLXclientState *a_cl, GLbyte *a_pc)
d397 2
a398 2
    EPHYR_LOG_ERROR ("not yet implemented\n") ;
    return BadImplementation ;
a400 1

d402 1
a402 1
ephyrGLXGetFBConfigsSGIX (__GLXclientState *a_cl, GLbyte *a_pc)
d404 1
a404 1
    return ephyrGLXGetFBConfigsSGIXReal (a_cl, a_pc, FALSE) ;
d408 1
a408 1
ephyrGLXGetFBConfigsSGIXSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d410 1
a410 1
    return ephyrGLXGetFBConfigsSGIXReal (a_cl, a_pc, TRUE) ;
d414 1
a414 1
ephyrGLXCreateContextReal (xGLXCreateContextReq *a_req, Bool a_do_swap)
d416 3
a418 2
    int res=BadImplementation;
    EphyrHostWindowAttributes host_w_attrs ;
d421 2
a422 2
    EPHYR_RETURN_VAL_IF_FAIL (a_req, BadValue) ;
    EPHYR_LOG ("enter\n") ;
d432 10
a441 10
    EPHYR_LOG ("context creation requested. localid:%d, "
               "screen:%d, visual:%d, direct:%d\n",
               (int)a_req->context, (int)a_req->screen,
               (int)a_req->visual, (int)a_req->isDirect) ;

    memset (&host_w_attrs, 0, sizeof (host_w_attrs)) ;
    if (!hostx_get_window_attributes (hostx_get_window (a_req->screen),
                                      &host_w_attrs)) {
        EPHYR_LOG_ERROR ("failed to get host window attrs\n") ;
        goto out ;
d444 1
a444 1
    EPHYR_LOG ("host window visual id: %d\n", host_w_attrs.visualid) ;
d446 6
a451 7
    if (!ephyrHostGLXCreateContext (a_req->screen,
                                    host_w_attrs.visualid,
                                    a_req->context,
                                    a_req->shareList,
                                    a_req->isDirect)) {
        EPHYR_LOG_ERROR ("ephyrHostGLXCreateContext() failed\n") ;
        goto out ;
d454 3
a456 3
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d460 1
a460 1
ephyrGLXCreateContext (__GLXclientState *cl, GLbyte *pc)
d464 1
a464 1
    return ephyrGLXCreateContextReal (req, FALSE) ;
d467 2
a468 1
int ephyrGLXCreateContextSwap (__GLXclientState *cl, GLbyte *pc)
d471 2
a472 1
    return ephyrGLXCreateContextReal (req, TRUE) ;
d476 2
a477 3
ephyrGLXDestroyContextReal (__GLXclientState *a_cl,
                            GLbyte *a_pc,
                            Bool a_do_swap)
d479 1
a479 1
    int res=BadImplementation;
d483 5
a487 5
    EPHYR_LOG ("enter. id:%d\n", (int)req->context) ;
    if (!ephyrHostDestroyContext (req->context)) {
        EPHYR_LOG_ERROR ("ephyrHostDestroyContext() failed\n") ;
        client->errorValue = req->context ;
        goto out ;
d489 1
a489 1
    res = Success ;
d491 3
a493 3
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d497 1
a497 1
ephyrGLXDestroyContext (__GLXclientState *a_cl, GLbyte *a_pc)
d499 1
a499 1
    return ephyrGLXDestroyContextReal (a_cl, a_pc, FALSE) ;
d503 1
a503 1
ephyrGLXDestroyContextSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d505 1
a505 1
    return ephyrGLXDestroyContextReal (a_cl, a_pc, TRUE) ;
d509 1
a509 1
ephyrGLXMakeCurrentReal (__GLXclientState *a_cl, GLbyte *a_pc, Bool a_do_swap)
d511 1
a511 1
    int res=BadImplementation;
d513 17
a529 21
    xGLXMakeCurrentReply reply ;
    DrawablePtr drawable=NULL;
    int rc=0;

    EPHYR_LOG ("enter\n") ;
    rc = dixLookupDrawable (&drawable,
                            req->drawable,
                            a_cl->client,
                            0,
                            DixReadAccess);
    EPHYR_RETURN_VAL_IF_FAIL (drawable, BadValue) ;
    EPHYR_RETURN_VAL_IF_FAIL (drawable->pScreen, BadValue) ;
    EPHYR_LOG ("screen nummber requested:%d\n",
               drawable->pScreen->myNum) ;

    memset (&reply, 0, sizeof (reply)) ;
    if (!ephyrHostGLXMakeCurrent (hostx_get_window (drawable->pScreen->myNum),
                                  req->context,
                                  req->oldContextTag,
                                  (int*)&reply.contextTag)) {
        EPHYR_LOG_ERROR ("ephyrHostGLXMakeCurrent() failed\n") ;
d541 1
a541 1
    WriteToClient(a_cl->client, sz_xGLXMakeCurrentReply, (char *)&reply);
d543 4
a546 4
    res = Success ;
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d550 1
a550 1
ephyrGLXMakeCurrent (__GLXclientState *a_cl, GLbyte *a_pc)
d552 1
a552 1
    return ephyrGLXMakeCurrentReal (a_cl, a_pc, FALSE) ;
d556 1
a556 1
ephyrGLXMakeCurrentSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d558 1
a558 1
    return ephyrGLXMakeCurrentReal (a_cl, a_pc, TRUE) ;
d562 1
a562 1
ephyrGLXGetStringReal (__GLXclientState *a_cl, GLbyte *a_pc, Bool a_do_swap)
d564 4
a567 3
    ClientPtr client=NULL ;
    int context_tag=0, name=0, res=BadImplementation, length=0 ;
    char *string=NULL;
d570 1
a570 1
    EPHYR_RETURN_VAL_IF_FAIL (a_cl && a_pc, BadValue) ;
d572 1
a572 1
    EPHYR_LOG ("enter\n") ;
d574 1
a574 1
    client = a_cl->client ;
d577 2
a578 2
        __GLX_SWAP_INT (a_pc + 4);
        __GLX_SWAP_INT (a_pc + __GLX_SINGLE_HDR_SIZE);
d580 1
a580 1
    context_tag = __GLX_GET_SINGLE_CONTEXT_TAG (a_pc) ;
d582 7
a588 8
    name = *(GLenum*)(a_pc + 0);
    EPHYR_LOG ("context_tag:%d, name:%d\n", context_tag, name) ;
    if (!ephyrHostGLXGetStringFromServer (context_tag,
                                          name,
                                          EPHYR_HOST_GLX_GetString,
                                          &string)) {
        EPHYR_LOG_ERROR ("failed to get string from server\n") ;
        goto out ;
d591 9
a599 8
        length = strlen (string) + 1;
        EPHYR_LOG ("got string:'%s', size:%d\n", string, length) ;
    } else {
        EPHYR_LOG ("got string: string (null)\n") ;
    }
    __GLX_BEGIN_REPLY (length);
    __GLX_PUT_SIZE (length);
    __GLX_SEND_HEADER ();
d601 2
a602 2
        __GLX_SWAP_REPLY_SIZE ();
        __GLX_SWAP_REPLY_HEADER ();
d604 1
a604 1
    WriteToClient (client, length, (char *)string);
d606 4
a609 4
    res = Success ;
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d613 1
a613 1
ephyrGLXGetString (__GLXclientState *a_cl, GLbyte *a_pc)
d615 1
a615 1
    return ephyrGLXGetStringReal (a_cl, a_pc, FALSE) ;
d619 1
a619 1
ephyrGLXGetStringSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d621 1
a621 1
    return ephyrGLXGetStringReal (a_cl, a_pc, TRUE) ;
d625 1
a625 1
ephyrGLXGetIntegervReal (__GLXclientState *a_cl, GLbyte *a_pc, Bool a_do_swap)
d627 4
a630 4
    int res=BadImplementation;
    xGLXSingleReq * const req = (xGLXSingleReq *) a_pc;
    GLenum int_name ;
    int value=0 ;
d632 1
a632 1
    GLint *buf=NULL ;
d634 1
a634 1
    EPHYR_LOG ("enter\n") ;
d638 7
a644 9
    int_name = *(GLenum*) (a_pc+0) ;
    if (!ephyrHostGetIntegerValue (req->contextTag, int_name, &value)) {
        EPHYR_LOG_ERROR ("ephyrHostGetIntegerValue() failed\n") ;
        goto out ;
    }
    buf = __glXGetAnswerBuffer (a_cl, sizeof (value),
                                answer_buf_room,
                                sizeof (answer_buf_room),
                                4) ;
d647 3
a649 3
        EPHYR_LOG_ERROR ("failed to allocate reply buffer\n") ;
        res = BadAlloc ;
        goto out ;
d651 2
a652 2
    __glXSendReply (a_cl->client, buf, 1, sizeof (value), GL_FALSE, 0) ;
    res = Success ;
d654 3
a656 3
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d660 1
a660 1
ephyrGLXGetIntegerv (__GLXclientState *a_cl, GLbyte *a_pc)
d662 1
a662 1
    return ephyrGLXGetIntegervReal (a_cl, a_pc, FALSE) ;
d666 1
a666 1
ephyrGLXGetIntegervSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d668 1
a668 1
    return ephyrGLXGetIntegervReal (a_cl, a_pc, TRUE) ;
d672 1
a672 1
ephyrGLXIsDirectReal (__GLXclientState *a_cl, GLbyte *a_pc, Bool a_do_swap)
d674 1
a674 1
    int res=BadImplementation;
d678 1
a678 1
    int is_direct=0 ;
d680 1
a680 1
    EPHYR_RETURN_VAL_IF_FAIL (a_cl && a_pc, FALSE) ;
d682 1
a682 1
    EPHYR_LOG ("enter\n") ;
d684 4
a687 4
    memset (&reply, 0, sizeof (reply)) ;
    if (!ephyrHostIsContextDirect (req->context, (int*)&is_direct)) {
        EPHYR_LOG_ERROR ("ephyrHostIsContextDirect() failed\n") ;
        goto out ;
d689 1
a689 1
    reply.isDirect = is_direct ;
d693 2
a694 2
    WriteToClient(client, sz_xGLXIsDirectReply, (char *)&reply);
    res = Success ;
d696 3
a698 3
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d702 1
a702 1
ephyrGLXIsDirect (__GLXclientState *a_cl, GLbyte *a_pc)
d704 1
a704 1
    return ephyrGLXIsDirectReal (a_cl, a_pc, FALSE) ;
d708 1
a708 1
ephyrGLXIsDirectSwap (__GLXclientState *a_cl, GLbyte *a_pc)
d710 1
a710 1
    return ephyrGLXIsDirectReal (a_cl, a_pc, TRUE) ;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d246 1
a246 1
    xfree (props_buf) ;
d303 1
a303 1
    xfree (props_buf) ;
d378 1
a378 1
    buf = xcalloc (reply.length << 2, 1);
d392 1
a392 1
    xfree (server_string) ;
d395 1
a395 1
    xfree (buf);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d246 3
a248 4
    if (props_buf) {
        xfree (props_buf) ;
        props_buf = NULL ;
    }
d303 3
a305 4
    if (props_buf) {
        xfree (props_buf) ;
        props_buf = NULL ;
    }
d392 6
a397 8
    if (server_string) {
        xfree (server_string) ;
        server_string = NULL;
    }
    if (buf) {
        xfree (buf);
        buf = NULL;
    }
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a44 2
#ifdef XEPHYR_DRI

a727 3

#endif /*XEPHYR_DRI*/

@

