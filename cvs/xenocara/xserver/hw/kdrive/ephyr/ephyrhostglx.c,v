head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 *
 * Copyright © 2007 OpenedHand Ltd
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * a lots of the content of this file has been adapted from the mesa source
 * code.
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */
#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include <X11/Xdefs.h>
#include <X11/Xmd.h>
#include <GL/glxproto.h>
#include <xcb/glx.h>
#include "ephyrhostglx.h"
#define _HAVE_XALLOC_DECLS
#include "ephyrlog.h"
#include "hostx.h"

static int glx_major, glx_minor;

enum VisualConfRequestType {
    EPHYR_GET_FB_CONFIG,
    EPHYR_VENDOR_PRIV_GET_FB_CONFIG_SGIX,
    EPHYR_GET_VISUAL_CONFIGS
};

static Bool ephyrHostGLXGetVisualConfigsInternal
    (enum VisualConfRequestType a_type,
     xcb_glx_get_visual_configs_reply_t *reply,
     int32_t a_screen,
     int32_t *a_num_visuals,
     int32_t *a_num_props,
     int32_t *a_props_buf_size,
     int32_t **a_props_buf);

Bool
ephyrHostGLXQueryVersion(int *a_major, int *a_minor)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_glx_query_version_cookie_t cookie;
    xcb_glx_query_version_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(a_major && a_minor, FALSE);
    EPHYR_LOG("enter\n");

    if (glx_major) {
        *a_major = glx_major;
        *a_minor = glx_minor;
        return TRUE;
    }

    /* Send the glXQueryVersion request */
    cookie = xcb_glx_query_version(conn, 2, 1);
    reply = xcb_glx_query_version_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_major = reply->major_version;
    *a_minor = reply->minor_version;
    free(reply);

    EPHYR_LOG("major:%d, minor:%d\n", *a_major, *a_minor);

    is_ok = TRUE;
 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostGLXGetString(int a_context_tag,
                      int a_string_name,
                      char **a_string)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_glx_get_string_cookie_t cookie;
    xcb_glx_get_string_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(conn && a_string, FALSE);

    EPHYR_LOG("enter\n");
    cookie = xcb_glx_get_string(conn, a_context_tag, a_string_name);
    reply = xcb_glx_get_string_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_string = malloc(reply->n + 1);
    memcpy(*a_string, xcb_glx_get_string_string(reply), reply->n);
    (*a_string)[reply->n] = '\0';
    free(reply);
    is_ok = TRUE;
out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool ephyrHostGLXQueryServerString(int a_screen_number,
                                   int a_string_name,
                                   char **a_string)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    int default_screen = hostx_get_screen();
    xcb_glx_query_server_string_cookie_t cookie;
    xcb_glx_query_server_string_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(conn && a_string, FALSE);

    EPHYR_LOG("enter\n");
    cookie = xcb_glx_query_server_string(conn, default_screen, a_string_name);
    reply = xcb_glx_query_server_string_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    *a_string = malloc(reply->str_len + 1);
    memcpy(*a_string, xcb_glx_query_server_string_string(reply), reply->str_len);
    (*a_string)[reply->str_len] = '\0';
    free(reply);
    is_ok = TRUE;
out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static Bool
ephyrHostGLXGetVisualConfigsInternal(enum VisualConfRequestType a_type,
                                     xcb_glx_get_visual_configs_reply_t *reply,
                                     int32_t a_screen,
                                     int32_t * a_num_visuals,
                                     int32_t * a_num_props,
                                     int32_t * a_props_buf_size,
                                     int32_t ** a_props_buf)
{
    Bool is_ok = FALSE;
    int num_props = 0, num_visuals = 0, props_buf_size = 0;
    int props_per_visual_size = 0;
    int32_t *props_buf = NULL;

   if (!reply->num_visuals) {
        EPHYR_LOG_ERROR("screen does not support GL rendering\n");
        goto out;
    }
    num_visuals = reply->num_visuals;

    num_props = reply->num_properties;

    if (a_type != EPHYR_GET_VISUAL_CONFIGS) {
        num_props *= 2;
    }
    props_per_visual_size = num_props * sizeof(uint32_t);
    props_buf_size = props_per_visual_size * reply->num_visuals;
    props_buf = malloc(props_buf_size);
    if (!props_buf)
        goto out;
    memcpy(props_buf, xcb_glx_get_visual_configs_property_list(reply),
           props_buf_size);

    *a_num_visuals = num_visuals;
    *a_num_props = reply->num_properties;
    *a_props_buf_size = props_buf_size;
    *a_props_buf = props_buf;
    is_ok = TRUE;

out:
    return is_ok;
}

Bool
ephyrHostGLXGetVisualConfigs(int32_t a_screen,
                             int32_t * a_num_visuals,
                             int32_t * a_num_props,
                             int32_t * a_props_buf_size, int32_t ** a_props_buf)
{
    Bool is_ok = FALSE;
    xcb_glx_get_visual_configs_cookie_t cookie;
    xcb_glx_get_visual_configs_reply_t *reply;
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();

    EPHYR_LOG("enter\n");
    cookie = xcb_glx_get_visual_configs(conn, screen);
    reply = xcb_glx_get_visual_configs_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    is_ok = ephyrHostGLXGetVisualConfigsInternal
        (EPHYR_GET_VISUAL_CONFIGS,
         reply,
         a_screen,
         a_num_visuals,
         a_num_props,
         a_props_buf_size,
         a_props_buf);

out:
    free(reply);
    EPHYR_LOG("leave:%d\n", is_ok);
    return is_ok;
}

Bool
ephyrHostGLXVendorPrivGetFBConfigsSGIX(int a_screen,
                                       int32_t * a_num_visuals,
                                       int32_t * a_num_props,
                                       int32_t * a_props_buf_size,
                                       int32_t ** a_props_buf)
{
    Bool is_ok=FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    int screen = hostx_get_screen();
    xcb_glx_vendor_private_with_reply_cookie_t cookie;
    union {
        xcb_glx_vendor_private_with_reply_reply_t *vprep;
        xcb_glx_get_visual_configs_reply_t *rep;
    } reply;

    EPHYR_LOG("enter\n");
    cookie = xcb_glx_vendor_private_with_reply(conn,
                                               X_GLXvop_GetFBConfigsSGIX,
                                               0, 4, (uint8_t *)&screen);
    reply.vprep = xcb_glx_vendor_private_with_reply_reply(conn, cookie, NULL);
    if (!reply.vprep)
        goto out;
    is_ok = ephyrHostGLXGetVisualConfigsInternal
        (EPHYR_VENDOR_PRIV_GET_FB_CONFIG_SGIX,
         reply.rep,
         a_screen,
         a_num_visuals,
         a_num_props,
         a_props_buf_size,
         a_props_buf);
out:
    free(reply.vprep);
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostGLXSendClientInfo(int32_t a_major, int32_t a_minor,
                           const char *a_extension_list)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int size;

    EPHYR_RETURN_VAL_IF_FAIL(conn && a_extension_list, FALSE);

    size = strlen (a_extension_list) + 1;
    xcb_glx_client_info(conn, a_major, a_minor, size, a_extension_list);

    return TRUE;
}

Bool
ephyrHostGLXCreateContext(int a_screen,
                          int a_generic_id,
                          int a_context_id,
                          int a_share_list_ctxt_id,
                          int a_render_type,
                          Bool a_direct,
                          int code)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    Bool is_ok = FALSE;
    int remote_context_id = 0;

    EPHYR_LOG("enter. screen:%d, generic_id:%d, contextid:%d, rendertype:%d, "
                 "direct:%d\n", a_screen, a_generic_id, a_context_id,
                 a_render_type, a_direct);

    if (!hostx_allocate_resource_id_peer(a_context_id, &remote_context_id)) {
        EPHYR_LOG_ERROR("failed to peer the context id %d host X",
                        remote_context_id);
        goto out;
    }

    switch (code) {
    case X_GLXCreateContext: {
        xcb_glx_create_context(conn,
                               remote_context_id,
                               a_generic_id,
                               hostx_get_screen(),
                               a_share_list_ctxt_id,
                               a_direct);
   }

    case X_GLXCreateNewContext: {
        xcb_glx_create_new_context(conn,
                                   remote_context_id,
                                   a_generic_id,
                                   hostx_get_screen(),
                                   a_render_type,
                                   a_share_list_ctxt_id,
                                   a_direct);
    }

    default:
        /* This should never be reached !*/
        EPHYR_LOG("Internal error! Invalid CreateContext code!\n");
    }

    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostDestroyContext(int a_ctxt_id)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    Bool is_ok = FALSE;
    int remote_ctxt_id = 0;

    EPHYR_LOG("enter:%d\n", a_ctxt_id);

    if (!hostx_get_resource_id_peer(a_ctxt_id, &remote_ctxt_id)) {
        EPHYR_LOG_ERROR("failed to get remote glx ctxt id\n");
        goto out;
    }
    EPHYR_LOG("host context id:%d\n", remote_ctxt_id);

    xcb_glx_destroy_context(conn, remote_ctxt_id);

    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostGLXMakeCurrent(int a_drawable, int a_readable,
                        int a_glx_ctxt_id, int a_old_ctxt_tag, int *a_ctxt_tag)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    Bool is_ok = FALSE;
    int remote_glx_ctxt_id = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_ctxt_tag, FALSE);

    EPHYR_LOG("enter. drawable:%d, read:%d, context:%d, oldtag:%d\n",
              a_drawable, a_readable, a_glx_ctxt_id, a_old_ctxt_tag);

    if (!hostx_get_resource_id_peer(a_glx_ctxt_id, &remote_glx_ctxt_id)) {
        EPHYR_LOG_ERROR("failed to get remote glx ctxt id\n");
        goto out;
    }

    /* If both drawables are the same, use the old MakeCurrent request.
     * Otherwise, if we have GLX 1.3 or higher, use the MakeContextCurrent
     * request which supports separate read and draw targets.  Failing that,
     * try the SGI MakeCurrentRead extension.  Logic cribbed from Mesa. */
    if (a_drawable == a_readable) {
        xcb_glx_make_current_cookie_t cookie;
        xcb_glx_make_current_reply_t *reply;
        cookie = xcb_glx_make_current(conn,
                                      a_drawable,
                                      remote_glx_ctxt_id,
                                      a_old_ctxt_tag);
        reply = xcb_glx_make_current_reply(conn, cookie, NULL);
        if (!reply)
            goto out;
        *a_ctxt_tag = reply->context_tag;
        free(reply);
    }
    else if (glx_major > 1 || glx_minor >= 3) {
        xcb_glx_make_context_current_cookie_t cookie;
        xcb_glx_make_context_current_reply_t *reply;
        cookie = xcb_glx_make_context_current(conn,
                                              a_old_ctxt_tag,
                                              a_drawable,
                                              a_readable,
                                              remote_glx_ctxt_id);
        reply = xcb_glx_make_context_current_reply(conn, cookie, NULL);
        if (!reply)
            goto out;
        *a_ctxt_tag = reply->context_tag;
        free(reply);
    }
    else {
        xcb_glx_vendor_private_with_reply_cookie_t cookie;
        xcb_glx_vendor_private_with_reply_reply_t *reply;
        uint32_t data[3] = {
            a_drawable, a_readable, remote_glx_ctxt_id,
        };

        EPHYR_LOG("enter\n");
        cookie = xcb_glx_vendor_private_with_reply(conn,
                                                   X_GLXvop_MakeCurrentReadSGI,
                                                   a_old_ctxt_tag,
                                                   sizeof(data),
                                                   (uint8_t *)data);
        reply = xcb_glx_vendor_private_with_reply_reply(conn, cookie, NULL);

        *a_ctxt_tag = reply->retval;

        free(reply);
    }

    EPHYR_LOG("context tag:%d\n", *a_ctxt_tag);
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostGetIntegerValue(int a_current_context_tag, int a_int, int *a_val)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    Bool is_ok = FALSE;
    int size = 0;
    xcb_glx_get_integerv_cookie_t cookie;
    xcb_glx_get_integerv_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(a_val, FALSE);

    EPHYR_LOG("enter\n");
    cookie = xcb_glx_get_integerv(conn, a_current_context_tag, a_int);
    reply = xcb_glx_get_integerv_reply(conn, cookie, NULL);
    if (!reply)
        goto out;
    size = reply->n;
    if (!size) {
        EPHYR_LOG_ERROR("X_GLsop_GetIngerv failed\n");
        goto out;
    }
    *a_val = reply->datum;
    is_ok = TRUE;

out:
    free(reply);
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostIsContextDirect(int a_ctxt_id, int *a_is_direct)
{
    Bool is_ok = FALSE;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_glx_is_direct_cookie_t cookie;
    xcb_glx_is_direct_reply_t *reply = NULL;
    int remote_glx_ctxt_id = 0;

    EPHYR_LOG("enter\n");
    if (!hostx_get_resource_id_peer (a_ctxt_id, &remote_glx_ctxt_id)) {
        EPHYR_LOG_ERROR ("failed to get remote glx ctxt id\n");
        goto out;
    }

    /* Send the glXIsDirect request */
    cookie = xcb_glx_is_direct(conn, remote_glx_ctxt_id);
    reply = xcb_glx_is_direct_reply(conn, cookie, NULL);
    if (!reply) {
        EPHYR_LOG_ERROR("fail in reading reply from host\n");
        goto out;
    }
    *a_is_direct = reply->is_direct;
    is_ok = TRUE;

out:
    free(reply);
    EPHYR_LOG("leave\n");
    return is_ok;
}
@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d4 2
a5 2
 * 
 * Copyright © 2007 OpenedHand Ltd 
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d34 2
a35 14
/*
 * including some server headers (like kdrive-config.h)
 * might define the macro _XSERVER64
 * on 64 bits machines. That macro must _NOT_ be defined for Xlib
 * client code, otherwise bad things happen.
 * So let's undef that macro if necessary.
 */
#ifdef _XSERVER64
#undef _XSERVER64
#endif

#include <X11/Xlibint.h>
#include <GL/glx.h>
#include <GL/internal/glcore.h>
d37 1
a37 1
#include <GL/glxint.h>
d53 1
d55 4
a58 25
     int32_t * a_num_visuals,
     int32_t * a_num_props, int32_t * a_props_buf_size, int32_t ** a_props_buf);
Bool
ephyrHostGLXGetMajorOpcode(int *a_opcode)
{
    Bool is_ok = FALSE;
    Display *dpy = hostx_get_display();
    static int opcode;
    int first_event_return = 0, first_error_return = 0;

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);
    EPHYR_LOG("enter\n");
    if (!opcode) {
        if (!XQueryExtension(dpy, GLX_EXTENSION_NAME, &opcode,
                             &first_event_return, &first_error_return)) {
            EPHYR_LOG_ERROR("XQueryExtension() failed\n");
            goto out;
        }
    }
    *a_opcode = opcode;
    is_ok = TRUE;
 out:
    EPHYR_LOG("release\n");
    return is_ok;
}
d64 3
a66 4
    Display *dpy = hostx_get_display();
    int major_opcode = 0;
    xGLXQueryVersionReq *req = NULL;
    xGLXQueryVersionReply reply;
a76 6
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }
    EPHYR_LOG("major opcode: %d\n", major_opcode);

d78 7
a84 13
    memset(&reply, 0, sizeof(reply));
    LockDisplay(dpy);
    GetReq(GLXQueryVersion, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLXQueryVersion;
    req->majorVersion = 2;
    req->minorVersion = 1;
    _XReply(dpy, (xReply *) &reply, 0, False);
    UnlockDisplay(dpy);
    SyncHandle();

    *a_major = glx_major = reply.majorVersion;
    *a_minor = glx_minor = reply.minorVersion;
a93 22
/**
 * GLX protocol structure for the ficticious "GXLGenericGetString" request.
 * 
 * This is a non-existant protocol packet.  It just so happens that all of
 * the real protocol packets used to request a string from the server have
 * an identical binary layout.  The only difference between them is the
 * meaning of the \c for_whom field and the value of the \c glxCode.
 * (this has been copied from the mesa source code)
 */
typedef struct GLXGenericGetString {
    CARD8 reqType;
    CARD8 glxCode;
    CARD16 length B16;
    CARD32 for_whom B32;
    CARD32 name B32;
} xGLXGenericGetStringReq;

/* These defines are only needed to make the GetReq macro happy.
 */
#define sz_xGLXGenericGetStringReq 12
#define X_GLXGenericGetString 0

d95 3
a97 4
ephyrHostGLXGetStringFromServer(int a_screen_number,
                                int a_string_name,
                                enum EphyrHostGLXGetStringOps a_op,
                                char **a_string)
d100 3
a102 5
    Display *dpy = hostx_get_display();
    int default_screen = DefaultScreen(dpy);
    xGLXGenericGetStringReq *req = NULL;
    xGLXSingleReply reply;
    int length = 0, numbytes = 0, major_opcode = 0, get_string_op = 0;
d104 1
a104 1
    EPHYR_RETURN_VAL_IF_FAIL(dpy && a_string, FALSE);
d107 13
a119 13
    switch (a_op) {
    case EPHYR_HOST_GLX_QueryServerString:
        get_string_op = X_GLXQueryServerString;
        break;
    case EPHYR_HOST_GLX_GetString:
        get_string_op = X_GLsop_GetString;
        EPHYR_LOG("Going to glXGetString. strname:%#x, ctxttag:%d\n",
                  a_string_name, a_screen_number);
        break;
    default:
        EPHYR_LOG_ERROR("unknown EphyrHostGLXGetStringOp:%d\n", a_op);
        goto out;
    }
d121 9
a129 5
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }
    EPHYR_LOG("major opcode: %d\n", major_opcode);
d131 1
a131 43
    LockDisplay(dpy);

    /* All of the GLX protocol requests for getting a string from the server
     * look the same.  The exact meaning of the a_for_whom field is usually
     * either the screen number (for glXQueryServerString) or the context tag
     * (for GLXSingle).
     */
    GetReq(GLXGenericGetString, req);
    req->reqType = major_opcode;
    req->glxCode = get_string_op;
    req->for_whom = default_screen;
    req->name = a_string_name;

    _XReply(dpy, (xReply *) &reply, 0, False);

    length = reply.length * 4;
    if (!length) {
        numbytes = 0;
    }
    else {
        numbytes = reply.size;
    }
    EPHYR_LOG("going to get a string of size:%d\n", numbytes);

    *a_string = (char *) Xmalloc(numbytes + 1);
    if (!a_string) {
        EPHYR_LOG_ERROR("allocation failed\n");
        goto out;
    }

    memset(*a_string, 0, numbytes + 1);
    if (_XRead(dpy, *a_string, numbytes)) {
        UnlockDisplay(dpy);
        SyncHandle();
        EPHYR_LOG_ERROR("read failed\n");
        goto out;
    }
    length -= numbytes;
    _XEatData(dpy, length);
    UnlockDisplay(dpy);
    SyncHandle();
    EPHYR_LOG("strname:%#x, strvalue:'%s', strlen:%d\n",
              a_string_name, *a_string, numbytes);
d133 9
d143 1
a143 1
 out:
d150 1
d158 2
a159 12
    Display *dpy = hostx_get_display();
    xGLXGetVisualConfigsReq *req;
    xGLXGetFBConfigsReq *fb_req;
    xGLXVendorPrivateWithReplyReq *vpreq;
    xGLXGetFBConfigsSGIXReq *sgi_req;
    xGLXGetVisualConfigsReply reply;
    char *server_glx_version = NULL, *server_glx_extensions = NULL;
    int j = 0,
        screens = 0,
        major_opcode = 0,
        num_props = 0,
        num_visuals = 0, props_buf_size = 0, props_per_visual_size = 0;
d162 1
a162 42
    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);

    screens = ScreenCount(dpy);
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get opcode\n");
        goto out;
    }

    LockDisplay(dpy);
    switch (a_type) {
    case EPHYR_GET_FB_CONFIG:
        GetReq(GLXGetFBConfigs, fb_req);
        fb_req->reqType = major_opcode;
        fb_req->glxCode = X_GLXGetFBConfigs;
        fb_req->screen = DefaultScreen(dpy);
        break;

    case EPHYR_VENDOR_PRIV_GET_FB_CONFIG_SGIX:
        GetReqExtra(GLXVendorPrivateWithReply,
                    sz_xGLXGetFBConfigsSGIXReq
                    - sz_xGLXVendorPrivateWithReplyReq, vpreq);
        sgi_req = (xGLXGetFBConfigsSGIXReq *) vpreq;
        sgi_req->reqType = major_opcode;
        sgi_req->glxCode = X_GLXVendorPrivateWithReply;
        sgi_req->vendorCode = X_GLXvop_GetFBConfigsSGIX;
        sgi_req->screen = DefaultScreen(dpy);
        break;

    case EPHYR_GET_VISUAL_CONFIGS:
        GetReq(GLXGetVisualConfigs, req);
        req->reqType = major_opcode;
        req->glxCode = X_GLXGetVisualConfigs;
        req->screen = DefaultScreen(dpy);
        break;
    }

    if (!_XReply(dpy, (xReply *) &reply, 0, False)) {
        EPHYR_LOG_ERROR("unknown error\n");
        UnlockDisplay(dpy);
        goto out;
    }
    if (!reply.numVisuals) {
a163 1
        UnlockDisplay(dpy);
d166 1
a166 1
    num_visuals = reply.numVisuals;
d168 1
a168 12
    /* FIXME: Is the __GLX_MIN_CONFIG_PROPS test correct for
     * FIXME: FBconfigs? 
     */
    /* Check number of properties */
    num_props = reply.numProps;
    if ((num_props < __GLX_MIN_CONFIG_PROPS) ||
        (num_props > __GLX_MAX_CONFIG_PROPS)) {
        /* Huh?  Not in protocol defined limits.  Punt */
        EPHYR_LOG_ERROR("got a bad reply to request\n");
        UnlockDisplay(dpy);
        goto out;
    }
d173 2
a174 2
    props_per_visual_size = num_props * __GLX_SIZE_INT32;
    props_buf_size = props_per_visual_size * reply.numVisuals;
d176 4
a179 8
    for (j = 0; j < reply.numVisuals; j++) {
        if (_XRead(dpy,
                   &((char *) props_buf)[j * props_per_visual_size],
                   props_per_visual_size) != Success) {
            EPHYR_LOG_ERROR("read failed\n");
        }
    }
    UnlockDisplay(dpy);
d182 1
a182 1
    *a_num_props = reply.numProps;
d187 1
a187 10
 out:
    if (server_glx_version) {
        XFree(server_glx_version);
        server_glx_version = NULL;
    }
    if (server_glx_extensions) {
        XFree(server_glx_extensions);
        server_glx_extensions = NULL;
    }
    SyncHandle();
d198 4
d204 12
a215 5
    is_ok = ephyrHostGLXGetVisualConfigsInternal(EPHYR_GET_VISUAL_CONFIGS,
                                                 a_screen,
                                                 a_num_visuals,
                                                 a_num_props,
                                                 a_props_buf_size, a_props_buf);
d217 2
d230 8
a237 1
    Bool is_ok = FALSE;
d240 6
d248 8
a255 1
         a_screen, a_num_visuals, a_num_props, a_props_buf_size, a_props_buf);
d264 1
a264 3
    Bool is_ok = FALSE;
    Display *dpy = hostx_get_display();
    xGLXClientInfoReq *req;
a265 1
    int32_t major_opcode = 0;
d267 1
a267 1
    EPHYR_RETURN_VAL_IF_FAIL(dpy && a_extension_list, FALSE);
d269 2
a270 22
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }

    LockDisplay(dpy);

    GetReq(GLXClientInfo, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLXClientInfo;
    req->major = a_major;
    req->minor = a_minor;

    size = strlen(a_extension_list) + 1;
    req->length += bytes_to_int32(size);
    req->numbytes = size;
    Data(dpy, a_extension_list, size);

    UnlockDisplay(dpy);
    SyncHandle();

    is_ok = TRUE;
d272 1
a272 2
 out:
    return is_ok;
d284 1
d286 1
a286 2
    Display *dpy = hostx_get_display();
    int major_opcode = 0, remote_context_id = 0;
a297 7
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }

    LockDisplay(dpy);

d300 7
a306 11
        /* Send the glXCreateContext request */
        xGLXCreateContextReq *req;
        GetReq(GLXCreateContext, req);
        req->reqType = major_opcode;
        req->glxCode = X_GLXCreateContext;
        req->context = remote_context_id;
        req->visual = a_generic_id;
        req->screen = DefaultScreen(dpy);
        req->shareList = a_share_list_ctxt_id;
        req->isDirect = a_direct;
    }
d309 7
a315 11
        /* Send the glXCreateNewContext request */
        xGLXCreateNewContextReq *req;
        GetReq(GLXCreateNewContext, req);
        req->reqType = major_opcode;
        req->glxCode = X_GLXCreateNewContext;
        req->context = remote_context_id;
        req->fbconfig = a_generic_id;
        req->screen = DefaultScreen(dpy);
        req->renderType = a_render_type;
        req->shareList = a_share_list_ctxt_id;
        req->isDirect = a_direct;
a322 3
    UnlockDisplay(dpy);
    SyncHandle();

d333 1
d335 1
a335 3
    Display *dpy = hostx_get_display();
    int major_opcode = 0, remote_ctxt_id = 0;
    xGLXDestroyContextReq *req = NULL;
a338 4
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }
d345 1
a345 7
    LockDisplay(dpy);
    GetReq(GLXDestroyContext, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLXDestroyContext;
    req->context = remote_ctxt_id;
    UnlockDisplay(dpy);
    SyncHandle();
d358 1
a359 2
    Display *dpy = hostx_get_display();
    int32_t major_opcode = 0;
a360 1
    xGLXMakeCurrentReply reply;
a366 4
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }
a371 2
    LockDisplay(dpy);

d377 11
a387 8
        xGLXMakeCurrentReq *req;

        GetReq(GLXMakeCurrent, req);
        req->reqType = major_opcode;
        req->glxCode = X_GLXMakeCurrent;
        req->drawable = a_drawable;
        req->context = remote_glx_ctxt_id;
        req->oldContextTag = a_old_ctxt_tag;
d390 29
a418 1
        xGLXMakeContextCurrentReq *req;
d420 1
a420 7
        GetReq(GLXMakeContextCurrent, req);
        req->reqType = major_opcode;
        req->glxCode = X_GLXMakeContextCurrent;
        req->drawable = a_drawable;
        req->readdrawable = a_readable;
        req->context = remote_glx_ctxt_id;
        req->oldContextTag = a_old_ctxt_tag;
a421 3
    else {
        xGLXVendorPrivateWithReplyReq *vpreq;
        xGLXMakeCurrentReadSGIReq *req;
a422 24
        GetReqExtra(GLXVendorPrivateWithReply,
                    (sz_xGLXMakeCurrentReadSGIReq -
                     sz_xGLXVendorPrivateWithReplyReq),
                    vpreq);
        req = (xGLXMakeCurrentReadSGIReq *) vpreq;
        req->reqType = major_opcode;
        req->glxCode = X_GLXVendorPrivateWithReply;
        req->vendorCode = X_GLXvop_MakeCurrentReadSGI;
        req->drawable = a_drawable;
        req->readable = a_readable;
        req->context = remote_glx_ctxt_id;
        req->oldContextTag = a_old_ctxt_tag;
    }

    memset(&reply, 0, sizeof(reply));
    if (!_XReply(dpy, (xReply *) &reply, 0, False)) {
        EPHYR_LOG_ERROR("failed to get reply from host\n");
        UnlockDisplay(dpy);
        SyncHandle();
        goto out;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    *a_ctxt_tag = reply.contextTag;
a430 35
#define X_GLXSingle 0

#define __EPHYR_GLX_SINGLE_PUT_CHAR(offset,a) \
    *((INT8 *) (pc + offset)) = a

#define EPHYR_GLX_SINGLE_PUT_SHORT(offset,a) \
    *((INT16 *) (pc + offset)) = a

#define EPHYR_GLX_SINGLE_PUT_LONG(offset,a) \
    *((INT32 *) (pc + offset)) = a

#define EPHYR_GLX_SINGLE_PUT_FLOAT(offset,a) \
    *((FLOAT32 *) (pc + offset)) = a

#define EPHYR_GLX_SINGLE_READ_XREPLY()       \
    (void) _XReply(dpy, (xReply*) &reply, 0, False)

#define EPHYR_GLX_SINGLE_GET_RETVAL(a,cast) \
    a = (cast) reply.retval

#define EPHYR_GLX_SINGLE_GET_SIZE(a) \
    a = (GLint) reply.size

#define EPHYR_GLX_SINGLE_GET_CHAR(p) \
    *p = *(GLbyte *)&reply.pad3;

#define EPHYR_GLX_SINGLE_GET_SHORT(p) \
    *p = *(GLshort *)&reply.pad3;

#define EPHYR_GLX_SINGLE_GET_LONG(p) \
    *p = *(GLint *)&reply.pad3;

#define EPHYR_GLX_SINGLE_GET_FLOAT(p) \
    *p = *(GLfloat *)&reply.pad3;

d434 1
d436 3
a438 5
    Display *dpy = hostx_get_display();
    int major_opcode = 0, size = 0;
    xGLXSingleReq *req = NULL;
    xGLXSingleReply reply;
    unsigned char *pc = NULL;
d443 3
a445 2
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
d447 1
a447 10
    }
    LockDisplay(dpy);
    GetReqExtra(GLXSingle, 4, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLsop_GetIntegerv;
    req->contextTag = a_current_context_tag;
    pc = ((unsigned char *) (req) + sz_xGLXSingleReq);
    EPHYR_GLX_SINGLE_PUT_LONG(0, a_int);
    EPHYR_GLX_SINGLE_READ_XREPLY();
    EPHYR_GLX_SINGLE_GET_SIZE(size);
a448 2
        UnlockDisplay(dpy);
        SyncHandle();
d452 1
a452 3
    EPHYR_GLX_SINGLE_GET_LONG(a_val);
    UnlockDisplay(dpy);
    SyncHandle();
d455 2
a456 1
 out:
d465 4
a468 4
    Display *dpy = hostx_get_display();
    xGLXIsDirectReq *req = NULL;
    xGLXIsDirectReply reply;
    int major_opcode = 0, remote_glx_ctxt_id = 0;
d471 2
a472 6
    if (!ephyrHostGLXGetMajorOpcode(&major_opcode)) {
        EPHYR_LOG_ERROR("failed to get major opcode\n");
        goto out;
    }
    if (!hostx_get_resource_id_peer(a_ctxt_id, &remote_glx_ctxt_id)) {
        EPHYR_LOG_ERROR("failed to get remote glx ctxt id\n");
a474 1
    memset(&reply, 0, sizeof(reply));
d477 3
a479 6
    LockDisplay(dpy);
    GetReq(GLXIsDirect, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLXIsDirect;
    req->context = remote_glx_ctxt_id;
    if (!_XReply(dpy, (xReply *) &reply, 0, False)) {
a480 2
        UnlockDisplay(dpy);
        SyncHandle();
d483 1
a483 3
    UnlockDisplay(dpy);
    SyncHandle();
    *a_is_direct = reply.isDirect;
d486 2
a487 1
 out:
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d55 2
d104 6
d124 1
a124 1
    _XReply(dpy, (xReply *) & reply, 0, False);
d128 2
a129 2
    *a_major = reply.majorVersion;
    *a_minor = reply.minorVersion;
d210 1
a210 1
    _XReply(dpy, (xReply *) & reply, 0, False);
d306 1
a306 1
    if (!_XReply(dpy, (xReply *) & reply, 0, False)) {
d442 1
a442 1
                          int a_visual_id,
d444 4
a447 1
                          int a_share_list_ctxt_id, Bool a_direct)
a451 1
    xGLXCreateContextReq *req;
d453 3
a455 2
    EPHYR_LOG("enter. screen:%d, visual:%d, contextid:%d, direct:%d\n",
              a_screen, a_visual_id, a_context_id, a_direct);
d470 32
a501 9
    /* Send the glXCreateContext request */
    GetReq(GLXCreateContext, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLXCreateContext;
    req->context = remote_context_id;
    req->visual = a_visual_id;
    req->screen = DefaultScreen(dpy);
    req->shareList = a_share_list_ctxt_id;
    req->isDirect = a_direct;
d549 1
a549 1
ephyrHostGLXMakeCurrent(int a_drawable,
a555 1
    xGLXMakeCurrentReq *req;
d560 2
a561 2
    EPHYR_LOG("enter. drawable:%d, context:%d, oldtag:%d\n",
              a_drawable, a_glx_ctxt_id, a_old_ctxt_tag);
d574 42
a615 6
    GetReq(GLXMakeCurrent, req);
    req->reqType = major_opcode;
    req->glxCode = X_GLXMakeCurrent;
    req->drawable = a_drawable;
    req->context = remote_glx_ctxt_id;
    req->oldContextTag = a_old_ctxt_tag;
d618 1
a618 1
    if (!_XReply(dpy, (xReply *) & reply, 0, False)) {
d738 1
a738 1
    if (!_XReply(dpy, (xReply *) & reply, 0, False)) {
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a58 1

d62 11
a72 13
                                        (enum VisualConfRequestType a_type,
                                         int32_t a_screen,
                                         int32_t *a_num_visuals,
                                         int32_t *a_num_props,
                                         int32_t *a_props_buf_size,
                                         int32_t **a_props_buf);
Bool
ephyrHostGLXGetMajorOpcode (int *a_opcode)
{
    Bool is_ok=FALSE ;
    Display *dpy=hostx_get_display () ;
    static int opcode ;
    int first_event_return=0, first_error_return=0;
d74 2
a75 2
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
    EPHYR_LOG ("enter\n") ;
d77 4
a80 4
        if (!XQueryExtension (dpy, GLX_EXTENSION_NAME, &opcode,
                              &first_event_return, &first_error_return)) {
            EPHYR_LOG_ERROR ("XQueryExtension() failed\n") ;
            goto out ;
d83 5
a87 5
    *a_opcode = opcode ;
    is_ok = TRUE ;
out:
    EPHYR_LOG ("release\n") ;
    return is_ok ;
d91 1
a91 1
ephyrHostGLXQueryVersion (int *a_major, int *a_minor)
d93 4
a96 4
    Bool is_ok = FALSE ;
    Display *dpy = hostx_get_display () ;
    int major_opcode=0;
    xGLXQueryVersionReq *req=NULL;
d99 2
a100 2
    EPHYR_RETURN_VAL_IF_FAIL (a_major && a_minor, FALSE) ;
    EPHYR_LOG ("enter\n") ;
d102 3
a104 3
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
d106 1
a106 1
    EPHYR_LOG ("major opcode: %d\n", major_opcode) ;
d109 3
a111 3
    memset (&reply, 0, sizeof (reply)) ;
    LockDisplay (dpy);
    GetReq (GLXQueryVersion, req);
d116 13
a128 13
    _XReply(dpy, (xReply*) &reply, 0, False);
    UnlockDisplay (dpy);
    SyncHandle ();

    *a_major = reply.majorVersion ;
    *a_minor = reply.minorVersion ;

    EPHYR_LOG ("major:%d, minor:%d\n", *a_major, *a_minor) ;

    is_ok = TRUE ;
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d154 9
a162 9
ephyrHostGLXGetStringFromServer (int a_screen_number,
                                 int a_string_name,
                                 enum EphyrHostGLXGetStringOps a_op,
                                 char **a_string)
{
    Bool is_ok=FALSE ;
    Display *dpy = hostx_get_display () ;
    int default_screen = DefaultScreen (dpy);
    xGLXGenericGetStringReq *req=NULL;
d164 1
a164 1
    int length=0, numbytes=0, major_opcode=0, get_string_op=0;
d166 1
a166 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy && a_string, FALSE) ;
d168 1
a168 1
    EPHYR_LOG ("enter\n") ;
d170 11
a180 16
        case EPHYR_HOST_GLX_QueryServerString:
            get_string_op = X_GLXQueryServerString;
            break ;
        case EPHYR_HOST_GLX_GetString:
            get_string_op = X_GLsop_GetString;
            EPHYR_LOG ("Going to glXGetString. strname:%#x, ctxttag:%d\n",
                       a_string_name, a_screen_number) ;
            break ;
        default:
            EPHYR_LOG_ERROR ("unknown EphyrHostGLXGetStringOp:%d\n", a_op) ;
            goto out ;
    }

    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
a181 1
    EPHYR_LOG ("major opcode: %d\n", major_opcode) ;
d183 7
a189 1
    LockDisplay (dpy);
d196 1
a196 1
    GetReq (GLXGenericGetString, req);
d202 1
a202 1
    _XReply (dpy, (xReply *)&reply, 0, False);
d207 2
a208 1
    } else {
d211 1
a211 1
    EPHYR_LOG ("going to get a string of size:%d\n", numbytes) ;
d213 1
a213 1
    *a_string = (char *) Xmalloc (numbytes +1);
d215 1
a215 1
        EPHYR_LOG_ERROR ("allocation failed\n") ;
d219 6
a224 6
    memset (*a_string, 0, numbytes+1) ;
    if (_XRead (dpy, *a_string, numbytes)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        EPHYR_LOG_ERROR ("read failed\n") ;
        goto out ;
d227 10
a236 10
    _XEatData (dpy, length) ;
    UnlockDisplay (dpy);
    SyncHandle ();
    EPHYR_LOG ("strname:%#x, strvalue:'%s', strlen:%d\n",
               a_string_name, *a_string, numbytes) ;

    is_ok = TRUE ;
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d240 6
a245 6
ephyrHostGLXGetVisualConfigsInternal (enum VisualConfRequestType a_type,
                                      int32_t a_screen,
                                      int32_t *a_num_visuals,
                                      int32_t *a_num_props,
                                      int32_t *a_props_buf_size,
                                      int32_t **a_props_buf)
d247 2
a248 2
    Bool is_ok = FALSE ;
    Display *dpy = hostx_get_display () ;
d254 14
a267 17
    char *server_glx_version=NULL,
         *server_glx_extensions=NULL ;
    int j=0,
        screens=0,
        major_opcode=0,
        num_props=0,
        num_visuals=0,
        props_buf_size=0,
        props_per_visual_size=0;
    int32_t *props_buf=NULL;

    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;

    screens = ScreenCount (dpy);
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get opcode\n") ;
        goto out ;
d272 2
a273 2
        case EPHYR_GET_FB_CONFIG:
        GetReq(GLXGetFBConfigs,fb_req);
d276 1
a276 1
        fb_req->screen = DefaultScreen (dpy);
d279 1
a279 1
        case EPHYR_VENDOR_PRIV_GET_FB_CONFIG_SGIX:
d282 1
a282 3
                         -
                    sz_xGLXVendorPrivateWithReplyReq,
                    vpreq);
d287 1
a287 1
        sgi_req->screen = DefaultScreen (dpy);
d290 2
a291 2
        case EPHYR_GET_VISUAL_CONFIGS:
        GetReq(GLXGetVisualConfigs,req);
d294 1
a294 1
        req->screen = DefaultScreen (dpy);
d298 2
a299 2
    if (!_XReply(dpy, (xReply*) &reply, 0, False)) {
        EPHYR_LOG_ERROR ("unknown error\n") ;
d301 1
a301 1
        goto out ;
d303 2
a304 2
   if (!reply.numVisuals) {
        EPHYR_LOG_ERROR ("screen does not support GL rendering\n") ;
d306 1
a306 1
        goto out ;
d308 1
a308 1
   num_visuals = reply.numVisuals ;
d318 1
a318 1
        EPHYR_LOG_ERROR ("got a bad reply to request\n") ;
d320 1
a320 1
        goto out ;
d328 1
a328 1
    props_buf = malloc (props_buf_size) ;
d330 4
a333 4
        if (_XRead (dpy,
                    &((char*)props_buf)[j*props_per_visual_size],
                    props_per_visual_size) != Success) {
            EPHYR_LOG_ERROR ("read failed\n") ;
d338 5
a342 5
    *a_num_visuals = num_visuals ;
    *a_num_props = reply.numProps ;
    *a_props_buf_size = props_buf_size ;
    *a_props_buf = props_buf ;
    is_ok = TRUE ;
d344 1
a344 1
out:
d346 2
a347 2
        XFree (server_glx_version) ;
        server_glx_version = NULL ;
d350 2
a351 2
        XFree (server_glx_extensions) ;
        server_glx_extensions = NULL ;
d353 1
a353 1
    SyncHandle () ;
d358 4
a361 5
ephyrHostGLXGetVisualConfigs (int32_t a_screen,
                              int32_t *a_num_visuals,
                              int32_t *a_num_props,
                              int32_t *a_props_buf_size,
                              int32_t **a_props_buf)
d365 6
a370 7
    EPHYR_LOG ("enter\n") ;
    is_ok = ephyrHostGLXGetVisualConfigsInternal (EPHYR_GET_VISUAL_CONFIGS,
                                                  a_screen,
                                                  a_num_visuals,
                                                  a_num_props,
                                                  a_props_buf_size,
                                                  a_props_buf) ;
d372 1
a372 1
    EPHYR_LOG ("leave:%d\n", is_ok) ;
d377 5
a381 5
ephyrHostGLXVendorPrivGetFBConfigsSGIX (int a_screen,
                                        int32_t *a_num_visuals,
                                        int32_t *a_num_props,
                                        int32_t *a_props_buf_size,
                                        int32_t **a_props_buf)
d383 3
a385 2
    Bool is_ok=FALSE ;
    EPHYR_LOG ("enter\n") ;
d387 4
a390 8
                                        (EPHYR_VENDOR_PRIV_GET_FB_CONFIG_SGIX,
                                         a_screen,
                                         a_num_visuals,
                                         a_num_props,
                                         a_props_buf_size,
                                         a_props_buf) ;
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d394 2
a395 2
ephyrHostGLXSendClientInfo (int32_t a_major, int32_t a_minor,
                            const char* a_extension_list)
d397 2
a398 2
    Bool is_ok = FALSE ;
    Display *dpy = hostx_get_display () ;
d401 1
a401 1
    int32_t major_opcode=0 ;
d403 1
a403 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy && a_extension_list, FALSE) ;
d405 3
a407 3
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
d410 1
a410 1
    LockDisplay (dpy);
d412 1
a412 1
    GetReq (GLXClientInfo,req);
d418 1
a418 1
    size = strlen (a_extension_list) + 1;
d421 1
a421 1
    Data (dpy, a_extension_list, size);
d426 1
a426 1
    is_ok=TRUE ;
d428 2
a429 2
out:
    return is_ok ;
d433 4
a436 5
ephyrHostGLXCreateContext (int a_screen,
                           int a_visual_id,
                           int a_context_id,
                           int a_share_list_ctxt_id,
                           Bool a_direct)
d439 2
a440 2
    Display *dpy = hostx_get_display ();
    int major_opcode=0, remote_context_id=0;
d443 2
a444 2
    EPHYR_LOG ("enter. screen:%d, visual:%d, contextid:%d, direct:%d\n",
               a_screen, a_visual_id, a_context_id, a_direct) ;
d446 4
a449 4
    if (!hostx_allocate_resource_id_peer (a_context_id, &remote_context_id)) {
        EPHYR_LOG_ERROR ("failed to peer the context id %d host X",
                         remote_context_id) ;
        goto out ;
d452 3
a454 3
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
d457 1
a457 1
    LockDisplay (dpy) ;
d460 1
a460 1
    GetReq(GLXCreateContext,req);
d465 1
a465 1
    req->screen = DefaultScreen (dpy);
d469 2
a470 2
    UnlockDisplay (dpy);
    SyncHandle ();
d472 1
a472 1
    is_ok = TRUE ;
d474 3
a476 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d480 1
a480 1
ephyrHostDestroyContext (int a_ctxt_id)
d482 4
a485 4
    Bool is_ok=FALSE;
    Display *dpy=hostx_get_display ();
    int major_opcode=0, remote_ctxt_id=0 ;
    xGLXDestroyContextReq *req=NULL;
d487 1
a487 1
    EPHYR_LOG ("enter:%d\n", a_ctxt_id) ;
d489 3
a491 3
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
d493 3
a495 3
    if (!hostx_get_resource_id_peer (a_ctxt_id, &remote_ctxt_id)) {
        EPHYR_LOG_ERROR ("failed to get remote glx ctxt id\n") ;
        goto out ;
d497 1
a497 1
    EPHYR_LOG ("host context id:%d\n", remote_ctxt_id) ;
d499 2
a500 2
    LockDisplay (dpy);
    GetReq (GLXDestroyContext,req);
d504 2
a505 2
    UnlockDisplay (dpy);
    SyncHandle ();
d507 1
a507 1
    is_ok = TRUE ;
d509 3
a511 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d515 2
a516 4
ephyrHostGLXMakeCurrent (int a_drawable,
                         int a_glx_ctxt_id,
                         int a_old_ctxt_tag,
                         int *a_ctxt_tag)
d518 4
a521 4
    Bool is_ok=FALSE ;
    Display *dpy = hostx_get_display () ;
    int32_t major_opcode=0 ;
    int remote_glx_ctxt_id=0 ;
d525 1
a525 1
    EPHYR_RETURN_VAL_IF_FAIL (a_ctxt_tag, FALSE) ;
d527 2
a528 2
    EPHYR_LOG ("enter. drawable:%d, context:%d, oldtag:%d\n",
               a_drawable, a_glx_ctxt_id, a_old_ctxt_tag) ;
d530 3
a532 3
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
d534 3
a536 3
    if (!hostx_get_resource_id_peer (a_glx_ctxt_id, &remote_glx_ctxt_id)) {
        EPHYR_LOG_ERROR ("failed to get remote glx ctxt id\n") ;
        goto out ;
d539 1
a539 1
    LockDisplay (dpy);
d541 1
a541 1
    GetReq (GLXMakeCurrent,req);
d548 16
a563 16
    memset (&reply, 0, sizeof (reply)) ;
    if (!_XReply (dpy, (xReply*)&reply, 0, False)) {
        EPHYR_LOG_ERROR ("failed to get reply from host\n") ;
        UnlockDisplay (dpy);
        SyncHandle ();
        goto out ;
    }
    UnlockDisplay (dpy);
    SyncHandle ();
    *a_ctxt_tag = reply.contextTag ;
    EPHYR_LOG ("context tag:%d\n", *a_ctxt_tag) ;
    is_ok = TRUE ;

out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d602 1
a602 1
ephyrHostGetIntegerValue (int a_current_context_tag, int a_int, int *a_val)
d604 4
a607 4
    Bool is_ok=FALSE;
    Display *dpy = hostx_get_display () ;
    int major_opcode=0, size=0;
    xGLXSingleReq *req=NULL;
d609 1
a609 1
    unsigned char* pc=NULL ;
d611 1
a611 1
    EPHYR_RETURN_VAL_IF_FAIL (a_val, FALSE) ;
d613 9
a621 9
    EPHYR_LOG ("enter\n") ;
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
    }
    LockDisplay (dpy) ;
    GetReqExtra (GLXSingle, 4, req) ;
    req->reqType = major_opcode ;
    req->glxCode = X_GLsop_GetIntegerv ;
d623 4
a626 4
    pc = ((unsigned char *)(req) + sz_xGLXSingleReq) ;
    EPHYR_GLX_SINGLE_PUT_LONG (0, a_int) ;
    EPHYR_GLX_SINGLE_READ_XREPLY () ;
    EPHYR_GLX_SINGLE_GET_SIZE (size) ;
d628 4
a631 4
        UnlockDisplay (dpy) ;
        SyncHandle () ;
        EPHYR_LOG_ERROR ("X_GLsop_GetIngerv failed\n") ;
        goto out ;
d633 4
a636 4
    EPHYR_GLX_SINGLE_GET_LONG (a_val) ;
    UnlockDisplay (dpy) ;
    SyncHandle () ;
    is_ok = TRUE ;
d638 3
a640 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d644 1
a644 2
ephyrHostIsContextDirect (int a_ctxt_id,
                          int *a_is_direct)
d646 3
a648 3
    Bool is_ok=FALSE;
    Display *dpy = hostx_get_display () ;
    xGLXIsDirectReq *req=NULL;
d650 1
a650 1
    int major_opcode=0, remote_glx_ctxt_id=0;
d652 8
a659 8
    EPHYR_LOG ("enter\n") ;
    if (!ephyrHostGLXGetMajorOpcode (&major_opcode)) {
        EPHYR_LOG_ERROR ("failed to get major opcode\n") ;
        goto out ;
    }
    if (!hostx_get_resource_id_peer (a_ctxt_id, &remote_glx_ctxt_id)) {
        EPHYR_LOG_ERROR ("failed to get remote glx ctxt id\n") ;
        goto out ;
d661 1
a661 1
    memset (&reply, 0, sizeof (reply)) ;
d664 2
a665 2
    LockDisplay (dpy);
    GetReq (GLXIsDirect,req);
d669 14
a682 14
    if (!_XReply (dpy, (xReply*) &reply, 0, False)) {
        EPHYR_LOG_ERROR ("fail in reading reply from host\n") ;
        UnlockDisplay (dpy);
        SyncHandle ();
        goto out ;
    }
    UnlockDisplay (dpy);
    SyncHandle ();
    *a_is_direct = reply.isDirect ;
    is_ok = TRUE ;

out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d431 1
a431 1
    req->length += (size + 3) >> 2;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a54 1
#ifdef XEPHYR_DRI
a699 3

#endif /*XEPHYR_DRI*/

@

