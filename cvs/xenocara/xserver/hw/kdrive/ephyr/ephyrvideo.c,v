head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 *
 * Copyright © 2007 OpenedHand Ltd
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include <string.h>
#include <X11/extensions/Xv.h>
#include <xcb/xcb.h>
#include <xcb/xcb_aux.h>
#include <xcb/xv.h>
#include "ephyrlog.h"
#include "kdrive.h"
#include "kxv.h"
#include "ephyr.h"
#include "hostx.h"

struct _EphyrXVPriv {
    xcb_xv_query_adaptors_reply_t *host_adaptors;
    KdVideoAdaptorPtr adaptors;
    int num_adaptors;
};
typedef struct _EphyrXVPriv EphyrXVPriv;

struct _EphyrPortPriv {
    int port_number;
    KdVideoAdaptorPtr current_adaptor;
    EphyrXVPriv *xv_priv;
    unsigned char *image_buf;
    int image_buf_size;
    int image_id;
    int drw_x, drw_y, drw_w, drw_h;
    int src_x, src_y, src_w, src_h;
    int image_width, image_height;
};
typedef struct _EphyrPortPriv EphyrPortPriv;

static Bool ephyrLocalAtomToHost(int a_local_atom, int *a_host_atom);

static EphyrXVPriv *ephyrXVPrivNew(void);
static void ephyrXVPrivDelete(EphyrXVPriv * a_this);
static Bool ephyrXVPrivQueryHostAdaptors(EphyrXVPriv * a_this);
static Bool ephyrXVPrivSetAdaptorsHooks(EphyrXVPriv * a_this);
static Bool ephyrXVPrivRegisterAdaptors(EphyrXVPriv * a_this,
                                        ScreenPtr a_screen);

static Bool ephyrXVPrivIsAttrValueValid(XvAttributePtr a_attrs,
                                        int a_attrs_len,
                                        const char *a_attr_name,
                                        int a_attr_value, Bool *a_is_valid);

static Bool ephyrXVPrivGetImageBufSize(int a_port_id,
                                       int a_image_id,
                                       unsigned short a_width,
                                       unsigned short a_height, int *a_size);

static Bool ephyrXVPrivSaveImageToPortPriv(EphyrPortPriv * a_port_priv,
                                           const unsigned char *a_image,
                                           int a_image_len);

static void ephyrStopVideo(KdScreenInfo * a_info,
                           void *a_xv_priv, Bool a_exit);

static int ephyrSetPortAttribute(KdScreenInfo * a_info,
                                 Atom a_attr_name,
                                 int a_attr_value, void *a_port_priv);

static int ephyrGetPortAttribute(KdScreenInfo * a_screen_info,
                                 Atom a_attr_name,
                                 int *a_attr_value, void *a_port_priv);

static void ephyrQueryBestSize(KdScreenInfo * a_info,
                               Bool a_motion,
                               short a_src_w,
                               short a_src_h,
                               short a_drw_w,
                               short a_drw_h,
                               unsigned int *a_prefered_w,
                               unsigned int *a_prefered_h, void *a_port_priv);

static int ephyrPutImage(KdScreenInfo * a_info,
                         DrawablePtr a_drawable,
                         short a_src_x,
                         short a_src_y,
                         short a_drw_x,
                         short a_drw_y,
                         short a_src_w,
                         short a_src_h,
                         short a_drw_w,
                         short a_drw_h,
                         int a_id,
                         unsigned char *a_buf,
                         short a_width,
                         short a_height,
                         Bool a_sync,
                         RegionPtr a_clipping_region, void *a_port_priv);

static int ephyrReputImage(KdScreenInfo * a_info,
                           DrawablePtr a_drawable,
                           short a_drw_x,
                           short a_drw_y,
                           RegionPtr a_clipping_region, void *a_port_priv);

static int ephyrPutVideo(KdScreenInfo * a_info,
                         DrawablePtr a_drawable,
                         short a_vid_x, short a_vid_y,
                         short a_drw_x, short a_drw_y,
                         short a_vid_w, short a_vid_h,
                         short a_drw_w, short a_drw_h,
                         RegionPtr a_clip_region, void *a_port_priv);

static int ephyrGetVideo(KdScreenInfo * a_info,
                         DrawablePtr a_drawable,
                         short a_vid_x, short a_vid_y,
                         short a_drw_x, short a_drw_y,
                         short a_vid_w, short a_vid_h,
                         short a_drw_w, short a_drw_h,
                         RegionPtr a_clip_region, void *a_port_priv);

static int ephyrPutStill(KdScreenInfo * a_info,
                         DrawablePtr a_drawable,
                         short a_vid_x, short a_vid_y,
                         short a_drw_x, short a_drw_y,
                         short a_vid_w, short a_vid_h,
                         short a_drw_w, short a_drw_h,
                         RegionPtr a_clip_region, void *a_port_priv);

static int ephyrGetStill(KdScreenInfo * a_info,
                         DrawablePtr a_drawable,
                         short a_vid_x, short a_vid_y,
                         short a_drw_x, short a_drw_y,
                         short a_vid_w, short a_vid_h,
                         short a_drw_w, short a_drw_h,
                         RegionPtr a_clip_region, void *a_port_priv);

static int ephyrQueryImageAttributes(KdScreenInfo * a_info,
                                     int a_id,
                                     unsigned short *a_w,
                                     unsigned short *a_h,
                                     int *a_pitches, int *a_offsets);
static int s_base_port_id;

/**************
 * <helpers>
 * ************/

static Bool
adaptor_has_flags(const xcb_xv_adaptor_info_t *adaptor, uint32_t flags)
{
    return (adaptor->type & flags) == flags;
}

static Bool
ephyrLocalAtomToHost(int a_local_atom, int *a_host_atom)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_intern_atom_cookie_t cookie;
    xcb_intern_atom_reply_t *reply;
    const char *atom_name = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_host_atom, FALSE);

    if (!ValidAtom(a_local_atom))
        return FALSE;

    atom_name = NameForAtom(a_local_atom);

    if (!atom_name)
        return FALSE;

    cookie = xcb_intern_atom(conn, FALSE, strlen(atom_name), atom_name);
    reply = xcb_intern_atom_reply(conn, cookie, NULL);
    if (!reply || reply->atom == None) {
        EPHYR_LOG_ERROR("no atom for string %s defined in host X\n", atom_name);
        return FALSE;
    }

    *a_host_atom = reply->atom;
    free(reply);

    return TRUE;
}

/**************
 *</helpers>
 * ************/

Bool
ephyrInitVideo(ScreenPtr pScreen)
{
    Bool is_ok = FALSE;

    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    static EphyrXVPriv *xv_priv;

    EPHYR_LOG("enter\n");

    if (screen->fb.bitsPerPixel == 8) {
        EPHYR_LOG_ERROR("8 bits depth not supported\n");
        return FALSE;
    }

    if (!xv_priv) {
        xv_priv = ephyrXVPrivNew();
    }
    if (!xv_priv) {
        EPHYR_LOG_ERROR("failed to create xv_priv\n");
        goto out;
    }

    if (!ephyrXVPrivRegisterAdaptors(xv_priv, pScreen)) {
        EPHYR_LOG_ERROR("failed to register adaptors\n");
        goto out;
    }
    is_ok = TRUE;

 out:
    return is_ok;
}

static EphyrXVPriv *
ephyrXVPrivNew(void)
{
    EphyrXVPriv *xv_priv = NULL;

    EPHYR_LOG("enter\n");

    xv_priv = calloc(1, sizeof(EphyrXVPriv));
    if (!xv_priv) {
        EPHYR_LOG_ERROR("failed to create EphyrXVPriv\n");
        goto error;
    }

    if (!ephyrXVPrivQueryHostAdaptors(xv_priv)) {
        EPHYR_LOG_ERROR("failed to query the host x for xv properties\n");
        goto error;
    }
    if (!ephyrXVPrivSetAdaptorsHooks(xv_priv)) {
        EPHYR_LOG_ERROR("failed to set xv_priv hooks\n");
        goto error;
    }

    EPHYR_LOG("leave\n");
    return xv_priv;

 error:
    if (xv_priv) {
        ephyrXVPrivDelete(xv_priv);
        xv_priv = NULL;
    }
    return NULL;
}

static void
ephyrXVPrivDelete(EphyrXVPriv * a_this)
{
    EPHYR_LOG("enter\n");

    if (!a_this)
        return;
    if (a_this->host_adaptors) {
        free(a_this->host_adaptors);
        a_this->host_adaptors = NULL;
    }
    free(a_this->adaptors);
    a_this->adaptors = NULL;
    free(a_this);
    EPHYR_LOG("leave\n");
}

static Bool
translate_video_encodings(KdVideoAdaptorPtr adaptor,
                          xcb_xv_adaptor_info_t *host_adaptor)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int i;
    xcb_xv_query_encodings_cookie_t cookie;
    xcb_xv_query_encodings_reply_t *reply;
    xcb_xv_encoding_info_iterator_t encoding_it;

    cookie = xcb_xv_query_encodings(conn, host_adaptor->base_id);
    reply = xcb_xv_query_encodings_reply(conn, cookie, NULL);
    if (!reply)
        return FALSE;

    adaptor->nEncodings = reply->num_encodings;
    adaptor->pEncodings = calloc(adaptor->nEncodings,
                                  sizeof(*adaptor->pEncodings));
    if (!adaptor->pEncodings) {
        free(reply);
        return FALSE;
    }

    encoding_it = xcb_xv_query_encodings_info_iterator(reply);
    for (i = 0; i < adaptor->nEncodings; i++) {
        xcb_xv_encoding_info_t *encoding_info = encoding_it.data;
        KdVideoEncodingPtr encoding = &adaptor->pEncodings[i];

        encoding->id = encoding_info->encoding;
        encoding->name = strndup(xcb_xv_encoding_info_name(encoding_info),
                                 encoding_info->name_size);
        encoding->width = encoding_info->width;
        encoding->height = encoding_info->height;
        encoding->rate.numerator = encoding_info->rate.numerator;
        encoding->rate.denominator = encoding_info->rate.denominator;

        xcb_xv_encoding_info_next(&encoding_it);
    }

    free(reply);
    return TRUE;
}

static Bool
translate_xv_attributes(KdVideoAdaptorPtr adaptor,
                        xcb_xv_adaptor_info_t *host_adaptor)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int i = 0;
    xcb_xv_attribute_info_iterator_t it;
    xcb_xv_query_port_attributes_cookie_t cookie =
        xcb_xv_query_port_attributes(conn, host_adaptor->base_id);
    xcb_xv_query_port_attributes_reply_t *reply =
        xcb_xv_query_port_attributes_reply(conn, cookie, NULL);

    if (!reply)
        return FALSE;

    adaptor->nAttributes = reply->num_attributes;
    adaptor->pAttributes = calloc(reply->num_attributes,
                                  sizeof(*adaptor->pAttributes));
    if (!adaptor->pAttributes) {
        EPHYR_LOG_ERROR("failed to allocate attributes\n");
        free(reply);
        return FALSE;
    }

    it = xcb_xv_query_port_attributes_attributes_iterator(reply);
    for (i = 0; i < reply->num_attributes; i++) {
        XvAttributePtr attribute = &adaptor->pAttributes[i];

        attribute->flags = it.data->flags;
        attribute->min_value = it.data->min;
        attribute->max_value = it.data->max;
        attribute->name = strndup(xcb_xv_attribute_info_name(it.data),
                                  it.data->size);

        /* make sure atoms of attrs names are created in xephyr */
        MakeAtom(xcb_xv_attribute_info_name(it.data), it.data->size, TRUE);

        xcb_xv_attribute_info_next(&it);
    }

    free(reply);
    return TRUE;
}

static Bool
translate_xv_image_formats(KdVideoAdaptorPtr adaptor,
                           xcb_xv_adaptor_info_t *host_adaptor)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int i = 0;
    xcb_xv_list_image_formats_cookie_t cookie =
        xcb_xv_list_image_formats(conn, host_adaptor->base_id);
    xcb_xv_list_image_formats_reply_t *reply =
        xcb_xv_list_image_formats_reply(conn, cookie, NULL);
    xcb_xv_image_format_info_t *formats;

    if (!reply)
        return FALSE;

    adaptor->nImages = reply->num_formats;
    adaptor->pImages = calloc(reply->num_formats, sizeof(XvImageRec));
    if (!adaptor->pImages) {
        free(reply);
        return FALSE;
    }

    formats = xcb_xv_list_image_formats_format(reply);
    for (i = 0; i < reply->num_formats; i++) {
        XvImagePtr image = &adaptor->pImages[i];

        image->id = formats[i].id;
        image->type = formats[i].type;
        image->byte_order = formats[i].byte_order;
        memcpy(image->guid, formats[i].guid, 16);
        image->bits_per_pixel = formats[i].bpp;
        image->format = formats[i].format;
        image->num_planes = formats[i].num_planes;
        image->depth = formats[i].depth;
        image->red_mask = formats[i].red_mask;
        image->green_mask = formats[i].green_mask;
        image->blue_mask = formats[i].blue_mask;
        image->y_sample_bits = formats[i].y_sample_bits;
        image->u_sample_bits = formats[i].u_sample_bits;
        image->v_sample_bits = formats[i].v_sample_bits;
        image->horz_y_period = formats[i].vhorz_y_period;
        image->horz_u_period = formats[i].vhorz_u_period;
        image->horz_v_period = formats[i].vhorz_v_period;
        image->vert_y_period = formats[i].vvert_y_period;
        image->vert_u_period = formats[i].vvert_u_period;
        image->vert_v_period = formats[i].vvert_v_period;
        memcpy(image->component_order, formats[i].vcomp_order, 32);
        image->scanline_order = formats[i].vscanline_order;
    }

    free(reply);
    return TRUE;
}

static Bool
ephyrXVPrivQueryHostAdaptors(EphyrXVPriv * a_this)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_screen_t *xscreen = xcb_aux_get_screen(conn, hostx_get_screen());
    int base_port_id = 0, i = 0, port_priv_offset = 0;
    Bool is_ok = FALSE;
    xcb_generic_error_t *e = NULL;
    xcb_xv_adaptor_info_iterator_t it;

    EPHYR_RETURN_VAL_IF_FAIL(a_this, FALSE);

    EPHYR_LOG("enter\n");

    {
        xcb_xv_query_adaptors_cookie_t cookie =
            xcb_xv_query_adaptors(conn, xscreen->root);
        a_this->host_adaptors = xcb_xv_query_adaptors_reply(conn, cookie, &e);
        if (e) {
            free(e);
            EPHYR_LOG_ERROR("failed to query host adaptors\n");
            goto out;
        }
    }

    if (a_this->host_adaptors)
        a_this->num_adaptors = a_this->host_adaptors->num_adaptors;
    if (a_this->num_adaptors < 0) {
        EPHYR_LOG_ERROR("failed to get number of host adaptors\n");
        goto out;
    }
    EPHYR_LOG("host has %d adaptors\n", a_this->num_adaptors);
    /*
     * copy what we can from adaptors into a_this->adaptors
     */
    if (a_this->num_adaptors) {
        a_this->adaptors = calloc(a_this->num_adaptors,
                                  sizeof(KdVideoAdaptorRec));
        if (!a_this->adaptors) {
            EPHYR_LOG_ERROR("failed to create internal adaptors\n");
            goto out;
        }
    }

    it = xcb_xv_query_adaptors_info_iterator(a_this->host_adaptors);
    for (i = 0; i < a_this->num_adaptors; i++) {
        xcb_xv_adaptor_info_t *cur_host_adaptor = it.data;
        xcb_xv_format_t *format = xcb_xv_adaptor_info_formats(cur_host_adaptor);
        int j = 0;

        a_this->adaptors[i].nPorts = cur_host_adaptor->num_ports;
        if (a_this->adaptors[i].nPorts <= 0) {
            EPHYR_LOG_ERROR("Could not find any port of adaptor %d\n", i);
            continue;
        }
        a_this->adaptors[i].type = cur_host_adaptor->type;
        a_this->adaptors[i].type |= XvWindowMask;
        a_this->adaptors[i].flags =
            VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
        a_this->adaptors[i].name =
            strndup(xcb_xv_adaptor_info_name(cur_host_adaptor),
                    cur_host_adaptor->name_size);
        if (!a_this->adaptors[i].name)
            a_this->adaptors[i].name = strdup("Xephyr Video Overlay");
        base_port_id = cur_host_adaptor->base_id;
        if (base_port_id < 0) {
            EPHYR_LOG_ERROR("failed to get port id for adaptor %d\n", i);
            continue;
        }
        if (!s_base_port_id)
            s_base_port_id = base_port_id;

        if (!translate_video_encodings(&a_this->adaptors[i],
                                       cur_host_adaptor)) {
            EPHYR_LOG_ERROR("failed to get encodings for port port id %d,"
                            " adaptors %d\n", base_port_id, i);
            continue;
        }

        a_this->adaptors[i].nFormats = cur_host_adaptor->num_formats;
        a_this->adaptors[i].pFormats =
            calloc(cur_host_adaptor->num_formats,
                   sizeof(*a_this->adaptors[i].pFormats));
        for (j = 0; j < cur_host_adaptor->num_formats; j++) {
            xcb_visualtype_t *visual =
                xcb_aux_find_visual_by_id(xscreen, format[j].visual);
            a_this->adaptors[i].pFormats[j].depth = format[j].depth;
            a_this->adaptors[i].pFormats[j].class = visual->_class;
        }

        a_this->adaptors[i].pPortPrivates =
            calloc(a_this->adaptors[i].nPorts,
                   sizeof(DevUnion) + sizeof(EphyrPortPriv));
        port_priv_offset = a_this->adaptors[i].nPorts;
        for (j = 0; j < a_this->adaptors[i].nPorts; j++) {
            EphyrPortPriv *port_privs_base =
                (EphyrPortPriv *) &a_this->adaptors[i].
                pPortPrivates[port_priv_offset];
            EphyrPortPriv *port_priv = &port_privs_base[j];

            port_priv->port_number = base_port_id + j;
            port_priv->current_adaptor = &a_this->adaptors[i];
            port_priv->xv_priv = a_this;
            a_this->adaptors[i].pPortPrivates[j].ptr = port_priv;
        }

        if (!translate_xv_attributes(&a_this->adaptors[i], cur_host_adaptor)) {
        {
            EPHYR_LOG_ERROR("failed to get port attribute "
                            "for adaptor %d\n", i);
            continue;
        }
        }

        if (!translate_xv_image_formats(&a_this->adaptors[i], cur_host_adaptor)) {
            EPHYR_LOG_ERROR("failed to get image formats "
                            "for adaptor %d\n", i);
            continue;
        }

        xcb_xv_adaptor_info_next(&it);
    }
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static Bool
ephyrXVPrivSetAdaptorsHooks(EphyrXVPriv * a_this)
{
    int i = 0;
    xcb_xv_adaptor_info_iterator_t it;

    EPHYR_RETURN_VAL_IF_FAIL(a_this, FALSE);

    EPHYR_LOG("enter\n");

    it = xcb_xv_query_adaptors_info_iterator(a_this->host_adaptors);
    for (i = 0; i < a_this->num_adaptors; i++) {
        xcb_xv_adaptor_info_t *cur_host_adaptor = it.data;

        a_this->adaptors[i].ReputImage = ephyrReputImage;
        a_this->adaptors[i].StopVideo = ephyrStopVideo;
        a_this->adaptors[i].SetPortAttribute = ephyrSetPortAttribute;
        a_this->adaptors[i].GetPortAttribute = ephyrGetPortAttribute;
        a_this->adaptors[i].QueryBestSize = ephyrQueryBestSize;
        a_this->adaptors[i].QueryImageAttributes = ephyrQueryImageAttributes;

        if (adaptor_has_flags(cur_host_adaptor,
                              XCB_XV_TYPE_IMAGE_MASK | XCB_XV_TYPE_INPUT_MASK))
            a_this->adaptors[i].PutImage = ephyrPutImage;

        if (adaptor_has_flags(cur_host_adaptor,
                              XCB_XV_TYPE_VIDEO_MASK | XCB_XV_TYPE_INPUT_MASK))
            a_this->adaptors[i].PutVideo = ephyrPutVideo;

        if (adaptor_has_flags(cur_host_adaptor,
                              XCB_XV_TYPE_VIDEO_MASK | XCB_XV_TYPE_OUTPUT_MASK))
            a_this->adaptors[i].GetVideo = ephyrGetVideo;

        if (adaptor_has_flags(cur_host_adaptor,
                              XCB_XV_TYPE_STILL_MASK | XCB_XV_TYPE_INPUT_MASK))
            a_this->adaptors[i].PutStill = ephyrPutStill;

        if (adaptor_has_flags(cur_host_adaptor,
                              XCB_XV_TYPE_STILL_MASK | XCB_XV_TYPE_OUTPUT_MASK))
            a_this->adaptors[i].GetStill = ephyrGetStill;
    }
    EPHYR_LOG("leave\n");
    return TRUE;
}

static Bool
ephyrXVPrivRegisterAdaptors(EphyrXVPriv * a_this, ScreenPtr a_screen)
{
    Bool is_ok = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(a_this && a_screen, FALSE);

    EPHYR_LOG("enter\n");

    if (!a_this->num_adaptors)
        goto out;

    if (!KdXVScreenInit(a_screen, a_this->adaptors, a_this->num_adaptors)) {
        EPHYR_LOG_ERROR("failed to register adaptors\n");
        goto out;
    }
    EPHYR_LOG("there are  %d registered adaptors\n", a_this->num_adaptors);
    is_ok = TRUE;

 out:

    EPHYR_LOG("leave\n");
    return is_ok;
}

static Bool
ephyrXVPrivIsAttrValueValid(XvAttributePtr a_attrs,
                            int a_attrs_len,
                            const char *a_attr_name,
                            int a_attr_value, Bool *a_is_valid)
{
    int i = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_attrs && a_attr_name && a_is_valid, FALSE);

    for (i = 0; i < a_attrs_len; i++) {
        if (a_attrs[i].name && strcmp(a_attrs[i].name, a_attr_name))
            continue;
        if (a_attrs[i].min_value > a_attr_value ||
            a_attrs[i].max_value < a_attr_value) {
            *a_is_valid = FALSE;
            EPHYR_LOG_ERROR("attribute was not valid\n"
                            "value:%d. min:%d. max:%d\n",
                            a_attr_value,
                            a_attrs[i].min_value, a_attrs[i].max_value);
        }
        else {
            *a_is_valid = TRUE;
        }
        return TRUE;
    }
    return FALSE;
}

static Bool
ephyrXVPrivGetImageBufSize(int a_port_id,
                           int a_image_id,
                           unsigned short a_width,
                           unsigned short a_height, int *a_size)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_xv_query_image_attributes_cookie_t cookie;
    xcb_xv_query_image_attributes_reply_t *reply;
    Bool is_ok = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(a_size, FALSE);

    EPHYR_LOG("enter\n");

    cookie = xcb_xv_query_image_attributes(conn,
                                           a_port_id, a_image_id,
                                           a_width, a_height);
    reply = xcb_xv_query_image_attributes_reply(conn, cookie, NULL);
    if (!reply)
        goto out;

    *a_size = reply->data_size;
    is_ok = TRUE;

    free(reply);

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static Bool
ephyrXVPrivSaveImageToPortPriv(EphyrPortPriv * a_port_priv,
                               const unsigned char *a_image_buf,
                               int a_image_len)
{
    Bool is_ok = FALSE;

    EPHYR_LOG("enter\n");

    if (a_port_priv->image_buf_size < a_image_len) {
        unsigned char *buf = NULL;

        buf = realloc(a_port_priv->image_buf, a_image_len);
        if (!buf) {
            EPHYR_LOG_ERROR("failed to realloc image buffer\n");
            goto out;
        }
        a_port_priv->image_buf = buf;
        a_port_priv->image_buf_size = a_image_len;
    }
    memmove(a_port_priv->image_buf, a_image_buf, a_image_len);
    is_ok = TRUE;

 out:
    return is_ok;
    EPHYR_LOG("leave\n");
}

static void
ephyrStopVideo(KdScreenInfo * a_info, void *a_port_priv, Bool a_exit)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    EphyrPortPriv *port_priv = a_port_priv;
    EphyrScrPriv *scrpriv = a_info->driver;

    EPHYR_RETURN_IF_FAIL(port_priv);

    EPHYR_LOG("enter\n");
    xcb_xv_stop_video(conn, port_priv->port_number, scrpriv->win);
    EPHYR_LOG("leave\n");
}

static int
ephyrSetPortAttribute(KdScreenInfo * a_info,
                      Atom a_attr_name, int a_attr_value, void *a_port_priv)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int res = Success, host_atom = 0;
    EphyrPortPriv *port_priv = a_port_priv;
    Bool is_attr_valid = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(port_priv, BadMatch);
    EPHYR_RETURN_VAL_IF_FAIL(port_priv->current_adaptor, BadMatch);
    EPHYR_RETURN_VAL_IF_FAIL(port_priv->current_adaptor->pAttributes, BadMatch);
    EPHYR_RETURN_VAL_IF_FAIL(port_priv->current_adaptor->nAttributes, BadMatch);
    EPHYR_RETURN_VAL_IF_FAIL(ValidAtom(a_attr_name), BadMatch);

    EPHYR_LOG("enter, portnum:%d, atomid:%d, attr_name:%s, attr_val:%d\n",
              port_priv->port_number,
              (int) a_attr_name, NameForAtom(a_attr_name), a_attr_value);

    if (!ephyrLocalAtomToHost(a_attr_name, &host_atom)) {
        EPHYR_LOG_ERROR("failed to convert local atom to host atom\n");
        res = BadMatch;
        goto out;
    }

    if (!ephyrXVPrivIsAttrValueValid(port_priv->current_adaptor->pAttributes,
                                     port_priv->current_adaptor->nAttributes,
                                     NameForAtom(a_attr_name),
                                     a_attr_value, &is_attr_valid)) {
        EPHYR_LOG_ERROR("failed to validate attribute %s\n",
                        NameForAtom(a_attr_name));
        /*
           res = BadMatch ;
           goto out ;
         */
    }
    if (!is_attr_valid) {
        EPHYR_LOG_ERROR("attribute %s is not valid\n",
                        NameForAtom(a_attr_name));
        /*
           res = BadMatch ;
           goto out ;
         */
    }

    xcb_xv_set_port_attribute(conn, port_priv->port_number,
                              host_atom, a_attr_value);
    xcb_flush(conn);

    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

static int
ephyrGetPortAttribute(KdScreenInfo * a_screen_info,
                      Atom a_attr_name, int *a_attr_value, void *a_port_priv)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    int res = Success, host_atom = 0;
    EphyrPortPriv *port_priv = a_port_priv;
    xcb_generic_error_t *e;
    xcb_xv_get_port_attribute_cookie_t cookie;
    xcb_xv_get_port_attribute_reply_t *reply;

    EPHYR_RETURN_VAL_IF_FAIL(port_priv, BadMatch);
    EPHYR_RETURN_VAL_IF_FAIL(ValidAtom(a_attr_name), BadMatch);

    EPHYR_LOG("enter, portnum:%d, atomid:%d, attr_name:%s\n",
              port_priv->port_number,
              (int) a_attr_name, NameForAtom(a_attr_name));

    if (!ephyrLocalAtomToHost(a_attr_name, &host_atom)) {
        EPHYR_LOG_ERROR("failed to convert local atom to host atom\n");
        res = BadMatch;
        goto out;
    }

    cookie = xcb_xv_get_port_attribute(conn, port_priv->port_number, host_atom);
    reply = xcb_xv_get_port_attribute_reply(conn, cookie, &e);
    if (e) {
        EPHYR_LOG_ERROR ("XvGetPortAttribute() failed: %d \n", e->error_code);
        free(e);
        res = BadMatch;
        goto out;
    }
    *a_attr_value = reply->value;

    free(reply);

    res = Success;
 out:
    EPHYR_LOG("leave\n");
    return res;
}

static void
ephyrQueryBestSize(KdScreenInfo * a_info,
                   Bool a_motion,
                   short a_src_w,
                   short a_src_h,
                   short a_drw_w,
                   short a_drw_h,
                   unsigned int *a_prefered_w,
                   unsigned int *a_prefered_h, void *a_port_priv)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    EphyrPortPriv *port_priv = a_port_priv;
    xcb_xv_query_best_size_cookie_t cookie =
        xcb_xv_query_best_size(conn,
                               port_priv->port_number,
                               a_src_w, a_src_h,
                               a_drw_w, a_drw_h,
                               a_motion);
    xcb_xv_query_best_size_reply_t *reply =
        xcb_xv_query_best_size_reply(conn, cookie, NULL);

    EPHYR_LOG("enter: frame (%dx%d), drw (%dx%d)\n",
              a_src_w, a_src_h, a_drw_w, a_drw_h);

    if (!reply) {
        EPHYR_LOG_ERROR ("XvQueryBestSize() failed\n");
        return;
    }
    *a_prefered_w = reply->actual_width;
    *a_prefered_h = reply->actual_height;
    EPHYR_LOG("actual (%dx%d)\n", *a_prefered_w, *a_prefered_h);
    free(reply);

    EPHYR_LOG("leave\n");
}


static Bool
ephyrHostXVPutImage(KdScreenInfo * a_info,
                    EphyrPortPriv *port_priv,
                    int a_image_id,
                    int a_drw_x,
                    int a_drw_y,
                    int a_drw_w,
                    int a_drw_h,
                    int a_src_x,
                    int a_src_y,
                    int a_src_w,
                    int a_src_h,
                    int a_image_width,
                    int a_image_height,
                    unsigned char *a_buf,
                    BoxPtr a_clip_rects, int a_clip_rect_nums)
{
    EphyrScrPriv *scrpriv = a_info->driver;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_gcontext_t gc;
    Bool is_ok = TRUE;
    xcb_rectangle_t *rects = NULL;
    int data_len, width, height;
    xcb_xv_query_image_attributes_cookie_t image_attr_cookie;
    xcb_xv_query_image_attributes_reply_t *image_attr_reply;

    EPHYR_RETURN_VAL_IF_FAIL(a_buf, FALSE);

    EPHYR_LOG("enter, num_clip_rects: %d\n", a_clip_rect_nums);

    image_attr_cookie = xcb_xv_query_image_attributes(conn,
                                                      port_priv->port_number,
                                                      a_image_id,
                                                      a_image_width,
                                                      a_image_height);
    image_attr_reply = xcb_xv_query_image_attributes_reply(conn,
                                                           image_attr_cookie,
                                                           NULL);
    if (!image_attr_reply)
        goto out;
    data_len = image_attr_reply->data_size;
    width = image_attr_reply->width;
    height = image_attr_reply->height;
    free(image_attr_reply);

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, scrpriv->win, 0, NULL);

    if (a_clip_rect_nums) {
        int i = 0;
        rects = calloc(a_clip_rect_nums, sizeof(xcb_rectangle_t));
        for (i=0; i < a_clip_rect_nums; i++) {
            rects[i].x = a_clip_rects[i].x1;
            rects[i].y = a_clip_rects[i].y1;
            rects[i].width = a_clip_rects[i].x2 - a_clip_rects[i].x1;
            rects[i].height = a_clip_rects[i].y2 - a_clip_rects[i].y1;
            EPHYR_LOG("(x,y,w,h): (%d,%d,%d,%d)\n",
                      rects[i].x, rects[i].y, rects[i].width, rects[i].height);
        }
        xcb_set_clip_rectangles(conn,
                                XCB_CLIP_ORDERING_YX_BANDED,
                                gc,
                                0,
                                0,
                                a_clip_rect_nums,
                                rects);
	free(rects);
    }
    xcb_xv_put_image(conn,
                     port_priv->port_number,
                     scrpriv->win,
                     gc,
                     a_image_id,
                     a_src_x, a_src_y, a_src_w, a_src_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h,
                     width, height,
                     data_len, a_buf);
    xcb_free_gc(conn, gc);

    is_ok = TRUE;

out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static int
ephyrPutImage(KdScreenInfo * a_info,
              DrawablePtr a_drawable,
              short a_src_x,
              short a_src_y,
              short a_drw_x,
              short a_drw_y,
              short a_src_w,
              short a_src_h,
              short a_drw_w,
              short a_drw_h,
              int a_id,
              unsigned char *a_buf,
              short a_width,
              short a_height,
              Bool a_sync, RegionPtr a_clipping_region, void *a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv;
    Bool is_ok = FALSE;
    int result = BadImplementation, image_size = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_info && a_info->pScreen, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(a_drawable, BadValue);

    EPHYR_LOG("enter\n");

    if (!ephyrHostXVPutImage(a_info, port_priv,
                             a_id,
                             a_drw_x, a_drw_y, a_drw_w, a_drw_h,
                             a_src_x, a_src_y, a_src_w, a_src_h,
                             a_width, a_height, a_buf,
                             RegionRects(a_clipping_region),
                             RegionNumRects(a_clipping_region))) {
        EPHYR_LOG_ERROR("EphyrHostXVPutImage() failed\n");
        goto out;
    }

    /*
     * Now save the image so that we can resend it to host it
     * later, in ReputImage.
     */
    if (!ephyrXVPrivGetImageBufSize(port_priv->port_number,
                                    a_id, a_width, a_height, &image_size)) {
        EPHYR_LOG_ERROR("failed to get image size\n");
        /*this is a minor error so we won't get bail out abruptly */
        is_ok = FALSE;
    }
    else {
        is_ok = TRUE;
    }
    if (is_ok) {
        if (!ephyrXVPrivSaveImageToPortPriv(port_priv, a_buf, image_size)) {
            is_ok = FALSE;
        }
        else {
            port_priv->image_id = a_id;
            port_priv->drw_x = a_drw_x;
            port_priv->drw_y = a_drw_y;
            port_priv->drw_w = a_drw_w;
            port_priv->drw_h = a_drw_h;
            port_priv->src_x = a_src_x;
            port_priv->src_y = a_src_y;
            port_priv->src_w = a_src_w;
            port_priv->src_h = a_src_h;
            port_priv->image_width = a_width;
            port_priv->image_height = a_height;
        }
    }
    if (!is_ok) {
        if (port_priv->image_buf) {
            free(port_priv->image_buf);
            port_priv->image_buf = NULL;
            port_priv->image_buf_size = 0;
        }
    }

    result = Success;

 out:
    EPHYR_LOG("leave\n");
    return result;
}

static int
ephyrReputImage(KdScreenInfo * a_info,
                DrawablePtr a_drawable,
                short a_drw_x,
                short a_drw_y, RegionPtr a_clipping_region, void *a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv;
    int result = BadImplementation;

    EPHYR_RETURN_VAL_IF_FAIL(a_info->pScreen, FALSE);
    EPHYR_RETURN_VAL_IF_FAIL(a_drawable && port_priv, BadValue);

    EPHYR_LOG("enter\n");

    if (!port_priv->image_buf_size || !port_priv->image_buf) {
        EPHYR_LOG_ERROR("has null image buf in cache\n");
        goto out;
    }
    if (!ephyrHostXVPutImage(a_info,
                             port_priv,
                             port_priv->image_id,
                             a_drw_x, a_drw_y,
                             port_priv->drw_w, port_priv->drw_h,
                             port_priv->src_x, port_priv->src_y,
                             port_priv->src_w, port_priv->src_h,
                             port_priv->image_width, port_priv->image_height,
                             port_priv->image_buf,
                             RegionRects(a_clipping_region),
                             RegionNumRects(a_clipping_region))) {
        EPHYR_LOG_ERROR("ephyrHostXVPutImage() failed\n");
        goto out;
    }

    result = Success;

 out:
    EPHYR_LOG("leave\n");
    return result;
}

static int
ephyrPutVideo(KdScreenInfo * a_info,
              DrawablePtr a_drawable,
              short a_vid_x, short a_vid_y,
              short a_drw_x, short a_drw_y,
              short a_vid_w, short a_vid_h,
              short a_drw_w, short a_drw_h,
              RegionPtr a_clipping_region, void *a_port_priv)
{
    EphyrScrPriv *scrpriv = a_info->driver;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_gcontext_t gc;
    EphyrPortPriv *port_priv = a_port_priv;

    EPHYR_RETURN_VAL_IF_FAIL(a_info->pScreen, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(a_drawable && port_priv, BadValue);

    EPHYR_LOG("enter\n");

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, scrpriv->win, 0, NULL);
    xcb_xv_put_video(conn, port_priv->port_number,
                     scrpriv->win, gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);
    xcb_free_gc(conn, gc);

    EPHYR_LOG("leave\n");
    return Success;
}

static int
ephyrGetVideo(KdScreenInfo * a_info,
              DrawablePtr a_drawable,
              short a_vid_x, short a_vid_y,
              short a_drw_x, short a_drw_y,
              short a_vid_w, short a_vid_h,
              short a_drw_w, short a_drw_h,
              RegionPtr a_clipping_region, void *a_port_priv)
{
    EphyrScrPriv *scrpriv = a_info->driver;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_gcontext_t gc;
    EphyrPortPriv *port_priv = a_port_priv;

    EPHYR_RETURN_VAL_IF_FAIL(a_info && a_info->pScreen, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(a_drawable && port_priv, BadValue);

    EPHYR_LOG("enter\n");

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, scrpriv->win, 0, NULL);
    xcb_xv_get_video(conn, port_priv->port_number,
                     scrpriv->win, gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);

    xcb_free_gc(conn, gc);

    EPHYR_LOG("leave\n");
    return Success;
}

static int
ephyrPutStill(KdScreenInfo * a_info,
              DrawablePtr a_drawable,
              short a_vid_x, short a_vid_y,
              short a_drw_x, short a_drw_y,
              short a_vid_w, short a_vid_h,
              short a_drw_w, short a_drw_h,
              RegionPtr a_clipping_region, void *a_port_priv)
{
    EphyrScrPriv *scrpriv = a_info->driver;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_gcontext_t gc;
    EphyrPortPriv *port_priv = a_port_priv;

    EPHYR_RETURN_VAL_IF_FAIL(a_info && a_info->pScreen, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(a_drawable && port_priv, BadValue);

    EPHYR_LOG("enter\n");

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, scrpriv->win, 0, NULL);
    xcb_xv_put_still(conn, port_priv->port_number,
                     scrpriv->win, gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);
    xcb_free_gc(conn, gc);

    EPHYR_LOG("leave\n");
    return Success;
}

static int
ephyrGetStill(KdScreenInfo * a_info,
              DrawablePtr a_drawable,
              short a_vid_x, short a_vid_y,
              short a_drw_x, short a_drw_y,
              short a_vid_w, short a_vid_h,
              short a_drw_w, short a_drw_h,
              RegionPtr a_clipping_region, void *a_port_priv)
{
    EphyrScrPriv *scrpriv = a_info->driver;
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_gcontext_t gc;
    EphyrPortPriv *port_priv = a_port_priv;

    EPHYR_RETURN_VAL_IF_FAIL(a_info && a_info->pScreen, BadValue);
    EPHYR_RETURN_VAL_IF_FAIL(a_drawable && port_priv, BadValue);

    EPHYR_LOG("enter\n");

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, scrpriv->win, 0, NULL);
    xcb_xv_get_still(conn, port_priv->port_number,
                     scrpriv->win, gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);
    xcb_free_gc(conn, gc);

    EPHYR_LOG("leave\n");
    return Success;
}

static int
ephyrQueryImageAttributes(KdScreenInfo * a_info,
                          int a_id,
                          unsigned short *a_w,
                          unsigned short *a_h, int *a_pitches, int *a_offsets)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_xv_query_image_attributes_cookie_t cookie;
    xcb_xv_query_image_attributes_reply_t *reply;
    int image_size = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_w && a_h, FALSE);

    EPHYR_LOG("enter: dim (%dx%d), pitches: %p, offsets: %p\n",
              *a_w, *a_h, a_pitches, a_offsets);

    cookie = xcb_xv_query_image_attributes(conn,
                                           s_base_port_id, a_id,
                                           *a_w, *a_h);
    reply = xcb_xv_query_image_attributes_reply(conn, cookie, NULL);
    if (!reply)
        goto out;

    *a_w = reply->width;
    *a_h = reply->height;
    if (a_pitches && a_offsets) {
        memcpy(a_pitches, xcb_xv_query_image_attributes_pitches(reply),
               reply->num_planes << 2);
        memcpy(a_offsets, xcb_xv_query_image_attributes_offsets(reply),
               reply->num_planes << 2);
    }
    image_size = reply->data_size;

    free(reply);

    EPHYR_LOG("image size: %d, dim (%dx%d)\n", image_size, *a_w, *a_h);

 out:
    EPHYR_LOG("leave\n");
    return image_size;
}
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d4 2
a5 2
 * 
 * Copyright © 2007 OpenedHand Ltd 
d72 1
a72 1
static Bool ephyrXVPrivIsAttrValueValid(KdAttributePtr a_attrs,
d366 1
a366 1
        KdAttributePtr attribute = &adaptor->pAttributes[i];
d400 1
a400 1
    adaptor->pImages = calloc(reply->num_formats, sizeof(KdImageRec));
d408 1
a408 1
        KdImagePtr image = &adaptor->pImages[i];
a614 2
    KdScreenPriv(a_screen);
    KdScreenInfo *screen = pScreenPriv->screen;
a615 2
    KdVideoAdaptorPtr *adaptors = NULL, *registered_adaptors = NULL;
    int num_registered_adaptors = 0, i = 0, num_adaptors = 0;
a622 2
    num_registered_adaptors =
        KdXVListGenericAdaptors(screen, &registered_adaptors);
d624 1
a624 11
    num_adaptors = num_registered_adaptors + a_this->num_adaptors;
    adaptors = calloc(num_adaptors, sizeof(KdVideoAdaptorPtr));
    if (!adaptors) {
        EPHYR_LOG_ERROR("failed to allocate adaptors tab\n");
        goto out;
    }
    memmove(adaptors, registered_adaptors, num_registered_adaptors);
    for (i = 0; i < a_this->num_adaptors; i++) {
        *(adaptors + num_registered_adaptors + i) = &a_this->adaptors[i];
    }
    if (!KdXVScreenInit(a_screen, adaptors, num_adaptors)) {
d628 1
a628 1
    EPHYR_LOG("there are  %d registered adaptors\n", num_adaptors);
a631 4
    free(registered_adaptors);
    registered_adaptors = NULL;
    free(adaptors);
    adaptors = NULL;
d638 1
a638 1
ephyrXVPrivIsAttrValueValid(KdAttributePtr a_attrs,
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d87 1
a87 1
                           pointer a_xv_priv, Bool a_exit);
d91 1
a91 1
                                 int a_attr_value, pointer a_port_priv);
d95 1
a95 1
                                 int *a_attr_value, pointer a_port_priv);
d104 1
a104 1
                               unsigned int *a_prefered_h, pointer a_port_priv);
d121 1
a121 1
                         RegionPtr a_clipping_region, pointer a_port_priv);
d127 1
a127 1
                           RegionPtr a_clipping_region, pointer a_port_priv);
d135 1
a135 1
                         RegionPtr a_clip_region, pointer a_port_priv);
d143 1
a143 1
                         RegionPtr a_clip_region, pointer a_port_priv);
d151 1
a151 1
                         RegionPtr a_clip_region, pointer a_port_priv);
d159 1
a159 1
                         RegionPtr a_clip_region, pointer a_port_priv);
d747 1
a747 1
ephyrStopVideo(KdScreenInfo * a_info, pointer a_port_priv, Bool a_exit)
d762 1
a762 1
                      Atom a_attr_name, int a_attr_value, pointer a_port_priv)
d817 1
a817 1
                      Atom a_attr_name, int *a_attr_value, pointer a_port_priv)
d865 1
a865 1
                   unsigned int *a_prefered_h, pointer a_port_priv)
d995 1
a995 1
              Bool a_sync, RegionPtr a_clipping_region, pointer a_port_priv)
d1067 1
a1067 1
                short a_drw_y, RegionPtr a_clipping_region, pointer a_port_priv)
d1110 1
a1110 1
              RegionPtr a_clipping_region, pointer a_port_priv)
d1141 1
a1141 1
              RegionPtr a_clipping_region, pointer a_port_priv)
d1173 1
a1173 1
              RegionPtr a_clipping_region, pointer a_port_priv)
d1204 1
a1204 1
              RegionPtr a_clipping_region, pointer a_port_priv)
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d34 3
a41 1
#include "ephyrhostvideo.h"
d44 1
a44 1
    EphyrHostXVAdaptorArray *host_adaptors;
a62 2
static Bool DoSimpleClip(BoxPtr a_dst_drw, BoxPtr a_clipper, BoxPtr a_result);

a64 4
/*
static Bool ephyrHostAtomToLocal (int a_host_atom, int *a_local_atom) ;
*/

d173 1
a173 1
DoSimpleClip(BoxPtr a_dst_box, BoxPtr a_clipper, BoxPtr a_result)
d175 1
a175 38
    BoxRec dstClippedBox;

    EPHYR_RETURN_VAL_IF_FAIL(a_dst_box && a_clipper && a_result, FALSE);

    /*
     * setup the clipbox inside the destination.
     */
    dstClippedBox.x1 = a_dst_box->x1;
    dstClippedBox.x2 = a_dst_box->x2;
    dstClippedBox.y1 = a_dst_box->y1;
    dstClippedBox.y2 = a_dst_box->y2;

    /*
     * if the cliper leftmost edge is inside
     * the destination area then the leftmost edge of the resulting
     * clipped box is the leftmost edge of the cliper.
     */
    if (a_clipper->x1 > dstClippedBox.x1)
        dstClippedBox.x1 = a_clipper->x1;

    /*
     * if the cliper top edge is inside the destination area
     * then the bottom horizontal edge of the resulting clipped box
     * is the bottom edge of the cliper
     */
    if (a_clipper->y1 > dstClippedBox.y1)
        dstClippedBox.y1 = a_clipper->y1;

    /*ditto for right edge */
    if (a_clipper->x2 < dstClippedBox.x2)
        dstClippedBox.x2 = a_clipper->x2;

    /*ditto for bottom edge */
    if (a_clipper->y2 < dstClippedBox.y2)
        dstClippedBox.y2 = a_clipper->y2;

    memcpy(a_result, &dstClippedBox, sizeof(dstClippedBox));
    return TRUE;
d181 3
a184 1
    int host_atom = None;
d196 3
a198 1
    if (!ephyrHostGetAtom(atom_name, FALSE, &host_atom) || host_atom == None) {
a201 3
    *a_host_atom = host_atom;
    return TRUE;
}
d203 2
a204 8
/*
 Not used yed.
static Bool
ephyrHostAtomToLocal (int a_host_atom, int *a_local_atom)
{
    Bool is_ok=FALSE ;
    char *atom_name=NULL ;
    int atom=None ;
d206 1
a206 18
    EPHYR_RETURN_VAL_IF_FAIL (a_local_atom, FALSE) ;

    atom_name = ephyrHostGetAtomName (a_host_atom) ;
    if (!atom_name)
        goto out ;

    atom = MakeAtom (atom_name, strlen (atom_name), TRUE) ;
    if (atom == None)
        goto out ;

    *a_local_atom = atom ;
    is_ok = TRUE ;

out:
    if (atom_name) {
        ephyrHostFree (atom_name) ;
    }
    return is_ok ;
a207 1
*/
a259 2
    ephyrHostXVInit();

d288 1
a288 1
        ephyrHostXVAdaptorArrayDelete(a_this->host_adaptors);
d297 46
a342 2
static KdVideoEncodingPtr
videoEncodingDup(EphyrHostEncoding * a_encodings, int a_num_encodings)
d344 1
a344 1
    KdVideoEncodingPtr result = NULL;
d346 5
d352 2
a353 1
    EPHYR_RETURN_VAL_IF_FAIL(a_encodings && a_num_encodings, NULL);
d355 7
a361 8
    result = calloc(a_num_encodings, sizeof(KdVideoEncodingRec));
    for (i = 0; i < a_num_encodings; i++) {
        result[i].id = a_encodings[i].id;
        result[i].name = strdup(a_encodings[i].name);
        result[i].width = a_encodings[i].width;
        result[i].height = a_encodings[i].height;
        result[i].rate.numerator = a_encodings[i].rate.numerator;
        result[i].rate.denominator = a_encodings[i].rate.denominator;
d363 19
a381 1
    return result;
d384 3
a386 2
static KdAttributePtr
portAttributesDup(EphyrHostAttribute * a_encodings, int a_num_encodings)
d388 1
d390 5
a394 1
    KdAttributePtr result = NULL;
d396 2
a397 1
    EPHYR_RETURN_VAL_IF_FAIL(a_encodings && a_num_encodings, NULL);
d399 5
a403 4
    result = calloc(a_num_encodings, sizeof(KdAttributeRec));
    if (!result) {
        EPHYR_LOG_ERROR("failed to allocate attributes\n");
        return NULL;
d405 27
a431 5
    for (i = 0; i < a_num_encodings; i++) {
        result[i].flags = a_encodings[i].flags;
        result[i].min_value = a_encodings[i].min_value;
        result[i].max_value = a_encodings[i].max_value;
        result[i].name = strdup(a_encodings[i].name);
d433 3
a435 1
    return result;
d441 3
a443 8
    EphyrHostXVAdaptor *cur_host_adaptor = NULL;
    EphyrHostVideoFormat *video_formats = NULL;
    EphyrHostEncoding *encodings = NULL;
    EphyrHostAttribute *attributes = NULL;
    EphyrHostImageFormat *image_formats = NULL;
    int num_video_formats = 0, base_port_id = 0,
        num_attributes = 0, num_formats = 0, i = 0, port_priv_offset = 0;
    unsigned num_encodings = 0;
d445 2
d452 9
a460 3
    if (!ephyrHostXVQueryAdaptors(&a_this->host_adaptors)) {
        EPHYR_LOG_ERROR("failed to query host adaptors\n");
        goto out;
d462 1
d464 1
a464 2
        a_this->num_adaptors =
            ephyrHostXVAdaptorArrayGetSize(a_this->host_adaptors);
d481 2
d484 2
d488 1
a488 5
        cur_host_adaptor = ephyrHostXVAdaptorArrayAt(a_this->host_adaptors, i);
        if (!cur_host_adaptor)
            continue;
        a_this->adaptors[i].nPorts =
            ephyrHostXVAdaptorGetNbPorts(cur_host_adaptor);
d493 1
a493 1
        a_this->adaptors[i].type = ephyrHostXVAdaptorGetType(cur_host_adaptor);
d497 4
a500 4
        if (ephyrHostXVAdaptorGetName(cur_host_adaptor))
            a_this->adaptors[i].name =
                strdup(ephyrHostXVAdaptorGetName(cur_host_adaptor));
        else
d502 1
a502 1
        base_port_id = ephyrHostXVAdaptorGetFirstPortID(cur_host_adaptor);
d510 2
a511 2
        if (!ephyrHostXVQueryEncodings(base_port_id,
                                       &encodings, &num_encodings)) {
d516 12
a527 12
        a_this->adaptors[i].nEncodings = num_encodings;
        a_this->adaptors[i].pEncodings =
            videoEncodingDup(encodings, num_encodings);
        video_formats = (EphyrHostVideoFormat *)
            ephyrHostXVAdaptorGetVideoFormats(cur_host_adaptor,
                                              &num_video_formats);
        a_this->adaptors[i].pFormats = (KdVideoFormatPtr) video_formats;
        a_this->adaptors[i].nFormats = num_video_formats;
        /* got a_this->adaptors[i].nPorts already
           a_this->adaptors[i].nPorts =
           ephyrHostXVAdaptorGetNbPorts (cur_host_adaptor) ;
         */
d543 3
a545 2
        if (!ephyrHostXVQueryPortAttributes(base_port_id,
                                            &attributes, &num_attributes)) {
a549 8
        a_this->adaptors[i].pAttributes =
            portAttributesDup(attributes, num_attributes);
        a_this->adaptors[i].nAttributes = num_attributes;
        /*make sure atoms of attrs names are created in xephyr */
        for (j = 0; j < a_this->adaptors[i].nAttributes; j++) {
            if (a_this->adaptors[i].pAttributes[j].name)
                MakeAtom(a_this->adaptors[i].pAttributes[j].name,
                         strlen(a_this->adaptors[i].pAttributes[j].name), TRUE);
d551 2
a552 2
        if (!ephyrHostXVQueryImageFormats(base_port_id,
                                          &image_formats, &num_formats)) {
d557 2
a558 2
        a_this->adaptors[i].pImages = (KdImagePtr) image_formats;
        a_this->adaptors[i].nImages = num_formats;
a562 8
    if (encodings) {
        ephyrHostEncodingsDelete(encodings, num_encodings);
        encodings = NULL;
    }
    if (attributes) {
        ephyrHostAttributesDelete(attributes);
        attributes = NULL;
    }
d571 1
a571 2
    Bool has_it = FALSE;
    EphyrHostXVAdaptor *cur_host_adaptor = NULL;
d577 1
d579 2
d588 2
a589 10
        cur_host_adaptor = ephyrHostXVAdaptorArrayAt(a_this->host_adaptors, i);
        if (!cur_host_adaptor) {
            EPHYR_LOG_ERROR("failed to get host adaptor at index %d\n", i);
            continue;
        }
        has_it = FALSE;
        if (!ephyrHostXVAdaptorHasPutImage(cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR("error\n");
        }
        if (has_it) {
a590 1
        }
d592 2
a593 5
        has_it = FALSE;
        if (!ephyrHostXVAdaptorHasPutVideo(cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR("error\n");
        }
        if (has_it) {
a594 1
        }
d596 2
a597 5
        has_it = FALSE;
        if (!ephyrHostXVAdaptorHasGetVideo(cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR("error\n");
        }
        if (has_it) {
a598 1
        }
d600 2
a601 5
        has_it = FALSE;
        if (!ephyrHostXVAdaptorHasPutStill(cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR("error\n");
        }
        if (has_it) {
a602 1
        }
d604 2
a605 5
        has_it = FALSE;
        if (!ephyrHostXVAdaptorHasGetStill(cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR("error\n");
        }
        if (has_it) {
a606 1
        }
d692 3
a695 1
    unsigned short width = a_width, height = a_height;
d701 5
a705 3
    if (!ephyrHostXVQueryImageAttributes(a_port_id, a_image_id,
                                         &width, &height, a_size, NULL, NULL)) {
        EPHYR_LOG_ERROR("failed to get image attributes\n");
d707 2
a708 1
    }
d711 2
d749 1
d751 1
a752 1
    EPHYR_RETURN_IF_FAIL(a_info && a_info->pScreen);
d756 1
a756 3
    if (!ephyrHostXVStopVideo(a_info->pScreen->myNum, port_priv->port_number)) {
        EPHYR_LOG_ERROR("XvStopVideo() failed\n");
    }
d764 1
d805 3
a807 6
    if (!ephyrHostXVSetPortAttribute(port_priv->port_number,
                                     host_atom, a_attr_value)) {
        EPHYR_LOG_ERROR("failed to set port attribute\n");
        res = BadMatch;
        goto out;
    }
d819 1
d822 3
d839 5
a843 3
    if (!ephyrHostXVGetPortAttribute(port_priv->port_number,
                                     host_atom, a_attr_value)) {
        EPHYR_LOG_ERROR("failed to get port attribute\n");
d847 3
d867 1
a867 1
    int res = 0;
d869 8
d878 2
a879 1
    EPHYR_RETURN_IF_FAIL(port_priv);
d881 3
a883 8
    EPHYR_LOG("enter\n");
    res = ephyrHostXVQueryBestSize(port_priv->port_number,
                                   a_motion,
                                   a_src_w, a_src_h,
                                   a_drw_w, a_drw_h,
                                   a_prefered_w, a_prefered_h);
    if (!res) {
        EPHYR_LOG_ERROR("Failed to query best size\n");
d885 91
d977 1
d1006 1
a1006 2
    if (!ephyrHostXVPutImage(a_info->pScreen->myNum,
                             port_priv->port_number,
d1011 1
a1011 1
                             (EphyrHostBox *) RegionRects(a_clipping_region),
d1081 2
a1082 2
    if (!ephyrHostXVPutImage(a_info->pScreen->myNum,
                             port_priv->port_number,
d1090 1
a1090 1
                             (EphyrHostBox *) RegionRects(a_clipping_region),
d1112 3
a1115 3
    BoxRec clipped_area, dst_box;
    int result = BadImplementation;
    int drw_x = 0, drw_y = 0, drw_w = 0, drw_h = 0;
d1122 7
a1128 24
    dst_box.x1 = a_drw_x;
    dst_box.x2 = a_drw_x + a_drw_w;
    dst_box.y1 = a_drw_y;
    dst_box.y2 = a_drw_y + a_drw_h;

    if (!DoSimpleClip(&dst_box,
                      RegionExtents(a_clipping_region), &clipped_area)) {
        EPHYR_LOG_ERROR("failed to simple clip\n");
        goto out;
    }

    drw_x = clipped_area.x1;
    drw_y = clipped_area.y1;
    drw_w = clipped_area.x2 - clipped_area.x1;
    drw_h = clipped_area.y2 - clipped_area.y1;

    if (!ephyrHostXVPutVideo(a_info->pScreen->myNum,
                             port_priv->port_number,
                             a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                             a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR("ephyrHostXVPutVideo() failed\n");
        goto out;
    }
    result = Success;
a1129 1
 out:
d1131 1
a1131 1
    return result;
d1143 3
a1146 3
    BoxRec clipped_area, dst_box;
    int result = BadImplementation;
    int drw_x = 0, drw_y = 0, drw_w = 0, drw_h = 0;
d1153 6
a1158 10
    dst_box.x1 = a_drw_x;
    dst_box.x2 = a_drw_x + a_drw_w;
    dst_box.y1 = a_drw_y;
    dst_box.y2 = a_drw_y + a_drw_h;

    if (!DoSimpleClip(&dst_box,
                      RegionExtents(a_clipping_region), &clipped_area)) {
        EPHYR_LOG_ERROR("failed to simple clip\n");
        goto out;
    }
d1160 1
a1160 13
    drw_x = clipped_area.x1;
    drw_y = clipped_area.y1;
    drw_w = clipped_area.x2 - clipped_area.x1;
    drw_h = clipped_area.y2 - clipped_area.y1;

    if (!ephyrHostXVGetVideo(a_info->pScreen->myNum,
                             port_priv->port_number,
                             a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                             a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR("ephyrHostXVGetVideo() failed\n");
        goto out;
    }
    result = Success;
a1161 1
 out:
d1163 1
a1163 1
    return result;
d1175 3
a1178 3
    BoxRec clipped_area, dst_box;
    int result = BadImplementation;
    int drw_x = 0, drw_y = 0, drw_w = 0, drw_h = 0;
d1185 7
a1191 10
    dst_box.x1 = a_drw_x;
    dst_box.x2 = a_drw_x + a_drw_w;
    dst_box.y1 = a_drw_y;
    dst_box.y2 = a_drw_y + a_drw_h;

    if (!DoSimpleClip(&dst_box,
                      RegionExtents(a_clipping_region), &clipped_area)) {
        EPHYR_LOG_ERROR("failed to simple clip\n");
        goto out;
    }
a1192 15
    drw_x = clipped_area.x1;
    drw_y = clipped_area.y1;
    drw_w = clipped_area.x2 - clipped_area.x1;
    drw_h = clipped_area.y2 - clipped_area.y1;

    if (!ephyrHostXVPutStill(a_info->pScreen->myNum,
                             port_priv->port_number,
                             a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                             a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR("ephyrHostXVPutStill() failed\n");
        goto out;
    }
    result = Success;

 out:
d1194 1
a1194 1
    return result;
d1206 3
a1209 3
    BoxRec clipped_area, dst_box;
    int result = BadImplementation;
    int drw_x = 0, drw_y = 0, drw_w = 0, drw_h = 0;
d1216 7
a1222 24
    dst_box.x1 = a_drw_x;
    dst_box.x2 = a_drw_x + a_drw_w;
    dst_box.y1 = a_drw_y;
    dst_box.y2 = a_drw_y + a_drw_h;

    if (!DoSimpleClip(&dst_box,
                      RegionExtents(a_clipping_region), &clipped_area)) {
        EPHYR_LOG_ERROR("failed to simple clip\n");
        goto out;
    }

    drw_x = clipped_area.x1;
    drw_y = clipped_area.y1;
    drw_w = clipped_area.x2 - clipped_area.x1;
    drw_h = clipped_area.y2 - clipped_area.y1;

    if (!ephyrHostXVGetStill(a_info->pScreen->myNum,
                             port_priv->port_number,
                             a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                             a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR("ephyrHostXVGetStill() failed\n");
        goto out;
    }
    result = Success;
a1223 1
 out:
d1225 1
a1225 1
    return result;
d1234 3
d1244 14
a1257 6
    if (!ephyrHostXVQueryImageAttributes(s_base_port_id,
                                         a_id,
                                         a_w, a_h,
                                         &image_size, a_pitches, a_offsets)) {
        EPHYR_LOG_ERROR("EphyrHostXVQueryImageAttributes() failed\n");
        goto out;
d1259 4
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d498 1
a498 1
                (EphyrPortPriv *) & a_this->adaptors[i].
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d42 3
a44 3
    EphyrHostXVAdaptorArray *host_adaptors ;
    KdVideoAdaptorPtr adaptors ;
    int num_adaptors ;
d46 1
a46 1
typedef struct _EphyrXVPriv EphyrXVPriv ;
d49 2
a50 2
    int port_number ;
    KdVideoAdaptorPtr current_adaptor ;
d52 6
a57 6
    unsigned char *image_buf ;
    int image_buf_size ;
    int image_id ;
    int drw_x, drw_y, drw_w, drw_h ;
    int src_x, src_y, src_w, src_h ;
    int image_width, image_height ;
d59 1
a59 1
typedef struct _EphyrPortPriv EphyrPortPriv ;
d61 1
a61 3
static Bool DoSimpleClip (BoxPtr a_dst_drw,
                          BoxPtr a_clipper,
                          BoxPtr a_result) ;
d63 1
a63 1
static Bool ephyrLocalAtomToHost (int a_local_atom, int *a_host_atom) ;
d69 102
a170 115
static EphyrXVPriv* ephyrXVPrivNew (void) ;
static void ephyrXVPrivDelete (EphyrXVPriv *a_this) ;
static Bool ephyrXVPrivQueryHostAdaptors (EphyrXVPriv *a_this) ;
static Bool ephyrXVPrivSetAdaptorsHooks (EphyrXVPriv *a_this) ;
static Bool ephyrXVPrivRegisterAdaptors (EphyrXVPriv *a_this,
                                         ScreenPtr a_screen) ;

static Bool ephyrXVPrivIsAttrValueValid (KdAttributePtr a_attrs,
                                         int a_attrs_len,
                                         const char *a_attr_name,
                                         int a_attr_value,
                                         Bool *a_is_valid) ;

static Bool ephyrXVPrivGetImageBufSize (int a_port_id,
                                        int a_image_id,
                                        unsigned short a_width,
                                        unsigned short a_height,
                                        int *a_size) ;

static Bool ephyrXVPrivSaveImageToPortPriv (EphyrPortPriv *a_port_priv,
                                            const unsigned char *a_image,
                                            int a_image_len) ;

static void ephyrStopVideo (KdScreenInfo *a_info,
                            pointer a_xv_priv,
                            Bool a_exit);

static int ephyrSetPortAttribute (KdScreenInfo *a_info,
                                  Atom a_attr_name,
                                  int a_attr_value,
                                  pointer a_port_priv);

static int ephyrGetPortAttribute (KdScreenInfo *a_screen_info,
                                  Atom a_attr_name,
                                  int *a_attr_value,
                                  pointer a_port_priv);

static void ephyrQueryBestSize (KdScreenInfo *a_info,
                                Bool a_motion,
                                short a_src_w,
                                short a_src_h,
                                short a_drw_w,
                                short a_drw_h,
                                unsigned int *a_prefered_w,
                                unsigned int *a_prefered_h,
                                pointer a_port_priv);

static int ephyrPutImage (KdScreenInfo *a_info,
                          DrawablePtr a_drawable,
                          short a_src_x,
                          short a_src_y,
                          short a_drw_x,
                          short a_drw_y,
                          short a_src_w,
                          short a_src_h,
                          short a_drw_w,
                          short a_drw_h,
                          int a_id,
                          unsigned char *a_buf,
                          short a_width,
                          short a_height,
                          Bool a_sync,
                          RegionPtr a_clipping_region,
                          pointer a_port_priv);

static int ephyrReputImage (KdScreenInfo *a_info,
                            DrawablePtr a_drawable,
                            short a_drw_x,
                            short a_drw_y,
                            RegionPtr a_clipping_region,
                            pointer a_port_priv) ;

static int ephyrPutVideo (KdScreenInfo *a_info,
                          DrawablePtr a_drawable,
                          short a_vid_x, short a_vid_y,
                          short a_drw_x, short a_drw_y,
                          short a_vid_w, short a_vid_h,
                          short a_drw_w, short a_drw_h,
                          RegionPtr a_clip_region,
                          pointer a_port_priv) ;

static int ephyrGetVideo (KdScreenInfo *a_info,
                          DrawablePtr a_drawable,
                          short a_vid_x, short a_vid_y,
                          short a_drw_x, short a_drw_y,
                          short a_vid_w, short a_vid_h,
                          short a_drw_w, short a_drw_h,
                          RegionPtr a_clip_region,
                          pointer a_port_priv) ;

static int ephyrPutStill (KdScreenInfo *a_info,
                          DrawablePtr a_drawable,
                          short a_vid_x, short a_vid_y,
                          short a_drw_x, short a_drw_y,
                          short a_vid_w, short a_vid_h,
                          short a_drw_w, short a_drw_h,
                          RegionPtr a_clip_region,
                          pointer a_port_priv) ;

static int ephyrGetStill (KdScreenInfo *a_info,
                          DrawablePtr a_drawable,
                          short a_vid_x, short a_vid_y,
                          short a_drw_x, short a_drw_y,
                          short a_vid_w, short a_vid_h,
                          short a_drw_w, short a_drw_h,
                          RegionPtr a_clip_region,
                          pointer a_port_priv) ;

static int ephyrQueryImageAttributes (KdScreenInfo *a_info,
                                      int a_id,
                                      unsigned short *a_w,
                                      unsigned short *a_h,
                                      int *a_pitches,
                                      int *a_offsets);
static int s_base_port_id ;
d177 1
a177 3
DoSimpleClip (BoxPtr a_dst_box,
              BoxPtr a_clipper,
              BoxPtr a_result)
d179 1
a179 1
    BoxRec dstClippedBox ;
d181 1
a181 1
    EPHYR_RETURN_VAL_IF_FAIL (a_dst_box && a_clipper && a_result, FALSE) ;
d186 4
a189 4
    dstClippedBox.x1 = a_dst_box->x1 ;
    dstClippedBox.x2 = a_dst_box->x2 ;
    dstClippedBox.y1 = a_dst_box->y1 ;
    dstClippedBox.y2 = a_dst_box->y2 ;
d197 1
a197 1
        dstClippedBox.x1 = a_clipper->x1 ;
d205 1
a205 1
        dstClippedBox.y1 = a_clipper->y1 ;
d207 1
a207 1
    /*ditto for right edge*/
d209 1
a209 1
        dstClippedBox.x2 = a_clipper->x2 ;
d211 1
a211 1
    /*ditto for bottom edge*/
d213 1
a213 1
        dstClippedBox.y2 = a_clipper->y2 ;
d215 2
a216 2
    memcpy (a_result, &dstClippedBox, sizeof (dstClippedBox)) ;
    return TRUE ;
d220 1
a220 1
ephyrLocalAtomToHost (int a_local_atom, int *a_host_atom)
d222 2
a223 2
    const char *atom_name=NULL;
    int host_atom=None ;
d225 1
a225 1
    EPHYR_RETURN_VAL_IF_FAIL (a_host_atom, FALSE) ;
d227 2
a228 2
    if (!ValidAtom (a_local_atom))
        return FALSE ;
d230 1
a230 1
    atom_name = NameForAtom (a_local_atom) ;
d233 1
a233 1
        return FALSE ;
d235 3
a237 4
    if (!ephyrHostGetAtom (atom_name, FALSE, &host_atom) || host_atom == None) {
        EPHYR_LOG_ERROR ("no atom for string %s defined in host X\n",
                         atom_name) ;
        return FALSE ;
d239 2
a240 2
    *a_host_atom = host_atom ;
    return TRUE ;
d278 1
a278 1
ephyrInitVideo (ScreenPtr pScreen)
d280 2
a281 1
    Bool is_ok = FALSE ;
d286 1
a286 1
    EPHYR_LOG ("enter\n") ;
d289 2
a290 2
        EPHYR_LOG_ERROR ("8 bits depth not supported\n") ;
        return FALSE ;
d294 1
a294 1
        xv_priv = ephyrXVPrivNew () ;
d297 2
a298 2
        EPHYR_LOG_ERROR ("failed to create xv_priv\n") ;
        goto out ;
d301 3
a303 3
    if (!ephyrXVPrivRegisterAdaptors (xv_priv, pScreen)) {
        EPHYR_LOG_ERROR ("failed to register adaptors\n") ;
        goto out ;
d305 1
a305 1
    is_ok = TRUE ;
d307 2
a308 2
out:
    return is_ok ;
d311 2
a312 2
static EphyrXVPriv*
ephyrXVPrivNew (void)
d314 1
a314 1
    EphyrXVPriv *xv_priv=NULL ;
d316 1
a316 1
    EPHYR_LOG ("enter\n") ;
d318 1
a318 1
    xv_priv = calloc(1, sizeof (EphyrXVPriv)) ;
d320 2
a321 2
        EPHYR_LOG_ERROR ("failed to create EphyrXVPriv\n") ;
        goto error ;
d324 1
a324 1
    ephyrHostXVInit () ;
d326 3
a328 3
    if (!ephyrXVPrivQueryHostAdaptors (xv_priv)) {
        EPHYR_LOG_ERROR ("failed to query the host x for xv properties\n") ;
        goto error ;
d330 3
a332 3
    if (!ephyrXVPrivSetAdaptorsHooks (xv_priv)) {
        EPHYR_LOG_ERROR ("failed to set xv_priv hooks\n") ;
        goto error ;
d335 2
a336 2
    EPHYR_LOG ("leave\n") ;
    return xv_priv ;
d338 1
a338 1
error:
d340 2
a341 2
        ephyrXVPrivDelete (xv_priv) ;
        xv_priv = NULL ;
d343 1
a343 1
    return NULL ;
d347 1
a347 1
ephyrXVPrivDelete (EphyrXVPriv *a_this)
d349 1
a349 1
    EPHYR_LOG ("enter\n") ;
d352 1
a352 1
        return ;
d354 2
a355 2
        ephyrHostXVAdaptorArrayDelete (a_this->host_adaptors) ;
        a_this->host_adaptors = NULL ;
d357 4
a360 4
    free(a_this->adaptors) ;
    a_this->adaptors = NULL ;
    free(a_this) ;
    EPHYR_LOG ("leave\n") ;
d364 1
a364 2
videoEncodingDup (EphyrHostEncoding *a_encodings,
                   int a_num_encodings)
d366 2
a367 2
    KdVideoEncodingPtr result = NULL ;
    int i=0 ;
d369 1
a369 1
    EPHYR_RETURN_VAL_IF_FAIL (a_encodings && a_num_encodings, NULL) ;
d371 8
a378 8
    result = calloc(a_num_encodings, sizeof (KdVideoEncodingRec)) ;
    for (i=0 ; i < a_num_encodings; i++) {
        result[i].id = a_encodings[i].id ;
        result[i].name = strdup (a_encodings[i].name) ;
        result[i].width = a_encodings[i].width ;
        result[i].height = a_encodings[i].height ;
        result[i].rate.numerator = a_encodings[i].rate.numerator ;
        result[i].rate.denominator = a_encodings[i].rate.denominator ;
d380 1
a380 1
    return result ;
d384 1
a384 2
portAttributesDup (EphyrHostAttribute *a_encodings,
                   int a_num_encodings)
d386 2
a387 2
    int i=0 ;
    KdAttributePtr result=NULL ;
d389 1
a389 1
    EPHYR_RETURN_VAL_IF_FAIL (a_encodings && a_num_encodings, NULL) ;
d391 1
a391 1
    result = calloc(a_num_encodings, sizeof (KdAttributeRec)) ;
d393 2
a394 2
        EPHYR_LOG_ERROR ("failed to allocate attributes\n") ;
        return NULL ;
d396 5
a400 5
    for (i=0; i < a_num_encodings; i++) {
        result[i].flags = a_encodings[i].flags ;
        result[i].min_value = a_encodings[i].min_value ;
        result[i].max_value = a_encodings[i].max_value ;
        result[i].name = strdup (a_encodings[i].name) ;
d402 1
a402 1
    return result ;
d406 1
a406 1
ephyrXVPrivQueryHostAdaptors (EphyrXVPriv *a_this)
d408 17
a424 18
    EphyrHostXVAdaptor *cur_host_adaptor=NULL ;
    EphyrHostVideoFormat *video_formats=NULL ;
    EphyrHostEncoding *encodings=NULL ;
    EphyrHostAttribute *attributes=NULL ;
    EphyrHostImageFormat *image_formats=NULL ;
    int num_video_formats=0, base_port_id=0,
        num_attributes=0, num_formats=0, i=0,
        port_priv_offset=0;
    unsigned num_encodings=0 ;
    Bool is_ok = FALSE ;

    EPHYR_RETURN_VAL_IF_FAIL (a_this, FALSE) ;

    EPHYR_LOG ("enter\n") ;

    if (!ephyrHostXVQueryAdaptors (&a_this->host_adaptors)) {
        EPHYR_LOG_ERROR ("failed to query host adaptors\n") ;
        goto out ;
d428 1
a428 1
                    ephyrHostXVAdaptorArrayGetSize (a_this->host_adaptors) ;
d430 2
a431 2
        EPHYR_LOG_ERROR ("failed to get number of host adaptors\n") ;
        goto out ;
d433 1
a433 1
    EPHYR_LOG ("host has %d adaptors\n", a_this->num_adaptors) ;
d439 1
a439 1
                                    sizeof (KdVideoAdaptorRec)) ;
d441 2
a442 2
            EPHYR_LOG_ERROR ("failed to create internal adaptors\n") ;
            goto out ;
d445 4
a448 4
    for (i=0; i < a_this->num_adaptors; i++) {
        int j=0 ;
        cur_host_adaptor =
                   ephyrHostXVAdaptorArrayAt (a_this->host_adaptors, i) ;
d450 1
a450 1
            continue ;
d452 7
a458 8
                            ephyrHostXVAdaptorGetNbPorts (cur_host_adaptor) ;
        if (a_this->adaptors[i].nPorts <=0) {
            EPHYR_LOG_ERROR ("Could not find any port of adaptor %d\n", i) ;
            continue ;
        }
        a_this->adaptors[i].type =
                        ephyrHostXVAdaptorGetType (cur_host_adaptor) ;
        a_this->adaptors[i].type |= XvWindowMask ;
d460 2
a461 2
                        VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
        if (ephyrHostXVAdaptorGetName (cur_host_adaptor))
d463 1
a463 1
                    strdup (ephyrHostXVAdaptorGetName (cur_host_adaptor)) ;
d465 2
a466 2
            a_this->adaptors[i].name = strdup ("Xephyr Video Overlay");
        base_port_id = ephyrHostXVAdaptorGetFirstPortID (cur_host_adaptor) ;
d468 2
a469 2
            EPHYR_LOG_ERROR ("failed to get port id for adaptor %d\n", i) ;
            continue ;
d472 1
a472 1
            s_base_port_id = base_port_id ;
d474 5
a478 7
        if (!ephyrHostXVQueryEncodings (base_port_id,
                                        &encodings,
                                        &num_encodings)) {
            EPHYR_LOG_ERROR ("failed to get encodings for port port id %d,"
                             " adaptors %d\n",
                             base_port_id, i) ;
            continue ;
d480 1
a480 1
        a_this->adaptors[i].nEncodings = num_encodings ;
d482 6
a487 6
                            videoEncodingDup (encodings, num_encodings) ;
        video_formats = (EphyrHostVideoFormat*)
            ephyrHostXVAdaptorGetVideoFormats (cur_host_adaptor,
                                               &num_video_formats);
        a_this->adaptors[i].pFormats = (KdVideoFormatPtr) video_formats ;
        a_this->adaptors[i].nFormats = num_video_formats ;
d489 3
a491 3
        a_this->adaptors[i].nPorts =
                            ephyrHostXVAdaptorGetNbPorts (cur_host_adaptor) ;
        */
d493 2
a494 2
                calloc(a_this->adaptors[i].nPorts,
                         sizeof (DevUnion) + sizeof (EphyrPortPriv)) ;
d496 1
a496 1
        for (j=0; j < a_this->adaptors[i].nPorts; j++) {
d498 4
a501 2
                    (EphyrPortPriv*)&a_this->adaptors[i].pPortPrivates[port_priv_offset];
            EphyrPortPriv *port_priv = &port_privs_base[j] ;
d503 2
a504 2
            port_priv->current_adaptor = &a_this->adaptors[i] ;
            port_priv->xv_priv = a_this ;
d507 5
a511 6
        if (!ephyrHostXVQueryPortAttributes (base_port_id,
                                             &attributes,
                                             &num_attributes)) {
            EPHYR_LOG_ERROR ("failed to get port attribute "
                             "for adaptor %d\n", i) ;
            continue ;
d514 4
a517 4
                    portAttributesDup (attributes, num_attributes);
        a_this->adaptors[i].nAttributes = num_attributes ;
        /*make sure atoms of attrs names are created in xephyr*/
        for (j=0; j < a_this->adaptors[i].nAttributes; j++) {
d519 8
a526 10
                MakeAtom (a_this->adaptors[i].pAttributes[j].name,
                          strlen (a_this->adaptors[i].pAttributes[j].name),
                          TRUE) ;
        }
        if (!ephyrHostXVQueryImageFormats (base_port_id,
                                           &image_formats,
                                           &num_formats)) {
            EPHYR_LOG_ERROR ("failed to get image formats "
                             "for adaptor %d\n", i) ;
            continue ;
d528 2
a529 2
        a_this->adaptors[i].pImages = (KdImagePtr) image_formats ;
        a_this->adaptors[i].nImages = num_formats ;
d531 1
a531 1
    is_ok = TRUE ;
d533 1
a533 1
out:
d535 2
a536 2
        ephyrHostEncodingsDelete (encodings, num_encodings) ;
        encodings = NULL ;
d539 2
a540 2
        ephyrHostAttributesDelete (attributes) ;
        attributes = NULL ;
d542 2
a543 2
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d547 1
a547 1
ephyrXVPrivSetAdaptorsHooks (EphyrXVPriv *a_this)
d549 3
a551 15
    int i=0 ;
    Bool has_it=FALSE ;
    EphyrHostXVAdaptor *cur_host_adaptor=NULL ;

    EPHYR_RETURN_VAL_IF_FAIL (a_this, FALSE) ;

    EPHYR_LOG ("enter\n") ;

    for (i=0; i < a_this->num_adaptors; i++) {
        a_this->adaptors[i].ReputImage = ephyrReputImage ;
        a_this->adaptors[i].StopVideo = ephyrStopVideo ;
        a_this->adaptors[i].SetPortAttribute = ephyrSetPortAttribute ;
        a_this->adaptors[i].GetPortAttribute = ephyrGetPortAttribute ;
        a_this->adaptors[i].QueryBestSize = ephyrQueryBestSize ;
        a_this->adaptors[i].QueryImageAttributes = ephyrQueryImageAttributes ;
d553 13
a565 2
        cur_host_adaptor =
                   ephyrHostXVAdaptorArrayAt (a_this->host_adaptors, i) ;
d567 2
a568 2
            EPHYR_LOG_ERROR ("failed to get host adaptor at index %d\n", i) ;
            continue ;
d570 3
a572 3
        has_it = FALSE ;
        if (!ephyrHostXVAdaptorHasPutImage (cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR ("error\n") ;
d578 3
a580 3
        has_it = FALSE ;
        if (!ephyrHostXVAdaptorHasPutVideo (cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR ("error\n") ;
d586 3
a588 3
        has_it = FALSE ;
        if (!ephyrHostXVAdaptorHasGetVideo (cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR ("error\n") ;
d594 3
a596 3
        has_it = FALSE ;
        if (!ephyrHostXVAdaptorHasPutStill (cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR ("error\n") ;
d602 3
a604 3
        has_it = FALSE ;
        if (!ephyrHostXVAdaptorHasGetStill (cur_host_adaptor, &has_it)) {
            EPHYR_LOG_ERROR ("error\n") ;
d610 2
a611 2
    EPHYR_LOG ("leave\n") ;
    return TRUE ;
d615 1
a615 2
ephyrXVPrivRegisterAdaptors (EphyrXVPriv *a_this,
                             ScreenPtr a_screen)
d619 3
a621 3
    Bool is_ok = FALSE ;
    KdVideoAdaptorPtr *adaptors=NULL, *registered_adaptors=NULL ;
    int num_registered_adaptors=0, i=0, num_adaptors=0 ;
d623 1
a623 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this && a_screen, FALSE) ;
d625 1
a625 1
    EPHYR_LOG ("enter\n") ;
d628 1
a628 1
        goto out ;
d630 1
a630 1
                KdXVListGenericAdaptors (screen, &registered_adaptors);
d632 2
a633 2
    num_adaptors = num_registered_adaptors + a_this->num_adaptors ;
    adaptors = calloc(num_adaptors, sizeof (KdVideoAdaptorPtr)) ;
d635 2
a636 6
        EPHYR_LOG_ERROR ("failed to allocate adaptors tab\n") ;
        goto out ;
    }
    memmove (adaptors, registered_adaptors, num_registered_adaptors) ;
    for (i=0 ; i < a_this->num_adaptors; i++) {
        *(adaptors + num_registered_adaptors + i) = &a_this->adaptors[i] ;
d638 16
a653 6
    if (!KdXVScreenInit (a_screen, adaptors, num_adaptors)) {
        EPHYR_LOG_ERROR ("failed to register adaptors\n");
        goto out ;
    }
    EPHYR_LOG ("there are  %d registered adaptors\n", num_adaptors) ;
    is_ok = TRUE ;
d655 2
a656 8
out:
    free(registered_adaptors) ;
    registered_adaptors = NULL ;
    free(adaptors) ;
    adaptors = NULL ;

    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d660 12
a671 14
ephyrXVPrivIsAttrValueValid (KdAttributePtr a_attrs,
                             int a_attrs_len,
                             const char *a_attr_name,
                             int a_attr_value,
                             Bool *a_is_valid)
{
    int i=0 ;

    EPHYR_RETURN_VAL_IF_FAIL (a_attrs && a_attr_name && a_is_valid,
                              FALSE) ;

    for (i=0; i < a_attrs_len; i++) {
        if (a_attrs[i].name && strcmp (a_attrs[i].name, a_attr_name))
            continue ;
d674 8
a681 8
            *a_is_valid = FALSE ;
            EPHYR_LOG_ERROR ("attribute was not valid\n"
                             "value:%d. min:%d. max:%d\n",
                             a_attr_value,
                             a_attrs[i].min_value,
                             a_attrs[i].max_value) ;
        } else {
            *a_is_valid = TRUE ;
d683 1
a683 1
        return TRUE ;
d685 1
a685 1
    return FALSE ;
d689 4
a692 5
ephyrXVPrivGetImageBufSize (int a_port_id,
                            int a_image_id,
                            unsigned short a_width,
                            unsigned short a_height,
                            int *a_size)
d694 2
a695 2
    Bool is_ok=FALSE ;
    unsigned short width=a_width, height=a_height ;
d697 1
a697 1
    EPHYR_RETURN_VAL_IF_FAIL (a_size, FALSE) ;
d699 1
a699 1
    EPHYR_LOG ("enter\n") ;
d701 4
a704 4
    if (!ephyrHostXVQueryImageAttributes (a_port_id, a_image_id,
                                          &width, &height, a_size, NULL, NULL)) {
        EPHYR_LOG_ERROR ("failed to get image attributes\n") ;
        goto out ;
d706 1
a706 1
    is_ok = TRUE ;
d708 3
a710 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d714 3
a716 3
ephyrXVPrivSaveImageToPortPriv (EphyrPortPriv *a_port_priv,
                                const unsigned char *a_image_buf,
                                int a_image_len)
d718 1
a718 1
    Bool is_ok=FALSE ;
d720 1
a720 1
    EPHYR_LOG ("enter\n") ;
d723 3
a725 2
        unsigned char *buf=NULL ;
        buf = realloc (a_port_priv->image_buf, a_image_len) ;
d727 2
a728 2
            EPHYR_LOG_ERROR ("failed to realloc image buffer\n") ;
            goto out ;
d730 1
a730 1
        a_port_priv->image_buf = buf ;
d733 2
a734 2
    memmove (a_port_priv->image_buf, a_image_buf, a_image_len) ;
    is_ok = TRUE ;
d736 3
a738 3
out:
    return is_ok ;
    EPHYR_LOG ("leave\n") ;
d742 1
a742 1
ephyrStopVideo (KdScreenInfo *a_info, pointer a_port_priv, Bool a_exit)
d744 1
a744 1
    EphyrPortPriv *port_priv = a_port_priv ;
d746 2
a747 2
    EPHYR_RETURN_IF_FAIL (a_info && a_info->pScreen) ;
    EPHYR_RETURN_IF_FAIL (port_priv) ;
d749 3
a751 4
    EPHYR_LOG ("enter\n") ;
    if (!ephyrHostXVStopVideo (a_info->pScreen->myNum,
                               port_priv->port_number)) {
        EPHYR_LOG_ERROR ("XvStopVideo() failed\n") ;
d753 1
a753 1
    EPHYR_LOG ("leave\n") ;
d757 29
a785 36
ephyrSetPortAttribute (KdScreenInfo *a_info,
                       Atom a_attr_name,
                       int a_attr_value,
                       pointer a_port_priv)
{
    int res=Success, host_atom=0 ;
    EphyrPortPriv *port_priv = a_port_priv ;
    Bool is_attr_valid=FALSE ;

    EPHYR_RETURN_VAL_IF_FAIL (port_priv, BadMatch) ;
    EPHYR_RETURN_VAL_IF_FAIL (port_priv->current_adaptor, BadMatch) ;
    EPHYR_RETURN_VAL_IF_FAIL (port_priv->current_adaptor->pAttributes,
                              BadMatch) ;
    EPHYR_RETURN_VAL_IF_FAIL (port_priv->current_adaptor->nAttributes,
                              BadMatch) ;
    EPHYR_RETURN_VAL_IF_FAIL (ValidAtom (a_attr_name), BadMatch) ;

    EPHYR_LOG ("enter, portnum:%d, atomid:%d, attr_name:%s, attr_val:%d\n",
               port_priv->port_number,
               (int)a_attr_name,
               NameForAtom (a_attr_name),
               a_attr_value) ;

    if (!ephyrLocalAtomToHost (a_attr_name, &host_atom)) {
        EPHYR_LOG_ERROR ("failed to convert local atom to host atom\n") ;
        res = BadMatch ;
        goto out ;
    }

    if (!ephyrXVPrivIsAttrValueValid (port_priv->current_adaptor->pAttributes,
                                      port_priv->current_adaptor->nAttributes,
                                      NameForAtom (a_attr_name),
                                      a_attr_value,
                                      &is_attr_valid)) {
        EPHYR_LOG_ERROR ("failed to validate attribute %s\n",
                         NameForAtom (a_attr_name)) ;
d787 2
a788 2
         res = BadMatch ;
         goto out ;
d792 2
a793 2
        EPHYR_LOG_ERROR ("attribute %s is not valid\n",
                         NameForAtom (a_attr_name)) ;
d795 3
a797 3
        res = BadMatch ;
        goto out ;
        */
d800 5
a804 6
    if (!ephyrHostXVSetPortAttribute (port_priv->port_number,
                                      host_atom,
                                      a_attr_value)) {
        EPHYR_LOG_ERROR ("failed to set port attribute\n") ;
        res = BadMatch ;
        goto out ;
d807 4
a810 4
    res = Success ;
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d814 17
a830 20
ephyrGetPortAttribute (KdScreenInfo *a_screen_info,
                       Atom a_attr_name,
                       int *a_attr_value,
                       pointer a_port_priv)
{
    int res=Success, host_atom=0 ;
    EphyrPortPriv *port_priv = a_port_priv ;

    EPHYR_RETURN_VAL_IF_FAIL (port_priv, BadMatch) ;
    EPHYR_RETURN_VAL_IF_FAIL (ValidAtom (a_attr_name), BadMatch) ;

    EPHYR_LOG ("enter, portnum:%d, atomid:%d, attr_name:%s\n",
               port_priv->port_number,
               (int)a_attr_name,
               NameForAtom (a_attr_name)) ;

    if (!ephyrLocalAtomToHost (a_attr_name, &host_atom)) {
        EPHYR_LOG_ERROR ("failed to convert local atom to host atom\n") ;
        res = BadMatch ;
        goto out ;
d833 5
a837 6
    if (!ephyrHostXVGetPortAttribute (port_priv->port_number,
                                      host_atom,
                                      a_attr_value)) {
        EPHYR_LOG_ERROR ("failed to get port attribute\n") ;
        res = BadMatch ;
        goto out ;
d840 4
a843 4
    res = Success ;
out:
    EPHYR_LOG ("leave\n") ;
    return res ;
d847 20
a866 21
ephyrQueryBestSize (KdScreenInfo *a_info,
                    Bool a_motion,
                    short a_src_w,
                    short a_src_h,
                    short a_drw_w,
                    short a_drw_h,
                    unsigned int *a_prefered_w,
                    unsigned int *a_prefered_h,
                    pointer a_port_priv)
{
    int res=0 ;
    EphyrPortPriv *port_priv = a_port_priv ;

    EPHYR_RETURN_IF_FAIL (port_priv) ;

    EPHYR_LOG ("enter\n") ;
    res = ephyrHostXVQueryBestSize (port_priv->port_number,
                                    a_motion,
                                    a_src_w, a_src_h,
                                    a_drw_w, a_drw_h,
                                    a_prefered_w, a_prefered_h) ;
d868 1
a868 1
        EPHYR_LOG_ERROR ("Failed to query best size\n") ;
d870 1
a870 1
    EPHYR_LOG ("leave\n") ;
d874 35
a908 37
ephyrPutImage (KdScreenInfo *a_info,
               DrawablePtr a_drawable,
               short a_src_x,
               short a_src_y,
               short a_drw_x,
               short a_drw_y,
               short a_src_w,
               short a_src_h,
               short a_drw_w,
               short a_drw_h,
               int a_id,
               unsigned char *a_buf,
               short a_width,
               short a_height,
               Bool a_sync,
               RegionPtr a_clipping_region,
               pointer a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv ;
    Bool is_ok=FALSE ;
    int result=BadImplementation, image_size=0 ;

    EPHYR_RETURN_VAL_IF_FAIL (a_info && a_info->pScreen, BadValue) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_drawable, BadValue) ;

    EPHYR_LOG ("enter\n") ;

    if (!ephyrHostXVPutImage (a_info->pScreen->myNum,
                              port_priv->port_number,
                              a_id,
                              a_drw_x, a_drw_y, a_drw_w, a_drw_h,
                              a_src_x, a_src_y, a_src_w, a_src_h,
                              a_width, a_height, a_buf,
                              (EphyrHostBox*)RegionRects (a_clipping_region),
                              RegionNumRects (a_clipping_region))) {
        EPHYR_LOG_ERROR ("EphyrHostXVPutImage() failed\n") ;
        goto out ;
d915 8
a922 7
    if (!ephyrXVPrivGetImageBufSize (port_priv->port_number,
                                     a_id, a_width, a_height, &image_size)) {
        EPHYR_LOG_ERROR ("failed to get image size\n") ;
        /*this is a minor error so we won't get bail out abruptly*/
        is_ok = FALSE ;
    } else {
        is_ok = TRUE ;
d925 4
a928 3
        if (!ephyrXVPrivSaveImageToPortPriv (port_priv, a_buf, image_size)) {
            is_ok=FALSE ;
        } else {
d932 2
a933 2
            port_priv->drw_w = a_drw_w ;
            port_priv->drw_h = a_drw_h ;
d935 5
a939 5
            port_priv->src_y = a_src_y ;
            port_priv->src_w = a_src_w ;
            port_priv->src_h = a_src_h ;
            port_priv->image_width = a_width ;
            port_priv->image_height = a_height ;
d944 3
a946 3
            free (port_priv->image_buf) ;
            port_priv->image_buf = NULL ;
            port_priv->image_buf_size = 0 ;
d950 1
a950 1
    result = Success ;
d952 3
a954 3
out:
    EPHYR_LOG ("leave\n") ;
    return result ;
d958 4
a961 6
ephyrReputImage (KdScreenInfo *a_info,
                 DrawablePtr a_drawable,
                 short a_drw_x,
                 short a_drw_y,
                 RegionPtr a_clipping_region,
                 pointer a_port_priv)
d963 2
a964 2
    EphyrPortPriv *port_priv = a_port_priv ;
    int result=BadImplementation ;
d966 2
a967 2
    EPHYR_RETURN_VAL_IF_FAIL (a_info->pScreen, FALSE) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_drawable && port_priv, BadValue) ;
d969 1
a969 1
    EPHYR_LOG ("enter\n") ;
d972 2
a973 2
        EPHYR_LOG_ERROR ("has null image buf in cache\n") ;
        goto out ;
d975 20
a994 20
    if (!ephyrHostXVPutImage (a_info->pScreen->myNum,
                              port_priv->port_number,
                              port_priv->image_id,
                              a_drw_x, a_drw_y,
                              port_priv->drw_w, port_priv->drw_h,
                              port_priv->src_x, port_priv->src_y,
                              port_priv->src_w, port_priv->src_h,
                              port_priv->image_width, port_priv->image_height,
                              port_priv->image_buf,
                              (EphyrHostBox*)RegionRects (a_clipping_region),
                              RegionNumRects (a_clipping_region))) {
        EPHYR_LOG_ERROR ("ephyrHostXVPutImage() failed\n") ;
        goto out ;
    }

    result = Success ;

out:
    EPHYR_LOG ("leave\n") ;
    return result ;
d998 12
a1009 13
ephyrPutVideo (KdScreenInfo *a_info,
               DrawablePtr a_drawable,
               short a_vid_x, short a_vid_y,
               short a_drw_x, short a_drw_y,
               short a_vid_w, short a_vid_h,
               short a_drw_w, short a_drw_h,
               RegionPtr a_clipping_region,
               pointer a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv ;
    BoxRec clipped_area, dst_box ;
    int result=BadImplementation ;
    int drw_x=0, drw_y=0, drw_w=0, drw_h=0 ;
d1011 2
a1012 2
    EPHYR_RETURN_VAL_IF_FAIL (a_info->pScreen, BadValue) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_drawable && port_priv, BadValue) ;
d1014 1
a1014 1
    EPHYR_LOG ("enter\n") ;
d1016 1
a1016 1
    dst_box.x1 = a_drw_x ;
d1018 1
a1018 1
    dst_box.y1 = a_drw_y ;
d1021 23
a1043 24
    if (!DoSimpleClip (&dst_box,
                       RegionExtents(a_clipping_region),
                       &clipped_area)) {
        EPHYR_LOG_ERROR ("failed to simple clip\n") ;
        goto out ;
    }

    drw_x = clipped_area.x1 ;
    drw_y = clipped_area.y1 ;
    drw_w = clipped_area.x2 - clipped_area.x1 ;
    drw_h = clipped_area.y2 - clipped_area.y1 ;

    if (!ephyrHostXVPutVideo (a_info->pScreen->myNum,
                              port_priv->port_number,
                              a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                              a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR ("ephyrHostXVPutVideo() failed\n") ;
        goto out ;
    }
    result = Success ;

out:
    EPHYR_LOG ("leave\n") ;
    return result ;
d1047 12
a1058 13
ephyrGetVideo (KdScreenInfo *a_info,
               DrawablePtr a_drawable,
               short a_vid_x, short a_vid_y,
               short a_drw_x, short a_drw_y,
               short a_vid_w, short a_vid_h,
               short a_drw_w, short a_drw_h,
               RegionPtr a_clipping_region,
               pointer a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv ;
    BoxRec clipped_area, dst_box ;
    int result=BadImplementation ;
    int drw_x=0, drw_y=0, drw_w=0, drw_h=0 ;
d1060 2
a1061 2
    EPHYR_RETURN_VAL_IF_FAIL (a_info && a_info->pScreen, BadValue) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_drawable && port_priv, BadValue) ;
d1063 1
a1063 1
    EPHYR_LOG ("enter\n") ;
d1065 1
a1065 1
    dst_box.x1 = a_drw_x ;
d1067 1
a1067 1
    dst_box.y1 = a_drw_y ;
d1070 23
a1092 24
    if (!DoSimpleClip (&dst_box,
                       RegionExtents(a_clipping_region),
                       &clipped_area)) {
        EPHYR_LOG_ERROR ("failed to simple clip\n") ;
        goto out ;
    }

    drw_x = clipped_area.x1 ;
    drw_y = clipped_area.y1 ;
    drw_w = clipped_area.x2 - clipped_area.x1 ;
    drw_h = clipped_area.y2 - clipped_area.y1 ;

    if (!ephyrHostXVGetVideo (a_info->pScreen->myNum,
                              port_priv->port_number,
                              a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                              a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR ("ephyrHostXVGetVideo() failed\n") ;
        goto out ;
    }
    result = Success ;

out:
    EPHYR_LOG ("leave\n") ;
    return result ;
d1096 12
a1107 13
ephyrPutStill (KdScreenInfo *a_info,
               DrawablePtr a_drawable,
               short a_vid_x, short a_vid_y,
               short a_drw_x, short a_drw_y,
               short a_vid_w, short a_vid_h,
               short a_drw_w, short a_drw_h,
               RegionPtr a_clipping_region,
               pointer a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv ;
    BoxRec clipped_area, dst_box ;
    int result=BadImplementation ;
    int drw_x=0, drw_y=0, drw_w=0, drw_h=0 ;
d1109 2
a1110 2
    EPHYR_RETURN_VAL_IF_FAIL (a_info && a_info->pScreen, BadValue) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_drawable && port_priv, BadValue) ;
d1112 1
a1112 1
    EPHYR_LOG ("enter\n") ;
d1114 1
a1114 1
    dst_box.x1 = a_drw_x ;
d1116 1
a1116 1
    dst_box.y1 = a_drw_y ;
d1119 23
a1141 24
    if (!DoSimpleClip (&dst_box,
                       RegionExtents(a_clipping_region),
                       &clipped_area)) {
        EPHYR_LOG_ERROR ("failed to simple clip\n") ;
        goto out ;
    }

    drw_x = clipped_area.x1 ;
    drw_y = clipped_area.y1 ;
    drw_w = clipped_area.x2 - clipped_area.x1 ;
    drw_h = clipped_area.y2 - clipped_area.y1 ;

    if (!ephyrHostXVPutStill (a_info->pScreen->myNum,
                              port_priv->port_number,
                              a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                              a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR ("ephyrHostXVPutStill() failed\n") ;
        goto out ;
    }
    result = Success ;

out:
    EPHYR_LOG ("leave\n") ;
    return result ;
d1145 12
a1156 13
ephyrGetStill (KdScreenInfo *a_info,
               DrawablePtr a_drawable,
               short a_vid_x, short a_vid_y,
               short a_drw_x, short a_drw_y,
               short a_vid_w, short a_vid_h,
               short a_drw_w, short a_drw_h,
               RegionPtr a_clipping_region,
               pointer a_port_priv)
{
    EphyrPortPriv *port_priv = a_port_priv ;
    BoxRec clipped_area, dst_box ;
    int result=BadImplementation ;
    int drw_x=0, drw_y=0, drw_w=0, drw_h=0 ;
d1158 2
a1159 2
    EPHYR_RETURN_VAL_IF_FAIL (a_info && a_info->pScreen, BadValue) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_drawable && port_priv, BadValue) ;
d1161 1
a1161 1
    EPHYR_LOG ("enter\n") ;
d1163 1
a1163 1
    dst_box.x1 = a_drw_x ;
d1165 1
a1165 1
    dst_box.y1 = a_drw_y ;
d1168 23
a1190 24
    if (!DoSimpleClip (&dst_box,
                       RegionExtents(a_clipping_region),
                       &clipped_area)) {
        EPHYR_LOG_ERROR ("failed to simple clip\n") ;
        goto out ;
    }

    drw_x = clipped_area.x1 ;
    drw_y = clipped_area.y1 ;
    drw_w = clipped_area.x2 - clipped_area.x1 ;
    drw_h = clipped_area.y2 - clipped_area.y1 ;

    if (!ephyrHostXVGetStill (a_info->pScreen->myNum,
                              port_priv->port_number,
                              a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                              a_drw_x, a_drw_y, a_drw_w, a_drw_h)) {
        EPHYR_LOG_ERROR ("ephyrHostXVGetStill() failed\n") ;
        goto out ;
    }
    result = Success ;

out:
    EPHYR_LOG ("leave\n") ;
    return result ;
d1194 4
a1197 6
ephyrQueryImageAttributes (KdScreenInfo *a_info,
                           int a_id,
                           unsigned short *a_w,
                           unsigned short *a_h,
                           int *a_pitches,
                           int *a_offsets)
d1199 1
a1199 1
    int image_size=0 ;
d1201 1
a1201 1
    EPHYR_RETURN_VAL_IF_FAIL (a_w && a_h, FALSE) ;
d1203 2
a1204 2
    EPHYR_LOG ("enter: dim (%dx%d), pitches: %p, offsets: %p\n",
               *a_w, *a_h, a_pitches, a_offsets) ;
d1206 1
a1206 1
   if (!ephyrHostXVQueryImageAttributes (s_base_port_id,
d1209 9
a1217 10
                                         &image_size,
                                         a_pitches, a_offsets)) {
       EPHYR_LOG_ERROR ("EphyrHostXVQueryImageAttributes() failed\n") ;
       goto out ;
   }
   EPHYR_LOG ("image size: %d, dim (%dx%d)\n", image_size, *a_w, *a_h) ;

out:
    EPHYR_LOG ("leave\n") ;
    return image_size ;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d335 1
a335 1
    xv_priv = xcalloc (1, sizeof (EphyrXVPriv)) ;
d374 1
a374 1
    xfree (a_this->adaptors) ;
d376 1
a376 1
    xfree (a_this) ;
d389 1
a389 1
    result = xcalloc (a_num_encodings, sizeof (KdVideoEncodingRec)) ;
d410 1
a410 1
    result = xcalloc (a_num_encodings, sizeof (KdAttributeRec)) ;
d458 1
a458 1
        a_this->adaptors = xcalloc (a_this->num_adaptors,
d516 1
a516 1
                xcalloc (a_this->adaptors[i].nPorts,
d659 1
a659 1
    adaptors = xcalloc (num_adaptors, sizeof (KdVideoAdaptorPtr)) ;
d676 1
a676 1
    xfree (registered_adaptors) ;
d678 1
a678 1
    xfree (adaptors) ;
d949 2
a950 2
                              (EphyrHostBox*)REGION_RECTS (a_clipping_region),
                              REGION_NUM_RECTS (a_clipping_region))) {
d1028 2
a1029 2
                              (EphyrHostBox*)REGION_RECTS (a_clipping_region),
                              REGION_NUM_RECTS (a_clipping_region))) {
d1067 1
a1067 1
                       REGION_EXTENTS (pScreen->pScreen, a_clipping_region),
d1118 1
a1118 1
                       REGION_EXTENTS (pScreen->pScreen, a_clipping_region),
d1169 1
a1169 1
                       REGION_EXTENTS (pScreen->pScreen, a_clipping_region),
d1220 1
a1220 1
                       REGION_EXTENTS (pScreen->pScreen, a_clipping_region),
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d239 1
a239 1
    char *atom_name=NULL;
d305 1
a305 1
    if (screen->fb[0].bitsPerPixel == 8) {
d374 2
a375 4
    if (a_this->adaptors) {
        xfree (a_this->adaptors) ;
        a_this->adaptors = NULL ;
    }
d676 5
a680 8
    if (registered_adaptors) {
        xfree (registered_adaptors) ;
        registered_adaptors = NULL ;
    }
    if (adaptors) {
        xfree (adaptors) ;
        adaptors=NULL ;
    }
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d1262 2
a1263 2
    EPHYR_LOG ("enter: dim (%dx%d), pitches: %#x, offsets: %#x\n",
               *a_w, *a_h, (unsigned int)a_pitches, (unsigned int)a_offsets) ;
@

