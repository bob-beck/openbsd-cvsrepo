head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.24.19.44.35;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@o-hand.com>
 *
 * Copyright Â© 2004 Nokia
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Nokia not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. Nokia makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * NOKIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL NOKIA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _XLIBS_STUFF_H_
#define _XLIBS_STUFF_H_

#include <X11/X.h>
#include <X11/Xmd.h>
#include <xcb/xcb.h>
#include <xcb/render.h>
#include "ephyr.h"

#define EPHYR_WANT_DEBUG 0

#if (EPHYR_WANT_DEBUG)
#define EPHYR_DBG(x, a...) \
 fprintf(stderr, __FILE__ ":%d,%s() " x "\n", __LINE__, __func__, ##a)
#else
#define EPHYR_DBG(x, a...) do {} while (0)
#endif

typedef struct EphyrHostXVars EphyrHostXVars;

typedef struct {
    int minKeyCode;
    int maxKeyCode;
} EphyrKeySyms;

typedef struct {
    VisualID visualid;
    int screen;
    int depth;
    int class;
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    int colormap_size;
    int bits_per_rgb;
} EphyrHostVisualInfo;

typedef struct {
    int x, y;
    int width, height;
    int visualid;
} EphyrHostWindowAttributes;

typedef struct {
    int x, y, width, height;
} EphyrBox;

typedef struct {
    short x1, y1, x2, y2;
} EphyrRect;

int
hostx_want_screen_geometry(KdScreenInfo *screen, int *width, int *height, int *x, int *y);

int
 hostx_want_host_cursor(void);

void
 hostx_use_sw_cursor(void);

xcb_cursor_t
 hostx_get_empty_cursor(void);

void
 hostx_get_output_geometry(const char *output,
                           int *x, int *y,
                           int *width, int *height);

void
 hostx_use_fullscreen(void);

int
 hostx_want_fullscreen(void);

int
hostx_want_preexisting_window(KdScreenInfo *screen);

void
 hostx_use_preexisting_window(unsigned long win_id);

void
 hostx_use_resname(char *name, int fromcmd);

void
 hostx_set_title(char *name);

void
 hostx_handle_signal(int signum);

int
 hostx_init(void);

void
hostx_add_screen(KdScreenInfo *screen, unsigned long win_id, int screen_num, Bool use_geometry, const char *output);

void
 hostx_set_display_name(char *name);

void
hostx_set_screen_number(KdScreenInfo *screen, int number);

void
hostx_set_win_title(KdScreenInfo *screen, const char *extra_text);

int
 hostx_get_depth(void);

int
hostx_get_server_depth(KdScreenInfo *screen);

int
hostx_get_bpp(KdScreenInfo *screen);

void
hostx_get_visual_masks(KdScreenInfo *screen,
                       CARD32 *rmsk, CARD32 *gmsk, CARD32 *bmsk);
void

hostx_set_cmap_entry(ScreenPtr pScreen, unsigned char idx,
                     unsigned char r, unsigned char g, unsigned char b);

void *hostx_screen_init(KdScreenInfo *screen,
                        int x, int y,
                        int width, int height, int buffer_height,
                        int *bytes_per_line, int *bits_per_pixel);

void
hostx_paint_rect(KdScreenInfo *screen,
                 int sx, int sy, int dx, int dy, int width, int height);

void
 hostx_load_keymap(void);

xcb_connection_t *
hostx_get_xcbconn(void);

int
hostx_get_screen(void);

int
 hostx_get_window(int a_screen_number);

int
 hostx_get_window_attributes(int a_window, EphyrHostWindowAttributes * a_attr);

int
 hostx_get_visuals_info(EphyrHostVisualInfo ** a_visuals, int *a_num_entries);

int hostx_create_window(int a_screen_number,
                        EphyrBox * a_geometry,
                        int a_visual_id, int *a_host_win /*out parameter */ );

int hostx_destroy_window(int a_win);

int hostx_set_window_geometry(int a_win, EphyrBox * a_geo);

int hostx_set_window_bounding_rectangles(int a_window,
                                         EphyrRect * a_rects, int a_num_rects);

int hostx_has_extension(xcb_extension_t *extension);

#ifdef XF86DRI
int hostx_lookup_peer_window(void *a_local_window,
                             int *a_host_peer /*out parameter */ );
int

hostx_allocate_resource_id_peer(int a_local_resource_id,
                                int *a_remote_resource_id);
int
 hostx_get_resource_id_peer(int a_local_resource_id, int *a_remote_resource_id);
int hostx_has_dri(void);

int hostx_has_glx(void);
#endif                          /* XF86DRI */

#endif /*_XLIBS_STUFF_H_*/
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d185 1
a185 1
int host_has_extension(xcb_extension_t *extension);
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d4 2
a5 2
 * 
 * Copyright Â© 2004 Nokia 
d32 1
d78 1
a78 1
hostx_want_screen_size(KdScreenInfo *screen, int *width, int *height);
d86 8
d119 1
a119 1
hostx_add_screen(KdScreenInfo *screen, unsigned long win_id, int screen_num);
d144 1
a144 1
hostx_set_cmap_entry(unsigned char idx,
d148 1
@


1.8
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d31 2
a43 11
typedef struct EphyrHostXEvent EphyrHostXEvent;
typedef void *EphyrScreenInfo;
typedef enum EphyrHostXEventType {
    EPHYR_EV_MOUSE_MOTION,
    EPHYR_EV_MOUSE_PRESS,
    EPHYR_EV_MOUSE_RELEASE,
    EPHYR_EV_KEY_PRESS,
    EPHYR_EV_KEY_RELEASE,
    EPHYR_EV_EXPOSE,
    EPHYR_EV_CONFIGURE,
} EphyrHostXEventType;
a44 1
/* I can't believe it's not a KeySymsRec. */
a47 2
    int mapWidth;
    CARD32 *map;
a49 43
struct EphyrHostXEvent {
    EphyrHostXEventType type;

    union {
        struct mouse_motion {
            int x;
            int y;
            int screen;
            int window;
        } mouse_motion;

        struct mouse_down {
            int button_num;
        } mouse_down;

        struct mouse_up {
            int button_num;
        } mouse_up;

        struct key_up {
            int scancode;
        } key_up;

        struct key_down {
            int scancode;
        } key_down;

        struct expose {
            int window;
        } expose;

        struct configure {
            int width;
            int height;
            int screen;
            int window;
        } configure;

    } data;

    int key_state;
};

d77 1
a77 1
 hostx_want_screen_size(EphyrScreenInfo screen, int *width, int *height);
d83 1
a83 1
 hostx_use_host_cursor(void);
d92 1
a92 1
 hostx_want_preexisting_window(EphyrScreenInfo screen);
d110 1
a110 1
 hostx_add_screen(EphyrScreenInfo screen, unsigned long win_id, int screen_num);
d116 1
a116 1
 hostx_set_screen_number(EphyrScreenInfo screen, int number);
d119 1
a119 1
 hostx_set_win_title(EphyrScreenInfo screen, char *extra_text);
d125 1
a125 4
 hostx_get_server_depth(EphyrScreenInfo screen);

void
 hostx_set_server_depth(EphyrScreenInfo screen, int depth);
d128 1
a128 1
 hostx_get_bpp(void *info);
d131 2
a132 1
 hostx_get_visual_masks(void *info, CARD32 *rmsk, CARD32 *gmsk, CARD32 *bmsk);
d138 1
a138 1
void *hostx_screen_init(EphyrScreenInfo screen,
d143 1
a143 2

hostx_paint_rect(EphyrScreenInfo screen,
d149 3
d153 1
a153 3
 hostx_get_event(EphyrHostXEvent * ev);

void *hostx_get_display(void);
a161 5

hostx_get_extension_info(const char *a_ext_name,
                         int *a_major_opcode,
                         int *a_first_even, int *a_first_error);
int
d175 1
a175 3
int hostx_set_window_clipping_rectangles(int a_window,
                                         EphyrRect * a_rects, int a_num_rects);
int hostx_has_xshape(void);
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d196 2
a197 1
                        int width, int height, int buffer_height);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d50 2
a51 1
    EPHYR_EV_EXPOSE
d92 7
@


1.5
log
@Update to xserver 1.11.2
@
text
@d38 1
a38 1
#define EPHYR_DBG(x, a...) do {} while (0) 
d41 1
a41 1
typedef struct EphyrHostXVars  EphyrHostXVars;
d43 9
a51 11
typedef void* EphyrScreenInfo ;
typedef enum EphyrHostXEventType
{
  EPHYR_EV_MOUSE_MOTION,
  EPHYR_EV_MOUSE_PRESS,
  EPHYR_EV_MOUSE_RELEASE,
  EPHYR_EV_KEY_PRESS,
  EPHYR_EV_KEY_RELEASE,
  EPHYR_EV_EXPOSE
} 
EphyrHostXEventType;
d55 4
a58 4
  int             minKeyCode;
  int             maxKeyCode;
  int             mapWidth;
  CARD32         *map;
d61 2
a62 32
struct EphyrHostXEvent
{
  EphyrHostXEventType type;

  union 
  {
    struct mouse_motion { 	
      int x;
      int y;
      int screen;
      int window;
    } mouse_motion;

    struct mouse_down { 	
      int button_num;
    } mouse_down;

    struct mouse_up {
      int button_num;
    } mouse_up;

    struct key_up {
      int scancode;
    } key_up;

    struct key_down {
      int scancode;
    } key_down;

    struct expose {
      int window;
    } expose;
d64 27
a90 1
  } data;
d92 3
a94 1
  int key_state;
d98 9
a106 9
  VisualID visualid;
  int screen;
  int depth;
  int class;
  unsigned long red_mask;
  unsigned long green_mask;
  unsigned long blue_mask;
  int colormap_size;
  int bits_per_rgb;
d111 2
a112 2
    int width, height ;
    int visualid ;
d116 1
a116 1
    int x,y,width,height;
d120 1
a120 1
    short x1,y1,x2,y2;
d124 1
a124 1
hostx_want_screen_size(EphyrScreenInfo screen, int *width, int *height);
d127 1
a127 1
hostx_want_host_cursor(void);
d130 1
a130 1
hostx_use_host_cursor(void);
d133 1
a133 1
hostx_use_fullscreen(void);
d136 1
a136 1
hostx_want_fullscreen(void);
d139 1
a139 1
hostx_want_preexisting_window(EphyrScreenInfo screen);
d142 1
a142 1
hostx_use_preexisting_window(unsigned long win_id);
d145 1
a145 1
hostx_use_resname (char *name, int fromcmd);
d148 1
a148 1
hostx_set_title(char *name);
d150 2
a151 2
void 
hostx_handle_signal(int signum);
d154 1
a154 1
hostx_init(void);
d157 1
a157 1
hostx_add_screen(EphyrScreenInfo screen, unsigned long win_id, int screen_num);
d160 1
a160 1
hostx_set_display_name(char *name);
d163 1
a163 1
hostx_set_screen_number(EphyrScreenInfo screen, int number);
d166 1
a166 1
hostx_set_win_title(EphyrScreenInfo screen, char *extra_text);
d169 1
a169 1
hostx_get_depth (void);
d172 1
a172 1
hostx_get_server_depth (EphyrScreenInfo screen);
d175 1
a175 1
hostx_set_server_depth(EphyrScreenInfo screen, int depth);
d178 1
a178 1
hostx_get_bpp(void *info);
d181 1
a181 4
hostx_get_visual_masks (void   *info,
			CARD32 *rmsk, 
			CARD32 *gmsk, 
			CARD32 *bmsk);
a182 4
hostx_set_cmap_entry(unsigned char idx, 
		     unsigned char r, 
		     unsigned char g, 
		     unsigned char b);
d184 5
a188 4
void*
hostx_screen_init (EphyrScreenInfo screen,
                   int width, int height,
                   int buffer_height);
d191 1
d193 1
a193 4
		 int sx,    int sy,
		 int dx,    int dy,
		 int width, int height);

d196 1
a196 1
hostx_load_keymap (void);
d199 1
a199 1
hostx_get_event (EphyrHostXEvent *ev);
d201 1
a201 2
void*
hostx_get_display (void) ;
d204 1
a204 1
hostx_get_window (int a_screen_number) ;
d207 1
a207 1
hostx_get_window_attributes (int a_window, EphyrHostWindowAttributes *a_attr)  ;
d210 4
a213 4
hostx_get_extension_info (const char *a_ext_name,
                          int *a_major_opcode,
                          int *a_first_even,
                          int *a_first_error) ;
d215 1
a215 2
hostx_get_visuals_info (EphyrHostVisualInfo **a_visuals,
                        int *a_num_entries) ;
d217 3
a219 4
int hostx_create_window (int a_screen_number,
                         EphyrBox *a_geometry,
                         int a_visual_id,
                         int *a_host_win /*out parameter*/) ;
d221 1
a221 1
int hostx_destroy_window (int a_win) ;
d223 1
a223 1
int hostx_set_window_geometry (int a_win, EphyrBox *a_geo) ;
d225 2
d228 3
a230 8
int hostx_set_window_bounding_rectangles (int a_window,
                                          EphyrRect *a_rects,
                                          int a_num_rects) ;

int hostx_set_window_clipping_rectangles (int a_window,
                                          EphyrRect *a_rects,
                                          int a_num_rects) ;
int hostx_has_xshape (void) ;
d233 2
a234 2
int hostx_lookup_peer_window (void *a_local_window,
                              int *a_host_peer /*out parameter*/) ;
d236 3
a238 2
hostx_allocate_resource_id_peer (int a_local_resource_id,
                                 int *a_remote_resource_id) ;
d240 2
a241 3
hostx_get_resource_id_peer (int a_local_resource_id,
                            int *a_remote_resource_id) ;
int hostx_has_dri (void) ;
d243 2
a244 2
int hostx_has_glx (void) ;
#endif /* XF86DRI */
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d5 1
a5 1
 * Copyright © 2004 Nokia 
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d151 3
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d247 1
a247 1
#ifdef XEPHYR_DRI
d259 1
a259 1
#endif /*XEPHYR_DRI*/
@


1.1
log
@Initial revision
@
text
@d29 3
d43 2
a44 2

typedef enum EphyrHostXEventType 
d50 2
a51 1
  EPHYR_EV_KEY_RELEASE
d55 8
d72 2
d92 4
d101 26
d128 1
a128 1
hostx_want_screen_size(int *width, int *height);
d143 1
a143 1
hostx_want_preexisting_window(void);
d148 3
d158 3
d164 4
a167 1
hostx_set_win_title(char *extra_text);
d173 1
a173 1
hostx_get_server_depth (void);
d176 1
a176 1
hostx_set_server_depth(int depth);
d179 1
a179 1
hostx_get_bpp(void);
d182 4
a185 3
hostx_get_visual_masks (unsigned long *rmsk, 
			unsigned long *gmsk, 
			unsigned long *bmsk);
d193 3
a195 1
hostx_screen_init (int width, int height, int buffer_height);
d198 3
a200 2
hostx_paint_rect(int sx,    int sy,
		 int dx,    int dy, 
d202 2
d205 7
a211 2
hostx_paint_debug_rect(int x,     int y, 
		       int width, int height);
d213 33
a245 2
void
hostx_load_keymap(void);
d247 6
d254 3
a256 1
hostx_get_event(EphyrHostXEvent *ev);
d258 4
a261 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a28 3
#include <X11/X.h>
#include <X11/Xmd.h>

a50 8
/* I can't believe it's not a KeySymsRec. */
typedef struct {
  int             minKeyCode;
  int             maxKeyCode;
  int             mapWidth;
  CARD32         *map;
} EphyrKeySyms;

d129 3
a131 3
hostx_get_visual_masks (CARD32 *rmsk, 
			CARD32 *gmsk, 
			CARD32 *bmsk);
@

