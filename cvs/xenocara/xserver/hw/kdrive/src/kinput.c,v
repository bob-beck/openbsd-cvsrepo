head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.09.28.15.36.34;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.28.14.50.48;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.19;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.58;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.58;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 1999 Keith Packard
 * Copyright © 2006 Nokia Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the authors not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The authors make no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"
#include "inputstr.h"

#define XK_PUBLISHING
#include <X11/keysym.h>
#if HAVE_X11_XF86KEYSYM_H
#include <X11/XF86keysym.h>
#endif
#include <signal.h>
#include <stdio.h>
#ifdef sun
#include <sys/file.h>           /* needed for FNONBLOCK & FASYNC */
#endif

#include "xkbsrv.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"            /* even though we don't use stubs.  cute, no? */
#include "exevents.h"
#include "extinit.h"
#include "exglobals.h"
#include "eventstr.h"
#include "xserver-properties.h"
#include "inpututils.h"
#include "optionstr.h"

#define AtomFromName(x) MakeAtom(x, strlen(x), 1)

struct KdConfigDevice {
    char *line;
    struct KdConfigDevice *next;
};

/* kdKeyboards and kdPointers hold all the real devices. */
static KdKeyboardInfo *kdKeyboards = NULL;
static KdPointerInfo *kdPointers = NULL;
static struct KdConfigDevice *kdConfigKeyboards = NULL;
static struct KdConfigDevice *kdConfigPointers = NULL;

static KdKeyboardDriver *kdKeyboardDrivers = NULL;
static KdPointerDriver *kdPointerDrivers = NULL;

static Bool kdInputEnabled;
static Bool kdOffScreen;
static unsigned long kdOffScreenTime;

static KdPointerMatrix kdPointerMatrix = {
    {{1, 0, 0},
     {0, 1, 0}}
};

void KdResetInputMachine(void);

#define KD_MAX_INPUT_FDS    8

typedef struct _kdInputFd {
    int fd;
    void (*read) (int fd, void *closure);
    int (*enable) (int fd, void *closure);
    void (*disable) (int fd, void *closure);
    void *closure;
} KdInputFd;

static KdInputFd kdInputFds[KD_MAX_INPUT_FDS];
static int kdNumInputFds;

extern Bool kdRawPointerCoordinates;

static void
KdSigio(int sig)
{
    int i;

    for (i = 0; i < kdNumInputFds; i++)
        (*kdInputFds[i].read) (kdInputFds[i].fd, kdInputFds[i].closure);
}

#ifdef DEBUG_SIGIO

void
KdAssertSigioBlocked(char *where)
{
    sigset_t set, old;

    sigemptyset(&set);
    sigprocmask(SIG_BLOCK, &set, &old);
    if (!sigismember(&old, SIGIO)) {
        ErrorF("SIGIO not blocked at %s\n", where);
        KdBacktrace(0);
    }
}

#else

#define KdAssertSigioBlocked(s)

#endif

static int kdnFds;

#ifdef FNONBLOCK
#define NOBLOCK FNONBLOCK
#else
#define NOBLOCK FNDELAY
#endif

void
KdResetInputMachine(void)
{
    KdPointerInfo *pi;

    for (pi = kdPointers; pi; pi = pi->next) {
        pi->mouseState = start;
        pi->eventHeld = FALSE;
    }
}

static void
KdNonBlockFd(int fd)
{
    int flags;

    flags = fcntl(fd, F_GETFL);
    flags |= FASYNC | NOBLOCK;
    fcntl(fd, F_SETFL, flags);
}

static void
KdAddFd(int fd)
{
    struct sigaction act;
    sigset_t set;

    kdnFds++;
    fcntl(fd, F_SETOWN, getpid());
    KdNonBlockFd(fd);
    AddEnabledDevice(fd);
    memset(&act, '\0', sizeof act);
    act.sa_handler = KdSigio;
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGIO);
    sigaddset(&act.sa_mask, SIGALRM);
    sigaddset(&act.sa_mask, SIGVTALRM);
    sigaction(SIGIO, &act, 0);
    sigemptyset(&set);
    sigprocmask(SIG_SETMASK, &set, 0);
}

static void
KdRemoveFd(int fd)
{
    struct sigaction act;
    int flags;

    kdnFds--;
    RemoveEnabledDevice(fd);
    flags = fcntl(fd, F_GETFL);
    flags &= ~(FASYNC | NOBLOCK);
    fcntl(fd, F_SETFL, flags);
    if (kdnFds == 0) {
        memset(&act, '\0', sizeof act);
        act.sa_handler = SIG_IGN;
        sigemptyset(&act.sa_mask);
        sigaction(SIGIO, &act, 0);
    }
}

Bool
KdRegisterFd(int fd, void (*read) (int fd, void *closure), void *closure)
{
    if (kdNumInputFds == KD_MAX_INPUT_FDS)
        return FALSE;
    kdInputFds[kdNumInputFds].fd = fd;
    kdInputFds[kdNumInputFds].read = read;
    kdInputFds[kdNumInputFds].enable = 0;
    kdInputFds[kdNumInputFds].disable = 0;
    kdInputFds[kdNumInputFds].closure = closure;
    kdNumInputFds++;
    if (kdInputEnabled)
        KdAddFd(fd);
    return TRUE;
}

void
KdUnregisterFd(void *closure, int fd, Bool do_close)
{
    int i, j;

    for (i = 0; i < kdNumInputFds; i++) {
        if (kdInputFds[i].closure == closure &&
            (fd == -1 || kdInputFds[i].fd == fd)) {
            if (kdInputEnabled)
                KdRemoveFd(kdInputFds[i].fd);
            if (do_close)
                close(kdInputFds[i].fd);
            for (j = i; j < (kdNumInputFds - 1); j++)
                kdInputFds[j] = kdInputFds[j + 1];
            kdNumInputFds--;
            break;
        }
    }
}

void
KdUnregisterFds(void *closure, Bool do_close)
{
    KdUnregisterFd(closure, -1, do_close);
}

void
KdDisableInput(void)
{
    KdKeyboardInfo *ki;
    KdPointerInfo *pi;
    int found = 0, i = 0;

    OsBlockSIGIO();

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->driver && ki->driver->Disable)
            (*ki->driver->Disable) (ki);
    }

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->driver && pi->driver->Disable)
            (*pi->driver->Disable) (pi);
    }

    if (kdNumInputFds) {
        ErrorF("[KdDisableInput] Buggy drivers: still %d input fds left!",
               kdNumInputFds);
        i = 0;
        while (i < kdNumInputFds) {
            found = 0;
            for (ki = kdKeyboards; ki; ki = ki->next) {
                if (ki == kdInputFds[i].closure) {
                    ErrorF("    fd %d belongs to keybd driver %s\n",
                           kdInputFds[i].fd,
                           ki->driver && ki->driver->name ?
                           ki->driver->name : "(unnamed!)");
                    found = 1;
                    break;
                }
            }

            if (found) {
                i++;
                continue;
            }

            for (pi = kdPointers; pi; pi = pi->next) {
                if (pi == kdInputFds[i].closure) {
                    ErrorF("    fd %d belongs to pointer driver %s\n",
                           kdInputFds[i].fd,
                           pi->driver && pi->driver->name ?
                           pi->driver->name : "(unnamed!)");
                    break;
                }
            }

            if (found) {
                i++;
                continue;
            }

            ErrorF("    fd %d not claimed by any active device!\n",
                   kdInputFds[i].fd);
            KdUnregisterFd(kdInputFds[i].closure, kdInputFds[i].fd, TRUE);
        }
    }

    kdInputEnabled = FALSE;
}

void
KdEnableInput(void)
{
    InternalEvent ev;
    KdKeyboardInfo *ki;
    KdPointerInfo *pi;

    kdInputEnabled = TRUE;

    ev.any.time = GetTimeInMillis();

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->driver && ki->driver->Enable)
            (*ki->driver->Enable) (ki);
        /* reset screen saver */
        NoticeEventTime (&ev, ki->dixdev);
    }

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->driver && pi->driver->Enable)
            (*pi->driver->Enable) (pi);
        /* reset screen saver */
        NoticeEventTime (&ev, pi->dixdev);
    }

    OsReleaseSIGIO();
}

static KdKeyboardDriver *
KdFindKeyboardDriver(const char *name)
{
    KdKeyboardDriver *ret;

    /* ask a stupid question ... */
    if (!name)
        return NULL;

    for (ret = kdKeyboardDrivers; ret; ret = ret->next) {
        if (strcmp(ret->name, name) == 0)
            return ret;
    }

    return NULL;
}

static KdPointerDriver *
KdFindPointerDriver(const char *name)
{
    KdPointerDriver *ret;

    /* ask a stupid question ... */
    if (!name)
        return NULL;

    for (ret = kdPointerDrivers; ret; ret = ret->next) {
        if (strcmp(ret->name, name) == 0)
            return ret;
    }

    return NULL;
}

static int
KdPointerProc(DeviceIntPtr pDevice, int onoff)
{
    DevicePtr pDev = (DevicePtr) pDevice;
    KdPointerInfo *pi;
    Atom xiclass;
    Atom *btn_labels;
    Atom *axes_labels;

    if (!pDev)
        return BadImplementation;

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->dixdev && pi->dixdev->id == pDevice->id)
            break;
    }

    if (!pi || !pi->dixdev || pi->dixdev->id != pDevice->id) {
        ErrorF("[KdPointerProc] Failed to find pointer for device %d!\n",
               pDevice->id);
        return BadImplementation;
    }

    switch (onoff) {
    case DEVICE_INIT:
#ifdef DEBUG
        ErrorF("initialising pointer %s ...\n", pi->name);
#endif
        if (!pi->driver) {
            if (!pi->driverPrivate) {
                ErrorF("no driver specified for %s\n", pi->name);
                return BadImplementation;
            }

            pi->driver = KdFindPointerDriver(pi->driverPrivate);
            if (!pi->driver) {
                ErrorF("Couldn't find pointer driver %s\n",
                       pi->driverPrivate ? (char *) pi->driverPrivate :
                       "(unnamed)");
                return !Success;
            }
            free(pi->driverPrivate);
            pi->driverPrivate = NULL;
        }

        if (!pi->driver->Init) {
            ErrorF("no init function\n");
            return BadImplementation;
        }

        if ((*pi->driver->Init) (pi) != Success) {
            return !Success;
        }

        btn_labels = calloc(pi->nButtons, sizeof(Atom));
        if (!btn_labels)
            return BadAlloc;
        axes_labels = calloc(pi->nAxes, sizeof(Atom));
        if (!axes_labels) {
            free(btn_labels);
            return BadAlloc;
        }

        switch (pi->nAxes) {
        default:
        case 7:
            btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
        case 6:
            btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
        case 5:
            btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
        case 4:
            btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
        case 3:
            btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
        case 2:
            btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        case 1:
            btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        case 0:
            break;
        }

        if (pi->nAxes >= 2) {
            axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
            axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
        }

        InitPointerDeviceStruct(pDev, pi->map, pi->nButtons, btn_labels,
                                (PtrCtrlProcPtr) NoopDDA,
                                GetMotionHistorySize(), pi->nAxes, axes_labels);

        free(btn_labels);
        free(axes_labels);

        if (pi->inputClass == KD_TOUCHSCREEN) {
            xiclass = AtomFromName(XI_TOUCHSCREEN);
        }
        else {
            xiclass = AtomFromName(XI_MOUSE);
        }

        AssignTypeAndName(pi->dixdev, xiclass,
                          pi->name ? pi->name : "Generic KDrive Pointer");

        return Success;

    case DEVICE_ON:
        if (pDev->on == TRUE)
            return Success;

        if (!pi->driver->Enable) {
            ErrorF("no enable function\n");
            return BadImplementation;
        }

        if ((*pi->driver->Enable) (pi) == Success) {
            pDev->on = TRUE;
            return Success;
        }
        else {
            return BadImplementation;
        }

        return Success;

    case DEVICE_OFF:
        if (pDev->on == FALSE) {
            return Success;
        }

        if (!pi->driver->Disable) {
            return BadImplementation;
        }
        else {
            (*pi->driver->Disable) (pi);
            pDev->on = FALSE;
            return Success;
        }

        return Success;

    case DEVICE_CLOSE:
        if (pDev->on) {
            if (!pi->driver->Disable) {
                return BadImplementation;
            }
            (*pi->driver->Disable) (pi);
            pDev->on = FALSE;
        }

        if (!pi->driver->Fini)
            return BadImplementation;

        (*pi->driver->Fini) (pi);

        KdRemovePointer(pi);

        return Success;
    }

    /* NOTREACHED */
    return BadImplementation;
}

Bool
LegalModifier(unsigned int key, DeviceIntPtr pDev)
{
    return TRUE;
}

static void
KdBell(int volume, DeviceIntPtr pDev, void *arg, int something)
{
    KeybdCtrl *ctrl = arg;
    KdKeyboardInfo *ki = NULL;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDev->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDev->id || !ki->driver)
        return;

    KdRingBell(ki, volume, ctrl->bell_pitch, ctrl->bell_duration);
}

void
DDXRingBell(int volume, int pitch, int duration)
{
    KdKeyboardInfo *ki = NULL;

    if (kdOsFuncs->Bell) {
        (*kdOsFuncs->Bell) (volume, pitch, duration);
    }
    else {
        for (ki = kdKeyboards; ki; ki = ki->next) {
            if (ki->dixdev->coreEvents)
                KdRingBell(ki, volume, pitch, duration);
        }
    }
}

void
KdRingBell(KdKeyboardInfo * ki, int volume, int pitch, int duration)
{
    if (!ki || !ki->driver || !ki->driver->Bell)
        return;

    if (kdInputEnabled)
        (*ki->driver->Bell) (ki, volume, pitch, duration);
}

static void
KdSetLeds(KdKeyboardInfo * ki, int leds)
{
    if (!ki || !ki->driver)
        return;

    if (kdInputEnabled) {
        if (ki->driver->Leds)
            (*ki->driver->Leds) (ki, leds);
    }
}

void
KdSetLed(KdKeyboardInfo * ki, int led, Bool on)
{
    if (!ki || !ki->dixdev || !ki->dixdev->kbdfeed)
        return;

    NoteLedState(ki->dixdev, led, on);
    KdSetLeds(ki, ki->dixdev->kbdfeed->ctrl.leds);
}

void
KdSetPointerMatrix(KdPointerMatrix * matrix)
{
    kdPointerMatrix = *matrix;
}

void
KdComputePointerMatrix(KdPointerMatrix * m, Rotation randr, int width,
                       int height)
{
    int x_dir = 1, y_dir = 1;
    int i, j;
    int size[2];

    size[0] = width;
    size[1] = height;
    if (randr & RR_Reflect_X)
        x_dir = -1;
    if (randr & RR_Reflect_Y)
        y_dir = -1;
    switch (randr & (RR_Rotate_All)) {
    case RR_Rotate_0:
        m->matrix[0][0] = x_dir;
        m->matrix[0][1] = 0;
        m->matrix[1][0] = 0;
        m->matrix[1][1] = y_dir;
        break;
    case RR_Rotate_90:
        m->matrix[0][0] = 0;
        m->matrix[0][1] = -x_dir;
        m->matrix[1][0] = y_dir;
        m->matrix[1][1] = 0;
        break;
    case RR_Rotate_180:
        m->matrix[0][0] = -x_dir;
        m->matrix[0][1] = 0;
        m->matrix[1][0] = 0;
        m->matrix[1][1] = -y_dir;
        break;
    case RR_Rotate_270:
        m->matrix[0][0] = 0;
        m->matrix[0][1] = x_dir;
        m->matrix[1][0] = -y_dir;
        m->matrix[1][1] = 0;
        break;
    }
    for (i = 0; i < 2; i++) {
        m->matrix[i][2] = 0;
        for (j = 0; j < 2; j++)
            if (m->matrix[i][j] < 0)
                m->matrix[i][2] = size[j] - 1;
    }
}

void
KdScreenToPointerCoords(int *x, int *y)
{
    int (*m)[3] = kdPointerMatrix.matrix;
    int div = m[0][1] * m[1][0] - m[1][1] * m[0][0];
    int sx = *x;
    int sy = *y;

    *x = (m[0][1] * sy - m[0][1] * m[1][2] + m[1][1] * m[0][2] -
          m[1][1] * sx) / div;
    *y = (m[1][0] * sx + m[0][0] * m[1][2] - m[1][0] * m[0][2] -
          m[0][0] * sy) / div;
}

static void
KdKbdCtrl(DeviceIntPtr pDevice, KeybdCtrl * ctrl)
{
    KdKeyboardInfo *ki;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDevice->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDevice->id || !ki->driver)
        return;

    KdSetLeds(ki, ctrl->leds);
    ki->bellPitch = ctrl->bell_pitch;
    ki->bellDuration = ctrl->bell_duration;
}

static int
KdKeyboardProc(DeviceIntPtr pDevice, int onoff)
{
    Bool ret;
    DevicePtr pDev = (DevicePtr) pDevice;
    KdKeyboardInfo *ki;
    Atom xiclass;
    XkbRMLVOSet rmlvo;

    if (!pDev)
        return BadImplementation;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDevice->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDevice->id) {
        return BadImplementation;
    }

    switch (onoff) {
    case DEVICE_INIT:
#ifdef DEBUG
        ErrorF("initialising keyboard %s\n", ki->name);
#endif
        if (!ki->driver) {
            if (!ki->driverPrivate) {
                ErrorF("no driver specified!\n");
                return BadImplementation;
            }

            ki->driver = KdFindKeyboardDriver(ki->driverPrivate);
            if (!ki->driver) {
                ErrorF("Couldn't find keyboard driver %s\n",
                       ki->driverPrivate ? (char *) ki->driverPrivate :
                       "(unnamed)");
                return !Success;
            }
            free(ki->driverPrivate);
            ki->driverPrivate = NULL;
        }

        if (!ki->driver->Init) {
            ErrorF("Keyboard %s: no init function\n", ki->name);
            return BadImplementation;
        }

        if ((*ki->driver->Init) (ki) != Success) {
            return !Success;
        }

        memset(&rmlvo, 0, sizeof(rmlvo));
        rmlvo.rules = ki->xkbRules;
        rmlvo.model = ki->xkbModel;
        rmlvo.layout = ki->xkbLayout;
        rmlvo.variant = ki->xkbVariant;
        rmlvo.options = ki->xkbOptions;
        ret = InitKeyboardDeviceStruct(pDevice, &rmlvo, KdBell, KdKbdCtrl);
        if (!ret) {
            ErrorF("Couldn't initialise keyboard %s\n", ki->name);
            return BadImplementation;
        }

        xiclass = AtomFromName(XI_KEYBOARD);
        AssignTypeAndName(pDevice, xiclass,
                          ki->name ? ki->name : "Generic KDrive Keyboard");

        KdResetInputMachine();

        return Success;

    case DEVICE_ON:
        if (pDev->on == TRUE)
            return Success;

        if (!ki->driver->Enable)
            return BadImplementation;

        if ((*ki->driver->Enable) (ki) != Success) {
            return BadMatch;
        }

        pDev->on = TRUE;
        return Success;

    case DEVICE_OFF:
        if (pDev->on == FALSE)
            return Success;

        if (!ki->driver->Disable)
            return BadImplementation;

        (*ki->driver->Disable) (ki);
        pDev->on = FALSE;

        return Success;

        break;

    case DEVICE_CLOSE:
        if (pDev->on) {
            if (!ki->driver->Disable)
                return BadImplementation;

            (*ki->driver->Disable) (ki);
            pDev->on = FALSE;
        }

        if (!ki->driver->Fini)
            return BadImplementation;

        (*ki->driver->Fini) (ki);

        KdRemoveKeyboard(ki);

        return Success;
    }

    /* NOTREACHED */
    return BadImplementation;
}

void
KdAddPointerDriver(KdPointerDriver * driver)
{
    KdPointerDriver **prev;

    if (!driver)
        return;

    for (prev = &kdPointerDrivers; *prev; prev = &(*prev)->next) {
        if (*prev == driver)
            return;
    }
    *prev = driver;
}

void
KdRemovePointerDriver(KdPointerDriver * driver)
{
    KdPointerDriver *tmp;

    if (!driver)
        return;

    /* FIXME remove all pointers using this driver */
    for (tmp = kdPointerDrivers; tmp; tmp = tmp->next) {
        if (tmp->next == driver)
            tmp->next = driver->next;
    }
    if (tmp == driver)
        tmp = NULL;
}

void
KdAddKeyboardDriver(KdKeyboardDriver * driver)
{
    KdKeyboardDriver **prev;

    if (!driver)
        return;

    for (prev = &kdKeyboardDrivers; *prev; prev = &(*prev)->next) {
        if (*prev == driver)
            return;
    }
    *prev = driver;
}

void
KdRemoveKeyboardDriver(KdKeyboardDriver * driver)
{
    KdKeyboardDriver *tmp;

    if (!driver)
        return;

    /* FIXME remove all keyboards using this driver */
    for (tmp = kdKeyboardDrivers; tmp; tmp = tmp->next) {
        if (tmp->next == driver)
            tmp->next = driver->next;
    }
    if (tmp == driver)
        tmp = NULL;
}

KdKeyboardInfo *
KdNewKeyboard(void)
{
    KdKeyboardInfo *ki = calloc(sizeof(KdKeyboardInfo), 1);

    if (!ki)
        return NULL;

    ki->minScanCode = 0;
    ki->maxScanCode = 0;
    ki->leds = 0;
    ki->bellPitch = 1000;
    ki->bellDuration = 200;
    ki->next = NULL;
    ki->options = NULL;
    ki->xkbRules = strdup(XKB_DFLT_RULES);
    ki->xkbModel = strdup(XKB_DFLT_MODEL);
    ki->xkbLayout = strdup(XKB_DFLT_LAYOUT);
    ki->xkbVariant = strdup(XKB_DFLT_VARIANT);
    ki->xkbOptions = strdup(XKB_DFLT_OPTIONS);

    return ki;
}

int
KdAddConfigKeyboard(char *keyboard)
{
    struct KdConfigDevice **prev, *new;

    if (!keyboard)
        return Success;

    new = (struct KdConfigDevice *) calloc(sizeof(struct KdConfigDevice), 1);
    if (!new)
        return BadAlloc;

    new->line = strdup(keyboard);
    new->next = NULL;

    for (prev = &kdConfigKeyboards; *prev; prev = &(*prev)->next);
    *prev = new;

    return Success;
}

int
KdAddKeyboard(KdKeyboardInfo * ki)
{
    KdKeyboardInfo **prev;

    if (!ki)
        return !Success;

    ki->dixdev = AddInputDevice(serverClient, KdKeyboardProc, TRUE);
    if (!ki->dixdev) {
        ErrorF("Couldn't register keyboard device %s\n",
               ki->name ? ki->name : "(unnamed)");
        return !Success;
    }

#ifdef DEBUG
    ErrorF("added keyboard %s with dix id %d\n", ki->name, ki->dixdev->id);
#endif

    for (prev = &kdKeyboards; *prev; prev = &(*prev)->next);
    *prev = ki;

    return Success;
}

void
KdRemoveKeyboard(KdKeyboardInfo * ki)
{
    KdKeyboardInfo **prev;

    if (!ki)
        return;

    for (prev = &kdKeyboards; *prev; prev = &(*prev)->next) {
        if (*prev == ki) {
            *prev = ki->next;
            break;
        }
    }

    KdFreeKeyboard(ki);
}

int
KdAddConfigPointer(char *pointer)
{
    struct KdConfigDevice **prev, *new;

    if (!pointer)
        return Success;

    new = (struct KdConfigDevice *) calloc(sizeof(struct KdConfigDevice), 1);
    if (!new)
        return BadAlloc;

    new->line = strdup(pointer);
    new->next = NULL;

    for (prev = &kdConfigPointers; *prev; prev = &(*prev)->next);
    *prev = new;

    return Success;
}

int
KdAddPointer(KdPointerInfo * pi)
{
    KdPointerInfo **prev;

    if (!pi)
        return Success;

    pi->mouseState = start;
    pi->eventHeld = FALSE;

    pi->dixdev = AddInputDevice(serverClient, KdPointerProc, TRUE);
    if (!pi->dixdev) {
        ErrorF("Couldn't add pointer device %s\n",
               pi->name ? pi->name : "(unnamed)");
        return BadDevice;
    }

    for (prev = &kdPointers; *prev; prev = &(*prev)->next);
    *prev = pi;

    return Success;
}

void
KdRemovePointer(KdPointerInfo * pi)
{
    KdPointerInfo **prev;

    if (!pi)
        return;

    for (prev = &kdPointers; *prev; prev = &(*prev)->next) {
        if (*prev == pi) {
            *prev = pi->next;
            break;
        }
    }

    KdFreePointer(pi);
}

/*
 * You can call your kdriver server with something like:
 * $ ./hw/kdrive/yourserver/X :1 -mouse evdev,,device=/dev/input/event4 -keybd
 * evdev,,device=/dev/input/event1,xkbmodel=abnt2,xkblayout=br
 */
static Bool
KdGetOptions(InputOption **options, char *string)
{
    InputOption *newopt = NULL;
    char *key = NULL, *value = NULL;
    int tam_key = 0;

    if (strchr(string, '=')) {
        tam_key = (strchr(string, '=') - string);
        key = strndup(string, tam_key);
        if (!key)
            goto out;

        value = strdup(strchr(string, '=') + 1);
        if (!value)
            goto out;
    }
    else {
        key = strdup(string);
        value = NULL;
    }

    newopt = input_option_new(*options, key, value);
    if (newopt)
        *options = newopt;

 out:
    free(key);
    free(value);

    return (newopt != NULL);
}

static void
KdParseKbdOptions(KdKeyboardInfo * ki)
{
    InputOption *option = NULL;

    nt_list_for_each_entry(option, ki->options, list.next) {
        const char *key = input_option_get_key(option);
        const char *value = input_option_get_value(option);

        if (strcasecmp(key, "XkbRules") == 0)
            ki->xkbRules = strdup(value);
        else if (strcasecmp(key, "XkbModel") == 0)
            ki->xkbModel = strdup(value);
        else if (strcasecmp(key, "XkbLayout") == 0)
            ki->xkbLayout = strdup(value);
        else if (strcasecmp(key, "XkbVariant") == 0)
            ki->xkbVariant = strdup(value);
        else if (strcasecmp(key, "XkbOptions") == 0)
            ki->xkbOptions = strdup(value);
        else if (!strcasecmp(key, "device"))
            ki->path = strdup(value);
        else
            ErrorF("Kbd option key (%s) of value (%s) not assigned!\n",
                   key, value);
    }
}

KdKeyboardInfo *
KdParseKeyboard(const char *arg)
{
    char save[1024];
    char delim;
    InputOption *options = NULL;
    KdKeyboardInfo *ki = NULL;

    ki = KdNewKeyboard();
    if (!ki)
        return NULL;

    ki->name = strdup("Unknown KDrive Keyboard");
    ki->path = NULL;
    ki->driver = NULL;
    ki->driverPrivate = NULL;
    ki->next = NULL;

    if (!arg) {
        ErrorF("keybd: no arg\n");
        KdFreeKeyboard(ki);
        return NULL;
    }

    if (strlen(arg) >= sizeof(save)) {
        ErrorF("keybd: arg too long\n");
        KdFreeKeyboard(ki);
        return NULL;
    }

    arg = KdParseFindNext(arg, ",", save, &delim);
    if (!save[0]) {
        ErrorF("keybd: failed on save[0]\n");
        KdFreeKeyboard(ki);
        return NULL;
    }

    if (strcmp(save, "auto") == 0)
        ki->driverPrivate = NULL;
    else
        ki->driverPrivate = strdup(save);

    if (delim != ',') {
        return ki;
    }

    arg = KdParseFindNext(arg, ",", save, &delim);

    while (delim == ',') {
        arg = KdParseFindNext(arg, ",", save, &delim);

        if (!KdGetOptions(&options, save)) {
            KdFreeKeyboard(ki);
            return NULL;
        }
    }

    if (options) {
        ki->options = options;
        KdParseKbdOptions(ki);
    }

    return ki;
}

static void
KdParsePointerOptions(KdPointerInfo * pi)
{
    InputOption *option = NULL;

    nt_list_for_each_entry(option, pi->options, list.next) {
        const char *key = input_option_get_key(option);
        const char *value = input_option_get_value(option);

        if (!strcmp(key, "emulatemiddle"))
            pi->emulateMiddleButton = TRUE;
        else if (!strcmp(key, "noemulatemiddle"))
            pi->emulateMiddleButton = FALSE;
        else if (!strcmp(key, "transformcoord"))
            pi->transformCoordinates = TRUE;
        else if (!strcmp(key, "rawcoord"))
            pi->transformCoordinates = FALSE;
        else if (!strcasecmp(key, "device"))
            pi->path = strdup(value);
        else if (!strcasecmp(key, "protocol"))
            pi->protocol = strdup(value);
        else
            ErrorF("Pointer option key (%s) of value (%s) not assigned!\n",
                   key, value);
    }
}

KdPointerInfo *
KdParsePointer(const char *arg)
{
    char save[1024];
    char delim;
    KdPointerInfo *pi = NULL;
    InputOption *options = NULL;
    int i = 0;

    pi = KdNewPointer();
    if (!pi)
        return NULL;
    pi->emulateMiddleButton = kdEmulateMiddleButton;
    pi->transformCoordinates = !kdRawPointerCoordinates;
    pi->protocol = NULL;
    pi->nButtons = 5;           /* XXX should not be hardcoded */
    pi->inputClass = KD_MOUSE;

    if (!arg) {
        ErrorF("mouse: no arg\n");
        KdFreePointer(pi);
        return NULL;
    }

    if (strlen(arg) >= sizeof(save)) {
        ErrorF("mouse: arg too long\n");
        KdFreePointer(pi);
        return NULL;
    }
    arg = KdParseFindNext(arg, ",", save, &delim);
    if (!save[0]) {
        ErrorF("failed on save[0]\n");
        KdFreePointer(pi);
        return NULL;
    }

    if (strcmp(save, "auto") == 0)
        pi->driverPrivate = NULL;
    else
        pi->driverPrivate = strdup(save);

    if (delim != ',') {
        return pi;
    }

    arg = KdParseFindNext(arg, ",", save, &delim);

    while (delim == ',') {
        arg = KdParseFindNext(arg, ",", save, &delim);
        if (save[0] == '{') {
            char *s = save + 1;

            i = 0;
            while (*s && *s != '}') {
                if ('1' <= *s && *s <= '0' + pi->nButtons)
                    pi->map[i] = *s - '0';
                else
                    UseMsg();
                s++;
            }
        }
        else {
            if (!KdGetOptions(&options, save)) {
                KdFreePointer(pi);
                return NULL;
            }
        }
    }

    if (options) {
        pi->options = options;
        KdParsePointerOptions(pi);
    }

    return pi;
}

void
KdInitInput(void)
{
    KdPointerInfo *pi;
    KdKeyboardInfo *ki;
    struct KdConfigDevice *dev;

    kdInputEnabled = TRUE;

    for (dev = kdConfigPointers; dev; dev = dev->next) {
        pi = KdParsePointer(dev->line);
        if (!pi)
            ErrorF("Failed to parse pointer\n");
        if (KdAddPointer(pi) != Success)
            ErrorF("Failed to add pointer!\n");
    }
    for (dev = kdConfigKeyboards; dev; dev = dev->next) {
        ki = KdParseKeyboard(dev->line);
        if (!ki)
            ErrorF("Failed to parse keyboard\n");
        if (KdAddKeyboard(ki) != Success)
            ErrorF("Failed to add keyboard!\n");
    }

    mieqInit();
}

void
KdCloseInput(void)
{
    mieqFini();
}

/*
 * Middle button emulation state machine
 *
 *  Possible transitions:
 *	Button 1 press	    v1
 *	Button 1 release    ^1
 *	Button 2 press	    v2
 *	Button 2 release    ^2
 *	Button 3 press	    v3
 *	Button 3 release    ^3
 *	Button other press  vo
 *	Button other release ^o
 *	Mouse motion	    <>
 *	Keyboard event	    k
 *	timeout		    ...
 *	outside box	    <->
 *
 *  States:
 *	start
 *	button_1_pend
 *	button_1_down
 *	button_2_down
 *	button_3_pend
 *	button_3_down
 *	synthetic_2_down_13
 *	synthetic_2_down_3
 *	synthetic_2_down_1
 *
 *  Transition diagram
 *
 *  start
 *	v1  -> (hold) (settimeout) button_1_pend
 *	^1  -> (deliver) start
 *	v2  -> (deliver) button_2_down
 *	^2  -> (deliever) start
 *	v3  -> (hold) (settimeout) button_3_pend
 *	^3  -> (deliver) start
 *	vo  -> (deliver) start
 *	^o  -> (deliver) start
 *	<>  -> (deliver) start
 *	k   -> (deliver) start
 *
 *  button_1_pend	(button 1 is down, timeout pending)
 *	^1  -> (release) (deliver) start
 *	v2  -> (release) (deliver) button_1_down
 *	^2  -> (release) (deliver) button_1_down
 *	v3  -> (cleartimeout) (generate v2) synthetic_2_down_13
 *	^3  -> (release) (deliver) button_1_down
 *	vo  -> (release) (deliver) button_1_down
 *	^o  -> (release) (deliver) button_1_down
 *	<-> -> (release) (deliver) button_1_down
 *	<>  -> (deliver) button_1_pend
 *	k   -> (release) (deliver) button_1_down
 *	... -> (release) button_1_down
 *
 *  button_1_down	(button 1 is down)
 *	^1  -> (deliver) start
 *	v2  -> (deliver) button_1_down
 *	^2  -> (deliver) button_1_down
 *	v3  -> (deliver) button_1_down
 *	^3  -> (deliver) button_1_down
 *	vo  -> (deliver) button_1_down
 *	^o  -> (deliver) button_1_down
 *	<>  -> (deliver) button_1_down
 *	k   -> (deliver) button_1_down
 *
 *  button_2_down	(button 2 is down)
 *	v1  -> (deliver) button_2_down
 *	^1  -> (deliver) button_2_down
 *	^2  -> (deliver) start
 *	v3  -> (deliver) button_2_down
 *	^3  -> (deliver) button_2_down
 *	vo  -> (deliver) button_2_down
 *	^o  -> (deliver) button_2_down
 *	<>  -> (deliver) button_2_down
 *	k   -> (deliver) button_2_down
 *
 *  button_3_pend	(button 3 is down, timeout pending)
 *	v1  -> (generate v2) synthetic_2_down
 *	^1  -> (release) (deliver) button_3_down
 *	v2  -> (release) (deliver) button_3_down
 *	^2  -> (release) (deliver) button_3_down
 *	^3  -> (release) (deliver) start
 *	vo  -> (release) (deliver) button_3_down
 *	^o  -> (release) (deliver) button_3_down
 *	<-> -> (release) (deliver) button_3_down
 *	<>  -> (deliver) button_3_pend
 *	k   -> (release) (deliver) button_3_down
 *	... -> (release) button_3_down
 *
 *  button_3_down	(button 3 is down)
 *	v1  -> (deliver) button_3_down
 *	^1  -> (deliver) button_3_down
 *	v2  -> (deliver) button_3_down
 *	^2  -> (deliver) button_3_down
 *	^3  -> (deliver) start
 *	vo  -> (deliver) button_3_down
 *	^o  -> (deliver) button_3_down
 *	<>  -> (deliver) button_3_down
 *	k   -> (deliver) button_3_down
 *
 *  synthetic_2_down_13	(button 1 and 3 are down)
 *	^1  -> (generate ^2) synthetic_2_down_3
 *	v2  -> synthetic_2_down_13
 *	^2  -> synthetic_2_down_13
 *	^3  -> (generate ^2) synthetic_2_down_1
 *	vo  -> (deliver) synthetic_2_down_13
 *	^o  -> (deliver) synthetic_2_down_13
 *	<>  -> (deliver) synthetic_2_down_13
 *	k   -> (deliver) synthetic_2_down_13
 *
 *  synthetic_2_down_3 (button 3 is down)
 *	v1  -> (deliver) synthetic_2_down_3
 *	^1  -> (deliver) synthetic_2_down_3
 *	v2  -> synthetic_2_down_3
 *	^2  -> synthetic_2_down_3
 *	^3  -> start
 *	vo  -> (deliver) synthetic_2_down_3
 *	^o  -> (deliver) synthetic_2_down_3
 *	<>  -> (deliver) synthetic_2_down_3
 *	k   -> (deliver) synthetic_2_down_3
 *
 *  synthetic_2_down_1 (button 1 is down)
 *	^1  -> start
 *	v2  -> synthetic_2_down_1
 *	^2  -> synthetic_2_down_1
 *	v3  -> (deliver) synthetic_2_down_1
 *	^3  -> (deliver) synthetic_2_down_1
 *	vo  -> (deliver) synthetic_2_down_1
 *	^o  -> (deliver) synthetic_2_down_1
 *	<>  -> (deliver) synthetic_2_down_1
 *	k   -> (deliver) synthetic_2_down_1
 */

typedef enum _inputClass {
    down_1, up_1,
    down_2, up_2,
    down_3, up_3,
    down_o, up_o,
    motion, outside_box,
    keyboard, timeout,
    num_input_class
} KdInputClass;

typedef enum _inputAction {
    noop,
    hold,
    setto,
    deliver,
    release,
    clearto,
    gen_down_2,
    gen_up_2
} KdInputAction;

#define MAX_ACTIONS 2

typedef struct _inputTransition {
    KdInputAction actions[MAX_ACTIONS];
    KdPointerState nextState;
} KdInputTransition;

static const
KdInputTransition kdInputMachine[num_input_states][num_input_class] = {
    /* start */
    {
     {{hold, setto}, button_1_pend},    /* v1 */
     {{deliver, noop}, start},  /* ^1 */
     {{deliver, noop}, button_2_down},  /* v2 */
     {{deliver, noop}, start},  /* ^2 */
     {{hold, setto}, button_3_pend},    /* v3 */
     {{deliver, noop}, start},  /* ^3 */
     {{deliver, noop}, start},  /* vo */
     {{deliver, noop}, start},  /* ^o */
     {{deliver, noop}, start},  /* <> */
     {{deliver, noop}, start},  /* <-> */
     {{noop, noop}, start},     /* k */
     {{noop, noop}, start},     /* ... */
     },
    /* button_1_pend */
    {
     {{noop, noop}, button_1_pend},     /* v1 */
     {{release, deliver}, start},       /* ^1 */
     {{release, deliver}, button_1_down},       /* v2 */
     {{release, deliver}, button_1_down},       /* ^2 */
     {{clearto, gen_down_2}, synth_2_down_13},  /* v3 */
     {{release, deliver}, button_1_down},       /* ^3 */
     {{release, deliver}, button_1_down},       /* vo */
     {{release, deliver}, button_1_down},       /* ^o */
     {{deliver, noop}, button_1_pend},  /* <> */
     {{release, deliver}, button_1_down},       /* <-> */
     {{noop, noop}, button_1_down},     /* k */
     {{release, noop}, button_1_down},  /* ... */
     },
    /* button_1_down */
    {
     {{noop, noop}, button_1_down},     /* v1 */
     {{deliver, noop}, start},  /* ^1 */
     {{deliver, noop}, button_1_down},  /* v2 */
     {{deliver, noop}, button_1_down},  /* ^2 */
     {{deliver, noop}, button_1_down},  /* v3 */
     {{deliver, noop}, button_1_down},  /* ^3 */
     {{deliver, noop}, button_1_down},  /* vo */
     {{deliver, noop}, button_1_down},  /* ^o */
     {{deliver, noop}, button_1_down},  /* <> */
     {{deliver, noop}, button_1_down},  /* <-> */
     {{noop, noop}, button_1_down},     /* k */
     {{noop, noop}, button_1_down},     /* ... */
     },
    /* button_2_down */
    {
     {{deliver, noop}, button_2_down},  /* v1 */
     {{deliver, noop}, button_2_down},  /* ^1 */
     {{noop, noop}, button_2_down},     /* v2 */
     {{deliver, noop}, start},  /* ^2 */
     {{deliver, noop}, button_2_down},  /* v3 */
     {{deliver, noop}, button_2_down},  /* ^3 */
     {{deliver, noop}, button_2_down},  /* vo */
     {{deliver, noop}, button_2_down},  /* ^o */
     {{deliver, noop}, button_2_down},  /* <> */
     {{deliver, noop}, button_2_down},  /* <-> */
     {{noop, noop}, button_2_down},     /* k */
     {{noop, noop}, button_2_down},     /* ... */
     },
    /* button_3_pend */
    {
     {{clearto, gen_down_2}, synth_2_down_13},  /* v1 */
     {{release, deliver}, button_3_down},       /* ^1 */
     {{release, deliver}, button_3_down},       /* v2 */
     {{release, deliver}, button_3_down},       /* ^2 */
     {{release, deliver}, button_3_down},       /* v3 */
     {{release, deliver}, start},       /* ^3 */
     {{release, deliver}, button_3_down},       /* vo */
     {{release, deliver}, button_3_down},       /* ^o */
     {{deliver, noop}, button_3_pend},  /* <> */
     {{release, deliver}, button_3_down},       /* <-> */
     {{release, noop}, button_3_down},  /* k */
     {{release, noop}, button_3_down},  /* ... */
     },
    /* button_3_down */
    {
     {{deliver, noop}, button_3_down},  /* v1 */
     {{deliver, noop}, button_3_down},  /* ^1 */
     {{deliver, noop}, button_3_down},  /* v2 */
     {{deliver, noop}, button_3_down},  /* ^2 */
     {{noop, noop}, button_3_down},     /* v3 */
     {{deliver, noop}, start},  /* ^3 */
     {{deliver, noop}, button_3_down},  /* vo */
     {{deliver, noop}, button_3_down},  /* ^o */
     {{deliver, noop}, button_3_down},  /* <> */
     {{deliver, noop}, button_3_down},  /* <-> */
     {{noop, noop}, button_3_down},     /* k */
     {{noop, noop}, button_3_down},     /* ... */
     },
    /* synthetic_2_down_13 */
    {
     {{noop, noop}, synth_2_down_13},   /* v1 */
     {{gen_up_2, noop}, synth_2_down_3},        /* ^1 */
     {{noop, noop}, synth_2_down_13},   /* v2 */
     {{noop, noop}, synth_2_down_13},   /* ^2 */
     {{noop, noop}, synth_2_down_13},   /* v3 */
     {{gen_up_2, noop}, synth_2_down_1},        /* ^3 */
     {{deliver, noop}, synth_2_down_13},        /* vo */
     {{deliver, noop}, synth_2_down_13},        /* ^o */
     {{deliver, noop}, synth_2_down_13},        /* <> */
     {{deliver, noop}, synth_2_down_13},        /* <-> */
     {{noop, noop}, synth_2_down_13},   /* k */
     {{noop, noop}, synth_2_down_13},   /* ... */
     },
    /* synthetic_2_down_3 */
    {
     {{deliver, noop}, synth_2_down_3}, /* v1 */
     {{deliver, noop}, synth_2_down_3}, /* ^1 */
     {{deliver, noop}, synth_2_down_3}, /* v2 */
     {{deliver, noop}, synth_2_down_3}, /* ^2 */
     {{noop, noop}, synth_2_down_3},    /* v3 */
     {{noop, noop}, start},     /* ^3 */
     {{deliver, noop}, synth_2_down_3}, /* vo */
     {{deliver, noop}, synth_2_down_3}, /* ^o */
     {{deliver, noop}, synth_2_down_3}, /* <> */
     {{deliver, noop}, synth_2_down_3}, /* <-> */
     {{noop, noop}, synth_2_down_3},    /* k */
     {{noop, noop}, synth_2_down_3},    /* ... */
     },
    /* synthetic_2_down_1 */
    {
     {{noop, noop}, synth_2_down_1},    /* v1 */
     {{noop, noop}, start},     /* ^1 */
     {{deliver, noop}, synth_2_down_1}, /* v2 */
     {{deliver, noop}, synth_2_down_1}, /* ^2 */
     {{deliver, noop}, synth_2_down_1}, /* v3 */
     {{deliver, noop}, synth_2_down_1}, /* ^3 */
     {{deliver, noop}, synth_2_down_1}, /* vo */
     {{deliver, noop}, synth_2_down_1}, /* ^o */
     {{deliver, noop}, synth_2_down_1}, /* <> */
     {{deliver, noop}, synth_2_down_1}, /* <-> */
     {{noop, noop}, synth_2_down_1},    /* k */
     {{noop, noop}, synth_2_down_1},    /* ... */
     },
};

#define EMULATION_WINDOW    10
#define EMULATION_TIMEOUT   100

static int
KdInsideEmulationWindow(KdPointerInfo * pi, int x, int y, int z)
{
    pi->emulationDx = pi->heldEvent.x - x;
    pi->emulationDy = pi->heldEvent.y - y;

    return (abs(pi->emulationDx) < EMULATION_WINDOW &&
            abs(pi->emulationDy) < EMULATION_WINDOW);
}

static KdInputClass
KdClassifyInput(KdPointerInfo * pi, int type, int x, int y, int z, int b)
{
    switch (type) {
    case ButtonPress:
        switch (b) {
        case 1:
            return down_1;
        case 2:
            return down_2;
        case 3:
            return down_3;
        default:
            return down_o;
        }
        break;
    case ButtonRelease:
        switch (b) {
        case 1:
            return up_1;
        case 2:
            return up_2;
        case 3:
            return up_3;
        default:
            return up_o;
        }
        break;
    case MotionNotify:
        if (pi->eventHeld && !KdInsideEmulationWindow(pi, x, y, z))
            return outside_box;
        else
            return motion;
    default:
        return keyboard;
    }
    return keyboard;
}

/* We return true if we're stealing the event. */
static Bool
KdRunMouseMachine(KdPointerInfo * pi, KdInputClass c, int type, int x, int y,
                  int z, int b, int absrel)
{
    const KdInputTransition *t;
    int a;

    c = KdClassifyInput(pi, type, x, y, z, b);
    t = &kdInputMachine[pi->mouseState][c];
    for (a = 0; a < MAX_ACTIONS; a++) {
        switch (t->actions[a]) {
        case noop:
            break;
        case hold:
            pi->eventHeld = TRUE;
            pi->emulationDx = 0;
            pi->emulationDy = 0;
            pi->heldEvent.type = type;
            pi->heldEvent.x = x;
            pi->heldEvent.y = y;
            pi->heldEvent.z = z;
            pi->heldEvent.flags = b;
            pi->heldEvent.absrel = absrel;
            return TRUE;
            break;
        case setto:
            pi->emulationTimeout = GetTimeInMillis() + EMULATION_TIMEOUT;
            pi->timeoutPending = TRUE;
            break;
        case deliver:
            _KdEnqueuePointerEvent(pi, pi->heldEvent.type, pi->heldEvent.x,
                                   pi->heldEvent.y, pi->heldEvent.z,
                                   pi->heldEvent.flags, pi->heldEvent.absrel,
                                   TRUE);
            break;
        case release:
            pi->eventHeld = FALSE;
            pi->timeoutPending = FALSE;
            _KdEnqueuePointerEvent(pi, pi->heldEvent.type, pi->heldEvent.x,
                                   pi->heldEvent.y, pi->heldEvent.z,
                                   pi->heldEvent.flags, pi->heldEvent.absrel,
                                   TRUE);
            return TRUE;
            break;
        case clearto:
            pi->timeoutPending = FALSE;
            break;
        case gen_down_2:
            _KdEnqueuePointerEvent(pi, ButtonPress, x, y, z, 2, absrel, TRUE);
            pi->eventHeld = FALSE;
            return TRUE;
            break;
        case gen_up_2:
            _KdEnqueuePointerEvent(pi, ButtonRelease, x, y, z, 2, absrel, TRUE);
            return TRUE;
            break;
        }
    }
    pi->mouseState = t->nextState;
    return FALSE;
}

static int
KdHandlePointerEvent(KdPointerInfo * pi, int type, int x, int y, int z, int b,
                     int absrel)
{
    if (pi->emulateMiddleButton)
        return KdRunMouseMachine(pi, KdClassifyInput(pi, type, x, y, z, b),
                                 type, x, y, z, b, absrel);
    return FALSE;
}

static void
KdReceiveTimeout(KdPointerInfo * pi)
{
    KdRunMouseMachine(pi, timeout, 0, 0, 0, 0, 0, 0);
}

/*
 * kdCheckTermination
 *
 * This function checks for the key sequence that terminates the server.  When
 * detected, it sets the dispatchException flag and returns.  The key sequence
 * is:
 *	Control-Alt
 * It's assumed that the server will be waken up by the caller when this
 * function returns.
 */

extern int nClients;

void
KdReleaseAllKeys(void)
{
#if 0
    int key;
    KdKeyboardInfo *ki;

    OsBlockSIGIO();

    for (ki = kdKeyboards; ki; ki = ki->next) {
        for (key = ki->keySyms.minKeyCode; key < ki->keySyms.maxKeyCode; key++) {
            if (key_is_down(ki->dixdev, key, KEY_POSTED | KEY_PROCESSED)) {
                KdHandleKeyboardEvent(ki, KeyRelease, key);
                QueueGetKeyboardEvents(ki->dixdev, KeyRelease, key, NULL);
            }
        }
    }

    OsReleaseSIGIO();
#endif
}

static void
KdCheckLock(void)
{
    KeyClassPtr keyc = NULL;
    Bool isSet = FALSE, shouldBeSet = FALSE;
    KdKeyboardInfo *tmp = NULL;

    for (tmp = kdKeyboards; tmp; tmp = tmp->next) {
        if (tmp->LockLed && tmp->dixdev && tmp->dixdev->key) {
            keyc = tmp->dixdev->key;
            isSet = (tmp->leds & (1 << (tmp->LockLed - 1))) != 0;
            /* FIXME: Just use XKB indicators! */
            shouldBeSet =
                ! !(XkbStateFieldFromRec(&keyc->xkbInfo->state) & LockMask);
            if (isSet != shouldBeSet)
                KdSetLed(tmp, tmp->LockLed, shouldBeSet);
        }
    }
}

void
KdEnqueueKeyboardEvent(KdKeyboardInfo * ki,
                       unsigned char scan_code, unsigned char is_up)
{
    unsigned char key_code;
    int type;

    if (!ki || !ki->dixdev || !ki->dixdev->kbdfeed || !ki->dixdev->key)
        return;

    if (scan_code >= ki->minScanCode && scan_code <= ki->maxScanCode) {
        key_code = scan_code + KD_MIN_KEYCODE - ki->minScanCode;

        /*
         * Set up this event -- the type may be modified below
         */
        if (is_up)
            type = KeyRelease;
        else
            type = KeyPress;

        QueueKeyboardEvents(ki->dixdev, type, key_code);
    }
    else {
        ErrorF("driver %s wanted to post scancode %d outside of [%d, %d]!\n",
               ki->name, scan_code, ki->minScanCode, ki->maxScanCode);
    }
}

/*
 * kdEnqueuePointerEvent
 *
 * This function converts hardware mouse event information into X event
 * information.  A mouse movement event is passed off to MI to generate
 * a MotionNotify event, if appropriate.  Button events are created and
 * passed off to MI for enqueueing.
 */

/* FIXME do something a little more clever to deal with multiple axes here */
void
KdEnqueuePointerEvent(KdPointerInfo * pi, unsigned long flags, int rx, int ry,
                      int rz)
{
    unsigned char buttons;
    int x, y, z;
    int (*matrix)[3] = kdPointerMatrix.matrix;
    unsigned long button;
    int n;
    int dixflags = 0;

    if (!pi)
        return;

    /* we don't need to transform z, so we don't. */
    if (flags & KD_MOUSE_DELTA) {
        if (pi->transformCoordinates) {
            x = matrix[0][0] * rx + matrix[0][1] * ry;
            y = matrix[1][0] * rx + matrix[1][1] * ry;
        }
        else {
            x = rx;
            y = ry;
        }
    }
    else {
        if (pi->transformCoordinates) {
            x = matrix[0][0] * rx + matrix[0][1] * ry + matrix[0][2];
            y = matrix[1][0] * rx + matrix[1][1] * ry + matrix[1][2];
        }
        else {
            x = rx;
            y = ry;
        }
    }
    z = rz;

    if (flags & KD_MOUSE_DELTA) {
        if (x || y || z) {
            dixflags = POINTER_RELATIVE | POINTER_ACCELERATE;
            _KdEnqueuePointerEvent(pi, MotionNotify, x, y, z, 0, dixflags,
                                   FALSE);
        }
    }
    else {
        dixflags = POINTER_ABSOLUTE;
        if (flags & KD_POINTER_DESKTOP)
            dixflags |= POINTER_DESKTOP;
        if (x != pi->dixdev->last.valuators[0] ||
            y != pi->dixdev->last.valuators[1])
            _KdEnqueuePointerEvent(pi, MotionNotify, x, y, z, 0, dixflags,
                                   FALSE);
    }

    buttons = flags;

    for (button = KD_BUTTON_1, n = 1; n <= pi->nButtons; button <<= 1, n++) {
        if (((pi->buttonState & button) ^ (buttons & button)) &&
            !(buttons & button)) {
            _KdEnqueuePointerEvent(pi, ButtonRelease, x, y, z, n,
                                   dixflags, FALSE);
        }
    }
    for (button = KD_BUTTON_1, n = 1; n <= pi->nButtons; button <<= 1, n++) {
        if (((pi->buttonState & button) ^ (buttons & button)) &&
            (buttons & button)) {
            _KdEnqueuePointerEvent(pi, ButtonPress, x, y, z, n,
                                   dixflags, FALSE);
        }
    }

    pi->buttonState = buttons;
}

void
_KdEnqueuePointerEvent(KdPointerInfo * pi, int type, int x, int y, int z,
                       int b, int absrel, Bool force)
{
    int valuators[3] = { x, y, z };
    ValuatorMask mask;

    /* TRUE from KdHandlePointerEvent, means 'we swallowed the event'. */
    if (!force && KdHandlePointerEvent(pi, type, x, y, z, b, absrel))
        return;

    valuator_mask_set_range(&mask, 0, 3, valuators);

    QueuePointerEvents(pi->dixdev, type, b, absrel, &mask);
}

void
KdBlockHandler(ScreenPtr pScreen, void *timeo, void *readmask)
{
    KdPointerInfo *pi;
    int myTimeout = 0;

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->timeoutPending) {
            int ms;

            ms = pi->emulationTimeout - GetTimeInMillis();
            if (ms < 1)
                ms = 1;
            if (ms < myTimeout || myTimeout == 0)
                myTimeout = ms;
        }
    }
    /* if we need to poll for events, do that */
    if (kdOsFuncs->pollEvents) {
        (*kdOsFuncs->pollEvents) ();
        myTimeout = 20;
    }
    if (myTimeout > 0)
        AdjustWaitForDelay(timeo, myTimeout);
}

void
KdWakeupHandler(ScreenPtr pScreen, unsigned long lresult, void *readmask)
{
    int result = (int) lresult;
    fd_set *pReadmask = (fd_set *) readmask;
    int i;
    KdPointerInfo *pi;

    if (kdInputEnabled && result > 0) {
        for (i = 0; i < kdNumInputFds; i++)
            if (FD_ISSET(kdInputFds[i].fd, pReadmask)) {
                OsBlockSIGIO();
                (*kdInputFds[i].read) (kdInputFds[i].fd, kdInputFds[i].closure);
                OsReleaseSIGIO();
            }
    }
    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->timeoutPending) {
            if ((long) (GetTimeInMillis() - pi->emulationTimeout) >= 0) {
                pi->timeoutPending = FALSE;
                OsBlockSIGIO();
                KdReceiveTimeout(pi);
                OsReleaseSIGIO();
            }
        }
    }
    if (kdSwitchPending)
        KdProcessSwitch();
}

#define KdScreenOrigin(pScreen) (&(KdGetScreenPriv(pScreen)->screen->origin))

static Bool
KdCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
{
    ScreenPtr pScreen = *ppScreen;
    ScreenPtr pNewScreen;
    int n;
    int dx, dy;
    int best_x, best_y;
    int n_best_x, n_best_y;
    CARD32 ms;

    if (kdDisableZaphod || screenInfo.numScreens <= 1)
        return FALSE;

    if (0 <= *x && *x < pScreen->width && 0 <= *y && *y < pScreen->height)
        return FALSE;

    ms = GetTimeInMillis();
    if (kdOffScreen && (int) (ms - kdOffScreenTime) < 1000)
        return FALSE;
    kdOffScreen = TRUE;
    kdOffScreenTime = ms;
    n_best_x = -1;
    best_x = 32767;
    n_best_y = -1;
    best_y = 32767;
    for (n = 0; n < screenInfo.numScreens; n++) {
        pNewScreen = screenInfo.screens[n];
        if (pNewScreen == pScreen)
            continue;
        dx = KdScreenOrigin(pNewScreen)->x - KdScreenOrigin(pScreen)->x;
        dy = KdScreenOrigin(pNewScreen)->y - KdScreenOrigin(pScreen)->y;
        if (*x < 0) {
            if (dx < 0 && -dx < best_x) {
                best_x = -dx;
                n_best_x = n;
            }
        }
        else if (*x >= pScreen->width) {
            if (dx > 0 && dx < best_x) {
                best_x = dx;
                n_best_x = n;
            }
        }
        if (*y < 0) {
            if (dy < 0 && -dy < best_y) {
                best_y = -dy;
                n_best_y = n;
            }
        }
        else if (*y >= pScreen->height) {
            if (dy > 0 && dy < best_y) {
                best_y = dy;
                n_best_y = n;
            }
        }
    }
    if (best_y < best_x)
        n_best_x = n_best_y;
    if (n_best_x == -1)
        return FALSE;
    pNewScreen = screenInfo.screens[n_best_x];

    if (*x < 0)
        *x += pNewScreen->width;
    if (*y < 0)
        *y += pNewScreen->height;

    if (*x >= pScreen->width)
        *x -= pScreen->width;
    if (*y >= pScreen->height)
        *y -= pScreen->height;

    *ppScreen = pNewScreen;
    return TRUE;
}

static void
KdCrossScreen(ScreenPtr pScreen, Bool entering)
{
}

int KdCurScreen;                /* current event screen */

static void
KdWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    OsBlockSIGIO();
    KdCurScreen = pScreen->myNum;
    miPointerWarpCursor(pDev, pScreen, x, y);
    OsReleaseSIGIO();
}

miPointerScreenFuncRec kdPointerScreenFuncs = {
    KdCursorOffScreen,
    KdCrossScreen,
    KdWarpCursor
};

void
ProcessInputEvents(void)
{
    mieqProcessInputEvents();
    if (kdSwitchPending)
        KdProcessSwitch();
    KdCheckLock();
}

/* At the moment, absolute/relative is up to the client. */
int
SetDeviceMode(register ClientPtr client, DeviceIntPtr pDev, int mode)
{
    return BadMatch;
}

int
SetDeviceValuators(register ClientPtr client, DeviceIntPtr pDev,
                   int *valuators, int first_valuator, int num_valuators)
{
    return BadMatch;
}

int
ChangeDeviceControl(register ClientPtr client, DeviceIntPtr pDev,
                    xDeviceCtl * control)
{
    switch (control->control) {
    case DEVICE_RESOLUTION:
        /* FIXME do something more intelligent here */
        return BadMatch;

    case DEVICE_ABS_CALIB:
    case DEVICE_ABS_AREA:
    case DEVICE_CORE:
        return BadMatch;
    case DEVICE_ENABLE:
        return Success;

    default:
        return BadMatch;
    }

    /* NOTREACHED */
    return BadImplementation;
}

int
NewInputDeviceRequest(InputOption *options, InputAttributes * attrs,
                      DeviceIntPtr *pdev)
{
    InputOption *option = NULL;
    KdPointerInfo *pi = NULL;
    KdKeyboardInfo *ki = NULL;

    nt_list_for_each_entry(option, options, list.next) {
        const char *key = input_option_get_key(option);
        const char *value = input_option_get_value(option);

        if (strcmp(key, "type") == 0) {
            if (strcmp(value, "pointer") == 0) {
                pi = KdNewPointer();
                if (!pi)
                    return BadAlloc;
            }
            else if (strcmp(value, "keyboard") == 0) {
                ki = KdNewKeyboard();
                if (!ki)
                    return BadAlloc;
            }
            else {
                ErrorF("unrecognised device type!\n");
                return BadValue;
            }
        }
#ifdef CONFIG_HAL
        else if (strcmp(key, "_source") == 0 &&
                 strcmp(value, "server/hal") == 0) {
            ErrorF("Ignoring device from HAL.\n");
            return BadValue;
        }
#endif
#ifdef CONFIG_UDEV
        else if (strcmp(key, "_source") == 0 &&
                 strcmp(value, "server/udev") == 0) {
            ErrorF("Ignoring device from udev.\n");
            return BadValue;
        }
#endif
    }

    if (!ki && !pi) {
        ErrorF("unrecognised device identifier!\n");
        return BadValue;
    }

    /* FIXME: change this code below to use KdParseKbdOptions and
     * KdParsePointerOptions */
    nt_list_for_each_entry(option, options, list.next) {
        const char *key = input_option_get_key(option);
        const char *value = input_option_get_value(option);

        if (strcmp(key, "device") == 0) {
            if (pi && value)
                pi->path = strdup(value);
            else if (ki && value)
                ki->path = strdup(value);
        }
        else if (strcmp(key, "driver") == 0) {
            if (pi) {
                pi->driver = KdFindPointerDriver(value);
                if (!pi->driver) {
                    ErrorF("couldn't find driver!\n");
                    KdFreePointer(pi);
                    return BadValue;
                }
                pi->options = options;
            }
            else if (ki) {
                ki->driver = KdFindKeyboardDriver(value);
                if (!ki->driver) {
                    ErrorF("couldn't find driver!\n");
                    KdFreeKeyboard(ki);
                    return BadValue;
                }
                ki->options = options;
            }
        }
    }

    if (pi) {
        if (KdAddPointer(pi) != Success ||
            ActivateDevice(pi->dixdev, TRUE) != Success ||
            EnableDevice(pi->dixdev, TRUE) != TRUE) {
            ErrorF("couldn't add or enable pointer\n");
            return BadImplementation;
        }
    }
    else if (ki) {
        if (KdAddKeyboard(ki) != Success ||
            ActivateDevice(ki->dixdev, TRUE) != Success ||
            EnableDevice(ki->dixdev, TRUE) != TRUE) {
            ErrorF("couldn't add or enable keyboard\n");
            return BadImplementation;
        }
    }

    if (pi) {
        *pdev = pi->dixdev;
    }
    else if (ki) {
        *pdev = ki->dixdev;
    }

    return Success;
}

void
DeleteInputDeviceRequest(DeviceIntPtr pDev)
{
    RemoveDevice(pDev, TRUE);
}
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a222 1
            kdNumInputFds--;
d225 1
a1643 35
#ifdef DEBUG
char *kdStateNames[] = {
    "start",
    "button_1_pend",
    "button_1_down",
    "button_2_down",
    "button_3_pend",
    "button_3_down",
    "synth_2_down_13",
    "synth_2_down_3",
    "synthetic_2_down_1",
    "num_input_states"
};

char *kdClassNames[] = {
    "down_1", "up_1",
    "down_2", "up_2",
    "down_3", "up_3",
    "motion", "ouside_box",
    "keyboard", "timeout",
    "num_input_class"
};

char *kdActionNames[] = {
    "noop",
    "hold",
    "setto",
    "deliver",
    "release",
    "clearto",
    "gen_down_2",
    "gen_up_2",
};
#endif                          /* DEBUG */

d1799 1
a1799 1
        QueueKeyboardEvents(ki->dixdev, type, key_code, NULL);
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d536 1
a536 1
KdBell(int volume, DeviceIntPtr pDev, pointer arg, int something)
d1943 1
a1943 1
KdBlockHandler(ScreenPtr pScreen, pointer timeout, pointer readmask)
d1965 1
a1965 1
        AdjustWaitForDelay(timeout, myTimeout);
d1969 1
a1969 1
KdWakeupHandler(ScreenPtr pScreen, unsigned long lresult, pointer readmask)
@


1.12
log
@Update to xserver 1.14.3
@
text
@d311 2
d316 2
d323 2
a326 5
    /* reset screen saver */
    ev.any.time = GetTimeInMillis();
    NoticeEventTime(&ev, pi->dixdev);
    NoticeEventTime(&ev, ki->dixdev);

d1090 1
a1090 1
KdParseKeyboard(char *arg)
d1182 1
a1182 1
KdParsePointer(char *arg)
a1678 7
static void
KdQueueEvent(DeviceIntPtr pDev, InternalEvent *ev)
{
    KdAssertSigioBlocked("KdQueueEvent");
    mieqEnqueue(pDev, ev);
}

a1817 2
    KeyClassPtr keyc = NULL;
    KeybdCtrl *ctrl = NULL;
a1822 3
    keyc = ki->dixdev->key;
    ctrl = &ki->dixdev->kbdfeed->ctrl;

a1855 1
    CARD32 ms;
a1865 2
    ms = GetTimeInMillis();

d1898 2
d2033 1
a2033 1
            if (dx <= 0 && -dx < best_x) {
d2039 1
a2039 1
            if (dx >= 0 && dx < best_x) {
d2045 1
a2045 1
            if (dy <= 0 && -dy < best_y) {
d2051 1
a2051 1
            if (dy >= 0 && dy < best_y) {
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d224 1
a224 1
            for (j = i; j < kdNumInputFds; j++)
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a104 20
static void
KdBlockSigio(void)
{
    sigset_t set;

    sigemptyset(&set);
    sigaddset(&set, SIGIO);
    sigprocmask(SIG_BLOCK, &set, 0);
}

static void
KdUnblockSigio(void)
{
    sigset_t set;

    sigemptyset(&set);
    sigaddset(&set, SIGIO);
    sigprocmask(SIG_UNBLOCK, &set, 0);
}

d244 1
a244 1
    KdBlockSigio();
d323 2
a324 1
    NoticeEventTime(&ev);
d326 1
a326 1
    KdUnblockSigio();
a684 2
extern KeybdCtrl defaultKeyboardControl;

d1784 1
a1784 1
    KdBlockSigio();
d1795 1
a1795 1
    KdUnblockSigio();
d1955 1
a1955 1
KdBlockHandler(int screen, pointer blockData, pointer timeout, pointer readmask)
d1981 1
a1981 2
KdWakeupHandler(int screen,
                pointer data, unsigned long lresult, pointer readmask)
d1991 1
a1991 1
                KdBlockSigio();
d1993 1
a1993 1
                KdUnblockSigio();
d2000 1
a2000 1
                KdBlockSigio();
d2002 1
a2002 1
                KdUnblockSigio();
d2099 1
a2099 1
    KdBlockSigio();
d2102 1
a2102 1
    KdUnblockSigio();
@


1.9
log
@Bugfix Update to xserver 1.11.3
@
text
@d38 1
a38 1
#include <sys/file.h> /* needed for FNONBLOCK & FASYNC */
d45 1
a45 1
#include "XIstubs.h" /* even though we don't use stubs.  cute, no? */
d52 1
d62 4
a65 4
static KdKeyboardInfo *kdKeyboards         = NULL;
static KdPointerInfo  *kdPointers          = NULL;
static struct KdConfigDevice *kdConfigKeyboards   = NULL;
static struct KdConfigDevice *kdConfigPointers    = NULL;
d68 1
a68 1
static KdPointerDriver  *kdPointerDrivers  = NULL;
d70 7
a76 6
static Bool		kdInputEnabled;
static Bool		kdOffScreen;
static unsigned long	kdOffScreenTime;
static KdPointerMatrix	kdPointerMatrix = {
   { { 1, 0, 0 },
     { 0, 1, 0 } }
d79 1
a79 1
void KdResetInputMachine (void);
d84 5
a88 5
    int	        fd;
    void        (*read) (int fd, void *closure);
    int	        (*enable) (int fd, void *closure);
    void        (*disable) (int fd, void *closure);
    void        *closure;
d92 1
a92 1
static int	 kdNumInputFds;
d94 1
a94 1
extern Bool      kdRawPointerCoordinates;
d97 1
a97 1
KdSigio (int sig)
d99 1
a99 1
    int	i;
d102 1
a102 1
	(*kdInputFds[i].read) (kdInputFds[i].fd, kdInputFds[i].closure);
d106 1
a106 1
KdBlockSigio (void)
d108 1
a108 1
    sigset_t	set;
d110 3
a112 3
    sigemptyset (&set);
    sigaddset (&set, SIGIO);
    sigprocmask (SIG_BLOCK, &set, 0);
d116 1
a116 1
KdUnblockSigio (void)
d118 1
a118 1
    sigset_t	set;
d120 3
a122 3
    sigemptyset (&set);
    sigaddset (&set, SIGIO);
    sigprocmask (SIG_UNBLOCK, &set, 0);
d128 1
a128 1
KdAssertSigioBlocked (char *where)
d130 1
a130 1
    sigset_t	set, old;
d132 4
a135 4
    sigemptyset (&set);
    sigprocmask (SIG_BLOCK, &set, &old);
    if (!sigismember (&old, SIGIO)) {
	ErrorF ("SIGIO not blocked at %s\n", where);
d146 1
a146 1
static int  kdnFds;
d155 1
a155 1
KdResetInputMachine (void)
d166 1
a166 1
KdNonBlockFd (int fd)
d168 5
a172 4
    int	flags;
    flags = fcntl (fd, F_GETFL);
    flags |= FASYNC|NOBLOCK;
    fcntl (fd, F_SETFL, flags);
d176 1
a176 1
KdAddFd (int fd)
d178 2
a179 2
    struct sigaction	act;
    sigset_t		set;
d182 4
a185 4
    fcntl (fd, F_SETOWN, getpid());
    KdNonBlockFd (fd);
    AddEnabledDevice (fd);
    memset (&act, '\0', sizeof act);
d187 7
a193 7
    sigemptyset (&act.sa_mask);
    sigaddset (&act.sa_mask, SIGIO);
    sigaddset (&act.sa_mask, SIGALRM);
    sigaddset (&act.sa_mask, SIGVTALRM);
    sigaction (SIGIO, &act, 0);
    sigemptyset (&set);
    sigprocmask (SIG_SETMASK, &set, 0);
d197 1
a197 1
KdRemoveFd (int fd)
d199 2
a200 2
    struct sigaction	act;
    int			flags;
d203 9
a211 10
    RemoveEnabledDevice (fd);
    flags = fcntl (fd, F_GETFL);
    flags &= ~(FASYNC|NOBLOCK);
    fcntl (fd, F_SETFL, flags);
    if (kdnFds == 0)
    {
	memset (&act, '\0', sizeof act);
	act.sa_handler = SIG_IGN;
	sigemptyset (&act.sa_mask);
	sigaction (SIGIO, &act, 0);
d216 1
a216 1
KdRegisterFd (int fd, void (*read) (int fd, void *closure), void *closure)
d219 1
a219 1
	return FALSE;
d227 1
a227 1
	KdAddFd (fd);
d232 1
a232 1
KdUnregisterFd (void *closure, int fd, Bool do_close)
d234 1
a234 1
    int	i, j;
d237 1
a237 1
	if (kdInputFds[i].closure == closure &&
d239 7
a245 7
	    if (kdInputEnabled)
		KdRemoveFd (kdInputFds[i].fd);
	    if (do_close)
		close (kdInputFds[i].fd);
	    kdNumInputFds--;
	    for (j = i; j < kdNumInputFds; j++)
		kdInputFds[j] = kdInputFds[j+1];
d247 1
a247 1
	}
d252 1
a252 1
KdUnregisterFds (void *closure, Bool do_close)
d258 1
a258 1
KdDisableInput (void)
d287 1
a287 1
                             ki->driver->name : "(unnamed!)");
d303 1
a303 1
                             pi->driver->name : "(unnamed!)");
d323 1
a323 1
KdEnableInput (void)
d342 2
a343 2
    ev.any.time = GetTimeInMillis ();
    NoticeEventTime (&ev);
d345 1
a345 1
    KdUnblockSigio ();
d349 1
a349 1
KdFindKeyboardDriver (char *name)
d366 1
a366 1
KdFindPointerDriver (char *name)
d385 5
a389 5
    DevicePtr       pDev = (DevicePtr)pDevice;
    KdPointerInfo   *pi;
    Atom            xiclass;
    Atom            *btn_labels;
    Atom            *axes_labels;
d392 1
a392 1
	return BadImplementation;
d405 1
a405 2
    switch (onoff)
    {
d436 37
a472 38
	btn_labels = calloc(pi->nButtons, sizeof(Atom));
	if (!btn_labels)
	    return BadAlloc;
	axes_labels = calloc(pi->nAxes, sizeof(Atom));
	if (!axes_labels) {
	    free(btn_labels);
	    return BadAlloc;
	}

	switch(pi->nAxes)
	{
	    default:
	    case 7:
		btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
	    case 6:
		btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
	    case 5:
		btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
	    case 4:
		btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
	    case 3:
		btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
	    case 2:
		btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
	    case 1:
		btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
	    case 0:
		break;
	}

	if (pi->nAxes >= 2) {
	    axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
	    axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
	}

	InitPointerDeviceStruct(pDev, pi->map, pi->nButtons, btn_labels,
	    (PtrCtrlProcPtr)NoopDDA,
	    GetMotionHistorySize(), pi->nAxes, axes_labels);
d487 1
a487 1
	return Success;
d506 1
a506 1
	return Success;
d525 1
a525 1
	if (pDev->on) {
d554 1
a554 1
KdBell (int volume, DeviceIntPtr pDev, pointer arg, int something)
d576 1
a576 1
        (*kdOsFuncs->Bell)(volume, pitch, duration);
d587 1
a587 1
KdRingBell(KdKeyboardInfo *ki, int volume, int pitch, int duration)
a595 1

d597 1
a597 1
KdSetLeds (KdKeyboardInfo *ki, int leds)
d609 1
a609 1
KdSetLed (KdKeyboardInfo *ki, int led, Bool on)
d614 2
a615 2
    NoteLedState (ki->dixdev, led, on);
    KdSetLeds (ki, ki->dixdev->kbdfeed->ctrl.leds);
d619 1
a619 1
KdSetPointerMatrix (KdPointerMatrix *matrix)
d625 2
a626 2
KdComputePointerMatrix (KdPointerMatrix *m, Rotation randr, int width,
                        int height)
d628 3
a630 3
    int		    x_dir = 1, y_dir = 1;
    int		    i, j;
    int		    size[2];
d632 2
a633 1
    size[0] = width; size[1] = height;
d635 1
a635 1
	x_dir = -1;
d637 1
a637 1
	y_dir = -1;
d640 5
a644 3
	m->matrix[0][0] = x_dir; m->matrix[0][1] = 0;
	m->matrix[1][0] = 0; m->matrix[1][1] = y_dir;
	break;
d646 5
a650 3
	m->matrix[0][0] = 0; m->matrix[0][1] = -x_dir;
	m->matrix[1][0] = y_dir; m->matrix[1][1] = 0;
	break;
d652 5
a656 3
	m->matrix[0][0] = -x_dir; m->matrix[0][1] = 0;
	m->matrix[1][0] = 0; m->matrix[1][1] = -y_dir;
	break;
d658 5
a662 3
	m->matrix[0][0] = 0; m->matrix[0][1] = x_dir;
	m->matrix[1][0] = -y_dir; m->matrix[1][1] = 0;
	break;
d664 5
a668 6
    for (i = 0; i < 2; i++)
    {
	m->matrix[i][2] = 0;
	for (j = 0 ; j < 2; j++)
	    if (m->matrix[i][j] < 0)
		m->matrix[i][2] = size[j] - 1;
d673 1
a673 1
KdScreenToPointerCoords (int *x, int *y)
d675 1
a675 1
    int	(*m)[3] = kdPointerMatrix.matrix;
d680 4
a683 2
    *x = (m[0][1] * sy - m[0][1] * m[1][2] + m[1][1] * m[0][2] - m[1][1] * sx) / div;
    *y = (m[1][0] * sx + m[0][0] * m[1][2] - m[1][0] * m[0][2] - m[0][0] * sy) / div;
d687 1
a687 1
KdKbdCtrl (DeviceIntPtr pDevice, KeybdCtrl *ctrl)
d709 2
a710 2
    Bool        ret;
    DevicePtr   pDev = (DevicePtr)pDevice;
d716 1
a716 1
	return BadImplementation;
d727 1
a727 2
    switch (onoff)
    {
d764 2
a765 2
        ret = InitKeyboardDeviceStruct (pDevice, &rmlvo, KdBell, KdKbdCtrl);
	if (!ret) {
d767 1
a767 1
	    return BadImplementation;
d807 1
a807 1
	if (pDev->on) {
d813 1
a813 1
	}
d830 1
a830 1
KdAddPointerDriver (KdPointerDriver *driver)
d845 1
a845 1
KdRemovePointerDriver (KdPointerDriver *driver)
d862 1
a862 1
KdAddKeyboardDriver (KdKeyboardDriver *driver)
d877 1
a877 1
KdRemoveKeyboardDriver (KdKeyboardDriver *driver)
d894 1
a894 1
KdNewKeyboard (void)
d897 1
d918 1
a918 1
KdAddConfigKeyboard (char *keyboard)
d939 1
a939 1
KdAddKeyboard (KdKeyboardInfo *ki)
d964 1
a964 1
KdRemoveKeyboard (KdKeyboardInfo *ki)
d982 1
a982 1
KdAddConfigPointer (char *pointer)
d1003 1
a1003 1
KdAddPointer (KdPointerInfo *pi)
d1027 1
a1027 1
KdRemovePointer (KdPointerInfo *pi)
d1050 1
a1050 1
KdGetOptions (InputOption **options, char *string)
d1052 3
a1054 6
    InputOption     *newopt = NULL, **tmpo = NULL;
    int             tam_key = 0;

    newopt = calloc(1, sizeof (InputOption));
    if (!newopt)
        return FALSE;
d1056 1
a1056 6
    for (tmpo = options; *tmpo; tmpo = &(*tmpo)->next)
        ; /* Hello, I'm here */
    *tmpo = newopt;

    if (strchr(string, '='))
    {
d1058 7
a1064 4
        newopt->key = (char *)malloc(tam_key);
        strncpy(newopt->key, string, tam_key);
        newopt->key[tam_key] = '\0';
        newopt->value = strdup(strchr(string, '=') + 1);
d1066 3
a1068 4
    else
    {
        newopt->key = strdup(string);
        newopt->value = NULL;
a1069 1
    newopt->next = NULL;
d1071 9
a1079 1
    return TRUE;
d1083 1
a1083 1
KdParseKbdOptions (KdKeyboardInfo *ki)
d1087 16
a1102 14
    for (option = ki->options; option; option = option->next)
    {
        if (strcasecmp(option->key, "XkbRules") == 0)
            ki->xkbRules = option->value;
        else if (strcasecmp(option->key, "XkbModel") == 0)
            ki->xkbModel = option->value;
        else if (strcasecmp(option->key, "XkbLayout") == 0)
            ki->xkbLayout = option->value;
        else if (strcasecmp(option->key, "XkbVariant") == 0)
            ki->xkbVariant = option->value;
        else if (strcasecmp(option->key, "XkbOptions") == 0)
            ki->xkbOptions = option->value;
        else if (!strcasecmp (option->key, "device"))
            ki->path = strdup(option->value);
d1104 2
a1105 2
           ErrorF("Kbd option key (%s) of value (%s) not assigned!\n",
                    option->key, option->value);
d1110 1
a1110 1
KdParseKeyboard (char *arg)
d1112 4
a1115 4
    char            save[1024];
    char            delim;
    InputOption     *options = NULL;
    KdKeyboardInfo     *ki = NULL;
d1127 1
a1127 2
    if (!arg)
    {
d1129 1
a1129 1
        KdFreeKeyboard (ki);
d1133 1
a1133 2
    if (strlen (arg) >= sizeof (save))
    {
d1135 1
a1135 1
        KdFreeKeyboard (ki);
d1139 2
a1140 3
    arg = KdParseFindNext (arg, ",", save, &delim);
    if (!save[0])
    {
d1142 1
a1142 1
        KdFreeKeyboard (ki);
d1146 1
a1146 1
    if (strcmp (save, "auto") == 0)
d1151 1
a1151 2
    if (delim != ',')
    {
d1155 1
a1155 1
    arg = KdParseFindNext (arg, ",", save, &delim);
d1157 2
a1158 3
    while (delim == ',')
    {
        arg = KdParseFindNext (arg, ",", save, &delim);
d1160 3
a1162 4
	if (!KdGetOptions(&options, save))
	{
	    KdFreeKeyboard(ki);
	    return NULL;
d1166 1
a1166 2
    if (options)
    {
d1175 1
a1175 1
KdParsePointerOptions (KdPointerInfo *pi)
d1179 5
a1183 3
    for (option = pi->options; option; option = option->next)
    {
        if (!strcmp (option->key, "emulatemiddle"))
d1185 1
a1185 1
        else if (!strcmp (option->key, "noemulatemiddle"))
d1187 1
a1187 1
        else if (!strcmp (option->key, "transformcoord"))
d1189 1
a1189 1
        else if (!strcmp (option->key, "rawcoord"))
d1191 4
a1194 4
        else if (!strcasecmp (option->key, "device"))
            pi->path = strdup(option->value);
        else if (!strcasecmp (option->key, "protocol"))
            pi->protocol = strdup(option->value);
d1197 1
a1197 1
                    option->key, option->value);
d1202 1
a1202 1
KdParsePointer (char *arg)
d1204 5
a1208 5
    char            save[1024];
    char            delim;
    KdPointerInfo   *pi = NULL;
    InputOption     *options = NULL;
    int             i = 0;
d1216 1
a1216 1
    pi->nButtons = 5; /* XXX should not be hardcoded */
d1219 1
a1219 2
    if (!arg)
    {
d1221 1
a1221 1
        KdFreePointer (pi);
d1225 1
a1225 2
    if (strlen (arg) >= sizeof (save))
    {
d1227 1
a1227 1
        KdFreePointer (pi);
d1230 2
a1231 3
    arg = KdParseFindNext (arg, ",", save, &delim);
    if (!save[0])
    {
d1233 1
a1233 1
        KdFreePointer (pi);
d1242 1
a1242 2
    if (delim != ',')
    {
d1246 1
a1246 1
    arg = KdParseFindNext (arg, ",", save, &delim);
d1248 3
a1250 5
    while (delim == ',')
    {
        arg = KdParseFindNext (arg, ",", save, &delim);
        if (save[0] == '{')
        {
d1252 3
a1254 3
             i = 0;
             while (*s && *s != '}')
             {
d1258 1
a1258 1
                    UseMsg ();
d1260 1
a1260 1
             }
d1262 2
a1263 4
        else
        {
            if (!KdGetOptions(&options, save))
            {
d1270 1
a1270 2
    if (options)
    {
a1277 1

d1279 1
a1279 1
KdInitInput (void)
d1306 1
a1306 1
KdCloseInput (void)
d1469 1
a1469 1
    KdInputAction  actions[MAX_ACTIONS];
d1474 1
a1474 1
KdInputTransition  kdInputMachine[num_input_states][num_input_class] = {
d1477 13
a1489 13
	{ { hold, setto },	    button_1_pend },	/* v1 */
	{ { deliver, noop },	    start },		/* ^1 */
	{ { deliver, noop },	    button_2_down },	/* v2 */
	{ { deliver, noop },	    start },		/* ^2 */
	{ { hold, setto },	    button_3_pend },	/* v3 */
	{ { deliver, noop },	    start },		/* ^3 */
	{ { deliver, noop },	    start },		/* vo */
	{ { deliver, noop },	    start },		/* ^o */
	{ { deliver, noop },	    start },		/* <> */
	{ { deliver, noop },	    start },		/* <-> */
	{ { noop, noop },	    start },		/* k */
	{ { noop, noop },	    start },		/* ... */
    },
d1492 13
a1504 13
	{ { noop, noop },	    button_1_pend },	/* v1 */
	{ { release, deliver },	    start },		/* ^1 */
	{ { release, deliver },	    button_1_down },	/* v2 */
	{ { release, deliver },	    button_1_down },	/* ^2 */
	{ { clearto, gen_down_2 },  synth_2_down_13 },	/* v3 */
	{ { release, deliver },	    button_1_down },	/* ^3 */
	{ { release, deliver },	    button_1_down },	/* vo */
	{ { release, deliver },	    button_1_down },	/* ^o */
	{ { deliver, noop },	    button_1_pend },	/* <> */
	{ { release, deliver },	    button_1_down },	/* <-> */
	{ { noop, noop },	    button_1_down },	/* k */
	{ { release, noop },	    button_1_down },	/* ... */
    },
d1507 13
a1519 13
	{ { noop, noop },	    button_1_down },	/* v1 */
	{ { deliver, noop },	    start },		/* ^1 */
	{ { deliver, noop },	    button_1_down },	/* v2 */
	{ { deliver, noop },	    button_1_down },	/* ^2 */
	{ { deliver, noop },	    button_1_down },	/* v3 */
	{ { deliver, noop },	    button_1_down },	/* ^3 */
	{ { deliver, noop },	    button_1_down },	/* vo */
	{ { deliver, noop },	    button_1_down },	/* ^o */
	{ { deliver, noop },	    button_1_down },	/* <> */
	{ { deliver, noop },	    button_1_down },	/* <-> */
	{ { noop, noop },	    button_1_down },	/* k */
	{ { noop, noop },	    button_1_down },	/* ... */
    },
d1522 13
a1534 13
	{ { deliver, noop },	    button_2_down },	/* v1 */
	{ { deliver, noop },	    button_2_down },	/* ^1 */
	{ { noop, noop },	    button_2_down },	/* v2 */
	{ { deliver, noop },	    start },		/* ^2 */
	{ { deliver, noop },	    button_2_down },	/* v3 */
	{ { deliver, noop },	    button_2_down },	/* ^3 */
	{ { deliver, noop },	    button_2_down },	/* vo */
	{ { deliver, noop },	    button_2_down },	/* ^o */
	{ { deliver, noop },	    button_2_down },	/* <> */
	{ { deliver, noop },	    button_2_down },	/* <-> */
	{ { noop, noop },	    button_2_down },	/* k */
	{ { noop, noop },	    button_2_down },	/* ... */
    },
d1537 13
a1549 13
	{ { clearto, gen_down_2 },  synth_2_down_13 },	/* v1 */
	{ { release, deliver },	    button_3_down },	/* ^1 */
	{ { release, deliver },	    button_3_down },	/* v2 */
	{ { release, deliver },	    button_3_down },	/* ^2 */
	{ { release, deliver },	    button_3_down },	/* v3 */
	{ { release, deliver },	    start },		/* ^3 */
	{ { release, deliver },	    button_3_down },	/* vo */
	{ { release, deliver },	    button_3_down },	/* ^o */
	{ { deliver, noop },	    button_3_pend },	/* <> */
	{ { release, deliver },	    button_3_down },	/* <-> */
	{ { release, noop },	    button_3_down },	/* k */
	{ { release, noop },	    button_3_down },	/* ... */
    },
d1552 13
a1564 13
	{ { deliver, noop },	    button_3_down },	/* v1 */
	{ { deliver, noop },	    button_3_down },	/* ^1 */
	{ { deliver, noop },	    button_3_down },	/* v2 */
	{ { deliver, noop },	    button_3_down },	/* ^2 */
	{ { noop, noop },	    button_3_down },	/* v3 */
	{ { deliver, noop },	    start },		/* ^3 */
	{ { deliver, noop },	    button_3_down },	/* vo */
	{ { deliver, noop },	    button_3_down },	/* ^o */
	{ { deliver, noop },	    button_3_down },	/* <> */
	{ { deliver, noop },	    button_3_down },	/* <-> */
	{ { noop, noop },	    button_3_down },	/* k */
	{ { noop, noop },	    button_3_down },	/* ... */
    },
d1567 13
a1579 13
	{ { noop, noop },	    synth_2_down_13 },	/* v1 */
	{ { gen_up_2, noop },	    synth_2_down_3 },	/* ^1 */
	{ { noop, noop },	    synth_2_down_13 },	/* v2 */
	{ { noop, noop },	    synth_2_down_13 },	/* ^2 */
	{ { noop, noop },	    synth_2_down_13 },	/* v3 */
	{ { gen_up_2, noop },	    synth_2_down_1 },	/* ^3 */
	{ { deliver, noop },	    synth_2_down_13 },	/* vo */
	{ { deliver, noop },	    synth_2_down_13 },	/* ^o */
	{ { deliver, noop },	    synth_2_down_13 },	/* <> */
	{ { deliver, noop },	    synth_2_down_13 },	/* <-> */
	{ { noop, noop },	    synth_2_down_13 },	/* k */
	{ { noop, noop },	    synth_2_down_13 },	/* ... */
    },
d1582 13
a1594 13
	{ { deliver, noop },	    synth_2_down_3 },	/* v1 */
	{ { deliver, noop },	    synth_2_down_3 },	/* ^1 */
	{ { deliver, noop },	    synth_2_down_3 },	/* v2 */
	{ { deliver, noop },	    synth_2_down_3 },	/* ^2 */
	{ { noop, noop },	    synth_2_down_3 },	/* v3 */
	{ { noop, noop },	    start },		/* ^3 */
	{ { deliver, noop },	    synth_2_down_3 },	/* vo */
	{ { deliver, noop },	    synth_2_down_3 },	/* ^o */
	{ { deliver, noop },	    synth_2_down_3 },	/* <> */
	{ { deliver, noop },	    synth_2_down_3 },	/* <-> */
	{ { noop, noop },	    synth_2_down_3 },	/* k */
	{ { noop, noop },	    synth_2_down_3 },	/* ... */
    },
d1597 13
a1609 13
	{ { noop, noop },	    synth_2_down_1 },	/* v1 */
	{ { noop, noop },	    start },		/* ^1 */
	{ { deliver, noop },	    synth_2_down_1 },	/* v2 */
	{ { deliver, noop },	    synth_2_down_1 },	/* ^2 */
	{ { deliver, noop },	    synth_2_down_1 },	/* v3 */
	{ { deliver, noop },	    synth_2_down_1 },	/* ^3 */
	{ { deliver, noop },	    synth_2_down_1 },	/* vo */
	{ { deliver, noop },	    synth_2_down_1 },	/* ^o */
	{ { deliver, noop },	    synth_2_down_1 },	/* <> */
	{ { deliver, noop },	    synth_2_down_1 },	/* <-> */
	{ { noop, noop },	    synth_2_down_1 },	/* k */
	{ { noop, noop },	    synth_2_down_1 },	/* ... */
    },
d1616 1
a1616 1
KdInsideEmulationWindow (KdPointerInfo *pi, int x, int y, int z)
d1621 2
a1622 2
    return (abs (pi->emulationDx) < EMULATION_WINDOW &&
	    abs (pi->emulationDy) < EMULATION_WINDOW);
d1626 1
a1626 1
KdClassifyInput (KdPointerInfo *pi, int type, int x, int y, int z, int b)
d1630 11
a1640 7
	switch (b) {
	case 1: return down_1;
	case 2: return down_2;
	case 3: return down_3;
	default: return down_o;
	}
	break;
d1642 11
a1652 7
	switch (b) {
	case 1: return up_1;
	case 2: return up_2;
	case 3: return up_3;
	default: return up_o;
	}
	break;
d1654 4
a1657 4
	if (pi->eventHeld && !KdInsideEmulationWindow(pi, x, y, z))
	    return outside_box;
	else
	    return motion;
d1659 1
a1659 1
	return keyboard;
d1665 1
a1665 1
char	*kdStateNames[] = {
d1678 1
a1678 1
char	*kdClassNames[] = {
d1697 1
a1697 1
#endif /* DEBUG */
d1700 1
a1700 1
KdQueueEvent (DeviceIntPtr pDev, InternalEvent *ev)
d1702 2
a1703 2
    KdAssertSigioBlocked ("KdQueueEvent");
    mieqEnqueue (pDev, ev);
d1708 2
a1709 2
KdRunMouseMachine (KdPointerInfo *pi, KdInputClass c, int type, int x, int y,
                   int z, int b, int absrel)
d1712 1
a1712 1
    int	a;
d1716 9
a1724 10
    for (a = 0; a < MAX_ACTIONS; a++)
    {
	switch (t->actions[a]) {
	case noop:
	    break;
	case hold:
	    pi->eventHeld = TRUE;
	    pi->emulationDx = 0;
	    pi->emulationDy = 0;
	    pi->heldEvent.type = type;
d1731 18
a1748 18
	    break;
	case setto:
	    pi->emulationTimeout = GetTimeInMillis () + EMULATION_TIMEOUT;
	    pi->timeoutPending = TRUE;
	    break;
	case deliver:
            _KdEnqueuePointerEvent (pi, pi->heldEvent.type, pi->heldEvent.x,
                                    pi->heldEvent.y, pi->heldEvent.z,
                                    pi->heldEvent.flags, pi->heldEvent.absrel,
                                    TRUE);
	    break;
	case release:
	    pi->eventHeld = FALSE;
	    pi->timeoutPending = FALSE;
            _KdEnqueuePointerEvent (pi, pi->heldEvent.type, pi->heldEvent.x,
                                    pi->heldEvent.y, pi->heldEvent.z,
                                    pi->heldEvent.flags, pi->heldEvent.absrel,
                                    TRUE);
d1750 7
a1756 8
	    break;
	case clearto:
	    pi->timeoutPending = FALSE;
	    break;
	case gen_down_2:
            _KdEnqueuePointerEvent (pi, ButtonPress, x, y, z, 2, absrel,
                                    TRUE);
	    pi->eventHeld = FALSE;
d1758 3
a1760 4
	    break;
	case gen_up_2:
            _KdEnqueuePointerEvent (pi, ButtonRelease, x, y, z, 2, absrel,
                                    TRUE);
d1762 2
a1763 2
	    break;
	}
d1770 2
a1771 2
KdHandlePointerEvent (KdPointerInfo *pi, int type, int x, int y, int z, int b,
                      int absrel)
d1774 2
a1775 2
        return KdRunMouseMachine (pi, KdClassifyInput(pi, type, x, y, z, b),
                                  type, x, y, z, b, absrel);
d1780 1
a1780 1
KdReceiveTimeout (KdPointerInfo *pi)
d1782 1
a1782 1
    KdRunMouseMachine (pi, timeout, 0, 0, 0, 0, 0, 0);
d1799 1
a1799 1
KdReleaseAllKeys (void)
d1802 1
a1802 1
    int	key;
d1805 1
a1805 1
    KdBlockSigio ();
d1808 1
a1808 2
        for (key = ki->keySyms.minKeyCode; key < ki->keySyms.maxKeyCode;
             key++) {
d1816 1
a1816 1
    KdUnblockSigio ();
d1821 1
a1821 1
KdCheckLock (void)
d1823 3
a1825 3
    KeyClassPtr	    keyc = NULL;
    Bool	    isSet = FALSE, shouldBeSet = FALSE;
    KdKeyboardInfo     *tmp = NULL;
d1830 1
a1830 1
            isSet = (tmp->leds & (1 << (tmp->LockLed-1))) != 0;
d1832 2
a1833 1
            shouldBeSet = !!(XkbStateFieldFromRec(&keyc->xkbInfo->state) & LockMask);
d1835 1
a1835 1
                KdSetLed (tmp, tmp->LockLed, shouldBeSet);
d1841 2
a1842 3
KdEnqueueKeyboardEvent(KdKeyboardInfo   *ki,
                       unsigned char scan_code,
		       unsigned char is_up)
d1845 1
a1845 1
    KeyClassPtr	keyc = NULL;
d1850 1
a1850 1
	return;
d1855 2
a1856 3
    if (scan_code >= ki->minScanCode && scan_code <= ki->maxScanCode)
    {
	key_code = scan_code + KD_MIN_KEYCODE - ki->minScanCode;
d1858 7
a1864 7
	/*
	 * Set up this event -- the type may be modified below
	 */
	if (is_up)
	    type = KeyRelease;
	else
	    type = KeyPress;
d1885 1
a1885 1
KdEnqueuePointerEvent(KdPointerInfo *pi, unsigned long flags, int rx, int ry,
d1888 1
a1888 1
    CARD32        ms;
d1890 2
a1891 2
    int           x, y, z;
    int           (*matrix)[3] = kdPointerMatrix.matrix;
d1893 2
a1894 2
    int           n;
    int           dixflags = 0;
d1897 1
a1897 1
	return;
d1903 8
a1910 8
	if (pi->transformCoordinates) {
	    x = matrix[0][0] * rx + matrix[0][1] * ry;
	    y = matrix[1][0] * rx + matrix[1][1] * ry;
	}
	else {
	    x = rx;
	    y = ry;
	}
d1913 8
a1920 8
	if (pi->transformCoordinates) {
	    x = matrix[0][0] * rx + matrix[0][1] * ry + matrix[0][2];
	    y = matrix[1][0] * rx + matrix[1][1] * ry + matrix[1][2];
	}
	else {
	    x = rx;
	    y = ry;
	}
d1924 2
a1925 4
    if (flags & KD_MOUSE_DELTA)
    {
        if (x || y || z)
        {
d1927 2
a1928 1
            _KdEnqueuePointerEvent(pi, MotionNotify, x, y, z, 0, dixflags, FALSE);
d1930 2
a1931 2
    } else
    {
d1935 2
a1936 1
            _KdEnqueuePointerEvent(pi, MotionNotify, x, y, z, 0, dixflags, FALSE);
d1941 1
a1941 2
    for (button = KD_BUTTON_1, n = 1; n <= pi->nButtons;
         button <<= 1, n++) {
d1943 1
a1943 1
           !(buttons & button)) {
d1946 1
a1946 1
	}
d1948 3
a1950 4
    for (button = KD_BUTTON_1, n = 1; n <= pi->nButtons;
         button <<= 1, n++) {
	if (((pi->buttonState & button) ^ (buttons & button)) &&
	    (buttons & button)) {
d1960 2
a1961 2
_KdEnqueuePointerEvent (KdPointerInfo *pi, int type, int x, int y, int z,
                        int b, int absrel, Bool force)
d1976 1
a1976 4
KdBlockHandler (int		screen,
		pointer		blockData,
		pointer		timeout,
		pointer		readmask)
d1978 2
a1979 2
    KdPointerInfo		    *pi;
    int myTimeout=0;
d1981 10
a1990 12
    for (pi = kdPointers; pi; pi = pi->next)
    {
	if (pi->timeoutPending)
	{
	    int	ms;

	    ms = pi->emulationTimeout - GetTimeInMillis ();
	    if (ms < 1)
		ms = 1;
	    if(ms<myTimeout || myTimeout==0)
		    myTimeout=ms;
	}
d1993 3
a1995 4
    if(kdOsFuncs->pollEvents)
    {
	    (*kdOsFuncs->pollEvents)();
	    myTimeout=20;
d1997 2
a1998 2
    if(myTimeout>0)
    	AdjustWaitForDelay (timeout, myTimeout);
d2002 2
a2003 4
KdWakeupHandler (int		screen,
		 pointer    	data,
		 unsigned long	lresult,
		 pointer	readmask)
d2005 4
a2008 4
    int		result = (int) lresult;
    fd_set	*pReadmask = (fd_set *) readmask;
    int		i;
    KdPointerInfo	*pi;
d2010 7
a2016 9
    if (kdInputEnabled && result > 0)
    {
	for (i = 0; i < kdNumInputFds; i++)
	    if (FD_ISSET (kdInputFds[i].fd, pReadmask))
	    {
		KdBlockSigio ();
		(*kdInputFds[i].read) (kdInputFds[i].fd, kdInputFds[i].closure);
		KdUnblockSigio ();
	    }
d2018 9
a2026 12
    for (pi = kdPointers; pi; pi = pi->next)
    {
	if (pi->timeoutPending)
	{
	    if ((long) (GetTimeInMillis () - pi->emulationTimeout) >= 0)
	    {
		pi->timeoutPending = FALSE;
		KdBlockSigio ();
		KdReceiveTimeout (pi);
		KdUnblockSigio ();
	    }
	}
d2029 1
a2029 1
	KdProcessSwitch ();
d2037 7
a2043 7
    ScreenPtr	pScreen  = *ppScreen;
    ScreenPtr	pNewScreen;
    int		n;
    int		dx, dy;
    int		best_x, best_y;
    int		n_best_x, n_best_y;
    CARD32	ms;
d2046 1
a2046 1
	return FALSE;
d2049 1
a2049 1
	return FALSE;
d2051 1
a2051 1
    ms = GetTimeInMillis ();
d2053 1
a2053 1
	return FALSE;
d2060 30
a2089 39
    for (n = 0; n < screenInfo.numScreens; n++)
    {
	pNewScreen = screenInfo.screens[n];
	if (pNewScreen == pScreen)
	    continue;
	dx = KdScreenOrigin(pNewScreen)->x - KdScreenOrigin(pScreen)->x;
	dy = KdScreenOrigin(pNewScreen)->y - KdScreenOrigin(pScreen)->y;
	if (*x < 0)
	{
	    if (dx <= 0 && -dx < best_x)
	    {
		best_x = -dx;
		n_best_x = n;
	    }
	}
	else if (*x >= pScreen->width)
	{
	    if (dx >= 0 && dx < best_x)
	    {
		best_x = dx;
		n_best_x = n;
	    }
	}
	if (*y < 0)
	{
	    if (dy <= 0 && -dy < best_y)
	    {
		best_y = -dy;
		n_best_y = n;
	    }
	}
	else if (*y >= pScreen->height)
	{
	    if (dy >= 0 && dy < best_y)
	    {
		best_y = dy;
		n_best_y = n;
	    }
	}
d2092 1
a2092 1
	n_best_x = n_best_y;
d2094 1
a2094 1
	return FALSE;
d2098 1
a2098 1
	*x += pNewScreen->width;
d2100 1
a2100 1
	*y += pNewScreen->height;
d2103 1
a2103 1
	*x -= pScreen->width;
d2105 1
a2105 1
	*y -= pScreen->height;
d2116 1
a2116 1
int KdCurScreen;	/* current event screen */
d2119 1
a2119 1
KdWarpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d2121 1
a2121 1
    KdBlockSigio ();
d2124 1
a2124 1
    KdUnblockSigio ();
d2127 1
a2127 2
miPointerScreenFuncRec kdPointerScreenFuncs =
{
d2134 1
a2134 1
ProcessInputEvents (void)
d2138 2
a2139 2
	KdProcessSwitch ();
    KdCheckLock ();
d2158 1
a2158 1
                        xDeviceCtl *control)
d2181 1
a2181 1
NewInputDeviceRequest(InputOption *options, InputAttributes *attrs,
d2188 6
a2193 3
    for (option = options; option; option = option->next) {
        if (strcmp(option->key, "type") == 0) {
            if (strcmp(option->value, "pointer") == 0) {
d2198 1
a2198 1
            else if (strcmp(option->value, "keyboard") == 0) {
d2209 2
a2210 3
        else if (strcmp(option->key, "_source") == 0 &&
                 strcmp(option->value, "server/hal") == 0)
        {
d2216 2
a2217 3
        else if (strcmp(option->key, "_source") == 0 &&
                 strcmp(option->value, "server/udev") == 0)
        {
d2231 9
a2239 6
    for (option = options; option; option = option->next) {
        if (strcmp(option->key, "device") == 0) {
            if (pi && option->value)
                pi->path = strdup(option->value);
            else if (ki && option->value)
                ki->path = strdup(option->value);
d2241 1
a2241 1
        else if (strcmp(option->key, "driver") == 0) {
d2243 1
a2243 1
                pi->driver = KdFindPointerDriver(option->value);
d2252 1
a2252 1
                ki->driver = KdFindKeyboardDriver(option->value);
d2282 2
a2283 1
    } else if(ki) {
@


1.8
log
@Update to xserver 1.11.2
@
text
@a2137 6
#ifndef XIPAQ
    if (entering)
	KdEnableScreen (pScreen);
    else
	KdDisableScreen (pScreen);
#endif
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 2
a3 2
 * Copyright  1999 Keith Packard
 * Copyright  2006 Nokia Corporation
d51 1
a68 2
static EventListPtr     kdEvents = NULL;

a477 1
            InitAbsoluteClassDeviceStruct(pDevice);
a943 4
    ki->dixdev->deviceGrab.ActivateGrab = ActivateKeyboardGrab;
    ki->dixdev->deviceGrab.DeactivateGrab = DeactivateKeyboardGrab;
    RegisterOtherDevice(ki->dixdev);

a1010 4
    pi->dixdev->deviceGrab.ActivateGrab = ActivatePointerGrab;
    pi->dixdev->deviceGrab.DeactivateGrab = DeactivatePointerGrab;
    RegisterOtherDevice(pi->dixdev);

d1308 6
d1800 1
a1800 1
    int	key, nEvents, i;
d1810 1
a1810 4
                GetEventList(&kdEvents);
                nEvents = GetKeyboardEvents(kdEvents, ki->dixdev, KeyRelease, key);
                for (i = 0; i < nEvents; i++)
                    KdQueueEvent (ki->dixdev, (kdEvents + i)->event);
d1846 1
a1846 1
    int type, nEvents, i;
d1866 1
a1866 5
        GetEventList(&kdEvents);

        nEvents = GetKeyboardEvents(kdEvents, ki->dixdev, type, key_code);
        for (i = 0; i < nEvents; i++)
            KdQueueEvent(ki->dixdev, (InternalEvent *)((kdEvents + i)->event));
a1964 1
    int nEvents = 0, i = 0;
d1966 1
d1972 3
a1974 5
    GetEventList(&kdEvents);
    nEvents = GetPointerEvents(kdEvents, pi->dixdev, type, b, absrel,
                               0, 3, valuators);
    for (i = 0; i < nEvents; i++)
        KdQueueEvent(pi->dixdev, (InternalEvent *)((kdEvents + i)->event));
a2167 1
    miPointerUpdateSprite(inputInfo.pointer);
a2172 24
/* FIXME use XSECURITY to work out whether the client should be allowed to
 * open and close. */
void
OpenInputDevice(DeviceIntPtr pDev, ClientPtr client, int *status)
{
    if (!pDev)
        *status = BadDevice;
    else
        *status = Success;
}

void
CloseInputDevice(DeviceIntPtr pDev, ClientPtr client)
{
    return;
}

/* We initialise all input devices at startup. */
void
AddOtherInputDevices(void)
{
    return;
}

a2197 2
        return Success;

@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d423 1
a423 1
            xfree(pi->driverPrivate);
d436 1
a436 1
	btn_labels = xcalloc(pi->nButtons, sizeof(Atom));
d439 1
a439 1
	axes_labels = xcalloc(pi->nAxes, sizeof(Atom));
d441 1
a441 1
	    xfree(btn_labels);
d475 2
a476 2
        xfree(btn_labels);
        xfree(axes_labels);
d739 1
a739 1
            xfree(ki->driverPrivate);
d890 1
a890 1
    KdKeyboardInfo *ki = xcalloc(sizeof(KdKeyboardInfo), 1);
d918 1
a918 1
    new = (struct KdConfigDevice *) xcalloc(sizeof(struct KdConfigDevice), 1);
d922 1
a922 1
    new->line = xstrdup(keyboard);
d986 1
a986 1
    new = (struct KdConfigDevice *) xcalloc(sizeof(struct KdConfigDevice), 1);
d990 1
a990 1
    new->line = xstrdup(pointer);
d1056 1
a1056 1
    newopt = xcalloc(1, sizeof (InputOption));
d1067 1
a1067 1
        newopt->key = (char *)xalloc(tam_key);
d1070 1
a1070 1
        newopt->value = xstrdup(strchr(string, '=') + 1);
d1074 1
a1074 1
        newopt->key = xstrdup(string);
d1150 1
a1150 1
        ki->driverPrivate = xstrdup(save);
d1246 1
a1246 1
        pi->driverPrivate = xstrdup(save);
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d41 1
a41 3
#ifdef XKB
#include <xkbsrv.h>
#endif
d49 2
a78 6
    
#define IsKeyDown(ki, key) ((ki->keyState[(key) >> 3] >> ((key) & 7)) & 1)
#define KEYMAP(ki)        (ki->dixdev->key->curKeySyms)
#define KEYMAPDDX(ki)     (ki->keySyms)
#define KEYCOL1(ki, k)    (KEYMAP(ki).map[((k)-(KEYMAP(ki).minKeyCode))*KEYMAP(ki).mapWidth])
#define KEYCOL1DDX(ki, k) (KEYMAPDDX(ki).map[((k)-(KEYMAPDDX(ki).minKeyCode))*KEYMAPDDX(ki).mapWidth])
d108 1
a108 1
    
d118 1
a118 1
    
d178 1
a178 1
    
d199 1
a199 1
    
d324 1
a324 1
    xEvent xE;
d327 1
a327 1
    
d341 2
a342 2
    xE.u.keyButtonPointer.time = GetTimeInMillis ();
    NoticeEventTime (&xE);
d355 1
a355 1
    
d387 2
d436 36
a471 1
	InitPointerDeviceStruct(pDev, pi->map, pi->nButtons,
d473 4
a476 1
	    GetMotionHistorySize(), pi->nAxes);
d490 1
a490 1
	
d494 1
a494 1
        
d541 1
a541 1
        
d560 1
a560 1
    
d568 1
a568 1
    
d593 1
a593 1
        
d694 1
a694 1
    ki->bellDuration = ctrl->bell_duration; 
a698 79
static void
KdInitAutoRepeats (KdKeyboardInfo *ki)
{
    int		    key_code;
    unsigned char   mask;
    int		    i;
    unsigned char   *repeats;

    repeats = defaultKeyboardControl.autoRepeats;
    memset (repeats, '\0', 32);
    for (key_code = KD_MIN_KEYCODE; key_code <= KD_MAX_KEYCODE; key_code++)
    {
	if (!ki->modmap[key_code])
	{
	    i = key_code >> 3;
	    mask = 1 << (key_code & 7);
	    repeats[i] |= mask;
	}
    }
}

const KdKeySymModsRec kdKeySymMods[] = {
  {  XK_Control_L,	ControlMask },
  {  XK_Control_R, ControlMask },
  {  XK_Shift_L,	ShiftMask },
  {  XK_Shift_R,	ShiftMask },
  {  XK_Caps_Lock,	LockMask },
  {  XK_Shift_Lock, LockMask },
  {  XK_Alt_L,	Mod1Mask },
  {  XK_Alt_R,	Mod1Mask },
  {  XK_Meta_L,	Mod1Mask },
  {  XK_Meta_R,	Mod1Mask },
  {  XK_Num_Lock,	Mod2Mask },
  {  XK_Super_L,	Mod3Mask },
  {  XK_Super_R,	Mod3Mask },
  {  XK_Hyper_L,	Mod3Mask },
  {  XK_Hyper_R,	Mod3Mask },
  {  XK_Mode_switch, Mod4Mask },
  /* PDA specific hacks */
#ifdef XF86XK_Start
  {  XF86XK_Start, ControlMask },
#endif
  {  XK_Menu, ShiftMask },
  {  XK_telephone, Mod1Mask },
#ifdef XF86XK_AudioRecord
  {  XF86XK_AudioRecord, Mod2Mask },
#endif
#ifdef XF86XK_Calendar
  {  XF86XK_Calendar, Mod3Mask }
#endif
};

#define NUM_SYM_MODS (sizeof(kdKeySymMods) / sizeof(kdKeySymMods[0]))

static void
KdInitModMap (KdKeyboardInfo *ki)
{
    int	    key_code;
    int	    row;
    int	    width;
    KeySym  *syms;
    int	    i;

    width = ki->keySyms.mapWidth;
    for (key_code = ki->keySyms.minKeyCode; key_code <= ki->keySyms.maxKeyCode; key_code++)
    {
	ki->modmap[key_code] = 0;
	syms = ki->keySyms.map + (key_code - ki->keySyms.minKeyCode) * width;
	for (row = 0; row < width; row++, syms++)
	{
	    for (i = 0; i < NUM_SYM_MODS; i++) 
	    {
		if (*syms == kdKeySymMods[i].modsym) 
		    ki->modmap[key_code] |= kdKeySymMods[i].modbit;
	    }
	}
    }
}

d706 1
a706 3
#ifdef XKB
    XkbComponentNamesRec names;
#endif
d752 7
a758 22
        KdInitModMap(ki);
        KdInitAutoRepeats(ki);

#ifdef XKB
        if (!noXkbExtension) {
            memset(&names, 0, sizeof(XkbComponentNamesRec));

            XkbSetRulesDflts (ki->xkbRules, ki->xkbModel, ki->xkbLayout,
                              ki->xkbVariant, ki->xkbOptions);

            ret = XkbInitKeyboardDeviceStruct (pDevice,
                                               &names,
                                               &ki->keySyms,
                                               ki->modmap,
                                               KdBell, KdKbdCtrl);
        }
        else
#endif
	ret = InitKeyboardDeviceStruct(pDev,
				       &ki->keySyms,
				       ki->modmap,
				       KdBell, KdKbdCtrl);
d797 1
a797 1
        
a890 1

a892 8
    
    ki->keySyms.map = (KeySym *)xcalloc(sizeof(KeySym),
                                        KD_MAX_LENGTH *
                                         kdDefaultKeySyms.mapWidth);
    if (!ki->keySyms.map) {
        xfree(ki);
        return NULL;
    }
a893 5
    memcpy(ki->keySyms.map, kdDefaultKeySyms.map,
           sizeof(KeySym) * (KD_MAX_LENGTH * kdDefaultKeySyms.mapWidth));
    ki->keySyms.minKeyCode = kdDefaultKeySyms.minKeyCode;
    ki->keySyms.maxKeyCode = kdDefaultKeySyms.maxKeyCode;
    ki->keySyms.mapWidth = kdDefaultKeySyms.mapWidth;
d901 5
a905 7
#ifdef XKB
    ki->xkbRules = KdSaveString("xorg");
    ki->xkbModel = KdSaveString("pc105");
    ki->xkbLayout = KdSaveString("us");
    ki->xkbVariant = NULL;
    ki->xkbOptions = NULL;
#endif
d938 1
a938 1
    
d1045 1
a1045 1
/* 
d1048 1
a1048 1
 * evdev,,device=/dev/input/event1,xkbmodel=abnt2,xkblayout=br 
d1050 1
a1050 1
static Bool 
d1061 1
a1061 1
        ; /* Hello, I'm here */ 
a1088 1
#ifdef XKB
d1100 1
a1100 1
            ki->path = KdSaveString(option->value);
d1102 1
a1102 2
#endif
           ErrorF("Kbd option key (%s) of value (%s) not assigned!\n", 
a1122 3
#ifdef XKB
    ki->xkb = NULL;
#endif
d1163 1
a1163 1
	if (!KdGetOptions(&options, save)) 
d1167 1
a1167 1
        }    
d1195 3
a1197 1
            pi->path = KdSaveString(option->value);
d1199 1
a1199 1
            ErrorF("Pointer option key (%s) of value (%s) not assigned!\n", 
d1218 1
d1451 1
a1451 1
 
d1631 1
a1631 1
				     
d1699 1
a1699 1
KdQueueEvent (DeviceIntPtr pDev, xEvent *ev)
a1786 7
#define KILL_SEQUENCE     ((1L << KK_CONTROL)|(1L << KK_ALT)|(1L << KK_F8)|(1L << KK_F10))
#define SPECIAL_SEQUENCE  ((1L << KK_CONTROL) | (1L << KK_ALT))
#define SETKILLKEY(b)     (KdSpecialKeys |= (1L << (b)))
#define CLEARKILLKEY(b)   (KdSpecialKeys &= ~(1L << (b)))

CARD32	KdSpecialKeys = 0;

a1799 83
static void
KdCheckSpecialKeys(KdKeyboardInfo *ki, int type, int sym)
{
    if (!ki)
        return;

    /*
     * Ignore key releases
     */

    if (type == KeyRelease)
        return;

    /* Some iPaq keyboard -> mouse button mapping used to be here, but I
     * refuse to perpetuate this madness. -daniels */

    /*
     * Check for control/alt pressed
     */
    if ((ki->dixdev->key->state & (ControlMask|Mod1Mask)) !=
	(ControlMask|Mod1Mask))
	return;

    /*
     * Let OS function see keysym first
     */
    
    if (kdOsFuncs->SpecialKey)
	if ((*kdOsFuncs->SpecialKey) (sym))
	    return;

    /*
     * Now check for backspace or delete; these signal the
     * X server to terminate
     *
     * I can't believe it's not XKB. -daniels
     */
    switch (sym) {
    case XK_BackSpace:
    case XK_Delete:
    case XK_KP_Delete:
	/*
	 * Set the dispatch exception flag so the server will terminate the
	 * next time through the dispatch loop.
	 */
	if (kdAllowZap || party_like_its_1989)
	    dispatchException |= DE_TERMINATE;
	break;
    }
}

/*
 * kdEnqueueKeyboardEvent
 *
 * This function converts hardware keyboard event information into an X event
 * and enqueues it using MI.  It wakes up the server before returning so that
 * the event will be processed normally.
 *
 */

static void
KdHandleKeyboardEvent (KdKeyboardInfo *ki, int type, int key)
{
    int           byte;
    CARD8         bit;
    KdPointerInfo *pi;
    
    byte = key >> 3;
    bit = 1 << (key & 7);

    switch (type) {
    case KeyPress:
	ki->keyState[byte] |= bit;
	break;
    case KeyRelease:
	ki->keyState[byte] &= ~bit;
	break;
    }

    for (pi = kdPointers; pi; pi = pi->next)
	KdRunMouseMachine (pi, keyboard, 0, 0, 0, 0, 0, 0);
}

d1803 1
d1812 1
a1812 1
            if (IsKeyDown(ki, key)) {
d1823 1
d1837 2
a1838 1
            shouldBeSet = (keyc->state & LockMask) != 0;
d1864 1
a1864 1
	
d1872 1
a1872 9
	
#ifdef XKB
        if (noXkbExtension)
#endif
        {
            KdCheckSpecialKeys(ki, type, key_code);
            KdHandleKeyboardEvent(ki, type, key_code);
	}
	
d1874 1
d1877 1
a1877 1
            KdQueueEvent(ki->dixdev, (kdEvents + i)->event);
d1909 1
a1909 1
    
d1925 2
a1926 2
	    x = matrix[0][0] * rx + matrix[0][1] * ry;
	    y = matrix[1][0] * rx + matrix[1][1] * ry;
d1987 1
a1987 1
        KdQueueEvent(pi->dixdev, (kdEvents + i)->event);
d2004 1
a2004 1
    
d2023 1
a2023 1
KdWakeupHandler (int		screen, 
d2032 1
a2032 1
    
d2072 1
a2072 1
    
d2078 1
a2078 1
	
d2091 1
a2091 1
	if (pNewScreen == pScreen) 
d2133 1
a2133 1
    
d2138 1
a2138 1
    
d2143 1
a2143 1
    
d2170 1
a2170 1
miPointerScreenFuncRec kdPointerScreenFuncs = 
d2178 1
a2178 1
ProcessInputEvents ()
d2252 2
a2253 1
NewInputDeviceRequest(InputOption *options, DeviceIntPtr *pdev)
d2276 16
d2304 1
a2304 1
                pi->path = KdSaveString(option->value);
d2306 1
a2306 1
                ki->path = KdSaveString(option->value);
d2332 2
a2333 2
            ActivateDevice(pi->dixdev) != Success ||
            EnableDevice(pi->dixdev) != TRUE) {
d2340 2
a2341 2
            ActivateDevice(ki->dixdev) != Success ||
            EnableDevice(ki->dixdev) != TRUE) {
d2359 1
a2359 1
    RemoveDevice(pDev);
@


1.4
log
@OpenBSD still uses old xkb-data, whose default rules are called 'xorg'.
Change kdrive's default configuration too.
@
text
@d68 1
a68 1
static xEvent           *kdEvents = NULL;
a440 1
	    GetMotionHistory,
d1017 1
a1017 1
    ki->dixdev = AddInputDevice(KdKeyboardProc, TRUE);
d1024 2
d1088 1
a1088 1
    pi->dixdev = AddInputDevice(KdPointerProc, TRUE);
d1095 2
d1134 1
a1134 1
    newopt = (InputOption *) xalloc(sizeof (InputOption));
a1137 2
    bzero(newopt, sizeof (InputOption));

a1394 5
    if (!kdEvents)
        kdEvents = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!kdEvents)
        FatalError("Couldn't allocate event buffer\n");

d1743 1
a1743 1
#ifndef NDEBUG
d1776 1
a1776 1
#endif
d1928 1
a1928 1
	/* 
d1932 1
a1932 1
	if (kdDontZap == FALSE)
d1983 1
d1986 1
a1986 1
                    KdQueueEvent (ki->dixdev, kdEvents + i);
d2048 1
d2051 1
a2051 1
            KdQueueEvent(ki->dixdev, kdEvents + i);
d2112 1
d2114 9
a2122 6
    } else if ((pi->dixdev->valuator) && (x != pi->dixdev->valuator->lastx ||
                                          y != pi->dixdev->valuator->lasty))
            dixflags = POINTER_ABSOLUTE;

    if (dixflags)
        _KdEnqueuePointerEvent(pi, MotionNotify, x, y, z, 0, dixflags, FALSE);
d2157 3
a2159 2
    nEvents = GetPointerEvents(kdEvents, pi->dixdev, type, b, absrel, 0, 3,
                               valuators);
d2161 1
a2161 1
        KdQueueEvent(pi->dixdev, kdEvents + i);
d2336 1
a2336 1
KdWarpCursor (ScreenPtr pScreen, int x, int y)
d2340 1
a2340 1
    miPointerWarpCursor (pScreen, x, y);
d2355 1
a2355 1
    miPointerUpdate();
d2413 1
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d979 1
a979 1
    ki->xkbRules = KdSaveString("base");
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d1298 1
a1298 1
    pi->nButtons = 3;
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: kinput.c,v 1.1 1999/11/02 03:54:46 keithp Exp $
 *
d3 1
d9 1
a9 1
 * documentation, and that the name of Keith Packard not be used in
d11 1
a11 1
 * specific, written prior permission.  Keith Packard makes no
d15 1
a15 1
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d17 1
a17 1
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
a22 1
/* $RCSId: xc/programs/Xserver/hw/kdrive/kinput.c,v 1.30 2002/11/13 16:37:39 keithp Exp $ */
a34 1
#include "kkeymap.h"
d42 1
a42 1
#include <X11/extensions/XKBsrv.h>
d45 19
a63 1
static DeviceIntPtr	pKdKeyboard, pKdPointer;
d65 4
a68 1
#define MAX_MOUSE_DRIVERS   4
a69 6
static KdMouseFuncs	*kdMouseFuncs[MAX_MOUSE_DRIVERS];
static int		kdNMouseFuncs;
static KdKeyboardFuncs	*kdKeyboardFuncs;
static int		kdBellPitch;
static int		kdBellDuration;
static int		kdLeds;
d73 1
a73 1
static KdMouseMatrix	kdMouseMatrix = {
d78 1
a78 13
int		kdMouseButtonCount;
int		kdMinScanCode;
int		kdMaxScanCode;
int		kdMinKeyCode;
int		kdMaxKeyCode;
int		kdKeymapWidth = KD_MAX_WIDTH;
KeySym		kdKeymap[KD_MAX_LENGTH * KD_MAX_WIDTH];
CARD8		kdModMap[MAP_LENGTH];
KeySymsRec	kdKeySyms;


void
KdResetInputMachine (void);
d80 5
a84 5
#define KD_KEY_COUNT		248

CARD8		kdKeyState[KD_KEY_COUNT/8];

#define IsKeyDown(key) ((kdKeyState[(key) >> 3] >> ((key) & 7)) & 1)
d89 5
a93 6
    int	    type;
    int	    fd;
    void    (*read) (int fd, void *closure);
    int	    (*enable) (int fd, void *closure);
    void    (*disable) (int fd, void *closure);
    void    *closure;
d96 4
a99 3
KdInputFd    	kdInputFds[KD_MAX_INPUT_FDS];
int		kdNumInputFds;
int		kdInputTypeSequence;
d130 1
a130 2
#undef VERIFY_SIGIO
#ifdef VERIFY_SIGIO
d139 1
a139 1
    if (!sigismember (&old, SIGIO))
d141 2
d159 11
a219 6
int
KdAllocInputType (void)
{
    return ++kdInputTypeSequence;
}

d221 1
a221 1
KdRegisterFd (int type, int fd, void (*read) (int fd, void *closure), void *closure)
a224 1
    kdInputFds[kdNumInputFds].type = type;
d230 1
a230 1
    ++kdNumInputFds;
d237 1
a237 17
KdRegisterFdEnableDisable (int fd, 
			   int (*enable) (int fd, void *closure),
			   void (*disable) (int fd, void *closure))
{
    int	i;
    
    for (i = 0; i < kdNumInputFds; i++)
	if (kdInputFds[i].fd == fd)
	{
	    kdInputFds[i].enable = enable;
	    kdInputFds[i].disable = disable;
	    break;
	}
}
			   
void
KdUnregisterFds (int type, Bool do_close)
d241 3
a243 4
    for (i = 0; i < kdNumInputFds;)
    {
	if (kdInputFds[i].type == type)
	{
d248 1
a248 1
	    --kdNumInputFds;
d251 1
a252 2
	else
	    i++;
d257 6
d265 58
a322 3
    int	i;

    KdBlockSigio ();
a323 6
    for (i = 0; i < kdNumInputFds; i++)
    {
	KdRemoveFd (kdInputFds[i].fd);
	if (kdInputFds[i].disable)
	    (*kdInputFds[i].disable) (kdInputFds[i].fd, kdInputFds[i].closure);
    }
d330 3
a332 2
    xEvent	xE;
    int	i;
d335 9
a343 6
    for (i = 0; i < kdNumInputFds; i++)
    {
	KdNonBlockFd (kdInputFds[i].fd);
	if (kdInputFds[i].enable)
	    kdInputFds[i].fd = (*kdInputFds[i].enable) (kdInputFds[i].fd, kdInputFds[i].closure);
	KdAddFd (kdInputFds[i].fd);
d345 1
a345 1
    
d353 34
d388 1
a388 1
KdMouseProc(DeviceIntPtr pDevice, int onoff)
d390 4
a393 4
    BYTE	map[KD_MAX_BUTTON];
    DevicePtr	pDev = (DevicePtr)pDevice;
    int		i;
    
d396 12
a407 1
    
d411 31
a441 4
	for (i = 1; i <= kdMouseButtonCount; i++)
	    map[i] = i;
	InitPointerDeviceStruct(pDev, map, kdMouseButtonCount,
	    miPointerGetMotionEvents,
d443 14
a456 2
	    miPointerGetMotionBufferSize());
	break;
d459 18
a476 5
	pDev->on = TRUE;
	pKdPointer = pDevice;
	for (i = 0; i < kdNMouseFuncs; i++)
	    (*kdMouseFuncs[i]->Init)();
	break;
d478 15
d494 16
a509 8
	if (pDev->on)
	{
	    pDev->on = FALSE;
	    pKdPointer = 0;
	    for (i = 0; i < kdNMouseFuncs; i++)
		(*kdMouseFuncs[i]->Fini) ();
	}
	break;
d511 3
a513 1
    return Success;
d517 1
a517 1
LegalModifier(unsigned int key, DevicePtr pDev)
d523 34
a556 1
KdBell (int volume, DeviceIntPtr pDev, pointer ctrl, int something)
d558 3
d562 1
a562 1
	(*kdKeyboardFuncs->Bell) (volume, kdBellPitch, kdBellDuration);
d567 1
a567 1
KdSetLeds (void)
d569 7
a575 2
    if (kdInputEnabled)
	(*kdKeyboardFuncs->Leds) (kdLeds);
d579 1
a579 1
KdSetLed (int led, Bool on)
d581 5
a585 3
    NoteLedState (pKdKeyboard, led, on);
    kdLeds = pKdKeyboard->kbdfeed->ctrl.leds;
    KdSetLeds ();
d589 1
a589 1
KdSetMouseMatrix (KdMouseMatrix *matrix)
d591 1
a591 1
    kdMouseMatrix = *matrix;
d595 2
a596 1
KdComputeMouseMatrix (KdMouseMatrix *m, Rotation randr, int width, int height)
d634 12
d649 94
a742 4
    kdLeds = ctrl->leds;
    kdBellPitch = ctrl->bell_pitch;
    kdBellDuration = ctrl->bell_duration;
    KdSetLeds ();
d746 1
a746 1
KdKeybdProc(DeviceIntPtr pDevice, int onoff)
d750 2
d759 9
d771 47
a817 5
	if (pDev != LookupKeyboardDevice())
	{
	    return !Success;
	}
#ifndef XKB
d819 2
a820 2
				       &kdKeySyms,
				       kdModMap,
d822 375
a1196 2
#else
	memset(&names, 0, sizeof(XkbComponentNamesRec));
d1198 6
a1203 6
	XkbSetRulesDflts ("base", "pc101", "us", NULL, NULL);
	ret = XkbInitKeyboardDeviceStruct ((DeviceIntPtr) pDev,
					   &names,
					   &kdKeySyms,
					   kdModMap,
					   KdBell, KdKbdCtrl);
d1205 41
a1245 13
	if (!ret)
	    return BadImplementation;
	break;
    case DEVICE_ON:
	pDev->on = TRUE;
	pKdKeyboard = pDevice;
	if (kdKeyboardFuncs)
	    (*kdKeyboardFuncs->Init) ();
	break;
    case DEVICE_OFF:
    case DEVICE_CLOSE:
	pKdKeyboard = 0;
	if (pDev->on)
d1247 9
a1255 5
	    pDev->on = FALSE;
	    if (kdKeyboardFuncs)
		(*kdKeyboardFuncs->Fini) ();
	}
	break;
d1257 2
a1258 1
    return Success;
a1260 2
extern KeybdCtrl defaultKeyboardControl;

d1262 1
a1262 1
KdInitAutoRepeats (void)
d1264 1
a1264 4
    int		    key_code;
    unsigned char   mask;
    int		    i;
    unsigned char   *repeats;
d1266 1
a1266 3
    repeats = defaultKeyboardControl.autoRepeats;
    memset (repeats, '\0', 32);
    for (key_code = KD_MIN_KEYCODE; key_code <= KD_MAX_KEYCODE; key_code++)
d1268 13
a1280 6
	if (!kdModMap[key_code])
	{
	    i = key_code >> 3;
	    mask = 1 << (key_code & 7);
	    repeats[i] |= mask;
	}
d1284 47
a1330 32
const KdKeySymModsRec kdKeySymMods[] = {
  {  XK_Control_L,	ControlMask },
  {  XK_Control_R, ControlMask },
  {  XK_Shift_L,	ShiftMask },
  {  XK_Shift_R,	ShiftMask },
  {  XK_Caps_Lock,	LockMask },
  {  XK_Shift_Lock, LockMask },
  {  XK_Alt_L,	Mod1Mask },
  {  XK_Alt_R,	Mod1Mask },
  {  XK_Meta_L,	Mod1Mask },
  {  XK_Meta_R,	Mod1Mask },
  {  XK_Num_Lock,	Mod2Mask },
  {  XK_Super_L,	Mod3Mask },
  {  XK_Super_R,	Mod3Mask },
  {  XK_Hyper_L,	Mod3Mask },
  {  XK_Hyper_R,	Mod3Mask },
  {  XK_Mode_switch, Mod4Mask },
#ifdef TOUCHSCREEN
  /* PDA specific hacks */
#ifdef XF86XK_Start
  {  XF86XK_Start, ControlMask },
#endif
  {  XK_Menu, ShiftMask },
  {  XK_telephone, Mod1Mask },
#ifdef XF86XK_AudioRecord
  {  XF86XK_AudioRecord, Mod2Mask },
#endif
#ifdef XF86XK_Calendar
  {  XF86XK_Calendar, Mod3Mask }
#endif
#endif
};
d1332 1
a1332 1
#define NUM_SYM_MODS (sizeof(kdKeySymMods) / sizeof(kdKeySymMods[0]))
d1334 25
a1358 8
static void
KdInitModMap (void)
{
    int	    key_code;
    int	    row;
    int	    width;
    KeySym  *syms;
    int	    i;
d1360 1
a1360 2
    width = kdKeySyms.mapWidth;
    for (key_code = kdMinKeyCode; key_code <= kdMaxKeyCode; key_code++)
d1362 2
a1363 10
	kdModMap[key_code] = 0;
	syms = kdKeymap + (key_code - kdMinKeyCode) * width;
	for (row = 0; row < width; row++, syms++)
	{
	    for (i = 0; i < NUM_SYM_MODS; i++) 
	    {
		if (*syms == kdKeySymMods[i].modsym) 
		    kdModMap[key_code] |= kdKeySymMods[i].modbit;
	    }
	}
d1365 2
d1369 1
d1371 1
a1371 1
KdAddMouseDriver(KdMouseFuncs *pMouseFuncs)
d1373 3
a1375 3
    if (kdNMouseFuncs < MAX_MOUSE_DRIVERS)
	kdMouseFuncs[kdNMouseFuncs++] = pMouseFuncs;
}
a1376 31
void
KdInitInput(KdMouseFuncs    *pMouseFuncs,
	    KdKeyboardFuncs *pKeyboardFuncs)
{
    DeviceIntPtr	pKeyboard, pPointer;
    KdMouseInfo		*mi;
    
    if (!kdMouseInfo)
	KdParseMouse (0);
    kdMouseButtonCount = 0;
    for (mi = kdMouseInfo; mi; mi = mi->next)
    {
	if (mi->nbutton > kdMouseButtonCount)
	    kdMouseButtonCount = mi->nbutton;
    }

    kdNMouseFuncs = 0;
    KdAddMouseDriver (pMouseFuncs);
    kdKeyboardFuncs = pKeyboardFuncs;
    memset (kdKeyState, '\0', sizeof (kdKeyState));
    if (kdKeyboardFuncs)
	(*kdKeyboardFuncs->Load) ();
    kdMinKeyCode = kdMinScanCode + KD_KEY_OFFSET;
    kdMaxKeyCode = kdMaxScanCode + KD_KEY_OFFSET;
    kdKeySyms.map = kdKeymap;
    kdKeySyms.minKeyCode = kdMinKeyCode;
    kdKeySyms.maxKeyCode = kdMaxKeyCode;
    kdKeySyms.mapWidth = kdKeymapWidth;
    kdLeds = 0;
    kdBellPitch = 1000;
    kdBellDuration = 200;
d1378 22
a1399 18
    KdInitModMap ();
    KdInitAutoRepeats ();
    KdResetInputMachine ();
    pPointer  = AddInputDevice(KdMouseProc, TRUE);
    pKeyboard = AddInputDevice(KdKeybdProc, TRUE);
    RegisterPointerDevice(pPointer);
    RegisterKeyboardDevice(pKeyboard);
    miRegisterPointerDevice(screenInfo.screens[0], pPointer);
    mieqInit(&pKeyboard->public, &pPointer->public);
#ifdef XINPUT
    {
	static long zero1, zero2;

	//SetExtInputCheck (&zero1, &zero2);
	ErrorF("Extended Input Devices not yet supported. Impelement it at line %d in %s\n",
	       __LINE__, __FILE__);
    }
#endif
d1561 1
a1561 1
    KdMouseState   nextState;
a1705 3
#define EventX(e)   ((e)->u.keyButtonPointer.rootX)
#define EventY(e)   ((e)->u.keyButtonPointer.rootY)

d1707 1
a1707 1
KdInsideEmulationWindow (KdMouseInfo *mi, xEvent *ev)
d1709 5
a1713 12
    if (ev->u.keyButtonPointer.pad1)
    {
	mi->emulationDx += EventX(ev);
	mi->emulationDy += EventY(ev);
    }
    else
    {
	mi->emulationDx = EventX(&mi->heldEvent) - EventX(ev);
	mi->emulationDy = EventY(&mi->heldEvent) - EventY(ev);
    }
    return (abs (mi->emulationDx) < EMULATION_WINDOW &&
	    abs (mi->emulationDy) < EMULATION_WINDOW);
d1717 1
a1717 1
KdClassifyInput (KdMouseInfo *mi, xEvent *ev)
d1719 1
a1719 1
    switch (ev->u.u.type) {
d1721 1
a1721 1
	switch (ev->u.u.detail) {
d1729 1
a1729 1
	switch (ev->u.u.detail) {
d1737 1
a1737 1
	if (mi->eventHeld && !KdInsideEmulationWindow(mi, ev))
d1783 1
a1783 1
KdQueueEvent (xEvent *ev)
d1786 1
a1786 20
    if (ev->u.u.type == MotionNotify)
    {
	if (ev->u.keyButtonPointer.pad1)
	{
	    ev->u.keyButtonPointer.pad1 = 0;
	    miPointerDeltaCursor (ev->u.keyButtonPointer.rootX, 
				  ev->u.keyButtonPointer.rootY, 
				  ev->u.keyButtonPointer.time);
	}
	else
	{
	    miPointerAbsoluteCursor(ev->u.keyButtonPointer.rootX, 
				    ev->u.keyButtonPointer.rootY, 
				    ev->u.keyButtonPointer.time);
	}
    }
    else
    {
	mieqEnqueue (ev);
    }
d1789 4
a1792 2
static void
KdRunMouseMachine (KdMouseInfo *mi, KdInputClass c, xEvent *ev)
d1795 1
a1795 1
    int			a;
d1797 2
a1798 1
    t = &kdInputMachine[mi->mouseState][c];
d1805 10
a1814 4
	    mi->eventHeld = TRUE;
	    mi->emulationDx = 0;
	    mi->emulationDy = 0;
	    mi->heldEvent = *ev;
d1817 2
a1818 2
	    mi->emulationTimeout = GetTimeInMillis () + EMULATION_TIMEOUT;
	    mi->timeoutPending = TRUE;
d1821 4
a1824 1
	    KdQueueEvent (ev);
d1827 7
a1833 3
	    mi->eventHeld = FALSE;
	    mi->timeoutPending = FALSE;
	    KdQueueEvent (&mi->heldEvent);
d1836 1
a1836 1
	    mi->timeoutPending = FALSE;
d1839 4
a1842 3
	    ev->u.u.detail = 2;
	    mi->eventHeld = FALSE;
	    KdQueueEvent (ev);
d1845 3
a1847 2
	    ev->u.u.detail = 2;
	    KdQueueEvent (ev);
d1851 2
a1852 1
    mi->mouseState = t->nextState;
d1855 3
a1857 2
void
KdResetInputMachine (void)
d1859 4
a1862 16
    KdMouseInfo	*mi;

    for (mi = kdMouseInfo; mi; mi = mi->next)
    {
	mi->mouseState = start;
	mi->eventHeld = FALSE;
    }
}

static void
KdHandleMouseEvent (KdMouseInfo *mi, xEvent *ev)
{
    if (mi->emulateMiddleButton)
	KdRunMouseMachine (mi, KdClassifyInput (mi, ev), ev);
    else
	KdQueueEvent (ev);
d1866 1
a1866 1
KdReceiveTimeout (KdMouseInfo *mi)
d1868 1
a1868 1
    KdRunMouseMachine (mi, timeout, 0);
d1871 4
a1874 6
#define KILL_SEQUENCE ((1L << KK_CONTROL)|(1L << KK_ALT)|(1L << KK_F8)|(1L << KK_F10))
#define SPECIAL_SEQUENCE ((1L << KK_CONTROL) | (1L << KK_ALT))
#define SETKILLKEY(b) (KdSpecialKeys |= (1L << (b)))
#define CLEARKILLKEY(b) (KdSpecialKeys &= ~(1L << (b)))
#define KEYMAP	    (pKdKeyboard->key->curKeySyms)
#define KEYCOL1(k) (KEYMAP.map[((k)-kdMinKeyCode)*KEYMAP.mapWidth])
a1877 5
#if 0
/* already defined in opaque.h */
extern char dispatchException;
#endif

d1892 1
a1892 1
KdCheckSpecialKeys(xEvent *xE)
d1894 2
a1895 3
    KeySym	sym = KEYCOL1(xE->u.u.detail);
    
    if (!pKdKeyboard) return;
a1899 2
    
    if (xE->u.u.type == KeyRelease) return;
d1901 5
a1905 17
#ifdef XIPAQ
    /* 
     * Check for buttons 1, 2 and 3 on the iPAQ
     */
    if (sym == XK_Pointer_Button1 && kdMouseInfo) {
	KdEnqueueMouseEvent(kdMouseInfo, KD_MOUSE_DELTA | KD_BUTTON_1, 0, 0);
	return;
    }
    if (sym == XK_Pointer_Button2 && kdMouseInfo) {
	KdEnqueueMouseEvent(kdMouseInfo, KD_MOUSE_DELTA | KD_BUTTON_2, 0, 0);
	return;
    }
    if (sym == XK_Pointer_Button3 && kdMouseInfo) {
	KdEnqueueMouseEvent(kdMouseInfo, KD_MOUSE_DELTA | KD_BUTTON_3, 0, 0);
	return;
    }
#endif
d1910 1
a1910 1
    if ((pKdKeyboard->key->state & (ControlMask|Mod1Mask)) !=
d1913 1
a1913 2
    
    
d1925 2
d1952 1
a1952 1
KdHandleKeyboardEvent (xEvent *ev)
d1954 3
a1956 4
    int		key = ev->u.u.detail;
    int		byte;
    CARD8	bit;
    KdMouseInfo	*mi;
d1960 2
a1961 1
    switch (ev->u.u.type) {
d1963 1
a1963 1
	kdKeyState[byte] |= bit;
d1966 1
a1966 1
	kdKeyState[byte] &= ~bit;
d1969 3
a1971 3
    for (mi = kdMouseInfo; mi; mi = mi->next)
	KdRunMouseMachine (mi, keyboard, 0);
    KdQueueEvent (ev);
d1977 2
a1978 2
    xEvent  xE;
    int	    key;
d1981 13
a1993 8
    for (key = 0; key < KD_KEY_COUNT; key++)
	if (IsKeyDown(key))
	{
	    xE.u.keyButtonPointer.time = GetTimeInMillis();
	    xE.u.u.type = KeyRelease;
	    xE.u.u.detail = key;
	    KdHandleKeyboardEvent (&xE);
	}
d2000 12
a2011 11
    KeyClassPtr	    keyc = pKdKeyboard->key;
    Bool	    isSet, shouldBeSet;

    if (kdKeyboardFuncs->LockLed)
    {
	isSet = (kdLeds & (1 << (kdKeyboardFuncs->LockLed-1))) != 0;
	shouldBeSet = (keyc->state & LockMask) != 0;
	if (isSet != shouldBeSet)
	{
	    KdSetLed (kdKeyboardFuncs->LockLed, shouldBeSet);
	}
d2016 8
a2023 6
KdEnqueueKeyboardEvent(unsigned char	scan_code,
		       unsigned char	is_up)
{
    unsigned char   key_code;
    xEvent	    xE;
    KeyClassPtr	    keyc;
d2025 1
a2025 1
    if (!pKdKeyboard)
a2026 1
    keyc = pKdKeyboard->key;
d2028 2
a2029 1
    xE.u.keyButtonPointer.time = GetTimeInMillis();
d2031 1
a2031 1
    if (kdMinScanCode <= scan_code && scan_code <= kdMaxScanCode)
d2033 1
a2033 1
	key_code = scan_code + KD_MIN_KEYCODE - kdMinScanCode;
d2039 1
a2039 1
	    xE.u.u.type = KeyRelease;
d2041 1
a2041 2
	    xE.u.u.type = KeyPress;
	xE.u.u.detail = key_code;
d2043 6
a2048 12
	switch (KEYCOL1(key_code)) 
	{
	case XK_Num_Lock:
	case XK_Scroll_Lock:
	case XK_Shift_Lock:
	case XK_Caps_Lock:
	    if (xE.u.u.type == KeyRelease)
		return;
	    if (IsKeyDown (key_code))
		xE.u.u.type = KeyRelease;
	    else
		xE.u.u.type = KeyPress;
d2051 7
a2057 31
	/*
	 * Check pressed keys which are already down
	 */
	if (IsKeyDown (key_code) && xE.u.u.type == KeyPress)
	{
	    KeybdCtrl	*ctrl = &pKdKeyboard->kbdfeed->ctrl;
	    
	    /*
	     * Check auto repeat
	     */
	    if (!ctrl->autoRepeat || keyc->modifierMap[key_code] ||
		!(ctrl->autoRepeats[key_code >> 3] & (1 << (key_code & 7))))
	    {
		return;
	    }
	    /*
	     * X delivers press/release even for autorepeat
	     */
	    xE.u.u.type = KeyRelease;
	    KdHandleKeyboardEvent (&xE);
	    xE.u.u.type = KeyPress;
	}
	/*
	 * Check released keys which are already up
	 */
	else if (!IsKeyDown (key_code) && xE.u.u.type == KeyRelease)
	{
	    return;
	}
	KdCheckSpecialKeys (&xE);
	KdHandleKeyboardEvent (&xE);
a2060 10
#define SetButton(mi, b, v, s) \
{\
    xE.u.u.detail = mi->map[b]; \
    xE.u.u.type = v; \
    KdHandleMouseEvent (mi, &xE); \
}

#define Press(mi, b)         SetButton(mi, b, ButtonPress, "Down")
#define Release(mi, b)       SetButton(mi, b, ButtonRelease, "Up")

d2062 1
a2062 1
 * kdEnqueueMouseEvent
d2070 1
a2070 32
static void
KdMouseAccelerate (DeviceIntPtr	device, int *dx, int *dy)
{
    PtrCtrl *pCtrl = &device->ptrfeed->ctrl;
    double  speed = sqrt (*dx * *dx + *dy * *dy);
    double  accel;
#ifdef QUADRATIC_ACCELERATION
    double  m;

    /*
     * Ok, so we want it moving num/den times faster at threshold*2
     *
     * accel = m *threshold + b
     * 1 = m * 0 + b	-> b = 1
     *
     * num/den = m * (threshold * 2) + 1
     *
     * num / den - 1 = m * threshold * 2
     * (num / den - 1) / threshold * 2 = m
     */
    m = (((double) pCtrl->num / (double) pCtrl->den - 1.0) / 
	 ((double) pCtrl->threshold * 2.0));
    accel = m * speed + 1;
#else
    accel = 1.0;
    if (speed > pCtrl->threshold)
	accel = (double) pCtrl->num / pCtrl->den;
#endif
    *dx = accel * *dx;
    *dy = accel * *dy;
}

d2072 2
a2073 1
KdEnqueueMouseEvent(KdMouseInfo *mi, unsigned long flags, int rx, int ry)
d2075 7
a2081 7
    CARD32	    ms;
    xEvent	    xE;
    unsigned char   buttons;
    int		    x, y;
    int		    (*matrix)[3] = kdMouseMatrix.matrix;
    unsigned long   button;
    int		    n;
d2083 1
a2083 1
    if (!pKdPointer)
d2087 4
a2090 5
    
    if (flags & KD_MOUSE_DELTA)
    {
	if (mi->transformCoordinates)
	{
d2094 1
a2094 2
	else
	{
a2097 2
	KdMouseAccelerate (pKdPointer, &x, &y);
	xE.u.keyButtonPointer.pad1 = 1;
d2099 4
a2102 6
    else
    {
	if (mi->transformCoordinates)
	{
	    x = matrix[0][0] * rx + matrix[0][1] * ry + matrix[0][2];
	    y = matrix[1][0] * rx + matrix[1][1] * ry + matrix[1][2];
d2104 1
a2104 2
	else
	{
a2107 1
	xE.u.keyButtonPointer.pad1 = 0;
d2109 12
a2120 7
    xE.u.keyButtonPointer.time = ms;
    xE.u.keyButtonPointer.rootX = x;
    xE.u.keyButtonPointer.rootY = y;

    xE.u.u.type = MotionNotify;
    xE.u.u.detail = 0;
    KdHandleMouseEvent (mi, &xE);
d2124 15
a2138 13
    for (button = KD_BUTTON_1, n = 0; button <= KD_BUTTON_5; button <<= 1, n++)
    {
	if ((mi->buttonState & button) ^ (buttons & button))
	{
	    if (buttons & button)
	    {
		Press(mi, n);
	    }
	    else
	    {
		Release(mi, n);
	    }
	}
d2140 2
a2141 1
    mi->buttonState = buttons;
d2145 2
a2146 1
KdEnqueueMotionEvent (KdMouseInfo *mi, int x, int y)
d2148 2
a2149 9
    xEvent  xE;
    CARD32  ms;
    
    ms = GetTimeInMillis();
    
    xE.u.u.type = MotionNotify;
    xE.u.keyButtonPointer.time = ms;
    xE.u.keyButtonPointer.rootX = x;
    xE.u.keyButtonPointer.rootY = y;
d2151 8
a2158 1
    KdHandleMouseEvent (mi, &xE);
d2167 1
a2167 1
    KdMouseInfo		    *mi;
d2170 1
a2170 1
    for (mi = kdMouseInfo; mi; mi = mi->next)
d2172 1
a2172 1
	if (mi->timeoutPending)
d2176 1
a2176 1
	    ms = mi->emulationTimeout - GetTimeInMillis ();
d2202 1
a2202 1
    KdMouseInfo	*mi;
d2214 1
a2214 1
    for (mi = kdMouseInfo; mi; mi = mi->next)
d2216 1
a2216 1
	if (mi->timeoutPending)
d2218 1
a2218 1
	    if ((long) (GetTimeInMillis () - mi->emulationTimeout) >= 0)
d2220 1
a2220 1
		mi->timeoutPending = FALSE;
d2222 1
a2222 1
		KdReceiveTimeout (mi);
d2356 157
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
a4 1
 * Copyright  2006 Nokia Corporation
d10 1
a10 1
 * documentation, and that the name of the authors not be used in
d12 1
a12 1
 * specific, written prior permission.  The authors make no
d16 1
a16 1
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d18 1
a18 1
 * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d24 1
d37 1
d45 1
a45 1
#include <xkbsrv.h>
d48 1
a48 19
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h" /* even though we don't use stubs.  cute, no? */
#include "exevents.h"
#include "extinit.h"
#include "exglobals.h"

#define AtomFromName(x) MakeAtom(x, strlen(x), 1)

struct KdConfigDevice {
    char *line;
    struct KdConfigDevice *next;
};

/* kdKeyboards and kdPointers hold all the real devices. */
static KdKeyboardInfo *kdKeyboards         = NULL;
static KdPointerInfo  *kdPointers          = NULL;
static struct KdConfigDevice *kdConfigKeyboards   = NULL;
static struct KdConfigDevice *kdConfigPointers    = NULL;
d50 1
a50 4
static KdKeyboardDriver *kdKeyboardDrivers = NULL;
static KdPointerDriver  *kdPointerDrivers  = NULL;

static xEvent           *kdEvents = NULL;
d52 6
d61 1
a61 1
static KdPointerMatrix	kdPointerMatrix = {
d66 13
a78 1
void KdResetInputMachine (void);
d80 5
a84 5
#define IsKeyDown(ki, key) ((ki->keyState[(key) >> 3] >> ((key) & 7)) & 1)
#define KEYMAP(ki)        (ki->dixdev->key->curKeySyms)
#define KEYMAPDDX(ki)     (ki->keySyms)
#define KEYCOL1(ki, k)    (KEYMAP(ki).map[((k)-(KEYMAP(ki).minKeyCode))*KEYMAP(ki).mapWidth])
#define KEYCOL1DDX(ki, k) (KEYMAPDDX(ki).map[((k)-(KEYMAPDDX(ki).minKeyCode))*KEYMAPDDX(ki).mapWidth])
d89 6
a94 5
    int	        fd;
    void        (*read) (int fd, void *closure);
    int	        (*enable) (int fd, void *closure);
    void        (*disable) (int fd, void *closure);
    void        *closure;
d97 3
a99 4
static KdInputFd kdInputFds[KD_MAX_INPUT_FDS];
static int	 kdNumInputFds;

extern Bool      kdRawPointerCoordinates;
d130 2
a131 1
#ifdef DEBUG_SIGIO
d140 1
a140 1
    if (!sigismember (&old, SIGIO)) {
a141 2
        KdBacktrace(0);
    }
a157 11
void
KdResetInputMachine (void)
{
    KdPointerInfo *pi;

    for (pi = kdPointers; pi; pi = pi->next) {
        pi->mouseState = start;
        pi->eventHeld = FALSE;
    }
}

d208 6
d215 1
a215 1
KdRegisterFd (int fd, void (*read) (int fd, void *closure), void *closure)
d219 1
d225 1
a225 1
    kdNumInputFds++;
d232 17
a248 1
KdUnregisterFd (void *closure, int fd, Bool do_close)
d252 4
a255 3
    for (i = 0; i < kdNumInputFds; i++) {
	if (kdInputFds[i].closure == closure &&
            (fd == -1 || kdInputFds[i].fd == fd)) {
d260 1
a260 1
	    kdNumInputFds--;
a262 1
            break;
d264 2
d270 1
a270 1
KdUnregisterFds (void *closure, Bool do_close)
d272 3
a274 2
    KdUnregisterFd(closure, -1, do_close);
}
d276 5
a280 60
void
KdDisableInput (void)
{
    KdKeyboardInfo *ki;
    KdPointerInfo *pi;
    int found = 0, i = 0;

    KdBlockSigio();

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->driver && ki->driver->Disable)
            (*ki->driver->Disable) (ki);
    }

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->driver && pi->driver->Disable)
            (*pi->driver->Disable) (pi);
    }

    if (kdNumInputFds) {
        ErrorF("[KdDisableInput] Buggy drivers: still %d input fds left!",
               kdNumInputFds);
        i = 0;
        while (i < kdNumInputFds) {
            found = 0;
            for (ki = kdKeyboards; ki; ki = ki->next) {
                if (ki == kdInputFds[i].closure) {
                    ErrorF("    fd %d belongs to keybd driver %s\n",
                           kdInputFds[i].fd,
                           ki->driver && ki->driver->name ?
                             ki->driver->name : "(unnamed!)");
                    found = 1;
                    break;
                }
            }

            if (found) {
                i++;
                continue;
            }

            for (pi = kdPointers; pi; pi = pi->next) {
                if (pi == kdInputFds[i].closure) {
                    ErrorF("    fd %d belongs to pointer driver %s\n",
                           kdInputFds[i].fd,
                           pi->driver && pi->driver->name ?
                             pi->driver->name : "(unnamed!)");
                    break;
                }
            }

            if (found) {
                i++;
                continue;
            }

            ErrorF("    fd %d not claimed by any active device!\n",
                   kdInputFds[i].fd);
            KdUnregisterFd(kdInputFds[i].closure, kdInputFds[i].fd, TRUE);
        }
a281 1

d288 2
a289 3
    xEvent xE;
    KdKeyboardInfo *ki;
    KdPointerInfo *pi;
d292 6
a297 4

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->driver && ki->driver->Enable)
            (*ki->driver->Enable) (ki);
d299 1
a299 6

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->driver && pi->driver->Enable)
            (*pi->driver->Enable) (pi);
    }

d307 2
a308 2
static KdKeyboardDriver *
KdFindKeyboardDriver (char *name)
d310 3
a312 5
    KdKeyboardDriver *ret;

    /* ask a stupid question ... */
    if (!name)
        return NULL;
a313 32
    for (ret = kdKeyboardDrivers; ret; ret = ret->next) {
        if (strcmp(ret->name, name) == 0)
            return ret;
    }

    return NULL;
}

static KdPointerDriver *
KdFindPointerDriver (char *name)
{
    KdPointerDriver *ret;

    /* ask a stupid question ... */
    if (!name)
        return NULL;

    for (ret = kdPointerDrivers; ret; ret = ret->next) {
        if (strcmp(ret->name, name) == 0)
            return ret;
    }

    return NULL;
}

static int
KdPointerProc(DeviceIntPtr pDevice, int onoff)
{
    DevicePtr       pDev = (DevicePtr)pDevice;
    KdPointerInfo   *pi;
    Atom            xiclass;

d316 1
a316 12

    for (pi = kdPointers; pi; pi = pi->next) {
        if (pi->dixdev && pi->dixdev->id == pDevice->id)
            break;
    }

    if (!pi || !pi->dixdev || pi->dixdev->id != pDevice->id) {
        ErrorF("[KdPointerProc] Failed to find pointer for device %d!\n",
               pDevice->id);
        return BadImplementation;
    }

d320 4
a323 31
#ifdef DEBUG
        ErrorF("initialising pointer %s ...\n", pi->name);
#endif
        if (!pi->driver) {
            if (!pi->driverPrivate) {
                ErrorF("no driver specified for %s\n", pi->name);
                return BadImplementation;
            }

            pi->driver = KdFindPointerDriver(pi->driverPrivate);
            if (!pi->driver) {
                ErrorF("Couldn't find pointer driver %s\n",
                       pi->driverPrivate ? (char *) pi->driverPrivate :
                       "(unnamed)");
                return !Success;
            }
            xfree(pi->driverPrivate);
            pi->driverPrivate = NULL;
        }

        if (!pi->driver->Init) {
            ErrorF("no init function\n");
            return BadImplementation;
        }

        if ((*pi->driver->Init) (pi) != Success) {
            return !Success;
        }

	InitPointerDeviceStruct(pDev, pi->map, pi->nButtons,
	    GetMotionHistory,
d325 2
a326 14
	    GetMotionHistorySize(), pi->nAxes);

        if (pi->inputClass == KD_TOUCHSCREEN) {
            InitAbsoluteClassDeviceStruct(pDevice);
            xiclass = AtomFromName(XI_TOUCHSCREEN);
        }
        else {
            xiclass = AtomFromName(XI_MOUSE);
        }

        AssignTypeAndName(pi->dixdev, xiclass,
                          pi->name ? pi->name : "Generic KDrive Pointer");

	return Success;
d329 5
a333 18
        if (pDev->on == TRUE)
            return Success;
        
        if (!pi->driver->Enable) {
            ErrorF("no enable function\n");
            return BadImplementation;
        }

        if ((*pi->driver->Enable) (pi) == Success) {
            pDev->on = TRUE;
            return Success;
        }
        else {
            return BadImplementation;
        }

	return Success;

a334 15
        if (pDev->on == FALSE) {
            return Success;
        }

        if (!pi->driver->Disable) {
            return BadImplementation;
        }
        else {
            (*pi->driver->Disable) (pi);
            pDev->on = FALSE;
            return Success;
        }

        return Success;

d336 8
a343 16
	if (pDev->on) {
            if (!pi->driver->Disable) {
                return BadImplementation;
            }
            (*pi->driver->Disable) (pi);
            pDev->on = FALSE;
        }

        if (!pi->driver->Fini)
            return BadImplementation;

        (*pi->driver->Fini) (pi);

        KdRemovePointer(pi);
        
        return Success;
d345 1
a345 3

    /* NOTREACHED */
    return BadImplementation;
d349 1
a349 1
LegalModifier(unsigned int key, DeviceIntPtr pDev)
d355 1
a355 18
KdBell (int volume, DeviceIntPtr pDev, pointer arg, int something)
{
    KeybdCtrl *ctrl = arg;
    KdKeyboardInfo *ki = NULL;
    
    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDev->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDev->id || !ki->driver)
        return;
    
    KdRingBell(ki, volume, ctrl->bell_pitch, ctrl->bell_duration);
}

void
DDXRingBell(int volume, int pitch, int duration)
a356 19
    KdKeyboardInfo *ki = NULL;

    if (kdOsFuncs->Bell) {
        (*kdOsFuncs->Bell)(volume, pitch, duration);
    }
    else {
        for (ki = kdKeyboards; ki; ki = ki->next) {
            if (ki->dixdev->coreEvents)
                KdRingBell(ki, volume, pitch, duration);
        }
    }
}

void
KdRingBell(KdKeyboardInfo *ki, int volume, int pitch, int duration)
{
    if (!ki || !ki->driver || !ki->driver->Bell)
        return;
        
d358 1
a358 1
        (*ki->driver->Bell) (ki, volume, pitch, duration);
d363 1
a363 1
KdSetLeds (KdKeyboardInfo *ki, int leds)
d365 2
a366 7
    if (!ki || !ki->driver)
        return;

    if (kdInputEnabled) {
        if (ki->driver->Leds)
            (*ki->driver->Leds) (ki, leds);
    }
d370 1
a370 1
KdSetLed (KdKeyboardInfo *ki, int led, Bool on)
d372 3
a374 5
    if (!ki || !ki->dixdev || !ki->dixdev->kbdfeed)
        return;

    NoteLedState (ki->dixdev, led, on);
    KdSetLeds (ki, ki->dixdev->kbdfeed->ctrl.leds);
d378 1
a378 1
KdSetPointerMatrix (KdPointerMatrix *matrix)
d380 1
a380 1
    kdPointerMatrix = *matrix;
d384 1
a384 2
KdComputePointerMatrix (KdPointerMatrix *m, Rotation randr, int width,
                        int height)
d425 4
a428 94
    KdKeyboardInfo *ki;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDevice->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDevice->id || !ki->driver)
        return;

    KdSetLeds(ki, ctrl->leds);
    ki->bellPitch = ctrl->bell_pitch;
    ki->bellDuration = ctrl->bell_duration; 
}

extern KeybdCtrl defaultKeyboardControl;

static void
KdInitAutoRepeats (KdKeyboardInfo *ki)
{
    int		    key_code;
    unsigned char   mask;
    int		    i;
    unsigned char   *repeats;

    repeats = defaultKeyboardControl.autoRepeats;
    memset (repeats, '\0', 32);
    for (key_code = KD_MIN_KEYCODE; key_code <= KD_MAX_KEYCODE; key_code++)
    {
	if (!ki->modmap[key_code])
	{
	    i = key_code >> 3;
	    mask = 1 << (key_code & 7);
	    repeats[i] |= mask;
	}
    }
}

const KdKeySymModsRec kdKeySymMods[] = {
  {  XK_Control_L,	ControlMask },
  {  XK_Control_R, ControlMask },
  {  XK_Shift_L,	ShiftMask },
  {  XK_Shift_R,	ShiftMask },
  {  XK_Caps_Lock,	LockMask },
  {  XK_Shift_Lock, LockMask },
  {  XK_Alt_L,	Mod1Mask },
  {  XK_Alt_R,	Mod1Mask },
  {  XK_Meta_L,	Mod1Mask },
  {  XK_Meta_R,	Mod1Mask },
  {  XK_Num_Lock,	Mod2Mask },
  {  XK_Super_L,	Mod3Mask },
  {  XK_Super_R,	Mod3Mask },
  {  XK_Hyper_L,	Mod3Mask },
  {  XK_Hyper_R,	Mod3Mask },
  {  XK_Mode_switch, Mod4Mask },
  /* PDA specific hacks */
#ifdef XF86XK_Start
  {  XF86XK_Start, ControlMask },
#endif
  {  XK_Menu, ShiftMask },
  {  XK_telephone, Mod1Mask },
#ifdef XF86XK_AudioRecord
  {  XF86XK_AudioRecord, Mod2Mask },
#endif
#ifdef XF86XK_Calendar
  {  XF86XK_Calendar, Mod3Mask }
#endif
};

#define NUM_SYM_MODS (sizeof(kdKeySymMods) / sizeof(kdKeySymMods[0]))

static void
KdInitModMap (KdKeyboardInfo *ki)
{
    int	    key_code;
    int	    row;
    int	    width;
    KeySym  *syms;
    int	    i;

    width = ki->keySyms.mapWidth;
    for (key_code = ki->keySyms.minKeyCode; key_code <= ki->keySyms.maxKeyCode; key_code++)
    {
	ki->modmap[key_code] = 0;
	syms = ki->keySyms.map + (key_code - ki->keySyms.minKeyCode) * width;
	for (row = 0; row < width; row++, syms++)
	{
	    for (i = 0; i < NUM_SYM_MODS; i++) 
	    {
		if (*syms == kdKeySymMods[i].modsym) 
		    ki->modmap[key_code] |= kdKeySymMods[i].modbit;
	    }
	}
    }
d432 1
a432 1
KdKeyboardProc(DeviceIntPtr pDevice, int onoff)
a435 2
    KdKeyboardInfo *ki;
    Atom xiclass;
a442 9
    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDevice->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDevice->id) {
        return BadImplementation;
    }

d446 11
a456 28
#ifdef DEBUG
        ErrorF("initialising keyboard %s\n", ki->name);
#endif
        if (!ki->driver) {
            if (!ki->driverPrivate) {
                ErrorF("no driver specified!\n");
                return BadImplementation;
            }

            ki->driver = KdFindKeyboardDriver(ki->driverPrivate);
            if (!ki->driver) {
                ErrorF("Couldn't find keyboard driver %s\n",
                       ki->driverPrivate ? (char *) ki->driverPrivate :
                       "(unnamed)");
                return !Success;
            }
            xfree(ki->driverPrivate);
            ki->driverPrivate = NULL;
        }

        if (!ki->driver->Init) {
            ErrorF("Keyboard %s: no init function\n", ki->name);
            return BadImplementation;
        }

        if ((*ki->driver->Init) (ki) != Success) {
            return !Success;
        }
d458 6
a463 17
        KdInitModMap(ki);
        KdInitAutoRepeats(ki);

#ifdef XKB
        if (!noXkbExtension) {
            memset(&names, 0, sizeof(XkbComponentNamesRec));

            XkbSetRulesDflts (ki->xkbRules, ki->xkbModel, ki->xkbLayout,
                              ki->xkbVariant, ki->xkbOptions);

            ret = XkbInitKeyboardDeviceStruct (pDevice,
                                               &names,
                                               &ki->keySyms,
                                               ki->modmap,
                                               KdBell, KdKbdCtrl);
        }
        else
d465 1
a465 6
	ret = InitKeyboardDeviceStruct(pDev,
				       &ki->keySyms,
				       ki->modmap,
				       KdBell, KdKbdCtrl);
	if (!ret) {
            ErrorF("Couldn't initialise keyboard %s\n", ki->name);
d467 1
a467 10
        }

        xiclass = AtomFromName(XI_KEYBOARD);
        AssignTypeAndName(pDevice, xiclass,
                          ki->name ? ki->name : "Generic KDrive Keyboard");

        KdResetInputMachine();

        return Success;

d469 5
a473 13
        if (pDev->on == TRUE)
            return Success;

        if (!ki->driver->Enable)
            return BadImplementation;

        if ((*ki->driver->Enable) (ki) != Success) {
            return BadMatch;
        }

        pDev->on = TRUE;
        return Success;

a474 13
        if (pDev->on == FALSE)
            return Success;

        if (!ki->driver->Disable)
            return BadImplementation;

        (*ki->driver->Disable) (ki);
        pDev->on = FALSE;

        return Success;
        
        break;

d476 6
a481 6
	if (pDev->on) {
            if (!ki->driver->Disable)
                return BadImplementation;

            (*ki->driver->Disable) (ki);
            pDev->on = FALSE;
d483 1
a483 58

        if (!ki->driver->Fini)
            return BadImplementation;

        (*ki->driver->Fini) (ki);

        KdRemoveKeyboard(ki);

        return Success;
    }

    /* NOTREACHED */
    return BadImplementation;
}

void
KdAddPointerDriver (KdPointerDriver *driver)
{
    KdPointerDriver **prev;

    if (!driver)
        return;

    for (prev = &kdPointerDrivers; *prev; prev = &(*prev)->next) {
        if (*prev == driver)
            return;
    }
    *prev = driver;
}

void
KdRemovePointerDriver (KdPointerDriver *driver)
{
    KdPointerDriver *tmp;

    if (!driver)
        return;

    /* FIXME remove all pointers using this driver */
    for (tmp = kdPointerDrivers; tmp; tmp = tmp->next) {
        if (tmp->next == driver)
            tmp->next = driver->next;
    }
    if (tmp == driver)
        tmp = NULL;
}

void
KdAddKeyboardDriver (KdKeyboardDriver *driver)
{
    KdKeyboardDriver **prev;

    if (!driver)
        return;

    for (prev = &kdKeyboardDrivers; *prev; prev = &(*prev)->next) {
        if (*prev == driver)
            return;
a484 77
    *prev = driver;
}

void
KdRemoveKeyboardDriver (KdKeyboardDriver *driver)
{
    KdKeyboardDriver *tmp;

    if (!driver)
        return;

    /* FIXME remove all keyboards using this driver */
    for (tmp = kdKeyboardDrivers; tmp; tmp = tmp->next) {
        if (tmp->next == driver)
            tmp->next = driver->next;
    }
    if (tmp == driver)
        tmp = NULL;
}

KdKeyboardInfo *
KdNewKeyboard (void)
{
    KdKeyboardInfo *ki = xcalloc(sizeof(KdKeyboardInfo), 1);

    if (!ki)
        return NULL;
    
    ki->keySyms.map = (KeySym *)xcalloc(sizeof(KeySym),
                                        KD_MAX_LENGTH *
                                         kdDefaultKeySyms.mapWidth);
    if (!ki->keySyms.map) {
        xfree(ki);
        return NULL;
    }

    memcpy(ki->keySyms.map, kdDefaultKeySyms.map,
           sizeof(KeySym) * (KD_MAX_LENGTH * kdDefaultKeySyms.mapWidth));
    ki->keySyms.minKeyCode = kdDefaultKeySyms.minKeyCode;
    ki->keySyms.maxKeyCode = kdDefaultKeySyms.maxKeyCode;
    ki->keySyms.mapWidth = kdDefaultKeySyms.mapWidth;
    ki->minScanCode = 0;
    ki->maxScanCode = 0;
    ki->leds = 0;
    ki->bellPitch = 1000;
    ki->bellDuration = 200;
    ki->next = NULL;
    ki->options = NULL;
#ifdef XKB
    ki->xkbRules = KdSaveString("base");
    ki->xkbModel = KdSaveString("pc105");
    ki->xkbLayout = KdSaveString("us");
    ki->xkbVariant = NULL;
    ki->xkbOptions = NULL;
#endif

    return ki;
}

int
KdAddConfigKeyboard (char *keyboard)
{
    struct KdConfigDevice **prev, *new;

    if (!keyboard)
        return Success;

    new = (struct KdConfigDevice *) xcalloc(sizeof(struct KdConfigDevice), 1);
    if (!new)
        return BadAlloc;

    new->line = xstrdup(keyboard);
    new->next = NULL;

    for (prev = &kdConfigKeyboards; *prev; prev = &(*prev)->next);
    *prev = new;

d488 1
a488 223
int
KdAddKeyboard (KdKeyboardInfo *ki)
{
    KdKeyboardInfo **prev;

    if (!ki)
        return !Success;
    
    ki->dixdev = AddInputDevice(KdKeyboardProc, TRUE);
    if (!ki->dixdev) {
        ErrorF("Couldn't register keyboard device %s\n",
               ki->name ? ki->name : "(unnamed)");
        return !Success;
    }

    RegisterOtherDevice(ki->dixdev);

#ifdef DEBUG
    ErrorF("added keyboard %s with dix id %d\n", ki->name, ki->dixdev->id);
#endif

    for (prev = &kdKeyboards; *prev; prev = &(*prev)->next);
    *prev = ki;

    return Success;
}

void
KdRemoveKeyboard (KdKeyboardInfo *ki)
{
    KdKeyboardInfo **prev;

    if (!ki)
        return;

    for (prev = &kdKeyboards; *prev; prev = &(*prev)->next) {
        if (*prev == ki) {
            *prev = ki->next;
            break;
        }
    }

    KdFreeKeyboard(ki);
}

int
KdAddConfigPointer (char *pointer)
{
    struct KdConfigDevice **prev, *new;

    if (!pointer)
        return Success;

    new = (struct KdConfigDevice *) xcalloc(sizeof(struct KdConfigDevice), 1);
    if (!new)
        return BadAlloc;

    new->line = xstrdup(pointer);
    new->next = NULL;

    for (prev = &kdConfigPointers; *prev; prev = &(*prev)->next);
    *prev = new;

    return Success;
}

int
KdAddPointer (KdPointerInfo *pi)
{
    KdPointerInfo **prev;

    if (!pi)
        return Success;

    pi->mouseState = start;
    pi->eventHeld = FALSE;

    pi->dixdev = AddInputDevice(KdPointerProc, TRUE);
    if (!pi->dixdev) {
        ErrorF("Couldn't add pointer device %s\n",
               pi->name ? pi->name : "(unnamed)");
        return BadDevice;
    }

    RegisterOtherDevice(pi->dixdev);

    for (prev = &kdPointers; *prev; prev = &(*prev)->next);
    *prev = pi;

    return Success;
}

void
KdRemovePointer (KdPointerInfo *pi)
{
    KdPointerInfo **prev;

    if (!pi)
        return;

    for (prev = &kdPointers; *prev; prev = &(*prev)->next) {
        if (*prev == pi) {
            *prev = pi->next;
            break;
        }
    }

    KdFreePointer(pi);
}

/* 
 * You can call your kdriver server with something like:
 * $ ./hw/kdrive/yourserver/X :1 -mouse evdev,,device=/dev/input/event4 -keybd
 * evdev,,device=/dev/input/event1,xkbmodel=abnt2,xkblayout=br 
 */
static Bool 
KdGetOptions (InputOption **options, char *string)
{
    InputOption     *newopt = NULL, **tmpo = NULL;
    int             tam_key = 0;

    newopt = (InputOption *) xalloc(sizeof (InputOption));
    if (!newopt)
        return FALSE;

    bzero(newopt, sizeof (InputOption));

    for (tmpo = options; *tmpo; tmpo = &(*tmpo)->next)
        ; /* Hello, I'm here */ 
    *tmpo = newopt;

    if (strchr(string, '='))
    {
        tam_key = (strchr(string, '=') - string);
        newopt->key = (char *)xalloc(tam_key);
        strncpy(newopt->key, string, tam_key);
        newopt->key[tam_key] = '\0';
        newopt->value = xstrdup(strchr(string, '=') + 1);
    }
    else
    {
        newopt->key = xstrdup(string);
        newopt->value = NULL;
    }
    newopt->next = NULL;

    return TRUE;
}

static void
KdParseKbdOptions (KdKeyboardInfo *ki)
{
    InputOption *option = NULL;

    for (option = ki->options; option; option = option->next)
    {
#ifdef XKB
        if (strcasecmp(option->key, "XkbRules") == 0)
            ki->xkbRules = option->value;
        else if (strcasecmp(option->key, "XkbModel") == 0)
            ki->xkbModel = option->value;
        else if (strcasecmp(option->key, "XkbLayout") == 0)
            ki->xkbLayout = option->value;
        else if (strcasecmp(option->key, "XkbVariant") == 0)
            ki->xkbVariant = option->value;
        else if (strcasecmp(option->key, "XkbOptions") == 0)
            ki->xkbOptions = option->value;
        else if (!strcasecmp (option->key, "device"))
            ki->path = KdSaveString(option->value);
        else
#endif
           ErrorF("Kbd option key (%s) of value (%s) not assigned!\n", 
                    option->key, option->value);
    }
}

KdKeyboardInfo *
KdParseKeyboard (char *arg)
{
    char            save[1024];
    char            delim;
    InputOption     *options = NULL;
    KdKeyboardInfo     *ki = NULL;

    ki = KdNewKeyboard();
    if (!ki)
        return NULL;

    ki->name = strdup("Unknown KDrive Keyboard");
    ki->path = NULL;
    ki->driver = NULL;
    ki->driverPrivate = NULL;
#ifdef XKB
    ki->xkb = NULL;
#endif
    ki->next = NULL;

    if (!arg)
    {
        ErrorF("keybd: no arg\n");
        KdFreeKeyboard (ki);
        return NULL;
    }

    if (strlen (arg) >= sizeof (save))
    {
        ErrorF("keybd: arg too long\n");
        KdFreeKeyboard (ki);
        return NULL;
    }

    arg = KdParseFindNext (arg, ",", save, &delim);
    if (!save[0])
    {
        ErrorF("keybd: failed on save[0]\n");
        KdFreeKeyboard (ki);
        return NULL;
    }

    if (strcmp (save, "auto") == 0)
        ki->driverPrivate = NULL;
    else
        ki->driverPrivate = xstrdup(save);
d490 7
a496 4
    if (delim != ',')
    {
        return ki;
    }
d498 3
a500 3
    arg = KdParseFindNext (arg, ",", save, &delim);

    while (delim == ',')
d502 1
a502 3
        arg = KdParseFindNext (arg, ",", save, &delim);

	if (!KdGetOptions(&options, save)) 
d504 4
a507 3
	    KdFreeKeyboard(ki);
	    return NULL;
        }    
d509 1
d511 32
a542 5
    if (options)
    {
        ki->options = options;
        KdParseKbdOptions(ki);
    }
d544 1
a544 2
    return ki;
}
d547 1
a547 1
KdParsePointerOptions (KdPointerInfo *pi)
d549 5
a553 1
    InputOption *option = NULL;
d555 2
a556 1
    for (option = pi->options; option; option = option->next)
d558 10
a567 13
        if (!strcmp (option->key, "emulatemiddle"))
            pi->emulateMiddleButton = TRUE;
        else if (!strcmp (option->key, "noemulatemiddle"))
            pi->emulateMiddleButton = FALSE;
        else if (!strcmp (option->key, "transformcoord"))
            pi->transformCoordinates = TRUE;
        else if (!strcmp (option->key, "rawcoord"))
            pi->transformCoordinates = FALSE;
        else if (!strcasecmp (option->key, "device"))
            pi->path = KdSaveString(option->value);
        else
            ErrorF("Pointer option key (%s) of value (%s) not assigned!\n", 
                    option->key, option->value);
d571 2
a572 2
KdPointerInfo *
KdParsePointer (char *arg)
d574 2
a575 80
    char            save[1024];
    char            delim;
    KdPointerInfo   *pi = NULL;
    InputOption     *options = NULL;
    int             i = 0;

    pi = KdNewPointer();
    if (!pi)
        return NULL;
    pi->emulateMiddleButton = kdEmulateMiddleButton;
    pi->transformCoordinates = !kdRawPointerCoordinates;
    pi->nButtons = 3;
    pi->inputClass = KD_MOUSE;

    if (!arg)
    {
        ErrorF("mouse: no arg\n");
        KdFreePointer (pi);
        return NULL;
    }

    if (strlen (arg) >= sizeof (save))
    {
        ErrorF("mouse: arg too long\n");
        KdFreePointer (pi);
        return NULL;
    }
    arg = KdParseFindNext (arg, ",", save, &delim);
    if (!save[0])
    {
        ErrorF("failed on save[0]\n");
        KdFreePointer (pi);
        return NULL;
    }

    if (strcmp(save, "auto") == 0)
        pi->driverPrivate = NULL;
    else
        pi->driverPrivate = xstrdup(save);

    if (delim != ',')
    {
        return pi;
    }

    arg = KdParseFindNext (arg, ",", save, &delim);

    while (delim == ',')
    {
        arg = KdParseFindNext (arg, ",", save, &delim);
        if (save[0] == '{')
        {
            char *s = save + 1;
             i = 0;
             while (*s && *s != '}')
             {
                if ('1' <= *s && *s <= '0' + pi->nButtons)
                    pi->map[i] = *s - '0';
                else
                    UseMsg ();
                s++;
             }
        }
        else
        {
            if (!KdGetOptions(&options, save))
            {
                KdFreePointer(pi);
                return NULL;
            }
        }
    }

    if (options)
    {
        pi->options = options;
        KdParsePointerOptions(pi);
    }

    return pi;
a577 1

d579 2
a580 1
KdInitInput (void)
d582 27
a608 4
    KdPointerInfo *pi;
    KdKeyboardInfo *ki;
    struct KdConfigDevice *dev;

d610 18
a627 22

    for (dev = kdConfigPointers; dev; dev = dev->next) {
        pi = KdParsePointer(dev->line);
        if (!pi)
            ErrorF("Failed to parse pointer\n");
        if (KdAddPointer(pi) != Success)
            ErrorF("Failed to add pointer!\n");
    }
    for (dev = kdConfigKeyboards; dev; dev = dev->next) {
        ki = KdParseKeyboard(dev->line);
        if (!ki)
            ErrorF("Failed to parse keyboard\n");
        if (KdAddKeyboard(ki) != Success)
            ErrorF("Failed to add keyboard!\n");
    }

    if (!kdEvents)
        kdEvents = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!kdEvents)
        FatalError("Couldn't allocate event buffer\n");

    mieqInit();
d789 1
a789 1
    KdPointerState nextState;
d934 3
d938 1
a938 1
KdInsideEmulationWindow (KdPointerInfo *pi, int x, int y, int z)
d940 12
a951 5
    pi->emulationDx = pi->heldEvent.x - x;
    pi->emulationDy = pi->heldEvent.y - y;

    return (abs (pi->emulationDx) < EMULATION_WINDOW &&
	    abs (pi->emulationDy) < EMULATION_WINDOW);
d955 1
a955 1
KdClassifyInput (KdPointerInfo *pi, int type, int x, int y, int z, int b)
d957 1
a957 1
    switch (type) {
d959 1
a959 1
	switch (b) {
d967 1
a967 1
	switch (b) {
d975 1
a975 1
	if (pi->eventHeld && !KdInsideEmulationWindow(pi, x, y, z))
d1021 1
a1021 1
KdQueueEvent (DeviceIntPtr pDev, xEvent *ev)
d1024 20
a1043 1
    mieqEnqueue (pDev, ev);
d1046 2
a1047 4
/* We return true if we're stealing the event. */
static Bool
KdRunMouseMachine (KdPointerInfo *pi, KdInputClass c, int type, int x, int y,
                   int z, int b, int absrel)
d1050 1
a1050 1
    int	a;
d1052 1
a1052 2
    c = KdClassifyInput(pi, type, x, y, z, b);
    t = &kdInputMachine[pi->mouseState][c];
d1059 4
a1062 10
	    pi->eventHeld = TRUE;
	    pi->emulationDx = 0;
	    pi->emulationDy = 0;
	    pi->heldEvent.type = type;
            pi->heldEvent.x = x;
            pi->heldEvent.y = y;
            pi->heldEvent.z = z;
            pi->heldEvent.flags = b;
            pi->heldEvent.absrel = absrel;
            return TRUE;
d1065 2
a1066 2
	    pi->emulationTimeout = GetTimeInMillis () + EMULATION_TIMEOUT;
	    pi->timeoutPending = TRUE;
d1069 1
a1069 4
            _KdEnqueuePointerEvent (pi, pi->heldEvent.type, pi->heldEvent.x,
                                    pi->heldEvent.y, pi->heldEvent.z,
                                    pi->heldEvent.flags, pi->heldEvent.absrel,
                                    TRUE);
d1072 3
a1074 7
	    pi->eventHeld = FALSE;
	    pi->timeoutPending = FALSE;
            _KdEnqueuePointerEvent (pi, pi->heldEvent.type, pi->heldEvent.x,
                                    pi->heldEvent.y, pi->heldEvent.z,
                                    pi->heldEvent.flags, pi->heldEvent.absrel,
                                    TRUE);
            return TRUE;
d1077 1
a1077 1
	    pi->timeoutPending = FALSE;
d1080 3
a1082 4
            _KdEnqueuePointerEvent (pi, ButtonPress, x, y, z, 2, absrel,
                                    TRUE);
	    pi->eventHeld = FALSE;
            return TRUE;
d1085 2
a1086 3
            _KdEnqueuePointerEvent (pi, ButtonRelease, x, y, z, 2, absrel,
                                    TRUE);
            return TRUE;
d1090 13
a1102 2
    pi->mouseState = t->nextState;
    return FALSE;
d1105 2
a1106 3
static int
KdHandlePointerEvent (KdPointerInfo *pi, int type, int x, int y, int z, int b,
                      int absrel)
d1108 4
a1111 4
    if (pi->emulateMiddleButton)
        return KdRunMouseMachine (pi, KdClassifyInput(pi, type, x, y, z, b),
                                  type, x, y, z, b, absrel);
    return FALSE;
d1115 1
a1115 1
KdReceiveTimeout (KdPointerInfo *pi)
d1117 1
a1117 1
    KdRunMouseMachine (pi, timeout, 0, 0, 0, 0, 0, 0);
d1120 6
a1125 4
#define KILL_SEQUENCE     ((1L << KK_CONTROL)|(1L << KK_ALT)|(1L << KK_F8)|(1L << KK_F10))
#define SPECIAL_SEQUENCE  ((1L << KK_CONTROL) | (1L << KK_ALT))
#define SETKILLKEY(b)     (KdSpecialKeys |= (1L << (b)))
#define CLEARKILLKEY(b)   (KdSpecialKeys &= ~(1L << (b)))
d1129 5
d1148 1
a1148 1
KdCheckSpecialKeys(KdKeyboardInfo *ki, int type, int sym)
d1150 3
a1152 2
    if (!ki)
        return;
d1157 2
d1160 17
a1176 5
    if (type == KeyRelease)
        return;

    /* Some iPaq keyboard -> mouse button mapping used to be here, but I
     * refuse to perpetuate this madness. -daniels */
d1181 1
a1181 1
    if ((ki->dixdev->key->state & (ControlMask|Mod1Mask)) !=
d1184 2
a1185 1

a1196 2
     *
     * I can't believe it's not XKB. -daniels
d1222 1
a1222 1
KdHandleKeyboardEvent (KdKeyboardInfo *ki, int type, int key)
d1224 4
a1227 3
    int           byte;
    CARD8         bit;
    KdPointerInfo *pi;
d1231 1
a1231 2

    switch (type) {
d1233 1
a1233 1
	ki->keyState[byte] |= bit;
d1236 1
a1236 1
	ki->keyState[byte] &= ~bit;
d1239 3
a1241 3

    for (pi = kdPointers; pi; pi = pi->next)
	KdRunMouseMachine (pi, keyboard, 0, 0, 0, 0, 0, 0);
d1247 2
a1248 2
    int	key, nEvents, i;
    KdKeyboardInfo *ki;
d1251 8
a1258 13

    for (ki = kdKeyboards; ki; ki = ki->next) {
        for (key = ki->keySyms.minKeyCode; key < ki->keySyms.maxKeyCode;
             key++) {
            if (IsKeyDown(ki, key)) {
                KdHandleKeyboardEvent(ki, KeyRelease, key);
                nEvents = GetKeyboardEvents(kdEvents, ki->dixdev, KeyRelease, key);
                for (i = 0; i < nEvents; i++)
                    KdQueueEvent (ki->dixdev, kdEvents + i);
            }
        }
    }

d1265 11
a1275 12
    KeyClassPtr	    keyc = NULL;
    Bool	    isSet = FALSE, shouldBeSet = FALSE;
    KdKeyboardInfo     *tmp = NULL;

    for (tmp = kdKeyboards; tmp; tmp = tmp->next) {
        if (tmp->LockLed && tmp->dixdev && tmp->dixdev->key) {
            keyc = tmp->dixdev->key;
            isSet = (tmp->leds & (1 << (tmp->LockLed-1))) != 0;
            shouldBeSet = (keyc->state & LockMask) != 0;
            if (isSet != shouldBeSet)
                KdSetLed (tmp, tmp->LockLed, shouldBeSet);
        }
d1280 6
a1285 8
KdEnqueueKeyboardEvent(KdKeyboardInfo   *ki,
                       unsigned char scan_code,
		       unsigned char is_up)
{
    unsigned char key_code;
    KeyClassPtr	keyc = NULL;
    KeybdCtrl *ctrl = NULL;
    int type, nEvents, i;
d1287 1
a1287 1
    if (!ki || !ki->dixdev || !ki->dixdev->kbdfeed || !ki->dixdev->key)
d1289 1
d1291 1
a1291 2
    keyc = ki->dixdev->key;
    ctrl = &ki->dixdev->kbdfeed->ctrl;
d1293 1
a1293 1
    if (scan_code >= ki->minScanCode && scan_code <= ki->maxScanCode)
d1295 1
a1295 1
	key_code = scan_code + KD_MIN_KEYCODE - ki->minScanCode;
d1301 1
a1301 1
	    type = KeyRelease;
d1303 2
a1304 1
	    type = KeyPress;
d1306 12
a1317 6
#ifdef XKB
        if (noXkbExtension)
#endif
        {
            KdCheckSpecialKeys(ki, type, key_code);
            KdHandleKeyboardEvent(ki, type, key_code);
d1320 31
a1350 7
        nEvents = GetKeyboardEvents(kdEvents, ki->dixdev, type, key_code);
        for (i = 0; i < nEvents; i++)
            KdQueueEvent(ki->dixdev, kdEvents + i);
    }
    else {
        ErrorF("driver %s wanted to post scancode %d outside of [%d, %d]!\n",
               ki->name, scan_code, ki->minScanCode, ki->maxScanCode);
d1354 10
d1365 1
a1365 1
 * kdEnqueuePointerEvent
d1373 32
a1404 1
/* FIXME do something a little more clever to deal with multiple axes here */
d1406 1
a1406 2
KdEnqueuePointerEvent(KdPointerInfo *pi, unsigned long flags, int rx, int ry,
                      int rz)
d1408 7
a1414 7
    CARD32        ms;
    unsigned char buttons;
    int           x, y, z;
    int           (*matrix)[3] = kdPointerMatrix.matrix;
    unsigned long button;
    int           n;
    int           dixflags;
d1416 1
a1416 1
    if (!pi)
d1420 5
a1424 4

    /* we don't need to transform z, so we don't. */
    if (flags & KD_MOUSE_DELTA) {
	if (pi->transformCoordinates) {
d1428 2
a1429 1
	else {
d1433 2
d1436 6
a1441 4
    else {
	if (pi->transformCoordinates) {
	    x = matrix[0][0] * rx + matrix[0][1] * ry;
	    y = matrix[1][0] * rx + matrix[1][1] * ry;
d1443 2
a1444 1
	else {
d1448 1
d1450 7
a1456 8
    z = rz;

    if (flags & KD_MOUSE_DELTA)
        dixflags = POINTER_RELATIVE & POINTER_ACCELERATE;
    else
        dixflags = POINTER_ABSOLUTE;

    _KdEnqueuePointerEvent(pi, MotionNotify, x, y, z, 0, dixflags, FALSE);
d1460 13
a1472 15
    for (button = KD_BUTTON_1, n = 1; n <= pi->nButtons;
         button <<= 1, n++) {
        if (((pi->buttonState & button) ^ (buttons & button)) &&
           !(buttons & button)) {
            _KdEnqueuePointerEvent(pi, ButtonRelease, x, y, z, n,
                                   dixflags, FALSE);
	}
    }
    for (button = KD_BUTTON_1, n = 1; n <= pi->nButtons;
         button <<= 1, n++) {
	if (((pi->buttonState & button) ^ (buttons & button)) &&
	    (buttons & button)) {
            _KdEnqueuePointerEvent(pi, ButtonPress, x, y, z, n,
                                   dixflags, FALSE);
        }
d1474 1
a1474 2

    pi->buttonState = buttons;
d1478 1
a1478 2
_KdEnqueuePointerEvent (KdPointerInfo *pi, int type, int x, int y, int z,
                        int b, int absrel, Bool force)
d1480 9
a1488 2
    int nEvents = 0, i = 0;
    int valuators[3] = { x, y, z };
d1490 1
a1490 8
    /* TRUE from KdHandlePointerEvent, means 'we swallowed the event'. */
    if (!force && KdHandlePointerEvent(pi, type, x, y, z, b, absrel))
        return;

    nEvents = GetPointerEvents(kdEvents, pi->dixdev, type, b, absrel, 0, 3,
                               valuators);
    for (i = 0; i < nEvents; i++)
        KdQueueEvent(pi->dixdev, kdEvents + i);
d1499 1
a1499 1
    KdPointerInfo		    *pi;
d1502 1
a1502 1
    for (pi = kdPointers; pi; pi = pi->next)
d1504 1
a1504 1
	if (pi->timeoutPending)
d1508 1
a1508 1
	    ms = pi->emulationTimeout - GetTimeInMillis ();
d1534 1
a1534 1
    KdPointerInfo	*pi;
d1546 1
a1546 1
    for (pi = kdPointers; pi; pi = pi->next)
d1548 1
a1548 1
	if (pi->timeoutPending)
d1550 1
a1550 1
	    if ((long) (GetTimeInMillis () - pi->emulationTimeout) >= 0)
d1552 1
a1552 1
		pi->timeoutPending = FALSE;
d1554 1
a1554 1
		KdReceiveTimeout (pi);
a1687 157
}

/* FIXME use XSECURITY to work out whether the client should be allowed to
 * open and close. */
void
OpenInputDevice(DeviceIntPtr pDev, ClientPtr client, int *status)
{
    if (!pDev)
        *status = BadDevice;
    else
        *status = Success;
}

void
CloseInputDevice(DeviceIntPtr pDev, ClientPtr client)
{
    return;
}

/* We initialise all input devices at startup. */
void
AddOtherInputDevices(void)
{
    return;
}

/* At the moment, absolute/relative is up to the client. */
int
SetDeviceMode(register ClientPtr client, DeviceIntPtr pDev, int mode)
{
    return BadMatch;
}

int
SetDeviceValuators(register ClientPtr client, DeviceIntPtr pDev,
                   int *valuators, int first_valuator, int num_valuators)
{
    return BadMatch;
}

int
ChangeDeviceControl(register ClientPtr client, DeviceIntPtr pDev,
                        xDeviceCtl *control)
{
    switch (control->control) {
    case DEVICE_RESOLUTION:
        /* FIXME do something more intelligent here */
        return BadMatch;

    case DEVICE_ABS_CALIB:
    case DEVICE_ABS_AREA:
        return Success;

    case DEVICE_CORE:
    case DEVICE_ENABLE:
        return Success;

    default:
        return BadMatch;
    }

    /* NOTREACHED */
    return BadImplementation;
}

int
NewInputDeviceRequest(InputOption *options, DeviceIntPtr *pdev)
{
    InputOption *option = NULL;
    KdPointerInfo *pi = NULL;
    KdKeyboardInfo *ki = NULL;

    for (option = options; option; option = option->next) {
        if (strcmp(option->key, "type") == 0) {
            if (strcmp(option->value, "pointer") == 0) {
                pi = KdNewPointer();
                if (!pi)
                    return BadAlloc;
            }
            else if (strcmp(option->value, "keyboard") == 0) {
                ki = KdNewKeyboard();
                if (!ki)
                    return BadAlloc;
            }
            else {
                ErrorF("unrecognised device type!\n");
                return BadValue;
            }
        }
    }

    if (!ki && !pi) {
        ErrorF("unrecognised device identifier!\n");
        return BadValue;
    }

    /* FIXME: change this code below to use KdParseKbdOptions and
     * KdParsePointerOptions */
    for (option = options; option; option = option->next) {
        if (strcmp(option->key, "device") == 0) {
            if (pi && option->value)
                pi->path = KdSaveString(option->value);
            else if (ki && option->value)
                ki->path = KdSaveString(option->value);
        }
        else if (strcmp(option->key, "driver") == 0) {
            if (pi) {
                pi->driver = KdFindPointerDriver(option->value);
                if (!pi->driver) {
                    ErrorF("couldn't find driver!\n");
                    KdFreePointer(pi);
                    return BadValue;
                }
                pi->options = options;
            }
            else if (ki) {
                ki->driver = KdFindKeyboardDriver(option->value);
                if (!ki->driver) {
                    ErrorF("couldn't find driver!\n");
                    KdFreeKeyboard(ki);
                    return BadValue;
                }
                ki->options = options;
            }
        }
    }

    if (pi) {
        if (KdAddPointer(pi) != Success ||
            ActivateDevice(pi->dixdev) != Success ||
            EnableDevice(pi->dixdev) != TRUE) {
            ErrorF("couldn't add or enable pointer\n");
            return BadImplementation;
        }
    }
    else if (ki) {
        if (KdAddKeyboard(ki) != Success ||
            ActivateDevice(ki->dixdev) != Success ||
            EnableDevice(ki->dixdev) != TRUE) {
            ErrorF("couldn't add or enable keyboard\n");
            return BadImplementation;
        }
    }

    if (pi) {
        *pdev = pi->dixdev;
    } else if(ki) {
        *pdev = ki->dixdev;
    }

    return Success;
}

void
DeleteInputDeviceRequest(DeviceIntPtr pDev)
{
    RemoveDevice(pDev);
@

