head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 1998-2001 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#if defined(_XOPEN_SOURCE) || defined(sun) && defined(__SVR4)
#include <math.h>
#else
#define _XOPEN_SOURCE           /* to get prototype for pow on some systems */
#include <math.h>
#undef _XOPEN_SOURCE
#endif

#include <X11/X.h>
#include "misc.h"
#include <X11/Xproto.h>
#include "colormapst.h"
#include "scrnintstr.h"

#include "resource.h"

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86str.h"
#include "micmap.h"
#include "xf86Crtc.h"

#ifdef XFreeXDGA
#include <X11/extensions/xf86dgaproto.h>
#include "dgaproc.h"
#endif

#include "xf86cmap.h"

#define SCREEN_PROLOGUE(pScreen, field) ((pScreen)->field = \
    ((CMapScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, CMapScreenKey))->field)
#define SCREEN_EPILOGUE(pScreen, field, wrapper)\
    ((pScreen)->field = wrapper)

#define LOAD_PALETTE(pmap) \
    ((pmap == GetInstalledmiColormap(pmap->pScreen)) && \
     ((pScreenPriv->flags & CMAP_LOAD_EVEN_IF_OFFSCREEN) || \
      xf86ScreenToScrn(pmap->pScreen)->vtSema || pScreenPriv->isDGAmode))

typedef struct _CMapLink {
    ColormapPtr cmap;
    struct _CMapLink *next;
} CMapLink, *CMapLinkPtr;

typedef struct {
    CloseScreenProcPtr CloseScreen;
    CreateColormapProcPtr CreateColormap;
    DestroyColormapProcPtr DestroyColormap;
    InstallColormapProcPtr InstallColormap;
    StoreColorsProcPtr StoreColors;
    Bool (*EnterVT) (ScrnInfoPtr);
    Bool (*SwitchMode) (ScrnInfoPtr, DisplayModePtr);
    int (*SetDGAMode) (ScrnInfoPtr, int, DGADevicePtr);
    xf86ChangeGammaProc *ChangeGamma;
    int maxColors;
    int sigRGBbits;
    int gammaElements;
    LOCO *gamma;
    int *PreAllocIndices;
    CMapLinkPtr maps;
    unsigned int flags;
    Bool isDGAmode;
} CMapScreenRec, *CMapScreenPtr;

typedef struct {
    int numColors;
    LOCO *colors;
    Bool recalculate;
    int overscan;
} CMapColormapRec, *CMapColormapPtr;

static DevPrivateKeyRec CMapScreenKeyRec;

#define CMapScreenKeyRegistered dixPrivateKeyRegistered(&CMapScreenKeyRec)
#define CMapScreenKey (&CMapScreenKeyRec)
static DevPrivateKeyRec CMapColormapKeyRec;

#define CMapColormapKey (&CMapColormapKeyRec)

static void CMapInstallColormap(ColormapPtr);
static void CMapStoreColors(ColormapPtr, int, xColorItem *);
static Bool CMapCloseScreen(ScreenPtr);
static Bool CMapCreateColormap(ColormapPtr);
static void CMapDestroyColormap(ColormapPtr);

static Bool CMapEnterVT(ScrnInfoPtr);
static Bool CMapSwitchMode(ScrnInfoPtr, DisplayModePtr);

#ifdef XFreeXDGA
static int CMapSetDGAMode(ScrnInfoPtr, int, DGADevicePtr);
#endif
static int CMapChangeGamma(ScrnInfoPtr, Gamma);

static void ComputeGamma(ScrnInfoPtr, CMapScreenPtr);
static Bool CMapAllocateColormapPrivate(ColormapPtr);
static void CMapRefreshColors(ColormapPtr, int, int *);
static void CMapSetOverscan(ColormapPtr, int, int *);
static void CMapReinstallMap(ColormapPtr);
static void CMapUnwrapScreen(ScreenPtr pScreen);

Bool
xf86ColormapAllocatePrivates(ScrnInfoPtr pScrn)
{
    /* If we support a better colormap system, then pretend we succeeded. */
    if (xf86_crtc_supports_gamma(pScrn))
        return TRUE;
    if (!dixRegisterPrivateKey(&CMapScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!dixRegisterPrivateKey(&CMapColormapKeyRec, PRIVATE_COLORMAP, 0))
        return FALSE;
    return TRUE;
}

Bool
xf86HandleColormaps(ScreenPtr pScreen,
                    int maxColors,
                    int sigRGBbits,
                    xf86LoadPaletteProc * loadPalette,
                    xf86SetOverscanProc * setOverscan, unsigned int flags)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ColormapPtr pDefMap = NULL;
    CMapScreenPtr pScreenPriv;
    LOCO *gamma;
    int *indices;
    int elements;

    /* If we support a better colormap system, then pretend we succeeded. */
    if (xf86_crtc_supports_gamma(pScrn))
        return TRUE;

    if (!maxColors || !sigRGBbits || !loadPalette)
        return FALSE;

    elements = 1 << sigRGBbits;

    if (!(gamma = xallocarray(elements, sizeof(LOCO))))
        return FALSE;

    if (!(indices = xallocarray(maxColors, sizeof(int)))) {
        free(gamma);
        return FALSE;
    }

    if (!(pScreenPriv = malloc(sizeof(CMapScreenRec)))) {
        free(gamma);
        free(indices);
        return FALSE;
    }

    dixSetPrivate(&pScreen->devPrivates, &CMapScreenKeyRec, pScreenPriv);

    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreenPriv->CreateColormap = pScreen->CreateColormap;
    pScreenPriv->DestroyColormap = pScreen->DestroyColormap;
    pScreenPriv->InstallColormap = pScreen->InstallColormap;
    pScreenPriv->StoreColors = pScreen->StoreColors;
    pScreen->CloseScreen = CMapCloseScreen;
    pScreen->CreateColormap = CMapCreateColormap;
    pScreen->DestroyColormap = CMapDestroyColormap;
    pScreen->InstallColormap = CMapInstallColormap;
    pScreen->StoreColors = CMapStoreColors;

    pScrn->LoadPalette = loadPalette;
    pScrn->SetOverscan = setOverscan;
    pScreenPriv->maxColors = maxColors;
    pScreenPriv->sigRGBbits = sigRGBbits;
    pScreenPriv->gammaElements = elements;
    pScreenPriv->gamma = gamma;
    pScreenPriv->PreAllocIndices = indices;
    pScreenPriv->maps = NULL;
    pScreenPriv->flags = flags;
    pScreenPriv->isDGAmode = FALSE;

    pScreenPriv->EnterVT = pScrn->EnterVT;
    pScreenPriv->SwitchMode = pScrn->SwitchMode;
    pScreenPriv->SetDGAMode = pScrn->SetDGAMode;
    pScreenPriv->ChangeGamma = pScrn->ChangeGamma;

    if (!(flags & CMAP_LOAD_EVEN_IF_OFFSCREEN)) {
        pScrn->EnterVT = CMapEnterVT;
        if ((flags & CMAP_RELOAD_ON_MODE_SWITCH) && pScrn->SwitchMode)
            pScrn->SwitchMode = CMapSwitchMode;
    }
#ifdef XFreeXDGA
    pScrn->SetDGAMode = CMapSetDGAMode;
#endif
    pScrn->ChangeGamma = CMapChangeGamma;

    ComputeGamma(pScrn, pScreenPriv);

    /* get the default map */
    dixLookupResourceByType((void **) &pDefMap, pScreen->defColormap,
                            RT_COLORMAP, serverClient, DixInstallAccess);

    if (!CMapAllocateColormapPrivate(pDefMap)) {
        CMapUnwrapScreen(pScreen);
        return FALSE;
    }

    /* Force the initial map to be loaded */
    SetInstalledmiColormap(pScreen, NULL);
    CMapInstallColormap(pDefMap);
    return TRUE;
}

/**** Screen functions ****/

static Bool
CMapCloseScreen(ScreenPtr pScreen)
{
    CMapUnwrapScreen(pScreen);

    return (*pScreen->CloseScreen) (pScreen);
}

static Bool
CMapColormapUseMax(VisualPtr pVisual, CMapScreenPtr pScreenPriv)
{
    if (pVisual->nplanes > 16)
        return TRUE;
    return ((1 << pVisual->nplanes) > pScreenPriv->maxColors);
}

static Bool
CMapAllocateColormapPrivate(ColormapPtr pmap)
{
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pmap->pScreen->devPrivates,
                                         CMapScreenKey);
    CMapColormapPtr pColPriv;
    CMapLinkPtr pLink;
    int numColors;
    LOCO *colors;

    if (CMapColormapUseMax(pmap->pVisual, pScreenPriv))
        numColors = pmap->pVisual->ColormapEntries;
    else
        numColors = 1 << pmap->pVisual->nplanes;

    if (!(colors = xallocarray(numColors, sizeof(LOCO))))
        return FALSE;

    if (!(pColPriv = malloc(sizeof(CMapColormapRec)))) {
        free(colors);
        return FALSE;
    }

    dixSetPrivate(&pmap->devPrivates, CMapColormapKey, pColPriv);

    pColPriv->numColors = numColors;
    pColPriv->colors = colors;
    pColPriv->recalculate = TRUE;
    pColPriv->overscan = -1;

    /* add map to list */
    pLink = malloc(sizeof(CMapLink));
    if (pLink) {
        pLink->cmap = pmap;
        pLink->next = pScreenPriv->maps;
        pScreenPriv->maps = pLink;
    }

    return TRUE;
}

static Bool
CMapCreateColormap(ColormapPtr pmap)
{
    ScreenPtr pScreen = pmap->pScreen;
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);
    Bool ret = FALSE;

    pScreen->CreateColormap = pScreenPriv->CreateColormap;
    if ((*pScreen->CreateColormap) (pmap)) {
        if (CMapAllocateColormapPrivate(pmap))
            ret = TRUE;
    }
    pScreen->CreateColormap = CMapCreateColormap;

    return ret;
}

static void
CMapDestroyColormap(ColormapPtr cmap)
{
    ScreenPtr pScreen = cmap->pScreen;
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);
    CMapColormapPtr pColPriv =
        (CMapColormapPtr) dixLookupPrivate(&cmap->devPrivates, CMapColormapKey);
    CMapLinkPtr prevLink = NULL, pLink = pScreenPriv->maps;

    if (pColPriv) {
        free(pColPriv->colors);
        free(pColPriv);
    }

    /* remove map from list */
    while (pLink) {
        if (pLink->cmap == cmap) {
            if (prevLink)
                prevLink->next = pLink->next;
            else
                pScreenPriv->maps = pLink->next;
            free(pLink);
            break;
        }
        prevLink = pLink;
        pLink = pLink->next;
    }

    if (pScreenPriv->DestroyColormap) {
        pScreen->DestroyColormap = pScreenPriv->DestroyColormap;
        (*pScreen->DestroyColormap) (cmap);
        pScreen->DestroyColormap = CMapDestroyColormap;
    }
}

static void
CMapStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs)
{
    ScreenPtr pScreen = pmap->pScreen;
    VisualPtr pVisual = pmap->pVisual;
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);
    int *indices = pScreenPriv->PreAllocIndices;
    int num = ndef;

    /* At the moment this isn't necessary since there's nobody below us */
    pScreen->StoreColors = pScreenPriv->StoreColors;
    (*pScreen->StoreColors) (pmap, ndef, pdefs);
    pScreen->StoreColors = CMapStoreColors;

    /* should never get here for these */
    if ((pVisual->class == TrueColor) ||
        (pVisual->class == StaticColor) || (pVisual->class == StaticGray))
        return;

    if (pVisual->class == DirectColor) {
        CMapColormapPtr pColPriv =
            (CMapColormapPtr) dixLookupPrivate(&pmap->devPrivates,
                                               CMapColormapKey);
        int i;

        if (CMapColormapUseMax(pVisual, pScreenPriv)) {
            int index;

            num = 0;
            while (ndef--) {
                if (pdefs[ndef].flags & DoRed) {
                    index = (pdefs[ndef].pixel & pVisual->redMask) >>
                        pVisual->offsetRed;
                    i = num;
                    while (i--)
                        if (indices[i] == index)
                            break;
                    if (i == -1)
                        indices[num++] = index;
                }
                if (pdefs[ndef].flags & DoGreen) {
                    index = (pdefs[ndef].pixel & pVisual->greenMask) >>
                        pVisual->offsetGreen;
                    i = num;
                    while (i--)
                        if (indices[i] == index)
                            break;
                    if (i == -1)
                        indices[num++] = index;
                }
                if (pdefs[ndef].flags & DoBlue) {
                    index = (pdefs[ndef].pixel & pVisual->blueMask) >>
                        pVisual->offsetBlue;
                    i = num;
                    while (i--)
                        if (indices[i] == index)
                            break;
                    if (i == -1)
                        indices[num++] = index;
                }
            }

        }
        else {
            /* not really as overkill as it seems */
            num = pColPriv->numColors;
            for (i = 0; i < pColPriv->numColors; i++)
                indices[i] = i;
        }
    }
    else {
        while (ndef--)
            indices[ndef] = pdefs[ndef].pixel;
    }

    CMapRefreshColors(pmap, num, indices);
}

static void
CMapInstallColormap(ColormapPtr pmap)
{
    ScreenPtr pScreen = pmap->pScreen;
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);

    if (pmap == GetInstalledmiColormap(pmap->pScreen))
        return;

    pScreen->InstallColormap = pScreenPriv->InstallColormap;
    (*pScreen->InstallColormap) (pmap);
    pScreen->InstallColormap = CMapInstallColormap;

    /* Important. We let the lower layers, namely DGA,
       overwrite the choice of Colormap to install */
    if (GetInstalledmiColormap(pmap->pScreen))
        pmap = GetInstalledmiColormap(pmap->pScreen);

    if (!(pScreenPriv->flags & CMAP_PALETTED_TRUECOLOR) &&
        (pmap->pVisual->class == TrueColor) &&
        CMapColormapUseMax(pmap->pVisual, pScreenPriv))
        return;

    if (LOAD_PALETTE(pmap))
        CMapReinstallMap(pmap);
}

/**** ScrnInfoRec functions ****/

static Bool
CMapEnterVT(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    Bool ret;
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);

    pScrn->EnterVT = pScreenPriv->EnterVT;
    ret = (*pScreenPriv->EnterVT) (pScrn);
    pScreenPriv->EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = CMapEnterVT;
    if (ret) {
        if (GetInstalledmiColormap(pScreen))
            CMapReinstallMap(GetInstalledmiColormap(pScreen));
        return TRUE;
    }
    return FALSE;
}

static Bool
CMapSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);

    if ((*pScreenPriv->SwitchMode) (pScrn, mode)) {
        if (GetInstalledmiColormap(pScreen))
            CMapReinstallMap(GetInstalledmiColormap(pScreen));
        return TRUE;
    }
    return FALSE;
}

#ifdef XFreeXDGA
static int
CMapSetDGAMode(ScrnInfoPtr pScrn, int num, DGADevicePtr dev)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);
    int ret;

    ret = (*pScreenPriv->SetDGAMode) (pScrn, num, dev);

    pScreenPriv->isDGAmode = DGAActive(pScrn->scrnIndex);

    if (!pScreenPriv->isDGAmode && GetInstalledmiColormap(pScreen)
        && xf86ScreenToScrn(pScreen)->vtSema)
        CMapReinstallMap(GetInstalledmiColormap(pScreen));

    return ret;
}
#endif

/**** Utilities ****/

static void
CMapReinstallMap(ColormapPtr pmap)
{
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pmap->pScreen->devPrivates,
                                         CMapScreenKey);
    CMapColormapPtr cmapPriv =
        (CMapColormapPtr) dixLookupPrivate(&pmap->devPrivates, CMapColormapKey);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pmap->pScreen);
    int i = cmapPriv->numColors;
    int *indices = pScreenPriv->PreAllocIndices;

    while (i--)
        indices[i] = i;

    if (cmapPriv->recalculate)
        CMapRefreshColors(pmap, cmapPriv->numColors, indices);
    else {
        (*pScrn->LoadPalette) (pScrn, cmapPriv->numColors,
                               indices, cmapPriv->colors, pmap->pVisual);
        if (pScrn->SetOverscan) {
#ifdef DEBUGOVERSCAN
            ErrorF("SetOverscan() called from CMapReinstallMap\n");
#endif
            pScrn->SetOverscan(pScrn, cmapPriv->overscan);
        }
    }

    cmapPriv->recalculate = FALSE;
}

static void
CMapRefreshColors(ColormapPtr pmap, int defs, int *indices)
{
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pmap->pScreen->devPrivates,
                                         CMapScreenKey);
    CMapColormapPtr pColPriv =
        (CMapColormapPtr) dixLookupPrivate(&pmap->devPrivates, CMapColormapKey);
    VisualPtr pVisual = pmap->pVisual;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pmap->pScreen);
    int numColors, i;
    LOCO *gamma, *colors;
    EntryPtr entry;
    int reds, greens, blues, maxValue, index, shift;

    numColors = pColPriv->numColors;
    shift = 16 - pScreenPriv->sigRGBbits;
    maxValue = (1 << pScreenPriv->sigRGBbits) - 1;
    gamma = pScreenPriv->gamma;
    colors = pColPriv->colors;

    reds = pVisual->redMask >> pVisual->offsetRed;
    greens = pVisual->greenMask >> pVisual->offsetGreen;
    blues = pVisual->blueMask >> pVisual->offsetBlue;

    switch (pVisual->class) {
    case StaticGray:
        for (i = 0; i < numColors; i++) {
            index = (i + 1) * maxValue / numColors;
            colors[i].red = gamma[index].red;
            colors[i].green = gamma[index].green;
            colors[i].blue = gamma[index].blue;
        }
        break;
    case TrueColor:
        if (CMapColormapUseMax(pVisual, pScreenPriv)) {
            for (i = 0; i <= reds; i++)
                colors[i].red = gamma[i * maxValue / reds].red;
            for (i = 0; i <= greens; i++)
                colors[i].green = gamma[i * maxValue / greens].green;
            for (i = 0; i <= blues; i++)
                colors[i].blue = gamma[i * maxValue / blues].blue;
            break;
        }
        for (i = 0; i < numColors; i++) {
            colors[i].red = gamma[((i >> pVisual->offsetRed) & reds) *
                                  maxValue / reds].red;
            colors[i].green = gamma[((i >> pVisual->offsetGreen) & greens) *
                                    maxValue / greens].green;
            colors[i].blue = gamma[((i >> pVisual->offsetBlue) & blues) *
                                   maxValue / blues].blue;
        }
        break;
    case StaticColor:
    case PseudoColor:
    case GrayScale:
        for (i = 0; i < defs; i++) {
            index = indices[i];
            entry = (EntryPtr) &pmap->red[index];

            if (entry->fShared) {
                colors[index].red =
                    gamma[entry->co.shco.red->color >> shift].red;
                colors[index].green =
                    gamma[entry->co.shco.green->color >> shift].green;
                colors[index].blue =
                    gamma[entry->co.shco.blue->color >> shift].blue;
            }
            else {
                colors[index].red = gamma[entry->co.local.red >> shift].red;
                colors[index].green =
                    gamma[entry->co.local.green >> shift].green;
                colors[index].blue = gamma[entry->co.local.blue >> shift].blue;
            }
        }
        break;
    case DirectColor:
        if (CMapColormapUseMax(pVisual, pScreenPriv)) {
            for (i = 0; i < defs; i++) {
                index = indices[i];
                if (index <= reds)
                    colors[index].red =
                        gamma[pmap->red[index].co.local.red >> shift].red;
                if (index <= greens)
                    colors[index].green =
                        gamma[pmap->green[index].co.local.green >> shift].green;
                if (index <= blues)
                    colors[index].blue =
                        gamma[pmap->blue[index].co.local.blue >> shift].blue;

            }
            break;
        }
        for (i = 0; i < defs; i++) {
            index = indices[i];

            colors[index].red = gamma[pmap->red[(index >> pVisual->
                                                 offsetRed) & reds].co.local.
                                      red >> shift].red;
            colors[index].green =
                gamma[pmap->green[(index >> pVisual->offsetGreen) & greens].co.
                      local.green >> shift].green;
            colors[index].blue =
                gamma[pmap->blue[(index >> pVisual->offsetBlue) & blues].co.
                      local.blue >> shift].blue;
        }
        break;
    }

    if (LOAD_PALETTE(pmap))
        (*pScrn->LoadPalette) (pScrn, defs, indices, colors, pmap->pVisual);

    if (pScrn->SetOverscan)
        CMapSetOverscan(pmap, defs, indices);

}

static Bool
CMapCompareColors(LOCO * color1, LOCO * color2)
{
    /* return TRUE if the color1 is "closer" to black than color2 */
#ifdef DEBUGOVERSCAN
    ErrorF("#%02x%02x%02x vs #%02x%02x%02x (%d vs %d)\n",
           color1->red, color1->green, color1->blue,
           color2->red, color2->green, color2->blue,
           color1->red + color1->green + color1->blue,
           color2->red + color2->green + color2->blue);
#endif
    return (color1->red + color1->green + color1->blue <
            color2->red + color2->green + color2->blue);
}

static void
CMapSetOverscan(ColormapPtr pmap, int defs, int *indices)
{
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pmap->pScreen->devPrivates,
                                         CMapScreenKey);
    CMapColormapPtr pColPriv =
        (CMapColormapPtr) dixLookupPrivate(&pmap->devPrivates, CMapColormapKey);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pmap->pScreen);
    VisualPtr pVisual = pmap->pVisual;
    int i;
    LOCO *colors;
    int index;
    Bool newOverscan = FALSE;
    int overscan, tmpOverscan;

    colors = pColPriv->colors;
    overscan = pColPriv->overscan;

    /*
     * Search for a new overscan index in the following cases:
     *
     *   - The index hasn't yet been initialised.Â  In this case search
     *     for an index that is black or a close match to black.
     *
     *   - The colour of the old index is changed.  In this case search
     *     all indices for a black or close match to black.
     *
     *   - The colour of the old index wasn't black.  In this case only
     *     search the indices that were changed for a better match to black.
     */

    switch (pVisual->class) {
    case StaticGray:
    case TrueColor:
        /* Should only come here once.  Initialise the overscan index to 0 */
        overscan = 0;
        newOverscan = TRUE;
        break;
    case StaticColor:
        /*
         * Only come here once, but search for the overscan in the same way
         * as for the other cases.
         */
    case DirectColor:
    case PseudoColor:
    case GrayScale:
        if (overscan < 0 || overscan > pScreenPriv->maxColors - 1) {
            /* Uninitialised */
            newOverscan = TRUE;
        }
        else {
            /* Check if the overscan was changed */
            for (i = 0; i < defs; i++) {
                index = indices[i];
                if (index == overscan) {
                    newOverscan = TRUE;
                    break;
                }
            }
        }
        if (newOverscan) {
            /* The overscan is either uninitialised or it has been changed */

            if (overscan < 0 || overscan > pScreenPriv->maxColors - 1)
                tmpOverscan = pScreenPriv->maxColors - 1;
            else
                tmpOverscan = overscan;

            /* search all entries for a close match to black */
            for (i = pScreenPriv->maxColors - 1; i >= 0; i--) {
                if (colors[i].red == 0 && colors[i].green == 0 &&
                    colors[i].blue == 0) {
                    overscan = i;
#ifdef DEBUGOVERSCAN
                    ErrorF("Black found at index 0x%02x\n", i);
#endif
                    break;
                }
                else {
#ifdef DEBUGOVERSCAN
                    ErrorF("0x%02x: ", i);
#endif
                    if (CMapCompareColors(&colors[i], &colors[tmpOverscan])) {
                        tmpOverscan = i;
#ifdef DEBUGOVERSCAN
                        ErrorF("possible \"Black\" at index 0x%02x\n", i);
#endif
                    }
                }
            }
            if (i < 0)
                overscan = tmpOverscan;
        }
        else {
            /* Check of the old overscan wasn't black */
            if (colors[overscan].red != 0 || colors[overscan].green != 0 ||
                colors[overscan].blue != 0) {
                int oldOverscan = tmpOverscan = overscan;

                /* See of there is now a better match */
                for (i = 0; i < defs; i++) {
                    index = indices[i];
                    if (colors[index].red == 0 && colors[index].green == 0 &&
                        colors[index].blue == 0) {
                        overscan = index;
#ifdef DEBUGOVERSCAN
                        ErrorF("Black found at index 0x%02x\n", index);
#endif
                        break;
                    }
                    else {
#ifdef DEBUGOVERSCAN
                        ErrorF("0x%02x: ", index);
#endif
                        if (CMapCompareColors(&colors[index],
                                              &colors[tmpOverscan])) {
                            tmpOverscan = index;
#ifdef DEBUGOVERSCAN
                            ErrorF("possible \"Black\" at index 0x%02x\n",
                                   index);
#endif
                        }
                    }
                }
                if (i == defs)
                    overscan = tmpOverscan;
                if (overscan != oldOverscan)
                    newOverscan = TRUE;
            }
        }
        break;
    }
    if (newOverscan) {
        pColPriv->overscan = overscan;
        if (LOAD_PALETTE(pmap)) {
#ifdef DEBUGOVERSCAN
            ErrorF("SetOverscan() called from CmapSetOverscan\n");
#endif
            pScrn->SetOverscan(pScrn, overscan);
        }
    }
}

static void
CMapUnwrapScreen(ScreenPtr pScreen)
{
    CMapScreenPtr pScreenPriv =
        (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates, CMapScreenKey);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->CreateColormap = pScreenPriv->CreateColormap;
    pScreen->DestroyColormap = pScreenPriv->DestroyColormap;
    pScreen->InstallColormap = pScreenPriv->InstallColormap;
    pScreen->StoreColors = pScreenPriv->StoreColors;

    pScrn->EnterVT = pScreenPriv->EnterVT;
    pScrn->SwitchMode = pScreenPriv->SwitchMode;
    pScrn->SetDGAMode = pScreenPriv->SetDGAMode;
    pScrn->ChangeGamma = pScreenPriv->ChangeGamma;

    free(pScreenPriv->gamma);
    free(pScreenPriv->PreAllocIndices);
    free(pScreenPriv);
}

static void
ComputeGamma(ScrnInfoPtr pScrn, CMapScreenPtr priv)
{
    int elements = priv->gammaElements - 1;
    double RedGamma, GreenGamma, BlueGamma;
    int i;

#ifndef DONT_CHECK_GAMMA
    /* This check is to catch drivers that are not initialising pScrn->gamma */
    if (pScrn->gamma.red < GAMMA_MIN || pScrn->gamma.red > GAMMA_MAX ||
        pScrn->gamma.green < GAMMA_MIN || pScrn->gamma.green > GAMMA_MAX ||
        pScrn->gamma.blue < GAMMA_MIN || pScrn->gamma.blue > GAMMA_MAX) {

        xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 0,
                       "The %s driver didn't call xf86SetGamma() to initialise\n"
                       "\tthe gamma values.\n", pScrn->driverName);
        xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 0,
                       "PLEASE FIX THE `%s' DRIVER!\n",
                       pScrn->driverName);
        pScrn->gamma.red = 1.0;
        pScrn->gamma.green = 1.0;
        pScrn->gamma.blue = 1.0;
    }
#endif

    RedGamma = 1.0 / (double) pScrn->gamma.red;
    GreenGamma = 1.0 / (double) pScrn->gamma.green;
    BlueGamma = 1.0 / (double) pScrn->gamma.blue;

    for (i = 0; i <= elements; i++) {
        if (RedGamma == 1.0)
            priv->gamma[i].red = i;
        else
            priv->gamma[i].red = (CARD16) (pow((double) i / (double) elements,
                                               RedGamma) * (double) elements +
                                           0.5);

        if (GreenGamma == 1.0)
            priv->gamma[i].green = i;
        else
            priv->gamma[i].green = (CARD16) (pow((double) i / (double) elements,
                                                 GreenGamma) *
                                             (double) elements + 0.5);

        if (BlueGamma == 1.0)
            priv->gamma[i].blue = i;
        else
            priv->gamma[i].blue = (CARD16) (pow((double) i / (double) elements,
                                                BlueGamma) * (double) elements +
                                            0.5);
    }
}

int
CMapChangeGamma(ScrnInfoPtr pScrn, Gamma gamma)
{
    int ret = Success;
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    CMapColormapPtr pColPriv;
    CMapScreenPtr pScreenPriv;
    CMapLinkPtr pLink;

    /* Is this sufficient checking ? */
    if (!CMapScreenKeyRegistered)
        return BadImplementation;

    pScreenPriv = (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                   CMapScreenKey);
    if (!pScreenPriv)
        return BadImplementation;

    if (gamma.red < GAMMA_MIN || gamma.red > GAMMA_MAX ||
        gamma.green < GAMMA_MIN || gamma.green > GAMMA_MAX ||
        gamma.blue < GAMMA_MIN || gamma.blue > GAMMA_MAX)
        return BadValue;

    pScrn->gamma.red = gamma.red;
    pScrn->gamma.green = gamma.green;
    pScrn->gamma.blue = gamma.blue;

    ComputeGamma(pScrn, pScreenPriv);

    /* mark all colormaps on this screen */
    pLink = pScreenPriv->maps;
    while (pLink) {
        pColPriv = (CMapColormapPtr) dixLookupPrivate(&pLink->cmap->devPrivates,
                                                      CMapColormapKey);
        pColPriv->recalculate = TRUE;
        pLink = pLink->next;
    }

    if (GetInstalledmiColormap(pScreen) &&
        ((pScreenPriv->flags & CMAP_LOAD_EVEN_IF_OFFSCREEN) ||
         pScrn->vtSema || pScreenPriv->isDGAmode)) {
        ColormapPtr pMap = GetInstalledmiColormap(pScreen);

        if (!(pScreenPriv->flags & CMAP_PALETTED_TRUECOLOR) &&
            (pMap->pVisual->class == TrueColor) &&
            CMapColormapUseMax(pMap->pVisual, pScreenPriv)) {

            /* if the current map doesn't have a palette look
               for another map to change the gamma on. */

            pLink = pScreenPriv->maps;
            while (pLink) {
                if (pLink->cmap->pVisual->class == PseudoColor)
                    break;
                pLink = pLink->next;
            }

            if (pLink) {
                /* need to trick CMapRefreshColors() into thinking
                   this is the currently installed map */
                SetInstalledmiColormap(pScreen, pLink->cmap);
                CMapReinstallMap(pLink->cmap);
                SetInstalledmiColormap(pScreen, pMap);
            }
        }
        else
            CMapReinstallMap(pMap);
    }

    pScrn->ChangeGamma = pScreenPriv->ChangeGamma;
    if (pScrn->ChangeGamma)
        ret = pScrn->ChangeGamma(pScrn, gamma);
    pScrn->ChangeGamma = CMapChangeGamma;

    return ret;
}

static void
ComputeGammaRamp(CMapScreenPtr priv,
                 unsigned short *red,
                 unsigned short *green, unsigned short *blue)
{
    int elements = priv->gammaElements;
    LOCO *entry = priv->gamma;
    int shift = 16 - priv->sigRGBbits;

    while (elements--) {
        entry->red = *(red++) >> shift;
        entry->green = *(green++) >> shift;
        entry->blue = *(blue++) >> shift;
        entry++;
    }
}

int
xf86ChangeGammaRamp(ScreenPtr pScreen,
                    int size,
                    unsigned short *red,
                    unsigned short *green, unsigned short *blue)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    CMapColormapPtr pColPriv;
    CMapScreenPtr pScreenPriv;
    CMapLinkPtr pLink;

    if (xf86_crtc_supports_gamma(pScrn)) {
        RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);

        if (crtc) {
            if (crtc->gammaSize != size)
                return BadValue;

            RRCrtcGammaSet(crtc, red, green, blue);

            return Success;
        }
    }

    if (!CMapScreenKeyRegistered)
        return BadImplementation;

    pScreenPriv = (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                   CMapScreenKey);
    if (!pScreenPriv)
        return BadImplementation;

    if (pScreenPriv->gammaElements != size)
        return BadValue;

    ComputeGammaRamp(pScreenPriv, red, green, blue);

    /* mark all colormaps on this screen */
    pLink = pScreenPriv->maps;
    while (pLink) {
        pColPriv = (CMapColormapPtr) dixLookupPrivate(&pLink->cmap->devPrivates,
                                                      CMapColormapKey);
        pColPriv->recalculate = TRUE;
        pLink = pLink->next;
    }

    if (GetInstalledmiColormap(pScreen) &&
        ((pScreenPriv->flags & CMAP_LOAD_EVEN_IF_OFFSCREEN) ||
         pScrn->vtSema || pScreenPriv->isDGAmode)) {
        ColormapPtr pMap = GetInstalledmiColormap(pScreen);

        if (!(pScreenPriv->flags & CMAP_PALETTED_TRUECOLOR) &&
            (pMap->pVisual->class == TrueColor) &&
            CMapColormapUseMax(pMap->pVisual, pScreenPriv)) {

            /* if the current map doesn't have a palette look
               for another map to change the gamma on. */

            pLink = pScreenPriv->maps;
            while (pLink) {
                if (pLink->cmap->pVisual->class == PseudoColor)
                    break;
                pLink = pLink->next;
            }

            if (pLink) {
                /* need to trick CMapRefreshColors() into thinking
                   this is the currently installed map */
                SetInstalledmiColormap(pScreen, pLink->cmap);
                CMapReinstallMap(pLink->cmap);
                SetInstalledmiColormap(pScreen, pMap);
            }
        }
        else
            CMapReinstallMap(pMap);
    }

    return Success;
}

int
xf86GetGammaRampSize(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    CMapScreenPtr pScreenPriv;

    if (xf86_crtc_supports_gamma(pScrn)) {
        RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);

        if (crtc)
            return crtc->gammaSize;
    }

    if (!CMapScreenKeyRegistered)
        return 0;

    pScreenPriv = (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                   CMapScreenKey);
    if (!pScreenPriv)
        return 0;

    return pScreenPriv->gammaElements;
}

int
xf86GetGammaRamp(ScreenPtr pScreen,
                 int size,
                 unsigned short *red,
                 unsigned short *green, unsigned short *blue)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    CMapScreenPtr pScreenPriv;
    LOCO *entry;
    int shift, sigbits;

    if (xf86_crtc_supports_gamma(pScrn)) {
        RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);

        if (crtc) {
            if (crtc->gammaSize < size)
                return BadValue;

            if (!RRCrtcGammaGet(crtc))
                return BadImplementation;

            memcpy(red, crtc->gammaRed, size * sizeof(*red));
            memcpy(green, crtc->gammaGreen, size * sizeof(*green));
            memcpy(blue, crtc->gammaBlue, size * sizeof(*blue));

            return Success;
        }
    }

    if (!CMapScreenKeyRegistered)
        return BadImplementation;

    pScreenPriv = (CMapScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                   CMapScreenKey);
    if (!pScreenPriv)
        return BadImplementation;

    if (size > pScreenPriv->gammaElements)
        return BadValue;

    entry = pScreenPriv->gamma;
    sigbits = pScreenPriv->sigRGBbits;

    while (size--) {
        *red = entry->red << (16 - sigbits);
        *green = entry->green << (16 - sigbits);
        *blue = entry->blue << (16 - sigbits);
        shift = sigbits;
        while (shift < 16) {
            *red |= *red >> shift;
            *green |= *green >> shift;
            *blue |= *blue >> shift;
            shift += sigbits;
        }
        red++;
        green++;
        blue++;
        entry++;
    }

    return Success;
}

int
xf86ChangeGamma(ScreenPtr pScreen, Gamma gamma)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    if (pScrn->ChangeGamma)
        return (*pScrn->ChangeGamma) (pScrn, gamma);

    return BadImplementation;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d169 1
a169 1
    if (!(gamma = malloc(elements * sizeof(LOCO))))
d172 1
a172 1
    if (!(indices = malloc(maxColors * sizeof(int)))) {
d273 1
a273 1
    if (!(colors = malloc(numColors * sizeof(LOCO))))
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a76 1
    ScrnInfoPtr pScrn;
d125 1
a125 1
static void ComputeGamma(CMapScreenPtr);
a195 1
    pScreenPriv->pScrn = pScrn;
d222 1
a222 1
    ComputeGamma(pScreenPriv);
d446 1
a446 1
    /* Important. We let the lower layers, namely DGA, 
d661 1
a661 2
        (*pScrn->LoadPalette) (pScreenPriv->pScrn, defs, indices,
                               colors, pmap->pVisual);
d822 1
a822 1
            pScrn->SetOverscan(pScreenPriv->pScrn, overscan);
d851 1
a851 1
ComputeGamma(CMapScreenPtr priv)
d859 3
a861 6
    if (priv->pScrn->gamma.red < GAMMA_MIN ||
        priv->pScrn->gamma.red > GAMMA_MAX ||
        priv->pScrn->gamma.green < GAMMA_MIN ||
        priv->pScrn->gamma.green > GAMMA_MAX ||
        priv->pScrn->gamma.blue < GAMMA_MIN ||
        priv->pScrn->gamma.blue > GAMMA_MAX) {
d863 1
a863 1
        xf86DrvMsgVerb(priv->pScrn->scrnIndex, X_WARNING, 0,
d865 2
a866 2
                       "\tthe gamma values.\n", priv->pScrn->driverName);
        xf86DrvMsgVerb(priv->pScrn->scrnIndex, X_WARNING, 0,
d868 4
a871 4
                       priv->pScrn->driverName);
        priv->pScrn->gamma.red = 1.0;
        priv->pScrn->gamma.green = 1.0;
        priv->pScrn->gamma.blue = 1.0;
d875 3
a877 3
    RedGamma = 1.0 / (double) priv->pScrn->gamma.red;
    GreenGamma = 1.0 / (double) priv->pScrn->gamma.green;
    BlueGamma = 1.0 / (double) priv->pScrn->gamma.blue;
d930 1
a930 1
    ComputeGamma(pScreenPriv);
d961 1
a961 1
                /* need to trick CMapRefreshColors() into thinking 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d227 1
a227 1
    dixLookupResourceByType((pointer *) &pDefMap, pScreen->defColormap,
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d69 1
a69 1
      xf86Screens[pmap->pScreen->myNum]->vtSema || pScreenPriv->isDGAmode))
d83 3
a85 3
    Bool (*EnterVT) (int, int);
    Bool (*SwitchMode) (int, DisplayModePtr, int);
    int (*SetDGAMode) (int, int, DGADevicePtr);
d114 1
a114 1
static Bool CMapCloseScreen(int, ScreenPtr);
d118 2
a119 2
static Bool CMapEnterVT(int, int);
static Bool CMapSwitchMode(int, DisplayModePtr, int);
d122 1
a122 1
static int CMapSetDGAMode(int, int, DGADevicePtr);
d124 1
a124 1
static int CMapChangeGamma(int, Gamma);
d154 1
a154 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d244 1
a244 1
CMapCloseScreen(int i, ScreenPtr pScreen)
d248 1
a248 1
    return (*pScreen->CloseScreen) (i, pScreen);
d465 1
a465 1
CMapEnterVT(int index, int flags)
d467 1
a467 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = screenInfo.screens[index];
d473 1
a473 1
    ret = (*pScreenPriv->EnterVT) (index, flags);
d485 1
a485 1
CMapSwitchMode(int index, DisplayModePtr mode, int flags)
d487 1
a487 1
    ScreenPtr pScreen = screenInfo.screens[index];
d491 1
a491 1
    if ((*pScreenPriv->SwitchMode) (index, mode, flags)) {
d501 1
a501 1
CMapSetDGAMode(int index, int num, DGADevicePtr dev)
d503 1
a503 1
    ScreenPtr pScreen = screenInfo.screens[index];
d508 1
a508 1
    ret = (*pScreenPriv->SetDGAMode) (index, num, dev);
d510 1
a510 1
    pScreenPriv->isDGAmode = DGAActive(index);
d513 1
a513 1
        && xf86Screens[pScreen->myNum]->vtSema)
d530 1
a530 1
    ScrnInfoPtr pScrn = xf86Screens[pmap->pScreen->myNum];
d562 1
a562 1
    ScrnInfoPtr pScrn = xf86Screens[pmap->pScreen->myNum];
d611 1
a611 1
            entry = (EntryPtr) & pmap->red[index];
d694 1
a694 1
    ScrnInfoPtr pScrn = xf86Screens[pmap->pScreen->myNum];
d835 1
a835 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d910 1
a910 1
CMapChangeGamma(int index, Gamma gamma)
d913 1
a913 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = pScrn->pScreen;
d980 1
a980 1
        ret = pScrn->ChangeGamma(index, gamma);
d1009 1
a1009 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1086 1
a1086 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1113 1
a1113 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1173 1
a1173 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1176 1
a1176 1
        return (*pScrn->ChangeGamma) (pScreen->myNum, gamma);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d35 1
a35 1
#define _XOPEN_SOURCE   /* to get prototype for pow on some systems */
a70 1

d72 2
a73 2
  ColormapPtr		cmap;
  struct _CMapLink	*next;
d77 18
a94 18
  ScrnInfoPtr			pScrn;
  CloseScreenProcPtr		CloseScreen;
  CreateColormapProcPtr 	CreateColormap;
  DestroyColormapProcPtr	DestroyColormap;
  InstallColormapProcPtr	InstallColormap;
  StoreColorsProcPtr		StoreColors;
  Bool				(*EnterVT)(int, int);
  Bool				(*SwitchMode)(int, DisplayModePtr, int);
  int				(*SetDGAMode)(int, int, DGADevicePtr);
  xf86ChangeGammaProc		*ChangeGamma;
  int				maxColors;
  int				sigRGBbits;
  int				gammaElements;
  LOCO				*gamma;
  int				*PreAllocIndices;
  CMapLinkPtr			maps;
  unsigned int			flags;
  Bool				isDGAmode;
d98 4
a101 4
  int		numColors;
  LOCO		*colors;
  Bool		recalculate;
  int		overscan;
d105 1
d109 1
d114 3
a116 3
static Bool CMapCloseScreen (int, ScreenPtr);
static Bool CMapCreateColormap (ColormapPtr);
static void CMapDestroyColormap (ColormapPtr);
d120 1
d122 1
a122 1
static int  CMapSetDGAMode(int, int, DGADevicePtr);
d124 1
a124 1
static int  CMapChangeGamma(int, Gamma);
d128 1
a128 1
static void CMapRefreshColors(ColormapPtr, int, int*);
d133 2
a134 2

Bool xf86ColormapAllocatePrivates(ScrnInfoPtr pScrn)
d138 1
a138 1
	return TRUE;
d140 1
a140 1
	return FALSE;
d143 1
a143 1
	return FALSE;
d147 7
a153 8
Bool xf86HandleColormaps(
    ScreenPtr pScreen,
    int maxColors,
    int sigRGBbits,
    xf86LoadPaletteProc *loadPalette,
    xf86SetOverscanProc *setOverscan,
    unsigned int flags
){
d156 3
a158 3
    CMapScreenPtr pScreenPriv;  
    LOCO *gamma; 
    int *indices; 
d163 1
a163 1
	return TRUE;
d165 2
a166 2
    if(!maxColors || !sigRGBbits || !loadPalette)
	return FALSE;
d170 7
a176 2
    if(!(gamma = malloc(elements * sizeof(LOCO))))
    	return FALSE;
d178 4
a181 9
    if(!(indices = malloc(maxColors * sizeof(int)))) {
	free(gamma);
	return FALSE;
    }
      
    if(!(pScreenPriv = malloc(sizeof(CMapScreenRec)))) {
	free(gamma);
	free(indices);
	return FALSE;     
d185 1
a185 1
     
d211 1
a211 1
    pScreenPriv->SetDGAMode = pScrn->SetDGAMode;    
d215 3
a217 3
	pScrn->EnterVT = CMapEnterVT;
	if ((flags & CMAP_RELOAD_ON_MODE_SWITCH) && pScrn->SwitchMode) 
	    pScrn->SwitchMode = CMapSwitchMode;
d223 1
a223 1
 
d227 4
a230 4
    dixLookupResourceByType((pointer *)&pDefMap, pScreen->defColormap,
			    RT_COLORMAP, serverClient, DixInstallAccess);
    
    if(!CMapAllocateColormapPrivate(pDefMap)) {
d232 1
a232 1
	return FALSE;
a240 1

a242 1

d244 1
a244 1
CMapCloseScreen (int i, ScreenPtr pScreen)
d262 3
a264 2
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pmap->pScreen->devPrivates, CMapScreenKey);
d271 11
a281 11
	numColors = pmap->pVisual->ColormapEntries;
    else 
	numColors = 1 << pmap->pVisual->nplanes; 

    if(!(colors = malloc(numColors * sizeof(LOCO))))
	return FALSE;

    if(!(pColPriv = malloc(sizeof(CMapColormapRec)))) {
	free(colors);
	return FALSE;
    }	
d284 1
a284 1
 
d292 4
a295 4
    if(pLink) {
	pLink->cmap = pmap;
	pLink->next = pScreenPriv->maps;
	pScreenPriv->maps = pLink;
d301 2
a302 2
static Bool 
CMapCreateColormap (ColormapPtr pmap)
d305 2
a306 2
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
d310 3
a312 3
    if((*pScreen->CreateColormap)(pmap)) { 
	if(CMapAllocateColormapPrivate(pmap)) 
	   ret = TRUE;
d320 1
a320 1
CMapDestroyColormap (ColormapPtr cmap)
d323 4
a326 4
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
    CMapColormapPtr pColPriv = (CMapColormapPtr)dixLookupPrivate(
	&cmap->devPrivates, CMapColormapKey);
d329 3
a331 3
    if(pColPriv) {
	free(pColPriv->colors);
	free(pColPriv);
d333 1
a333 1
   
d335 17
a351 17
    while(pLink) {
	if(pLink->cmap == cmap) {
	   if(prevLink)
		prevLink->next = pLink->next;
	   else
		pScreenPriv->maps = pLink->next;
	   free(pLink);
	   break;
	}
	prevLink = pLink;
	pLink = pLink->next;
    }

    if(pScreenPriv->DestroyColormap) {
    	pScreen->DestroyColormap = pScreenPriv->DestroyColormap;
	(*pScreen->DestroyColormap)(cmap);
    	pScreen->DestroyColormap = CMapDestroyColormap;
a354 2


d356 8
a363 11
CMapStoreColors(
     ColormapPtr	pmap,
     int		ndef,
     xColorItem	        *pdefs
){
    ScreenPtr 	pScreen = pmap->pScreen;
    VisualPtr	pVisual = pmap->pVisual;
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
    int 	*indices = pScreenPriv->PreAllocIndices;
    int		num = ndef;
d367 1
a367 1
    (*pScreen->StoreColors)(pmap, ndef, pdefs); 
d371 59
a429 54
    if(	(pVisual->class == TrueColor) ||
	(pVisual->class == StaticColor) ||
	(pVisual->class == StaticGray))
	return;

    if(pVisual->class == DirectColor) {
	CMapColormapPtr pColPriv = (CMapColormapPtr)dixLookupPrivate(
	    &pmap->devPrivates, CMapColormapKey);
	int i;

	if (CMapColormapUseMax(pVisual, pScreenPriv)) {
	    int index;

	    num = 0;
	    while(ndef--) {
		if(pdefs[ndef].flags & DoRed) {
		    index = (pdefs[ndef].pixel & pVisual->redMask) >>
					pVisual->offsetRed;
		    i = num;
		    while(i--)
			if(indices[i] == index) break;
		    if(i == -1)
			indices[num++] = index;
		}
		if(pdefs[ndef].flags & DoGreen) {
		    index = (pdefs[ndef].pixel & pVisual->greenMask) >>
					pVisual->offsetGreen;
		    i = num;
		    while(i--)
			if(indices[i] == index) break;
		    if(i == -1)
			indices[num++] = index;
		}
		if(pdefs[ndef].flags & DoBlue) {
		    index = (pdefs[ndef].pixel & pVisual->blueMask) >>
					pVisual->offsetBlue;
		    i = num;
		    while(i--)
			if(indices[i] == index) break;
		    if(i == -1)
			indices[num++] = index;
		}
	    }

	} else {
	    /* not really as overkill as it seems */
	    num = pColPriv->numColors;
	    for(i = 0; i < pColPriv->numColors; i++)
		indices[i] = i;
	}
    } else {
	while(ndef--)
	   indices[ndef] = pdefs[ndef].pixel;
    } 
a433 1

d437 3
a439 3
    ScreenPtr 	  pScreen = pmap->pScreen;
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
d442 1
a442 1
	return;
d445 1
a445 1
    (*pScreen->InstallColormap)(pmap);
d451 1
a451 1
	pmap = GetInstalledmiColormap(pmap->pScreen);
d454 3
a456 3
	 (pmap->pVisual->class == TrueColor) &&
	 CMapColormapUseMax(pmap->pVisual, pScreenPriv))
	return;
d458 2
a459 2
    if(LOAD_PALETTE(pmap))
	CMapReinstallMap(pmap);
a461 1

d464 1
a464 1
static Bool 
d470 2
a471 2
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
d474 1
a474 1
    ret = (*pScreenPriv->EnterVT)(index, flags);
d477 4
a480 4
    if(ret) {
	if(GetInstalledmiColormap(pScreen))
	    CMapReinstallMap(GetInstalledmiColormap(pScreen));
	return TRUE;
d485 1
a485 2

static Bool 
d489 2
a490 2
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
d492 4
a495 4
    if((*pScreenPriv->SwitchMode)(index, mode, flags)) {
	if(GetInstalledmiColormap(pScreen))
	    CMapReinstallMap(GetInstalledmiColormap(pScreen));
	return TRUE;
d501 1
a501 1
static int  
d505 2
a506 2
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
d509 1
a509 1
    ret = (*pScreenPriv->SetDGAMode)(index, num, dev);
d513 3
a515 3
    if(!pScreenPriv->isDGAmode && GetInstalledmiColormap(pScreen)
         && xf86Screens[pScreen->myNum]->vtSema)
	CMapReinstallMap(GetInstalledmiColormap(pScreen));
a520 1

d526 5
a530 4
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pmap->pScreen->devPrivates, CMapScreenKey);
    CMapColormapPtr cmapPriv = (CMapColormapPtr)dixLookupPrivate(
	&pmap->devPrivates, CMapColormapKey);
d535 5
a539 5
    while(i--)
	indices[i] = i;
   
    if(cmapPriv->recalculate)
	CMapRefreshColors(pmap, cmapPriv->numColors, indices);
d541 3
a543 3
	(*pScrn->LoadPalette)(pScrn, cmapPriv->numColors,
 			indices, cmapPriv->colors, pmap->pVisual);
	if (pScrn->SetOverscan) {
d545 1
a545 1
	    ErrorF("SetOverscan() called from CMapReinstallMap\n");
d547 2
a548 2
	    pScrn->SetOverscan(pScrn, cmapPriv->overscan);
	}
d554 2
a555 3

static void 
CMapRefreshColors(ColormapPtr pmap, int defs, int* indices)
d557 5
a561 4
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pmap->pScreen->devPrivates, CMapScreenKey);
    CMapColormapPtr pColPriv = (CMapColormapPtr)dixLookupPrivate(
	&pmap->devPrivates, CMapColormapKey);
d579 1
a579 1
    switch(pVisual->class) {
d581 7
a587 7
	for(i = 0; i < numColors; i++) { 
	    index = (i+1) * maxValue / numColors;
	    colors[i].red   = gamma[index].red;
	    colors[i].green = gamma[index].green;
	    colors[i].blue  = gamma[index].blue;
	}
	break;
d590 17
a606 17
	    for(i = 0; i <= reds; i++) 
		colors[i].red   = gamma[i * maxValue / reds].red;
	    for(i = 0; i <= greens; i++) 
		colors[i].green = gamma[i * maxValue / greens].green;
	    for(i = 0; i <= blues; i++) 
		colors[i].blue  = gamma[i * maxValue / blues].blue;
	    break;
	}
	for(i = 0; i < numColors; i++) {
	    colors[i].red   = gamma[((i >> pVisual->offsetRed) & reds) * 
					maxValue / reds].red;
	    colors[i].green = gamma[((i >> pVisual->offsetGreen) & greens) * 
					maxValue / greens].green;
	    colors[i].blue  = gamma[((i >> pVisual->offsetBlue) & blues) * 
					maxValue / blues].blue;
	}
	break;
d610 20
a629 21
	for(i = 0; i < defs; i++) { 
	    index = indices[i];
	    entry = (EntryPtr)&pmap->red[index];

	    if(entry->fShared) {
		colors[index].red = 
			gamma[entry->co.shco.red->color >> shift].red;
		colors[index].green = 
			gamma[entry->co.shco.green->color >> shift].green;
		colors[index].blue = 
			gamma[entry->co.shco.blue->color >> shift].blue;
	    } else {
		colors[index].red   = 
				gamma[entry->co.local.red >> shift].red;
		colors[index].green = 
				gamma[entry->co.local.green >> shift].green;
		colors[index].blue  = 
				gamma[entry->co.local.blue >> shift].blue;
	    }
	}
	break;
d632 11
a642 30
	    for(i = 0; i < defs; i++) { 
		index = indices[i];
		if(index <= reds)
		    colors[index].red   = 
			gamma[pmap->red[index].co.local.red >> shift].red;
		if(index <= greens)
		    colors[index].green = 
			gamma[pmap->green[index].co.local.green >> shift].green;
		if(index <= blues)
		    colors[index].blue   = 
			gamma[pmap->blue[index].co.local.blue >> shift].blue;

	    }
	    break;
	}
	for(i = 0; i < defs; i++) { 
	    index = indices[i];

	    colors[index].red   = gamma[pmap->red[
				(index >> pVisual->offsetRed) & reds
				].co.local.red >> shift].red;
	    colors[index].green = gamma[pmap->green[
				(index >> pVisual->offsetGreen) & greens
				].co.local.green >> shift].green;
	    colors[index].blue  = gamma[pmap->blue[
				(index >> pVisual->offsetBlue) & blues
				].co.local.blue >> shift].blue;
	}
	break;
    }
d644 22
a665 4

    if(LOAD_PALETTE(pmap))
	(*pScrn->LoadPalette)(pScreenPriv->pScrn, defs, indices,
 					colors, pmap->pVisual);
d668 1
a668 1
	CMapSetOverscan(pmap, defs, indices);
d673 1
a673 1
CMapCompareColors(LOCO *color1, LOCO *color2)
d678 4
a681 4
	color1->red, color1->green, color1->blue,
	color2->red, color2->green, color2->blue,
	color1->red + color1->green + color1->blue,
	color2->red + color2->green + color2->blue);
d684 1
a684 1
	    color2->red + color2->green + color2->blue);
d690 5
a694 4
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pmap->pScreen->devPrivates, CMapScreenKey);
    CMapColormapPtr pColPriv = (CMapColormapPtr)dixLookupPrivate(
	&pmap->devPrivates, CMapColormapKey);
d722 4
a725 4
	/* Should only come here once.  Initialise the overscan index to 0 */
	overscan = 0;
	newOverscan = TRUE;
	break;
d727 1
a727 1
	/*
d730 1
a730 1
	 */
d734 27
a760 26
	if (overscan < 0 || overscan > pScreenPriv->maxColors - 1) {
	    /* Uninitialised */
	    newOverscan = TRUE;
	} else {
	    /* Check if the overscan was changed */
	    for (i = 0; i < defs; i++) {
		index = indices[i];
		if (index == overscan) {
		    newOverscan = TRUE;
		    break;
		}
	    }
	}
	if (newOverscan) {
	    /* The overscan is either uninitialised or it has been changed */

	    if (overscan < 0 || overscan > pScreenPriv->maxColors - 1)
		tmpOverscan = pScreenPriv->maxColors - 1;
	    else
		tmpOverscan = overscan;

	    /* search all entries for a close match to black */
	    for (i = pScreenPriv->maxColors - 1; i >= 0; i--) {
		if (colors[i].red == 0 && colors[i].green == 0 &&
		    colors[i].blue == 0) {
		    overscan = i;
d762 1
a762 1
		    ErrorF("Black found at index 0x%02x\n", i);
d764 3
a766 2
		    break;
		} else {
d768 1
a768 1
		    ErrorF("0x%02x: ", i);
d770 2
a771 2
		    if (CMapCompareColors(&colors[i], &colors[tmpOverscan])) {
			tmpOverscan = i;
d773 1
a773 1
			ErrorF("possible \"Black\" at index 0x%02x\n", i);
d775 18
a792 16
		    }
		}
	    }
	    if (i < 0)
		overscan = tmpOverscan;
	} else {
	    /* Check of the old overscan wasn't black */
	    if (colors[overscan].red != 0 || colors[overscan].green != 0 ||
		colors[overscan].blue != 0) {
		int oldOverscan = tmpOverscan = overscan;
		/* See of there is now a better match */
		for (i = 0; i < defs; i++) {
		    index = indices[i];
		    if (colors[index].red == 0 && colors[index].green == 0 &&
			colors[index].blue == 0) {
			overscan = index;
d794 1
a794 1
			ErrorF("Black found at index 0x%02x\n", index);
d796 3
a798 2
			break;
		    } else {
d800 1
a800 1
			ErrorF("0x%02x: ", index);
d802 3
a804 3
			if (CMapCompareColors(&colors[index],
					      &colors[tmpOverscan])) {
			    tmpOverscan = index;
d806 2
a807 2
			    ErrorF("possible \"Black\" at index 0x%02x\n",
				   index);
d809 10
a818 10
			}
		    }
		}
		if (i == defs)
		    overscan = tmpOverscan;
		if (overscan != oldOverscan)
		    newOverscan = TRUE;
	    }
	}
	break;
d821 2
a822 2
	pColPriv->overscan = overscan;
	if (LOAD_PALETTE(pmap)) {
d824 1
a824 1
	    ErrorF("SetOverscan() called from CmapSetOverscan\n");
d826 2
a827 2
	    pScrn->SetOverscan(pScreenPriv->pScrn, overscan);
	}
d834 2
a835 2
    CMapScreenPtr pScreenPriv = (CMapScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, CMapScreenKey);
d844 3
a846 3
    pScrn->EnterVT = pScreenPriv->EnterVT; 
    pScrn->SwitchMode = pScreenPriv->SwitchMode; 
    pScrn->SetDGAMode = pScreenPriv->SetDGAMode; 
d854 1
a854 2

static void 
d864 15
a878 14
	priv->pScrn->gamma.red > GAMMA_MAX ||
	priv->pScrn->gamma.green < GAMMA_MIN ||
	priv->pScrn->gamma.green > GAMMA_MAX ||
	priv->pScrn->gamma.blue < GAMMA_MIN ||
	priv->pScrn->gamma.blue > GAMMA_MAX) {

	xf86DrvMsgVerb(priv->pScrn->scrnIndex, X_WARNING, 0,
	    "The %s driver didn't call xf86SetGamma() to initialise\n"
	    "\tthe gamma values.\n", priv->pScrn->driverName);
	xf86DrvMsgVerb(priv->pScrn->scrnIndex, X_WARNING, 0,
	    "PLEASE FIX THE `%s' DRIVER!\n", priv->pScrn->driverName);
	priv->pScrn->gamma.red = 1.0;
	priv->pScrn->gamma.green = 1.0;
	priv->pScrn->gamma.blue = 1.0;
d882 25
a906 22
    RedGamma = 1.0 / (double)priv->pScrn->gamma.red;
    GreenGamma = 1.0 / (double)priv->pScrn->gamma.green;
    BlueGamma = 1.0 / (double)priv->pScrn->gamma.blue;
    
    for(i = 0; i <= elements; i++) {
	if(RedGamma == 1.0)  
	    priv->gamma[i].red = i;
	else
	    priv->gamma[i].red = (CARD16)(pow((double)i/(double)elements,
			RedGamma) * (double)elements + 0.5);

	if(GreenGamma == 1.0)  
	    priv->gamma[i].green = i;
	else
	    priv->gamma[i].green = (CARD16)(pow((double)i/(double)elements,
			GreenGamma) * (double)elements + 0.5);

	if(BlueGamma == 1.0)  
	    priv->gamma[i].blue = i;
	else
	    priv->gamma[i].blue = (CARD16)(pow((double)i/(double)elements,
			BlueGamma) * (double)elements + 0.5);
a909 1

d911 2
a912 4
CMapChangeGamma(
   int index,
   Gamma gamma
){
d919 1
a919 1
        
d921 7
a927 2
    if(!CMapScreenKeyRegistered)
	return BadImplementation;
a928 5
    pScreenPriv = (CMapScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  CMapScreenKey);
    if(!pScreenPriv)
	return BadImplementation;
 
d930 3
a932 3
	gamma.green < GAMMA_MIN || gamma.green > GAMMA_MAX ||
	gamma.blue < GAMMA_MIN || gamma.blue > GAMMA_MAX)
	return BadValue;
d942 36
a977 35
    while(pLink) {
    	pColPriv = (CMapColormapPtr)dixLookupPrivate(&pLink->cmap->devPrivates,
						     CMapColormapKey);
	pColPriv->recalculate = TRUE;
	pLink = pLink->next;
    }

    if(GetInstalledmiColormap(pScreen) &&
       ((pScreenPriv->flags & CMAP_LOAD_EVEN_IF_OFFSCREEN) ||
	pScrn->vtSema || pScreenPriv->isDGAmode)) {
	ColormapPtr pMap = GetInstalledmiColormap(pScreen);

	if (!(pScreenPriv->flags & CMAP_PALETTED_TRUECOLOR) &&
	    (pMap->pVisual->class == TrueColor) &&
	    CMapColormapUseMax(pMap->pVisual, pScreenPriv)) {

	    /* if the current map doesn't have a palette look
		for another map to change the gamma on. */

	    pLink = pScreenPriv->maps;
	    while(pLink) {
		if(pLink->cmap->pVisual->class == PseudoColor)
		    break;
		pLink = pLink->next;
	    }

	    if(pLink) {
		/* need to trick CMapRefreshColors() into thinking 
		   this is the currently installed map */
		SetInstalledmiColormap(pScreen, pLink->cmap);
		CMapReinstallMap(pLink->cmap);
		SetInstalledmiColormap(pScreen, pMap);
	    }
	} else
	    CMapReinstallMap(pMap);
d982 1
a982 1
	ret = pScrn->ChangeGamma(index, gamma);
a987 1

d989 4
a992 6
ComputeGammaRamp (
    CMapScreenPtr priv,
    unsigned short *red,
    unsigned short *green,
    unsigned short *blue
){
d997 5
a1001 5
    while(elements--) {
	entry->red = *(red++) >> shift;
	entry->green = *(green++) >> shift;
	entry->blue = *(blue++) >> shift;
	entry++;
d1006 5
a1010 7
xf86ChangeGammaRamp(
   ScreenPtr pScreen,
   int size,
   unsigned short *red, 
   unsigned short *green,
   unsigned short *blue
){
d1017 1
a1017 1
	RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);
d1019 3
a1021 3
	if (crtc) {
	    if (crtc->gammaSize != size)
		return BadValue;
d1023 1
a1023 1
	    RRCrtcGammaSet(crtc, red, green, blue);
d1025 2
a1026 2
	    return Success;
	}
d1029 1
a1029 1
    if(!CMapScreenKeyRegistered)
d1032 3
a1034 3
    pScreenPriv = (CMapScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  CMapScreenKey);
    if(!pScreenPriv)
d1037 2
a1038 2
    if(pScreenPriv->gammaElements != size)
	return BadValue;
d1044 3
a1046 3
    while(pLink) {
    	pColPriv = (CMapColormapPtr)dixLookupPrivate(&pLink->cmap->devPrivates,
						     CMapColormapKey);
d1051 3
a1053 3
    if(GetInstalledmiColormap(pScreen) &&
       ((pScreenPriv->flags & CMAP_LOAD_EVEN_IF_OFFSCREEN) ||
        pScrn->vtSema || pScreenPriv->isDGAmode)) {
d1058 1
a1058 1
	    CMapColormapUseMax(pMap->pVisual, pScreenPriv)) {
d1061 1
a1061 1
                for another map to change the gamma on. */
d1064 2
a1065 2
            while(pLink) {
                if(pLink->cmap->pVisual->class == PseudoColor)
d1070 1
a1070 1
            if(pLink) {
d1077 2
a1078 1
        } else
d1092 1
a1092 1
	RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);
d1094 2
a1095 2
	if (crtc)
	    return crtc->gammaSize;
d1098 2
a1099 1
    if(!CMapScreenKeyRegistered) return 0;
d1101 4
a1104 3
    pScreenPriv = (CMapScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  CMapScreenKey);
    if(!pScreenPriv) return 0;
d1110 5
a1114 7
xf86GetGammaRamp(
   ScreenPtr pScreen,
   int size,
   unsigned short *red,
   unsigned short *green,
   unsigned short *blue
){
d1121 1
a1121 1
	RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);
d1123 3
a1125 3
	if (crtc) {
	    if (crtc->gammaSize < size)
		return BadValue;
d1127 2
a1128 2
	    if (!RRCrtcGammaGet(crtc))
		return BadImplementation;
d1130 3
a1132 3
	    memcpy(red, crtc->gammaRed, size * sizeof(*red));
	    memcpy(green, crtc->gammaGreen, size * sizeof(*green));
	    memcpy(blue, crtc->gammaBlue, size * sizeof(*blue));
d1134 2
a1135 2
	    return Success;
	}
d1138 2
a1139 2
    if(!CMapScreenKeyRegistered)
	return BadImplementation;
d1141 4
a1144 4
    pScreenPriv = (CMapScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  CMapScreenKey);
    if(!pScreenPriv) 
	return BadImplementation;
d1146 2
a1147 2
    if(size > pScreenPriv->gammaElements)
	return BadValue;
d1152 14
a1165 12
    while(size--) {
	*red = entry->red << (16 - sigbits);
	*green = entry->green << (16 - sigbits);
	*blue = entry->blue << (16 - sigbits);
	shift = sigbits;
	while(shift < 16) {
	    *red |= *red >> shift;
	    *green |= *green >> shift;
	    *blue |= *blue >> shift;
	    shift += sigbits;
	}
	red++; green++; blue++;
d1173 2
a1174 4
xf86ChangeGamma(
   ScreenPtr pScreen,
   Gamma gamma
){
d1177 2
a1178 2
    if(pScrn->ChangeGamma)
	return (*pScrn->ChangeGamma)(pScreen->myNum, gamma);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d66 2
a67 2
#define LOAD_PALETTE(pmap, index) \
    ((pmap == miInstalledMaps[index]) && \
d69 1
a69 1
      xf86Screens[index]->vtSema || pScreenPriv->isDGAmode))
d105 5
a109 4
static int CMapScreenKeyIndex;
static DevPrivateKey CMapScreenKey;
static int CMapColormapKeyIndex;
static DevPrivateKey CMapColormapKey = &CMapColormapKeyIndex;
d132 12
a166 2
    CMapScreenKey = &CMapScreenKeyIndex;

d169 1
a169 1
    if(!(gamma = xalloc(elements * sizeof(LOCO))))
d172 2
a173 2
    if(!(indices = xalloc(maxColors * sizeof(int)))) {
	xfree(gamma);
d177 3
a179 3
    if(!(pScreenPriv = xalloc(sizeof(CMapScreenRec)))) {
	xfree(gamma);
	xfree(indices);
d183 1
a183 1
    dixSetPrivate(&pScreen->devPrivates, CMapScreenKey, pScreenPriv);
d235 1
a235 1
    miInstalledMaps[pScreen->myNum] = NULL;
d275 1
a275 1
    if(!(colors = xalloc(numColors * sizeof(LOCO))))
d278 2
a279 2
    if(!(pColPriv = xalloc(sizeof(CMapColormapRec)))) {
	xfree(colors);
d291 1
a291 1
    pLink = xalloc(sizeof(CMapLink));
d330 2
a331 2
	if(pColPriv->colors) xfree(pColPriv->colors);
	xfree(pColPriv);
d341 1
a341 1
	   xfree(pLink);
a438 1
    int		  index = pScreen->myNum;
d442 1
a442 1
    if (pmap == miInstalledMaps[index])
d451 2
a452 2
    if (miInstalledMaps[index])
	pmap = miInstalledMaps[index];
d459 1
a459 1
    if(LOAD_PALETTE(pmap, index))
d469 1
d471 1
d475 7
a481 3
    if((*pScreenPriv->EnterVT)(index, flags)) {
	if(miInstalledMaps[index])
	    CMapReinstallMap(miInstalledMaps[index]);
d496 2
a497 2
	if(miInstalledMaps[index])
	    CMapReinstallMap(miInstalledMaps[index]);
d516 1
a516 1
    if(!pScreenPriv->isDGAmode && miInstalledMaps[index] 
d518 1
a518 1
	CMapReinstallMap(miInstalledMaps[index]);
d668 1
a668 1
    if(LOAD_PALETTE(pmap, pmap->pScreen->myNum))
d821 1
a821 1
	if (LOAD_PALETTE(pmap, pmap->pScreen->myNum)) {
d848 3
a850 3
    xfree(pScreenPriv->gamma);
    xfree(pScreenPriv->PreAllocIndices);
    xfree(pScreenPriv);
d920 1
a920 1
    if(CMapScreenKey == NULL)
d948 1
a948 1
    if(miInstalledMaps[pScreen->myNum] && 
d951 1
a951 1
	ColormapPtr pMap = miInstalledMaps[pScreen->myNum];
d970 1
a970 1
		miInstalledMaps[pScreen->myNum] = pLink->cmap;
d972 1
a972 1
		miInstalledMaps[pScreen->myNum] = pMap;
d1032 1
a1032 1
    if(CMapScreenKey == NULL)
d1054 1
a1054 1
    if(miInstalledMaps[pScreen->myNum] &&
d1057 1
a1057 1
        ColormapPtr pMap = miInstalledMaps[pScreen->myNum];
d1076 1
a1076 1
                miInstalledMaps[pScreen->myNum] = pLink->cmap;
d1078 1
a1078 1
                miInstalledMaps[pScreen->myNum] = pMap;
d1100 1
a1100 1
    if(CMapScreenKey == NULL) return 0;
d1140 1
a1140 1
    if(CMapScreenKey == NULL) 
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d52 1
d55 1
a55 2
#define _XF86DGA_SERVER_
#include <X11/extensions/xf86dgastr.h>
d87 1
d118 1
d120 1
d132 1
a132 1
_X_EXPORT Bool xf86HandleColormaps(
d147 4
d200 1
d215 2
a216 2

    pDefMap = (ColormapPtr) LookupIDByType(pScreen->defColormap, RT_COLORMAP);
d568 2
a569 2
	for(i = 0; i <= numColors - 1; i++) { 
	    index = i * maxValue / numColors;
d830 1
d896 1
d962 6
a967 1
    return Success;
d990 1
a990 1
_X_EXPORT int
d1003 13
d1071 1
a1071 1
_X_EXPORT int
d1074 1
d1077 7
d1093 1
a1093 1
_X_EXPORT int
d1101 1
d1106 18
d1166 1
a1166 1
    return Success; /* Success? */
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d32 1
a32 2
#if defined(_XOPEN_SOURCE) || defined(__QNXNTO__) \
	|| (defined(sun) && defined(__SVR4))
d104 4
a107 2
static DevPrivateKey CMapScreenKey = NULL;
static DevPrivateKey CMapColormapKey = &CMapColormapKey;
d147 1
a147 1
    CMapScreenKey = &CMapScreenKey;
@


1.1
log
@Initial revision
@
text
@d63 1
a63 1
   ((CMapScreenPtr) (pScreen)->devPrivates[CMapScreenIndex].ptr)->field)
d105 2
a106 3
static unsigned long CMapGeneration = 0;
static int CMapScreenIndex = -1;
static int CMapColormapIndex = -1;
a120 1
static Bool CMapInitDefMap(ColormapPtr,int);
d146 1
a146 7
    if(CMapGeneration != serverGeneration) {
	if(((CMapScreenIndex = AllocateScreenPrivateIndex()) < 0) ||
	   ((CMapColormapIndex = AllocateColormapPrivateIndex(
					CMapInitDefMap)) < 0))
		return FALSE;
	CMapGeneration = serverGeneration;
    }
d164 1
a164 1
    pScreen->devPrivates[CMapScreenIndex].ptr = (pointer)pScreenPriv;
a219 6
static Bool 
CMapInitDefMap(ColormapPtr cmap, int index)
{
    return TRUE;
}

d243 2
a244 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pmap->pScreen->devPrivates[CMapScreenIndex].ptr;
d263 1
a263 1
    pmap->devPrivates[CMapColormapIndex].ptr = (pointer)pColPriv;
d285 2
a286 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr)pScreen->devPrivates[CMapScreenIndex].ptr;
d303 4
a306 4
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
    CMapColormapPtr pColPriv = 
	(CMapColormapPtr) cmap->devPrivates[CMapColormapIndex].ptr;
d345 2
a346 2
    CMapScreenPtr pScreenPriv = 
        	(CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
d362 2
a363 2
	CMapColormapPtr pColPriv = 
	   (CMapColormapPtr) pmap->devPrivates[CMapColormapIndex].ptr;
d420 2
a421 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
d451 2
a452 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
d467 2
a468 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
d483 2
a484 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
d505 4
a508 4
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pmap->pScreen->devPrivates[CMapScreenIndex].ptr;
    CMapColormapPtr cmapPriv = 
	(CMapColormapPtr) pmap->devPrivates[CMapColormapIndex].ptr;
d536 4
a539 4
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pmap->pScreen->devPrivates[CMapScreenIndex].ptr;
    CMapColormapPtr pColPriv = 
	(CMapColormapPtr) pmap->devPrivates[CMapColormapIndex].ptr;
d670 4
a673 4
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pmap->pScreen->devPrivates[CMapScreenIndex].ptr;
    CMapColormapPtr pColPriv = 
	(CMapColormapPtr) pmap->devPrivates[CMapColormapIndex].ptr;
d808 2
a809 2
    CMapScreenPtr pScreenPriv = 
        (CMapScreenPtr) pScreen->devPrivates[CMapScreenIndex].ptr;
d893 1
a893 1
    if(CMapScreenIndex == -1)
d896 2
a897 1
    pScreenPriv = (CMapScreenPtr)pScreen->devPrivates[CMapScreenIndex].ptr;
d915 2
a916 2
    	pColPriv = 
	 (CMapColormapPtr) pLink->cmap->devPrivates[CMapColormapIndex].ptr;
d987 1
a987 1
    if(CMapScreenIndex == -1)
d990 2
a991 1
    pScreenPriv = (CMapScreenPtr)pScreen->devPrivates[CMapScreenIndex].ptr;
d1003 2
a1004 2
        pColPriv =
         (CMapColormapPtr) pLink->cmap->devPrivates[CMapColormapIndex].ptr;
d1047 1
a1047 1
    if(CMapScreenIndex == -1) return 0;
d1049 2
a1050 1
    pScreenPriv = (CMapScreenPtr)pScreen->devPrivates[CMapScreenIndex].ptr;
d1068 1
a1068 1
    if(CMapScreenIndex == -1) 
d1071 2
a1072 1
    pScreenPriv = (CMapScreenPtr)pScreen->devPrivates[CMapScreenIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
