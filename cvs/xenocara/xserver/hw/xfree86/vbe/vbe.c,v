head	1.15;
access;
symbols
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.28.53;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.25;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.20;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
/*
 *                   XFree86 vbe module
 *               Copyright 2000 Egbert Eich
 *
 * The mode query/save/set/restore functions from the vesa driver
 * have been moved here.
 * Copyright (c) 2000 by Conectiva S.A. (http://www.conectiva.com)
 * Authors: Paulo César Pereira de Andrade <pcpa@@conectiva.com.br>
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>

#include "xf86.h"
#include "xf86Modes.h"
#include "vbe.h"
#include <X11/extensions/dpmsconst.h>

#define VERSION(x) VBE_VERSION_MAJOR(x),VBE_VERSION_MINOR(x)

#if X_BYTE_ORDER == X_LITTLE_ENDIAN
#define B_O16(x)  (x)
#define B_O32(x)  (x)
#else
#define B_O16(x)  ((((x) & 0xff) << 8) | (((x) & 0xff) >> 8))
#define B_O32(x)  ((((x) & 0xff) << 24) | (((x) & 0xff00) << 8) \
                  | (((x) & 0xff0000) >> 8) | (((x) & 0xff000000) >> 24))
#endif
#define L_ADD(x)  (B_O32(x) & 0xffff) + ((B_O32(x) >> 12) & 0xffff00)

#define FARP(p)		(((unsigned)(p & 0xffff0000) >> 12) | (p & 0xffff))
#define R16(v)		((v) & 0xffff)

static unsigned char *vbeReadEDID(vbeInfoPtr pVbe);
static Bool vbeProbeDDC(vbeInfoPtr pVbe);

static const char vbeVersionString[] = "VBE2";

vbeInfoPtr
VBEInit(xf86Int10InfoPtr pInt, int entityIndex)
{
    return VBEExtendedInit(pInt, entityIndex, 0);
}

vbeInfoPtr
VBEExtendedInit(xf86Int10InfoPtr pInt, int entityIndex, int Flags)
{
    int RealOff;
    void *page = NULL;
    ScrnInfoPtr pScrn = xf86FindScreenForEntity(entityIndex);
    vbeControllerInfoPtr vbe = NULL;
    Bool init_int10 = FALSE;
    vbeInfoPtr vip = NULL;
    int screen;

    if (!pScrn)
        return NULL;
    screen = pScrn->scrnIndex;

    if (!pInt) {
        if (!xf86LoadSubModule(pScrn, "int10"))
            goto error;

        xf86DrvMsg(screen, X_INFO, "initializing int10\n");
        pInt = xf86ExtendedInitInt10(entityIndex, Flags);
        if (!pInt)
            goto error;
        init_int10 = TRUE;
    }

    page = xf86Int10AllocPages(pInt, 1, &RealOff);
    if (!page)
        goto error;
    vbe = (vbeControllerInfoPtr) page;
    memcpy(vbe->VbeSignature, vbeVersionString, 4);

    pInt->ax = 0x4F00;
    pInt->es = SEG_ADDR(RealOff);
    pInt->di = SEG_OFF(RealOff);
    pInt->num = 0x10;

    xf86ExecX86int10(pInt);

    if ((pInt->ax & 0xff) != 0x4f) {
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA BIOS not detected\n");
        goto error;
    }

    switch (pInt->ax & 0xff00) {
    case 0:
        xf86DrvMsg(screen, X_INFO, "VESA BIOS detected\n");
        break;
    case 0x100:
        xf86DrvMsg(screen, X_INFO, "VESA BIOS function failed\n");
        goto error;
    case 0x200:
        xf86DrvMsg(screen, X_INFO, "VESA BIOS not supported\n");
        goto error;
    case 0x300:
        xf86DrvMsg(screen, X_INFO, "VESA BIOS not supported in current mode\n");
        goto error;
    default:
        xf86DrvMsg(screen, X_INFO, "Invalid\n");
        goto error;
    }

    xf86DrvMsgVerb(screen, X_INFO, 4,
                   "VbeVersion is %d, OemStringPtr is 0x%08lx,\n"
                   "\tOemVendorNamePtr is 0x%08lx, OemProductNamePtr is 0x%08lx,\n"
                   "\tOemProductRevPtr is 0x%08lx\n",
                   vbe->VbeVersion, (unsigned long) vbe->OemStringPtr,
                   (unsigned long) vbe->OemVendorNamePtr,
                   (unsigned long) vbe->OemProductNamePtr,
                   (unsigned long) vbe->OemProductRevPtr);

    xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE Version %i.%i\n",
                   VERSION(vbe->VbeVersion));
    xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE Total Mem: %i kB\n",
                   vbe->TotalMem * 64);
    xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE OEM: %s\n",
                   (CARD8 *) xf86int10Addr(pInt, L_ADD(vbe->OemStringPtr)));

    if (B_O16(vbe->VbeVersion) >= 0x200) {
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE OEM Software Rev: %i.%i\n",
                       VERSION(vbe->OemSoftwareRev));
        if (vbe->OemVendorNamePtr)
            xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE OEM Vendor: %s\n",
                           (CARD8 *) xf86int10Addr(pInt,
                                                   L_ADD(vbe->
                                                         OemVendorNamePtr)));
        if (vbe->OemProductNamePtr)
            xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE OEM Product: %s\n",
                           (CARD8 *) xf86int10Addr(pInt,
                                                   L_ADD(vbe->
                                                         OemProductNamePtr)));
        if (vbe->OemProductRevPtr)
            xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE OEM Product Rev: %s\n",
                           (CARD8 *) xf86int10Addr(pInt,
                                                   L_ADD(vbe->
                                                         OemProductRevPtr)));
    }
    vip = (vbeInfoPtr) xnfalloc(sizeof(vbeInfoRec));
    vip->version = B_O16(vbe->VbeVersion);
    vip->pInt10 = pInt;
    vip->ddc = DDC_UNCHECKED;
    vip->memory = page;
    vip->real_mode_base = RealOff;
    vip->num_pages = 1;
    vip->init_int10 = init_int10;

    return vip;

 error:
    if (page)
        xf86Int10FreePages(pInt, page, 1);
    if (init_int10)
        xf86FreeInt10(pInt);
    return NULL;
}

void
vbeFree(vbeInfoPtr pVbe)
{
    if (!pVbe)
        return;

    xf86Int10FreePages(pVbe->pInt10, pVbe->memory, pVbe->num_pages);
    /* If we have initalized int10 we ought to free it, too */
    if (pVbe->init_int10)
        xf86FreeInt10(pVbe->pInt10);
    free(pVbe);
    return;
}

static Bool
vbeProbeDDC(vbeInfoPtr pVbe)
{
    const char *ddc_level;
    int screen = pVbe->pInt10->pScrn->scrnIndex;

    if (pVbe->ddc == DDC_NONE)
        return FALSE;
    if (pVbe->ddc != DDC_UNCHECKED)
        return TRUE;

    pVbe->pInt10->ax = 0x4F15;
    pVbe->pInt10->bx = 0;
    pVbe->pInt10->cx = 0;
    pVbe->pInt10->es = 0;
    pVbe->pInt10->di = 0;
    pVbe->pInt10->num = 0x10;

    xf86ExecX86int10(pVbe->pInt10);

    if ((pVbe->pInt10->ax & 0xff) != 0x4f) {
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC not supported\n");
        pVbe->ddc = DDC_NONE;
        return FALSE;
    }

    switch ((pVbe->pInt10->ax >> 8) & 0xff) {
    case 0:
        xf86DrvMsg(screen, X_INFO, "VESA VBE DDC supported\n");
        switch (pVbe->pInt10->bx & 0x3) {
        case 0:
            ddc_level = " none";
            pVbe->ddc = DDC_NONE;
            break;
        case 1:
            ddc_level = " 1";
            pVbe->ddc = DDC_1;
            break;
        case 2:
            ddc_level = " 2";
            pVbe->ddc = DDC_2;
            break;
        case 3:
            ddc_level = " 1 + 2";
            pVbe->ddc = DDC_1_2;
            break;
        default:
            ddc_level = "";
            pVbe->ddc = DDC_NONE;
            break;
        }
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC Level%s\n", ddc_level);
        if (pVbe->pInt10->bx & 0x4) {
            xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC Screen blanked"
                           "for data transfer\n");
            pVbe->ddc_blank = TRUE;
        }
        else
            pVbe->ddc_blank = FALSE;

        xf86DrvMsgVerb(screen, X_INFO, 3,
                       "VESA VBE DDC transfer in appr. %x sec.\n",
                       (pVbe->pInt10->bx >> 8) & 0xff);
    }

    return TRUE;
}

typedef enum {
    VBEOPT_NOVBE,
    VBEOPT_NODDC
} VBEOpts;

static const OptionInfoRec VBEOptions[] = {
    {VBEOPT_NOVBE, "NoVBE", OPTV_BOOLEAN, {0}, FALSE},
    {VBEOPT_NODDC, "NoDDC", OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL, OPTV_NONE, {0}, FALSE},
};

static unsigned char *
vbeReadEDID(vbeInfoPtr pVbe)
{
    int RealOff = pVbe->real_mode_base;
    void *page = pVbe->memory;
    unsigned char *tmp = NULL;
    Bool novbe = FALSE;
    Bool noddc = FALSE;
    ScrnInfoPtr pScrn = pVbe->pInt10->pScrn;
    int screen = pScrn->scrnIndex;
    OptionInfoPtr options;

    if (!page)
        return NULL;

    options = xnfalloc(sizeof(VBEOptions));
    (void) memcpy(options, VBEOptions, sizeof(VBEOptions));
    xf86ProcessOptions(screen, pScrn->options, options);
    xf86GetOptValBool(options, VBEOPT_NOVBE, &novbe);
    xf86GetOptValBool(options, VBEOPT_NODDC, &noddc);
    free(options);
    if (novbe || noddc)
        return NULL;

    if (!vbeProbeDDC(pVbe))
        goto error;

    memset(page, 0, sizeof(vbeInfoPtr));
    strcpy(page, vbeVersionString);

    pVbe->pInt10->ax = 0x4F15;
    pVbe->pInt10->bx = 0x01;
    pVbe->pInt10->cx = 0;
    pVbe->pInt10->dx = 0;
    pVbe->pInt10->es = SEG_ADDR(RealOff);
    pVbe->pInt10->di = SEG_OFF(RealOff);
    pVbe->pInt10->num = 0x10;

    xf86ExecX86int10(pVbe->pInt10);

    if ((pVbe->pInt10->ax & 0xff) != 0x4f) {
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC invalid\n");
        goto error;
    }
    switch (pVbe->pInt10->ax & 0xff00) {
    case 0x0:
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC read successfully\n");
        tmp = (unsigned char *) xnfalloc(128);
        memcpy(tmp, page, 128);
        break;
    case 0x100:
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC read failed\n");
        break;
    default:
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE DDC unkown failure %i\n",
                       pVbe->pInt10->ax & 0xff00);
        break;
    }

 error:
    return tmp;
}

xf86MonPtr
vbeDoEDID(vbeInfoPtr pVbe, void *unused)
{
    unsigned char *DDC_data = NULL;

    if (!pVbe)
        return NULL;
    if (pVbe->version < 0x200)
        return NULL;

    DDC_data = vbeReadEDID(pVbe);

    if (!DDC_data)
        return NULL;

    return xf86InterpretEDID(pVbe->pInt10->pScrn->scrnIndex, DDC_data);
}

#define GET_UNALIGNED2(x) \
            ((*(CARD16*)(x)) | (*(((CARD16*)(x) + 1))) << 16)

VbeInfoBlock *
VBEGetVBEInfo(vbeInfoPtr pVbe)
{
    VbeInfoBlock *block = NULL;
    int i, pStr, pModes;
    char *str;
    CARD16 major, *modes;

    memset(pVbe->memory, 0, sizeof(VbeInfoBlock));

    /*
       Input:
       AH    := 4Fh     Super VGA support
       AL    := 00h     Return Super VGA information
       ES:DI := Pointer to buffer

       Output:
       AX    := status
       (All other registers are preserved)
     */

    ((char *) pVbe->memory)[0] = 'V';
    ((char *) pVbe->memory)[1] = 'B';
    ((char *) pVbe->memory)[2] = 'E';
    ((char *) pVbe->memory)[3] = '2';

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f00;
    pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
    pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return NULL;

    block = calloc(sizeof(VbeInfoBlock), 1);
    block->VESASignature[0] = ((char *) pVbe->memory)[0];
    block->VESASignature[1] = ((char *) pVbe->memory)[1];
    block->VESASignature[2] = ((char *) pVbe->memory)[2];
    block->VESASignature[3] = ((char *) pVbe->memory)[3];

    block->VESAVersion = *(CARD16 *) (((char *) pVbe->memory) + 4);
    major = (unsigned) block->VESAVersion >> 8;

    pStr = GET_UNALIGNED2((((char *) pVbe->memory) + 6));
    str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
    block->OEMStringPtr = strdup(str);

    block->Capabilities[0] = ((char *) pVbe->memory)[10];
    block->Capabilities[1] = ((char *) pVbe->memory)[11];
    block->Capabilities[2] = ((char *) pVbe->memory)[12];
    block->Capabilities[3] = ((char *) pVbe->memory)[13];

    pModes = GET_UNALIGNED2((((char *) pVbe->memory) + 14));
    modes = xf86int10Addr(pVbe->pInt10, FARP(pModes));
    i = 0;
    while (modes[i] != 0xffff)
        i++;
    block->VideoModePtr = xallocarray(i + 1, sizeof(CARD16));
    memcpy(block->VideoModePtr, modes, sizeof(CARD16) * i);
    block->VideoModePtr[i] = 0xffff;

    block->TotalMemory = *(CARD16 *) (((char *) pVbe->memory) + 18);

    if (major < 2)
        memcpy(&block->OemSoftwareRev, ((char *) pVbe->memory) + 20, 236);
    else {
        block->OemSoftwareRev = *(CARD16 *) (((char *) pVbe->memory) + 20);
        pStr = GET_UNALIGNED2((((char *) pVbe->memory) + 22));
        str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
        block->OemVendorNamePtr = strdup(str);
        pStr = GET_UNALIGNED2((((char *) pVbe->memory) + 26));
        str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
        block->OemProductNamePtr = strdup(str);
        pStr = GET_UNALIGNED2((((char *) pVbe->memory) + 30));
        str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
        block->OemProductRevPtr = strdup(str);
        memcpy(&block->Reserved, ((char *) pVbe->memory) + 34, 222);
        memcpy(&block->OemData, ((char *) pVbe->memory) + 256, 256);
    }

    return block;
}

void
VBEFreeVBEInfo(VbeInfoBlock * block)
{
    free(block->OEMStringPtr);
    free(block->VideoModePtr);
    if (((unsigned) block->VESAVersion >> 8) >= 2) {
        free(block->OemVendorNamePtr);
        free(block->OemProductNamePtr);
        free(block->OemProductRevPtr);
    }
    free(block);
}

Bool
VBESetVBEMode(vbeInfoPtr pVbe, int mode, VbeCRTCInfoBlock * block)
{
    /*
       Input:
       AH    := 4Fh     Super VGA support
       AL    := 02h     Set Super VGA video mode
       BX    := Video mode
       D0-D8  := Mode number
       D9-D10 := Reserved (must be 0)
       D11    := 0 Use current default refresh rate
       := 1 Use user specified CRTC values for refresh rate
       D12-13   Reserved for VBE/AF (must be 0)
       D14    := 0 Use windowed frame buffer model
       := 1 Use linear/flat frame buffer model
       D15    := 0 Clear video memory
       := 1 Don't clear video memory
       ES:DI := Pointer to VbeCRTCInfoBlock structure

       Output: AX = Status
       (All other registers are preserved)
     */
    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f02;
    pVbe->pInt10->bx = mode;
    if (block) {
        pVbe->pInt10->bx |= 1 << 11;
        memcpy(pVbe->memory, block, sizeof(VbeCRTCInfoBlock));
        pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
        pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);
    }
    else
        pVbe->pInt10->bx &= ~(1 << 11);

    xf86ExecX86int10(pVbe->pInt10);

    return (R16(pVbe->pInt10->ax) == 0x4f);
}

Bool
VBEGetVBEMode(vbeInfoPtr pVbe, int *mode)
{
    /*
       Input:
       AH := 4Fh        Super VGA support
       AL := 03h        Return current video mode

       Output:
       AX := Status
       BX := Current video mode
       (All other registers are preserved)
     */
    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f03;

    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) == 0x4f) {
        *mode = R16(pVbe->pInt10->bx);

        return TRUE;
    }

    return FALSE;
}

VbeModeInfoBlock *
VBEGetModeInfo(vbeInfoPtr pVbe, int mode)
{
    VbeModeInfoBlock *block = NULL;

    memset(pVbe->memory, 0, sizeof(VbeModeInfoBlock));

    /*
       Input:
       AH    := 4Fh     Super VGA support
       AL    := 01h     Return Super VGA mode information
       CX    :=         Super VGA video mode
       (mode number must be one of those returned by Function 0)
       ES:DI := Pointer to buffer

       Output:
       AX    := status
       (All other registers are preserved)
     */
    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f01;
    pVbe->pInt10->cx = mode;
    pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
    pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);
    xf86ExecX86int10(pVbe->pInt10);
    if (R16(pVbe->pInt10->ax) != 0x4f)
        return NULL;

    block = malloc(sizeof(VbeModeInfoBlock));
    if (block)
        memcpy(block, pVbe->memory, sizeof(*block));

    return block;
}

void
VBEFreeModeInfo(VbeModeInfoBlock * block)
{
    free(block);
}

Bool
VBESaveRestore(vbeInfoPtr pVbe, vbeSaveRestoreFunction function,
               void **memory, int *size, int *real_mode_pages)
{
    /*
       Input:
       AH    := 4Fh     Super VGA support
       AL    := 04h     Save/restore Super VGA video state
       DL    := 00h     Return save/restore state buffer size
       CX    := Requested states
       D0 = Save/restore video hardware state
       D1 = Save/restore video BIOS data state
       D2 = Save/restore video DAC state
       D3 = Save/restore Super VGA state

       Output:
       AX = Status
       BX = Number of 64-byte blocks to hold the state buffer
       (All other registers are preserved)

       Input:
       AH    := 4Fh     Super VGA support
       AL    := 04h     Save/restore Super VGA video state
       DL    := 01h     Save Super VGA video state
       CX    := Requested states (see above)
       ES:BX := Pointer to buffer

       Output:
       AX    := Status
       (All other registers are preserved)

       Input:
       AH    := 4Fh     Super VGA support
       AL    := 04h     Save/restore Super VGA video state
       DL    := 02h     Restore Super VGA video state
       CX    := Requested states (see above)
       ES:BX := Pointer to buffer

       Output:
       AX     := Status
       (All other registers are preserved)
     */

    if ((pVbe->version & 0xff00) > 0x100) {
        int screen = pVbe->pInt10->pScrn->scrnIndex;

        if (function == MODE_QUERY || (function == MODE_SAVE && !*memory)) {
            /* Query amount of memory to save state */

            pVbe->pInt10->num = 0x10;
            pVbe->pInt10->ax = 0x4f04;
            pVbe->pInt10->dx = 0;
            pVbe->pInt10->cx = 0x000f;
            xf86ExecX86int10(pVbe->pInt10);
            if (R16(pVbe->pInt10->ax) != 0x4f)
                return FALSE;

            if (function == MODE_SAVE) {
                int npages = (R16(pVbe->pInt10->bx) * 64) / 4096 + 1;

                if ((*memory = xf86Int10AllocPages(pVbe->pInt10, npages,
                                                   real_mode_pages)) == NULL) {
                    xf86DrvMsg(screen, X_ERROR,
                               "Cannot allocate memory to save SVGA state.\n");
                    return FALSE;
                }
            }
            *size = pVbe->pInt10->bx * 64;
        }

        /* Save/Restore Super VGA state */
        if (function != MODE_QUERY) {

            if (!*memory)
                return FALSE;
            pVbe->pInt10->num = 0x10;
            pVbe->pInt10->ax = 0x4f04;
            switch (function) {
            case MODE_SAVE:
                pVbe->pInt10->dx = 1;
                break;
            case MODE_RESTORE:
                pVbe->pInt10->dx = 2;
                break;
            case MODE_QUERY:
                return FALSE;
            }
            pVbe->pInt10->cx = 0x000f;

            pVbe->pInt10->es = SEG_ADDR(*real_mode_pages);
            pVbe->pInt10->bx = SEG_OFF(*real_mode_pages);
            xf86ExecX86int10(pVbe->pInt10);
            return (R16(pVbe->pInt10->ax) == 0x4f);

        }
    }
    return TRUE;
}

Bool
VBEBankSwitch(vbeInfoPtr pVbe, unsigned int iBank, int window)
{
    /*
       Input:
       AH    := 4Fh     Super VGA support
       AL    := 05h

       Output:
     */
    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f05;
    pVbe->pInt10->bx = window;
    pVbe->pInt10->dx = iBank;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return FALSE;

    return TRUE;
}

Bool
VBESetGetLogicalScanlineLength(vbeInfoPtr pVbe, vbeScanwidthCommand command,
                               int width, int *pixels, int *bytes, int *max)
{
    if (command < SCANWID_SET || command > SCANWID_GET_MAX)
        return FALSE;

    /*
       Input:
       AX := 4F06h VBE Set/Get Logical Scan Line Length
       BL := 00h Set Scan Line Length in Pixels
       := 01h Get Scan Line Length
       := 02h Set Scan Line Length in Bytes
       := 03h Get Maximum Scan Line Length
       CX := If BL=00h Desired Width in Pixels
       If BL=02h Desired Width in Bytes
       (Ignored for Get Functions)

       Output:
       AX := VBE Return Status
       BX := Bytes Per Scan Line
       CX := Actual Pixels Per Scan Line
       (truncated to nearest complete pixel)
       DX := Maximum Number of Scan Lines
     */

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f06;
    pVbe->pInt10->bx = command;
    if (command == SCANWID_SET || command == SCANWID_SET_BYTES)
        pVbe->pInt10->cx = width;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return FALSE;

    if (command == SCANWID_GET || command == SCANWID_GET_MAX) {
        if (pixels)
            *pixels = R16(pVbe->pInt10->cx);
        if (bytes)
            *bytes = R16(pVbe->pInt10->bx);
        if (max)
            *max = R16(pVbe->pInt10->dx);
    }

    return TRUE;
}

Bool
VBESetDisplayStart(vbeInfoPtr pVbe, int x, int y, Bool wait_retrace)
{
    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f07;
    pVbe->pInt10->bx = wait_retrace ? 0x80 : 0x00;
    pVbe->pInt10->cx = x;
    pVbe->pInt10->dx = y;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return FALSE;

    return TRUE;
}

Bool
VBEGetDisplayStart(vbeInfoPtr pVbe, int *x, int *y)
{
    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f07;
    pVbe->pInt10->bx = 0x01;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return FALSE;

    *x = pVbe->pInt10->cx;
    *y = pVbe->pInt10->dx;

    return TRUE;
}

int
VBESetGetDACPaletteFormat(vbeInfoPtr pVbe, int bits)
{
    /*
       Input:
       AX := 4F08h VBE Set/Get Palette Format
       BL := 00h Set DAC Palette Format
       := 01h Get DAC Palette Format
       BH := Desired bits of color per primary
       (Set DAC Palette Format only)

       Output:
       AX := VBE Return Status
       BH := Current number of bits of color per primary
     */

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f08;
    if (!bits)
        pVbe->pInt10->bx = 0x01;
    else
        pVbe->pInt10->bx = (bits & 0x00ff) << 8;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return 0;

    return (bits != 0 ? bits : (pVbe->pInt10->bx >> 8) & 0x00ff);
}

CARD32 *
VBESetGetPaletteData(vbeInfoPtr pVbe, Bool set, int first, int num,
                     CARD32 *data, Bool secondary, Bool wait_retrace)
{
    /*
       Input:
       (16-bit)
       AX    := 4F09h VBE Load/Unload Palette Data
       BL    := 00h Set Palette Data
       := 01h Get Palette Data
       := 02h Set Secondary Palette Data
       := 03h Get Secondary Palette Data
       := 80h Set Palette Data during Vertical Retrace
       CX    := Number of palette registers to update (to a maximum of 256)
       DX    := First of the palette registers to update (start)
       ES:DI := Table of palette values (see below for format)

       Output:
       AX    := VBE Return Status

       Input:
       (32-bit)
       BL     := 00h Set Palette Data
       := 80h Set Palette Data during Vertical Retrace
       CX     := Number of palette registers to update (to a maximum of 256)
       DX     := First of the palette registers to update (start)
       ES:EDI := Table of palette values (see below for format)
       DS     := Selector for memory mapped registers
     */

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f09;
    if (!secondary)
        pVbe->pInt10->bx = set && wait_retrace ? 0x80 : set ? 0 : 1;
    else
        pVbe->pInt10->bx = set ? 2 : 3;
    pVbe->pInt10->cx = num;
    pVbe->pInt10->dx = first;
    pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
    pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);
    if (set)
        memcpy(pVbe->memory, data, num * sizeof(CARD32));
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return NULL;

    if (set)
        return data;

    data = xallocarray(num, sizeof(CARD32));
    memcpy(data, pVbe->memory, num * sizeof(CARD32));

    return data;
}

VBEpmi *
VBEGetVBEpmi(vbeInfoPtr pVbe)
{
    VBEpmi *pmi;

    /*
       Input:
       AH    := 4Fh     Super VGA support
       AL    := 0Ah     Protected Mode Interface
       BL    := 00h     Return Protected Mode Table

       Output:
       AX    := Status
       ES    := Real Mode Segment of Table
       DI    := Offset of Table
       CX    := Lenght of Table including protected mode code in bytes (for copying purposes)
       (All other registers are preserved)
     */

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f0a;
    pVbe->pInt10->bx = 0;
    pVbe->pInt10->di = 0;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return NULL;

    pmi = malloc(sizeof(VBEpmi));
    pmi->seg_tbl = R16(pVbe->pInt10->es);
    pmi->tbl_off = R16(pVbe->pInt10->di);
    pmi->tbl_len = R16(pVbe->pInt10->cx);

    return pmi;
}

#if 0
vbeModeInfoPtr
VBEBuildVbeModeList(vbeInfoPtr pVbe, VbeInfoBlock * vbe)
{
    vbeModeInfoPtr ModeList = NULL;

    int i = 0;

    while (vbe->VideoModePtr[i] != 0xffff) {
        vbeModeInfoPtr m;
        VbeModeInfoBlock *mode;
        int id = vbe->VideoModePtr[i++];
        int bpp;

        if ((mode = VBEGetModeInfo(pVbe, id)) == NULL)
            continue;

        bpp = mode->BitsPerPixel;

        m = xnfcalloc(sizeof(vbeModeInfoRec), 1);
        m->width = mode->XResolution;
        m->height = mode->YResolution;
        m->bpp = bpp;
        m->n = id;
        m->next = ModeList;

        xf86DrvMsgVerb(pVbe->pInt10->pScrn->scrnIndex, X_PROBED, 3,
                       "BIOS reported VESA mode 0x%x: x:%i y:%i bpp:%i\n",
                       m->n, m->width, m->height, m->bpp);

        ModeList = m;

        VBEFreeModeInfo(mode);
    }
    return ModeList;
}

unsigned short
VBECalcVbeModeIndex(vbeModeInfoPtr m, DisplayModePtr mode, int bpp)
{
    while (m) {
        if (bpp == m->bpp
            && mode->HDisplay == m->width && mode->VDisplay == m->height)
            return m->n;
        m = m->next;
    }
    return 0;
}
#endif

void
VBEVesaSaveRestore(vbeInfoPtr pVbe, vbeSaveRestorePtr vbe_sr,
                   vbeSaveRestoreFunction function)
{
    Bool SaveSucc = FALSE;

    if (VBE_VERSION_MAJOR(pVbe->version) > 1
        && (function == MODE_SAVE || vbe_sr->pstate)) {
        if (function == MODE_RESTORE)
            memcpy(vbe_sr->state, vbe_sr->pstate, vbe_sr->stateSize);
        ErrorF("VBESaveRestore\n");
        if ((VBESaveRestore(pVbe, function,
                            (void *) &vbe_sr->state,
                            &vbe_sr->stateSize, &vbe_sr->statePage))) {
            if (function == MODE_SAVE) {
                SaveSucc = TRUE;
                vbe_sr->stateMode = -1; /* invalidate */
                /* don't rely on the memory not being touched */
                if (vbe_sr->pstate == NULL)
                    vbe_sr->pstate = malloc(vbe_sr->stateSize);
                memcpy(vbe_sr->pstate, vbe_sr->state, vbe_sr->stateSize);
            }
            ErrorF("VBESaveRestore done with success\n");
            return;
        }
        ErrorF("VBESaveRestore done\n");
    }

    if (function == MODE_SAVE && !SaveSucc)
        (void) VBEGetVBEMode(pVbe, &vbe_sr->stateMode);

    if (function == MODE_RESTORE && vbe_sr->stateMode != -1)
        VBESetVBEMode(pVbe, vbe_sr->stateMode, NULL);

}

int
VBEGetPixelClock(vbeInfoPtr pVbe, int mode, int clock)
{
    /*
       Input:
       AX := 4F0Bh VBE Get Pixel Clock
       BL := 00h Get Pixel Clock
       ECX := pixel clock in units of Hz
       DX := mode number

       Output:
       AX := VBE Return Status
       ECX := Closest pixel clock
     */

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f0b;
    pVbe->pInt10->bx = 0x00;
    pVbe->pInt10->cx = clock;
    pVbe->pInt10->dx = mode;
    xf86ExecX86int10(pVbe->pInt10);

    if (R16(pVbe->pInt10->ax) != 0x4f)
        return 0;

    return pVbe->pInt10->cx;
}

Bool
VBEDPMSSet(vbeInfoPtr pVbe, int mode)
{
    /*
       Input:
       AX := 4F10h DPMS
       BL := 01h Set Display Power State
       BH := requested power state

       Output:
       AX := VBE Return Status
     */

    pVbe->pInt10->num = 0x10;
    pVbe->pInt10->ax = 0x4f10;
    pVbe->pInt10->bx = 0x01;
    switch (mode) {
    case DPMSModeOn:
        break;
    case DPMSModeStandby:
        pVbe->pInt10->bx |= 0x100;
        break;
    case DPMSModeSuspend:
        pVbe->pInt10->bx |= 0x200;
        break;
    case DPMSModeOff:
        pVbe->pInt10->bx |= 0x400;
        break;
    }
    xf86ExecX86int10(pVbe->pInt10);
    return (R16(pVbe->pInt10->ax) == 0x4f);
}

void
VBEInterpretPanelID(ScrnInfoPtr pScrn, struct vbePanelID *data)
{
    DisplayModePtr mode;
    const float PANEL_HZ = 60.0;

    if (!data)
        return;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PanelID returned panel resolution %dx%d\n",
               data->hsize, data->vsize);

    if (pScrn->monitor->nHsync || pScrn->monitor->nVrefresh)
        return;

    if (data->hsize < 320 || data->vsize < 240) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "...which I refuse to believe\n");
        return;
    }

    mode = xf86CVTMode(data->hsize, data->vsize, PANEL_HZ, 1, 0);

    pScrn->monitor->nHsync = 1;
    pScrn->monitor->hsync[0].lo = 29.37;
    pScrn->monitor->hsync[0].hi = (float) mode->Clock / (float) mode->HTotal;
    pScrn->monitor->nVrefresh = 1;
    pScrn->monitor->vrefresh[0].lo = 56.0;
    pScrn->monitor->vrefresh[0].hi =
        (float) mode->Clock * 1000.0 / (float) mode->HTotal /
        (float) mode->VTotal;

    if (pScrn->monitor->vrefresh[0].hi < 59.47)
        pScrn->monitor->vrefresh[0].hi = 59.47;

    free(mode);
}

struct vbePanelID *
VBEReadPanelID(vbeInfoPtr pVbe)
{
    int RealOff = pVbe->real_mode_base;
    void *page = pVbe->memory;
    void *tmp = NULL;
    int screen = pVbe->pInt10->pScrn->scrnIndex;

    pVbe->pInt10->ax = 0x4F11;
    pVbe->pInt10->bx = 0x01;
    pVbe->pInt10->cx = 0;
    pVbe->pInt10->dx = 0;
    pVbe->pInt10->es = SEG_ADDR(RealOff);
    pVbe->pInt10->di = SEG_OFF(RealOff);
    pVbe->pInt10->num = 0x10;

    xf86ExecX86int10(pVbe->pInt10);

    if ((pVbe->pInt10->ax & 0xff) != 0x4f) {
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE PanelID invalid\n");
        goto error;
    }

    switch (pVbe->pInt10->ax & 0xff00) {
    case 0x0:
        xf86DrvMsgVerb(screen, X_INFO, 3,
                       "VESA VBE PanelID read successfully\n");
        tmp = xnfalloc(32);
        memcpy(tmp, page, 32);
        break;
    case 0x100:
        xf86DrvMsgVerb(screen, X_INFO, 3, "VESA VBE PanelID read failed\n");
        break;
    default:
        xf86DrvMsgVerb(screen, X_INFO, 3,
                       "VESA VBE PanelID unknown failure %i\n",
                       pVbe->pInt10->ax & 0xff00);
        break;
    }

 error:
    return tmp;
}
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d400 1
a400 1
    block->VideoModePtr = malloc(sizeof(CARD16) * (i + 1));
d828 1
a828 1
    data = malloc(num * sizeof(CARD32));
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d6 1
a6 1
 * The mode query/save/set/restore functions from the vesa driver 
d9 1
a9 1
 * Authors: Paulo César Pereira de Andrade <pcpa@@conectiva.com.br> 
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d53 1
a53 1
    pointer page = NULL;
d262 1
a262 1
    pointer page = pVbe->memory;
d322 1
a322 1
vbeDoEDID(vbeInfoPtr pVbe, pointer unused)
d548 1
a548 1
               pointer *memory, int *size, int *real_mode_pages)
d932 1
a932 1
                            (pointer) &vbe_sr->state,
d1058 1
a1058 1
    pointer page = pVbe->memory;
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d19 1
d322 1
a322 1
vbeDoEDID(vbeInfoPtr pVbe, pointer pDDCModule)
a323 2
    xf86MonPtr pMonitor;
    pointer pModule;
a330 7
    if (!(pModule = pDDCModule)) {
        pModule =
            xf86LoadSubModule(pVbe->pInt10->pScrn, "ddc");
        if (!pModule)
            return NULL;
    }

d336 1
a336 5
    pMonitor = xf86InterpretEDID(pVbe->pInt10->pScrn->scrnIndex, DDC_data);

    if (!pDDCModule)
        xf86UnloadSubModule(pModule);
    return pMonitor;
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d182 1
a182 1
    int screen = pVbe->pInt10->scrnIndex;
d265 2
a266 1
    int screen = pVbe->pInt10->scrnIndex;
d274 1
a274 1
    xf86ProcessOptions(screen, xf86Screens[screen]->options, options);
d334 1
a334 1
            xf86LoadSubModule(xf86Screens[pVbe->pInt10->scrnIndex], "ddc");
d344 1
a344 1
    pMonitor = xf86InterpretEDID(pVbe->pInt10->scrnIndex, DDC_data);
d602 1
a602 1
        int screen = pVbe->pInt10->scrnIndex;
d908 1
a908 1
        xf86DrvMsgVerb(pVbe->pInt10->scrnIndex, X_PROBED, 3,
d1030 1
a1030 1
VBEInterpretPanelID(int scrnIndex, struct vbePanelID *data)
a1031 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1038 1
a1038 1
    xf86DrvMsg(scrnIndex, X_INFO, "PanelID returned panel resolution %dx%d\n",
d1045 1
a1045 1
        xf86DrvMsg(scrnIndex, X_INFO, "...which I refuse to believe\n");
d1072 1
a1072 1
    int screen = pVbe->pInt10->scrnIndex;
@


1.9
log
@Bugfix Update to xserver 1.11.3
@
text
@d25 1
a25 1
#define B_O16(x)  (x) 
d37 1
a37 1
static unsigned char * vbeReadEDID(vbeInfoPtr pVbe);
d59 2
a60 1
    if (!pScrn) return NULL;
d62 1
a62 1
    
d64 9
a72 2
	if (!xf86LoadSubModule(pScrn, "int10"))
	    goto error;
d74 5
a78 11
	xf86DrvMsg(screen,X_INFO,"initializing int10\n");
	pInt = xf86ExtendedInitInt10(entityIndex,Flags);
	if (!pInt)
	    goto error;
	init_int10 = TRUE;
    }
    
    page = xf86Int10AllocPages(pInt,1,&RealOff);
    if (!page) goto error;
    vbe = (vbeControllerInfoPtr) page;    
    memcpy(vbe->VbeSignature,vbeVersionString,4);
d84 1
a84 1
    
d88 2
a89 2
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA BIOS not detected\n");
	goto error;
d91 1
a91 1
    
d94 2
a95 2
	xf86DrvMsg(screen,X_INFO,"VESA BIOS detected\n");
	break;
d97 2
a98 2
	xf86DrvMsg(screen,X_INFO,"VESA BIOS function failed\n");
	goto error;
d100 2
a101 2
	xf86DrvMsg(screen,X_INFO,"VESA BIOS not supported\n");
	goto error;
d103 2
a104 2
	xf86DrvMsg(screen,X_INFO,"VESA BIOS not supported in current mode\n");
	goto error;
d106 2
a107 2
	xf86DrvMsg(screen,X_INFO,"Invalid\n");
	goto error;
d109 1
a109 1
    
d111 15
a125 15
		"VbeVersion is %d, OemStringPtr is 0x%08lx,\n"
		"\tOemVendorNamePtr is 0x%08lx, OemProductNamePtr is 0x%08lx,\n"
		"\tOemProductRevPtr is 0x%08lx\n",
		vbe->VbeVersion, (unsigned long)vbe->OemStringPtr,
		(unsigned long)vbe->OemVendorNamePtr,
		(unsigned long)vbe->OemProductNamePtr,
		(unsigned long)vbe->OemProductRevPtr);

    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE Version %i.%i\n",
		   VERSION(vbe->VbeVersion));
    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE Total Mem: %i kB\n",
		   vbe->TotalMem * 64);
    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE OEM: %s\n",
		   (CARD8*)xf86int10Addr(pInt,L_ADD(vbe->OemStringPtr)));
    
d127 17
a143 11
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE OEM Software Rev: %i.%i\n",
		    VERSION(vbe->OemSoftwareRev));
	if (vbe->OemVendorNamePtr)
	    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE OEM Vendor: %s\n",
		    (CARD8*)xf86int10Addr(pInt,L_ADD(vbe->OemVendorNamePtr)));
	if (vbe->OemProductNamePtr)
	    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE OEM Product: %s\n",
		    (CARD8*)xf86int10Addr(pInt,L_ADD(vbe->OemProductNamePtr)));
	if (vbe->OemProductRevPtr)
	    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE OEM Product Rev: %s\n",
		    (CARD8*)xf86int10Addr(pInt,L_ADD(vbe->OemProductRevPtr)));
d145 1
a145 1
    vip = (vbeInfoPtr)xnfalloc(sizeof(vbeInfoRec));
d158 1
a158 1
	xf86Int10FreePages(pInt, page, 1);
d160 1
a160 1
	xf86FreeInt10(pInt);
d168 1
a168 1
	return;
d170 1
a170 1
    xf86Int10FreePages(pVbe->pInt10,pVbe->memory,pVbe->num_pages);
d172 2
a173 2
    if (pVbe->init_int10) 
	xf86FreeInt10(pVbe->pInt10);
d181 1
a181 1
    char *ddc_level;
d183 1
a183 1
    
d185 1
a185 1
	return FALSE;
d187 1
a187 1
	return TRUE;
d199 3
a201 3
        xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC not supported\n");
	pVbe->ddc = DDC_NONE;
	return FALSE;
d206 35
a240 34
	xf86DrvMsg(screen,X_INFO,"VESA VBE DDC supported\n");
	switch (pVbe->pInt10->bx & 0x3) {
	case 0:
  	    ddc_level = " none"; 
	    pVbe->ddc = DDC_NONE;
	    break;
	case 1:
  	    ddc_level = " 1";
	    pVbe->ddc = DDC_1;
	    break;
	case 2:
  	    ddc_level = " 2"; 
	    pVbe->ddc = DDC_2;
	    break;
	case 3:
  	    ddc_level = " 1 + 2"; 
	    pVbe->ddc = DDC_1_2;
	    break;
	default:
 	    ddc_level = "";
	    pVbe->ddc = DDC_NONE;
	    break;
	}
  	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC Level%s\n",ddc_level); 
  	if (pVbe->pInt10->bx & 0x4) {
    	    xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC Screen blanked" 
    			"for data transfer\n"); 
    	    pVbe->ddc_blank = TRUE;
    	}  else
    	    pVbe->ddc_blank = FALSE;
	    
  	xf86DrvMsgVerb(screen,X_INFO,3,
		       "VESA VBE DDC transfer in appr. %x sec.\n", 
		       (pVbe->pInt10->bx >> 8) & 0xff); 
d242 2
a243 2
    
    return TRUE; 
d247 1
a247 1
  VBEOPT_NOVBE,
d252 3
a254 3
    { VBEOPT_NOVBE,	"NoVBE",	OPTV_BOOLEAN,	{0},	FALSE },
    { VBEOPT_NODDC,	"NoDDC",	OPTV_BOOLEAN,	{0},	FALSE },
    { -1,		NULL,		OPTV_NONE,	{0},	FALSE },
d268 2
a269 1
    if (!page) return NULL;
d272 1
a272 1
    (void)memcpy(options, VBEOptions, sizeof(VBEOptions));
d277 2
a278 3
    if (novbe || noddc) return NULL;
    
    if (!vbeProbeDDC(pVbe)) goto error;
d280 5
a284 2
    memset(page,0,sizeof(vbeInfoPtr));
    strcpy(page,vbeVersionString);
d297 2
a298 2
        xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC invalid\n");
	goto error;
d302 4
a305 4
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC read successfully\n");
  	tmp = (unsigned char *)xnfalloc(128); 
  	memcpy(tmp,page,128); 
	break;
d307 2
a308 2
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC read failed\n");	
	break;
d310 3
a312 3
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE DDC unkown failure %i\n",
		       pVbe->pInt10->ax & 0xff00);
	break;
d314 1
a314 1
    
d322 2
a323 2
    xf86MonPtr    pMonitor;
    pointer       pModule;
d325 3
a327 2
    
    if (!pVbe) return NULL;
d329 1
a329 1
	return NULL;
d332 4
a335 4
	pModule =
	    xf86LoadSubModule(xf86Screens[pVbe->pInt10->scrnIndex], "ddc");
	if (!pModule)
	    return NULL;
d337 1
a337 1
        
d340 3
a342 3
    if (!DDC_data) 
	return NULL;
    
d364 8
a371 8
    Input:
	AH    := 4Fh	Super VGA support
	AL    := 00h	Return Super VGA information
	ES:DI := Pointer to buffer

    Output:
	AX    := status
	(All other registers are preserved)
d374 4
a377 4
    ((char*)pVbe->memory)[0] = 'V';
    ((char*)pVbe->memory)[1] = 'B';
    ((char*)pVbe->memory)[2] = 'E';
    ((char*)pVbe->memory)[3] = '2';
d386 1
a386 1
	return NULL;
d389 4
a392 4
    block->VESASignature[0] = ((char*)pVbe->memory)[0];
    block->VESASignature[1] = ((char*)pVbe->memory)[1];
    block->VESASignature[2] = ((char*)pVbe->memory)[2];
    block->VESASignature[3] = ((char*)pVbe->memory)[3];
d394 2
a395 2
    block->VESAVersion = *(CARD16*)(((char*)pVbe->memory) + 4);
    major = (unsigned)block->VESAVersion >> 8;
d397 1
a397 1
    pStr = GET_UNALIGNED2((((char*)pVbe->memory) + 6));
d401 4
a404 4
    block->Capabilities[0] = ((char*)pVbe->memory)[10];
    block->Capabilities[1] = ((char*)pVbe->memory)[11];
    block->Capabilities[2] = ((char*)pVbe->memory)[12];
    block->Capabilities[3] = ((char*)pVbe->memory)[13];
d406 1
a406 1
    pModes = GET_UNALIGNED2((((char*)pVbe->memory) + 14));
d410 1
a410 1
	i++;
d415 1
a415 1
    block->TotalMemory = *(CARD16*)(((char*)pVbe->memory) + 18);
d418 1
a418 1
	memcpy(&block->OemSoftwareRev, ((char*)pVbe->memory) + 20, 236);
d420 12
a431 12
	block->OemSoftwareRev = *(CARD16*)(((char*)pVbe->memory) + 20);
	pStr = GET_UNALIGNED2((((char*)pVbe->memory) + 22));
	str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
	block->OemVendorNamePtr = strdup(str);
	pStr = GET_UNALIGNED2((((char*)pVbe->memory) + 26));
	str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
	block->OemProductNamePtr = strdup(str);
	pStr = GET_UNALIGNED2((((char*)pVbe->memory) + 30));
	str = xf86int10Addr(pVbe->pInt10, FARP(pStr));
	block->OemProductRevPtr = strdup(str);
	memcpy(&block->Reserved, ((char*)pVbe->memory) + 34, 222);
	memcpy(&block->OemData, ((char*)pVbe->memory) + 256, 256);
d438 1
a438 1
VBEFreeVBEInfo(VbeInfoBlock *block)
d442 4
a445 4
    if (((unsigned)block->VESAVersion >> 8) >= 2) {
	free(block->OemVendorNamePtr);
	free(block->OemProductNamePtr);
	free(block->OemProductRevPtr);
d451 1
a451 1
VBESetVBEMode(vbeInfoPtr pVbe, int mode, VbeCRTCInfoBlock *block)
d454 18
a471 18
    Input:
	AH    := 4Fh	Super VGA support
	AL    := 02h	Set Super VGA video mode
	BX    := Video mode
	    D0-D8  := Mode number
	    D9-D10 := Reserved (must be 0)
	    D11    := 0 Use current default refresh rate
		   := 1 Use user specified CRTC values for refresh rate
	    D12-13	Reserved for VBE/AF (must be 0)
	    D14    := 0 Use windowed frame buffer model
		   := 1 Use linear/flat frame buffer model
	    D15    := 0 Clear video memory
		   := 1 Don't clear video memory
	ES:DI := Pointer to VbeCRTCInfoBlock structure

    Output: AX = Status
	(All other registers are preserved)
    */
d476 7
a482 6
	pVbe->pInt10->bx |= 1 << 11;
	memcpy(pVbe->memory, block, sizeof(VbeCRTCInfoBlock));
	pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
	pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);
    } else
	pVbe->pInt10->bx &= ~(1 << 11);
d493 9
a501 9
    Input:
	AH := 4Fh	Super VGA support
	AL := 03h	Return current video mode

    Output:
	AX := Status
	BX := Current video mode
	(All other registers are preserved)
    */
d508 1
a508 1
	*mode = R16(pVbe->pInt10->bx);
d510 1
a510 1
	return TRUE;
d524 10
a533 10
    Input:
	AH    := 4Fh	Super VGA support
	AL    := 01h	Return Super VGA mode information
	CX    := 	Super VGA video mode
			(mode number must be one of those returned by Function 0)
	ES:DI := Pointer to buffer

    Output:
	AX    := status
	(All other registers are preserved)
d542 1
a542 1
	return NULL;
d546 1
a546 1
	memcpy(block, pVbe->memory, sizeof(*block));
d552 1
a552 1
VBEFreeModeInfo(VbeModeInfoBlock *block)
d558 2
a559 2
VBESaveRestore(vbeInfoPtr pVbe, vbeSaveRestoreFunction function, 
	       pointer *memory, int *size, int *real_mode_pages)
d562 36
a597 38
    Input:
	AH    := 4Fh	Super VGA support
	AL    := 04h	Save/restore Super VGA video state
	DL    := 00h	Return save/restore state buffer size
	CX    := Requested states
		D0 = Save/restore video hardware state
		D1 = Save/restore video BIOS data state
		D2 = Save/restore video DAC state
		D3 = Save/restore Super VGA state

    Output:
	AX = Status
	BX = Number of 64-byte blocks to hold the state buffer
	(All other registers are preserved)


    Input:
	AH    := 4Fh	Super VGA support
	AL    := 04h	Save/restore Super VGA video state
	DL    := 01h	Save Super VGA video state
	CX    := Requested states (see above)
	ES:BX := Pointer to buffer

    Output:
	AX    := Status
	(All other registers are preserved)


    Input:
	AH    := 4Fh	Super VGA support
	AL    := 04h	Save/restore Super VGA video state
	DL    := 02h	Restore Super VGA video state
	CX    := Requested states (see above)
	ES:BX := Pointer to buffer

    Output:
	AX     := Status
	(All other registers are preserved)
a601 46
        if (function == MODE_QUERY ||
	    (function == MODE_SAVE && !*memory)) {
	    /* Query amount of memory to save state */

	    pVbe->pInt10->num = 0x10;
	    pVbe->pInt10->ax = 0x4f04;
	    pVbe->pInt10->dx = 0;
	    pVbe->pInt10->cx = 0x000f;
	    xf86ExecX86int10(pVbe->pInt10);
	    if (R16(pVbe->pInt10->ax) != 0x4f)
	        return FALSE;

	    if (function == MODE_SAVE) {
	        int npages = (R16(pVbe->pInt10->bx) * 64) / 4096 + 1;
		if ((*memory = xf86Int10AllocPages(pVbe->pInt10, npages,
						   real_mode_pages)) == NULL) {
		    xf86DrvMsg(screen, X_ERROR,
			       "Cannot allocate memory to save SVGA state.\n");
		    return FALSE;
		}
	    }
	    *size = pVbe->pInt10->bx * 64;
	}

	/* Save/Restore Super VGA state */
	if (function != MODE_QUERY) {
	    
	    if (!*memory) return FALSE;
	    pVbe->pInt10->num = 0x10;
	    pVbe->pInt10->ax = 0x4f04;
	    switch (function) {
	    case MODE_SAVE:
	      pVbe->pInt10->dx = 1;
	      break;
	    case MODE_RESTORE:
	      pVbe->pInt10->dx = 2;
	      break;
	    case MODE_QUERY:
	      return FALSE;
	    }
	    pVbe->pInt10->cx = 0x000f;
	    
	    pVbe->pInt10->es = SEG_ADDR(*real_mode_pages);
	    pVbe->pInt10->bx = SEG_OFF(*real_mode_pages);
	    xf86ExecX86int10(pVbe->pInt10);
	    return (R16(pVbe->pInt10->ax) == 0x4f);
d603 49
a651 1
	}
d660 3
a662 3
    Input:
	AH    := 4Fh	Super VGA support
	AL    := 05h
d664 1
a664 1
    Output:
d673 1
a673 1
	return FALSE;
d680 1
a680 1
				int width, int *pixels, int *bytes, int *max)
d683 1
a683 1
	return FALSE;
d686 16
a701 16
    Input:
	AX := 4F06h VBE Set/Get Logical Scan Line Length
	BL := 00h Set Scan Line Length in Pixels
	   := 01h Get Scan Line Length
	   := 02h Set Scan Line Length in Bytes
	   := 03h Get Maximum Scan Line Length
	CX := If BL=00h Desired Width in Pixels
	      If BL=02h Desired Width in Bytes
	      (Ignored for Get Functions)

    Output:
	AX := VBE Return Status
	BX := Bytes Per Scan Line
	CX := Actual Pixels Per Scan Line
	      (truncated to nearest complete pixel)
	DX := Maximum Number of Scan Lines
d708 1
a708 1
	pVbe->pInt10->cx = width;
d712 1
a712 1
	return FALSE;
d715 6
a720 6
	if (pixels)
	    *pixels = R16(pVbe->pInt10->cx);
	if (bytes)
	    *bytes = R16(pVbe->pInt10->bx);
	if (max)
	    *max = R16(pVbe->pInt10->dx);
d737 1
a737 1
	return FALSE;
d751 1
a751 1
	return FALSE;
d763 10
a772 10
    Input:
	AX := 4F08h VBE Set/Get Palette Format
	BL := 00h Set DAC Palette Format
	   := 01h Get DAC Palette Format
	BH := Desired bits of color per primary
	      (Set DAC Palette Format only)

    Output:
	AX := VBE Return Status
	BH := Current number of bits of color per primary
d778 3
a780 3
	pVbe->pInt10->bx = 0x01;
    else 
	pVbe->pInt10->bx = (bits & 0x00ff) << 8;
d784 1
a784 1
	return 0;
d791 1
a791 1
		      CARD32 *data, Bool secondary, Bool wait_retrace)
d794 23
a816 24
    Input:
    (16-bit)
	AX    := 4F09h VBE Load/Unload Palette Data
	BL    := 00h Set Palette Data
	      := 01h Get Palette Data
	      := 02h Set Secondary Palette Data
	      := 03h Get Secondary Palette Data
	      := 80h Set Palette Data during Vertical Retrace
	CX    := Number of palette registers to update (to a maximum of 256)
	DX    := First of the palette registers to update (start)
	ES:DI := Table of palette values (see below for format)

    Output:
	AX    := VBE Return Status


    Input:
    (32-bit)
	BL     := 00h Set Palette Data
	       := 80h Set Palette Data during Vertical Retrace
	CX     := Number of palette registers to update (to a maximum of 256)
	DX     := First of the palette registers to update (start)
	ES:EDI := Table of palette values (see below for format)
	DS     := Selector for memory mapped registers
d822 1
a822 1
	pVbe->pInt10->bx = set && wait_retrace ? 0x80 : set ? 0 : 1;
d824 1
a824 1
	pVbe->pInt10->bx = set ? 2 : 3;
d830 1
a830 1
	memcpy(pVbe->memory, data, num * sizeof(CARD32));
d834 1
a834 1
	return NULL;
d837 1
a837 1
	return data;
d851 11
a861 11
    Input:
	AH    := 4Fh	Super VGA support
	AL    := 0Ah	Protected Mode Interface
	BL    := 00h	Return Protected Mode Table

    Output:
	AX    := Status
	ES    := Real Mode Segment of Table
	DI    := Offset of Table
	CX    := Lenght of Table including protected mode code in bytes (for copying purposes)
	(All other registers are preserved)
d871 1
a871 1
	return NULL;
d883 1
a883 1
VBEBuildVbeModeList(vbeInfoPtr pVbe, VbeInfoBlock *vbe)
d888 1
d890 20
a909 20
	vbeModeInfoPtr m;
	VbeModeInfoBlock *mode;
	int id = vbe->VideoModePtr[i++];
	int bpp;

	if ((mode = VBEGetModeInfo(pVbe, id)) == NULL)
	    continue;

 	bpp = mode->BitsPerPixel;

	m = xnfcalloc(sizeof(vbeModeInfoRec),1);
	m->width = mode->XResolution;
	m->height = mode->YResolution;
	m->bpp = bpp;
	m->n = id;
	m->next = ModeList;

	xf86DrvMsgVerb(pVbe->pInt10->scrnIndex, X_PROBED, 3,
		       "BIOS reported VESA mode 0x%x: x:%i y:%i bpp:%i\n",
		       m->n, m->width, m->height, m->bpp);
d911 1
a911 1
	ModeList = m;
d913 1
a913 1
	VBEFreeModeInfo(mode);
d918 1
a918 1
unsigned short 
d922 4
a925 5
	if (bpp == m->bpp 
	    && mode->HDisplay == m->width 
	    && mode->VDisplay == m->height)
	    return m->n;
	m = m->next;
d933 1
a933 1
		  vbeSaveRestoreFunction function)
d938 21
a958 21
	&& (function == MODE_SAVE || vbe_sr->pstate)) {
	if (function == MODE_RESTORE)
	    memcpy(vbe_sr->state, vbe_sr->pstate, vbe_sr->stateSize);
	ErrorF("VBESaveRestore\n");
	if ((VBESaveRestore(pVbe,function,
			    (pointer)&vbe_sr->state,
			    &vbe_sr->stateSize,&vbe_sr->statePage))) {
	    if (function == MODE_SAVE) {
		SaveSucc = TRUE;
		vbe_sr->stateMode = -1; /* invalidate */
		/* don't rely on the memory not being touched */
		if (vbe_sr->pstate == NULL)
		    vbe_sr->pstate = malloc(vbe_sr->stateSize);
		memcpy(vbe_sr->pstate, vbe_sr->state, vbe_sr->stateSize);
	    }
	    ErrorF("VBESaveRestore done with success\n");
	    return;
	}
	ErrorF("VBESaveRestore done\n");
    } 
    
d960 2
a961 2
	    (void)VBEGetVBEMode(pVbe, &vbe_sr->stateMode);
	
d963 1
a963 1
	    VBESetVBEMode(pVbe, vbe_sr->stateMode, NULL);
d971 9
a979 9
    Input:
	AX := 4F0Bh VBE Get Pixel Clock
	BL := 00h Get Pixel Clock
	ECX := pixel clock in units of Hz
        DX := mode number
     
    Output:
	AX := VBE Return Status
	ECX := Closest pixel clock
d990 1
a990 1
	return 0;
d999 7
a1005 7
    Input:
	AX := 4F10h DPMS
	BL := 01h Set Display Power State
	BH := requested power state
     
    Output:
	AX := VBE Return Status
d1013 1
a1013 1
	break;
d1015 2
a1016 2
	pVbe->pInt10->bx |= 0x100;
	break;
d1018 2
a1019 2
	pVbe->pInt10->bx |= 0x200;
	break;
d1021 2
a1022 2
	pVbe->pInt10->bx |= 0x400;
	break;
d1036 1
a1036 1
	return;
d1039 1
a1039 1
	    data->hsize, data->vsize);
d1042 1
a1042 1
	return;
d1045 2
a1046 2
	xf86DrvMsg(scrnIndex, X_INFO, "...which I refuse to believe\n");
	return;
d1053 1
a1053 1
    pScrn->monitor->hsync[0].hi = (float)mode->Clock / (float)mode->HTotal;
d1057 2
a1058 1
	(float)mode->Clock*1000.0 / (float)mode->HTotal / (float)mode->VTotal;
d1061 1
a1061 1
	pScrn->monitor->vrefresh[0].hi = 59.47;
d1085 2
a1086 2
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID invalid\n");
	goto error;
d1091 5
a1095 4
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID read successfully\n");
	tmp = xnfalloc(32); 
	memcpy(tmp, page, 32); 
	break;
d1097 2
a1098 2
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID read failed\n");       
	break;
d1100 4
a1103 3
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID unknown failure %i\n",
		       pVbe->pInt10->ax & 0xff00);
	break;
d1106 1
a1106 1
error:
@


1.8
log
@Update to xserver 1.11.2
@
text
@d1039 1
a1039 1
    pScrn->monitor->hsync[0].lo = 31.5;
d1045 3
@


1.7
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d1031 5
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d398 1
a398 1
    block->VideoModePtr = malloc(sizeof(CARD16) * i + 1);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a19 1
#include <X11/Xarch.h>
d166 1
a166 1
    xfree(pVbe);
d266 1
a266 1
    xfree(options);
d348 1
a348 1
    bzero(pVbe->memory, sizeof(VbeInfoBlock));
d373 1
a373 1
	return (NULL);
d375 1
a375 1
    block = xcalloc(sizeof(VbeInfoBlock), 1);
d398 1
a398 1
    block->VideoModePtr = xalloc(sizeof(CARD16) * i + 1);
d421 1
a421 1
    return (block);
d427 2
a428 2
    xfree(block->OEMStringPtr);
    xfree(block->VideoModePtr);
d430 3
a432 3
	xfree(block->OemVendorNamePtr);
	xfree(block->OemProductNamePtr);
	xfree(block->OemProductRevPtr);
d434 1
a434 1
    xfree(block);
d496 1
a496 1
	return (TRUE);
d499 1
a499 1
    return (FALSE);
d507 1
a507 1
    bzero(pVbe->memory, sizeof(VbeModeInfoBlock));
d528 1
a528 1
	return (NULL);
d530 3
a532 1
    block = xcalloc(sizeof(VbeModeInfoBlock), 1);
d534 1
a534 63
    block->ModeAttributes = *(CARD16*)pVbe->memory;
    block->WinAAttributes = ((char*)pVbe->memory)[2];
    block->WinBAttributes = ((char*)pVbe->memory)[3];
    block->WinGranularity = *(CARD16*)(((char*)pVbe->memory) + 4);
    block->WinSize = *(CARD16*)(((char*)pVbe->memory) + 6);
    block->WinASegment = *(CARD16*)(((char*)pVbe->memory) + 8);
    block->WinBSegment = *(CARD16*)(((char*)pVbe->memory) + 10);
    block->WinFuncPtr = *(CARD32*)(((char*)pVbe->memory) + 12);
    block->BytesPerScanline = *(CARD16*)(((char*)pVbe->memory) + 16);

    /* mandatory information for VBE 1.2 and above */
    block->XResolution = *(CARD16*)(((char*)pVbe->memory) + 18);
    block->YResolution = *(CARD16*)(((char*)pVbe->memory) + 20);
    block->XCharSize = ((char*)pVbe->memory)[22];
    block->YCharSize = ((char*)pVbe->memory)[23];
    block->NumberOfPlanes = ((char*)pVbe->memory)[24];
    block->BitsPerPixel = ((char*)pVbe->memory)[25];
    block->NumberOfBanks = ((char*)pVbe->memory)[26];
    block->MemoryModel = ((char*)pVbe->memory)[27];
    block->BankSize = ((char*)pVbe->memory)[28];
    block->NumberOfImages = ((char*)pVbe->memory)[29];
    block->Reserved = ((char*)pVbe->memory)[30];

    /* Direct color fields (required for direct/6 and YUV/7 memory models) */
    block->RedMaskSize = ((char*)pVbe->memory)[31];
    block->RedFieldPosition = ((char*)pVbe->memory)[32];
    block->GreenMaskSize = ((char*)pVbe->memory)[33];
    block->GreenFieldPosition = ((char*)pVbe->memory)[34];
    block->BlueMaskSize = ((char*)pVbe->memory)[35];
    block->BlueFieldPosition = ((char*)pVbe->memory)[36];
    block->RsvdMaskSize = ((char*)pVbe->memory)[37];
    block->RsvdFieldPosition = ((char*)pVbe->memory)[38];
    block->DirectColorModeInfo = ((char*)pVbe->memory)[39];

    /* Mandatory information for VBE 2.0 and above */
    if (pVbe->version >= 0x200) {
	block->PhysBasePtr = *(CARD32*)(((char*)pVbe->memory) + 40);
	block->Reserved32 = *(CARD32*)(((char*)pVbe->memory) + 44);
	block->Reserved16 = *(CARD16*)(((char*)pVbe->memory) + 48);

	/* Mandatory information for VBE 3.0 and above */
	if (pVbe->version >= 0x300) {
	    block->LinBytesPerScanLine = *(CARD16*)(((char*)pVbe->memory) + 50);
	    block->BnkNumberOfImagePages = ((char*)pVbe->memory)[52];
	    block->LinNumberOfImagePages = ((char*)pVbe->memory)[53];
	    block->LinRedMaskSize = ((char*)pVbe->memory)[54];
	    block->LinRedFieldPosition = ((char*)pVbe->memory)[55];
	    block->LinGreenMaskSize = ((char*)pVbe->memory)[56];
	    block->LinGreenFieldPosition = ((char*)pVbe->memory)[57];
	    block->LinBlueMaskSize = ((char*)pVbe->memory)[58];
	    block->LinBlueFieldPosition = ((char*)pVbe->memory)[59];
	    block->LinRsvdMaskSize = ((char*)pVbe->memory)[60];
	    block->LinRsvdFieldPosition = ((char*)pVbe->memory)[61];
	    block->MaxPixelClock = *(CARD32*)(((char*)pVbe->memory) + 62);
	    memcpy(&block->Reserved2, ((char*)pVbe->memory) + 66, 188);
	}
	else
	memcpy(&block->LinBytesPerScanLine, ((char*)pVbe->memory) + 50, 206);
    }
    else
	memcpy(&block->PhysBasePtr, ((char*)pVbe->memory) + 40, 216);

    return (block);
d540 1
a540 1
    xfree(block);
d600 1
a600 1
	        return (FALSE);
d608 1
a608 1
		    return (FALSE);
d659 1
a659 1
	return (FALSE);
d661 1
a661 1
    return (TRUE);
d669 1
a669 1
	return (FALSE);
d698 1
a698 1
	return (FALSE);
d709 1
a709 1
    return (TRUE);
d723 1
a723 1
	return (FALSE);
d725 1
a725 1
    return (TRUE);
d737 1
a737 1
	return (FALSE);
d742 1
a742 1
    return (TRUE);
d770 1
a770 1
	return (0);
d821 1
a821 1
	return (NULL);
d824 1
a824 1
	return (data);
d826 1
a826 1
    data = xalloc(num * sizeof(CARD32));
d829 1
a829 1
    return (data);
d858 1
a858 1
	return (NULL);
d860 1
a860 1
    pmi = xalloc(sizeof(VBEpmi));
d865 1
a865 1
    return (pmi);
d937 1
a937 1
		    vbe_sr->pstate = xalloc(vbe_sr->stateSize);
d977 1
a977 1
	return (0);
d979 1
a979 1
    return (pVbe->pInt10->cx);
d1041 1
a1041 1
    xfree(mode);
@


1.4
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a20 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
a21 4
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d21 3
d26 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d1111 1
a1111 1
    unsigned char *tmp = NULL;
d1132 2
a1133 2
	tmp = (unsigned char *)xnfalloc(32); 
	memcpy(tmp,page,32); 
@


1.1
log
@Initial revision
@
text
@d1022 1
a1022 1
	BL := 01h Get Pixel Clock
d1033 1
a1033 1
    pVbe->pInt10->bx = 0x01;
d1077 70
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a1076 70
void
VBEInterpretPanelID(int scrnIndex, struct vbePanelID *data)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    DisplayModePtr mode;
    const float PANEL_HZ = 60.0;

    if (!data)
	return;

    xf86DrvMsg(scrnIndex, X_INFO, "PanelID returned panel resolution %dx%d\n",
	    data->hsize, data->vsize);

    if (pScrn->monitor->nHsync || pScrn->monitor->nVrefresh)
	return;

    mode = xf86CVTMode(data->hsize, data->vsize, PANEL_HZ, 1, 0);

    pScrn->monitor->nHsync = 1;
    pScrn->monitor->hsync[0].lo = 31.5;
    pScrn->monitor->hsync[0].hi = (float)mode->Clock / (float)mode->HTotal;
    pScrn->monitor->nVrefresh = 1;
    pScrn->monitor->vrefresh[0].lo = 56.0;
    pScrn->monitor->vrefresh[0].hi =
	(float)mode->Clock*1000.0 / (float)mode->HTotal / (float)mode->VTotal;

    xfree(mode);
}

struct vbePanelID *
VBEReadPanelID(vbeInfoPtr pVbe)
{
    int RealOff = pVbe->real_mode_base;
    pointer page = pVbe->memory;
    unsigned char *tmp = NULL;
    int screen = pVbe->pInt10->scrnIndex;

    pVbe->pInt10->ax = 0x4F11;
    pVbe->pInt10->bx = 0x01;
    pVbe->pInt10->cx = 0;
    pVbe->pInt10->dx = 0;
    pVbe->pInt10->es = SEG_ADDR(RealOff);
    pVbe->pInt10->di = SEG_OFF(RealOff);
    pVbe->pInt10->num = 0x10;

    xf86ExecX86int10(pVbe->pInt10);

    if ((pVbe->pInt10->ax & 0xff) != 0x4f) {
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID invalid\n");
	goto error;
    }

    switch (pVbe->pInt10->ax & 0xff00) {
    case 0x0:
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID read successfully\n");
	tmp = (unsigned char *)xnfalloc(32); 
	memcpy(tmp,page,32); 
	break;
    case 0x100:
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID read failed\n");       
	break;
    default:
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID unknown failure %i\n",
		       pVbe->pInt10->ax & 0xff00);
	break;
    }

error:
    return tmp;
}
@

