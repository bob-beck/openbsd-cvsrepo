head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 1987, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * This is based on cfbcmap.c.  The functions here are useful independently
 * of cfb, which is the reason for including them here.  How "mi" these
 * are may be debatable.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "colormapst.h"
#include "resource.h"
#include "globals.h"
#include "micmap.h"

DevPrivateKeyRec micmapScrPrivateKeyRec;

int
miListInstalledColormaps(ScreenPtr pScreen, Colormap * pmaps)
{
    if (GetInstalledmiColormap(pScreen)) {
        *pmaps = GetInstalledmiColormap(pScreen)->mid;
        return 1;
    }
    return 0;
}

void
miInstallColormap(ColormapPtr pmap)
{
    ColormapPtr oldpmap = GetInstalledmiColormap(pmap->pScreen);

    if (pmap != oldpmap) {
        /* Uninstall pInstalledMap. No hardware changes required, just
         * notify all interested parties. */
        if (oldpmap != (ColormapPtr) None)
            WalkTree(pmap->pScreen, TellLostMap, (char *) &oldpmap->mid);
        /* Install pmap */
        SetInstalledmiColormap(pmap->pScreen, pmap);
        WalkTree(pmap->pScreen, TellGainedMap, (char *) &pmap->mid);

    }
}

void
miUninstallColormap(ColormapPtr pmap)
{
    ColormapPtr curpmap = GetInstalledmiColormap(pmap->pScreen);

    if (pmap == curpmap) {
        if (pmap->mid != pmap->pScreen->defColormap) {
            dixLookupResourceByType((void **) &curpmap,
                                    pmap->pScreen->defColormap,
                                    RT_COLORMAP, serverClient, DixUseAccess);
            (*pmap->pScreen->InstallColormap) (curpmap);
        }
    }
}

void
miResolveColor(unsigned short *pred, unsigned short *pgreen,
               unsigned short *pblue, VisualPtr pVisual)
{
    int shift = 16 - pVisual->bitsPerRGBValue;
    unsigned lim = (1 << pVisual->bitsPerRGBValue) - 1;

    if ((pVisual->class | DynamicClass) == GrayScale) {
        /* rescale to gray then rgb bits */
        *pred = (30L * *pred + 59L * *pgreen + 11L * *pblue) / 100;
        *pblue = *pgreen = *pred = ((*pred >> shift) * 65535) / lim;
    }
    else {
        /* rescale to rgb bits */
        *pred = ((*pred >> shift) * 65535) / lim;
        *pgreen = ((*pgreen >> shift) * 65535) / lim;
        *pblue = ((*pblue >> shift) * 65535) / lim;
    }
}

Bool
miInitializeColormap(ColormapPtr pmap)
{
    unsigned i;
    VisualPtr pVisual;
    unsigned lim, maxent, shift;

    pVisual = pmap->pVisual;
    lim = (1 << pVisual->bitsPerRGBValue) - 1;
    shift = 16 - pVisual->bitsPerRGBValue;
    maxent = pVisual->ColormapEntries - 1;
    if (pVisual->class == TrueColor) {
        unsigned limr, limg, limb;

        limr = pVisual->redMask >> pVisual->offsetRed;
        limg = pVisual->greenMask >> pVisual->offsetGreen;
        limb = pVisual->blueMask >> pVisual->offsetBlue;
        for (i = 0; i <= maxent; i++) {
            /* rescale to [0..65535] then rgb bits */
            pmap->red[i].co.local.red =
                ((((i * 65535) / limr) >> shift) * 65535) / lim;
            pmap->green[i].co.local.green =
                ((((i * 65535) / limg) >> shift) * 65535) / lim;
            pmap->blue[i].co.local.blue =
                ((((i * 65535) / limb) >> shift) * 65535) / lim;
        }
    }
    else if (pVisual->class == StaticColor) {
        unsigned limr, limg, limb;

        limr = pVisual->redMask >> pVisual->offsetRed;
        limg = pVisual->greenMask >> pVisual->offsetGreen;
        limb = pVisual->blueMask >> pVisual->offsetBlue;
        for (i = 0; i <= maxent; i++) {
            /* rescale to [0..65535] then rgb bits */
            pmap->red[i].co.local.red =
                ((((((i & pVisual->redMask) >> pVisual->offsetRed)
                    * 65535) / limr) >> shift) * 65535) / lim;
            pmap->red[i].co.local.green =
                ((((((i & pVisual->greenMask) >> pVisual->offsetGreen)
                    * 65535) / limg) >> shift) * 65535) / lim;
            pmap->red[i].co.local.blue =
                ((((((i & pVisual->blueMask) >> pVisual->offsetBlue)
                    * 65535) / limb) >> shift) * 65535) / lim;
        }
    }
    else if (pVisual->class == StaticGray) {
        for (i = 0; i <= maxent; i++) {
            /* rescale to [0..65535] then rgb bits */
            pmap->red[i].co.local.red = ((((i * 65535) / maxent) >> shift)
                                         * 65535) / lim;
            pmap->red[i].co.local.green = pmap->red[i].co.local.red;
            pmap->red[i].co.local.blue = pmap->red[i].co.local.red;
        }
    }
    return TRUE;
}

/* When simulating DirectColor on PseudoColor hardware, multiple
   entries of the colormap must be updated
 */

#define AddElement(mask) { \
    pixel = red | green | blue; \
    for (i = 0; i < nresult; i++) \
  	if (outdefs[i].pixel == pixel) \
    	    break; \
    if (i == nresult) \
    { \
   	nresult++; \
	outdefs[i].pixel = pixel; \
	outdefs[i].flags = 0; \
    } \
    outdefs[i].flags |= (mask); \
    outdefs[i].red = pmap->red[red >> pVisual->offsetRed].co.local.red; \
    outdefs[i].green = pmap->green[green >> pVisual->offsetGreen].co.local.green; \
    outdefs[i].blue = pmap->blue[blue >> pVisual->offsetBlue].co.local.blue; \
}

int
miExpandDirectColors(ColormapPtr pmap, int ndef, xColorItem * indefs,
                     xColorItem * outdefs)
{
    int red, green, blue;
    int maxred, maxgreen, maxblue;
    int stepred, stepgreen, stepblue;
    VisualPtr pVisual;
    int pixel;
    int nresult;
    int i;

    pVisual = pmap->pVisual;

    stepred = 1 << pVisual->offsetRed;
    stepgreen = 1 << pVisual->offsetGreen;
    stepblue = 1 << pVisual->offsetBlue;
    maxred = pVisual->redMask;
    maxgreen = pVisual->greenMask;
    maxblue = pVisual->blueMask;
    nresult = 0;
    for (; ndef--; indefs++) {
        if (indefs->flags & DoRed) {
            red = indefs->pixel & pVisual->redMask;
            for (green = 0; green <= maxgreen; green += stepgreen) {
                for (blue = 0; blue <= maxblue; blue += stepblue) {
                    AddElement(DoRed)
                }
            }
        }
        if (indefs->flags & DoGreen) {
            green = indefs->pixel & pVisual->greenMask;
            for (red = 0; red <= maxred; red += stepred) {
                for (blue = 0; blue <= maxblue; blue += stepblue) {
                    AddElement(DoGreen)
                }
            }
        }
        if (indefs->flags & DoBlue) {
            blue = indefs->pixel & pVisual->blueMask;
            for (red = 0; red <= maxred; red += stepred) {
                for (green = 0; green <= maxgreen; green += stepgreen) {
                    AddElement(DoBlue)
                }
            }
        }
    }
    return nresult;
}

Bool
miCreateDefColormap(ScreenPtr pScreen)
{
    unsigned short zero = 0, ones = 0xFFFF;
    Pixel wp, bp;
    VisualPtr pVisual;
    ColormapPtr cmap;
    int alloctype;

    if (!dixRegisterPrivateKey(&micmapScrPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    for (pVisual = pScreen->visuals;
         pVisual->vid != pScreen->rootVisual; pVisual++);

    if (pScreen->rootDepth == 1 || (pVisual->class & DynamicClass))
        alloctype = AllocNone;
    else
        alloctype = AllocAll;

    if (CreateColormap(pScreen->defColormap, pScreen, pVisual, &cmap,
                       alloctype, 0) != Success)
        return FALSE;

    if (pScreen->rootDepth > 1) {
        wp = pScreen->whitePixel;
        bp = pScreen->blackPixel;
        if ((AllocColor(cmap, &ones, &ones, &ones, &wp, 0) !=
             Success) ||
            (AllocColor(cmap, &zero, &zero, &zero, &bp, 0) != Success))
            return FALSE;
        pScreen->whitePixel = wp;
        pScreen->blackPixel = bp;
    }

    (*pScreen->InstallColormap) (cmap);
    return TRUE;
}

/*
 * Default true color bitmasks, should be overridden by
 * driver
 */

#define _RZ(d) ((d + 2) / 3)
#define _RS(d) 0
#define _RM(d) ((1 << _RZ(d)) - 1)
#define _GZ(d) ((d - _RZ(d) + 1) / 2)
#define _GS(d) _RZ(d)
#define _GM(d) (((1 << _GZ(d)) - 1) << _GS(d))
#define _BZ(d) (d - _RZ(d) - _GZ(d))
#define _BS(d) (_RZ(d) + _GZ(d))
#define _BM(d) (((1 << _BZ(d)) - 1) << _BS(d))
#define _CE(d) (1 << _RZ(d))

typedef struct _miVisuals {
    struct _miVisuals *next;
    int depth;
    int bitsPerRGB;
    int visuals;
    int count;
    int preferredCVC;
    Pixel redMask, greenMask, blueMask;
} miVisualsRec, *miVisualsPtr;

static int miVisualPriority[] = {
    PseudoColor, GrayScale, StaticColor, TrueColor, DirectColor, StaticGray
};

#define NUM_PRIORITY	6

static miVisualsPtr miVisuals;

void
miClearVisualTypes(void)
{
    miVisualsPtr v;

    while ((v = miVisuals)) {
        miVisuals = v->next;
        free(v);
    }
}

Bool
miSetVisualTypesAndMasks(int depth, int visuals, int bitsPerRGB,
                         int preferredCVC,
                         Pixel redMask, Pixel greenMask, Pixel blueMask)
{
    miVisualsPtr new, *prev, v;
    int count;

    new = malloc(sizeof *new);
    if (!new)
        return FALSE;
    if (!redMask || !greenMask || !blueMask) {
        redMask = _RM(depth);
        greenMask = _GM(depth);
        blueMask = _BM(depth);
    }
    new->next = 0;
    new->depth = depth;
    new->visuals = visuals;
    new->bitsPerRGB = bitsPerRGB;
    new->preferredCVC = preferredCVC;
    new->redMask = redMask;
    new->greenMask = greenMask;
    new->blueMask = blueMask;
    count = (visuals >> 1) & 033333333333;
    count = visuals - count - ((count >> 1) & 033333333333);
    count = (((count + (count >> 3)) & 030707070707) % 077);    /* HAKMEM 169 */
    new->count = count;
    for (prev = &miVisuals; (v = *prev); prev = &v->next);
    *prev = new;
    return TRUE;
}

Bool
miSetVisualTypes(int depth, int visuals, int bitsPerRGB, int preferredCVC)
{
    return miSetVisualTypesAndMasks(depth, visuals, bitsPerRGB,
                                    preferredCVC, 0, 0, 0);
}

int
miGetDefaultVisualMask(int depth)
{
    if (depth > MAX_PSEUDO_DEPTH)
        return LARGE_VISUALS;
    else if (depth >= MIN_TRUE_DEPTH)
        return ALL_VISUALS;
    else if (depth == 1)
        return StaticGrayMask;
    else
        return SMALL_VISUALS;
}

static Bool
miVisualTypesSet(int depth)
{
    miVisualsPtr visuals;

    for (visuals = miVisuals; visuals; visuals = visuals->next)
        if (visuals->depth == depth)
            return TRUE;
    return FALSE;
}

Bool
miSetPixmapDepths(void)
{
    int d, f;

    /* Add any unlisted depths from the pixmap formats */
    for (f = 0; f < screenInfo.numPixmapFormats; f++) {
        d = screenInfo.formats[f].depth;
        if (!miVisualTypesSet(d)) {
            if (!miSetVisualTypes(d, 0, 0, -1))
                return FALSE;
        }
    }
    return TRUE;
}

/*
 * Distance to least significant one bit
 */
static int
maskShift(Pixel p)
{
    int s;

    if (!p)
        return 0;
    s = 0;
    while (!(p & 1)) {
        s++;
        p >>= 1;
    }
    return s;
}

/*
 * Given a list of formats for a screen, create a list
 * of visuals and depths for the screen which corespond to
 * the set which can be used with this version of cfb.
 */

Bool
miInitVisuals(VisualPtr * visualp, DepthPtr * depthp, int *nvisualp,
              int *ndepthp, int *rootDepthp, VisualID * defaultVisp,
              unsigned long sizes, int bitsPerRGB, int preferredVis)
{
    int i, j = 0, k;
    VisualPtr visual;
    DepthPtr depth;
    VisualID *vid;
    int d, b;
    int f;
    int ndepth, nvisual;
    int nvtype;
    int vtype;
    miVisualsPtr visuals, nextVisuals;
    int *preferredCVCs, *prefp;
    int first_depth;

    /* none specified, we'll guess from pixmap formats */
    if (!miVisuals) {
        for (f = 0; f < screenInfo.numPixmapFormats; f++) {
            d = screenInfo.formats[f].depth;
            b = screenInfo.formats[f].bitsPerPixel;
            if (sizes & (1 << (b - 1)))
                vtype = miGetDefaultVisualMask(d);
            else
                vtype = 0;
            if (!miSetVisualTypes(d, vtype, bitsPerRGB, -1))
                return FALSE;
        }
    }
    nvisual = 0;
    ndepth = 0;
    for (visuals = miVisuals; visuals; visuals = nextVisuals) {
        nextVisuals = visuals->next;
        ndepth++;
        nvisual += visuals->count;
    }
    depth = xallocarray(ndepth, sizeof(DepthRec));
    visual = xallocarray(nvisual, sizeof(VisualRec));
    preferredCVCs = xallocarray(ndepth, sizeof(int));
    if (!depth || !visual || !preferredCVCs) {
        free(depth);
        free(visual);
        free(preferredCVCs);
        return FALSE;
    }
    *depthp = depth;
    *visualp = visual;
    *ndepthp = ndepth;
    *nvisualp = nvisual;
    prefp = preferredCVCs;
    for (visuals = miVisuals; visuals; visuals = nextVisuals) {
        nextVisuals = visuals->next;
        d = visuals->depth;
        vtype = visuals->visuals;
        nvtype = visuals->count;
        *prefp = visuals->preferredCVC;
        prefp++;
        vid = NULL;
        if (nvtype) {
            vid = xallocarray(nvtype, sizeof(VisualID));
            if (!vid) {
                free(depth);
                free(visual);
                free(preferredCVCs);
                return FALSE;
            }
        }
        depth->depth = d;
        depth->numVids = nvtype;
        depth->vids = vid;
        depth++;
        for (i = 0; i < NUM_PRIORITY; i++) {
            if (!(vtype & (1 << miVisualPriority[i])))
                continue;
            visual->class = miVisualPriority[i];
            visual->bitsPerRGBValue = visuals->bitsPerRGB;
            visual->ColormapEntries = 1 << d;
            visual->nplanes = d;
            visual->vid = *vid = FakeClientID(0);
            switch (visual->class) {
            case PseudoColor:
            case GrayScale:
            case StaticGray:
                visual->redMask = 0;
                visual->greenMask = 0;
                visual->blueMask = 0;
                visual->offsetRed = 0;
                visual->offsetGreen = 0;
                visual->offsetBlue = 0;
                break;
            case DirectColor:
            case TrueColor:
                visual->ColormapEntries = _CE(d);
                /* fall through */
            case StaticColor:
                visual->redMask = visuals->redMask;
                visual->greenMask = visuals->greenMask;
                visual->blueMask = visuals->blueMask;
                visual->offsetRed = maskShift(visuals->redMask);
                visual->offsetGreen = maskShift(visuals->greenMask);
                visual->offsetBlue = maskShift(visuals->blueMask);
            }
            vid++;
            visual++;
        }
        free(visuals);
    }
    miVisuals = NULL;
    visual = *visualp;
    depth = *depthp;

    /*
     * if we did not supplyied by a preferred visual class
     * check if there is a preferred class in one of the depth
     * structures - if there is, we want to start looking for the
     * default visual/depth from that depth.
     */
    first_depth = 0;
    if (preferredVis < 0 && defaultColorVisualClass < 0) {
        for (i = 0; i < ndepth; i++) {
            if (preferredCVCs[i] >= 0) {
                first_depth = i;
                break;
            }
        }
    }

    for (i = first_depth; i < ndepth; i++) {
        int prefColorVisualClass = -1;

        if (defaultColorVisualClass >= 0)
            prefColorVisualClass = defaultColorVisualClass;
        else if (preferredVis >= 0)
            prefColorVisualClass = preferredVis;
        else if (preferredCVCs[i] >= 0)
            prefColorVisualClass = preferredCVCs[i];

        if (*rootDepthp && *rootDepthp != depth[i].depth)
            continue;

        for (j = 0; j < depth[i].numVids; j++) {
            for (k = 0; k < nvisual; k++)
                if (visual[k].vid == depth[i].vids[j])
                    break;
            if (k == nvisual)
                continue;
            if (prefColorVisualClass < 0 ||
                visual[k].class == prefColorVisualClass)
                break;
        }
        if (j != depth[i].numVids)
            break;
    }
    if (i == ndepth) {
        i = 0;
        j = 0;
    }
    *rootDepthp = depth[i].depth;
    *defaultVisp = depth[i].vids[j];
    free(preferredCVCs);

    return TRUE;
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d461 3
a463 3
    depth = malloc(ndepth * sizeof(DepthRec));
    visual = malloc(nvisual * sizeof(VisualRec));
    preferredCVCs = malloc(ndepth * sizeof(int));
d484 1
a484 1
            vid = malloc(nvtype * sizeof(VisualID));
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a237 34
/* 
 * In the following sources PC X server vendors may want to delete 
 * "_not_tog" from "#ifdef WIN32_not_tog"
 */
#ifdef WIN32_not_tog
    /*  
     * these are the MS-Windows desktop colors, adjusted for X's 16-bit 
     * color specifications.
     */
    static xColorItem citems[] = {
        {0, 0, 0, 0, 0, 0},
        {1, 0x8000, 0, 0, 0, 0},
        {2, 0, 0x8000, 0, 0, 0},
        {3, 0x8000, 0x8000, 0, 0, 0},
        {4, 0, 0, 0x8000, 0, 0},
        {5, 0x8000, 0, 0x8000, 0, 0},
        {6, 0, 0x8000, 0x8000, 0, 0},
        {7, 0xc000, 0xc000, 0xc000, 0, 0},
        {8, 0xc000, 0xdc00, 0xc000, 0, 0},
        {9, 0xa600, 0xca00, 0xf000, 0, 0},
        {246, 0xff00, 0xfb00, 0xf000, 0, 0},
        {247, 0xa000, 0xa000, 0xa400, 0, 0},
        {248, 0x8000, 0x8000, 0x8000, 0, 0},
        {249, 0xff00, 0, 0, 0, 0},
        {250, 0, 0xff00, 0, 0, 0},
        {251, 0xff00, 0xff00, 0, 0, 0},
        {252, 0, 0, 0xff00, 0, 0},
        {253, 0xff00, 0, 0xff00, 0, 0},
        {254, 0, 0xff00, 0xff00, 0, 0},
        {255, 0xff00, 0xff00, 0xff00, 0, 0}
    };
#define NUM_DESKTOP_COLORS sizeof citems / sizeof citems[0]
    int i;
#else
a238 1
#endif
a261 8
#ifdef WIN32_not_tog
        for (i = 0; i < NUM_DESKTOP_COLORS; i++) {
            if (AllocColor(cmap,
                           &citems[i].red, &citems[i].green, &citems[i].blue,
                           &citems[i].pixel, 0) != Success)
                return FALSE;
        }
#else
a267 1
#endif
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d78 1
a78 1
            dixLookupResourceByType((pointer *) &curpmap,
@


1.5
log
@Update to xserver 1.11.2
@
text
@a29 1

d45 1
a45 1
miListInstalledColormaps(ScreenPtr pScreen, Colormap *pmaps)
d48 2
a49 2
	*pmaps = GetInstalledmiColormap(pScreen)->mid;
	return 1;
d59 8
a66 9
    if(pmap != oldpmap)
    {
	/* Uninstall pInstalledMap. No hardware changes required, just
	 * notify all interested parties. */
	if(oldpmap != (ColormapPtr)None)
	    WalkTree(pmap->pScreen, TellLostMap, (char *)&oldpmap->mid);
	/* Install pmap */
	SetInstalledmiColormap(pmap->pScreen, pmap);
	WalkTree(pmap->pScreen, TellGainedMap, (char *)&pmap->mid);
d76 7
a82 10
    if(pmap == curpmap)
    {
	if (pmap->mid != pmap->pScreen->defColormap)
	{
	    dixLookupResourceByType((pointer *)&curpmap,
				    pmap->pScreen->defColormap,
				    RT_COLORMAP, serverClient,
				    DixUseAccess);
	    (*pmap->pScreen->InstallColormap)(curpmap);
	}
d88 1
a88 1
		unsigned short *pblue, VisualPtr pVisual)
d93 10
a102 12
    if ((pVisual->class | DynamicClass) == GrayScale)
    {
	/* rescale to gray then rgb bits */
	*pred = (30L * *pred + 59L * *pgreen + 11L * *pblue) / 100;
	*pblue = *pgreen = *pred = ((*pred >> shift) * 65535) / lim;
    }
    else
    {
	/* rescale to rgb bits */
	*pred = ((*pred >> shift) * 65535) / lim;
	*pgreen = ((*pgreen >> shift) * 65535) / lim;
	*pblue = ((*pblue >> shift) * 65535) / lim;
d117 43
a159 49
    if (pVisual->class == TrueColor)
    {
	unsigned limr, limg, limb;

	limr = pVisual->redMask >> pVisual->offsetRed;
	limg = pVisual->greenMask >> pVisual->offsetGreen;
	limb = pVisual->blueMask >> pVisual->offsetBlue;
	for(i = 0; i <= maxent; i++)
	{
	    /* rescale to [0..65535] then rgb bits */
	    pmap->red[i].co.local.red =
		((((i * 65535) / limr) >> shift) * 65535) / lim;
	    pmap->green[i].co.local.green =
		((((i * 65535) / limg) >> shift) * 65535) / lim;
	    pmap->blue[i].co.local.blue =
		((((i * 65535) / limb) >> shift) * 65535) / lim;
	}
    }
    else if (pVisual->class == StaticColor)
    {
	unsigned limr, limg, limb;

	limr = pVisual->redMask >> pVisual->offsetRed;
	limg = pVisual->greenMask >> pVisual->offsetGreen;
	limb = pVisual->blueMask >> pVisual->offsetBlue;
	for(i = 0; i <= maxent; i++)
	{
	    /* rescale to [0..65535] then rgb bits */
	    pmap->red[i].co.local.red =
		((((((i & pVisual->redMask) >> pVisual->offsetRed)
		    * 65535) / limr) >> shift) * 65535) / lim;
	    pmap->red[i].co.local.green =
		((((((i & pVisual->greenMask) >> pVisual->offsetGreen)
		    * 65535) / limg) >> shift) * 65535) / lim;
	    pmap->red[i].co.local.blue =
		((((((i & pVisual->blueMask) >> pVisual->offsetBlue)
		    * 65535) / limb) >> shift) * 65535) / lim;
	}
    }
    else if (pVisual->class == StaticGray)
    {
	for(i = 0; i <= maxent; i++)
	{
	    /* rescale to [0..65535] then rgb bits */
	    pmap->red[i].co.local.red = ((((i * 65535) / maxent) >> shift)
					 * 65535) / lim;
	    pmap->red[i].co.local.green = pmap->red[i].co.local.red;
	    pmap->red[i].co.local.blue = pmap->red[i].co.local.red;
	}
d186 2
a187 2
miExpandDirectColors(ColormapPtr pmap, int ndef, xColorItem *indefs,
			xColorItem *outdefs)
d189 7
a195 7
    int	        red, green, blue;
    int	        maxred, maxgreen, maxblue;
    int	        stepred, stepgreen, stepblue;
    VisualPtr   pVisual;
    int         pixel;
    int         nresult;
    int         i;
d206 25
a230 35
    for (;ndef--; indefs++)
    {
	if (indefs->flags & DoRed)
	{
	    red = indefs->pixel & pVisual->redMask;
    	    for (green = 0; green <= maxgreen; green += stepgreen)
    	    {
	    	for (blue = 0; blue <= maxblue; blue += stepblue)
	    	{
		    AddElement (DoRed)
	    	}
    	    }
	}
	if (indefs->flags & DoGreen)
	{
	    green = indefs->pixel & pVisual->greenMask;
    	    for (red = 0; red <= maxred; red += stepred)
    	    {
	    	for (blue = 0; blue <= maxblue; blue += stepblue)
	    	{
		    AddElement (DoGreen)
	    	}
    	    }
	}
	if (indefs->flags & DoBlue)
	{
	    blue = indefs->pixel & pVisual->blueMask;
    	    for (red = 0; red <= maxred; red += stepred)
    	    {
	    	for (green = 0; green <= maxgreen; green += stepgreen)
	    	{
		    AddElement (DoBlue)
	    	}
    	    }
	}
d248 20
a267 20
	{   0,      0,      0,      0, 0, 0 },
	{   1, 0x8000,      0,      0, 0, 0 },
	{   2,      0, 0x8000,      0, 0, 0 },
	{   3, 0x8000, 0x8000,      0, 0, 0 },
	{   4,      0,      0, 0x8000, 0, 0 },
	{   5, 0x8000,      0, 0x8000, 0, 0 },
	{   6,      0, 0x8000, 0x8000, 0, 0 },
	{   7, 0xc000, 0xc000, 0xc000, 0, 0 },
	{   8, 0xc000, 0xdc00, 0xc000, 0, 0 },
	{   9, 0xa600, 0xca00, 0xf000, 0, 0 },
	{ 246, 0xff00, 0xfb00, 0xf000, 0, 0 },
	{ 247, 0xa000, 0xa000, 0xa400, 0, 0 },
	{ 248, 0x8000, 0x8000, 0x8000, 0, 0 },
	{ 249, 0xff00,      0,      0, 0, 0 },
	{ 250,      0, 0xff00,      0, 0, 0 },
	{ 251, 0xff00, 0xff00,      0, 0, 0 },
	{ 252,      0,      0, 0xff00, 0, 0 },
	{ 253, 0xff00,      0, 0xff00, 0, 0 },
	{ 254,      0, 0xff00, 0xff00, 0, 0 },
	{ 255, 0xff00, 0xff00, 0xff00, 0, 0 }
d272 1
a272 1
    unsigned short	zero = 0, ones = 0xFFFF;
d275 2
a276 2
    VisualPtr	pVisual;
    ColormapPtr	cmap;
d278 1
a278 1
    
d280 1
a280 1
	return FALSE;
d283 1
a283 3
	 pVisual->vid != pScreen->rootVisual;
	 pVisual++)
	;
d286 1
a286 1
	alloctype = AllocNone;
d288 1
a288 1
	alloctype = AllocAll;
d291 2
a292 2
		       alloctype, 0) != Success)
	return FALSE;
d295 2
a296 2
	wp = pScreen->whitePixel;
	bp = pScreen->blackPixel;
d298 6
a303 6
	for (i = 0; i < NUM_DESKTOP_COLORS; i++) {
	    if (AllocColor (cmap,
			    &citems[i].red, &citems[i].green, &citems[i].blue,
			    &citems[i].pixel, 0) != Success)
		return FALSE;
	}
d305 6
a310 7
	if ((AllocColor(cmap, &ones, &ones, &ones, &wp, 0) !=
       	       Success) ||
	    (AllocColor(cmap, &zero, &zero, &zero, &bp, 0) !=
       	       Success))
    	    return FALSE;
	pScreen->whitePixel = wp;
	pScreen->blackPixel = bp;
d314 1
a314 1
    (*pScreen->InstallColormap)(cmap);
d335 7
a341 7
    struct _miVisuals	*next;
    int			depth;
    int			bitsPerRGB;
    int			visuals;
    int			count;
    int			preferredCVC;
    Pixel		redMask, greenMask, blueMask;
d344 1
a344 1
static int  miVisualPriority[] = {
d350 1
a350 1
static miVisualsPtr	miVisuals;
d358 2
a359 2
	miVisuals = v->next;
	free(v);
a362 1

d364 3
a366 3
miSetVisualTypesAndMasks(int depth, int visuals, int bitsPerRGB, 
			 int preferredCVC,
			 Pixel redMask, Pixel greenMask, Pixel blueMask)
d368 2
a369 2
    miVisualsPtr   new, *prev, v;
    int		    count;
d373 5
a377 6
	return FALSE;
    if (!redMask || !greenMask || !blueMask)
    {
	redMask = _RM(depth);
	greenMask = _GM(depth);
	blueMask = _BM(depth);
d389 1
a389 1
    count = (((count + (count >> 3)) & 030707070707) % 077);	/* HAKMEM 169 */
d399 2
a400 2
    return miSetVisualTypesAndMasks (depth, visuals, bitsPerRGB,
				     preferredCVC, 0, 0, 0);
d407 1
a407 1
	return LARGE_VISUALS;
d409 1
a409 1
	return ALL_VISUALS;
d411 1
a411 1
	return StaticGrayMask;
d413 1
a413 1
	return SMALL_VISUALS;
d417 1
a417 1
miVisualTypesSet (int depth)
d419 1
a419 1
    miVisualsPtr    visuals;
d422 2
a423 2
	if (visuals->depth == depth)
	    return TRUE;
d428 1
a428 1
miSetPixmapDepths (void)
d430 2
a431 2
    int	d, f;
    
d433 6
a438 8
    for (f = 0; f < screenInfo.numPixmapFormats; f++) 
    {
	d = screenInfo.formats[f].depth;
	if (!miVisualTypesSet (d))
	{
	    if (!miSetVisualTypes (d, 0, 0, -1))
		return FALSE;
	}
d447 1
a447 1
maskShift (Pixel p)
d449 1
a449 1
    int	s;
d451 2
a452 1
    if (!p) return 0;
d454 3
a456 4
    while (!(p & 1))
    {
	s++;
	p >>= 1;
d468 16
a483 17
miInitVisuals(VisualPtr *visualp, DepthPtr *depthp, int *nvisualp,
		int *ndepthp, int *rootDepthp, VisualID *defaultVisp,
		unsigned long sizes, int bitsPerRGB, int preferredVis)

{
    int		i, j = 0, k;
    VisualPtr	visual;
    DepthPtr	depth;
    VisualID	*vid;
    int		d, b;
    int		f;
    int		ndepth, nvisual;
    int		nvtype;
    int		vtype;
    miVisualsPtr   visuals, nextVisuals;
    int		*preferredCVCs, *prefp;
    int		first_depth;
d486 11
a496 13
    if (!miVisuals) 
    {
    	for (f = 0; f < screenInfo.numPixmapFormats; f++) 
    	{
	    d = screenInfo.formats[f].depth;
	    b = screenInfo.formats[f].bitsPerPixel;
	    if (sizes & (1 << (b - 1)))
		vtype = miGetDefaultVisualMask(d);
	    else
		vtype = 0;
	    if (!miSetVisualTypes (d, vtype, bitsPerRGB, -1))
		return FALSE;
    	}
d500 4
a503 5
    for (visuals = miVisuals; visuals; visuals = nextVisuals) 
    {
	nextVisuals = visuals->next;
	ndepth++;
	nvisual += visuals->count;
d505 2
a506 2
    depth = malloc(ndepth * sizeof (DepthRec));
    visual = malloc(nvisual * sizeof (VisualRec));
d508 5
a512 6
    if (!depth || !visual || !preferredCVCs)
    {
	free(depth);
	free(visual);
	free(preferredCVCs);
	return FALSE;
d519 56
a574 58
    for (visuals = miVisuals; visuals; visuals = nextVisuals) 
    {
	nextVisuals = visuals->next;
	d = visuals->depth;
	vtype = visuals->visuals;
	nvtype = visuals->count;
	*prefp = visuals->preferredCVC;
	prefp++;
	vid = NULL;
	if (nvtype)
	{
	    vid = malloc(nvtype * sizeof (VisualID));
	    if (!vid) {
	        free(depth);
	        free(visual);
		free(preferredCVCs);
		return FALSE;
	    }
	}
	depth->depth = d;
	depth->numVids = nvtype;
	depth->vids = vid;
	depth++;
	for (i = 0; i < NUM_PRIORITY; i++) {
	    if (! (vtype & (1 << miVisualPriority[i])))
		continue;
	    visual->class = miVisualPriority[i];
	    visual->bitsPerRGBValue = visuals->bitsPerRGB;
	    visual->ColormapEntries = 1 << d;
	    visual->nplanes = d;
	    visual->vid = *vid = FakeClientID (0);
	    switch (visual->class) {
	    case PseudoColor:
	    case GrayScale:
	    case StaticGray:
		visual->redMask = 0;
		visual->greenMask =  0;
		visual->blueMask =  0;
		visual->offsetRed  =  0;
		visual->offsetGreen = 0;
		visual->offsetBlue =  0;
		break;
	    case DirectColor:
	    case TrueColor:
		visual->ColormapEntries = _CE(d);
		/* fall through */
	    case StaticColor:
		visual->redMask =  visuals->redMask;
		visual->greenMask =  visuals->greenMask;
		visual->blueMask =  visuals->blueMask;
		visual->offsetRed  =  maskShift (visuals->redMask);
		visual->offsetGreen = maskShift (visuals->greenMask);
		visual->offsetBlue =  maskShift (visuals->blueMask);
	    }
	    vid++;
	    visual++;
	}
	free(visuals);
d587 34
a620 36
    if (preferredVis < 0 && defaultColorVisualClass < 0 ) {
       for (i = 0; i < ndepth; i++) {
	  if (preferredCVCs[i] >= 0) {
	     first_depth = i;
	     break;
	  }
       }
    }

    for (i = first_depth; i < ndepth; i++)
    {
	int prefColorVisualClass = -1;

	if (defaultColorVisualClass >= 0)
	    prefColorVisualClass = defaultColorVisualClass;
	else if (preferredVis >= 0)
	    prefColorVisualClass = preferredVis;
	else if (preferredCVCs[i] >= 0)
	    prefColorVisualClass = preferredCVCs[i];

	if (*rootDepthp && *rootDepthp != depth[i].depth)
	    continue;
	
	for (j = 0; j < depth[i].numVids; j++)
	{
	    for (k = 0; k < nvisual; k++)
		if (visual[k].vid == depth[i].vids[j])
		    break;
	    if (k == nvisual)
		continue;
	    if (prefColorVisualClass < 0 ||
		visual[k].class == prefColorVisualClass)
		break;
	}
	if (j != depth[i].numVids)
	    break;
d623 2
a624 2
	i = 0;
	j = 0;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright Â© 1987 Sun Microsystems, Inc.  All rights reserved.
d567 2
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d43 1
a43 1
ColormapPtr miInstalledMaps[MAXSCREENS];
d48 3
a50 3
    if (miInstalledMaps[pScreen->myNum]) {
	*pmaps = miInstalledMaps[pScreen->myNum]->mid;
	return (1);
d58 1
a58 2
    int index = pmap->pScreen->myNum;
    ColormapPtr oldpmap = miInstalledMaps[index];
d67 1
a67 1
	miInstalledMaps[index] = pmap;
d76 1
a76 2
    int index = pmap->pScreen->myNum;
    ColormapPtr curpmap = miInstalledMaps[index];
d302 3
d385 1
a385 1
	xfree(v);
d398 1
a398 1
    new = xalloc (sizeof *new);
d539 3
a541 3
    depth = xalloc (ndepth * sizeof (DepthRec));
    visual = xalloc (nvisual * sizeof (VisualRec));
    preferredCVCs = xalloc(ndepth * sizeof(int));
d544 3
a546 3
	xfree (depth);
	xfree (visual);
	xfree (preferredCVCs);
d565 1
a565 1
	    vid = xalloc (nvtype * sizeof (VisualID));
d567 1
a567 1
		xfree(preferredCVCs);
d609 1
a609 1
	xfree (visuals);
d665 1
a665 1
    xfree(preferredCVCs);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1 22
a22 28
/************************************************************
Copyright 1987 by Sun Microsystems, Inc. Mountain View, CA.

                    All Rights Reserved

Permission  to  use,  copy,  modify,  and  distribute   this
software  and  its documentation for any purpose and without
fee is hereby granted, provided that the above copyright no-
tice  appear  in all copies and that both that copyright no-
tice and this permission notice appear in  supporting  docu-
mentation,  and  that the names of Sun or X Consortium
not be used in advertising or publicity pertaining to 
distribution  of  the software  without specific prior 
written permission. Sun and X Consortium make no 
representations about the suitability of this software for 
any purpose. It is provided "as is" without any express or 
implied warranty.

SUN DISCLAIMS ALL WARRANTIES WITH REGARD TO  THIS  SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-
NESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SUN BE  LI-
ABLE  FOR  ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  DATA  OR
PROFITS,  WHETHER  IN  AN  ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/
d43 1
a43 1
_X_EXPORT ColormapPtr miInstalledMaps[MAXSCREENS];
d45 1
a45 1
_X_EXPORT int
d55 1
a55 1
_X_EXPORT void
d74 1
a74 1
_X_EXPORT void
d84 4
a87 2
	    curpmap = (ColormapPtr) LookupIDByType(pmap->pScreen->defColormap,
						   RT_COLORMAP);
d93 1
a93 1
_X_EXPORT void
d115 1
a115 1
_X_EXPORT Bool
d200 1
a200 1
_X_EXPORT int
d260 1
a260 1
_X_EXPORT Bool
d377 1
a377 1
_X_EXPORT void
d389 1
a389 1
_X_EXPORT Bool
d397 1
a397 1
    new = (miVisualsPtr) xalloc (sizeof *new);
d423 1
a423 1
_X_EXPORT Bool
d430 1
a430 1
_X_EXPORT int
d454 1
a454 1
_X_EXPORT Bool
d496 1
a496 1
_X_EXPORT Bool
d538 3
a540 3
    depth = (DepthPtr) xalloc (ndepth * sizeof (DepthRec));
    visual = (VisualPtr) xalloc (nvisual * sizeof (VisualRec));
    preferredCVCs = (int *)xalloc(ndepth * sizeof(int));
d564 1
a564 1
	    vid = (VisualID *) xalloc (nvtype * sizeof (VisualID));
@


1.1
log
@Initial revision
@
text
@a50 6
static Bool miDoInitVisuals(VisualPtr *visualp, DepthPtr *depthp, int *nvisualp,
		int *ndepthp, int *rootDepthp, VisualID *defaultVisp,
		unsigned long sizes, int bitsPerRGB, int preferredVis);

_X_EXPORT miInitVisualsProcPtr miInitVisualsProc = miDoInitVisuals;

d122 2
a123 2
    register unsigned i;
    register VisualPtr pVisual;
d208 7
a214 7
    register int    red, green, blue;
    int		    maxred, maxgreen, maxblue;
    int		    stepred, stepgreen, stepblue;
    VisualPtr	    pVisual;
    register int    pixel;
    register int    nresult;
    register int    i;
d382 1
a382 1
miClearVisualTypes()
a475 14
_X_EXPORT Bool
miInitVisuals(VisualPtr *visualp, DepthPtr *depthp, int *nvisualp,
		int *ndepthp, int *rootDepthp, VisualID *defaultVisp,
		unsigned long sizes, int bitsPerRGB, int preferredVis)

{
    if (miInitVisualsProc)
	return miInitVisualsProc(visualp, depthp, nvisualp, ndepthp,
				 rootDepthp, defaultVisp, sizes, bitsPerRGB,
				 preferredVis);
    else
	return FALSE;
}

d500 2
a501 2
static Bool
miDoInitVisuals(VisualPtr *visualp, DepthPtr *depthp, int *nvisualp,
d504 1
a671 7

void
miResetInitVisuals()
{
    miInitVisualsProc = miDoInitVisuals;
}

@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d128 2
a129 2
    unsigned i;
    VisualPtr pVisual;
d214 7
a220 7
    int	        red, green, blue;
    int	        maxred, maxgreen, maxblue;
    int	        stepred, stepgreen, stepblue;
    VisualPtr   pVisual;
    int         pixel;
    int         nresult;
    int         i;
d388 1
a388 1
miClearVisualTypes(void)
d693 1
a693 1
miResetInitVisuals(void)
@

