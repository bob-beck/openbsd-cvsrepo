head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.4
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.2
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.08.09.18.59.54;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	6HLO5qdN5N4nPDjW;

1.17
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	s0SI41sEunLdyFfd;

1.16
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	Te1daavkBLskZ8gc;

1.15
date	2014.12.21.11.41.45;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	OOAr3LJJfv7DyAHR;

1.14
date	2014.12.09.17.58.53;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	vcnjRBuLQw44cPHf;

1.13
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.10;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.11;	author matthieu;	state Exp;
branches;
next	;

1.11.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.12.2.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.18
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, provided that the above
copyright notice(s) and this permission notice appear in all copies of
the Software and that both the above copyright notice(s) and this
permission notice appear in supporting documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.

X Window System is a trademark of The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include <X11/Xauth.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "site.h"
#include <errno.h>
#include <sys/types.h>
#ifndef WIN32
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <ctype.h>

#ifndef NO_LOCAL_CLIENT_CRED
#include <pwd.h>
#endif

#if defined(TCPCONN) || defined(STREAMSCONN)
#include <netinet/in.h>
#endif                          /* TCPCONN || STREAMSCONN */

#ifdef HAVE_GETPEERUCRED
#include <ucred.h>
#ifdef sun
#include <zone.h>
#endif
#endif

#if defined(SVR4) ||  (defined(SYSV) && defined(__i386__)) || defined(__GNU__)
#include <sys/utsname.h>
#endif
#if defined(SYSV) &&  defined(__i386__)
#include <sys/stream.h>
#endif
#ifdef __GNU__
#undef SIOCGIFCONF
#include <netdb.h>
#else                           /*!__GNU__ */
#include <net/if.h>
#endif /*__GNU__ */

#ifdef SVR4
#include <sys/sockio.h>
#include <sys/stropts.h>
#endif

#include <netdb.h>

#ifdef CSRG_BASED
#include <sys/param.h>
#if (BSD >= 199103)
#define VARIABLE_IFREQ
#endif
#endif

#ifdef BSD44SOCKETS
#ifndef VARIABLE_IFREQ
#define VARIABLE_IFREQ
#endif
#endif

#ifdef HAVE_GETIFADDRS
#include <ifaddrs.h>
#endif

/* Solaris provides an extended interface SIOCGLIFCONF.  Other systems
 * may have this as well, but the code has only been tested on Solaris
 * so far, so we only enable it there.  Other platforms may be added as
 * needed.
 *
 * Test for Solaris commented out  --  TSI @@ UQV  2003.06.13
 */
#ifdef SIOCGLIFCONF
/* #if defined(sun) */
#define USE_SIOCGLIFCONF
/* #endif */
#endif

#if defined(IPv6) && defined(AF_INET6)
#include <arpa/inet.h>
#endif

#endif                          /* WIN32 */

#if !defined(WIN32) || defined(__CYGWIN__)
#include <libgen.h>
#endif

#define X_INCLUDE_NETDB_H
#include <X11/Xos_r.h>

#include "dixstruct.h"
#include "osdep.h"

#include "xace.h"

Bool defeatAccessControl = FALSE;

#define addrEqual(fam, address, length, host) \
			 ((fam) == (host)->family &&\
			  (length) == (host)->len &&\
			  !memcmp (address, (host)->addr, length))

static int ConvertAddr(struct sockaddr * /*saddr */ ,
                       int * /*len */ ,
                       void ** /*addr */ );

static int CheckAddr(int /*family */ ,
                     const void * /*pAddr */ ,
                     unsigned /*length */ );

static Bool NewHost(int /*family */ ,
                    const void * /*addr */ ,
                    int /*len */ ,
                    int /* addingLocalHosts */ );

/* XFree86 bug #156: To keep track of which hosts were explicitly requested in
   /etc/X<display>.hosts, we've added a requested field to the HOST struct,
   and a LocalHostRequested variable.  These default to FALSE, but are set
   to TRUE in ResetHosts when reading in /etc/X<display>.hosts.  They are
   checked in DisableLocalHost(), which is called to disable the default
   local host entries when stronger authentication is turned on. */

typedef struct _host {
    short family;
    short len;
    unsigned char *addr;
    struct _host *next;
    int requested;
} HOST;

#define MakeHost(h,l)	(h)=malloc(sizeof *(h)+(l));\
			if (h) { \
			   (h)->addr=(unsigned char *) ((h) + 1);\
			   (h)->requested = FALSE; \
			}
#define FreeHost(h)	free(h)
static HOST *selfhosts = NULL;
static HOST *validhosts = NULL;
static int AccessEnabled = DEFAULT_ACCESS_CONTROL;
static int LocalHostEnabled = FALSE;
static int LocalHostRequested = FALSE;
static int UsingXdmcp = FALSE;

static enum {
    LOCAL_ACCESS_SCOPE_HOST = 0,
#ifndef NO_LOCAL_CLIENT_CRED
    LOCAL_ACCESS_SCOPE_USER,
#endif
} LocalAccessScope;

/* FamilyServerInterpreted implementation */
static Bool siAddrMatch(int family, void *addr, int len, HOST * host,
                        ClientPtr client);
static int siCheckAddr(const char *addrString, int length);
static void siTypesInitialize(void);

/*
 * called when authorization is not enabled to add the
 * local host to the access list
 */

void
EnableLocalAccess(void)
{
    switch (LocalAccessScope) {
        case LOCAL_ACCESS_SCOPE_HOST:
            EnableLocalHost();
            break;
#ifndef NO_LOCAL_CLIENT_CRED
        case LOCAL_ACCESS_SCOPE_USER:
            EnableLocalUser();
            break;
#endif
    }
}

void
EnableLocalHost(void)
{
    if (!UsingXdmcp) {
        LocalHostEnabled = TRUE;
        AddLocalHosts();
    }
}

/*
 * called when authorization is enabled to keep us secure
 */
void
DisableLocalAccess(void)
{
    switch (LocalAccessScope) {
        case LOCAL_ACCESS_SCOPE_HOST:
            DisableLocalHost();
            break;
#ifndef NO_LOCAL_CLIENT_CRED
        case LOCAL_ACCESS_SCOPE_USER:
            DisableLocalUser();
            break;
#endif
    }
}

void
DisableLocalHost(void)
{
    HOST *self;

    if (!LocalHostRequested)    /* Fix for XFree86 bug #156 */
        LocalHostEnabled = FALSE;
    for (self = selfhosts; self; self = self->next) {
        if (!self->requested)   /* Fix for XFree86 bug #156 */
            (void) RemoveHost((ClientPtr) NULL, self->family, self->len,
                              (void *) self->addr);
    }
}

#ifndef NO_LOCAL_CLIENT_CRED
static int GetLocalUserAddr(char **addr)
{
    static const char *type = "localuser";
    static const char delimiter = '\0';
    static const char *value;
    struct passwd *pw;
    int length = -1;

    pw = getpwuid(getuid());

    if (pw == NULL || pw->pw_name == NULL)
        goto out;

    value = pw->pw_name;

    length = asprintf(addr, "%s%c%s", type, delimiter, value);

    if (length == -1) {
        goto out;
    }

    /* Trailing NUL */
    length++;

out:
    return length;
}

void
EnableLocalUser(void)
{
    char *addr = NULL;
    int length = -1;

    length = GetLocalUserAddr(&addr);

    if (length == -1)
        return;

    NewHost(FamilyServerInterpreted, addr, length, TRUE);

    free(addr);
}

void
DisableLocalUser(void)
{
    char *addr = NULL;
    int length = -1;

    length = GetLocalUserAddr(&addr);

    if (length == -1)
        return;

    RemoveHost(NULL, FamilyServerInterpreted, length, addr);

    free(addr);
}

void
LocalAccessScopeUser(void)
{
    LocalAccessScope = LOCAL_ACCESS_SCOPE_USER;
}
#endif

/*
 * called at init time when XDMCP will be used; xdmcp always
 * adds local hosts manually when needed
 */

void
AccessUsingXdmcp(void)
{
    UsingXdmcp = TRUE;
    LocalHostEnabled = FALSE;
}

#if  defined(SVR4) && !defined(sun)  && defined(SIOCGIFCONF) && !defined(USE_SIOCGLIFCONF)

/* Deal with different SIOCGIFCONF ioctl semantics on these OSs */

static int
ifioctl(int fd, int cmd, char *arg)
{
    struct strioctl ioc;
    int ret;

    memset((char *) &ioc, 0, sizeof(ioc));
    ioc.ic_cmd = cmd;
    ioc.ic_timout = 0;
    if (cmd == SIOCGIFCONF) {
        ioc.ic_len = ((struct ifconf *) arg)->ifc_len;
        ioc.ic_dp = ((struct ifconf *) arg)->ifc_buf;
    }
    else {
        ioc.ic_len = sizeof(struct ifreq);
        ioc.ic_dp = arg;
    }
    ret = ioctl(fd, I_STR, (char *) &ioc);
    if (ret >= 0 && cmd == SIOCGIFCONF)
#ifdef SVR4
        ((struct ifconf *) arg)->ifc_len = ioc.ic_len;
#endif
    return ret;
}
#else
#define ifioctl ioctl
#endif

/*
 * DefineSelf (fd):
 *
 * Define this host for access control.  Find all the hosts the OS knows about
 * for this fd and add them to the selfhosts list.
 */

#if !defined(SIOCGIFCONF)
void
DefineSelf(int fd)
{
#if !defined(TCPCONN) && !defined(STREAMSCONN) && !defined(UNIXCONN)
    return;
#else
    register int n;
    int len;
    caddr_t addr;
    int family;
    register HOST *host;

#ifndef WIN32
    struct utsname name;
#else
    struct {
        char nodename[512];
    } name;
#endif

    register struct hostent *hp;

    union {
        struct sockaddr sa;
        struct sockaddr_in in;
#if defined(IPv6) && defined(AF_INET6)
        struct sockaddr_in6 in6;
#endif
    } saddr;

    struct sockaddr_in *inetaddr;
    struct sockaddr_in6 *inet6addr;
    struct sockaddr_in broad_addr;

#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
    _Xgethostbynameparams hparams;
#endif

    /* Why not use gethostname()?  Well, at least on my system, I've had to
     * make an ugly kernel patch to get a name longer than 8 characters, and
     * uname() lets me access to the whole string (it smashes release, you
     * see), whereas gethostname() kindly truncates it for me.
     */
#ifndef WIN32
    uname(&name);
#else
    gethostname(name.nodename, sizeof(name.nodename));
#endif

    hp = _XGethostbyname(name.nodename, hparams);
    if (hp != NULL) {
        saddr.sa.sa_family = hp->h_addrtype;
        switch (hp->h_addrtype) {
        case AF_INET:
            inetaddr = (struct sockaddr_in *) (&(saddr.sa));
            memcpy(&(inetaddr->sin_addr), hp->h_addr, hp->h_length);
            len = sizeof(saddr.sa);
            break;
#if defined(IPv6) && defined(AF_INET6)
        case AF_INET6:
            inet6addr = (struct sockaddr_in6 *) (&(saddr.sa));
            memcpy(&(inet6addr->sin6_addr), hp->h_addr, hp->h_length);
            len = sizeof(saddr.in6);
            break;
#endif
        default:
            goto DefineLocalHost;
        }
        family = ConvertAddr(&(saddr.sa), &len, (void **) &addr);
        if (family != -1 && family != FamilyLocal) {
            for (host = selfhosts;
                 host && !addrEqual(family, addr, len, host);
                 host = host->next);
            if (!host) {
                /* add this host to the host list.      */
                MakeHost(host, len)
                    if (host) {
                    host->family = family;
                    host->len = len;
                    memcpy(host->addr, addr, len);
                    host->next = selfhosts;
                    selfhosts = host;
                }
#ifdef XDMCP
                /*
                 *  If this is an Internet Address, but not the localhost
                 *  address (127.0.0.1), nor the bogus address (0.0.0.0),
                 *  register it.
                 */
                if (family == FamilyInternet &&
                    !(len == 4 &&
                      ((addr[0] == 127) ||
                       (addr[0] == 0 && addr[1] == 0 &&
                        addr[2] == 0 && addr[3] == 0)))
                    ) {
                    XdmcpRegisterConnection(family, (char *) addr, len);
                    broad_addr = *inetaddr;
                    ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
                        htonl(INADDR_BROADCAST);
                    XdmcpRegisterBroadcastAddress((struct sockaddr_in *)
                                                  &broad_addr);
                }
#if defined(IPv6) && defined(AF_INET6)
                else if (family == FamilyInternet6 &&
                         !(IN6_IS_ADDR_LOOPBACK((struct in6_addr *) addr))) {
                    XdmcpRegisterConnection(family, (char *) addr, len);
                }
#endif

#endif                          /* XDMCP */
            }
        }
    }
    /*
     * now add a host of family FamilyLocalHost...
     */
 DefineLocalHost:
    for (host = selfhosts;
         host && !addrEqual(FamilyLocalHost, "", 0, host); host = host->next);
    if (!host) {
        MakeHost(host, 0);
        if (host) {
            host->family = FamilyLocalHost;
            host->len = 0;
            /* Nothing to store in host->addr */
            host->next = selfhosts;
            selfhosts = host;
        }
    }
#endif                          /* !TCPCONN && !STREAMSCONN && !UNIXCONN */
}

#else

#ifdef USE_SIOCGLIFCONF
#define ifr_type    struct lifreq
#else
#define ifr_type    struct ifreq
#endif

#ifdef VARIABLE_IFREQ
#define ifr_size(p) (sizeof (struct ifreq) + \
		     (p->ifr_addr.sa_len > sizeof (p->ifr_addr) ? \
		      p->ifr_addr.sa_len - sizeof (p->ifr_addr) : 0))
#define ifraddr_size(a) (a.sa_len)
#else
#define ifr_size(p) (sizeof (ifr_type))
#define ifraddr_size(a) (sizeof (a))
#endif

#if defined(IPv6) && defined(AF_INET6)
static void
in6_fillscopeid(struct sockaddr_in6 *sin6)
{
#if defined(__KAME__)
    if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
        sin6->sin6_scope_id =
            ntohs(*(u_int16_t *) &sin6->sin6_addr.s6_addr[2]);
        sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
    }
#endif
}
#endif

void
DefineSelf(int fd)
{
#ifndef HAVE_GETIFADDRS
    char *cp, *cplim;

#ifdef USE_SIOCGLIFCONF
    struct sockaddr_storage buf[16];
    struct lifconf ifc;
    register struct lifreq *ifr;

#ifdef SIOCGLIFNUM
    struct lifnum ifn;
#endif
#else                           /* !USE_SIOCGLIFCONF */
    char buf[2048];
    struct ifconf ifc;
    register struct ifreq *ifr;
#endif
    void *bufptr = buf;
#else                           /* HAVE_GETIFADDRS */
    struct ifaddrs *ifap, *ifr;
#endif
    int len;
    unsigned char *addr;
    int family;
    register HOST *host;

#ifndef HAVE_GETIFADDRS

    len = sizeof(buf);

#ifdef USE_SIOCGLIFCONF

#ifdef SIOCGLIFNUM
    ifn.lifn_family = AF_UNSPEC;
    ifn.lifn_flags = 0;
    if (ioctl(fd, SIOCGLIFNUM, (char *) &ifn) < 0)
        ErrorF("Getting interface count: %s\n", strerror(errno));
    if (len < (ifn.lifn_count * sizeof(struct lifreq))) {
        len = ifn.lifn_count * sizeof(struct lifreq);
        bufptr = malloc(len);
    }
#endif

    ifc.lifc_family = AF_UNSPEC;
    ifc.lifc_flags = 0;
    ifc.lifc_len = len;
    ifc.lifc_buf = bufptr;

#define IFC_IOCTL_REQ SIOCGLIFCONF
#define IFC_IFC_REQ ifc.lifc_req
#define IFC_IFC_LEN ifc.lifc_len
#define IFR_IFR_ADDR ifr->lifr_addr
#define IFR_IFR_NAME ifr->lifr_name

#else                           /* Use SIOCGIFCONF */
    ifc.ifc_len = len;
    ifc.ifc_buf = bufptr;

#define IFC_IOCTL_REQ SIOCGIFCONF
#define IFC_IFC_REQ ifc.ifc_req
#define IFC_IFC_LEN ifc.ifc_len
#define IFR_IFR_ADDR ifr->ifr_addr
#define IFR_IFR_NAME ifr->ifr_name
#endif

    if (ifioctl(fd, IFC_IOCTL_REQ, (void *) &ifc) < 0)
        ErrorF("Getting interface configuration (4): %s\n", strerror(errno));

    cplim = (char *) IFC_IFC_REQ + IFC_IFC_LEN;

    for (cp = (char *) IFC_IFC_REQ; cp < cplim; cp += ifr_size(ifr)) {
        ifr = (ifr_type *) cp;
        len = ifraddr_size(IFR_IFR_ADDR);
        family = ConvertAddr((struct sockaddr *) &IFR_IFR_ADDR,
                             &len, (void **) &addr);
        if (family == -1 || family == FamilyLocal)
            continue;
#if defined(IPv6) && defined(AF_INET6)
        if (family == FamilyInternet6)
            in6_fillscopeid((struct sockaddr_in6 *) &IFR_IFR_ADDR);
#endif
        for (host = selfhosts;
             host && !addrEqual(family, addr, len, host); host = host->next);
        if (host)
            continue;
        MakeHost(host, len)
            if (host) {
            host->family = family;
            host->len = len;
            memcpy(host->addr, addr, len);
            host->next = selfhosts;
            selfhosts = host;
        }
#ifdef XDMCP
        {
#ifdef USE_SIOCGLIFCONF
            struct sockaddr_storage broad_addr;
#else
            struct sockaddr broad_addr;
#endif

            /*
             * If this isn't an Internet Address, don't register it.
             */
            if (family != FamilyInternet
#if defined(IPv6) && defined(AF_INET6)
                && family != FamilyInternet6
#endif
                )
                continue;

            /*
             * ignore 'localhost' entries as they're not useful
             * on the other end of the wire
             */
            if (family == FamilyInternet &&
                addr[0] == 127 && addr[1] == 0 && addr[2] == 0 && addr[3] == 1)
                continue;
#if defined(IPv6) && defined(AF_INET6)
            else if (family == FamilyInternet6 &&
                     IN6_IS_ADDR_LOOPBACK((struct in6_addr *) addr))
                continue;
#endif

            /*
             * Ignore '0.0.0.0' entries as they are
             * returned by some OSes for unconfigured NICs but they are
             * not useful on the other end of the wire.
             */
            if (len == 4 &&
                addr[0] == 0 && addr[1] == 0 && addr[2] == 0 && addr[3] == 0)
                continue;

            XdmcpRegisterConnection(family, (char *) addr, len);

#if defined(IPv6) && defined(AF_INET6)
            /* IPv6 doesn't support broadcasting, so we drop out here */
            if (family == FamilyInternet6)
                continue;
#endif

            broad_addr = IFR_IFR_ADDR;

            ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
                htonl(INADDR_BROADCAST);
#if defined(USE_SIOCGLIFCONF) && defined(SIOCGLIFBRDADDR)
            {
                struct lifreq broad_req;

                broad_req = *ifr;
                if (ioctl(fd, SIOCGLIFFLAGS, (char *) &broad_req) != -1 &&
                    (broad_req.lifr_flags & IFF_BROADCAST) &&
                    (broad_req.lifr_flags & IFF_UP)
                    ) {
                    broad_req = *ifr;
                    if (ioctl(fd, SIOCGLIFBRDADDR, &broad_req) != -1)
                        broad_addr = broad_req.lifr_broadaddr;
                    else
                        continue;
                }
                else
                    continue;
            }

#elif defined(SIOCGIFBRDADDR)
            {
                struct ifreq broad_req;

                broad_req = *ifr;
                if (ifioctl(fd, SIOCGIFFLAGS, (void *) &broad_req) != -1 &&
                    (broad_req.ifr_flags & IFF_BROADCAST) &&
                    (broad_req.ifr_flags & IFF_UP)
                    ) {
                    broad_req = *ifr;
                    if (ifioctl(fd, SIOCGIFBRDADDR, (void *) &broad_req) != -1)
                        broad_addr = broad_req.ifr_addr;
                    else
                        continue;
                }
                else
                    continue;
            }
#endif                          /* SIOCGIFBRDADDR */
            XdmcpRegisterBroadcastAddress((struct sockaddr_in *) &broad_addr);
        }
#endif                          /* XDMCP */
    }
    if (bufptr != buf)
        free(bufptr);
#else                           /* HAVE_GETIFADDRS */
    if (getifaddrs(&ifap) < 0) {
        ErrorF("Warning: getifaddrs returns %s\n", strerror(errno));
        return;
    }
    for (ifr = ifap; ifr != NULL; ifr = ifr->ifa_next) {
        if (!ifr->ifa_addr)
            continue;
        len = sizeof(*(ifr->ifa_addr));
        family = ConvertAddr((struct sockaddr *) ifr->ifa_addr, &len,
                             (void **) &addr);
        if (family == -1 || family == FamilyLocal)
            continue;
#if defined(IPv6) && defined(AF_INET6)
        if (family == FamilyInternet6)
            in6_fillscopeid((struct sockaddr_in6 *) ifr->ifa_addr);
#endif

        for (host = selfhosts;
             host != NULL && !addrEqual(family, addr, len, host);
             host = host->next);
        if (host != NULL)
            continue;
        MakeHost(host, len);
        if (host != NULL) {
            host->family = family;
            host->len = len;
            memcpy(host->addr, addr, len);
            host->next = selfhosts;
            selfhosts = host;
        }
#ifdef XDMCP
        {
            /*
             * If this isn't an Internet Address, don't register it.
             */
            if (family != FamilyInternet
#if defined(IPv6) && defined(AF_INET6)
                && family != FamilyInternet6
#endif
                )
                continue;

            /*
             * ignore 'localhost' entries as they're not useful
             * on the other end of the wire
             */
            if (ifr->ifa_flags & IFF_LOOPBACK)
                continue;

            if (family == FamilyInternet &&
                addr[0] == 127 && addr[1] == 0 && addr[2] == 0 && addr[3] == 1)
                continue;

            /*
             * Ignore '0.0.0.0' entries as they are
             * returned by some OSes for unconfigured NICs but they are
             * not useful on the other end of the wire.
             */
            if (len == 4 &&
                addr[0] == 0 && addr[1] == 0 && addr[2] == 0 && addr[3] == 0)
                continue;
#if defined(IPv6) && defined(AF_INET6)
            else if (family == FamilyInternet6 &&
                     IN6_IS_ADDR_LOOPBACK((struct in6_addr *) addr))
                continue;
#endif
            XdmcpRegisterConnection(family, (char *) addr, len);
#if defined(IPv6) && defined(AF_INET6)
            if (family == FamilyInternet6)
                /* IPv6 doesn't support broadcasting, so we drop out here */
                continue;
#endif
            if ((ifr->ifa_flags & IFF_BROADCAST) &&
                (ifr->ifa_flags & IFF_UP) && ifr->ifa_broadaddr)
                XdmcpRegisterBroadcastAddress((struct sockaddr_in *) ifr->
                                              ifa_broadaddr);
            else
                continue;
        }
#endif                          /* XDMCP */

    }                           /* for */
    freeifaddrs(ifap);
#endif                          /* HAVE_GETIFADDRS */

    /*
     * add something of FamilyLocalHost
     */
    for (host = selfhosts;
         host && !addrEqual(FamilyLocalHost, "", 0, host); host = host->next);
    if (!host) {
        MakeHost(host, 0);
        if (host) {
            host->family = FamilyLocalHost;
            host->len = 0;
            /* Nothing to store in host->addr */
            host->next = selfhosts;
            selfhosts = host;
        }
    }
}
#endif                          /* hpux && !HAVE_IFREQ */

#ifdef XDMCP
void
AugmentSelf(void *from, int len)
{
    int family;
    void *addr;
    register HOST *host;

    family = ConvertAddr(from, &len, (void **) &addr);
    if (family == -1 || family == FamilyLocal)
        return;
    for (host = selfhosts; host; host = host->next) {
        if (addrEqual(family, addr, len, host))
            return;
    }
    MakeHost(host, len)
        if (!host)
        return;
    host->family = family;
    host->len = len;
    memcpy(host->addr, addr, len);
    host->next = selfhosts;
    selfhosts = host;
}
#endif

void
AddLocalHosts(void)
{
    HOST *self;

    for (self = selfhosts; self; self = self->next)
        /* Fix for XFree86 bug #156: pass addingLocal = TRUE to
         * NewHost to tell that we are adding the default local
         * host entries and not to flag the entries as being
         * explicitely requested */
        (void) NewHost(self->family, self->addr, self->len, TRUE);
}

/* Reset access control list to initial hosts */
void
ResetHosts(const char *display)
{
    register HOST *host;
    char lhostname[120], ohostname[120];
    char *hostname = ohostname;
    char fname[PATH_MAX + 1];
    int fnamelen;
    FILE *fd;
    char *ptr;
    int i, hostlen;

#if (defined(TCPCONN) || defined(STREAMSCONN) ) && \
     (!defined(IPv6) || !defined(AF_INET6))
    union {
        struct sockaddr sa;
#if defined(TCPCONN) || defined(STREAMSCONN)
        struct sockaddr_in in;
#endif                          /* TCPCONN || STREAMSCONN */
    } saddr;
#endif
    int family = 0;
    void *addr = NULL;
    int len;

    siTypesInitialize();
    AccessEnabled = defeatAccessControl ? FALSE : DEFAULT_ACCESS_CONTROL;
    LocalHostEnabled = FALSE;
    while ((host = validhosts) != 0) {
        validhosts = host->next;
        FreeHost(host);
    }

#if defined WIN32 && defined __MINGW32__
#define ETC_HOST_PREFIX "X"
#else
#define ETC_HOST_PREFIX "/etc/X"
#endif
#define ETC_HOST_SUFFIX ".hosts"
    fnamelen = strlen(ETC_HOST_PREFIX) + strlen(ETC_HOST_SUFFIX) +
        strlen(display) + 1;
    if (fnamelen > sizeof(fname))
        FatalError("Display name `%s' is too long\n", display);
    snprintf(fname, sizeof(fname), ETC_HOST_PREFIX "%s" ETC_HOST_SUFFIX,
             display);

    if ((fd = fopen(fname, "r")) != 0) {
        while (fgets(ohostname, sizeof(ohostname), fd)) {
            family = FamilyWild;
            if (*ohostname == '#')
                continue;
            if ((ptr = strchr(ohostname, '\n')) != 0)
                *ptr = 0;
            hostlen = strlen(ohostname) + 1;
            for (i = 0; i < hostlen; i++)
                lhostname[i] = tolower(ohostname[i]);
            hostname = ohostname;
            if (!strncmp("local:", lhostname, 6)) {
                family = FamilyLocalHost;
                NewHost(family, "", 0, FALSE);
                LocalHostRequested = TRUE;      /* Fix for XFree86 bug #156 */
            }
#if defined(TCPCONN) || defined(STREAMSCONN)
            else if (!strncmp("inet:", lhostname, 5)) {
                family = FamilyInternet;
                hostname = ohostname + 5;
            }
#if defined(IPv6) && defined(AF_INET6)
            else if (!strncmp("inet6:", lhostname, 6)) {
                family = FamilyInternet6;
                hostname = ohostname + 6;
            }
#endif
#endif
#ifdef SECURE_RPC
            else if (!strncmp("nis:", lhostname, 4)) {
                family = FamilyNetname;
                hostname = ohostname + 4;
            }
#endif
            else if (!strncmp("si:", lhostname, 3)) {
                family = FamilyServerInterpreted;
                hostname = ohostname + 3;
                hostlen -= 3;
            }

            if (family == FamilyServerInterpreted) {
                len = siCheckAddr(hostname, hostlen);
                if (len >= 0) {
                    NewHost(family, hostname, len, FALSE);
                }
            }
            else
#ifdef SECURE_RPC
            if ((family == FamilyNetname) || (strchr(hostname, '@@'))) {
                SecureRPCInit();
                (void) NewHost(FamilyNetname, hostname, strlen(hostname),
                               FALSE);
            }
            else
#endif                          /* SECURE_RPC */
#if defined(TCPCONN) || defined(STREAMSCONN)
            {
#if defined(IPv6) && defined(AF_INET6)
                if ((family == FamilyInternet) || (family == FamilyInternet6) ||
                    (family == FamilyWild)) {
                    struct addrinfo *addresses;
                    struct addrinfo *a;
                    int f;

                    if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
                        for (a = addresses; a != NULL; a = a->ai_next) {
                            len = a->ai_addrlen;
                            f = ConvertAddr(a->ai_addr, &len,
                                            (void **) &addr);
                            if (addr && ((family == f) ||
                                         ((family == FamilyWild) && (f != -1)))) {
                                NewHost(f, addr, len, FALSE);
                            }
                        }
                        freeaddrinfo(addresses);
                    }
                }
#else
#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
                _Xgethostbynameparams hparams;
#endif
                register struct hostent *hp;

                /* host name */
                if ((family == FamilyInternet &&
                     ((hp = _XGethostbyname(hostname, hparams)) != 0)) ||
                    ((hp = _XGethostbyname(hostname, hparams)) != 0)) {
                    saddr.sa.sa_family = hp->h_addrtype;
                    len = sizeof(saddr.sa);
                    if ((family =
                         ConvertAddr(&saddr.sa, &len,
                                     (void **) &addr)) != -1) {
#ifdef h_addr                   /* new 4.3bsd version of gethostent */
                        char **list;

                        /* iterate over the addresses */
                        for (list = hp->h_addr_list; *list; list++)
                            (void) NewHost(family, (void *) *list, len, FALSE);
#else
                        (void) NewHost(family, (void *) hp->h_addr, len,
                                       FALSE);
#endif
                    }
                }
#endif                          /* IPv6 */
            }
#endif                          /* TCPCONN || STREAMSCONN */
            family = FamilyWild;
        }
        fclose(fd);
    }
}

static Bool
xtransLocalClient(ClientPtr client)
{
    int alen, family, notused;
    Xtransaddr *from = NULL;
    void *addr;
    register HOST *host;
    OsCommPtr oc = (OsCommPtr) client->osPrivate;

    if (!oc->trans_conn)
        return FALSE;

    if (!_XSERVTransGetPeerAddr(oc->trans_conn, &notused, &alen, &from)) {
        family = ConvertAddr((struct sockaddr *) from,
                             &alen, (void **) &addr);
        if (family == -1) {
            free(from);
            return FALSE;
        }
        if (family == FamilyLocal) {
            free(from);
            return TRUE;
        }
        for (host = selfhosts; host; host = host->next) {
            if (addrEqual(family, addr, alen, host)) {
                free(from);
                return TRUE;
            }
        }
        free(from);
    }
    return FALSE;
}

/* Is client on the local host */
Bool
ComputeLocalClient(ClientPtr client)
{
    const char *cmdname = GetClientCmdName(client);

    if (!xtransLocalClient(client))
        return FALSE;

    /* If the executable name is "ssh", assume that this client connection
     * is forwarded from another host via SSH
     */
    if (cmdname) {
        char *cmd = strdup(cmdname);
        Bool ret;

        /* Cut off any colon and whatever comes after it, see
         * https://lists.freedesktop.org/archives/xorg-devel/2015-December/048164.html
         */
        cmd = strtok(cmd, ":");

#if !defined(WIN32) || defined(__CYGWIN__)
        ret = strcmp(basename(cmd), "ssh") != 0;
#else
        ret = strcmp(cmd, "ssh") != 0;
#endif

        free(cmd);

        return ret;
    }

    return TRUE;
}

/*
 * Return the uid and all gids of a connected local client
 * Allocates a LocalClientCredRec - caller must call FreeLocalClientCreds
 *
 * Used by localuser & localgroup ServerInterpreted access control forms below
 * Used by AuthAudit to log who local connections came from
 */
int
GetLocalClientCreds(ClientPtr client, LocalClientCredRec ** lccp)
{
#if defined(HAVE_GETPEEREID) || defined(HAVE_GETPEERUCRED) || defined(SO_PEERCRED)
    int fd;
    XtransConnInfo ci;
    LocalClientCredRec *lcc;

#ifdef HAVE_GETPEEREID
    uid_t uid;
    gid_t gid;
#elif defined(HAVE_GETPEERUCRED)
    ucred_t *peercred = NULL;
    const gid_t *gids;
#elif defined(SO_PEERCRED)
    struct ucred peercred;
    socklen_t so_len = sizeof(peercred);
#endif

    if (client == NULL)
        return -1;
    ci = ((OsCommPtr) client->osPrivate)->trans_conn;
#if !(defined(sun) && defined(HAVE_GETPEERUCRED))
    /* Most implementations can only determine peer credentials for Unix
     * domain sockets - Solaris getpeerucred can work with a bit more, so
     * we just let it tell us if the connection type is supported or not
     */
    if (!_XSERVTransIsLocal(ci)) {
        return -1;
    }
#endif

    *lccp = calloc(1, sizeof(LocalClientCredRec));
    if (*lccp == NULL)
        return -1;
    lcc = *lccp;

    fd = _XSERVTransGetConnectionNumber(ci);
#ifdef HAVE_GETPEEREID
    if (getpeereid(fd, &uid, &gid) == -1) {
        FreeLocalClientCreds(lcc);
        return -1;
    }
    lcc->euid = uid;
    lcc->egid = gid;
    lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET;
    return 0;
#elif defined(HAVE_GETPEERUCRED)
    if (getpeerucred(fd, &peercred) < 0) {
        FreeLocalClientCreds(lcc);
        return -1;
    }
    lcc->euid = ucred_geteuid(peercred);
    if (lcc->euid != -1)
        lcc->fieldsSet |= LCC_UID_SET;
    lcc->egid = ucred_getegid(peercred);
    if (lcc->egid != -1)
        lcc->fieldsSet |= LCC_GID_SET;
    lcc->pid = ucred_getpid(peercred);
    if (lcc->pid != -1)
        lcc->fieldsSet |= LCC_PID_SET;
#ifdef HAVE_GETZONEID
    lcc->zoneid = ucred_getzoneid(peercred);
    if (lcc->zoneid != -1)
        lcc->fieldsSet |= LCC_ZID_SET;
#endif
    lcc->nSuppGids = ucred_getgroups(peercred, &gids);
    if (lcc->nSuppGids > 0) {
        lcc->pSuppGids = calloc(lcc->nSuppGids, sizeof(int));
        if (lcc->pSuppGids == NULL) {
            lcc->nSuppGids = 0;
        }
        else {
            int i;

            for (i = 0; i < lcc->nSuppGids; i++) {
                (lcc->pSuppGids)[i] = (int) gids[i];
            }
        }
    }
    else {
        lcc->nSuppGids = 0;
    }
    ucred_free(peercred);
    return 0;
#elif defined(SO_PEERCRED)
    if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &peercred, &so_len) == -1) {
        FreeLocalClientCreds(lcc);
        return -1;
    }
    lcc->euid = peercred.uid;
    lcc->egid = peercred.gid;
    lcc->pid = peercred.pid;
    lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET | LCC_PID_SET;
    return 0;
#endif
#else
    /* No system call available to get the credentials of the peer */
    return -1;
#endif
}

void
FreeLocalClientCreds(LocalClientCredRec * lcc)
{
    if (lcc != NULL) {
        if (lcc->nSuppGids > 0) {
            free(lcc->pSuppGids);
        }
        free(lcc);
    }
}

static int
AuthorizedClient(ClientPtr client)
{
    int rc;

    if (!client || defeatAccessControl)
        return Success;

    /* untrusted clients can't change host access */
    rc = XaceHook(XACE_SERVER_ACCESS, client, DixManageAccess);
    if (rc != Success)
        return rc;

    return client->local ? Success : BadAccess;
}

/* Add a host to the access control list.  This is the external interface
 * called from the dispatcher */

int
AddHost(ClientPtr client, int family, unsigned length,  /* of bytes in pAddr */
        const void *pAddr)
{
    int rc, len;

    rc = AuthorizedClient(client);
    if (rc != Success)
        return rc;
    switch (family) {
    case FamilyLocalHost:
        len = length;
        LocalHostEnabled = TRUE;
        break;
#ifdef SECURE_RPC
    case FamilyNetname:
        len = length;
        SecureRPCInit();
        break;
#endif
    case FamilyInternet:
#if defined(IPv6) && defined(AF_INET6)
    case FamilyInternet6:
#endif
    case FamilyDECnet:
    case FamilyChaos:
    case FamilyServerInterpreted:
        if ((len = CheckAddr(family, pAddr, length)) < 0) {
            client->errorValue = length;
            return BadValue;
        }
        break;
    case FamilyLocal:
    default:
        client->errorValue = family;
        return BadValue;
    }
    if (NewHost(family, pAddr, len, FALSE))
        return Success;
    return BadAlloc;
}

Bool
ForEachHostInFamily(int family, Bool (*func) (unsigned char *addr,
                                              short len,
                                              void *closure),
                    void *closure)
{
    HOST *host;

    for (host = validhosts; host; host = host->next)
        if (family == host->family && func(host->addr, host->len, closure))
            return TRUE;
    return FALSE;
}

/* Add a host to the access control list. This is the internal interface
 * called when starting or resetting the server */
static Bool
NewHost(int family, const void *addr, int len, int addingLocalHosts)
{
    register HOST *host;

    for (host = validhosts; host; host = host->next) {
        if (addrEqual(family, addr, len, host))
            return TRUE;
    }
    if (!addingLocalHosts) {    /* Fix for XFree86 bug #156 */
        for (host = selfhosts; host; host = host->next) {
            if (addrEqual(family, addr, len, host)) {
                host->requested = TRUE;
                break;
            }
        }
    }
    MakeHost(host, len)
        if (!host)
        return FALSE;
    host->family = family;
    host->len = len;
    memcpy(host->addr, addr, len);
    host->next = validhosts;
    validhosts = host;
    return TRUE;
}

/* Remove a host from the access control list */

int
RemoveHost(ClientPtr client, int family, unsigned length,       /* of bytes in pAddr */
           void *pAddr)
{
    int rc, len;
    register HOST *host, **prev;

    rc = AuthorizedClient(client);
    if (rc != Success)
        return rc;
    switch (family) {
    case FamilyLocalHost:
        len = length;
        LocalHostEnabled = FALSE;
        break;
#ifdef SECURE_RPC
    case FamilyNetname:
        len = length;
        break;
#endif
    case FamilyInternet:
#if defined(IPv6) && defined(AF_INET6)
    case FamilyInternet6:
#endif
    case FamilyDECnet:
    case FamilyChaos:
    case FamilyServerInterpreted:
        if ((len = CheckAddr(family, pAddr, length)) < 0) {
            client->errorValue = length;
            return BadValue;
        }
        break;
    case FamilyLocal:
    default:
        client->errorValue = family;
        return BadValue;
    }
    for (prev = &validhosts;
         (host = *prev) && (!addrEqual(family, pAddr, len, host));
         prev = &host->next);
    if (host) {
        *prev = host->next;
        FreeHost(host);
    }
    return Success;
}

/* Get all hosts in the access control list */
int
GetHosts(void **data, int *pnHosts, int *pLen, BOOL * pEnabled)
{
    int len;
    register int n = 0;
    register unsigned char *ptr;
    register HOST *host;
    int nHosts = 0;

    *pEnabled = AccessEnabled ? EnableAccess : DisableAccess;
    for (host = validhosts; host; host = host->next) {
        nHosts++;
        n += pad_to_int32(host->len) + sizeof(xHostEntry);
        /* Could check for INT_MAX, but in reality having more than 1mb of
           hostnames in the access list is ridiculous */
        if (n >= 1048576)
            break;
    }
    if (n) {
        *data = ptr = malloc(n);
        if (!ptr) {
            return BadAlloc;
        }
        for (host = validhosts; host; host = host->next) {
            len = host->len;
            if ((ptr + sizeof(xHostEntry) + len) > ((unsigned char *) *data + n))
                break;
            ((xHostEntry *) ptr)->family = host->family;
            ((xHostEntry *) ptr)->length = len;
            ptr += sizeof(xHostEntry);
            memcpy(ptr, host->addr, len);
            ptr += pad_to_int32(len);
        }
    }
    else {
        *data = NULL;
    }
    *pnHosts = nHosts;
    *pLen = n;
    return Success;
}

/* Check for valid address family and length, and return address length. */

 /*ARGSUSED*/ static int
CheckAddr(int family, const void *pAddr, unsigned length)
{
    int len;

    switch (family) {
#if defined(TCPCONN) || defined(STREAMSCONN)
    case FamilyInternet:
        if (length == sizeof(struct in_addr))
            len = length;
        else
            len = -1;
        break;
#if defined(IPv6) && defined(AF_INET6)
    case FamilyInternet6:
        if (length == sizeof(struct in6_addr))
            len = length;
        else
            len = -1;
        break;
#endif
#endif
    case FamilyServerInterpreted:
        len = siCheckAddr(pAddr, length);
        break;
    default:
        len = -1;
    }
    return len;
}

/* Check if a host is not in the access control list.
 * Returns 1 if host is invalid, 0 if we've found it. */

int
InvalidHost(register struct sockaddr *saddr, int len, ClientPtr client)
{
    int family;
    void *addr = NULL;
    register HOST *selfhost, *host;

    if (!AccessEnabled)         /* just let them in */
        return 0;
    family = ConvertAddr(saddr, &len, (void **) &addr);
    if (family == -1)
        return 1;
    if (family == FamilyLocal) {
        if (!LocalHostEnabled) {
            /*
             * check to see if any local address is enabled.  This
             * implicitly enables local connections.
             */
            for (selfhost = selfhosts; selfhost; selfhost = selfhost->next) {
                for (host = validhosts; host; host = host->next) {
                    if (addrEqual(selfhost->family, selfhost->addr,
                                  selfhost->len, host))
                        return 0;
                }
            }
        }
        else
            return 0;
    }
    for (host = validhosts; host; host = host->next) {
        if (host->family == FamilyServerInterpreted) {
            if (siAddrMatch(family, addr, len, host, client)) {
                return 0;
            }
        }
        else {
            if (addr && addrEqual(family, addr, len, host))
                return 0;
        }

    }
    return 1;
}

static int
ConvertAddr(register struct sockaddr *saddr, int *len, void **addr)
{
    if (*len == 0)
        return FamilyLocal;
    switch (saddr->sa_family) {
    case AF_UNSPEC:
#if defined(UNIXCONN) || defined(LOCALCONN)
    case AF_UNIX:
#endif
        return FamilyLocal;
#if defined(TCPCONN) || defined(STREAMSCONN)
    case AF_INET:
#ifdef WIN32
        if (16777343 == *(long *) &((struct sockaddr_in *) saddr)->sin_addr)
            return FamilyLocal;
#endif
        *len = sizeof(struct in_addr);
        *addr = (void *) &(((struct sockaddr_in *) saddr)->sin_addr);
        return FamilyInternet;
#if defined(IPv6) && defined(AF_INET6)
    case AF_INET6:
    {
        struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *) saddr;

        if (IN6_IS_ADDR_V4MAPPED(&(saddr6->sin6_addr))) {
            *len = sizeof(struct in_addr);
            *addr = (void *) &(saddr6->sin6_addr.s6_addr[12]);
            return FamilyInternet;
        }
        else {
            *len = sizeof(struct in6_addr);
            *addr = (void *) &(saddr6->sin6_addr);
            return FamilyInternet6;
        }
    }
#endif
#endif
    default:
        return -1;
    }
}

int
ChangeAccessControl(ClientPtr client, int fEnabled)
{
    int rc = AuthorizedClient(client);

    if (rc != Success)
        return rc;
    AccessEnabled = fEnabled;
    return Success;
}

/* returns FALSE if xhost + in effect, else TRUE */
int
GetAccessControl(void)
{
    return AccessEnabled;
}

int
GetClientFd(ClientPtr client)
{
    return ((OsCommPtr) client->osPrivate)->fd;
}

Bool
ClientIsLocal(ClientPtr client)
{
    XtransConnInfo ci = ((OsCommPtr) client->osPrivate)->trans_conn;

    return _XSERVTransIsLocal(ci);
}

/*****************************************************************************
 * FamilyServerInterpreted host entry implementation
 *
 * Supports an extensible system of host types which the server can interpret
 * See the IPv6 extensions to the X11 protocol spec for the definition.
 *
 * Currently supported schemes:
 *
 * hostname	- hostname as defined in IETF RFC 2396
 * ipv6		- IPv6 literal address as defined in IETF RFC's 3513 and <TBD>
 *
 * See xc/doc/specs/SIAddresses for formal definitions of each type.
 */

/* These definitions and the siTypeAdd function could be exported in the
 * future to enable loading additional host types, but that was not done for
 * the initial implementation.
 */
typedef Bool (*siAddrMatchFunc) (int family, void *addr, int len,
                                 const char *siAddr, int siAddrlen,
                                 ClientPtr client, void *siTypePriv);
typedef int (*siCheckAddrFunc) (const char *addrString, int length,
                                void *siTypePriv);

struct siType {
    struct siType *next;
    const char *typeName;
    siAddrMatchFunc addrMatch;
    siCheckAddrFunc checkAddr;
    void *typePriv;             /* Private data for type routines */
};

static struct siType *siTypeList;

static int
siTypeAdd(const char *typeName, siAddrMatchFunc addrMatch,
          siCheckAddrFunc checkAddr, void *typePriv)
{
    struct siType *s, *p;

    if ((typeName == NULL) || (addrMatch == NULL) || (checkAddr == NULL))
        return BadValue;

    for (s = siTypeList, p = NULL; s != NULL; p = s, s = s->next) {
        if (strcmp(typeName, s->typeName) == 0) {
            s->addrMatch = addrMatch;
            s->checkAddr = checkAddr;
            s->typePriv = typePriv;
            return Success;
        }
    }

    s = malloc(sizeof(struct siType));
    if (s == NULL)
        return BadAlloc;

    if (p == NULL)
        siTypeList = s;
    else
        p->next = s;

    s->next = NULL;
    s->typeName = typeName;
    s->addrMatch = addrMatch;
    s->checkAddr = checkAddr;
    s->typePriv = typePriv;
    return Success;
}

/* Checks to see if a host matches a server-interpreted host entry */
static Bool
siAddrMatch(int family, void *addr, int len, HOST * host, ClientPtr client)
{
    Bool matches = FALSE;
    struct siType *s;
    const char *valueString;
    int addrlen;

    valueString = (const char *) memchr(host->addr, '\0', host->len);
    if (valueString != NULL) {
        for (s = siTypeList; s != NULL; s = s->next) {
            if (strcmp((char *) host->addr, s->typeName) == 0) {
                addrlen = host->len - (strlen((char *) host->addr) + 1);
                matches = s->addrMatch(family, addr, len,
                                       valueString + 1, addrlen, client,
                                       s->typePriv);
                break;
            }
        }
#ifdef FAMILY_SI_DEBUG
        ErrorF("Xserver: siAddrMatch(): type = %s, value = %*.*s -- %s\n",
               host->addr, addrlen, addrlen, valueString + 1,
               (matches) ? "accepted" : "rejected");
#endif
    }
    return matches;
}

static int
siCheckAddr(const char *addrString, int length)
{
    const char *valueString;
    int addrlen, typelen;
    int len = -1;
    struct siType *s;

    /* Make sure there is a \0 byte inside the specified length
       to separate the address type from the address value. */
    valueString = (const char *) memchr(addrString, '\0', length);
    if (valueString != NULL) {
        /* Make sure the first string is a recognized address type,
         * and the second string is a valid address of that type.
         */
        typelen = strlen(addrString) + 1;
        addrlen = length - typelen;

        for (s = siTypeList; s != NULL; s = s->next) {
            if (strcmp(addrString, s->typeName) == 0) {
                len = s->checkAddr(valueString + 1, addrlen, s->typePriv);
                if (len >= 0) {
                    len += typelen;
                }
                break;
            }
        }
#ifdef FAMILY_SI_DEBUG
        {
            const char *resultMsg;

            if (s == NULL) {
                resultMsg = "type not registered";
            }
            else {
                if (len == -1)
                    resultMsg = "rejected";
                else
                    resultMsg = "accepted";
            }

            ErrorF
                ("Xserver: siCheckAddr(): type = %s, value = %*.*s, len = %d -- %s\n",
                 addrString, addrlen, addrlen, valueString + 1, len, resultMsg);
        }
#endif
    }
    return len;
}

/***
 * Hostname server-interpreted host type
 *
 * Stored as hostname string, explicitly defined to be resolved ONLY
 * at access check time, to allow for hosts with dynamic addresses
 * but static hostnames, such as found in some DHCP & mobile setups.
 *
 * Hostname must conform to IETF RFC 2396 sec. 3.2.2, which defines it as:
 * 	hostname     = *( domainlabel "." ) toplabel [ "." ]
 *	domainlabel  = alphanum | alphanum *( alphanum | "-" ) alphanum
 *	toplabel     = alpha | alpha *( alphanum | "-" ) alphanum
 */

#ifdef NI_MAXHOST
#define SI_HOSTNAME_MAXLEN NI_MAXHOST
#else
#ifdef MAXHOSTNAMELEN
#define SI_HOSTNAME_MAXLEN MAXHOSTNAMELEN
#else
#define SI_HOSTNAME_MAXLEN 256
#endif
#endif

static Bool
siHostnameAddrMatch(int family, void *addr, int len,
                    const char *siAddr, int siAddrLen, ClientPtr client,
                    void *typePriv)
{
    Bool res = FALSE;

/* Currently only supports checking against IPv4 & IPv6 connections, but
 * support for other address families, such as DECnet, could be added if
 * desired.
 */
#if defined(IPv6) && defined(AF_INET6)
    if ((family == FamilyInternet) || (family == FamilyInternet6)) {
        char hostname[SI_HOSTNAME_MAXLEN];
        struct addrinfo *addresses;
        struct addrinfo *a;
        int f, hostaddrlen;
        void *hostaddr = NULL;

        if (siAddrLen >= sizeof(hostname))
            return FALSE;

        strlcpy(hostname, siAddr, siAddrLen + 1);

        if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
            for (a = addresses; a != NULL; a = a->ai_next) {
                hostaddrlen = a->ai_addrlen;
                f = ConvertAddr(a->ai_addr, &hostaddrlen, &hostaddr);
                if ((f == family) && (len == hostaddrlen) && hostaddr &&
                    (memcmp(addr, hostaddr, len) == 0)) {
                    res = TRUE;
                    break;
                }
            }
            freeaddrinfo(addresses);
        }
    }
#else                           /* IPv6 not supported, use gethostbyname instead for IPv4 */
    if (family == FamilyInternet) {
        register struct hostent *hp;

#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
        _Xgethostbynameparams hparams;
#endif
        char hostname[SI_HOSTNAME_MAXLEN];
        int f, hostaddrlen;
        void *hostaddr;
        const char **addrlist;

        if (siAddrLen >= sizeof(hostname))
            return FALSE;

        strlcpy(hostname, siAddr, siAddrLen + 1);

        if ((hp = _XGethostbyname(hostname, hparams)) != NULL) {
#ifdef h_addr                   /* new 4.3bsd version of gethostent */
            /* iterate over the addresses */
            for (addrlist = hp->h_addr_list; *addrlist; addrlist++)
#else
            addrlist = &hp->h_addr;
#endif
            {
                struct sockaddr_in sin;

                sin.sin_family = hp->h_addrtype;
                memcpy(&(sin.sin_addr), *addrlist, hp->h_length);
                hostaddrlen = sizeof(sin);
                f = ConvertAddr((struct sockaddr *) &sin,
                                &hostaddrlen, &hostaddr);
                if ((f == family) && (len == hostaddrlen) &&
                    (memcmp(addr, hostaddr, len) == 0)) {
                    res = TRUE;
                    break;
                }
            }
        }
    }
#endif
    return res;
}

static int
siHostnameCheckAddr(const char *valueString, int length, void *typePriv)
{
    /* Check conformance of hostname to RFC 2396 sec. 3.2.2 definition.
     * We do not use ctype functions here to avoid locale-specific
     * character sets.  Hostnames must be pure ASCII.
     */
    int len = length;
    int i;
    Bool dotAllowed = FALSE;
    Bool dashAllowed = FALSE;

    if ((length <= 0) || (length >= SI_HOSTNAME_MAXLEN)) {
        len = -1;
    }
    else {
        for (i = 0; i < length; i++) {
            char c = valueString[i];

            if (c == 0x2E) {    /* '.' */
                if (dotAllowed == FALSE) {
                    len = -1;
                    break;
                }
                else {
                    dotAllowed = FALSE;
                    dashAllowed = FALSE;
                }
            }
            else if (c == 0x2D) {       /* '-' */
                if (dashAllowed == FALSE) {
                    len = -1;
                    break;
                }
                else {
                    dotAllowed = FALSE;
                }
            }
            else if (((c >= 0x30) && (c <= 0x3A)) /* 0-9 */ ||
                     ((c >= 0x61) && (c <= 0x7A)) /* a-z */ ||
                     ((c >= 0x41) && (c <= 0x5A)) /* A-Z */ ) {
                dotAllowed = TRUE;
                dashAllowed = TRUE;
            }
            else {              /* Invalid character */
                len = -1;
                break;
            }
        }
    }
    return len;
}

#if defined(IPv6) && defined(AF_INET6)
/***
 * "ipv6" server interpreted type
 *
 * Currently supports only IPv6 literal address as specified in IETF RFC 3513
 *
 * Once draft-ietf-ipv6-scoping-arch-00.txt becomes an RFC, support will be
 * added for the scoped address format it specifies.
 */

/* Maximum length of an IPv6 address string - increase when adding support
 * for scoped address qualifiers.  Includes room for trailing NUL byte.
 */
#define SI_IPv6_MAXLEN INET6_ADDRSTRLEN

static Bool
siIPv6AddrMatch(int family, void *addr, int len,
                const char *siAddr, int siAddrlen, ClientPtr client,
                void *typePriv)
{
    struct in6_addr addr6;
    char addrbuf[SI_IPv6_MAXLEN];

    if ((family != FamilyInternet6) || (len != sizeof(addr6)))
        return FALSE;

    memcpy(addrbuf, siAddr, siAddrlen);
    addrbuf[siAddrlen] = '\0';

    if (inet_pton(AF_INET6, addrbuf, &addr6) != 1) {
        perror("inet_pton");
        return FALSE;
    }

    if (memcmp(addr, &addr6, len) == 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

static int
siIPv6CheckAddr(const char *addrString, int length, void *typePriv)
{
    int len;

    /* Minimum length is 3 (smallest legal address is "::1") */
    if (length < 3) {
        /* Address is too short! */
        len = -1;
    }
    else if (length >= SI_IPv6_MAXLEN) {
        /* Address is too long! */
        len = -1;
    }
    else {
        /* Assume inet_pton is sufficient validation */
        struct in6_addr addr6;
        char addrbuf[SI_IPv6_MAXLEN];

        memcpy(addrbuf, addrString, length);
        addrbuf[length] = '\0';

        if (inet_pton(AF_INET6, addrbuf, &addr6) != 1) {
            perror("inet_pton");
            len = -1;
        }
        else {
            len = length;
        }
    }
    return len;
}
#endif                          /* IPv6 */

#if !defined(NO_LOCAL_CLIENT_CRED)
/***
 * "localuser" & "localgroup" server interpreted types
 *
 * Allows local connections from a given local user or group
 */

#include <pwd.h>
#include <grp.h>

#define LOCAL_USER 1
#define LOCAL_GROUP 2

typedef struct {
    int credType;
} siLocalCredPrivRec, *siLocalCredPrivPtr;

static siLocalCredPrivRec siLocalUserPriv = { LOCAL_USER };
static siLocalCredPrivRec siLocalGroupPriv = { LOCAL_GROUP };

static Bool
siLocalCredGetId(const char *addr, int len, siLocalCredPrivPtr lcPriv, int *id)
{
    Bool parsedOK = FALSE;
    char *addrbuf = malloc(len + 1);

    if (addrbuf == NULL) {
        return FALSE;
    }

    memcpy(addrbuf, addr, len);
    addrbuf[len] = '\0';

    if (addr[0] == '#') {       /* numeric id */
        char *cp;

        errno = 0;
        *id = strtol(addrbuf + 1, &cp, 0);
        if ((errno == 0) && (cp != (addrbuf + 1))) {
            parsedOK = TRUE;
        }
    }
    else {                      /* non-numeric name */
        if (lcPriv->credType == LOCAL_USER) {
            struct passwd *pw = getpwnam(addrbuf);

            if (pw != NULL) {
                *id = (int) pw->pw_uid;
                parsedOK = TRUE;
            }
        }
        else {                  /* group */
            struct group *gr = getgrnam(addrbuf);

            if (gr != NULL) {
                *id = (int) gr->gr_gid;
                parsedOK = TRUE;
            }
        }
    }

    free(addrbuf);
    return parsedOK;
}

static Bool
siLocalCredAddrMatch(int family, void *addr, int len,
                     const char *siAddr, int siAddrlen, ClientPtr client,
                     void *typePriv)
{
    int siAddrId;
    LocalClientCredRec *lcc;
    siLocalCredPrivPtr lcPriv = (siLocalCredPrivPtr) typePriv;

    if (GetLocalClientCreds(client, &lcc) == -1) {
        return FALSE;
    }

#ifdef HAVE_GETZONEID           /* Ensure process is in the same zone */
    if ((lcc->fieldsSet & LCC_ZID_SET) && (lcc->zoneid != getzoneid())) {
        FreeLocalClientCreds(lcc);
        return FALSE;
    }
#endif

    if (siLocalCredGetId(siAddr, siAddrlen, lcPriv, &siAddrId) == FALSE) {
        FreeLocalClientCreds(lcc);
        return FALSE;
    }

    if (lcPriv->credType == LOCAL_USER) {
        if ((lcc->fieldsSet & LCC_UID_SET) && (lcc->euid == siAddrId)) {
            FreeLocalClientCreds(lcc);
            return TRUE;
        }
    }
    else {
        if ((lcc->fieldsSet & LCC_GID_SET) && (lcc->egid == siAddrId)) {
            FreeLocalClientCreds(lcc);
            return TRUE;
        }
        if (lcc->pSuppGids != NULL) {
            int i;

            for (i = 0; i < lcc->nSuppGids; i++) {
                if (lcc->pSuppGids[i] == siAddrId) {
                    FreeLocalClientCreds(lcc);
                    return TRUE;
                }
            }
        }
    }
    FreeLocalClientCreds(lcc);
    return FALSE;
}

static int
siLocalCredCheckAddr(const char *addrString, int length, void *typePriv)
{
    int len = length;
    int id;

    if (siLocalCredGetId(addrString, length,
                         (siLocalCredPrivPtr) typePriv, &id) == FALSE) {
        len = -1;
    }
    return len;
}
#endif                          /* localuser */

static void
siTypesInitialize(void)
{
    siTypeAdd("hostname", siHostnameAddrMatch, siHostnameCheckAddr, NULL);
#if defined(IPv6) && defined(AF_INET6)
    siTypeAdd("ipv6", siIPv6AddrMatch, siIPv6CheckAddr, NULL);
#endif
#if !defined(NO_LOCAL_CLIENT_CRED)
    siTypeAdd("localuser", siLocalCredAddrMatch, siLocalCredCheckAddr,
              &siLocalUserPriv);
    siTypeAdd("localgroup", siLocalCredAddrMatch, siLocalCredCheckAddr,
              &siLocalGroupPriv);
#endif
}
@


1.17
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d176 4
d1088 2
a1089 3
/* Is client on the local host */
Bool
ComputeLocalClient(ClientPtr client)
d1120 35
@


1.16
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a1223 1
#define NO_LOCAL_CLIENT_CRED
d1575 14
@


1.15
log
@Update to xorg-server  1.16.3.

Most of the 1.16.2->1.16.3 changes are the security patches that
where already there. This adds some extra fixes plus a few unrelated
bug fixes.
@
text
@d38 2
a39 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d41 1
a41 1
both that copyright notice and this permission notice appear in 
d44 1
a44 1
software without specific, written prior permission.  
d105 4
d208 1
a208 1
   checked in DisableLocalHost(), which is called to disable the default 
d232 7
d251 15
d278 15
d306 68
d421 1
a421 1
 * Define this host for access control.  Find all the hosts the OS knows about 
d824 1
a824 1
            /* 
d947 1
a947 1
    void *addr;
d1040 2
a1041 2
                            if ((family == f) ||
                                ((family == FamilyWild) && (f != -1))) {
a1119 27
 * Return the uid and gid of a connected local client
 * 
 * Used by XShm to test access rights to shared memory segments
 */
int
LocalClientCred(ClientPtr client, int *pUid, int *pGid)
{
    LocalClientCredRec *lcc;
    int ret = GetLocalClientCreds(client, &lcc);

    if (ret == 0) {
#ifdef HAVE_GETZONEID           /* only local if in the same zone */
        if ((lcc->fieldsSet & LCC_ZID_SET) && (lcc->zoneid != getzoneid())) {
            FreeLocalClientCreds(lcc);
            return -1;
        }
#endif
        if ((lcc->fieldsSet & LCC_UID_SET) && (pUid != NULL))
            *pUid = lcc->euid;
        if ((lcc->fieldsSet & LCC_GID_SET) && (pGid != NULL))
            *pGid = lcc->egid;
        FreeLocalClientCreds(lcc);
    }
    return ret;
}

/*
d1122 1
a1122 1
 * 
d1149 2
a1150 2
    /* Most implementations can only determine peer credentials for Unix 
     * domain sockets - Solaris getpeerucred can work with a bit more, so 
d1302 3
a1304 3
ForEachHostInFamily(int family, Bool (*func) (unsigned char * /* addr */ ,
                                              short /* len */ ,
                                              void */* closure */ ),
d1315 1
a1315 1
/* Add a host to the access control list. This is the internal interface 
d1470 1
a1470 1
/* Check if a host is not in the access control list. 
d1477 1
a1477 1
    void *addr;
d1488 1
a1488 1
             * check to see if any local address is enabled.  This 
d1509 1
a1509 1
            if (addrEqual(family, addr, len, host))
d1592 1
a1592 1
/* These definitions and the siTypeAdd function could be exported in the 
d1689 1
a1689 1
         * and the second string is a valid address of that type. 
d1756 2
a1757 2
/* Currently only supports checking against IPv4 & IPv6 connections, but 
 * support for other address families, such as DECnet, could be added if 
d1766 1
a1766 1
        void *hostaddr;
d1777 1
a1777 1
                if ((f == family) && (len == hostaddrlen) &&
d1835 1
a1835 1
     * character sets.  Hostnames must be pure ASCII.  
d1889 1
a1889 1
 * Once draft-ietf-ipv6-scoping-arch-00.txt becomes an RFC, support will be 
d1893 2
a1894 2
/* Maximum length of an IPv6 address string - increase when adding support 
 * for scoped address qualifiers.  Includes room for trailing NUL byte. 
@


1.14
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d1338 1
a1338 1
            if ((ptr + sizeof(xHostEntry) + len) > (data + n))
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1326 4
d1338 2
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d189 1
a189 1
                       pointer * /*addr */ );
d229 1
a229 1
static Bool siAddrMatch(int family, pointer addr, int len, HOST * host,
d261 1
a261 1
                              (pointer) self->addr);
d385 1
a385 1
        family = ConvertAddr(&(saddr.sa), &len, (pointer *) &addr);
d548 1
a548 1
    if (ifioctl(fd, IFC_IOCTL_REQ, (pointer) &ifc) < 0)
d557 1
a557 1
                             &len, (pointer *) &addr);
d652 1
a652 1
                if (ifioctl(fd, SIOCGIFFLAGS, (pointer) &broad_req) != -1 &&
d657 1
a657 1
                    if (ifioctl(fd, SIOCGIFBRDADDR, (pointer) &broad_req) != -1)
d682 1
a682 1
                             (pointer *) &addr);
d778 1
a778 1
AugmentSelf(pointer from, int len)
d781 1
a781 1
    pointer addr;
d784 1
a784 1
    family = ConvertAddr(from, &len, (pointer *) &addr);
d817 1
a817 1
ResetHosts(char *display)
d838 1
a838 1
    pointer addr;
d930 1
a930 1
                                            (pointer *) &addr);
d953 1
a953 1
                                     (pointer *) &addr)) != -1) {
d959 1
a959 1
                            (void) NewHost(family, (pointer) *list, len, FALSE);
d961 1
a961 1
                        (void) NewHost(family, (pointer) hp->h_addr, len,
d981 1
a981 1
    pointer addr;
d990 1
a990 1
                             &alen, (pointer *) &addr);
d1222 2
a1223 2
                                              pointer /* closure */ ),
                    pointer closure)
d1267 1
a1267 1
           pointer pAddr)
d1314 1
a1314 1
GetHosts(pointer *data, int *pnHosts, int *pLen, BOOL * pEnabled)
d1389 1
a1389 1
    pointer addr;
d1394 1
a1394 1
    family = ConvertAddr(saddr, &len, (pointer *) &addr);
d1430 1
a1430 1
ConvertAddr(register struct sockaddr *saddr, int *len, pointer *addr)
d1447 1
a1447 1
        *addr = (pointer) &(((struct sockaddr_in *) saddr)->sin_addr);
d1456 1
a1456 1
            *addr = (pointer) &(saddr6->sin6_addr.s6_addr[12]);
d1461 1
a1461 1
            *addr = (pointer) &(saddr6->sin6_addr);
d1508 1
a1508 1
typedef Bool (*siAddrMatchFunc) (int family, pointer addr, int len,
d1561 1
a1561 1
siAddrMatch(int family, pointer addr, int len, HOST * host, ClientPtr client)
d1662 1
a1662 1
siHostnameAddrMatch(int family, pointer addr, int len,
d1678 1
a1678 1
        pointer hostaddr;
d1707 1
a1707 1
        pointer hostaddr;
d1811 1
a1811 1
siIPv6AddrMatch(int family, pointer addr, int len,
d1937 1
a1937 1
siLocalCredAddrMatch(int family, pointer addr, int len,
@


1.12.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1325 4
        /* Could check for INT_MAX, but in reality having more than 1mb of
           hostnames in the access list is ridiculous */
        if (n >= 1048576)
            break;
a1333 2
            if ((ptr + sizeof(xHostEntry) + len) > (data + n))
                break;
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d166 4
a464 4
#endif

#if defined(IPv6) && defined(AF_INET6)
#include <arpa/inet.h>
@


1.11.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1325 4
        /* Could check for INT_MAX, but in reality having more than 1mb of
           hostnames in the access list is ridiculous */
        if (n >= 1048576)
            break;
a1333 2
            if ((ptr + sizeof(xHostEntry) + len) > (data + n))
                break;
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d474 1
a474 1
            ntohs(*(u_int16_t *) & sin6->sin6_addr.s6_addr[2]);
a1009 8
Bool
LocalClient(ClientPtr client)
{
    if (!client->osPrivate)
        return FALSE;
    return ((OsCommPtr) client->osPrivate)->local_client;
}

d1171 1
a1171 1
    return LocalClient(client) ? Success : BadAccess;
@


1.9
log
@Update to xserver 1.11.2
@
text
@d105 1
a105 1
#if defined(TCPCONN) || defined(STREAMSCONN) 
d107 1
a107 1
#endif /* TCPCONN || STREAMSCONN */
d109 5
a113 5
#ifdef HAS_GETPEERUCRED
# include <ucred.h>
# ifdef sun
#  include <zone.h>
# endif
d117 1
a117 1
# include <sys/utsname.h>
d120 1
a120 1
# include <sys/stream.h>
d125 2
a126 2
#else /*!__GNU__*/
# include <net/if.h>
d149 1
a149 1
#ifdef HAS_GETIFADDRS
d166 1
a166 2
#endif /* WIN32 */

a177 2
#define acmp(a1, a2, len) memcmp((char *)(a1), (char *)(a2), len)
#define acopy(a1, a2, len) memmove((char *)(a2), (char *)(a1), len)
d181 1
a181 1
			  !acmp (address, (host)->addr, length))
d183 12
a194 12
static int ConvertAddr(struct sockaddr * /*saddr*/,
		       int * /*len*/,
		       pointer * /*addr*/);

static int CheckAddr(int /*family*/,
		     const void * /*pAddr*/,
		     unsigned /*length*/);

static Bool NewHost(int /*family*/,
		    const void  * /*addr*/,
		    int /*len*/,
		    int /* addingLocalHosts */);
d204 5
a208 5
	short		family;
	short		len;
	unsigned char	*addr;
	struct _host *next;
	int		requested;
d225 3
a227 3
static Bool siAddrMatch(int family, pointer addr, int len, HOST *host, 
	ClientPtr client);
static int  siCheckAddr(const char *addrString, int length);
d236 1
a236 1
EnableLocalHost (void)
d238 3
a240 4
    if (!UsingXdmcp)
    {
	LocalHostEnabled = TRUE;
	AddLocalHosts ();
d248 1
a248 1
DisableLocalHost (void)
d252 2
a253 2
    if (!LocalHostRequested)		/* Fix for XFree86 bug #156 */
	LocalHostEnabled = FALSE;
d255 3
a257 2
      if (!self->requested)		/* Fix for XFree86 bug #156 */
	(void) RemoveHost ((ClientPtr)NULL, self->family, self->len, (pointer)self->addr);
d267 1
a267 1
AccessUsingXdmcp (void)
a272 1

d278 1
a278 1
ifioctl (int fd, int cmd, char *arg)
d286 7
a292 9
    if (cmd == SIOCGIFCONF)
    {
	ioc.ic_len = ((struct ifconf *) arg)->ifc_len;
	ioc.ic_dp = ((struct ifconf *) arg)->ifc_buf;
    }
    else
    {
	ioc.ic_len = sizeof(struct ifreq);
	ioc.ic_dp = arg;
d297 1
a297 1
	((struct ifconf *) arg)->ifc_len = ioc.ic_len;
d312 1
a312 1
#if !defined(SIOCGIFCONF) 
d314 1
a314 1
DefineSelf (int fd)
d320 4
a323 4
    int	len;
    caddr_t	addr;
    int		family;
    register HOST	*host;
d329 1
a329 1
        char  nodename[512];	    
d333 1
a333 1
    register struct hostent  *hp;
d336 2
a337 2
	struct  sockaddr   sa;
	struct  sockaddr_in  in;
d339 1
a339 1
	struct  sockaddr_in6  in6;
d342 3
a344 3
	
    struct	sockaddr_in	*inetaddr;
    struct	sockaddr_in6	*inet6addr;
d346 1
d363 33
a395 37
    if (hp != NULL)
    {
	saddr.sa.sa_family = hp->h_addrtype;
	switch (hp->h_addrtype) {
	case AF_INET:
	    inetaddr = (struct sockaddr_in *) (&(saddr.sa));
	    acopy ( hp->h_addr, &(inetaddr->sin_addr), hp->h_length);
	    len = sizeof(saddr.sa);
	    break;
#if defined(IPv6) && defined(AF_INET6)
	case AF_INET6:
	    inet6addr = (struct sockaddr_in6 *) (&(saddr.sa));
	    acopy ( hp->h_addr, &(inet6addr->sin6_addr), hp->h_length);
	    len = sizeof(saddr.in6);
	    break;
#endif
	default:
	    goto DefineLocalHost;
	}
	family = ConvertAddr ( &(saddr.sa), &len, (pointer *)&addr);
	if ( family != -1 && family != FamilyLocal )
	{
	    for (host = selfhosts;
		 host && !addrEqual (family, addr, len, host);
		 host = host->next) ;
	    if (!host)
	    {
		/* add this host to the host list.	*/
		MakeHost(host,len)
		if (host)
		{
		    host->family = family;
		    host->len = len;
		    acopy ( addr, host->addr, len);
		    host->next = selfhosts;
		    selfhosts = host;
		}
d397 28
a424 30
		/*
		 *  If this is an Internet Address, but not the localhost
		 *  address (127.0.0.1), nor the bogus address (0.0.0.0),
		 *  register it.
		 */
		if (family == FamilyInternet &&
		    !(len == 4 &&
		      ((addr[0] == 127) ||
		       (addr[0] == 0 && addr[1] == 0 &&
			addr[2] == 0 && addr[3] == 0)))
		      )
		{
		    XdmcpRegisterConnection (family, (char *)addr, len);
		    broad_addr = *inetaddr;
		    ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
			htonl (INADDR_BROADCAST);
		    XdmcpRegisterBroadcastAddress ((struct sockaddr_in *)
						   &broad_addr);
		}
#if defined(IPv6) && defined(AF_INET6)
		else if (family == FamilyInternet6 &&
		  !(IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr)))
		{
		    XdmcpRegisterConnection (family, (char *)addr, len);
		}
#endif

#endif /* XDMCP */
	    }
	}
d429 1
a429 1
DefineLocalHost:
d431 10
a440 13
	 host && !addrEqual(FamilyLocalHost, "", 0, host);
	 host = host->next);
    if (!host)
    {
	MakeHost(host, 0);
	if (host)
	{
	    host->family = FamilyLocalHost;
	    host->len = 0;
	    acopy("", host->addr, 0);
	    host->next = selfhosts;
	    selfhosts = host;
	}
d442 1
a442 1
#endif /* !TCPCONN && !STREAMSCONN && !UNIXCONN */
d472 5
a476 5
	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
		sin6->sin6_scope_id =
			ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
		sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
	}
d482 1
a482 1
DefineSelf (int fd)
d484 4
a487 3
#ifndef HAS_GETIFADDRS
    char 		*cp, *cplim;
# ifdef USE_SIOCGLIFCONF
d489 1
a489 1
    struct lifconf	ifc;
d491 7
a497 6
#  ifdef SIOCGLIFNUM
    struct lifnum	ifn;
#  endif
# else /* !USE_SIOCGLIFCONF */
    char		buf[2048];
    struct ifconf	ifc;
d499 11
a509 11
# endif
    void *		bufptr = buf;   
#else /* HAS_GETIFADDRS */
    struct ifaddrs *	ifap, *ifr;
#endif
    int 		len;
    unsigned char *	addr;
    int 		family;
    register HOST 	*host;
    
#ifndef HAS_GETIFADDRS
d514 1
a514 1
    
d518 2
a519 2
    if (ioctl (fd, SIOCGLIFNUM, (char *) &ifn) < 0)
        Error ("Getting interface count");    
d521 2
a522 2
	len = ifn.lifn_count * sizeof(struct lifreq);
	bufptr = malloc(len);
d525 1
a525 1
    
d537 1
a537 1
#else /* Use SIOCGIFCONF */
d548 2
a549 2
    if (ifioctl (fd, IFC_IOCTL_REQ, (pointer) &ifc) < 0)
        Error ("Getting interface configuration (4)");
d552 6
a557 7
    
    for (cp = (char *) IFC_IFC_REQ; cp < cplim; cp += ifr_size (ifr))
    {
	ifr = (ifr_type *) cp;
	len = ifraddr_size (IFR_IFR_ADDR);
	family = ConvertAddr ((struct sockaddr *) &IFR_IFR_ADDR, 
	  			&len, (pointer *)&addr);
d559 1
a559 1
	    continue;
d561 2
a562 2
	if (family == FamilyInternet6) 
	    in6_fillscopeid((struct sockaddr_in6 *)&IFR_IFR_ADDR);
d565 1
a565 3
 	     host && !addrEqual (family, addr, len, host);
	     host = host->next)
	    ;
d567 9
a575 10
	    continue;
	MakeHost(host,len)
	if (host)
	{
	    host->family = family;
	    host->len = len;
	    acopy(addr, host->addr, len);
	    host->next = selfhosts;
	    selfhosts = host;
	}
d577 1
a577 1
	{
d579 1
a579 1
	    struct sockaddr_storage broad_addr;
d581 1
a581 1
	    struct sockaddr broad_addr;
d584 4
a587 4
	    /*
	     * If this isn't an Internet Address, don't register it.
	     */
	    if (family != FamilyInternet
d589 1
a589 1
	      && family != FamilyInternet6
d591 2
a592 2
		)
		continue;
d594 7
a600 8
	    /*
 	     * ignore 'localhost' entries as they're not useful
	     * on the other end of the wire
	     */
	    if (family == FamilyInternet &&
		addr[0] == 127 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 1)
		continue;
d602 3
a604 3
	    else if (family == FamilyInternet6 && 
	      IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr))
		continue;
d607 8
a614 9
	    /*
	     * Ignore '0.0.0.0' entries as they are
	     * returned by some OSes for unconfigured NICs but they are
	     * not useful on the other end of the wire.
	     */
	    if (len == 4 &&
		addr[0] == 0 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 0)
		continue;
d616 1
a616 1
	    XdmcpRegisterConnection (family, (char *)addr, len);
d619 3
a621 3
	    /* IPv6 doesn't support broadcasting, so we drop out here */
	    if (family == FamilyInternet6)
		continue;
d624 1
a624 1
	    broad_addr = IFR_IFR_ADDR;
d626 2
a627 2
	    ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
		htonl (INADDR_BROADCAST);
d629 17
a645 18
	    {
	    	struct lifreq    broad_req;
    
	    	broad_req = *ifr;
		if (ioctl (fd, SIOCGLIFFLAGS, (char *) &broad_req) != -1 &&
		    (broad_req.lifr_flags & IFF_BROADCAST) &&
		    (broad_req.lifr_flags & IFF_UP)
		    )
		{
		    broad_req = *ifr;
		    if (ioctl (fd, SIOCGLIFBRDADDR, &broad_req) != -1)
			broad_addr = broad_req.lifr_broadaddr;
		    else
			continue;
		}
		else
		    continue;
	    }
d648 21
a668 22
	    {
	    	struct ifreq    broad_req;
    
	    	broad_req = *ifr;
		if (ifioctl (fd, SIOCGIFFLAGS, (pointer) &broad_req) != -1 &&
		    (broad_req.ifr_flags & IFF_BROADCAST) &&
		    (broad_req.ifr_flags & IFF_UP)
		    )
		{
		    broad_req = *ifr;
		    if (ifioctl (fd, SIOCGIFBRDADDR, (pointer) &broad_req) != -1)
			broad_addr = broad_req.ifr_addr;
		    else
			continue;
		}
		else
		    continue;
	    }
#endif /* SIOCGIFBRDADDR */
	    XdmcpRegisterBroadcastAddress ((struct sockaddr_in *) &broad_addr);
	}
#endif /* XDMCP */
d671 2
a672 2
        free(bufptr);    
#else /* HAS_GETIFADDRS */
d674 2
a675 2
	ErrorF("Warning: getifaddrs returns %s\n", strerror(errno));
	return;
d680 23
a702 24
	len = sizeof(*(ifr->ifa_addr));
	family = ConvertAddr((struct sockaddr *) ifr->ifa_addr, &len,
			     (pointer *)&addr);
	if (family == -1 || family == FamilyLocal) 
	    continue;
#if defined(IPv6) && defined(AF_INET6)
	if (family == FamilyInternet6) 
	    in6_fillscopeid((struct sockaddr_in6 *)ifr->ifa_addr);
#endif

	for (host = selfhosts; 
	     host != NULL && !addrEqual(family, addr, len, host);
	     host = host->next) 
	    ;
	if (host != NULL) 
	    continue;
	MakeHost(host, len);
	if (host != NULL) {
	    host->family = family;
	    host->len = len;
	    acopy(addr, host->addr, len);
	    host->next = selfhosts;
	    selfhosts = host;
	}
d704 51
a754 54
	{
	    /*
	     * If this isn't an Internet Address, don't register it.
	     */
	    if (family != FamilyInternet
#if defined(IPv6) && defined(AF_INET6)
		&& family != FamilyInternet6
#endif
	    )
		continue;

	    /* 
	     * ignore 'localhost' entries as they're not useful
	     * on the other end of the wire
	     */
	    if (ifr->ifa_flags & IFF_LOOPBACK) 
		    continue;

	    if (family == FamilyInternet && 
		addr[0] == 127 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 1) 
		continue;

	    /*
	     * Ignore '0.0.0.0' entries as they are
	     * returned by some OSes for unconfigured NICs but they are
	     * not useful on the other end of the wire.
	     */
	    if (len == 4 &&
		addr[0] == 0 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 0)
		continue;
#if defined(IPv6) && defined(AF_INET6)
	    else if (family == FamilyInternet6 && 
	      IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr))
		continue;
#endif
	    XdmcpRegisterConnection(family, (char *)addr, len);
#if defined(IPv6) && defined(AF_INET6)
	    if (family == FamilyInternet6) 
		/* IPv6 doesn't support broadcasting, so we drop out here */
		continue;
#endif
	    if ((ifr->ifa_flags & IFF_BROADCAST) &&
		(ifr->ifa_flags & IFF_UP) &&
                ifr->ifa_broadaddr)
		XdmcpRegisterBroadcastAddress(
		    (struct sockaddr_in *) ifr->ifa_broadaddr);
	    else
		continue;
	}
#endif /* XDMCP */
		
    } /* for */
d756 1
a756 1
#endif /* HAS_GETIFADDRS */
d762 10
a771 13
	 host && !addrEqual(FamilyLocalHost, "", 0, host);
	 host = host->next);
    if (!host)
    {
	MakeHost(host, 0);
	if (host)
	{
	    host->family = FamilyLocalHost;
	    host->len = 0;
	    acopy("", host->addr, 0);
	    host->next = selfhosts;
	    selfhosts = host;
	}
d774 1
a774 1
#endif /* hpux && !HAS_IFREQ */
d784 1
a784 1
    family = ConvertAddr(from, &len, (pointer *)&addr);
d786 8
a793 9
	return;
    for (host = selfhosts; host; host = host->next)
    {
	if (addrEqual(family, addr, len, host))
	    return;
    }
    MakeHost(host,len)
    if (!host)
	return;
d796 1
a796 1
    acopy(addr, host->addr, len);
d803 1
a803 1
AddLocalHosts (void)
d805 1
a805 1
    HOST    *self;
d808 5
a812 5
	    /* Fix for XFree86 bug #156: pass addingLocal = TRUE to
	     * NewHost to tell that we are adding the default local
	     * host entries and not to flag the entries as being
	     * explicitely requested */
	(void) NewHost (self->family, self->addr, self->len, TRUE);
d817 1
a817 1
ResetHosts (char *display)
d819 9
a827 8
    register HOST	*host;
    char                lhostname[120], ohostname[120];
    char 		*hostname = ohostname;
    char		fname[PATH_MAX + 1];
    int			fnamelen;
    FILE		*fd;
    char		*ptr;
    int                 i, hostlen;
d831 1
a831 1
        struct sockaddr	sa;
d833 7
a839 7
	struct sockaddr_in in;
#endif /* TCPCONN || STREAMSCONN */
    }			saddr;
#endif
    int			family = 0;
    pointer		addr;
    int 		len;
d844 1
a844 2
    while ((host = validhosts) != 0)
    {
d846 1
a846 1
        FreeHost (host);
d856 1
a856 1
		strlen(display) + 1;
d858 20
a877 23
	FatalError("Display name `%s' is too long\n", display);
    snprintf(fname, sizeof(fname), ETC_HOST_PREFIX "%s" ETC_HOST_SUFFIX, 
	     display);

    if ((fd = fopen (fname, "r")) != 0)
    {
        while (fgets (ohostname, sizeof (ohostname), fd))
	{
	family = FamilyWild;
	if (*ohostname == '#')
	    continue;
    	if ((ptr = strchr(ohostname, '\n')) != 0)
    	    *ptr = 0;
        hostlen = strlen(ohostname) + 1;
        for (i = 0; i < hostlen; i++)
	    lhostname[i] = tolower(ohostname[i]);
	hostname = ohostname;
	if (!strncmp("local:", lhostname, 6))
	{
	    family = FamilyLocalHost;
	    NewHost(family, "", 0, FALSE);
	    LocalHostRequested = TRUE;	/* Fix for XFree86 bug #156 */
	}
d879 9
a887 11
	else if (!strncmp("inet:", lhostname, 5))
	{
	    family = FamilyInternet;
	    hostname = ohostname + 5;
	}
#if defined(IPv6) && defined(AF_INET6)
	else if (!strncmp("inet6:", lhostname, 6))
	{
	    family = FamilyInternet6;
	    hostname = ohostname + 6;
	}
d891 18
a908 22
	else if (!strncmp("nis:", lhostname, 4))
	{
	    family = FamilyNetname;
	    hostname = ohostname + 4;
	}
#endif
	else if (!strncmp("si:", lhostname, 3))
	{
	    family = FamilyServerInterpreted;
	    hostname = ohostname + 3;
	    hostlen -= 3;
	}


	if (family == FamilyServerInterpreted) 
	{
	    len = siCheckAddr(hostname, hostlen);
	    if (len >= 0) {
		NewHost(family, hostname, len, FALSE);
	    }
	}
	else
d910 7
a916 7
	if ((family == FamilyNetname) || (strchr(hostname, '@@')))
	{
	    SecureRPCInit ();
	    (void) NewHost (FamilyNetname, hostname, strlen (hostname), FALSE);
	}
	else
#endif /* SECURE_RPC */
d918 1
a918 1
	{
d920 19
a938 19
	    if ( (family == FamilyInternet) || (family == FamilyInternet6) ||
		 (family == FamilyWild) ) 
            {
		struct addrinfo *addresses;
		struct addrinfo *a;
		int f;
	    
		if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
		    for (a = addresses ; a != NULL ; a = a->ai_next) {
			len = a->ai_addrlen;
			f = ConvertAddr(a->ai_addr,&len,(pointer *)&addr);
			if ( (family == f) || 
			     ((family == FamilyWild) && (f != -1)) ) {
			    NewHost(f, addr, len, FALSE);
			}			
		    }
		    freeaddrinfo(addresses);
		}
	    }
d941 1
a941 1
	    _Xgethostbynameparams hparams;
d943 1
a943 1
	    register struct hostent *hp;
d945 15
a959 15
    	    /* host name */
    	    if ((family == FamilyInternet &&
		 ((hp = _XGethostbyname(hostname, hparams)) != 0)) ||
		((hp = _XGethostbyname(hostname, hparams)) != 0))
	    {
    		saddr.sa.sa_family = hp->h_addrtype;
		len = sizeof(saddr.sa);
    		if ((family = ConvertAddr (&saddr.sa, &len, (pointer *)&addr)) != -1)
		{
#ifdef h_addr				/* new 4.3bsd version of gethostent */
		    char **list;

		    /* iterate over the addresses */
		    for (list = hp->h_addr_list; *list; list++)
			(void) NewHost (family, (pointer)*list, len, FALSE);
d961 2
a962 1
    		    (void) NewHost (family, (pointer)hp->h_addr, len, FALSE);
d964 6
a969 6
		}
    	    }
#endif /* IPv6 */
        }
#endif /* TCPCONN || STREAMSCONN */
	family = FamilyWild;
d971 1
a971 1
        fclose (fd);
d979 5
a983 5
    int    		alen, family, notused;
    Xtransaddr		*from = NULL;
    pointer		addr;
    register HOST	*host;
    OsCommPtr           oc = (OsCommPtr) client->osPrivate;
d988 18
a1005 22
    if (!_XSERVTransGetPeerAddr (oc->trans_conn, &notused, &alen, &from))
    {
	family = ConvertAddr ((struct sockaddr *) from,
	    &alen, (pointer *)&addr);
	if (family == -1)
	{
	    free(from);
	    return FALSE;
	}
	if (family == FamilyLocal)
	{
	    free(from);
	    return TRUE;
	}
	for (host = selfhosts; host; host = host->next)
	{
	    if (addrEqual (family, addr, alen, host)) {
		free(from);
		return TRUE;
	    }
	}
	free(from);
d1010 2
a1011 1
Bool LocalClient(ClientPtr client)
d1015 1
a1015 1
    return ((OsCommPtr)client->osPrivate)->local_client;
d1030 11
a1040 11
#ifdef HAVE_GETZONEID /* only local if in the same zone */
	if ((lcc->fieldsSet & LCC_ZID_SET) && (lcc->zoneid != getzoneid())) {
	    FreeLocalClientCreds(lcc);
	    return -1;
	}	    
#endif
	if ((lcc->fieldsSet & LCC_UID_SET) && (pUid != NULL))
	    *pUid = lcc->euid;
	if ((lcc->fieldsSet & LCC_GID_SET) && (pGid != NULL))
	    *pGid = lcc->egid;
	FreeLocalClientCreds(lcc);
d1053 1
a1053 1
GetLocalClientCreds(ClientPtr client, LocalClientCredRec **lccp)
d1055 1
a1055 1
#if defined(HAS_GETPEEREID) || defined(HAS_GETPEERUCRED) || defined(SO_PEERCRED)
d1059 2
a1060 1
#ifdef HAS_GETPEEREID
d1063 1
a1063 1
#elif defined(HAS_GETPEERUCRED)
d1072 3
a1074 3
	return -1;
    ci = ((OsCommPtr)client->osPrivate)->trans_conn;
#if !(defined(sun) && defined(HAS_GETPEERUCRED))
d1080 1
a1080 1
	return -1;
d1086 1
a1086 1
	return -1;
d1088 1
a1088 1
        
d1090 1
a1090 1
#ifdef HAS_GETPEEREID
d1092 2
a1093 2
	FreeLocalClientCreds(lcc);
	return -1;
d1099 1
a1099 1
#elif defined(HAS_GETPEERUCRED)
d1101 2
a1102 2
	FreeLocalClientCreds(lcc);
    	return -1;
d1106 1
a1106 1
	lcc->fieldsSet |= LCC_UID_SET;
d1109 1
a1109 1
	lcc->fieldsSet |= LCC_GID_SET;
d1112 1
a1112 1
	lcc->fieldsSet |= LCC_PID_SET;
d1116 1
a1116 1
	lcc->fieldsSet |= LCC_ZID_SET;
d1120 14
a1133 11
	lcc->pSuppGids = calloc(lcc->nSuppGids, sizeof(int));
	if (lcc->pSuppGids == NULL) {
	    lcc->nSuppGids = 0;
	} else {
	    int i;
	    for (i = 0 ; i < lcc->nSuppGids; i++) {
		(lcc->pSuppGids)[i] = (int) gids[i];
	    }
	}
    } else {
	lcc->nSuppGids = 0;
d1139 2
a1140 2
	FreeLocalClientCreds(lcc);
	return -1;
d1156 1
a1156 1
FreeLocalClientCreds(LocalClientCredRec *lcc)
d1159 4
a1162 4
	if (lcc->nSuppGids > 0) {
	    free(lcc->pSuppGids);
	}
	free(lcc);
d1172 1
a1172 1
	return Success;
d1177 1
a1177 1
	return rc;
d1186 2
a1187 4
AddHost (ClientPtr	client,
	 int            family,
	 unsigned       length,        /* of bytes in pAddr */
	 const void *   pAddr)
d1193 1
a1193 1
	return rc;
d1196 3
a1198 3
	len = length;
	LocalHostEnabled = TRUE;
	break;
d1201 3
a1203 3
	len = length;
	SecureRPCInit ();
	break;
d1212 5
a1216 6
	if ((len = CheckAddr (family, pAddr, length)) < 0)
	{
	    client->errorValue = length;
	    return BadValue;
	}
	break;
d1219 2
a1220 2
	client->errorValue = family;
	return BadValue;
d1222 2
a1223 2
    if (NewHost (family, pAddr, len, FALSE))
	return Success;
d1228 4
a1231 6
ForEachHostInFamily (int	    family,
		     Bool    (*func)(
			 unsigned char * /* addr */,
			 short           /* len */,
			 pointer         /* closure */),
		     pointer closure)
d1233 1
a1233 1
    HOST    *host;
d1236 2
a1237 2
	if (family == host->family && func (host->addr, host->len, closure))
	    return TRUE;
d1244 1
a1244 4
NewHost (int		family,
	 const void *	addr,
	 int		len,
	 int		addingLocalHosts)
d1248 11
a1258 4
    for (host = validhosts; host; host = host->next)
    {
        if (addrEqual (family, addr, len, host))
	    return TRUE;
d1260 3
a1262 11
    if (!addingLocalHosts) {			/* Fix for XFree86 bug #156 */
	for (host = selfhosts; host; host = host->next) {
	    if (addrEqual (family, addr, len, host)) {
		host->requested = TRUE;
		break;
	    }	    
	}
    }
    MakeHost(host,len)
    if (!host)
	return FALSE;
d1265 1
a1265 1
    acopy(addr, host->addr, len);
d1274 2
a1275 5
RemoveHost (
    ClientPtr		client,
    int                 family,
    unsigned            length,        /* of bytes in pAddr */
    pointer             pAddr)
d1278 1
a1278 1
    register HOST	*host, **prev;
d1282 1
a1282 1
	return rc;
d1285 3
a1287 3
	len = length;
	LocalHostEnabled = FALSE;
	break;
d1290 2
a1291 2
	len = length;
	break;
d1300 2
a1301 3
    	if ((len = CheckAddr (family, pAddr, length)) < 0)
    	{
	    client->errorValue = length;
d1303 2
a1304 2
    	}
	break;
d1307 1
a1307 1
	client->errorValue = family;
d1311 3
a1313 5
         (host = *prev) && (!addrEqual (family, pAddr, len, host));
         prev = &host->next)
        ;
    if (host)
    {
d1315 1
a1315 1
        FreeHost (host);
d1322 1
a1322 5
GetHosts (
    pointer		*data,
    int			*pnHosts,
    int			*pLen,
    BOOL		*pEnabled)
d1324 2
a1325 2
    int			len;
    register int 	n = 0;
d1327 2
a1328 2
    register HOST	*host;
    int			nHosts = 0;
d1331 3
a1333 4
    for (host = validhosts; host; host = host->next)
    {
	nHosts++;
	n += pad_to_int32(host->len) + sizeof(xHostEntry);
d1335 1
a1335 2
    if (n)
    {
d1337 2
a1338 12
	if (!ptr)
	{
	    return BadAlloc;
	}
        for (host = validhosts; host; host = host->next)
	{
	    len = host->len;
	    ((xHostEntry *)ptr)->family = host->family;
	    ((xHostEntry *)ptr)->length = len;
	    ptr += sizeof(xHostEntry);
	    acopy (host->addr, ptr, len);
	    ptr += pad_to_int32(len);
d1340 11
a1350 2
    } else {
	*data = NULL;
d1359 2
a1360 6
/*ARGSUSED*/
static int
CheckAddr (
    int			family,
    const void *	pAddr,
    unsigned		length)
d1362 1
a1362 1
    int	len;
d1364 1
a1364 2
    switch (family)
    {
d1366 5
a1370 5
      case FamilyInternet:
	if (length == sizeof (struct in_addr))
	    len = length;
	else
	    len = -1;
d1373 5
a1377 5
      case FamilyInternet6:
	if (length == sizeof (struct in6_addr))
	    len = length;
	else
	    len = -1;
d1380 5
a1384 5
#endif 
      case FamilyServerInterpreted:
	len = siCheckAddr(pAddr, length);
	break;
      default:
d1394 5
a1398 8
InvalidHost (
    register struct sockaddr	*saddr,
    int				len,
    ClientPtr			client)
{
    int 			family;
    pointer			addr;
    register HOST 		*selfhost, *host;
d1400 1
a1400 1
    if (!AccessEnabled)   /* just let them in */
d1402 1
a1402 1
    family = ConvertAddr (saddr, &len, (pointer *)&addr);
d1405 16
a1420 19
    if (family == FamilyLocal)
    {
	if (!LocalHostEnabled)
 	{
	    /*
	     * check to see if any local address is enabled.  This 
	     * implicitly enables local connections.
	     */
	    for (selfhost = selfhosts; selfhost; selfhost=selfhost->next)
 	    {
		for (host = validhosts; host; host=host->next)
		{
		    if (addrEqual (selfhost->family, selfhost->addr,
				   selfhost->len, host))
			return 0;
		}
	    }
	} else
	    return 0;
d1422 10
a1431 10
    for (host = validhosts; host; host = host->next)
    {
	if (host->family == FamilyServerInterpreted) {
	    if (siAddrMatch (family, addr, len, host, client)) {
		return 0;
	    }
	} else {
	    if (addrEqual (family, addr, len, host))
		return 0;
	}
d1438 1
a1438 4
ConvertAddr (
    register struct sockaddr	*saddr,
    int				*len,
    pointer			*addr)
d1442 1
a1442 2
    switch (saddr->sa_family)
    {
d1451 1
a1451 1
        if (16777343 == *(long*)&((struct sockaddr_in *) saddr)->sin_addr)
d1454 1
a1454 1
        *len = sizeof (struct in_addr);
d1458 1
a1458 1
    case AF_INET6: 
d1460 12
a1471 10
	struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *) saddr;
	if (IN6_IS_ADDR_V4MAPPED(&(saddr6->sin6_addr))) {
	    *len = sizeof (struct in_addr);
	    *addr = (pointer) &(saddr6->sin6_addr.s6_addr[12]);
	    return FamilyInternet;
	} else {
	    *len = sizeof (struct in6_addr);
	    *addr = (pointer) &(saddr6->sin6_addr);
	    return FamilyInternet6;
	}
d1481 1
a1481 3
ChangeAccessControl(
    ClientPtr client,
    int fEnabled)
d1484 1
d1486 1
a1486 1
	return rc;
d1516 5
a1520 4
typedef Bool (*siAddrMatchFunc)(int family, pointer addr, int len, 
  const char *siAddr, int siAddrlen, ClientPtr client, void *siTypePriv);
typedef int  (*siCheckAddrFunc)(const char *addrString, int length, 
  void *siTypePriv);
d1523 5
a1527 5
    struct siType *	next;
    const char *	typeName;
    siAddrMatchFunc	addrMatch;
    siCheckAddrFunc	checkAddr;
    void *		typePriv;	/* Private data for type routines */
d1534 1
a1534 1
  siCheckAddrFunc checkAddr, void *typePriv)
d1539 1
a1539 1
	return BadValue;
d1541 7
a1547 7
    for (s = siTypeList, p = NULL; s != NULL ; p = s, s = s->next) {
	if (strcmp(typeName, s->typeName) == 0) {
	    s->addrMatch = addrMatch;
	    s->checkAddr = checkAddr;
	    s->typePriv = typePriv;
	    return Success;
	}
d1552 1
a1552 1
	return BadAlloc;
d1555 1
a1555 1
	siTypeList = s;
d1557 1
a1557 1
	p->next = s;
d1568 2
a1569 2
static Bool 
siAddrMatch(int family, pointer addr, int len, HOST *host, ClientPtr client)
d1578 9
a1586 8
	for (s = siTypeList; s != NULL ; s = s->next) {
	    if (strcmp((char *) host->addr, s->typeName) == 0) {
		addrlen = host->len - (strlen((char *)host->addr) + 1);
		matches = s->addrMatch(family, addr, len, 
		  valueString + 1, addrlen, client, s->typePriv);
		break;
	    }
	}
d1588 3
a1590 4
	ErrorF(
	    "Xserver: siAddrMatch(): type = %s, value = %*.*s -- %s\n",
	      host->addr, addrlen, addrlen, valueString + 1,
	      (matches) ? "accepted" : "rejected");
d1608 15
a1622 15
	/* Make sure the first string is a recognized address type,
	 * and the second string is a valid address of that type. 
	 */
	typelen = strlen(addrString) + 1;
	addrlen = length - typelen;

	for (s = siTypeList; s != NULL ; s = s->next) {
	    if (strcmp(addrString, s->typeName) == 0) {
		len = s->checkAddr(valueString + 1, addrlen, s->typePriv);
		if (len >= 0) {
		    len += typelen;
		}
		break;
	    }
	}
d1624 2
a1625 2
	{
	    const char *resultMsg;
d1627 14
a1640 12
	    if (s == NULL) {
		resultMsg = "type not registered";
	    } else {
		if (len == -1) 
		    resultMsg = "rejected";
		else
		    resultMsg = "accepted";
	    }

	    ErrorF("Xserver: siCheckAddr(): type = %s, value = %*.*s, len = %d -- %s\n",
	      addrString, addrlen, addrlen, valueString + 1, len, resultMsg);
	}
a1645 1

d1660 4
a1663 1
# define SI_HOSTNAME_MAXLEN NI_MAXHOST
d1665 2
a1666 5
# ifdef MAXHOSTNAMELEN
#  define SI_HOSTNAME_MAXLEN MAXHOSTNAMELEN
# else
#  define SI_HOSTNAME_MAXLEN 256
# endif
d1669 1
a1669 1
static Bool 
d1671 2
a1672 1
  const char *siAddr, int siAddrLen, ClientPtr client, void *typePriv)
d1682 23
a1704 24
	char hostname[SI_HOSTNAME_MAXLEN];
	struct addrinfo *addresses;
	struct addrinfo *a;
	int f, hostaddrlen;
	pointer hostaddr;

	if (siAddrLen >= sizeof(hostname)) 
	    return FALSE;

	strncpy(hostname, siAddr, siAddrLen);
	hostname[siAddrLen] = '\0';

	if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
	    for (a = addresses ; a != NULL ; a = a->ai_next) {
		hostaddrlen = a->ai_addrlen;
		f = ConvertAddr(a->ai_addr,&hostaddrlen,&hostaddr);
		if ((f == family) && (len == hostaddrlen) &&
		  (acmp (addr, hostaddr, len) == 0) ) {
		    res = TRUE;
		    break;
		}
	    }
	    freeaddrinfo(addresses);
	}
d1706 1
a1706 1
#else /* IPv6 not supported, use gethostbyname instead for IPv4 */
d1708 2
a1709 1
	register struct hostent *hp;
d1711 1
a1711 1
	_Xgethostbynameparams hparams;
d1713 14
a1726 15
	char hostname[SI_HOSTNAME_MAXLEN];
	int f, hostaddrlen;
	pointer hostaddr;
	const char **addrlist;

	if (siAddrLen >= sizeof(hostname)) 
	    return FALSE;

	strncpy(hostname, siAddr, siAddrLen);
	hostname[siAddrLen] = '\0';

	if ((hp = _XGethostbyname(hostname, hparams)) != NULL) {
#ifdef h_addr				/* new 4.3bsd version of gethostent */
	    /* iterate over the addresses */
	    for (addrlist = hp->h_addr_list; *addrlist; addrlist++)
d1728 1
a1728 1
	    addrlist = &hp->h_addr;
d1730 2
a1731 2
	    {
		struct  sockaddr_in  sin;
d1733 11
a1743 11
    		sin.sin_family = hp->h_addrtype;
		acopy ( *addrlist, &(sin.sin_addr), hp->h_length);
		hostaddrlen = sizeof(sin);
    		f = ConvertAddr ((struct sockaddr *)&sin, 
		  &hostaddrlen, &hostaddr);
		if ((f == family) && (len == hostaddrlen) &&
		  (acmp (addr, hostaddr, len) == 0) ) {
		    res = TRUE;
		    break;
		}
    	    }
a1749 1

d1761 1
a1761 1
		    
d1763 36
a1798 30
	len = -1;
    } else {
	for (i = 0; i < length; i++) {
	    char c = valueString[i];

	    if (c == 0x2E) { /* '.' */
		if (dotAllowed == FALSE) {
		    len = -1;
		    break;
		} else {
		    dotAllowed = FALSE;
		    dashAllowed = FALSE;
		}
	    } else if (c == 0x2D) { /* '-' */
		if (dashAllowed == FALSE) {
		    len = -1;
		    break;
		} else {
		    dotAllowed = FALSE;
		}
	    } else if (((c >= 0x30) && (c <= 0x3A)) /* 0-9 */ ||
		       ((c >= 0x61) && (c <= 0x7A)) /* a-z */ ||
		       ((c >= 0x41) && (c <= 0x5A)) /* A-Z */) {
		dotAllowed = TRUE;
		dashAllowed = TRUE;
	    } else { /* Invalid character */
		len = -1;
		break;
	    }
	}
d1818 1
a1818 1
static Bool 
d1820 2
a1821 1
  const char *siAddr, int siAddrlen, ClientPtr client, void *typePriv)
d1827 1
a1827 1
	return FALSE;
d1833 2
a1834 2
	perror("inet_pton");
	return FALSE;
d1838 4
a1841 3
	return TRUE;
    } else {
	return FALSE;
d1852 22
a1873 19
	/* Address is too short! */
	len = -1;
    } else if (length >= SI_IPv6_MAXLEN) {
	/* Address is too long! */
	len = -1;
    } else {
	/* Assume inet_pton is sufficient validation */
	struct in6_addr addr6;
	char addrbuf[SI_IPv6_MAXLEN];

	memcpy(addrbuf, addrString, length);
	addrbuf[length] = '\0';

	if (inet_pton(AF_INET6, addrbuf, &addr6) != 1) {
	    perror("inet_pton");
	    len = -1;
	} else {
	    len = length;
	}
d1877 1
a1877 1
#endif /* IPv6 */
d1906 1
a1906 1
	return FALSE;
d1912 26
a1937 23
    if (addr[0] == '#') { /* numeric id */
	char *cp;
	errno = 0;
	*id = strtol(addrbuf + 1, &cp, 0);
	if ((errno == 0) && (cp != (addrbuf+1))) {
	    parsedOK = TRUE;
	}
    } else { /* non-numeric name */
	if (lcPriv->credType == LOCAL_USER) {
	    struct passwd *pw = getpwnam(addrbuf);

	    if (pw != NULL) {
		*id = (int) pw->pw_uid;
		parsedOK = TRUE;
	    }
	} else { /* group */
	    struct group *gr = getgrnam(addrbuf);

	    if (gr != NULL) {
		*id = (int) gr->gr_gid;
		parsedOK = TRUE;
	    }
	}
d1944 1
a1944 1
static Bool 
d1946 2
a1947 1
  const char *siAddr, int siAddrlen, ClientPtr client, void *typePriv)
d1954 1
a1954 1
	return FALSE;
d1957 1
a1957 1
#ifdef HAVE_GETZONEID /* Ensure process is in the same zone */
d1959 2
a1960 2
	FreeLocalClientCreds(lcc);
	return FALSE;
d1965 2
a1966 2
	FreeLocalClientCreds(lcc);
	return FALSE;
d1970 20
a1989 19
	if ((lcc->fieldsSet & LCC_UID_SET) && (lcc->euid == siAddrId)) {
	    FreeLocalClientCreds(lcc);
	    return TRUE;
	}
    } else {
	if ((lcc->fieldsSet & LCC_GID_SET) && (lcc->egid == siAddrId)) {
	    FreeLocalClientCreds(lcc);
	    return TRUE;
	}
	if (lcc->pSuppGids != NULL) {
	    int i;

	    for (i = 0 ; i < lcc->nSuppGids; i++) {
		if (lcc->pSuppGids[i] == siAddrId) {
		    FreeLocalClientCreds(lcc);
		    return TRUE;
		}
	    }
	}
d2001 3
a2003 3
    if (siLocalCredGetId(addrString, length, 
	(siLocalCredPrivPtr)typePriv, &id) == FALSE) {
	len = -1;
d2007 1
a2007 1
#endif /* localuser */
d2017 4
a2020 4
    siTypeAdd("localuser", siLocalCredAddrMatch, siLocalCredCheckAddr, 
      &siLocalUserPriv);
    siTypeAdd("localgroup", siLocalCredAddrMatch, siLocalCredCheckAddr, 
      &siLocalGroupPriv);
@


1.8
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d57 1
a57 1
 * Copyright  2004 Sun Microsystems, Inc.  All rights reserved.
d105 1
a105 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(__SCO__)
d107 1
a107 5
#endif /* TCPCONN || STREAMSCONN || ISC || __SCO__ */
#ifdef DNETCONN
#include <netdnet/dn.h>
#include <netdnet/dnetdb.h>
#endif
a167 15
#ifndef PATH_MAX
#include <sys/param.h>
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define PATH_MAX MAXPATHLEN
#else
#define PATH_MAX 1024
#endif
#endif
#endif 

#ifdef __SCO__
/* The system defined value is wrong. MAXPATHLEN is set in sco5.cf. */
#undef PATH_MAX
#endif
a176 8
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define PATH_MAX MAXPATHLEN
#else
#define PATH_MAX 1024
#endif
#endif

d277 1
a277 1
#if  defined(SVR4) && !defined(SCO325) && !defined(sun)  && defined(SIOCGIFCONF) && !defined(USE_SIOCGLIFCONF)
d307 1
a307 1
#else /* Case sun, SCO325 and others  */
d309 1
a309 1
#endif /* ((SVR4 && !sun !SCO325) || ISC) && SIOCGIFCONF */
d322 1
a322 1
#if !defined(TCPCONN) && !defined(STREAMSCONN) && !defined(UNIXCONN) && !defined(MNX_TCPCONN)
d456 1
a456 1
#endif /* !TCPCONN && !STREAMSCONN && !UNIXCONN && !MNX_TCPCONN */
a520 29
#ifdef DNETCONN
    struct dn_naddr *dnaddr = getnodeadd();
    /*
     * AF_DECnet may not be listed in the interface list.  Instead use
     * the supported library call to find out the local address (if any).
     */
    if (dnaddr)
    {    
	addr = (unsigned char *) dnaddr;
	len = dnaddr->a_len + sizeof(dnaddr->a_len);
	family = FamilyDECnet;
	for (host = selfhosts;
	     host && !addrEqual (family, addr, len, host);
	     host = host->next)
	    ;
        if (!host)
	{
	    MakeHost(host,len)
	    if (host)
	    {
		host->family = family;
		host->len = len;
		acopy(addr, host->addr, len);
		host->next = selfhosts;
		selfhosts = host;
	    }
	}
    }
#endif /* DNETCONN */
a570 7
#ifdef DNETCONN
	/*
	 * DECnet was handled up above.
	 */
	if (family == AF_DECnet)
	    continue;
#endif /* DNETCONN */
a699 4
#ifdef DNETCONN
	if (ifr->ifa_addr.sa_family == AF_DECnet) 
	    continue;
#endif /* DNETCONN */
d855 2
a856 2
#if ((defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)) && \
     (!defined(IPv6) || !defined(AF_INET6))) || defined(DNETCONN)
d859 1
a859 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)
a861 3
#ifdef DNETCONN
	struct sockaddr_dn dn;
#endif
a863 4
#ifdef DNETCONN
    struct nodeent 	*np;
    struct dn_naddr 	dnaddr, *dnaddrp, *dnet_addr();
#endif
d909 1
a909 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)
a922 7
#ifdef DNETCONN
	else if (!strncmp("dnet:", lhostname, 5))
	{
	    family = FamilyDECnet;
	    hostname = ohostname + 5;
	}
#endif
a945 26
#ifdef DNETCONN
    	if ((family == FamilyDECnet) || ((family == FamilyWild) &&
	    (ptr = strchr(hostname, ':')) && (*(ptr + 1) == ':') &&
	    !(*ptr = '\0')))	/* bash trailing colons if necessary */
	{
    	    /* node name (DECnet names end in "::") */
	    dnaddrp = dnet_addr(hostname);
    	    if (!dnaddrp && (np = getnodebyname (hostname)))
	    {
		/* node was specified by name */
		saddr.sa.sa_family = np->n_addrtype;
		len = sizeof(saddr.sa);
		if (ConvertAddr (&saddr.sa, &len, (pointer *)&addr) == FamilyDECnet)
		{
		    memset((char *) &dnaddr, 0, sizeof (dnaddr));
		    dnaddr.a_len = np->n_length;
		    acopy (np->n_addr, dnaddr.a_addr, np->n_length);
		    dnaddrp = &dnaddr;
		}
    	    }
	    if (dnaddrp)
		(void) NewHost(FamilyDECnet, (pointer)dnaddrp,
			(int)(dnaddrp->a_len + sizeof(dnaddrp->a_len)), FALSE);
    	}
	else
#endif /* DNETCONN */
d954 1
a954 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)
d1012 2
a1013 1
Bool LocalClient(ClientPtr client)
d1019 1
d1021 1
a1021 3
    if (!client->osPrivate)
        return FALSE;
    if (!((OsCommPtr)client->osPrivate)->trans_conn)
d1024 1
a1024 2
    if (!_XSERVTransGetPeerAddr (((OsCommPtr)client->osPrivate)->trans_conn,
	&notused, &alen, &from))
d1050 7
d1427 1
a1427 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)
a1442 15
#ifdef DNETCONN
      case FamilyDECnet:
        {
	    struct dn_naddr *dnaddr = (struct dn_naddr *) pAddr;

	    if ((length < sizeof(dnaddr->a_len)) ||
		(length < dnaddr->a_len + sizeof(dnaddr->a_len)))
		len = -1;
	    else
		len = dnaddr->a_len + sizeof(dnaddr->a_len);
	    if (len > sizeof(struct dn_naddr))
		len = -1;
	}
        break;
#endif
d1492 1
a1492 1
	if ((host->family == FamilyServerInterpreted)) {
d1520 1
a1520 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)
a1543 16
#endif
#ifdef DNETCONN
    case AF_DECnet:
	{
	    struct sockaddr_dn *sdn = (struct sockaddr_dn *) saddr;
	    *len = sdn->sdn_nodeaddrl + sizeof(sdn->sdn_nodeaddrl);
	    *addr = (pointer) &(sdn->sdn_add);
	}
        return FamilyDECnet;
#endif
#ifdef CHAOSCONN
    case AF_CHAOS:
	{
	    not implemented
	}
	return FamilyChaos;
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1148 2
a1149 1
	    if (addrEqual (family, addr, alen, host))
d1151 1
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d218 1
a218 1
		     pointer /*pAddr*/,
d222 1
a222 1
		    pointer /*addr*/,
d241 1
a241 1
#define MakeHost(h,l)	(h)=xalloc(sizeof *(h)+(l));\
d246 1
a246 1
#define FreeHost(h)	xfree(h)
d314 1
a314 1
    bzero((char *) &ioc, sizeof(ioc));
d332 1
a332 1
    return(ret);
d590 1
a590 1
	bufptr = xalloc(len);
d1041 1
a1041 1
		    bzero ((char *) &dnaddr, sizeof (dnaddr));
d1126 5
d1138 1
a1138 1
	    xfree (from);
d1143 1
a1143 1
	    xfree (from);
d1151 1
a1151 1
	xfree (from);
d1221 1
a1221 1
    *lccp = Xcalloc(sizeof(LocalClientCredRec));
d1257 1
a1257 1
	lcc->pSuppGids = Xcalloc((lcc->nSuppGids) * sizeof(int));
d1294 1
a1294 1
	    Xfree(lcc->pSuppGids);
d1296 1
a1296 1
	Xfree(lcc);
d1323 1
a1323 1
	 pointer        pAddr)
d1351 1
a1351 1
	    return (BadValue);
d1357 1
a1357 1
	return (BadValue);
d1384 1
a1384 1
	 pointer	addr,
d1449 1
a1449 1
            return(BadValue);
d1455 1
a1455 1
        return(BadValue);
d1466 1
a1466 1
    return (Success);
d1491 1
a1491 1
        *data = ptr = xalloc (n);
d1494 1
a1494 1
	    return(BadAlloc);
d1510 1
a1510 1
    return(Success);
d1519 1
a1519 1
    pointer		pAddr,
d1563 1
a1563 1
    return (len);
d1580 1
a1580 1
        return(0);    
d1608 1
a1608 1
		return (0);
d1612 1
a1612 1
		return (0);
d1616 1
a1616 1
    return (1);
d1626 1
a1626 1
        return (FamilyLocal);
d1750 1
a1750 1
    s = xalloc(sizeof(struct siType));
d2092 1
a2092 1
    char *addrbuf = xalloc(len + 1);
d2126 1
a2126 1
    xfree(addrbuf);
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a3 1
Copyright 2004 Sun Microsystems, Inc.
d56 23
d241 1
a241 1
#define MakeHost(h,l)	(h)=(HOST *) xalloc(sizeof *(h)+(l));\
d440 1
a440 2
		      ((addr[0] == 127 && addr[1] == 0 &&
			addr[2] == 0 && addr[3] == 1) ||
d768 2
a769 1
	family = ConvertAddr(ifr->ifa_addr, &len, (pointer *)&addr);
a792 1
	    struct sockaddr broad_addr;
d836 4
a839 2
		(ifr->ifa_flags & IFF_UP))
		broad_addr = *ifr->ifa_broadaddr;
a841 2
	    XdmcpRegisterBroadcastAddress((struct sockaddr_in *)
					  &broad_addr);
d1119 1
a1119 1
_X_EXPORT Bool LocalClient(ClientPtr client)
d1133 1
a1133 1
	    xfree ((char *) from);
d1138 1
a1138 1
	    xfree ((char *) from);
d1146 1
a1146 1
	xfree ((char *) from);
d1482 1
a1482 1
	n += (((host->len + 3) >> 2) << 2) + sizeof(xHostEntry);
d1486 1
a1486 1
        *data = ptr = (pointer) xalloc (n);
d1498 1
a1498 1
	    ptr += ((len + 3) >> 2) << 2;
d1745 1
a1745 1
    s = (struct siType *) xalloc(sizeof(struct siType));
@


1.4
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a78 1
#ifndef Lynx
a79 3
#else
#include <socket.h>
#endif
d83 1
a83 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(ISC) || defined(__SCO__)
a97 20
#if defined(DGUX)
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <ctype.h>
#include <sys/utsname.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/param.h>
#include <sys/sockio.h>
#endif


#if defined(hpux) || defined(QNX4)
# include <sys/utsname.h>
# ifdef HAS_IFREQ
#  include <net/if.h>
# endif
#else
a102 4
# ifdef ISC
#  include <sys/stropts.h>
#  include <sys/sioctl.h>
# endif /* ISC */
a109 1
#endif /* hpux */
a150 1
#ifndef Lynx
a151 3
#else
#include <param.h>
#endif 
d282 1
a282 1
#if ((defined(SVR4) && !defined(DGUX) && !defined(SCO325) && !defined(sun) && !defined(NCR)) || defined(ISC)) && !defined(__sgi) && defined(SIOCGIFCONF) && !defined(USE_SIOCGLIFCONF)
a298 11
#ifdef ISC
	/* SIOCGIFCONF is somewhat brain damaged on ISC. The argument
	 * buffer must contain the ifconf structure as header. Ifc_req
	 * is also not a pointer but a one element array of ifreq
	 * structures. On return this array is extended by enough
	 * ifreq fields to hold all interfaces. The return buffer length
	 * is placed in the buffer header.
	 */
        ((struct ifconf *) ioc.ic_dp)->ifc_len =
                                         ioc.ic_len - sizeof(struct ifconf);
#endif
a309 8
#ifdef ISC
    {
	((struct ifconf *) arg)->ifc_len =
				 ((struct ifconf *)ioc.ic_dp)->ifc_len;
	((struct ifconf *) arg)->ifc_buf = 
			(caddr_t)((struct ifconf *)ioc.ic_dp)->ifc_req;
    }
#endif
d312 1
a312 1
#else /* Case DGUX, sun, SCO325 NCR and others  */
d314 1
a314 1
#endif /* ((SVR4 && !DGUX !sun !SCO325 !NCR) || ISC) && SIOCGIFCONF */
d323 1
a323 147
#ifdef WINTCP /* NCR Wollongong based TCP */

#include <sys/un.h>
#include <stropts.h>
#include <tiuser.h>

#include <sys/stream.h>
#include <net/if.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in.h>
#include <netinet/in_var.h>

void
DefineSelf (int fd)
{
    /*
     * The Wolongong drivers used by NCR SVR4/MP-RAS don't understand the
     * socket IO calls that most other drivers seem to like. Because of
     * this, this routine must be special cased for NCR. Eventually,
     * this will be cleared up.
     */

    struct ipb ifnet;
    struct in_ifaddr ifaddr;
    struct strioctl str;
    unsigned char *addr;
    register HOST *host;
    int	family, len;

    if ((fd = open ("/dev/ip", O_RDWR, 0 )) < 0)
        Error ("Getting interface configuration (1)");

    /* Indicate that we want to start at the begining */
    ifnet.ib_next = (struct ipb *) 1;

    while (ifnet.ib_next)
    {
	str.ic_cmd = IPIOC_GETIPB;
	str.ic_timout = 0;
	str.ic_len = sizeof (struct ipb);
	str.ic_dp = (char *) &ifnet;

	if (ioctl (fd, (int) I_STR, (char *) &str) < 0)
	{
	    close (fd);
	    Error ("Getting interface configuration (2)");
	}

	ifaddr.ia_next = (struct in_ifaddr *) ifnet.if_addrlist;
	str.ic_cmd = IPIOC_GETINADDR;
	str.ic_timout = 0;
	str.ic_len = sizeof (struct in_ifaddr);
	str.ic_dp = (char *) &ifaddr;

	if (ioctl (fd, (int) I_STR, (char *) &str) < 0)
	{
	    close (fd);
	    Error ("Getting interface configuration (3)");
	}

	len = sizeof(struct sockaddr_in);
	family = ConvertAddr (IA_SIN(&ifaddr), &len, (pointer *)&addr);
        if (family == -1 || family == FamilyLocal)
	    continue;
        for (host = selfhosts;
 	     host && !addrEqual (family, addr, len, host);
	     host = host->next)
	    ;
        if (host)
	    continue;
	MakeHost(host,len)
	if (host)
	{
	    host->family = family;
	    host->len = len;
	    acopy(addr, host->addr, len);
	    host->next = selfhosts;
	    selfhosts = host;
	}
#ifdef XDMCP
        {
	    struct sockaddr broad_addr;

	    /*
	     * If this isn't an Internet Address, don't register it.
	     */
	    if (family != FamilyInternet)
		continue;

	    /*
 	     * Ignore 'localhost' entries as they're not useful
	     * on the other end of the wire.
	     */
	    if (len == 4 &&
		addr[0] == 127 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 1)
		continue;

	    /*
	     * Ignore '0.0.0.0' entries as they are
	     * returned by some OSes for unconfigured NICs but they are
	     * not useful on the other end of the wire.
	     */
	    if (len == 4 &&
		addr[0] == 0 && addr[1] == 0 &&
		addr[2] == 0 && addr[3] == 0)
		continue;

	    XdmcpRegisterConnection (family, (char *)addr, len);


#define IA_BROADADDR(ia) ((struct sockaddr_in *)(&((struct in_ifaddr *)ia)->ia_broadaddr))

	    XdmcpRegisterBroadcastAddress (
		(struct sockaddr_in *) IA_BROADADDR(&ifaddr));

#undef IA_BROADADDR
	}
#endif /* XDMCP */
    }

    close(fd);

    /*
     * add something of FamilyLocalHost
     */
    for (host = selfhosts;
	 host && !addrEqual(FamilyLocalHost, "", 0, host);
	 host = host->next);
    if (!host)
    {
	MakeHost(host, 0);
	if (host)
	{
	    host->family = FamilyLocalHost;
	    host->len = 0;
	    acopy("", host->addr, 0);
	    host->next = selfhosts;
	    selfhosts = host;
	}
    }
}

#else /* WINTCP */

#if !defined(SIOCGIFCONF) || (defined (hpux) && ! defined (HAS_IFREQ)) || defined(QNX4)
a365 1
#ifndef QNX4
a370 7
#else
    /* QNX4's uname returns node number in name.nodename, not the hostname
       have to overwrite it */
    char hname[1024];
    gethostname(hname, 1024);
    name.nodename = hname;
#endif
a478 4
#ifdef QNX4
#define ifr_size(p) (p->ifr_addr.sa_len + IFNAMSIZ)
#define ifraddr_size(a) (a.sa_len)
#else
a481 1
#endif
d483 1
a483 1
#if defined(DEF_SELF_DEBUG) || (defined(IPv6) && defined(AF_INET6))
d505 3
a507 3
    char		buf[2048], *cp, *cplim;
    void *		bufptr = buf;   
#ifdef USE_SIOCGLIFCONF
d510 1
a510 1
#ifdef SIOCGLIFNUM
d512 3
a514 2
#endif
#else
d517 3
a519 2
#endif 
#else 
a588 3
#ifdef ISC
#define IFC_IFC_REQ (struct ifreq *) ifc.ifc_buf
#else
a589 1
#endif /* ISC */
a618 13
#ifdef DEF_SELF_DEBUG
	if (family == FamilyInternet) 
	    ErrorF("Xserver: DefineSelf(): ifname = %s, addr = %d.%d.%d.%d\n",
		   IFR_IFR_NAME, addr[0], addr[1], addr[2], addr[3]);
#if defined(IPv6) && defined(AF_INET6)
	else if (family == FamilyInternet6) {
	    char cp[INET6_ADDRSTRLEN] = "";
	    inet_ntop(AF_INET6, addr, cp, sizeof(cp));
	    ErrorF("Xserver: DefineSelf(): ifname = %s, addr = %s\n",
		   IFR_IFR_NAME,  cp);
	}
#endif
#endif /* DEF_SELF_DEBUG */
a727 5
#ifdef DEF_SELF_DEBUG
	    ErrorF("Xserver: DefineSelf(): ifname = %s, baddr = %s\n",
		   IFR_IFR_NAME,
	           inet_ntoa(((struct sockaddr_in *) &broad_addr)->sin_addr));
#endif /* DEF_SELF_DEBUG */
a754 14
#ifdef DEF_SELF_DEBUG
	if (family == FamilyInternet) 
	    ErrorF("Xserver: DefineSelf(): ifname = %s, addr = %d.%d.%d.%d\n",
		   ifr->ifa_name, addr[0], addr[1], addr[2], addr[3]);
#if defined(IPv6) && defined(AF_INET6)
	else if (family == FamilyInternet6) {
		char cp[INET6_ADDRSTRLEN];

		inet_ntop(AF_INET6, addr, cp, sizeof(cp));
		ErrorF("Xserver: DefineSelf(): ifname = %s addr = %s\n",
		    ifr->ifa_name, cp);
	}
#endif
#endif /* DEF_SELF_DEBUG */
a818 5
#ifdef DEF_SELF_DEBUG
	    ErrorF("Xserver: DefineSelf(): ifname = %s, baddr = %s\n",
		   ifr->ifa_name,
	           inet_ntoa(((struct sockaddr_in *) &broad_addr)->sin_addr));
#endif /* DEF_SELF_DEBUG */
a847 1
#endif /* WINTCP */
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d122 1
a122 1
#if defined(SVR4) ||  (defined(SYSV) && defined(i386)) || defined(__GNU__)
d125 1
a125 1
#if defined(SYSV) &&  defined(i386)
a236 4
static int LocalClientCredAndGroups(ClientPtr client, int *pUid, int *pGid, 
				    int **pSuppGids, int *nSuppGids);


a1382 1
 * or the uid/gid for nobody those ids cannot be determined
d1389 17
a1405 1
    return LocalClientCredAndGroups(client, pUid, pGid, NULL, NULL);
d1410 1
a1410 1
 * or the uid/gid for nobody those ids cannot be determined
a1411 4
 * If the caller passes non-NULL values for pSuppGids & nSuppGids,
 * they are responsible for calling XFree(*pSuppGids) to release the
 * memory allocated for the supplemental group ids list.
 *
d1413 1
d1415 2
a1416 3
static int
LocalClientCredAndGroups(ClientPtr client, int *pUid, int *pGid, 
			 int **pSuppGids, int *nSuppGids)
d1421 1
d1427 1
d1446 5
a1450 5
    if (pSuppGids != NULL)
	*pSuppGids = NULL;
    if (nSuppGids != NULL)
	*nSuppGids = 0;

d1453 7
a1459 6
    if (getpeereid(fd, &uid, &gid) == -1) 
	    return -1;
    if (pUid != NULL)
	    *pUid = uid;
    if (pGid != NULL)
	    *pGid = gid;
d1462 2
a1463 1
    if (getpeerucred(fd, &peercred) < 0)
a1464 4
#ifdef sun /* Ensure process is in the same zone */
    if (getzoneid() != ucred_getzoneid(peercred)) {
	ucred_free(peercred);
	return -1;
d1466 23
a1488 17
#endif
    if (pUid != NULL)
	*pUid = ucred_geteuid(peercred);
    if (pGid != NULL)
	*pGid = ucred_getegid(peercred);
    if (pSuppGids != NULL && nSuppGids != NULL) {
	const gid_t *gids;
	*nSuppGids = ucred_getgroups(peercred, &gids);
	if (*nSuppGids > 0) {
	    *pSuppGids = xalloc(sizeof(int) * (*nSuppGids));
	    if (*pSuppGids == NULL) {
		*nSuppGids = 0;
	    } else {
		int i;
		for (i = 0 ; i < *nSuppGids; i++) {
		    (*pSuppGids)[i] = (int) gids[i];
		}
d1491 2
d1497 8
a1504 6
    if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &peercred, &so_len) == -1) 
	    return -1;
    if (pUid != NULL)
	    *pUid = peercred.uid;
    if (pGid != NULL)
	    *pGid = peercred.gid;
d1514 12
a1525 1
static Bool
d1528 2
d1531 1
a1531 1
	return TRUE;
d1534 3
a1536 2
    if (!XaceHook(XACE_HOSTLIST_ACCESS, client, DixWriteAccess))
	return FALSE;
d1538 1
a1538 1
    return LocalClient(client);
d1550 1
a1550 1
    int			len;
d1552 3
a1554 2
    if (!AuthorizedClient(client))
	return(BadAccess);
d1648 1
a1648 1
    int			len;
d1651 3
a1653 2
    if (!AuthorizedClient(client))
	return(BadAccess);
d1910 3
a1912 2
    if (!AuthorizedClient(client))
	return BadAccess;
d2359 2
a2360 1
    int connUid, connGid, *connSuppGids, connNumSuppGids, siAddrId;
d2363 1
a2363 2
    if (LocalClientCredAndGroups(client, &connUid, &connGid,
      &connSuppGids, &connNumSuppGids) == -1) {
d2367 7
d2375 1
d2380 2
a2381 1
	if (connUid == siAddrId) {
d2385 2
a2386 1
	if (connGid == siAddrId) {
d2389 1
a2389 1
	if (connSuppGids != NULL) {
d2392 3
a2394 3
	    for (i = 0 ; i < connNumSuppGids; i++) {
		if (connSuppGids[i] == siAddrId) {
		    xfree(connSuppGids);
a2397 1
	    xfree(connSuppGids);
d2400 1
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a204 1
#ifdef XACE
a205 1
#endif
d237 2
a238 2
int LocalClientCredAndGroups(ClientPtr client, int *pUid, int *pGid, 
                             int **pSuppGids, int *nSuppGids);
a1171 4
#ifdef K5AUTH
    krb5_principal      princ;
    krb5_data		kbuf;
#endif
a1196 3
#ifdef __UNIXOS2__
    strlcpy(fname, (char*)__XOS2RedirRoot(fname), sizeof(fname));
#endif /* __UNIXOS2__ */
a1206 4
#ifdef __UNIXOS2__
    	if ((ptr = strchr(ohostname, '\r')) != 0)
    	    *ptr = 0;
#endif
a1244 7
#ifdef K5AUTH
	else if (!strncmp("krb:", lhostname, 4))
	{
	    family = FamilyKrb5Principal;
	    hostname = ohostname + 4;
	}
#endif
a1286 10
#ifdef K5AUTH
	if (family == FamilyKrb5Principal)
	{
            krb5_parse_name(hostname, &princ);
	    XauKrb5Encode(princ, &kbuf);
	    (void) NewHost(FamilyKrb5Principal, kbuf.data, kbuf.length, FALSE);
	    krb5_free_principal(princ);
        }
	else
#endif
d1407 1
a1407 1
int
d1502 1
a1502 1
#ifdef XACE
d1504 1
a1504 1
    if (!XaceHook(XACE_HOSTLIST_ACCESS, client, SecurityWriteAccess))
d1506 1
a1506 1
#endif
a1527 5
#ifdef K5AUTH
    case FamilyKrb5Principal:
        len = length;
        break;
#endif
a1625 5
#ifdef K5AUTH
    case FamilyKrb5Principal:
        len = length;
	break;
#endif
d1822 1
a1822 1
#if defined(UNIXCONN) || defined(LOCALCONN) || defined(OS2PIPECONN)
@


1.1
log
@Initial revision
@
text
@d1201 2
a1202 1
    sprintf(fname, ETC_HOST_PREFIX "%s" ETC_HOST_SUFFIX, display);
d1204 1
a1204 1
    strcpy(fname, (char*)__XOS2RedirRoot(fname));
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d205 1
d207 1
d239 2
a240 2
static int LocalClientCredAndGroups(ClientPtr client, int *pUid, int *pGid, 
				    int **pSuppGids, int *nSuppGids);
d1174 4
d1202 3
d1215 4
d1257 7
d1306 10
d1436 1
a1436 1
static int
d1531 1
a1531 1

d1533 1
a1533 1
    if (!XaceHook(XACE_HOSTLIST_ACCESS, client, DixWriteAccess))
d1535 1
a1535 1

d1557 5
d1660 5
d1861 1
a1861 1
#if defined(UNIXCONN) || defined(LOCALCONN)
@

