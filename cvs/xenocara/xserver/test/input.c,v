head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.02.16.08.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/**
 * Copyright © 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <X11/X.h>
#include "misc.h"
#include "resource.h"
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/Xatom.h>
#include "windowstr.h"
#include "inputstr.h"
#include "eventconvert.h"
#include "exevents.h"
#include "exglobals.h"
#include "dixgrabs.h"
#include "eventstr.h"
#include "inpututils.h"
#include "mi.h"
#include "assert.h"

/**
 * Init a device with axes.
 * Verify values set on the device.
 *
 * Result: All axes set to default values (usually 0).
 */
static void
dix_init_valuators(void)
{
    DeviceIntRec dev;
    ValuatorClassPtr val;
    AxisInfoPtr axis;
    const int num_axes = 2;
    int i;
    Atom atoms[MAX_VALUATORS] = { 0 };

    memset(&dev, 0, sizeof(DeviceIntRec));
    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */

    assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));

    val = dev.valuator;
    assert(val);
    assert(val->numAxes == num_axes);
    assert(val->numMotionEvents == 0);
    assert(val->axisVal);

    for (i = 0; i < num_axes; i++) {
        assert(val->axisVal[i] == 0);
        assert(val->axes->min_value == NO_AXIS_LIMITS);
        assert(val->axes->max_value == NO_AXIS_LIMITS);
        assert(val->axes->mode == Absolute);
    }

    assert(dev.last.numValuators == num_axes);

    /* invalid increment */
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_VERTICAL, 0.0, SCROLL_FLAG_NONE) == FALSE);
    /* invalid type */
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_VERTICAL - 1, 1.0, SCROLL_FLAG_NONE) == FALSE);
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_HORIZONTAL + 1, 1.0,
            SCROLL_FLAG_NONE) == FALSE);
    /* invalid axisnum */
    assert(SetScrollValuator
           (&dev, 2, SCROLL_TYPE_HORIZONTAL, 1.0, SCROLL_FLAG_NONE) == FALSE);

    /* valid */
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_VERTICAL, 3.0, SCROLL_FLAG_NONE) == TRUE);
    axis = &dev.valuator->axes[0];
    assert(axis->scroll.increment == 3.0);
    assert(axis->scroll.type == SCROLL_TYPE_VERTICAL);
    assert(axis->scroll.flags == 0);

    /* valid */
    assert(SetScrollValuator
           (&dev, 1, SCROLL_TYPE_HORIZONTAL, 2.0, SCROLL_FLAG_NONE) == TRUE);
    axis = &dev.valuator->axes[1];
    assert(axis->scroll.increment == 2.0);
    assert(axis->scroll.type == SCROLL_TYPE_HORIZONTAL);
    assert(axis->scroll.flags == 0);

    /* can add another non-preffered axis */
    assert(SetScrollValuator
           (&dev, 1, SCROLL_TYPE_VERTICAL, 5.0, SCROLL_FLAG_NONE) == TRUE);
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_HORIZONTAL, 5.0, SCROLL_FLAG_NONE) == TRUE);

    /* can overwrite with Preferred */
    assert(SetScrollValuator
           (&dev, 1, SCROLL_TYPE_VERTICAL, 5.5, SCROLL_FLAG_PREFERRED) == TRUE);
    axis = &dev.valuator->axes[1];
    assert(axis->scroll.increment == 5.5);
    assert(axis->scroll.type == SCROLL_TYPE_VERTICAL);
    assert(axis->scroll.flags == SCROLL_FLAG_PREFERRED);

    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_HORIZONTAL, 8.8,
            SCROLL_FLAG_PREFERRED) == TRUE);
    axis = &dev.valuator->axes[0];
    assert(axis->scroll.increment == 8.8);
    assert(axis->scroll.type == SCROLL_TYPE_HORIZONTAL);
    assert(axis->scroll.flags == SCROLL_FLAG_PREFERRED);

    /* can overwrite as none */
    assert(SetScrollValuator(&dev, 0, SCROLL_TYPE_NONE, 5.0,
                             SCROLL_FLAG_NONE) == TRUE);
    axis = &dev.valuator->axes[0];
    assert(axis->scroll.type == SCROLL_TYPE_NONE);

    /* can overwrite axis with new settings */
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_VERTICAL, 5.0, SCROLL_FLAG_NONE) == TRUE);
    axis = &dev.valuator->axes[0];
    assert(axis->scroll.type == SCROLL_TYPE_VERTICAL);
    assert(axis->scroll.increment == 5.0);
    assert(axis->scroll.flags == SCROLL_FLAG_NONE);
    assert(SetScrollValuator
           (&dev, 0, SCROLL_TYPE_VERTICAL, 3.0, SCROLL_FLAG_NONE) == TRUE);
    assert(axis->scroll.type == SCROLL_TYPE_VERTICAL);
    assert(axis->scroll.increment == 3.0);
    assert(axis->scroll.flags == SCROLL_FLAG_NONE);
}

/* just check the known success cases, and that error cases set the client's
 * error value correctly. */
static void
dix_check_grab_values(void)
{
    ClientRec client;
    GrabParameters param;
    int rc;

    memset(&client, 0, sizeof(client));

    param.grabtype = CORE;
    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = GrabModeSync;
    param.modifiers = AnyModifier;
    param.ownerEvents = FALSE;

    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = GrabModeAsync;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = XIGrabModeTouch;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.this_device_mode = XIGrabModeTouch + 1;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.this_device_mode);
    assert(client.errorValue == XIGrabModeTouch + 1);

    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = GrabModeAsync;
    rc = CheckGrabValues(&client, &param);

    param.this_device_mode = GrabModeSync;
    param.other_devices_mode = XIGrabModeTouch;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);
    assert(rc == Success);

    param.other_devices_mode = XIGrabModeTouch + 1;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.other_devices_mode);
    assert(client.errorValue == XIGrabModeTouch + 1);

    param.other_devices_mode = GrabModeSync;

    param.modifiers = 1 << 13;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.modifiers);
    assert(client.errorValue == (1 << 13));

    param.modifiers = AnyModifier;
    param.ownerEvents = TRUE;
    rc = CheckGrabValues(&client, &param);
    assert(rc == Success);

    param.ownerEvents = 3;
    rc = CheckGrabValues(&client, &param);
    assert(rc == BadValue);
    assert(client.errorValue == param.ownerEvents);
    assert(client.errorValue == 3);
}

/**
 * Convert various internal events to the matching core event and verify the
 * parameters.
 */
static void
dix_event_to_core(int type)
{
    DeviceEvent ev;
    xEvent *core;
    int time;
    int x, y;
    int rc;
    int state;
    int detail;
    int count;
    const int ROOT_WINDOW_ID = 0x100;

    /* EventToCore memsets the event to 0 */
#define test_event() \
    assert(rc == Success); \
    assert(core); \
    assert(count == 1); \
    assert(core->u.u.type == type); \
    assert(core->u.u.detail == detail); \
    assert(core->u.keyButtonPointer.time == time); \
    assert(core->u.keyButtonPointer.rootX == x); \
    assert(core->u.keyButtonPointer.rootY == y); \
    assert(core->u.keyButtonPointer.state == state); \
    assert(core->u.keyButtonPointer.eventX == 0); \
    assert(core->u.keyButtonPointer.eventY == 0); \
    assert(core->u.keyButtonPointer.root == ROOT_WINDOW_ID); \
    assert(core->u.keyButtonPointer.event == 0); \
    assert(core->u.keyButtonPointer.child == 0); \
    assert(core->u.keyButtonPointer.sameScreen == FALSE);

    x = 0;
    y = 0;
    time = 12345;
    state = 0;
    detail = 0;

    ev.header = 0xFF;
    ev.length = sizeof(DeviceEvent);
    ev.time = time;
    ev.root_y = x;
    ev.root_x = y;
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    ev.root = ROOT_WINDOW_ID;
    ev.corestate = state;
    ev.detail.key = detail;

    ev.type = type;
    ev.detail.key = 0;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    x = 1;
    y = 2;
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    x = 0x7FFF;
    y = 0x7FFF;
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    x = 0x8000;                 /* too high */
    y = 0x8000;                 /* too high */
    ev.root_x = x;
    ev.root_y = y;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    assert(rc == Success);
    assert(core);
    assert(count == 1);
    assert(core->u.keyButtonPointer.rootX != x);
    assert(core->u.keyButtonPointer.rootY != y);

    x = 0x7FFF;
    y = 0x7FFF;
    ev.root_x = x;
    ev.root_y = y;
    time = 0;
    ev.time = time;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    detail = 1;
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    detail = 0xFF;              /* highest value */
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    detail = 0xFFF;             /* too big */
    ev.detail.key = detail;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    assert(rc == BadMatch);

    detail = 0xFF;              /* too big */
    ev.detail.key = detail;
    state = 0xFFFF;             /* highest value */
    ev.corestate = state;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    test_event();

    state = 0x10000;            /* too big */
    ev.corestate = state;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    assert(rc == Success);
    assert(core);
    assert(count == 1);
    assert(core->u.keyButtonPointer.state != state);
    assert(core->u.keyButtonPointer.state == (state & 0xFFFF));

#undef test_event
}

static void
dix_event_to_core_fail(int evtype, int expected_rc)
{
    DeviceEvent ev;
    xEvent *core;
    int rc;
    int count;

    ev.header = 0xFF;
    ev.length = sizeof(DeviceEvent);

    ev.type = evtype;
    rc = EventToCore((InternalEvent *) &ev, &core, &count);
    assert(rc == expected_rc);
}

static void
dix_event_to_core_conversion(void)
{
    dix_event_to_core_fail(0, BadImplementation);
    dix_event_to_core_fail(1, BadImplementation);
    dix_event_to_core_fail(ET_ProximityOut + 1, BadImplementation);
    dix_event_to_core_fail(ET_ProximityIn, BadMatch);
    dix_event_to_core_fail(ET_ProximityOut, BadMatch);

    dix_event_to_core(ET_KeyPress);
    dix_event_to_core(ET_KeyRelease);
    dix_event_to_core(ET_ButtonPress);
    dix_event_to_core(ET_ButtonRelease);
    dix_event_to_core(ET_Motion);
}

static void
_dix_test_xi_convert(DeviceEvent *ev, int expected_rc, int expected_count)
{
    xEvent *xi;
    int count = 0;
    int rc;

    rc = EventToXI((InternalEvent *) ev, &xi, &count);
    assert(rc == expected_rc);
    assert(count >= expected_count);
    if (count > 0) {
        deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer *) xi;

        assert(kbp->type == IEventBase + ev->type);
        assert(kbp->detail == ev->detail.key);
        assert(kbp->time == ev->time);
        assert((kbp->deviceid & ~MORE_EVENTS) == ev->deviceid);
        assert(kbp->root_x == ev->root_x);
        assert(kbp->root_y == ev->root_y);
        assert(kbp->state == ev->corestate);
        assert(kbp->event_x == 0);
        assert(kbp->event_y == 0);
        assert(kbp->root == ev->root);
        assert(kbp->event == 0);
        assert(kbp->child == 0);
        assert(kbp->same_screen == FALSE);

        while (--count > 0) {
            deviceValuator *v = (deviceValuator *) &xi[count];

            assert(v->type == DeviceValuator);
            assert(v->num_valuators <= 6);
        }

        free(xi);
    }
}

/**
 * This tests for internal event → XI1 event conversion
 * - all conversions should generate the right XI event type
 * - right number of events generated
 * - extra events are valuators
 */
static void
dix_event_to_xi1_conversion(void)
{
    DeviceEvent ev = { 0 };
    int time;
    int x, y;
    int state;
    int detail;
    const int ROOT_WINDOW_ID = 0x100;
    int deviceid;

    IEventBase = 80;
    DeviceValuator = IEventBase - 1;
    DeviceKeyPress = IEventBase + ET_KeyPress;
    DeviceKeyRelease = IEventBase + ET_KeyRelease;
    DeviceButtonPress = IEventBase + ET_ButtonPress;
    DeviceButtonRelease = IEventBase + ET_ButtonRelease;
    DeviceMotionNotify = IEventBase + ET_Motion;
    DeviceFocusIn = IEventBase + ET_FocusIn;
    DeviceFocusOut = IEventBase + ET_FocusOut;
    ProximityIn = IEventBase + ET_ProximityIn;
    ProximityOut = IEventBase + ET_ProximityOut;

    /* EventToXI callocs */
    x = 0;
    y = 0;
    time = 12345;
    state = 0;
    detail = 0;
    deviceid = 4;

    ev.header = 0xFF;

    ev.header = 0xFF;
    ev.length = sizeof(DeviceEvent);
    ev.time = time;
    ev.root_y = x;
    ev.root_x = y;
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    ev.root = ROOT_WINDOW_ID;
    ev.corestate = state;
    ev.detail.key = detail;
    ev.deviceid = deviceid;

    /* test all types for bad match */
    ev.type = ET_KeyPress;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityIn;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityOut;
    _dix_test_xi_convert(&ev, Success, 1);

    /* No axes */
    ClearBit(ev.valuators.mask, 0);
    ClearBit(ev.valuators.mask, 1);
    ev.type = ET_KeyPress;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;
    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;
    _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityIn;
    _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityOut;
    _dix_test_xi_convert(&ev, BadMatch, 0);

    /* more than 6 axes → 2 valuator events */
    SetBit(ev.valuators.mask, 0);
    SetBit(ev.valuators.mask, 1);
    SetBit(ev.valuators.mask, 2);
    SetBit(ev.valuators.mask, 3);
    SetBit(ev.valuators.mask, 4);
    SetBit(ev.valuators.mask, 5);
    SetBit(ev.valuators.mask, 6);
    ev.type = ET_KeyPress;
    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_KeyRelease;
    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonPress;
    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonRelease;
    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_Motion;
    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityIn;
    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityOut;
    _dix_test_xi_convert(&ev, Success, 2);

    /* keycode too high */
    ev.type = ET_KeyPress;
    ev.detail.key = 256;
    _dix_test_xi_convert(&ev, Success, 0);

    /* deviceid too high */
    ev.type = ET_KeyPress;
    ev.detail.key = 18;
    ev.deviceid = 128;
    _dix_test_xi_convert(&ev, Success, 0);
}

static void
xi2_struct_sizes(void)
{
#define compare(req) \
    assert(sizeof(req) == sz_##req);

    compare(xXIQueryVersionReq);
    compare(xXIWarpPointerReq);
    compare(xXIChangeCursorReq);
    compare(xXIChangeHierarchyReq);
    compare(xXISetClientPointerReq);
    compare(xXIGetClientPointerReq);
    compare(xXISelectEventsReq);
    compare(xXIQueryVersionReq);
    compare(xXIQueryDeviceReq);
    compare(xXISetFocusReq);
    compare(xXIGetFocusReq);
    compare(xXIGrabDeviceReq);
    compare(xXIUngrabDeviceReq);
    compare(xXIAllowEventsReq);
    compare(xXIPassiveGrabDeviceReq);
    compare(xXIPassiveUngrabDeviceReq);
    compare(xXIListPropertiesReq);
    compare(xXIChangePropertyReq);
    compare(xXIDeletePropertyReq);
    compare(xXIGetPropertyReq);
    compare(xXIGetSelectedEventsReq);
#undef compare
}

static void
dix_grab_matching(void)
{
    DeviceIntRec xi_all_devices, xi_all_master_devices, dev1, dev2;
    GrabRec a, b;
    BOOL rc;

    memset(&a, 0, sizeof(a));
    memset(&b, 0, sizeof(b));

    /* different grabtypes must fail */
    a.grabtype = CORE;
    b.grabtype = XI2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = XI2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XI2 grabs for different devices must fail, regardless of ignoreDevice
     * XI2 grabs for master devices must fail against a slave */
    memset(&xi_all_devices, 0, sizeof(DeviceIntRec));
    memset(&xi_all_master_devices, 0, sizeof(DeviceIntRec));
    memset(&dev1, 0, sizeof(DeviceIntRec));
    memset(&dev2, 0, sizeof(DeviceIntRec));

    xi_all_devices.id = XIAllDevices;
    xi_all_master_devices.id = XIAllMasterDevices;
    dev1.id = 10;
    dev1.type = SLAVE;
    dev2.id = 11;
    dev2.type = SLAVE;

    inputInfo.all_devices = &xi_all_devices;
    inputInfo.all_master_devices = &xi_all_master_devices;
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.device = &dev1;
    b.device = &dev2;

    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.device = &dev2;
    b.device = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.device = inputInfo.all_master_devices;
    b.device = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.device = &dev1;
    b.device = inputInfo.all_master_devices;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    /* ignoreDevice FALSE must fail for different devices for CORE and XI */
    a.grabtype = XI;
    b.grabtype = XI;
    a.device = &dev1;
    b.device = &dev2;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    a.device = &dev1;
    b.device = &dev2;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    /* ignoreDevice FALSE must fail for different modifier devices for CORE
     * and XI */
    a.grabtype = XI;
    b.grabtype = XI;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);

    /* different event type must fail */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = XI;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyRelease;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&a, &b, TRUE);
    assert(rc == FALSE);

    /* different modifiers must fail */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.device = &dev1;
    b.device = &dev1;
    a.modifierDevice = &dev1;
    b.modifierDevice = &dev1;
    a.type = XI_KeyPress;
    b.type = XI_KeyPress;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 2;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* AnyModifier must fail for XI2 */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XIAnyModifier must fail for CORE and XI */
    a.grabtype = XI;
    b.grabtype = XI;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* different detail must fail */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.detail.exact = 1;
    b.detail.exact = 2;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* detail of AnyModifier must fail */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.detail.exact = AnyModifier;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* detail of XIAnyModifier must fail */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.detail.exact = XIAnyModifier;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    a.grabtype = XI;
    b.grabtype = XI;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == FALSE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == FALSE);

    /* XIAnyModifier or AnyModifer must succeed */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = XIAnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = XI;
    b.grabtype = XI;
    a.detail.exact = 1;
    b.detail.exact = 1;
    a.modifiersDetail.exact = AnyModifier;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    /* AnyKey or XIAnyKeycode must succeed */
    a.grabtype = XI2;
    b.grabtype = XI2;
    a.detail.exact = XIAnyKeycode;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = CORE;
    b.grabtype = CORE;
    a.detail.exact = AnyKey;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);

    a.grabtype = XI;
    b.grabtype = XI;
    a.detail.exact = AnyKey;
    b.detail.exact = 1;
    a.modifiersDetail.exact = 1;
    b.modifiersDetail.exact = 1;
    rc = GrabMatchesSecond(&a, &b, FALSE);
    assert(rc == TRUE);
    rc = GrabMatchesSecond(&b, &a, FALSE);
    assert(rc == TRUE);
}

static void
test_bits_to_byte(int i)
{
    int expected_bytes;

    expected_bytes = (i + 7) / 8;

    assert(bits_to_bytes(i) >= i / 8);
    assert((bits_to_bytes(i) * 8) - i <= 7);
    assert(expected_bytes == bits_to_bytes(i));
}

static void
test_bytes_to_int32(int i)
{
    int expected_4byte;

    expected_4byte = (i + 3) / 4;

    assert(bytes_to_int32(i) <= i);
    assert((bytes_to_int32(i) * 4) - i <= 3);
    assert(expected_4byte == bytes_to_int32(i));
}

static void
test_pad_to_int32(int i)
{
    int expected_bytes;

    expected_bytes = ((i + 3) / 4) * 4;

    assert(pad_to_int32(i) >= i);
    assert(pad_to_int32(i) - i <= 3);
    assert(expected_bytes == pad_to_int32(i));
}

static void
test_padding_for_int32(int i)
{
    static const int padlength[4] = { 0, 3, 2, 1 };
    int expected_bytes = (((i + 3) / 4) * 4) - i;

    assert(padding_for_int32(i) >= 0);
    assert(padding_for_int32(i) <= 3);
    assert(padding_for_int32(i) == expected_bytes);
    assert(padding_for_int32(i) == padlength[i & 3]);
    assert((padding_for_int32(i) + i) == pad_to_int32(i));
}

static void
include_byte_padding_macros(void)
{
    printf("Testing bits_to_bytes()\n");

    /* the macros don't provide overflow protection */
    test_bits_to_byte(0);
    test_bits_to_byte(1);
    test_bits_to_byte(2);
    test_bits_to_byte(7);
    test_bits_to_byte(8);
    test_bits_to_byte(0xFF);
    test_bits_to_byte(0x100);
    test_bits_to_byte(INT_MAX - 9);
    test_bits_to_byte(INT_MAX - 8);

    printf("Testing bytes_to_int32()\n");

    test_bytes_to_int32(0);
    test_bytes_to_int32(1);
    test_bytes_to_int32(2);
    test_bytes_to_int32(7);
    test_bytes_to_int32(8);
    test_bytes_to_int32(0xFF);
    test_bytes_to_int32(0x100);
    test_bytes_to_int32(0xFFFF);
    test_bytes_to_int32(0x10000);
    test_bytes_to_int32(0xFFFFFF);
    test_bytes_to_int32(0x1000000);
    test_bytes_to_int32(INT_MAX - 4);
    test_bytes_to_int32(INT_MAX - 3);

    printf("Testing pad_to_int32()\n");

    test_pad_to_int32(0);
    test_pad_to_int32(1);
    test_pad_to_int32(2);
    test_pad_to_int32(3);
    test_pad_to_int32(7);
    test_pad_to_int32(8);
    test_pad_to_int32(0xFF);
    test_pad_to_int32(0x100);
    test_pad_to_int32(0xFFFF);
    test_pad_to_int32(0x10000);
    test_pad_to_int32(0xFFFFFF);
    test_pad_to_int32(0x1000000);
    test_pad_to_int32(INT_MAX - 4);
    test_pad_to_int32(INT_MAX - 3);

    printf("Testing padding_for_int32()\n");

    test_padding_for_int32(0);
    test_padding_for_int32(1);
    test_padding_for_int32(2);
    test_padding_for_int32(3);
    test_padding_for_int32(7);
    test_padding_for_int32(8);
    test_padding_for_int32(0xFF);
    test_padding_for_int32(0x100);
    test_padding_for_int32(0xFFFF);
    test_padding_for_int32(0x10000);
    test_padding_for_int32(0xFFFFFF);
    test_padding_for_int32(0x1000000);
    test_padding_for_int32(INT_MAX - 4);
    test_padding_for_int32(INT_MAX - 3);
}

static void
xi_unregister_handlers(void)
{
    DeviceIntRec dev;
    int handler;

    memset(&dev, 0, sizeof(dev));

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 1);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 2);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 3);

    printf("Unlinking from front.\n");

    XIUnregisterPropertyHandler(&dev, 4);       /* NOOP */
    assert(dev.properties.handlers->id == 3);
    XIUnregisterPropertyHandler(&dev, 3);
    assert(dev.properties.handlers->id == 2);
    XIUnregisterPropertyHandler(&dev, 2);
    assert(dev.properties.handlers->id == 1);
    XIUnregisterPropertyHandler(&dev, 1);
    assert(dev.properties.handlers == NULL);

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 4);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 5);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 6);
    XIUnregisterPropertyHandler(&dev, 3);       /* NOOP */
    assert(dev.properties.handlers->next->next->next == NULL);
    XIUnregisterPropertyHandler(&dev, 4);
    assert(dev.properties.handlers->next->next == NULL);
    XIUnregisterPropertyHandler(&dev, 5);
    assert(dev.properties.handlers->next == NULL);
    XIUnregisterPropertyHandler(&dev, 6);
    assert(dev.properties.handlers == NULL);

    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 7);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 8);
    handler = XIRegisterPropertyHandler(&dev, NULL, NULL, NULL);
    assert(handler == 9);

    XIDeleteAllDeviceProperties(&dev);
    assert(dev.properties.handlers == NULL);
    XIUnregisterPropertyHandler(&dev, 7);       /* NOOP */

}

static void
cmp_attr_fields(InputAttributes * attr1, InputAttributes * attr2)
{
    char **tags1, **tags2;

    assert(attr1 && attr2);
    assert(attr1 != attr2);
    assert(attr1->flags == attr2->flags);

    if (attr1->product != NULL) {
        assert(attr1->product != attr2->product);
        assert(strcmp(attr1->product, attr2->product) == 0);
    }
    else
        assert(attr2->product == NULL);

    if (attr1->vendor != NULL) {
        assert(attr1->vendor != attr2->vendor);
        assert(strcmp(attr1->vendor, attr2->vendor) == 0);
    }
    else
        assert(attr2->vendor == NULL);

    if (attr1->device != NULL) {
        assert(attr1->device != attr2->device);
        assert(strcmp(attr1->device, attr2->device) == 0);
    }
    else
        assert(attr2->device == NULL);

    if (attr1->pnp_id != NULL) {
        assert(attr1->pnp_id != attr2->pnp_id);
        assert(strcmp(attr1->pnp_id, attr2->pnp_id) == 0);
    }
    else
        assert(attr2->pnp_id == NULL);

    if (attr1->usb_id != NULL) {
        assert(attr1->usb_id != attr2->usb_id);
        assert(strcmp(attr1->usb_id, attr2->usb_id) == 0);
    }
    else
        assert(attr2->usb_id == NULL);

    tags1 = attr1->tags;
    tags2 = attr2->tags;

    /* if we don't have any tags, skip the tag checking bits */
    if (!tags1) {
        assert(!tags2);
        return;
    }

    /* Don't lug around empty arrays */
    assert(*tags1);
    assert(*tags2);

    /* check for identical content, but duplicated */
    while (*tags1) {
        assert(*tags1 != *tags2);
        assert(strcmp(*tags1, *tags2) == 0);
        tags1++;
        tags2++;
    }

    /* ensure tags1 and tags2 have the same no of elements */
    assert(!*tags2);

    /* check for not sharing memory */
    tags1 = attr1->tags;
    while (*tags1) {
        tags2 = attr2->tags;
        while (*tags2)
            assert(*tags1 != *tags2++);

        tags1++;
    }
}

static void
dix_input_attributes(void)
{
    InputAttributes *orig;
    InputAttributes *new;

    new = DuplicateInputAttributes(NULL);
    assert(!new);

    orig = calloc(1, sizeof(InputAttributes));
    assert(orig);

    new = DuplicateInputAttributes(orig);
    assert(memcmp(orig, new, sizeof(InputAttributes)) == 0);

    orig->product = xnfstrdup("product name");
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    orig->vendor = xnfstrdup("vendor name");
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    orig->device = xnfstrdup("device path");
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    orig->pnp_id = xnfstrdup("PnPID");
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    orig->usb_id = xnfstrdup("USBID");
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    orig->flags = 0xF0;
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    orig->tags = xstrtokenize("tag1 tag2 tag3", " ");
    new = DuplicateInputAttributes(orig);
    cmp_attr_fields(orig, new);
    FreeInputAttributes(new);

    FreeInputAttributes(orig);
}

static void
dix_input_valuator_masks(void)
{
    ValuatorMask *mask = NULL, *copy;
    int nvaluators = MAX_VALUATORS;
    double valuators[nvaluators];
    int val_ranged[nvaluators];
    int i;
    int first_val, num_vals;

    for (i = 0; i < nvaluators; i++) {
        valuators[i] = i + 0.5;
        val_ranged[i] = i;
    }

    mask = valuator_mask_new(nvaluators);
    assert(mask != NULL);
    assert(valuator_mask_size(mask) == 0);
    assert(valuator_mask_num_valuators(mask) == 0);

    for (i = 0; i < nvaluators; i++) {
        assert(!valuator_mask_isset(mask, i));
        valuator_mask_set_double(mask, i, valuators[i]);
        assert(valuator_mask_isset(mask, i));
        assert(valuator_mask_get(mask, i) == trunc(valuators[i]));
        assert(valuator_mask_get_double(mask, i) == valuators[i]);
        assert(valuator_mask_size(mask) == i + 1);
        assert(valuator_mask_num_valuators(mask) == i + 1);
    }

    for (i = 0; i < nvaluators; i++) {
        assert(valuator_mask_isset(mask, i));
        valuator_mask_unset(mask, i);
        /* we're removing valuators from the front, so size should stay the
         * same until the last bit is removed */
        if (i < nvaluators - 1)
            assert(valuator_mask_size(mask) == nvaluators);
        assert(!valuator_mask_isset(mask, i));
    }

    assert(valuator_mask_size(mask) == 0);
    valuator_mask_zero(mask);
    assert(valuator_mask_size(mask) == 0);
    assert(valuator_mask_num_valuators(mask) == 0);
    for (i = 0; i < nvaluators; i++)
        assert(!valuator_mask_isset(mask, i));

    first_val = 5;
    num_vals = 6;

    valuator_mask_set_range(mask, first_val, num_vals, val_ranged);
    assert(valuator_mask_size(mask) == first_val + num_vals);
    assert(valuator_mask_num_valuators(mask) == num_vals);
    for (i = 0; i < nvaluators; i++) {
        double val;

        if (i < first_val || i >= first_val + num_vals) {
            assert(!valuator_mask_isset(mask, i));
            assert(!valuator_mask_fetch_double(mask, i, &val));
        }
        else {
            assert(valuator_mask_isset(mask, i));
            assert(valuator_mask_get(mask, i) == val_ranged[i - first_val]);
            assert(valuator_mask_get_double(mask, i) ==
                   val_ranged[i - first_val]);
            assert(valuator_mask_fetch_double(mask, i, &val));
            assert(val_ranged[i - first_val] == val);
        }
    }

    copy = valuator_mask_new(nvaluators);
    valuator_mask_copy(copy, mask);
    assert(mask != copy);
    assert(valuator_mask_size(mask) == valuator_mask_size(copy));
    assert(valuator_mask_num_valuators(mask) ==
           valuator_mask_num_valuators(copy));

    for (i = 0; i < nvaluators; i++) {
        double a, b;

        assert(valuator_mask_isset(mask, i) == valuator_mask_isset(copy, i));

        if (!valuator_mask_isset(mask, i))
            continue;

        assert(valuator_mask_get(mask, i) == valuator_mask_get(copy, i));
        assert(valuator_mask_get_double(mask, i) ==
               valuator_mask_get_double(copy, i));
        assert(valuator_mask_fetch_double(mask, i, &a));
        assert(valuator_mask_fetch_double(copy, i, &b));
        assert(a == b);
    }

    valuator_mask_free(&mask);
    assert(mask == NULL);
}

static void
dix_valuator_mode(void)
{
    DeviceIntRec dev;
    const int num_axes = MAX_VALUATORS;
    int i;
    Atom atoms[MAX_VALUATORS] = { 0 };

    memset(&dev, 0, sizeof(DeviceIntRec));
    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */

    assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));

    for (i = 0; i < num_axes; i++) {
        assert(valuator_get_mode(&dev, i) == Absolute);
        valuator_set_mode(&dev, i, Relative);
        assert(dev.valuator->axes[i].mode == Relative);
        assert(valuator_get_mode(&dev, i) == Relative);
    }

    valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Absolute);
    for (i = 0; i < num_axes; i++)
        assert(valuator_get_mode(&dev, i) == Absolute);

    valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Relative);
    for (i = 0; i < num_axes; i++)
        assert(valuator_get_mode(&dev, i) == Relative);
}

static void
dix_input_valuator_masks_unaccel(void)
{
    ValuatorMask *mask = NULL;
    double x, ux;

    /* set mask normally */
    mask = valuator_mask_new(MAX_VALUATORS);
    assert(!valuator_mask_has_unaccelerated(mask));
    valuator_mask_set_double(mask, 0, 1.0);
    assert(!valuator_mask_has_unaccelerated(mask));
    valuator_mask_unset(mask, 0);
    assert(!valuator_mask_has_unaccelerated(mask));

    /* all unset, now set accel mask */
    valuator_mask_set_unaccelerated(mask, 0, 1.0, 2.0);
    assert(valuator_mask_has_unaccelerated(mask));
    assert(valuator_mask_isset(mask, 0));
    assert(!valuator_mask_isset(mask, 1));
    assert(valuator_mask_get_accelerated(mask, 0) ==  1.0);
    assert(valuator_mask_get_unaccelerated(mask, 0) ==  2.0);
    assert(valuator_mask_fetch_unaccelerated(mask, 0, &x, &ux));
    assert(x == 1.0);
    assert(ux == 2.0);
    x = 0xff;
    ux = 0xfe;
    assert(!valuator_mask_fetch_unaccelerated(mask, 1, &x, &ux));
    assert(x == 0xff);
    assert(ux == 0xfe);

    /* all unset, now set normally again */
    valuator_mask_unset(mask, 0);
    assert(!valuator_mask_has_unaccelerated(mask));
    assert(!valuator_mask_isset(mask, 0));
    valuator_mask_set_double(mask, 0, 1.0);
    assert(!valuator_mask_has_unaccelerated(mask));
    valuator_mask_unset(mask, 0);
    assert(!valuator_mask_has_unaccelerated(mask));

    valuator_mask_zero(mask);
    assert(!valuator_mask_has_unaccelerated(mask));

    valuator_mask_set_unaccelerated(mask, 0, 1.0, 2.0);
    valuator_mask_set_unaccelerated(mask, 1, 3.0, 4.5);
    assert(valuator_mask_isset(mask, 0));
    assert(valuator_mask_isset(mask, 1));
    assert(!valuator_mask_isset(mask, 2));
    assert(valuator_mask_has_unaccelerated(mask));
    assert(valuator_mask_get_accelerated(mask, 0) == 1.0);
    assert(valuator_mask_get_accelerated(mask, 1) == 3.0);
    assert(valuator_mask_get_unaccelerated(mask, 0) == 2.0);
    assert(valuator_mask_get_unaccelerated(mask, 1) == 4.5);
    assert(valuator_mask_fetch_unaccelerated(mask, 0, &x, &ux));
    assert(x == 1.0);
    assert(ux == 2.0);
    assert(valuator_mask_fetch_unaccelerated(mask, 1, &x, &ux));
    assert(x == 3.0);
    assert(ux == 4.5);

    valuator_mask_free(&mask);
}

static void
include_bit_test_macros(void)
{
    uint8_t mask[9] = { 0 };
    int i;

    for (i = 0; i < sizeof(mask) / sizeof(mask[0]); i++) {
        assert(BitIsOn(mask, i) == 0);
        SetBit(mask, i);
        assert(BitIsOn(mask, i) == 1);
        assert(! !(mask[i / 8] & (1 << (i % 8))));
        assert(CountBits(mask, sizeof(mask)) == 1);
        ClearBit(mask, i);
        assert(BitIsOn(mask, i) == 0);
    }
}

/**
 * Ensure that val->axisVal and val->axes are aligned on doubles.
 */
static void
dix_valuator_alloc(void)
{
    ValuatorClassPtr v = NULL;
    int num_axes = 0;

    while (num_axes < 5) {
        v = AllocValuatorClass(v, num_axes);

        assert(v);
        assert(v->numAxes == num_axes);
#if !defined(__i386__) && !defined(__m68k__) && !defined(__sh__)
        /* must be double-aligned on 64 bit */
        assert(offsetof(struct _ValuatorClassRec, axisVal) % sizeof(double) == 0);
        assert(offsetof(struct _ValuatorClassRec, axes) % sizeof(double) == 0);
#endif
        num_axes++;
    }

    free(v);
}

static void
dix_get_master(void)
{
    DeviceIntRec vcp, vck;
    DeviceIntRec ptr, kbd;
    DeviceIntRec floating;
    SpriteInfoRec vcp_sprite, vck_sprite;
    SpriteInfoRec ptr_sprite, kbd_sprite;
    SpriteInfoRec floating_sprite;

    memset(&vcp, 0, sizeof(vcp));
    memset(&vck, 0, sizeof(vck));
    memset(&ptr, 0, sizeof(ptr));
    memset(&kbd, 0, sizeof(kbd));
    memset(&floating, 0, sizeof(floating));

    memset(&vcp_sprite, 0, sizeof(vcp_sprite));
    memset(&vck_sprite, 0, sizeof(vck_sprite));
    memset(&ptr_sprite, 0, sizeof(ptr_sprite));
    memset(&kbd_sprite, 0, sizeof(kbd_sprite));
    memset(&floating_sprite, 0, sizeof(floating_sprite));

    vcp.type = MASTER_POINTER;
    vck.type = MASTER_KEYBOARD;
    ptr.type = SLAVE;
    kbd.type = SLAVE;
    floating.type = SLAVE;

    vcp.spriteInfo = &vcp_sprite;
    vck.spriteInfo = &vck_sprite;
    ptr.spriteInfo = &ptr_sprite;
    kbd.spriteInfo = &kbd_sprite;
    floating.spriteInfo = &floating_sprite;

    vcp_sprite.paired = &vck;
    vck_sprite.paired = &vcp;
    ptr_sprite.paired = &vcp;
    kbd_sprite.paired = &vck;
    floating_sprite.paired = &floating;

    vcp_sprite.spriteOwner = TRUE;
    floating_sprite.spriteOwner = TRUE;

    ptr.master = &vcp;
    kbd.master = &vck;

    assert(GetPairedDevice(&vcp) == &vck);
    assert(GetPairedDevice(&vck) == &vcp);
    assert(GetMaster(&ptr, MASTER_POINTER) == &vcp);
    assert(GetMaster(&ptr, MASTER_KEYBOARD) == &vck);
    assert(GetMaster(&kbd, MASTER_POINTER) == &vcp);
    assert(GetMaster(&kbd, MASTER_KEYBOARD) == &vck);
    assert(GetMaster(&ptr, MASTER_ATTACHED) == &vcp);
    assert(GetMaster(&kbd, MASTER_ATTACHED) == &vck);

    assert(GetPairedDevice(&floating) == &floating);
    assert(GetMaster(&floating, MASTER_POINTER) == NULL);
    assert(GetMaster(&floating, MASTER_KEYBOARD) == NULL);
    assert(GetMaster(&floating, MASTER_ATTACHED) == NULL);

    assert(GetMaster(&vcp, POINTER_OR_FLOAT) == &vcp);
    assert(GetMaster(&vck, POINTER_OR_FLOAT) == &vcp);
    assert(GetMaster(&ptr, POINTER_OR_FLOAT) == &vcp);
    assert(GetMaster(&kbd, POINTER_OR_FLOAT) == &vcp);

    assert(GetMaster(&vcp, KEYBOARD_OR_FLOAT) == &vck);
    assert(GetMaster(&vck, KEYBOARD_OR_FLOAT) == &vck);
    assert(GetMaster(&ptr, KEYBOARD_OR_FLOAT) == &vck);
    assert(GetMaster(&kbd, KEYBOARD_OR_FLOAT) == &vck);

    assert(GetMaster(&floating, KEYBOARD_OR_FLOAT) == &floating);
    assert(GetMaster(&floating, POINTER_OR_FLOAT) == &floating);
}

static void
input_option_test(void)
{
    InputOption *list = NULL;
    InputOption *opt;
    const char *val;

    printf("Testing input_option list interface\n");

    list = input_option_new(list, "key", "value");
    assert(list);
    opt = input_option_find(list, "key");
    val = input_option_get_value(opt);
    assert(strcmp(val, "value") == 0);

    list = input_option_new(list, "2", "v2");
    opt = input_option_find(list, "key");
    val = input_option_get_value(opt);
    assert(strcmp(val, "value") == 0);

    opt = input_option_find(list, "2");
    val = input_option_get_value(opt);
    assert(strcmp(val, "v2") == 0);

    list = input_option_new(list, "3", "v3");

    /* search, delete */
    opt = input_option_find(list, "key");
    val = input_option_get_value(opt);
    assert(strcmp(val, "value") == 0);
    list = input_option_free_element(list, "key");
    opt = input_option_find(list, "key");
    assert(opt == NULL);

    opt = input_option_find(list, "2");
    val = input_option_get_value(opt);
    assert(strcmp(val, "v2") == 0);
    list = input_option_free_element(list, "2");
    opt = input_option_find(list, "2");
    assert(opt == NULL);

    opt = input_option_find(list, "3");
    val = input_option_get_value(opt);
    assert(strcmp(val, "v3") == 0);
    list = input_option_free_element(list, "3");
    opt = input_option_find(list, "3");
    assert(opt == NULL);

    /* list deletion */
    list = input_option_new(list, "1", "v3");
    list = input_option_new(list, "2", "v3");
    list = input_option_new(list, "3", "v3");
    input_option_free_list(&list);

    assert(list == NULL);

    list = input_option_new(list, "1", "v1");
    list = input_option_new(list, "2", "v2");
    list = input_option_new(list, "3", "v3");

    /* value replacement */
    opt = input_option_find(list, "2");
    val = input_option_get_value(opt);
    assert(strcmp(val, "v2") == 0);
    input_option_set_value(opt, "foo");
    val = input_option_get_value(opt);
    assert(strcmp(val, "foo") == 0);
    opt = input_option_find(list, "2");
    val = input_option_get_value(opt);
    assert(strcmp(val, "foo") == 0);

    /* key replacement */
    input_option_set_key(opt, "bar");
    val = input_option_get_key(opt);
    assert(strcmp(val, "bar") == 0);
    opt = input_option_find(list, "bar");
    val = input_option_get_value(opt);
    assert(strcmp(val, "foo") == 0);

    /* value replacement in input_option_new */
    list = input_option_new(list, "bar", "foobar");
    opt = input_option_find(list, "bar");
    val = input_option_get_value(opt);
    assert(strcmp(val, "foobar") == 0);

    input_option_free_list(&list);
    assert(list == NULL);
}

static void
_test_double_fp16_values(double orig_d)
{
    FP1616 first_fp16, final_fp16;
    double final_d;

    if (orig_d > 0x7FFF) {
        printf("Test out of range\n");
        assert(0);
    }

    first_fp16 = double_to_fp1616(orig_d);
    final_d = fp1616_to_double(first_fp16);
    final_fp16 = double_to_fp1616(final_d);

    /* {
     *    char first_fp16_s[64];
     *    char final_fp16_s[64];
     *    snprintf(first_fp16_s, sizeof(first_fp16_s), "%d + %u * 2^-16", (first_fp16 & 0xffff0000) >> 16, first_fp16 & 0xffff);
     *    snprintf(final_fp16_s, sizeof(final_fp16_s), "%d + %u * 2^-16", (final_fp16 & 0xffff0000) >> 16, final_fp16 & 0xffff);
     *
     *    printf("FP16: original double: %f first fp16: %s, re-encoded double: %f, final fp16: %s\n", orig_d, first_fp16_s, final_d, final_fp16_s);
     * }
     */

    /* since we lose precision, we only do rough range testing */
    assert(final_d > orig_d - 0.1);
    assert(final_d < orig_d + 0.1);

    assert(memcmp(&first_fp16, &final_fp16, sizeof(FP1616)) == 0);

    if (orig_d > 0)
        _test_double_fp16_values(-orig_d);
}

static void
_test_double_fp32_values(double orig_d)
{
    FP3232 first_fp32, final_fp32;
    double final_d;

    if (orig_d > 0x7FFFFFFF) {
        printf("Test out of range\n");
        assert(0);
    }

    first_fp32 = double_to_fp3232(orig_d);
    final_d = fp3232_to_double(first_fp32);
    final_fp32 = double_to_fp3232(final_d);

    /* {
     *     char first_fp32_s[64];
     *     char final_fp32_s[64];
     *     snprintf(first_fp32_s, sizeof(first_fp32_s), "%d + %u * 2^-32", first_fp32.integral, first_fp32.frac);
     *     snprintf(final_fp32_s, sizeof(final_fp32_s), "%d + %u * 2^-32", first_fp32.integral, final_fp32.frac);
     *
     *     printf("FP32: original double: %f first fp32: %s, re-encoded double: %f, final fp32: %s\n", orig_d, first_fp32_s, final_d, final_fp32_s);
     * }
     */

    /* since we lose precision, we only do rough range testing */
    assert(final_d > orig_d - 0.1);
    assert(final_d < orig_d + 0.1);

    assert(memcmp(&first_fp32, &final_fp32, sizeof(FP3232)) == 0);

    if (orig_d > 0)
        _test_double_fp32_values(-orig_d);
}

static void
dix_double_fp_conversion(void)
{
    uint32_t i;

    printf("Testing double to FP1616/FP3232 conversions\n");

    _test_double_fp16_values(0);
    for (i = 1; i < 0x7FFF; i <<= 1) {
        double val;

        val = i;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        /* and some pseudo-random floating points */
        val = i - 0.00382;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.00382;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.05234;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.12342;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.27583;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.50535;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.72342;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);

        val = i + 0.80408;
        _test_double_fp16_values(val);
        _test_double_fp32_values(val);
    }

    for (i = 0x7FFFF; i < 0x7FFFFFFF; i <<= 1) {
        _test_double_fp32_values(i);
        /* and a few more random floating points, obtained
         * by faceplanting into the numpad repeatedly */
        _test_double_fp32_values(i + 0.010177);
        _test_double_fp32_values(i + 0.213841);
        _test_double_fp32_values(i + 0.348720);
        _test_double_fp32_values(i + 0.472020);
        _test_double_fp32_values(i + 0.572020);
        _test_double_fp32_values(i + 0.892929);
    }
}

/* The mieq test verifies that events added to the queue come out in the same
 * order that they went in.
 */
static uint32_t mieq_test_event_last_processed;

static void
mieq_test_event_handler(int screenNum, InternalEvent *ie, DeviceIntPtr dev)
{
    RawDeviceEvent *e = (RawDeviceEvent *) ie;

    assert(e->type == ET_RawMotion);
    assert(e->flags > mieq_test_event_last_processed);
    mieq_test_event_last_processed = e->flags;
}

static void
_mieq_test_generate_events(uint32_t start, uint32_t count)
{
    static DeviceIntRec dev;
    static SpriteInfoRec spriteInfo;
    static SpriteRec sprite;

    memset(&dev, 0, sizeof(dev));
    memset(&spriteInfo, 0, sizeof(spriteInfo));
    memset(&sprite, 0, sizeof(sprite));
    dev.spriteInfo = &spriteInfo;
    spriteInfo.sprite = &sprite;

    dev.enabled = 1;

    count += start;
    while (start < count) {
        RawDeviceEvent e = { 0 };
        e.header = ET_Internal;
        e.type = ET_RawMotion;
        e.length = sizeof(e);
        e.time = GetTimeInMillis();
        e.flags = start;

        mieqEnqueue(&dev, (InternalEvent *) &e);

        start++;
    }
}

#define mieq_test_generate_events(c) { _mieq_test_generate_events(next, c); next += c; }

static void
mieq_test(void)
{
    uint32_t next = 1;

    mieq_test_event_last_processed = 0;
    mieqInit();
    mieqSetHandler(ET_RawMotion, mieq_test_event_handler);

    /* Enough to fit the buffer but trigger a grow */
    mieq_test_generate_events(180);

    /* We should resize to 512 now */
    mieqProcessInputEvents();

    /* Some should now get dropped */
    mieq_test_generate_events(500);

    /* Tell us how many got dropped, 1024 now */
    mieqProcessInputEvents();

    /* Now make it 2048 */
    mieq_test_generate_events(900);
    mieqProcessInputEvents();

    /* Now make it 4096 (max) */
    mieq_test_generate_events(1950);
    mieqProcessInputEvents();

    /* Now overflow one last time with the maximal queue and reach the verbosity limit */
    mieq_test_generate_events(10000);
    mieqProcessInputEvents();

    mieqFini();
}

/* Simple check that we're replaying events in-order */
static void
process_input_proc(InternalEvent *ev, DeviceIntPtr device)
{
    static int last_evtype = -1;

    if (ev->any.header == 0xac)
        last_evtype = -1;

    assert(ev->any.type == ++last_evtype);
}

static void
dix_enqueue_events(void)
{
#define NEVENTS 5
    DeviceIntRec dev;
    InternalEvent ev[NEVENTS];
    SpriteInfoRec spriteInfo;
    SpriteRec sprite;
    QdEventPtr qe;
    int i;

    memset(&dev, 0, sizeof(dev));
    dev.public.processInputProc = process_input_proc;

    memset(&spriteInfo, 0, sizeof(spriteInfo));
    memset(&sprite, 0, sizeof(sprite));
    dev.spriteInfo = &spriteInfo;
    spriteInfo.sprite = &sprite;

    InitEvents();
    assert(xorg_list_is_empty(&syncEvents.pending));

    /* this way PlayReleasedEvents really runs through all events in the
     * queue */
    inputInfo.devices = &dev;

    /* to reset process_input_proc */
    ev[0].any.header = 0xac;

    for (i = 0; i < NEVENTS; i++) {
        ev[i].any.length = sizeof(*ev);
        ev[i].any.type = i;
        EnqueueEvent(&ev[i], &dev);
        assert(!xorg_list_is_empty(&syncEvents.pending));
        qe = xorg_list_last_entry(&syncEvents.pending, QdEventRec, next);
        assert(memcmp(qe->event, &ev[i], ev[i].any.length) == 0);
        qe = xorg_list_first_entry(&syncEvents.pending, QdEventRec, next);
        assert(memcmp(qe->event, &ev[0], ev[i].any.length) == 0);
    }

    /* calls process_input_proc */
    dev.deviceGrab.sync.frozen = 1;
    PlayReleasedEvents();
    assert(!xorg_list_is_empty(&syncEvents.pending));

    dev.deviceGrab.sync.frozen = 0;
    PlayReleasedEvents();
    assert(xorg_list_is_empty(&syncEvents.pending));

    inputInfo.devices = NULL;
}

int
main(int argc, char **argv)
{
    dix_enqueue_events();
    dix_double_fp_conversion();
    dix_input_valuator_masks();
    dix_input_valuator_masks_unaccel();
    dix_input_attributes();
    dix_init_valuators();
    dix_event_to_core_conversion();
    dix_event_to_xi1_conversion();
    dix_check_grab_values();
    xi2_struct_sizes();
    dix_grab_matching();
    dix_valuator_mode();
    include_byte_padding_macros();
    include_bit_test_macros();
    xi_unregister_handlers();
    dix_valuator_alloc();
    dix_get_master();
    input_option_test();
    mieq_test();

    return 0;
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1361 62
d1912 1
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d1183 1
a1183 1
    InputAttributes orig = { 0 };
a1184 1
    char *tags[4] = { "tag1", "tag2", "tag2", NULL };
d1189 2
a1190 2
    new = DuplicateInputAttributes(&orig);
    assert(memcmp(&orig, new, sizeof(InputAttributes)) == 0);
d1192 6
a1197 3
    orig.product = "product name";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1200 3
a1202 3
    orig.vendor = "vendor name";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1205 3
a1207 3
    orig.device = "device path";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1210 3
a1212 3
    orig.pnp_id = "PnPID";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1215 3
a1217 3
    orig.usb_id = "USBID";
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1220 3
a1222 3
    orig.flags = 0xF0;
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1225 3
a1227 3
    orig.tags = tags;
    new = DuplicateInputAttributes(&orig);
    cmp_attr_fields(&orig, new);
d1229 2
d1393 2
a1394 2
        assert(((void *) v->axisVal - (void *) v) % sizeof(double) == 0);
        assert(((void *) v->axes - (void *) v) % sizeof(double) == 0);
d1715 12
d1736 1
a1736 1
        mieqEnqueue(NULL, (InternalEvent *) &e);
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1387 1
a1387 1
#if !defined(__i386__) && !defined(__sh__)
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d409 1
a409 1
            deviceValuator *v = (deviceValuator *) & xi[count];
d968 13
d1012 1
a1012 1
    printf("Testing pad_to_int32\n");
a1014 1
    test_pad_to_int32(0);
d1017 1
d1028 17
@


1.5
log
@Update to xserver 1.11.2
@
text
@d43 1
d52 2
a53 1
static void dix_init_valuators(void)
d57 1
a61 1

d63 1
a63 1
    dev.type = MASTER_POINTER; /* claim it's a master to stop ptracccel */
d74 1
a74 2
    for (i = 0; i < num_axes; i++)
    {
d82 70
d156 2
a157 1
static void dix_check_grab_values(void)
d165 1
a165 1
    param.grabtype = GRABTYPE_CORE;
d178 5
a182 1
    param.this_device_mode = GrabModeAsync + 1;
d186 1
a186 1
    assert(client.errorValue == GrabModeAsync + 1);
d191 5
d198 1
a198 1
    param.other_devices_mode = GrabModeAsync + 1;
d202 1
a202 1
    assert(client.errorValue == GrabModeAsync + 1);
a211 1

a223 1

d228 2
a229 1
static void dix_event_to_core(int type)
d265 5
a269 5
    ev.header   = 0xFF;
    ev.length   = sizeof(DeviceEvent);
    ev.time     = time;
    ev.root_y   = x;
    ev.root_x   = y;
d272 1
a272 1
    ev.root     = ROOT_WINDOW_ID;
d278 1
a278 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d285 1
a285 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d292 1
a292 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d295 2
a296 2
    x = 0x8000; /* too high */
    y = 0x8000; /* too high */
d299 1
a299 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d312 1
a312 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d317 1
a317 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d320 1
a320 1
    detail = 0xFF; /* highest value */
d322 1
a322 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d325 1
a325 1
    detail = 0xFFF; /* too big */
d327 1
a327 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d330 1
a330 1
    detail = 0xFF; /* too big */
d332 1
a332 1
    state = 0xFFFF; /* highest value */
d334 1
a334 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d337 1
a337 1
    state = 0x10000; /* too big */
d339 1
a339 1
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d349 2
a350 1
static void dix_event_to_core_fail(int evtype, int expected_rc)
d357 2
a358 2
    ev.header   = 0xFF;
    ev.length   = sizeof(DeviceEvent);
d360 2
a361 2
    ev.type     = evtype;
    rc = EventToCore((InternalEvent*)&ev, &core, &count);
d365 2
a366 1
static void dix_event_to_core_conversion(void)
d388 1
a388 1
    rc = EventToXI((InternalEvent*)ev, &xi, &count);
d391 3
a393 2
    if (count > 0){
        deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*)xi;
d409 2
a410 1
            deviceValuator *v = (deviceValuator*)&xi[count];
a414 1

d425 2
a426 1
static void dix_event_to_xi1_conversion(void)
d428 1
a428 1
    DeviceEvent ev = {0};
d437 4
a440 4
    DeviceValuator      = IEventBase - 1;
    DeviceKeyPress      = IEventBase + ET_KeyPress;
    DeviceKeyRelease    = IEventBase + ET_KeyRelease;
    DeviceButtonPress   = IEventBase + ET_ButtonPress;
d442 5
a446 5
    DeviceMotionNotify  = IEventBase + ET_Motion;
    DeviceFocusIn       = IEventBase + ET_FocusIn;
    DeviceFocusOut      = IEventBase + ET_FocusOut;
    ProximityIn         = IEventBase + ET_ProximityIn;
    ProximityOut        = IEventBase + ET_ProximityOut;
d456 1
a456 1
    ev.header   = 0xFF;
d458 5
a462 5
    ev.header           = 0xFF;
    ev.length           = sizeof(DeviceEvent);
    ev.time             = time;
    ev.root_y           = x;
    ev.root_x           = y;
d465 4
a468 4
    ev.root             = ROOT_WINDOW_ID;
    ev.corestate        = state;
    ev.detail.key       = detail;
    ev.deviceid         = deviceid;
d471 14
a484 7
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, Success, 1);
d489 14
a502 7
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 1);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, BadMatch, 0);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, BadMatch, 0);
d512 14
a525 8
    ev.type = ET_KeyPress;         _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_KeyRelease;       _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonPress;      _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ButtonRelease;    _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_Motion;           _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityIn;      _dix_test_xi_convert(&ev, Success, 2);
    ev.type = ET_ProximityOut;     _dix_test_xi_convert(&ev, Success, 2);

d539 2
a540 2

static void xi2_struct_sizes(void)
d569 2
a570 2

static void dix_grab_matching(void)
d580 2
a581 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_XI2;
d587 2
a588 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI2;
d594 2
a595 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_CORE;
d617 2
a618 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d647 2
a648 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d656 2
a657 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d667 2
a668 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d676 2
a677 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d686 2
a687 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d699 2
a700 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d712 2
a713 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d726 2
a727 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d741 2
a742 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d748 2
a749 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d756 2
a757 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d766 2
a767 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d775 2
a776 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d785 2
a786 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d796 2
a797 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d803 2
a804 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d811 2
a812 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d822 2
a823 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d829 2
a830 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d837 2
a838 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d848 2
a849 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d855 2
a856 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d863 2
a864 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d874 2
a875 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d885 2
a886 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d897 2
a898 2
    a.grabtype = GRABTYPE_XI2;
    b.grabtype = GRABTYPE_XI2;
d908 2
a909 2
    a.grabtype = GRABTYPE_CORE;
    b.grabtype = GRABTYPE_CORE;
d919 2
a920 2
    a.grabtype = GRABTYPE_XI;
    b.grabtype = GRABTYPE_XI;
d931 2
a932 1
static void test_bits_to_byte(int i)
d934 3
a936 2
        int expected_bytes;
        expected_bytes = (i + 7)/8;
d938 3
a940 3
        assert(bits_to_bytes(i) >= i/8);
        assert((bits_to_bytes(i) * 8) - i <= 7);
        assert(expected_bytes == bits_to_bytes(i));
d943 2
a944 1
static void test_bytes_to_int32(int i)
d946 3
a948 2
        int expected_4byte;
        expected_4byte = (i + 3)/4;
d950 3
a952 3
        assert(bytes_to_int32(i) <= i);
        assert((bytes_to_int32(i) * 4) - i <= 3);
        assert(expected_4byte == bytes_to_int32(i));
d955 2
a956 1
static void test_pad_to_int32(int i)
d958 1
a958 2
        int expected_bytes;
        expected_bytes = ((i + 3)/4) * 4;
d960 5
a964 3
        assert(pad_to_int32(i) >= i);
        assert(pad_to_int32(i) - i <= 3);
        assert(expected_bytes == pad_to_int32(i));
d966 3
a968 1
static void include_byte_padding_macros(void)
d1017 2
a1018 1
static void xi_unregister_handlers(void)
d1034 1
a1034 1
    XIUnregisterPropertyHandler(&dev, 4); /* NOOP */
d1049 1
a1049 1
    XIUnregisterPropertyHandler(&dev, 3); /* NOOP */
d1067 1
a1067 1
    XIUnregisterPropertyHandler(&dev, 7); /* NOOP */
d1071 2
a1072 2
static void cmp_attr_fields(InputAttributes *attr1,
                            InputAttributes *attr2)
d1080 1
a1080 2
    if (attr1->product != NULL)
    {
d1083 2
a1084 1
    } else
d1087 1
a1087 2
    if (attr1->vendor != NULL)
    {
d1090 2
a1091 1
    } else
d1094 1
a1094 2
    if (attr1->device != NULL)
    {
d1097 2
a1098 1
    } else
d1101 1
a1101 2
    if (attr1->pnp_id != NULL)
    {
d1104 2
a1105 1
    } else
d1108 1
a1108 2
    if (attr1->usb_id != NULL)
    {
d1111 2
a1112 1
    } else
d1119 1
a1119 2
    if (!tags1)
    {
d1129 1
a1129 2
    while (*tags1)
    {
d1141 1
a1141 2
    while (*tags1)
    {
d1150 2
a1151 1
static void dix_input_attributes(void)
d1153 1
a1153 1
    InputAttributes orig = {0};
d1155 1
a1155 1
    char *tags[4] = {"tag1", "tag2", "tag2", NULL};
d1199 2
a1200 1
static void dix_input_valuator_masks(void)
d1204 2
a1205 1
    int valuators[nvaluators];
d1209 4
a1212 2
    for (i = 0; i < nvaluators; i++)
        valuators[i] = i;
d1219 1
a1219 2
    for (i = 0; i < nvaluators; i++)
    {
d1221 1
a1221 1
        valuator_mask_set(mask, i, valuators[i]);
d1223 2
a1224 1
        assert(valuator_mask_get(mask, i) == valuators[i]);
d1229 1
a1229 2
    for (i = 0; i < nvaluators; i++)
    {
d1249 1
a1249 1
    valuator_mask_set_range(mask, first_val, num_vals, valuators);
d1252 4
a1255 3
    for (i = 0; i < nvaluators; i++)
    {
        if (i < first_val || i >= first_val + num_vals)
d1257 3
a1259 2
        else
        {
d1261 5
a1265 1
            assert(valuator_mask_get(mask, i) == valuators[i - first_val]);
d1273 5
a1277 1
    assert(valuator_mask_num_valuators(mask) == valuator_mask_num_valuators(copy));
a1278 2
    for (i = 0; i < nvaluators; i++)
    {
d1280 4
d1285 5
d1296 2
a1297 1
static void dix_valuator_mode(void)
d1305 1
a1305 1
    dev.type = MASTER_POINTER; /* claim it's a master to stop ptracccel */
d1310 1
a1310 2
    for (i = 0; i < num_axes; i++)
    {
d1326 2
a1327 1
static void include_bit_test_macros(void)
d1332 1
a1332 2
    for (i = 0; i < sizeof(mask)/sizeof(mask[0]); i++)
    {
d1336 1
a1336 1
        assert(!!(mask[i/8] & (1 << (i % 8))));
d1346 2
a1347 1
static void dix_valuator_alloc(void)
d1352 1
a1352 2
    while (num_axes < 5)
    {
d1359 2
a1360 2
        assert(((void*)v->axisVal - (void*)v) % sizeof(double) == 0);
        assert(((void*)v->axes - (void*)v) % sizeof(double) == 0);
d1362 1
a1362 1
        num_axes ++;
d1368 432
a1799 1
int main(int argc, char** argv)
d1801 2
d1816 3
@


1.4
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d39 1
d42 2
a43 1
#include <glib.h>
d63 2
a64 2
    g_assert(InitValuatorClassDeviceStruct(NULL, 0, atoms, 0, 0) == FALSE);
    g_assert(InitValuatorClassDeviceStruct(&dev, num_axes, atoms, 0, Absolute));
d67 4
a70 5
    g_assert(val);
    g_assert(val->numAxes == num_axes);
    g_assert(val->numMotionEvents == 0);
    g_assert(val->mode == Absolute);
    g_assert(val->axisVal);
d74 4
a77 3
        g_assert(val->axisVal[i] == 0);
        g_assert(val->axes->min_value == NO_AXIS_LIMITS);
        g_assert(val->axes->max_value == NO_AXIS_LIMITS);
d80 1
a80 1
    g_assert(dev.last.numValuators == num_axes);
d100 1
a100 1
    g_assert(rc == Success);
d104 1
a104 1
    g_assert(rc == Success);
d108 3
a110 3
    g_assert(rc == BadValue);
    g_assert(client.errorValue == param.this_device_mode);
    g_assert(client.errorValue == GrabModeAsync + 1);
d115 1
a115 1
    g_assert(rc == Success);
d119 3
a121 3
    g_assert(rc == BadValue);
    g_assert(client.errorValue == param.other_devices_mode);
    g_assert(client.errorValue == GrabModeAsync + 1);
d127 3
a129 3
    g_assert(rc == BadValue);
    g_assert(client.errorValue == param.modifiers);
    g_assert(client.errorValue == (1 << 13));
d135 1
a135 1
    g_assert(rc == Success);
d139 3
a141 3
    g_assert(rc == BadValue);
    g_assert(client.errorValue == param.ownerEvents);
    g_assert(client.errorValue == 3);
d152 1
a152 1
    xEvent core;
d158 1
d163 15
a177 13
    g_assert(rc == Success); \
    g_assert(core.u.u.type == type); \
    g_assert(core.u.u.detail == detail); \
    g_assert(core.u.keyButtonPointer.time == time); \
    g_assert(core.u.keyButtonPointer.rootX == x); \
    g_assert(core.u.keyButtonPointer.rootY == y); \
    g_assert(core.u.keyButtonPointer.state == state); \
    g_assert(core.u.keyButtonPointer.eventX == 0); \
    g_assert(core.u.keyButtonPointer.eventY == 0); \
    g_assert(core.u.keyButtonPointer.root == ROOT_WINDOW_ID); \
    g_assert(core.u.keyButtonPointer.event == 0); \
    g_assert(core.u.keyButtonPointer.child == 0); \
    g_assert(core.u.keyButtonPointer.sameScreen == FALSE);
d198 1
a198 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d205 1
a205 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d212 1
a212 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d219 6
a224 3
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(core.u.keyButtonPointer.rootX != x);
    g_assert(core.u.keyButtonPointer.rootY != y);
d232 1
a232 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d237 1
a237 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d242 1
a242 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d247 2
a248 2
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(rc == BadMatch);
d254 1
a254 1
    rc = EventToCore((InternalEvent*)&ev, &core);
d259 6
a264 3
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(core.u.keyButtonPointer.state != state);
    g_assert(core.u.keyButtonPointer.state == (state & 0xFFFF));
d269 1
a269 1
static void dix_event_to_core_conversion(void)
d272 1
a272 1
    xEvent core;
d274 1
d279 12
a290 19
    ev.type     = 0;
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(rc == BadImplementation);

    ev.type     = 1;
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(rc == BadImplementation);

    ev.type     = ET_ProximityOut + 1;
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(rc == BadImplementation);

    ev.type     = ET_ProximityIn;
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(rc == BadMatch);

    ev.type     = ET_ProximityOut;
    rc = EventToCore((InternalEvent*)&ev, &core);
    g_assert(rc == BadMatch);
d299 137
d439 1
a439 1
    g_assert(sizeof(req) == sz_##req);
d479 1
a479 1
    g_assert(rc == FALSE);
d481 1
a481 1
    g_assert(rc == FALSE);
d486 1
a486 1
    g_assert(rc == FALSE);
d488 1
a488 1
    g_assert(rc == FALSE);
d493 1
a493 1
    g_assert(rc == FALSE);
d495 1
a495 1
    g_assert(rc == FALSE);
d519 1
a519 1
    g_assert(rc == FALSE);
d524 1
a524 1
    g_assert(rc == FALSE);
d526 1
a526 1
    g_assert(rc == FALSE);
d531 1
a531 1
    g_assert(rc == FALSE);
d533 1
a533 1
    g_assert(rc == FALSE);
d538 1
a538 1
    g_assert(rc == FALSE);
d540 1
a540 1
    g_assert(rc == FALSE);
d550 1
a550 1
    g_assert(rc == FALSE);
d559 1
a559 1
    g_assert(rc == FALSE);
d570 1
a570 1
    g_assert(rc == FALSE);
d579 1
a579 1
    g_assert(rc == FALSE);
d591 1
a591 1
    g_assert(rc == FALSE);
d593 1
a593 1
    g_assert(rc == FALSE);
d604 1
a604 1
    g_assert(rc == FALSE);
d606 1
a606 1
    g_assert(rc == FALSE);
d617 1
a617 1
    g_assert(rc == FALSE);
d619 1
a619 1
    g_assert(rc == FALSE);
d633 1
a633 1
    g_assert(rc == FALSE);
d635 1
a635 1
    g_assert(rc == FALSE);
d640 1
a640 1
    g_assert(rc == FALSE);
d642 1
a642 1
    g_assert(rc == FALSE);
d647 1
a647 1
    g_assert(rc == FALSE);
d649 1
a649 1
    g_assert(rc == FALSE);
d657 1
a657 1
    g_assert(rc == FALSE);
d659 1
a659 1
    g_assert(rc == FALSE);
d667 1
a667 1
    g_assert(rc == FALSE);
d669 1
a669 1
    g_assert(rc == FALSE);
d676 1
a676 1
    g_assert(rc == FALSE);
d678 1
a678 1
    g_assert(rc == FALSE);
d688 1
a688 1
    g_assert(rc == FALSE);
d690 1
a690 1
    g_assert(rc == FALSE);
d695 1
a695 1
    g_assert(rc == FALSE);
d697 1
a697 1
    g_assert(rc == FALSE);
d702 1
a702 1
    g_assert(rc == FALSE);
d704 1
a704 1
    g_assert(rc == FALSE);
d714 1
a714 1
    g_assert(rc == FALSE);
d716 1
a716 1
    g_assert(rc == FALSE);
d721 1
a721 1
    g_assert(rc == FALSE);
d723 1
a723 1
    g_assert(rc == FALSE);
d728 1
a728 1
    g_assert(rc == FALSE);
d730 1
a730 1
    g_assert(rc == FALSE);
d740 1
a740 1
    g_assert(rc == FALSE);
d742 1
a742 1
    g_assert(rc == FALSE);
d747 1
a747 1
    g_assert(rc == FALSE);
d749 1
a749 1
    g_assert(rc == FALSE);
d754 1
a754 1
    g_assert(rc == FALSE);
d756 1
a756 1
    g_assert(rc == FALSE);
d766 1
a766 1
    g_assert(rc == TRUE);
d768 1
a768 1
    g_assert(rc == TRUE);
d777 1
a777 1
    g_assert(rc == TRUE);
d779 1
a779 1
    g_assert(rc == TRUE);
d788 1
a788 1
    g_assert(rc == TRUE);
d790 1
a790 1
    g_assert(rc == TRUE);
d800 1
a800 1
    g_assert(rc == TRUE);
d802 1
a802 1
    g_assert(rc == TRUE);
d811 1
a811 1
    g_assert(rc == TRUE);
d813 1
a813 1
    g_assert(rc == TRUE);
d822 1
a822 1
    g_assert(rc == TRUE);
d824 1
a824 1
    g_assert(rc == TRUE);
d832 3
a834 3
        g_assert(bits_to_bytes(i) >= i/8);
        g_assert((bits_to_bytes(i) * 8) - i <= 7);
        g_assert(expected_bytes == bits_to_bytes(i));
d842 3
a844 3
        g_assert(bytes_to_int32(i) <= i);
        g_assert((bytes_to_int32(i) * 4) - i <= 3);
        g_assert(expected_4byte == bytes_to_int32(i));
d852 3
a854 3
        g_assert(pad_to_int32(i) >= i);
        g_assert(pad_to_int32(i) - i <= 3);
        g_assert(expected_bytes == pad_to_int32(i));
d858 1
a858 1
    g_test_message("Testing bits_to_bytes()");
d871 1
a871 1
    g_test_message("Testing bytes_to_int32()");
d887 1
a887 1
    g_test_message("Testing pad_to_int32");
d913 1
a913 1
    g_assert(handler == 1);
d915 1
a915 1
    g_assert(handler == 2);
d917 1
a917 1
    g_assert(handler == 3);
d919 1
a919 1
    g_test_message("Unlinking from front.");
d922 1
a922 1
    g_assert(dev.properties.handlers->id == 3);
d924 1
a924 1
    g_assert(dev.properties.handlers->id == 2);
d926 1
a926 1
    g_assert(dev.properties.handlers->id == 1);
d928 1
a928 1
    g_assert(dev.properties.handlers == NULL);
d931 1
a931 1
    g_assert(handler == 4);
d933 1
a933 1
    g_assert(handler == 5);
d935 1
a935 1
    g_assert(handler == 6);
d937 1
a937 1
    g_assert(dev.properties.handlers->next->next->next == NULL);
d939 1
a939 1
    g_assert(dev.properties.handlers->next->next == NULL);
d941 1
a941 1
    g_assert(dev.properties.handlers->next == NULL);
d943 1
a943 1
    g_assert(dev.properties.handlers == NULL);
d946 1
a946 1
    g_assert(handler == 7);
d948 1
a948 1
    g_assert(handler == 8);
d950 1
a950 1
    g_assert(handler == 9);
d953 1
a953 1
    g_assert(dev.properties.handlers == NULL);
d963 3
a965 3
    g_assert(attr1 && attr2);
    g_assert(attr1 != attr2);
    g_assert(attr1->flags == attr2->flags);
d969 2
a970 2
        g_assert(attr1->product != attr2->product);
        g_assert(strcmp(attr1->product, attr2->product) == 0);
d972 1
a972 1
        g_assert(attr2->product == NULL);
d976 2
a977 2
        g_assert(attr1->vendor != attr2->vendor);
        g_assert(strcmp(attr1->vendor, attr2->vendor) == 0);
d979 1
a979 1
        g_assert(attr2->vendor == NULL);
d983 2
a984 2
        g_assert(attr1->device != attr2->device);
        g_assert(strcmp(attr1->device, attr2->device) == 0);
d986 1
a986 1
        g_assert(attr2->device == NULL);
d990 2
a991 2
        g_assert(attr1->pnp_id != attr2->pnp_id);
        g_assert(strcmp(attr1->pnp_id, attr2->pnp_id) == 0);
d993 1
a993 1
        g_assert(attr2->pnp_id == NULL);
d997 2
a998 2
        g_assert(attr1->usb_id != attr2->usb_id);
        g_assert(strcmp(attr1->usb_id, attr2->usb_id) == 0);
d1000 1
a1000 1
        g_assert(attr2->usb_id == NULL);
d1008 1
a1008 1
        g_assert(!tags2);
d1013 2
a1014 2
    g_assert(*tags1);
    g_assert(*tags2);
d1019 2
a1020 2
        g_assert(*tags1 != *tags2);
        g_assert(strcmp(*tags1, *tags2) == 0);
d1026 1
a1026 1
    g_assert(!*tags2);
d1034 1
a1034 1
            g_assert(*tags1 != *tags2++);
d1047 1
a1047 1
    g_assert(!new);
d1050 1
a1050 1
    g_assert(memcmp(&orig, new, sizeof(InputAttributes)) == 0);
d1088 10
d1099 117
a1215 1
int main(int argc, char** argv)
d1217 2
a1218 2
    g_test_init(&argc, &argv,NULL);
    g_test_bug_base("https://bugzilla.freedesktop.org/show_bug.cgi?id=");
d1220 3
a1222 8
    g_test_add_func("/dix/input/attributes", dix_input_attributes);
    g_test_add_func("/dix/input/init-valuators", dix_init_valuators);
    g_test_add_func("/dix/input/event-core-conversion", dix_event_to_core_conversion);
    g_test_add_func("/dix/input/check-grab-values", dix_check_grab_values);
    g_test_add_func("/dix/input/xi2-struct-sizes", xi2_struct_sizes);
    g_test_add_func("/dix/input/grab_matching", dix_grab_matching);
    g_test_add_func("/include/byte_padding_macros", include_byte_padding_macros);
    g_test_add_func("/Xi/xiproperty/register-unregister", xi_unregister_handlers);
d1224 28
d1253 1
a1253 1
    return g_test_run();
@


1.3
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d685 1
a685 1
static void include_byte_padding_macros(void)
a686 6
    int i;
    g_test_message("Testing bits_to_bytes()");

    /* the macros don't provide overflow protection */
    for (i = 0; i < INT_MAX - 7; i++)
    {
d692 2
a693 1
    }
d695 2
a696 3
    g_test_message("Testing bytes_to_int32()");
    for (i = 0; i < INT_MAX - 3; i++)
    {
d702 2
a703 1
    }
d705 2
a706 4
    g_test_message("Testing pad_to_int32");

    for (i = 0; i < INT_MAX - 3; i++)
    {
d712 34
a745 1
    }
d747 14
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d185 2
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d774 131
d910 1
d918 1
@

