head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.28.15.36.36;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.31.07.52.36;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "scrnintstr.h"
#include "cursorstr.h"
#include "dixevents.h"
#include "servermd.h"
#include "mipointer.h"
#include "inputstr.h"
#include "windowstr.h"
#include "xace.h"
#include "list.h"
#include "xibarriers.h"

static RESTYPE CursorClientType;
static RESTYPE CursorHideCountType;
static RESTYPE CursorWindowType;
static CursorPtr CursorCurrent[MAXDEVICES];

static DevPrivateKeyRec CursorScreenPrivateKeyRec;

#define CursorScreenPrivateKey (&CursorScreenPrivateKeyRec)

static void deleteCursorHideCountsForScreen(ScreenPtr pScreen);

#define VERIFY_CURSOR(pCursor, cursor, client, access)			\
    do {								\
	int err;							\
	err = dixLookupResourceByType((void **) &pCursor, cursor,	\
				      RT_CURSOR, client, access);	\
	if (err != Success) {						\
	    client->errorValue = cursor;				\
	    return err;							\
	}								\
    } while (0)

/*
 * There is a global list of windows selecting for cursor events
 */

typedef struct _CursorEvent *CursorEventPtr;

typedef struct _CursorEvent {
    CursorEventPtr next;
    CARD32 eventMask;
    ClientPtr pClient;
    WindowPtr pWindow;
    XID clientResource;
} CursorEventRec;

static CursorEventPtr cursorEvents;

/*
 * Each screen has a list of clients which have requested
 * that the cursor be hid, and the number of times each
 * client has requested.
*/

typedef struct _CursorHideCountRec *CursorHideCountPtr;

typedef struct _CursorHideCountRec {
    CursorHideCountPtr pNext;
    ClientPtr pClient;
    ScreenPtr pScreen;
    int hideCount;
    XID resource;
} CursorHideCountRec;

/*
 * Wrap DisplayCursor to catch cursor change events
 */

typedef struct _CursorScreen {
    DisplayCursorProcPtr DisplayCursor;
    CloseScreenProcPtr CloseScreen;
    CursorHideCountPtr pCursorHideCounts;
} CursorScreenRec, *CursorScreenPtr;

#define GetCursorScreen(s) ((CursorScreenPtr)dixLookupPrivate(&(s)->devPrivates, CursorScreenPrivateKey))
#define GetCursorScreenIfSet(s) GetCursorScreen(s)
#define SetCursorScreen(s,p) dixSetPrivate(&(s)->devPrivates, CursorScreenPrivateKey, p)
#define Wrap(as,s,elt,func)	(((as)->elt = (s)->elt), (s)->elt = func)
#define Unwrap(as,s,elt,backup)	(((backup) = (s)->elt), (s)->elt = (as)->elt)

/* The cursor doesn't show up until the first XDefineCursor() */
Bool CursorVisible = FALSE;
Bool EnableCursor = TRUE;

static Bool
CursorDisplayCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    CursorScreenPtr cs = GetCursorScreen(pScreen);
    Bool ret;
    DisplayCursorProcPtr backupProc;

    Unwrap(cs, pScreen, DisplayCursor, backupProc);

    CursorVisible = CursorVisible && EnableCursor;

    if (cs->pCursorHideCounts != NULL || !CursorVisible) {
        ret = (*pScreen->DisplayCursor) (pDev, pScreen, NullCursor);
    }
    else {
        ret = (*pScreen->DisplayCursor) (pDev, pScreen, pCursor);
    }

    if (pCursor != CursorCurrent[pDev->id]) {
        CursorEventPtr e;

        CursorCurrent[pDev->id] = pCursor;
        for (e = cursorEvents; e; e = e->next) {
            if ((e->eventMask & XFixesDisplayCursorNotifyMask)) {
                xXFixesCursorNotifyEvent ev = {
                    .type = XFixesEventBase + XFixesCursorNotify,
                    .subtype = XFixesDisplayCursorNotify,
                    .window = e->pWindow->drawable.id,
                    .cursorSerial = pCursor ? pCursor->serialNumber : 0,
                    .timestamp = currentTime.milliseconds,
                    .name = pCursor ? pCursor->name : None
                };
                WriteEventsToClient(e->pClient, 1, (xEvent *) &ev);
            }
        }
    }
    Wrap(cs, pScreen, DisplayCursor, backupProc);

    return ret;
}

static Bool
CursorCloseScreen(ScreenPtr pScreen)
{
    CursorScreenPtr cs = GetCursorScreen(pScreen);
    Bool ret;
    _X_UNUSED CloseScreenProcPtr close_proc;
    _X_UNUSED DisplayCursorProcPtr display_proc;

    Unwrap(cs, pScreen, CloseScreen, close_proc);
    Unwrap(cs, pScreen, DisplayCursor, display_proc);
    deleteCursorHideCountsForScreen(pScreen);
    ret = (*pScreen->CloseScreen) (pScreen);
    free(cs);
    return ret;
}

#define CursorAllEvents (XFixesDisplayCursorNotifyMask)

static int
XFixesSelectCursorInput(ClientPtr pClient, WindowPtr pWindow, CARD32 eventMask)
{
    CursorEventPtr *prev, e;
    void *val;
    int rc;

    for (prev = &cursorEvents; (e = *prev); prev = &e->next) {
        if (e->pClient == pClient && e->pWindow == pWindow) {
            break;
        }
    }
    if (!eventMask) {
        if (e) {
            FreeResource(e->clientResource, 0);
        }
        return Success;
    }
    if (!e) {
        e = (CursorEventPtr) malloc(sizeof(CursorEventRec));
        if (!e)
            return BadAlloc;

        e->next = 0;
        e->pClient = pClient;
        e->pWindow = pWindow;
        e->clientResource = FakeClientID(pClient->index);

        /*
         * Add a resource hanging from the window to
         * catch window destroy
         */
        rc = dixLookupResourceByType(&val, pWindow->drawable.id,
                                     CursorWindowType, serverClient,
                                     DixGetAttrAccess);
        if (rc != Success)
            if (!AddResource(pWindow->drawable.id, CursorWindowType,
                             (void *) pWindow)) {
                free(e);
                return BadAlloc;
            }

        if (!AddResource(e->clientResource, CursorClientType, (void *) e))
            return BadAlloc;

        *prev = e;
    }
    e->eventMask = eventMask;
    return Success;
}

int
ProcXFixesSelectCursorInput(ClientPtr client)
{
    REQUEST(xXFixesSelectCursorInputReq);
    WindowPtr pWin;
    int rc;

    REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->eventMask & ~CursorAllEvents) {
        client->errorValue = stuff->eventMask;
        return BadValue;
    }
    return XFixesSelectCursorInput(client, pWin, stuff->eventMask);
}

static int
GetBit(unsigned char *line, int x)
{
    unsigned char mask;

    if (screenInfo.bitmapBitOrder == LSBFirst)
        mask = (1 << (x & 7));
    else
        mask = (0x80 >> (x & 7));
    /* XXX assumes byte order is host byte order */
    line += (x >> 3);
    if (*line & mask)
        return 1;
    return 0;
}

int
SProcXFixesSelectCursorInput(ClientPtr client)
{
    REQUEST(xXFixesSelectCursorInputReq);

    swaps(&stuff->length);
    swapl(&stuff->window);
    swapl(&stuff->eventMask);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

void
SXFixesCursorNotifyEvent(xXFixesCursorNotifyEvent * from,
                         xXFixesCursorNotifyEvent * to)
{
    to->type = from->type;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->window, to->window);
    cpswapl(from->cursorSerial, to->cursorSerial);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->name, to->name);
}

static void
CopyCursorToImage(CursorPtr pCursor, CARD32 *image)
{
    int width = pCursor->bits->width;
    int height = pCursor->bits->height;
    int npixels = width * height;

    if (pCursor->bits->argb)
        memcpy(image, pCursor->bits->argb, npixels * sizeof(CARD32));
    else
    {
        unsigned char *srcLine = pCursor->bits->source;
        unsigned char *mskLine = pCursor->bits->mask;
        int stride = BitmapBytePad(width);
        int x, y;
        CARD32 fg, bg;

        fg = (0xff000000 |
              ((pCursor->foreRed & 0xff00) << 8) |
              (pCursor->foreGreen & 0xff00) | (pCursor->foreBlue >> 8));
        bg = (0xff000000 |
              ((pCursor->backRed & 0xff00) << 8) |
              (pCursor->backGreen & 0xff00) | (pCursor->backBlue >> 8));
        for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
                if (GetBit(mskLine, x)) {
                    if (GetBit(srcLine, x))
                        *image++ = fg;
                    else
                        *image++ = bg;
                }
                else
                    *image++ = 0;
            }
            srcLine += stride;
            mskLine += stride;
        }
    }
}

int
ProcXFixesGetCursorImage(ClientPtr client)
{
/*    REQUEST(xXFixesGetCursorImageReq); */
    xXFixesGetCursorImageReply *rep;
    CursorPtr pCursor;
    CARD32 *image;
    int npixels, width, height, rc, x, y;

    REQUEST_SIZE_MATCH(xXFixesGetCursorImageReq);
    pCursor = CursorCurrent[PickPointer(client)->id];
    if (!pCursor)
        return BadCursor;
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, pCursor->id, RT_CURSOR,
                  pCursor, RT_NONE, NULL, DixReadAccess);
    if (rc != Success)
        return rc;
    GetSpritePosition(PickPointer(client), &x, &y);
    width = pCursor->bits->width;
    height = pCursor->bits->height;
    npixels = width * height;
    rep = calloc(sizeof(xXFixesGetCursorImageReply) + npixels * sizeof(CARD32),
                 1);
    if (!rep)
        return BadAlloc;

    rep->type = X_Reply;
    rep->sequenceNumber = client->sequence;
    rep->length = npixels;
    rep->width = width;
    rep->height = height;
    rep->x = x;
    rep->y = y;
    rep->xhot = pCursor->bits->xhot;
    rep->yhot = pCursor->bits->yhot;
    rep->cursorSerial = pCursor->serialNumber;

    image = (CARD32 *) (rep + 1);
    CopyCursorToImage(pCursor, image);
    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swaps(&rep->x);
        swaps(&rep->y);
        swaps(&rep->width);
        swaps(&rep->height);
        swaps(&rep->xhot);
        swaps(&rep->yhot);
        swapl(&rep->cursorSerial);
        SwapLongs(image, npixels);
    }
    WriteToClient(client,
                  sizeof(xXFixesGetCursorImageReply) + (npixels << 2), rep);
    free(rep);
    return Success;
}

int
SProcXFixesGetCursorImage(ClientPtr client)
{
    REQUEST(xXFixesGetCursorImageReq);
    swaps(&stuff->length);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetCursorName(ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;

    REQUEST(xXFixesSetCursorNameReq);
    Atom atom;

    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
    tchar = (char *) &stuff[1];
    atom = MakeAtom(tchar, stuff->nbytes, TRUE);
    if (atom == BAD_RESOURCE)
        return BadAlloc;

    pCursor->name = atom;
    return Success;
}

int
SProcXFixesSetCursorName(ClientPtr client)
{
    REQUEST(xXFixesSetCursorNameReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
    swapl(&stuff->cursor);
    swaps(&stuff->nbytes);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesGetCursorName(ClientPtr client)
{
    CursorPtr pCursor;
    xXFixesGetCursorNameReply reply;

    REQUEST(xXFixesGetCursorNameReq);
    const char *str;
    int len;

    REQUEST_SIZE_MATCH(xXFixesGetCursorNameReq);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixGetAttrAccess);
    if (pCursor->name)
        str = NameForAtom(pCursor->name);
    else
        str = "";
    len = strlen(str);

    reply = (xXFixesGetCursorNameReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(len),
        .atom = pCursor->name,
        .nbytes = len
    };
    if (client->swapped) {
        swaps(&reply.sequenceNumber);
        swapl(&reply.length);
        swapl(&reply.atom);
        swaps(&reply.nbytes);
    }
    WriteReplyToClient(client, sizeof(xXFixesGetCursorNameReply), &reply);
    WriteToClient(client, len, str);

    return Success;
}

int
SProcXFixesGetCursorName(ClientPtr client)
{
    REQUEST(xXFixesGetCursorNameReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesGetCursorNameReq);
    swapl(&stuff->cursor);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesGetCursorImageAndName(ClientPtr client)
{
/*    REQUEST(xXFixesGetCursorImageAndNameReq); */
    xXFixesGetCursorImageAndNameReply *rep;
    CursorPtr pCursor;
    CARD32 *image;
    int npixels;
    const char *name;
    int nbytes, nbytesRound;
    int width, height;
    int rc, x, y;

    REQUEST_SIZE_MATCH(xXFixesGetCursorImageAndNameReq);
    pCursor = CursorCurrent[PickPointer(client)->id];
    if (!pCursor)
        return BadCursor;
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, pCursor->id, RT_CURSOR,
                  pCursor, RT_NONE, NULL, DixReadAccess | DixGetAttrAccess);
    if (rc != Success)
        return rc;
    GetSpritePosition(PickPointer(client), &x, &y);
    width = pCursor->bits->width;
    height = pCursor->bits->height;
    npixels = width * height;
    name = pCursor->name ? NameForAtom(pCursor->name) : "";
    nbytes = strlen(name);
    nbytesRound = pad_to_int32(nbytes);
    rep = calloc(sizeof(xXFixesGetCursorImageAndNameReply) +
                 npixels * sizeof(CARD32) + nbytesRound, 1);
    if (!rep)
        return BadAlloc;

    rep->type = X_Reply;
    rep->sequenceNumber = client->sequence;
    rep->length = npixels + bytes_to_int32(nbytesRound);
    rep->width = width;
    rep->height = height;
    rep->x = x;
    rep->y = y;
    rep->xhot = pCursor->bits->xhot;
    rep->yhot = pCursor->bits->yhot;
    rep->cursorSerial = pCursor->serialNumber;
    rep->cursorName = pCursor->name;
    rep->nbytes = nbytes;

    image = (CARD32 *) (rep + 1);
    CopyCursorToImage(pCursor, image);
    memcpy((image + npixels), name, nbytes);
    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swaps(&rep->x);
        swaps(&rep->y);
        swaps(&rep->width);
        swaps(&rep->height);
        swaps(&rep->xhot);
        swaps(&rep->yhot);
        swapl(&rep->cursorSerial);
        swapl(&rep->cursorName);
        swaps(&rep->nbytes);
        SwapLongs(image, npixels);
    }
    WriteToClient(client, sizeof(xXFixesGetCursorImageAndNameReply) +
                  (npixels << 2) + nbytesRound, rep);
    free(rep);
    return Success;
}

int
SProcXFixesGetCursorImageAndName(ClientPtr client)
{
    REQUEST(xXFixesGetCursorImageAndNameReq);
    swaps(&stuff->length);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

/*
 * Find every cursor reference in the system, ask testCursor
 * whether it should be replaced with a reference to pCursor.
 */

typedef Bool (*TestCursorFunc) (CursorPtr pOld, void *closure);

typedef struct {
    RESTYPE type;
    TestCursorFunc testCursor;
    CursorPtr pNew;
    void *closure;
} ReplaceCursorLookupRec, *ReplaceCursorLookupPtr;

static const RESTYPE CursorRestypes[] = {
    RT_WINDOW, RT_PASSIVEGRAB, RT_CURSOR
};

#define NUM_CURSOR_RESTYPES (sizeof (CursorRestypes) / sizeof (CursorRestypes[0]))

static Bool
ReplaceCursorLookup(void *value, XID id, void *closure)
{
    ReplaceCursorLookupPtr rcl = (ReplaceCursorLookupPtr) closure;
    WindowPtr pWin;
    GrabPtr pGrab;
    CursorPtr pCursor = 0, *pCursorRef = 0;
    XID cursor = 0;

    switch (rcl->type) {
    case RT_WINDOW:
        pWin = (WindowPtr) value;
        if (pWin->optional) {
            pCursorRef = &pWin->optional->cursor;
            pCursor = *pCursorRef;
        }
        break;
    case RT_PASSIVEGRAB:
        pGrab = (GrabPtr) value;
        pCursorRef = &pGrab->cursor;
        pCursor = *pCursorRef;
        break;
    case RT_CURSOR:
        pCursorRef = 0;
        pCursor = (CursorPtr) value;
        cursor = id;
        break;
    }
    if (pCursor && pCursor != rcl->pNew) {
        if ((*rcl->testCursor) (pCursor, rcl->closure)) {
            CursorPtr curs = RefCursor(rcl->pNew);
            /* either redirect reference or update resource database */
            if (pCursorRef)
                *pCursorRef = curs;
            else
                ChangeResourceValue(id, RT_CURSOR, curs);
            FreeCursor(pCursor, cursor);
        }
    }
    return FALSE;               /* keep walking */
}

static void
ReplaceCursor(CursorPtr pCursor, TestCursorFunc testCursor, void *closure)
{
    int clientIndex;
    int resIndex;
    ReplaceCursorLookupRec rcl;

    /*
     * Cursors exist only in the resource database, windows and grabs.
     * All of these are always pointed at by the resource database.  Walk
     * the whole thing looking for cursors
     */
    rcl.testCursor = testCursor;
    rcl.pNew = pCursor;
    rcl.closure = closure;

    /* for each client */
    for (clientIndex = 0; clientIndex < currentMaxClients; clientIndex++) {
        if (!clients[clientIndex])
            continue;
        for (resIndex = 0; resIndex < NUM_CURSOR_RESTYPES; resIndex++) {
            rcl.type = CursorRestypes[resIndex];
            /*
             * This function walks the entire client resource database
             */
            LookupClientResourceComplex(clients[clientIndex],
                                        rcl.type,
                                        ReplaceCursorLookup, (void *) &rcl);
        }
    }
    /* this "knows" that WindowHasNewCursor doesn't depend on it's argument */
    WindowHasNewCursor(screenInfo.screens[0]->root);
}

static Bool
TestForCursor(CursorPtr pCursor, void *closure)
{
    return (pCursor == (CursorPtr) closure);
}

int
ProcXFixesChangeCursor(ClientPtr client)
{
    CursorPtr pSource, pDestination;

    REQUEST(xXFixesChangeCursorReq);

    REQUEST_SIZE_MATCH(xXFixesChangeCursorReq);
    VERIFY_CURSOR(pSource, stuff->source, client,
                  DixReadAccess | DixGetAttrAccess);
    VERIFY_CURSOR(pDestination, stuff->destination, client,
                  DixWriteAccess | DixSetAttrAccess);

    ReplaceCursor(pSource, TestForCursor, (void *) pDestination);
    return Success;
}

int
SProcXFixesChangeCursor(ClientPtr client)
{
    REQUEST(xXFixesChangeCursorReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesChangeCursorReq);
    swapl(&stuff->source);
    swapl(&stuff->destination);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static Bool
TestForCursorName(CursorPtr pCursor, void *closure)
{
    Atom *pName = closure;

    return pCursor->name == *pName;
}

int
ProcXFixesChangeCursorByName(ClientPtr client)
{
    CursorPtr pSource;
    Atom name;
    char *tchar;

    REQUEST(xXFixesChangeCursorByNameReq);

    REQUEST_FIXED_SIZE(xXFixesChangeCursorByNameReq, stuff->nbytes);
    VERIFY_CURSOR(pSource, stuff->source, client,
                  DixReadAccess | DixGetAttrAccess);
    tchar = (char *) &stuff[1];
    name = MakeAtom(tchar, stuff->nbytes, FALSE);
    if (name)
        ReplaceCursor(pSource, TestForCursorName, &name);
    return Success;
}

int
SProcXFixesChangeCursorByName(ClientPtr client)
{
    REQUEST(xXFixesChangeCursorByNameReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXFixesChangeCursorByNameReq);
    swapl(&stuff->source);
    swaps(&stuff->nbytes);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

/*
 * Routines for manipulating the per-screen hide counts list.
 * This list indicates which clients have requested cursor hiding
 * for that screen.
 */

/* Return the screen's hide-counts list element for the given client */
static CursorHideCountPtr
findCursorHideCount(ClientPtr pClient, ScreenPtr pScreen)
{
    CursorScreenPtr cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc;

    for (pChc = cs->pCursorHideCounts; pChc != NULL; pChc = pChc->pNext) {
        if (pChc->pClient == pClient) {
            return pChc;
        }
    }

    return NULL;
}

static int
createCursorHideCount(ClientPtr pClient, ScreenPtr pScreen)
{
    CursorScreenPtr cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc;

    pChc = (CursorHideCountPtr) malloc(sizeof(CursorHideCountRec));
    if (pChc == NULL) {
        return BadAlloc;
    }
    pChc->pClient = pClient;
    pChc->pScreen = pScreen;
    pChc->hideCount = 1;
    pChc->resource = FakeClientID(pClient->index);
    pChc->pNext = cs->pCursorHideCounts;
    cs->pCursorHideCounts = pChc;

    /*
     * Create a resource for this element so it can be deleted
     * when the client goes away.
     */
    if (!AddResource(pChc->resource, CursorHideCountType, (void *) pChc))
        return BadAlloc;

    return Success;
}

/*
 * Delete the given hide-counts list element from its screen list.
 */
static void
deleteCursorHideCount(CursorHideCountPtr pChcToDel, ScreenPtr pScreen)
{
    CursorScreenPtr cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc, pNext;
    CursorHideCountPtr pChcLast = NULL;

    pChc = cs->pCursorHideCounts;
    while (pChc != NULL) {
        pNext = pChc->pNext;
        if (pChc == pChcToDel) {
            free(pChc);
            if (pChcLast == NULL) {
                cs->pCursorHideCounts = pNext;
            }
            else {
                pChcLast->pNext = pNext;
            }
            return;
        }
        pChcLast = pChc;
        pChc = pNext;
    }
}

/*
 * Delete all the hide-counts list elements for this screen.
 */
static void
deleteCursorHideCountsForScreen(ScreenPtr pScreen)
{
    CursorScreenPtr cs = GetCursorScreen(pScreen);
    CursorHideCountPtr pChc, pTmp;

    pChc = cs->pCursorHideCounts;
    while (pChc != NULL) {
        pTmp = pChc->pNext;
        FreeResource(pChc->resource, 0);
        pChc = pTmp;
    }
    cs->pCursorHideCounts = NULL;
}

int
ProcXFixesHideCursor(ClientPtr client)
{
    WindowPtr pWin;
    CursorHideCountPtr pChc;

    REQUEST(xXFixesHideCursorReq);
    int ret;

    REQUEST_SIZE_MATCH(xXFixesHideCursorReq);

    ret = dixLookupResourceByType((void **) &pWin, stuff->window, RT_WINDOW,
                                  client, DixGetAttrAccess);
    if (ret != Success) {
        client->errorValue = stuff->window;
        return ret;
    }

    /*
     * Has client hidden the cursor before on this screen?
     * If so, just increment the count.
     */

    pChc = findCursorHideCount(client, pWin->drawable.pScreen);
    if (pChc != NULL) {
        pChc->hideCount++;
        return Success;
    }

    /*
     * This is the first time this client has hid the cursor
     * for this screen.
     */
    ret = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
                   DixHideAccess);
    if (ret != Success)
        return ret;

    ret = createCursorHideCount(client, pWin->drawable.pScreen);

    if (ret == Success) {
        DeviceIntPtr dev;

        for (dev = inputInfo.devices; dev; dev = dev->next) {
            if (IsMaster(dev) && IsPointerDevice(dev))
                CursorDisplayCursor(dev, pWin->drawable.pScreen,
                                    CursorCurrent[dev->id]);
        }
    }

    return ret;
}

int
SProcXFixesHideCursor(ClientPtr client)
{
    REQUEST(xXFixesHideCursorReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesHideCursorReq);
    swapl(&stuff->window);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesShowCursor(ClientPtr client)
{
    WindowPtr pWin;
    CursorHideCountPtr pChc;
    int rc;

    REQUEST(xXFixesShowCursorReq);

    REQUEST_SIZE_MATCH(xXFixesShowCursorReq);

    rc = dixLookupResourceByType((void **) &pWin, stuff->window, RT_WINDOW,
                                 client, DixGetAttrAccess);
    if (rc != Success) {
        client->errorValue = stuff->window;
        return rc;
    }

    /*
     * Has client hidden the cursor on this screen?
     * If not, generate an error.
     */
    pChc = findCursorHideCount(client, pWin->drawable.pScreen);
    if (pChc == NULL) {
        return BadMatch;
    }

    rc = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
                  DixShowAccess);
    if (rc != Success)
        return rc;

    pChc->hideCount--;
    if (pChc->hideCount <= 0) {
        FreeResource(pChc->resource, 0);
    }

    return Success;
}

int
SProcXFixesShowCursor(ClientPtr client)
{
    REQUEST(xXFixesShowCursorReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesShowCursorReq);
    swapl(&stuff->window);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int
CursorFreeClient(void *data, XID id)
{
    CursorEventPtr old = (CursorEventPtr) data;
    CursorEventPtr *prev, e;

    for (prev = &cursorEvents; (e = *prev); prev = &e->next) {
        if (e == old) {
            *prev = e->next;
            free(e);
            break;
        }
    }
    return 1;
}

static int
CursorFreeHideCount(void *data, XID id)
{
    CursorHideCountPtr pChc = (CursorHideCountPtr) data;
    ScreenPtr pScreen = pChc->pScreen;
    DeviceIntPtr dev;

    deleteCursorHideCount(pChc, pChc->pScreen);
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (IsMaster(dev) && IsPointerDevice(dev))
            CursorDisplayCursor(dev, pScreen, CursorCurrent[dev->id]);
    }

    return 1;
}

static int
CursorFreeWindow(void *data, XID id)
{
    WindowPtr pWindow = (WindowPtr) data;
    CursorEventPtr e, next;

    for (e = cursorEvents; e; e = next) {
        next = e->next;
        if (e->pWindow == pWindow) {
            FreeResource(e->clientResource, 0);
        }
    }
    return 1;
}

int
ProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);

    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    LEGAL_NEW_RESOURCE(stuff->barrier, client);

    return XICreatePointerBarrier(client, stuff);
}

int
SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
    CARD16 *in_devices = (CARD16 *) &stuff[1];

    swaps(&stuff->length);
    swaps(&stuff->num_devices);
    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));

    swapl(&stuff->barrier);
    swapl(&stuff->window);
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}

int
ProcXFixesDestroyPointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesDestroyPointerBarrierReq);

    REQUEST_SIZE_MATCH(xXFixesDestroyPointerBarrierReq);

    return XIDestroyPointerBarrier(client, stuff);
}

int
SProcXFixesDestroyPointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesDestroyPointerBarrierReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesDestroyPointerBarrierReq);
    swapl(&stuff->barrier);
    return ProcXFixesVector[stuff->xfixesReqType] (client);
}

Bool
XFixesCursorInit(void)
{
    int i;

    if (party_like_its_1989)
        CursorVisible = EnableCursor;
    else
        CursorVisible = FALSE;

    if (!dixRegisterPrivateKey(&CursorScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        CursorScreenPtr cs;

        cs = (CursorScreenPtr) calloc(1, sizeof(CursorScreenRec));
        if (!cs)
            return FALSE;
        Wrap(cs, pScreen, CloseScreen, CursorCloseScreen);
        Wrap(cs, pScreen, DisplayCursor, CursorDisplayCursor);
        cs->pCursorHideCounts = NULL;
        SetCursorScreen(pScreen, cs);
    }
    CursorClientType = CreateNewResourceType(CursorFreeClient,
                                             "XFixesCursorClient");
    CursorHideCountType = CreateNewResourceType(CursorFreeHideCount,
                                                "XFixesCursorHideCount");
    CursorWindowType = CreateNewResourceType(CursorFreeWindow,
                                             "XFixesCursorWindow");

    return CursorClientType && CursorHideCountType && CursorWindowType;
}
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a308 1
#ifdef ARGB_CURSOR
a311 1
#endif
d777 1
a777 2
    if (!AddResource(pChc->resource, CursorHideCountType, (void *) pChc)) {
        free(pChc);
a778 1
    }
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d635 1
a635 1
    /* 
d738 1
a738 1
 * This list indicates which clients have requested cursor hiding 
d775 1
a775 1
    /* 
d787 1
a787 1
/* 
d815 1
a815 1
/* 
d851 3
a853 3
    /* 
     * Has client hidden the cursor before on this screen? 
     * If so, just increment the count. 
d862 2
a863 2
    /* 
     * This is the first time this client has hid the cursor 
d915 1
a915 1
    /* 
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d75 1
a75 1
	err = dixLookupResourceByType((pointer *) &pCursor, cursor,	\
d198 1
a198 1
    pointer val;
d231 1
a231 1
                             (pointer) pWindow)) {
d236 1
a236 1
        if (!AddResource(e->clientResource, CursorClientType, (pointer) e))
d571 1
a571 1
typedef Bool (*TestCursorFunc) (CursorPtr pOld, pointer closure);
d577 1
a577 1
    pointer closure;
d587 1
a587 1
ReplaceCursorLookup(pointer value, XID id, pointer closure)
d629 1
a629 1
ReplaceCursor(CursorPtr pCursor, TestCursorFunc testCursor, pointer closure)
d655 1
a655 1
                                        ReplaceCursorLookup, (pointer) &rcl);
d663 1
a663 1
TestForCursor(CursorPtr pCursor, pointer closure)
d681 1
a681 1
    ReplaceCursor(pSource, TestForCursor, (pointer) pDestination);
d698 1
a698 1
TestForCursorName(CursorPtr pCursor, pointer closure)
d779 1
a779 1
    if (!AddResource(pChc->resource, CursorHideCountType, (pointer) pChc)) {
d844 1
a844 1
    ret = dixLookupResourceByType((pointer *) &pWin, stuff->window, RT_WINDOW,
d908 1
a908 1
    rc = dixLookupResourceByType((pointer *) &pWin, stuff->window, RT_WINDOW,
d949 1
a949 1
CursorFreeClient(pointer data, XID id)
d965 1
a965 1
CursorFreeHideCount(pointer data, XID id)
d981 1
a981 1
CursorFreeWindow(pointer data, XID id)
d1059 2
@


1.10
log
@Update to xserver 1.14.3
@
text
@d132 1
a132 2
static Bool CursorVisible = FALSE;

d144 1
a144 6
    /*
     * Have to check ConnectionInfo to distinguish client requests from
     * initial root window setup.  Not a great way to do it, I admit.
     */
    if (ConnectionInfo)
        CursorVisible = EnableCursor;
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d622 1
a622 1
            rcl->pNew->refcnt++;
d625 1
a625 1
                *pCursorRef = rcl->pNew;
d627 1
a627 1
                ChangeResourceValue(id, RT_CURSOR, rcl->pNew);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d59 1
a63 1
RESTYPE PointerBarrierType;
a114 8
typedef struct PointerBarrierClient *PointerBarrierClientPtr;

struct PointerBarrierClient {
    ScreenPtr screen;
    struct PointerBarrier barrier;
    struct xorg_list entry;
};

a121 1
    ConstrainCursorHarderProcPtr ConstrainCursorHarder;
a122 1
    struct xorg_list barriers;
d165 8
a172 8
                xXFixesCursorNotifyEvent ev;

                ev.type = XFixesEventBase + XFixesCursorNotify;
                ev.subtype = XFixesDisplayCursorNotify;
                ev.window = e->pWindow->drawable.id;
                ev.cursorSerial = pCursor ? pCursor->serialNumber : 0;
                ev.timestamp = currentTime.milliseconds;
                ev.name = pCursor ? pCursor->name : None;
d183 1
a183 1
CursorCloseScreen(int index, ScreenPtr pScreen)
a188 1
    ConstrainCursorHarderProcPtr constrain_proc;
a191 1
    Unwrap(cs, pScreen, ConstrainCursorHarder, constrain_proc);
d193 1
a193 1
    ret = (*pScreen->CloseScreen) (index, pScreen);
d371 2
a372 1
    rep = malloc(sizeof(xXFixesGetCursorImageReply) + npixels * sizeof(CARD32));
d401 2
a402 2
    WriteToClient(client, sizeof(xXFixesGetCursorImageReply) +
                  (npixels << 2), (char *) rep);
d465 7
a471 5
    reply.type = X_Reply;
    reply.length = bytes_to_int32(len);
    reply.sequenceNumber = client->sequence;
    reply.atom = pCursor->name;
    reply.nbytes = len;
d523 2
a524 2
    rep = malloc(sizeof(xXFixesGetCursorImageAndNameReply) +
                 npixels * sizeof(CARD32) + nbytesRound);
d559 1
a559 1
                  (npixels << 2) + nbytesRound, (char *) rep);
a1000 259
static BOOL
barrier_is_horizontal(const struct PointerBarrier *barrier)
{
    return barrier->y1 == barrier->y2;
}

static BOOL
barrier_is_vertical(const struct PointerBarrier *barrier)
{
    return barrier->x1 == barrier->x2;
}

/**
 * @@return The set of barrier movement directions the movement vector
 * x1/y1 → x2/y2 represents.
 */
int
barrier_get_direction(int x1, int y1, int x2, int y2)
{
    int direction = 0;

    /* which way are we trying to go */
    if (x2 > x1)
        direction |= BarrierPositiveX;
    if (x2 < x1)
        direction |= BarrierNegativeX;
    if (y2 > y1)
        direction |= BarrierPositiveY;
    if (y2 < y1)
        direction |= BarrierNegativeY;

    return direction;
}

/**
 * Test if the barrier may block movement in the direction defined by
 * x1/y1 → x2/y2. This function only tests whether the directions could be
 * blocked, it does not test if the barrier actually blocks the movement.
 *
 * @@return TRUE if the barrier blocks the direction of movement or FALSE
 * otherwise.
 */
BOOL
barrier_is_blocking_direction(const struct PointerBarrier * barrier,
                              int direction)
{
    /* Barriers define which way is ok, not which way is blocking */
    return (barrier->directions & direction) != direction;
}

/**
 * Test if the movement vector x1/y1 → x2/y2 is intersecting with the
 * barrier. A movement vector with the startpoint or endpoint adjacent to
 * the barrier itself counts as intersecting.
 *
 * @@param x1 X start coordinate of movement vector
 * @@param y1 Y start coordinate of movement vector
 * @@param x2 X end coordinate of movement vector
 * @@param y2 Y end coordinate of movement vector
 * @@param[out] distance The distance between the start point and the
 * intersection with the barrier (if applicable).
 * @@return TRUE if the barrier intersects with the given vector
 */
BOOL
barrier_is_blocking(const struct PointerBarrier * barrier,
                    int x1, int y1, int x2, int y2, double *distance)
{
    BOOL rc = FALSE;
    float ua, ub, ud;
    int dir = barrier_get_direction(x1, y1, x2, y2);

    /* Algorithm below doesn't handle edge cases well, hence the extra
     * checks. */
    if (barrier_is_vertical(barrier)) {
        /* handle immediate barrier adjacency, moving away */
        if (dir & BarrierPositiveX && x1 == barrier->x1)
            return FALSE;
        if (dir & BarrierNegativeX && x1 == (barrier->x1 - 1))
            return FALSE;
        /* startpoint adjacent to barrier, moving towards -> block */
        if (x1 == barrier->x1 && y1 >= barrier->y1 && y1 <= barrier->y2) {
            *distance = 0;
            return TRUE;
        }
    }
    else {
        /* handle immediate barrier adjacency, moving away */
        if (dir & BarrierPositiveY && y1 == barrier->y1)
            return FALSE;
        if (dir & BarrierNegativeY && y1 == (barrier->y1 - 1))
            return FALSE;
        /* startpoint adjacent to barrier, moving towards -> block */
        if (y1 == barrier->y1 && x1 >= barrier->x1 && x1 <= barrier->x2) {
            *distance = 0;
            return TRUE;
        }
    }

    /* not an edge case, compute distance */
    ua = 0;
    ud = (barrier->y2 - barrier->y1) * (x2 - x1) - (barrier->x2 -
                                                    barrier->x1) * (y2 - y1);
    if (ud != 0) {
        ua = ((barrier->x2 - barrier->x1) * (y1 - barrier->y1) -
              (barrier->y2 - barrier->y1) * (x1 - barrier->x1)) / ud;
        ub = ((x2 - x1) * (y1 - barrier->y1) -
              (y2 - y1) * (x1 - barrier->x1)) / ud;
        if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
            ua = 0;
    }

    if (ua > 0 && ua <= 1) {
        double ix = barrier->x1 + ua * (barrier->x2 - barrier->x1);
        double iy = barrier->y1 + ua * (barrier->y2 - barrier->y1);

        *distance = sqrt(pow(x1 - ix, 2) + pow(y1 - iy, 2));
        rc = TRUE;
    }

    return rc;
}

/**
 * Find the nearest barrier that is blocking movement from x1/y1 to x2/y2.
 *
 * @@param dir Only barriers blocking movement in direction dir are checked
 * @@param x1 X start coordinate of movement vector
 * @@param y1 Y start coordinate of movement vector
 * @@param x2 X end coordinate of movement vector
 * @@param y2 Y end coordinate of movement vector
 * @@return The barrier nearest to the movement origin that blocks this movement.
 */
static struct PointerBarrier *
barrier_find_nearest(CursorScreenPtr cs, int dir,
                     int x1, int y1, int x2, int y2)
{
    struct PointerBarrierClient *c;
    struct PointerBarrier *nearest = NULL;
    double min_distance = INT_MAX;      /* can't get higher than that in X anyway */

    xorg_list_for_each_entry(c, &cs->barriers, entry) {
        struct PointerBarrier *b = &c->barrier;
        double distance;

        if (!barrier_is_blocking_direction(b, dir))
            continue;

        if (barrier_is_blocking(b, x1, y1, x2, y2, &distance)) {
            if (min_distance > distance) {
                min_distance = distance;
                nearest = b;
            }
        }
    }

    return nearest;
}

/**
 * Clamp to the given barrier given the movement direction specified in dir.
 *
 * @@param barrier The barrier to clamp to
 * @@param dir The movement direction
 * @@param[out] x The clamped x coordinate.
 * @@param[out] y The clamped x coordinate.
 */
void
barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x,
                         int *y)
{
    if (barrier_is_vertical(barrier)) {
        if ((dir & BarrierNegativeX) & ~barrier->directions)
            *x = barrier->x1;
        if ((dir & BarrierPositiveX) & ~barrier->directions)
            *x = barrier->x1 - 1;
    }
    if (barrier_is_horizontal(barrier)) {
        if ((dir & BarrierNegativeY) & ~barrier->directions)
            *y = barrier->y1;
        if ((dir & BarrierPositiveY) & ~barrier->directions)
            *y = barrier->y1 - 1;
    }
}

static void
CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode,
                            int *x, int *y)
{
    CursorScreenPtr cs = GetCursorScreen(screen);

    if (!xorg_list_is_empty(&cs->barriers) && !IsFloating(dev) &&
        mode == Relative) {
        int ox, oy;
        int dir;
        struct PointerBarrier *nearest = NULL;

        /* where are we coming from */
        miPointerGetPosition(dev, &ox, &oy);

        /* How this works:
         * Given the origin and the movement vector, get the nearest barrier
         * to the origin that is blocking the movement.
         * Clamp to that barrier.
         * Then, check from the clamped intersection to the original
         * destination, again finding the nearest barrier and clamping.
         */
        dir = barrier_get_direction(ox, oy, *x, *y);

        nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
        if (nearest) {
            barrier_clamp_to_barrier(nearest, dir, x, y);

            if (barrier_is_vertical(nearest)) {
                dir &= ~(BarrierNegativeX | BarrierPositiveX);
                ox = *x;
            }
            else if (barrier_is_horizontal(nearest)) {
                dir &= ~(BarrierNegativeY | BarrierPositiveY);
                oy = *y;
            }

            nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
            if (nearest) {
                barrier_clamp_to_barrier(nearest, dir, x, y);
            }
        }
    }

    if (cs->ConstrainCursorHarder) {
        screen->ConstrainCursorHarder = cs->ConstrainCursorHarder;
        screen->ConstrainCursorHarder(dev, screen, mode, x, y);
        screen->ConstrainCursorHarder = CursorConstrainCursorHarder;
    }
}

static struct PointerBarrierClient *
CreatePointerBarrierClient(ScreenPtr screen, ClientPtr client,
                           xXFixesCreatePointerBarrierReq * stuff)
{
    CursorScreenPtr cs = GetCursorScreen(screen);
    struct PointerBarrierClient *ret = malloc(sizeof(*ret));

    if (ret) {
        ret->screen = screen;
        ret->barrier.x1 = min(stuff->x1, stuff->x2);
        ret->barrier.x2 = max(stuff->x1, stuff->x2);
        ret->barrier.y1 = min(stuff->y1, stuff->y2);
        ret->barrier.y2 = max(stuff->y1, stuff->y2);
        ret->barrier.directions = stuff->directions & 0x0f;
        if (barrier_is_horizontal(&ret->barrier))
            ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
        if (barrier_is_vertical(&ret->barrier))
            ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
        xorg_list_add(&ret->entry, &cs->barriers);
    }

    return ret;
}

a1003 5
    int err;
    WindowPtr pWin;
    struct PointerBarrierClient *barrier;
    struct PointerBarrier b;

d1006 1
a1006 1
    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
d1009 1
a1009 30
    err = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (err != Success) {
        client->errorValue = stuff->window;
        return err;
    }

    /* This sure does need fixing. */
    if (stuff->num_devices)
        return BadImplementation;

    b.x1 = stuff->x1;
    b.x2 = stuff->x2;
    b.y1 = stuff->y1;
    b.y2 = stuff->y2;

    if (!barrier_is_horizontal(&b) && !barrier_is_vertical(&b))
        return BadValue;

    /* no 0-sized barriers */
    if (barrier_is_horizontal(&b) && barrier_is_vertical(&b))
        return BadValue;

    if (!(barrier = CreatePointerBarrierClient(pWin->drawable.pScreen,
                                               client, stuff)))
        return BadAlloc;

    if (!AddResource(stuff->barrier, PointerBarrierType, &barrier->barrier))
        return BadAlloc;

    return Success;
d1016 2
d1020 3
a1022 1
    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
d1030 2
a1031 21
    return ProcXFixesVector[stuff->xfixesReqType] (client);
}

static int
CursorFreeBarrier(void *data, XID id)
{
    struct PointerBarrierClient *b = NULL, *barrier;
    ScreenPtr screen;
    CursorScreenPtr cs;

    barrier = container_of(data, struct PointerBarrierClient, barrier);

    screen = barrier->screen;
    cs = GetCursorScreen(screen);

    /* find and unlink from the screen private */
    xorg_list_for_each_entry(b, &cs->barriers, entry) {
        if (b == barrier) {
            xorg_list_del(&b->entry);
            break;
        }
d1034 1
a1034 2
    free(barrier);
    return Success;
a1039 3
    int err;
    void *barrier;

d1044 1
a1044 9
    err = dixLookupResourceByType((void **) &barrier, stuff->barrier,
                                  PointerBarrierType, client, DixDestroyAccess);
    if (err != Success) {
        client->errorValue = stuff->barrier;
        return err;
    }

    FreeResource(stuff->barrier, RT_NONE);
    return Success;
a1075 1
        xorg_list_init(&cs->barriers);
a1077 1
        Wrap(cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
a1086 2
    PointerBarrierType = CreateNewResourceType(CursorFreeBarrier,
                                               "XFixesPointerBarrier");
d1088 1
a1088 2
    return CursorClientType && CursorHideCountType && CursorWindowType &&
        PointerBarrierType;
@


1.7
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@d60 5
a64 5
static RESTYPE		CursorClientType;
static RESTYPE		CursorHideCountType;
static RESTYPE		CursorWindowType;
RESTYPE			PointerBarrierType;
static CursorPtr	CursorCurrent[MAXDEVICES];
d67 1
d70 1
a70 1
static void deleteCursorHideCountsForScreen (ScreenPtr pScreen);
d90 5
a94 5
    CursorEventPtr	next;
    CARD32		eventMask;
    ClientPtr		pClient;
    WindowPtr		pWindow;
    XID			clientResource;
d97 1
a97 1
static CursorEventPtr	    cursorEvents;
d108 5
a112 5
    CursorHideCountPtr   pNext;  
    ClientPtr            pClient;
    ScreenPtr            pScreen;
    int                  hideCount;
    XID			 resource;
d120 1
a120 1
    struct list entry;
d128 2
a129 2
    DisplayCursorProcPtr	DisplayCursor;
    CloseScreenProcPtr		CloseScreen;
d131 2
a132 2
    CursorHideCountPtr          pCursorHideCounts;
    struct list                 barriers;
d147 1
a147 3
CursorDisplayCursor (DeviceIntPtr pDev,
                     ScreenPtr pScreen,
		     CursorPtr pCursor)
d149 2
a150 2
    CursorScreenPtr	cs = GetCursorScreen(pScreen);
    Bool		ret;
d153 1
a153 1
    Unwrap (cs, pScreen, DisplayCursor, backupProc);
d160 1
a160 1
	CursorVisible = EnableCursor;
d163 4
a166 3
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, NullCursor);
    } else {
	ret = (*pScreen->DisplayCursor) (pDev, pScreen, pCursor);
d169 2
a170 3
    if (pCursor != CursorCurrent[pDev->id])
    {
	CursorEventPtr	e;
d172 14
a185 15
	CursorCurrent[pDev->id] = pCursor;
	for (e = cursorEvents; e; e = e->next)
	{
	    if ((e->eventMask & XFixesDisplayCursorNotifyMask))
	    {
		xXFixesCursorNotifyEvent	ev;
		ev.type = XFixesEventBase + XFixesCursorNotify;
		ev.subtype = XFixesDisplayCursorNotify;
		ev.window = e->pWindow->drawable.id;
		ev.cursorSerial = pCursor ? pCursor->serialNumber : 0;
		ev.timestamp = currentTime.milliseconds;
		ev.name = pCursor ? pCursor->name : None;
		WriteEventsToClient (e->pClient, 1, (xEvent *) &ev);
	    }
	}
d187 1
a187 1
    Wrap (cs, pScreen, DisplayCursor, backupProc);
d193 1
a193 1
CursorCloseScreen (int index, ScreenPtr pScreen)
d195 4
a198 4
    CursorScreenPtr	cs = GetCursorScreen (pScreen);
    Bool		ret;
    _X_UNUSED CloseScreenProcPtr	close_proc;
    _X_UNUSED DisplayCursorProcPtr	display_proc;
d201 3
a203 3
    Unwrap (cs, pScreen, CloseScreen, close_proc);
    Unwrap (cs, pScreen, DisplayCursor, display_proc);
    Unwrap (cs, pScreen, ConstrainCursorHarder, constrain_proc);
d213 1
a213 3
XFixesSelectCursorInput (ClientPtr	pClient,
			 WindowPtr	pWindow,
			 CARD32		eventMask)
d215 1
a215 1
    CursorEventPtr	*prev, e;
d219 4
a222 7
    for (prev = &cursorEvents; (e = *prev); prev = &e->next)
    {
	if (e->pClient == pClient &&
	    e->pWindow == pWindow)
	{
	    break;
	}
d224 5
a228 7
    if (!eventMask)
    {
	if (e)
	{
	    FreeResource (e->clientResource, 0);
	}
	return Success;
d230 23
a252 25
    if (!e)
    {
	e = (CursorEventPtr) malloc(sizeof (CursorEventRec));
	if (!e)
	    return BadAlloc;

	e->next = 0;
	e->pClient = pClient;
	e->pWindow = pWindow;
	e->clientResource = FakeClientID(pClient->index);

	/*
	 * Add a resource hanging from the window to
	 * catch window destroy
	 */
	rc = dixLookupResourceByType( &val, pWindow->drawable.id,
				      CursorWindowType, serverClient,
				      DixGetAttrAccess);
	if (rc != Success)
	    if (!AddResource (pWindow->drawable.id, CursorWindowType,
			      (pointer) pWindow))
	    {
		free(e);
		return BadAlloc;
	    }
d254 2
a255 2
	if (!AddResource (e->clientResource, CursorClientType, (pointer) e))
	    return BadAlloc;
d257 1
a257 1
	*prev = e;
d264 1
a264 1
ProcXFixesSelectCursorInput (ClientPtr client)
d266 3
a268 3
    REQUEST (xXFixesSelectCursorInputReq);
    WindowPtr	pWin;
    int		rc;
d270 1
a270 1
    REQUEST_SIZE_MATCH (xXFixesSelectCursorInputReq);
d274 3
a276 4
    if (stuff->eventMask & ~CursorAllEvents)
    {
	client->errorValue = stuff->eventMask;
	return BadValue;
d278 1
a278 1
    return XFixesSelectCursorInput (client, pWin, stuff->eventMask);
d282 1
a282 1
GetBit (unsigned char *line, int x)
d284 2
a285 2
    unsigned char   mask;
    
d287 1
a287 1
	mask = (1 << (x & 7));
d289 1
a289 1
	mask = (0x80 >> (x & 7));
d293 1
a293 1
	return 1;
d298 1
a298 1
SProcXFixesSelectCursorInput (ClientPtr client)
a299 1
    register int n;
d302 3
a304 3
    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    swapl(&stuff->eventMask, n);
d307 1
a307 1
    
d309 2
a310 2
SXFixesCursorNotifyEvent (xXFixesCursorNotifyEvent *from,
			  xXFixesCursorNotifyEvent *to)
d313 5
a317 5
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->window, to->window);
    cpswapl (from->cursorSerial, to->cursorSerial);
    cpswapl (from->timestamp, to->timestamp);
    cpswapl (from->name, to->name);
d321 1
a321 1
CopyCursorToImage (CursorPtr pCursor, CARD32 *image)
d326 1
a326 1
    
d329 1
a329 1
	memcpy (image, pCursor->bits->argb, npixels * sizeof (CARD32));
d333 26
a358 31
	unsigned char	*srcLine = pCursor->bits->source;
	unsigned char	*mskLine = pCursor->bits->mask;
	int		stride = BitmapBytePad (width);
	int		x, y;
	CARD32		fg, bg;
	
	fg = (0xff000000 | 
	      ((pCursor->foreRed & 0xff00) << 8) |
	      (pCursor->foreGreen & 0xff00) |
	      (pCursor->foreBlue >> 8));
	bg = (0xff000000 | 
	      ((pCursor->backRed & 0xff00) << 8) |
	      (pCursor->backGreen & 0xff00) |
	      (pCursor->backBlue >> 8));
	for (y = 0; y < height; y++)
	{
	    for (x = 0; x < width; x++)
	    {
		if (GetBit (mskLine, x))
		{
		    if (GetBit (srcLine, x))
			*image++ = fg;
		    else
			*image++ = bg;
		}
		else
		    *image++ = 0;
	    }
	    srcLine += stride;
	    mskLine += stride;
	}
d363 1
a363 1
ProcXFixesGetCursorImage (ClientPtr client)
d366 4
a369 4
    xXFixesGetCursorImageReply	*rep;
    CursorPtr			pCursor;
    CARD32			*image;
    int				npixels, width, height, rc, x, y;
d374 1
a374 1
	return BadCursor;
d376 1
a376 1
		  pCursor, RT_NONE, NULL, DixReadAccess);
d378 2
a379 2
	return rc;
    GetSpritePosition (PickPointer(client), &x, &y);
d383 1
a383 2
    rep = malloc(sizeof (xXFixesGetCursorImageReply) +
		  npixels * sizeof (CARD32));
d385 1
a385 1
	return BadAlloc;
d395 1
a395 1
    rep->yhot = pCursor->bits->yhot; 
d399 12
a410 14
    CopyCursorToImage (pCursor, image);
    if (client->swapped)
    {
	int n;
	swaps (&rep->sequenceNumber, n);
	swapl (&rep->length, n);
	swaps (&rep->x, n);
	swaps (&rep->y, n);
	swaps (&rep->width, n);
	swaps (&rep->height, n);
	swaps (&rep->xhot, n);
	swaps (&rep->yhot, n);
	swapl (&rep->cursorSerial, n);
	SwapLongs (image, npixels);
d412 2
a413 2
    WriteToClient(client, sizeof (xXFixesGetCursorImageReply) +
			 (npixels << 2), (char *) rep);
d419 1
a419 1
SProcXFixesGetCursorImage (ClientPtr client)
a420 1
    int n;
d422 1
a422 1
    swaps (&stuff->length, n);
d427 1
a427 1
ProcXFixesSetCursorName (ClientPtr client)
d431 1
d438 1
a438 1
    atom = MakeAtom (tchar, stuff->nbytes, TRUE);
d440 2
a441 2
	return BadAlloc;
    
d447 1
a447 1
SProcXFixesSetCursorName (ClientPtr client)
a448 1
    int n;
d451 1
a451 1
    swaps (&stuff->length, n);
d453 2
a454 2
    swapl (&stuff->cursor, n);
    swaps (&stuff->nbytes, n);
d459 1
a459 1
ProcXFixesGetCursorName (ClientPtr client)
d461 3
a463 2
    CursorPtr			pCursor;
    xXFixesGetCursorNameReply	reply;
d471 1
a471 1
	str = NameForAtom (pCursor->name);
d473 3
a475 3
	str = "";
    len = strlen (str);
    
d481 5
a485 7
    if (client->swapped)
    {
	int n;
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swapl (&reply.atom, n);
	swaps (&reply.nbytes, n);
d489 1
a489 1
    
d494 1
a494 1
SProcXFixesGetCursorName (ClientPtr client)
a495 1
    int n;
d498 1
a498 1
    swaps (&stuff->length, n);
d500 1
a500 1
    swapl (&stuff->cursor, n);
d505 1
a505 1
ProcXFixesGetCursorImageAndName (ClientPtr client)
d508 8
a515 8
    xXFixesGetCursorImageAndNameReply	*rep;
    CursorPtr			pCursor;
    CARD32			*image;
    int				npixels;
    const char			*name;
    int				nbytes, nbytesRound;
    int				width, height;
    int				rc, x, y;
d520 1
a520 1
	return BadCursor;
d522 1
a522 1
		  pCursor, RT_NONE, NULL, DixReadAccess|DixGetAttrAccess);
d524 2
a525 2
	return rc;
    GetSpritePosition (PickPointer(client), &x, &y);
d529 2
a530 2
    name = pCursor->name ? NameForAtom (pCursor->name) : "";
    nbytes = strlen (name);
d532 2
a533 2
    rep = malloc(sizeof (xXFixesGetCursorImageAndNameReply) +
		  npixels * sizeof (CARD32) + nbytesRound);
d535 1
a535 1
	return BadAlloc;
d545 1
a545 1
    rep->yhot = pCursor->bits->yhot; 
d551 15
a565 17
    CopyCursorToImage (pCursor, image);
    memcpy ((image + npixels), name, nbytes);
    if (client->swapped)
    {
	int n;
	swaps (&rep->sequenceNumber, n);
	swapl (&rep->length, n);
	swaps (&rep->x, n);
	swaps (&rep->y, n);
	swaps (&rep->width, n);
	swaps (&rep->height, n);
	swaps (&rep->xhot, n);
	swaps (&rep->yhot, n);
	swapl (&rep->cursorSerial, n);
	swapl (&rep->cursorName, n);
	swaps (&rep->nbytes, n);
	SwapLongs (image, npixels);
d567 2
a568 2
    WriteToClient(client, sizeof (xXFixesGetCursorImageAndNameReply) +
			 (npixels << 2) + nbytesRound, (char *) rep);
d574 1
a574 1
SProcXFixesGetCursorImageAndName (ClientPtr client)
a575 1
    int n;
d577 1
a577 1
    swaps (&stuff->length, n);
d595 1
a595 1
static const RESTYPE    CursorRestypes[] = {
d602 1
a602 1
ReplaceCursorLookup (pointer value, XID id, pointer closure)
d604 5
a608 5
    ReplaceCursorLookupPtr  rcl = (ReplaceCursorLookupPtr) closure;
    WindowPtr		    pWin;
    GrabPtr		    pGrab;
    CursorPtr		    pCursor = 0, *pCursorRef = 0;
    XID			    cursor = 0;
d612 6
a617 7
	pWin = (WindowPtr) value;
	if (pWin->optional)
	{
	    pCursorRef = &pWin->optional->cursor;
	    pCursor = *pCursorRef;
	}
	break;
d619 4
a622 4
	pGrab = (GrabPtr) value;
	pCursorRef = &pGrab->cursor;
	pCursor = *pCursorRef;
	break;
d624 15
a638 4
	pCursorRef = 0;
	pCursor = (CursorPtr) value;
	cursor = id;
	break;
d640 1
a640 14
    if (pCursor && pCursor != rcl->pNew)
    {
	if ((*rcl->testCursor) (pCursor, rcl->closure))
	{
	    rcl->pNew->refcnt++;
	    /* either redirect reference or update resource database */
	    if (pCursorRef)
		*pCursorRef = rcl->pNew;
	    else
		ChangeResourceValue (id, RT_CURSOR, rcl->pNew);
	    FreeCursor (pCursor, cursor);
	}
    }
    return FALSE;   /* keep walking */
d644 1
a644 3
ReplaceCursor (CursorPtr pCursor,
	       TestCursorFunc testCursor,
	       pointer closure)
d646 1
a646 1
    int	clientIndex;
d648 2
a649 2
    ReplaceCursorLookupRec  rcl;
    
d660 12
a671 15
    for (clientIndex = 0; clientIndex < currentMaxClients; clientIndex++)
    {
	if (!clients[clientIndex])
	    continue;
	for (resIndex = 0; resIndex < NUM_CURSOR_RESTYPES; resIndex++)
	{
	    rcl.type = CursorRestypes[resIndex];
	    /*
	     * This function walks the entire client resource database
	     */
	    LookupClientResourceComplex (clients[clientIndex], 
					 rcl.type, 
					 ReplaceCursorLookup,
					 (pointer) &rcl);
	}
d674 1
a674 1
    WindowHasNewCursor (screenInfo.screens[0]->root);
d677 2
a678 2
static Bool 
TestForCursor (CursorPtr pCursor, pointer closure)
d684 1
a684 1
ProcXFixesChangeCursor (ClientPtr client)
d686 2
a687 1
    CursorPtr	pSource, pDestination;
d691 4
a694 4
    VERIFY_CURSOR (pSource, stuff->source, client,
		   DixReadAccess|DixGetAttrAccess);
    VERIFY_CURSOR (pDestination, stuff->destination, client,
		   DixWriteAccess|DixSetAttrAccess);
d696 1
a696 1
    ReplaceCursor (pSource, TestForCursor, (pointer) pDestination);
d701 1
a701 1
SProcXFixesChangeCursor (ClientPtr client)
a702 1
    int n;
d705 1
a705 1
    swaps (&stuff->length, n);
d707 2
a708 2
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
d713 1
a713 1
TestForCursorName (CursorPtr pCursor, pointer closure)
d716 1
d721 1
a721 1
ProcXFixesChangeCursorByName (ClientPtr client)
d723 4
a726 3
    CursorPtr	pSource;
    Atom	name;
    char	*tchar;
d731 1
a731 1
		  DixReadAccess|DixGetAttrAccess);
d733 1
a733 1
    name = MakeAtom (tchar, stuff->nbytes, FALSE);
d735 1
a735 1
	ReplaceCursor (pSource, TestForCursorName, &name);
d740 1
a740 1
SProcXFixesChangeCursorByName (ClientPtr client)
a741 1
    int n;
d744 4
a747 4
    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE (xXFixesChangeCursorByNameReq);
    swapl (&stuff->source, n);
    swaps (&stuff->nbytes, n);
d759 1
a759 1
findCursorHideCount (ClientPtr pClient, ScreenPtr pScreen) 
d761 1
a761 1
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
d765 3
a767 3
	if (pChc->pClient == pClient) {
	    return pChc;
	}
d770 1
a770 1
    return NULL;           
d774 1
a774 1
createCursorHideCount (ClientPtr pClient, ScreenPtr pScreen)
d776 1
a776 1
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
d781 1
a781 1
	return BadAlloc;
d789 1
a789 1
    
d794 3
a796 4
    if (!AddResource (pChc->resource, CursorHideCountType, 
		      (pointer) pChc)) {
	free(pChc);
	return BadAlloc;
d806 1
a806 1
deleteCursorHideCount (CursorHideCountPtr pChcToDel, ScreenPtr pScreen)
d808 1
a808 1
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
d814 13
a826 12
	pNext = pChc->pNext;
	if (pChc == pChcToDel) {
	    free(pChc);
	    if (pChcLast == NULL) {
		cs->pCursorHideCounts = pNext;
	    } else {
		pChcLast->pNext = pNext;
	    }
	    return;
	}
	pChcLast = pChc;
	pChc = pNext;
d834 1
a834 1
deleteCursorHideCountsForScreen (ScreenPtr pScreen)
d836 1
a836 1
    CursorScreenPtr    cs = GetCursorScreen(pScreen);
d841 3
a843 3
	pTmp = pChc->pNext;
	FreeResource(pChc->resource, 0);
	pChc = pTmp;
d845 1
a845 1
    cs->pCursorHideCounts = NULL;   
d848 2
a849 2
int 
ProcXFixesHideCursor (ClientPtr client) 
d853 1
d857 1
a857 1
    REQUEST_SIZE_MATCH (xXFixesHideCursorReq);
d859 2
a860 2
    ret = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			    client, DixGetAttrAccess);
d862 2
a863 2
	client->errorValue = stuff->window;
	return ret;
d873 2
a874 2
	pChc->hideCount++;
	return Success;
d882 1
a882 1
		   DixHideAccess);
d884 1
a884 1
	return ret;
d889 7
a895 6
	DeviceIntPtr dev;
	for (dev = inputInfo.devices; dev; dev = dev->next)
	{
	    if (IsMaster(dev) && IsPointerDevice(dev))
		CursorDisplayCursor(dev, pWin->drawable.pScreen, CursorCurrent[dev->id]);
	}
d901 2
a902 2
int 
SProcXFixesHideCursor (ClientPtr client) 
a903 1
    int n;
d906 3
a908 3
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesHideCursorReq);
    swapl (&stuff->window, n);
d912 2
a913 2
int 
ProcXFixesShowCursor (ClientPtr client) 
d918 1
d921 1
a921 1
    REQUEST_SIZE_MATCH (xXFixesShowCursorReq);
d923 2
a924 2
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			   client, DixGetAttrAccess);
d926 2
a927 2
	client->errorValue = stuff->window;
	return rc;
d936 1
a936 1
	return BadMatch;
d940 1
a940 1
		  DixShowAccess);
d942 1
a942 1
	return rc;
d946 1
a946 1
	FreeResource(pChc->resource, 0);
d952 2
a953 2
int 
SProcXFixesShowCursor (ClientPtr client) 
a954 1
    int n;
d957 3
a959 3
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesShowCursorReq);
    swapl (&stuff->window, n);
d964 1
a964 1
CursorFreeClient (pointer data, XID id)
d966 9
a974 11
    CursorEventPtr	old = (CursorEventPtr) data;
    CursorEventPtr	*prev, e;
    
    for (prev = &cursorEvents; (e = *prev); prev = &e->next)
    {
	if (e == old)
	{
	    *prev = e->next;
	    free(e);
	    break;
	}
d980 1
a980 1
CursorFreeHideCount (pointer data, XID id)
d987 1
a987 2
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
d996 1
a996 1
CursorFreeWindow (pointer data, XID id)
d998 2
a999 2
    WindowPtr		pWindow = (WindowPtr) data;
    CursorEventPtr	e, next;
d1001 5
a1005 7
    for (e = cursorEvents; e; e = next)
    {
	next = e->next;
	if (e->pWindow == pWindow)
	{
	    FreeResource (e->clientResource, 0);
	}
d1033 1
a1033 1
	direction |= BarrierPositiveX;
d1035 1
a1035 1
	direction |= BarrierNegativeX;
d1037 1
a1037 1
	direction |= BarrierPositiveY;
d1039 1
a1039 1
	direction |= BarrierNegativeY;
d1053 2
a1054 1
barrier_is_blocking_direction(const struct PointerBarrier *barrier, int direction)
d1074 2
a1075 3
barrier_is_blocking(const struct PointerBarrier *barrier,
		    int x1, int y1, int x2, int y2,
		    double *distance)
d1084 21
a1104 20
	/* handle immediate barrier adjacency, moving away */
	if (dir & BarrierPositiveX && x1 == barrier->x1)
	    return FALSE;
	if (dir & BarrierNegativeX && x1 == (barrier->x1 - 1))
	    return FALSE;
	/* startpoint adjacent to barrier, moving towards -> block */
	if (x1 == barrier->x1 && y1 >= barrier->y1 && y1 <= barrier->y2) {
	    *distance = 0;
	    return TRUE;
	}
    } else {
	/* handle immediate barrier adjacency, moving away */
	if (dir & BarrierPositiveY && y1 == barrier->y1)
	    return FALSE;
	if (dir & BarrierNegativeY && y1 == (barrier->y1 - 1))
	    return FALSE;
	/* startpoint adjacent to barrier, moving towards -> block */
	if (y1 == barrier->y1 && x1 >= barrier->x1 && x1 <= barrier->x2) {
	    *distance = 0;
	    return TRUE;
d1110 2
a1111 1
    ud = (barrier->y2 - barrier->y1) * (x2 - x1) - (barrier->x2 - barrier->x1) * (y2 - y1);
d1113 6
a1118 6
	ua = ((barrier->x2 - barrier->x1) * (y1 - barrier->y1) -
	     (barrier->y2 - barrier->y1) * (x1 - barrier->x1)) / ud;
	ub = ((x2 - x1) * (y1 - barrier->y1) -
	     (y2 - y1) * (x1 - barrier->x1)) / ud;
	if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
	    ua = 0;
d1121 3
a1123 4
    if (ua > 0 && ua <= 1)
    {
	double ix = barrier->x1 + ua * (barrier->x2 - barrier->x1);
	double iy = barrier->y1 + ua * (barrier->y2 - barrier->y1);
d1125 2
a1126 2
	*distance = sqrt(pow(x1 - ix, 2) + pow(y1 - iy, 2));
	rc = TRUE;
d1142 1
a1142 1
static struct PointerBarrier*
d1144 1
a1144 1
		     int x1, int y1, int x2, int y2)
d1148 1
a1148 1
    double min_distance = INT_MAX; /* can't get higher than that in X anyway */
d1150 13
a1162 15
    list_for_each_entry(c, &cs->barriers, entry) {
	struct PointerBarrier *b = &c->barrier;
	double distance;

	if (!barrier_is_blocking_direction(b, dir))
	    continue;

	if (barrier_is_blocking(b, x1, y1, x2, y2, &distance))
	{
	    if (min_distance > distance)
	    {
		min_distance = distance;
		nearest = b;
	    }
	}
d1177 2
a1178 1
barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x, int *y)
d1180 11
a1190 13
    if (barrier_is_vertical(barrier))
    {
	if ((dir & BarrierNegativeX) & ~barrier->directions)
	    *x = barrier->x1;
	if ((dir & BarrierPositiveX) & ~barrier->directions)
	    *x = barrier->x1 - 1;
    }
    if (barrier_is_horizontal(barrier))
    {
	if ((dir & BarrierNegativeY) & ~barrier->directions)
	    *y = barrier->y1;
	if ((dir & BarrierPositiveY) & ~barrier->directions)
	    *y = barrier->y1 - 1;
d1195 2
a1196 1
CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode, int *x, int *y)
d1200 36
a1235 34
    if (!list_is_empty(&cs->barriers) && !IsFloating(dev) && mode == Relative) {
	int ox, oy;
	int dir;
	struct PointerBarrier *nearest = NULL;

	/* where are we coming from */
	miPointerGetPosition(dev, &ox, &oy);

	/* How this works:
	 * Given the origin and the movement vector, get the nearest barrier
	 * to the origin that is blocking the movement.
	 * Clamp to that barrier.
	 * Then, check from the clamped intersection to the original
	 * destination, again finding the nearest barrier and clamping.
	 */
	dir = barrier_get_direction(ox, oy, *x, *y);

	nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
	if (nearest) {
	    barrier_clamp_to_barrier(nearest, dir, x, y);

	    if (barrier_is_vertical(nearest)) {
		dir &= ~(BarrierNegativeX | BarrierPositiveX);
		ox = *x;
	    } else if (barrier_is_horizontal(nearest)) {
		dir &= ~(BarrierNegativeY | BarrierPositiveY);
		oy = *y;
	    }

	    nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
	    if (nearest) {
		barrier_clamp_to_barrier(nearest, dir, x, y);
	    }
	}
d1239 3
a1241 3
	screen->ConstrainCursorHarder = cs->ConstrainCursorHarder;
	screen->ConstrainCursorHarder(dev, screen, mode, x, y);
	screen->ConstrainCursorHarder = CursorConstrainCursorHarder;
d1247 1
a1247 1
			   xXFixesCreatePointerBarrierReq *stuff)
d1253 11
a1263 11
	ret->screen = screen;
	ret->barrier.x1 = min(stuff->x1, stuff->x2);
	ret->barrier.x2 = max(stuff->x1, stuff->x2);
	ret->barrier.y1 = min(stuff->y1, stuff->y2);
	ret->barrier.y2 = max(stuff->y1, stuff->y2);
	ret->barrier.directions = stuff->directions & 0x0f;
	if (barrier_is_horizontal(&ret->barrier))
	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
	if (barrier_is_vertical(&ret->barrier))
	    ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
	list_add(&ret->entry, &cs->barriers);
d1270 1
a1270 1
ProcXFixesCreatePointerBarrier (ClientPtr client)
d1276 2
a1277 1
    REQUEST (xXFixesCreatePointerBarrierReq);
d1284 2
a1285 2
	client->errorValue = stuff->window;
	return err;
d1290 1
a1290 1
	return BadImplementation;
d1298 1
a1298 1
	return BadValue;
d1302 1
a1302 1
	return BadValue;
d1305 2
a1306 2
					       client, stuff)))
	return BadAlloc;
d1309 1
a1309 1
	return BadAlloc;
d1315 1
a1315 1
SProcXFixesCreatePointerBarrier (ClientPtr client)
a1316 1
    int n;
d1319 1
a1319 1
    swaps(&stuff->length, n);
d1321 8
a1328 8
    swapl(&stuff->barrier, n);
    swapl(&stuff->window, n);
    swaps(&stuff->x1, n);
    swaps(&stuff->y1, n);
    swaps(&stuff->x2, n);
    swaps(&stuff->y2, n);
    swapl(&stuff->directions, n);
    return ProcXFixesVector[stuff->xfixesReqType](client);
d1339 1
d1344 5
a1348 5
    list_for_each_entry(b, &cs->barriers, entry) {
	if (b == barrier) {
	    list_del(&b->entry);
	    break;
	}
d1356 1
a1356 1
ProcXFixesDestroyPointerBarrier (ClientPtr client)
d1360 2
a1361 1
    REQUEST (xXFixesDestroyPointerBarrierReq);
d1365 2
a1366 3
    err = dixLookupResourceByType((void **)&barrier, stuff->barrier,
				  PointerBarrierType, client,
				  DixDestroyAccess);
d1368 2
a1369 2
	client->errorValue = stuff->barrier;
	return err;
d1377 1
a1377 1
SProcXFixesDestroyPointerBarrier (ClientPtr client)
a1378 1
    int n;
d1381 1
a1381 1
    swaps(&stuff->length, n);
d1383 2
a1384 2
    swapl(&stuff->barrier, n);
    return ProcXFixesVector[stuff->xfixesReqType](client);
d1388 1
a1388 1
XFixesCursorInit (void)
d1390 1
a1390 1
    int	i;
d1393 2
a1394 2
	CursorVisible = EnableCursor;
    
d1396 1
a1396 1
	return FALSE;
d1398 13
a1410 14
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ScreenPtr	pScreen = screenInfo.screens[i];
	CursorScreenPtr	cs;

	cs = (CursorScreenPtr) calloc(1, sizeof (CursorScreenRec));
	if (!cs)
	    return FALSE;
	list_init(&cs->barriers);
	Wrap (cs, pScreen, CloseScreen, CursorCloseScreen);
	Wrap (cs, pScreen, DisplayCursor, CursorDisplayCursor);
	Wrap (cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
	cs->pCursorHideCounts = NULL;
	SetCursorScreen (pScreen, cs);
d1413 1
a1413 1
					     "XFixesCursorClient");
d1415 1
a1415 1
						"XFixesCursorHideCount");
d1417 1
a1417 1
					     "XFixesCursorWindow");
d1419 1
a1419 1
					      "XFixesPointerBarrier");
d1422 1
a1422 1
	   PointerBarrierType;
a1423 1

@


1.6
log
@Update to xserver 1.11.2
@
text
@d182 1
a182 1
		ev.cursorSerial = pCursor->serialNumber;
d184 1
a184 1
		ev.name = pCursor->name;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 2
a3 1
 * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
d54 1
d58 1
d63 1
d114 8
d129 1
d131 1
d199 3
a201 2
    CloseScreenProcPtr	close_proc;
    DisplayCursorProcPtr display_proc;
d205 1
d1048 376
d1440 1
a1440 1
	cs = (CursorScreenPtr) malloc(sizeof (CursorScreenRec));
d1443 1
d1446 1
d1456 2
d1459 2
a1460 1
    return CursorClientType && CursorHideCountType && CursorWindowType;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a60 1
static CursorPtr        pInvisibleCursor = NULL;
d62 2
a63 2
static int CursorScreenPrivateKeyIndex;
static DevPrivateKey CursorScreenPrivateKey = &CursorScreenPrivateKeyIndex;
d72 1
a72 4
	if (err == BadValue) {						\
	    client->errorValue = cursor;				\
	    return BadCursor;						\
	} else if (err != Success) {					\
d150 1
a150 2
        ret = ((*pScreen->RealizeCursor)(pDev, pScreen, pInvisibleCursor) &&
	       (*pScreen->DisplayCursor) (pDev, pScreen, pInvisibleCursor));
d162 1
a162 2
	    if ((e->eventMask & XFixesDisplayCursorNotifyMask) &&
		!e->pClient->clientGone)
a166 1
		ev.sequenceNumber = e->pClient->sequence;
d192 1
a192 1
    xfree (cs);
d225 1
a225 1
	e = (CursorEventPtr) xalloc (sizeof (CursorEventRec));
d245 1
a245 1
		xfree (e);
d272 1
a272 1
	return( BadValue );
d385 1
a385 1
    rep = xalloc (sizeof (xXFixesGetCursorImageReply) +
d419 2
a420 2
    xfree (rep);
    return client->noClientException;
d448 1
a448 1
    return(client->noClientException);
d497 1
a497 1
    return(client->noClientException);
d540 1
a540 1
    rep = xalloc (sizeof (xXFixesGetCursorImageAndNameReply) +
d579 2
a580 2
    xfree (rep);
    return client->noClientException;
d693 1
a693 1
    WindowHasNewCursor (WindowTable[0]);
d715 1
a715 1
    return (client->noClientException);
d735 1
a735 1
    return (pCursor->name == *pName);
d753 1
a753 1
    return (client->noClientException);
d797 1
a797 1
    pChc = (CursorHideCountPtr) xalloc(sizeof(CursorHideCountRec));
d814 1
a814 1
	xfree(pChc);
d835 1
a835 1
	    xfree(pChc);
d880 1
a880 1
	return (ret == BadValue) ? BadWindow : ret;
d891 1
a891 1
	return client->noClientException;
d943 1
a943 1
	return (rc == BadValue) ? BadWindow : rc;
d965 1
a965 1
    return (client->noClientException);
d991 1
a991 1
	    xfree (e);
a1031 31
static CursorPtr
createInvisibleCursor (void)
{
    CursorPtr pCursor;
    unsigned char *psrcbits, *pmaskbits;
    CursorMetricRec cm;

    psrcbits = (unsigned char *) xcalloc(4, 1);
    pmaskbits = (unsigned char *) xcalloc(4, 1);
    if (psrcbits == NULL || pmaskbits == NULL) {
	return NULL;
    }

    cm.width = 1;
    cm.height = 1;
    cm.xhot = 0;
    cm.yhot = 0;

    if (AllocARGBCursor(psrcbits, pmaskbits,
			NULL, &cm,
			0, 0, 0,
			0, 0, 0,
			&pCursor, serverClient, (XID)0) != Success)
	return NullCursor;

    if (!AddResource(FakeClientID(0), RT_CURSOR, (pointer) pCursor))
	return NullCursor;

    return pCursor;
}

d1040 3
d1048 1
a1048 1
	cs = (CursorScreenPtr) xalloc (sizeof (CursorScreenRec));
a1061 4

    pInvisibleCursor = createInvisibleCursor();
    if (pInvisibleCursor == NULL)
	return BadAlloc;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems
d4 10
a13 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Sun Microsystems not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Sun Microsystems makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d15 7
a21 7
 * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d60 1
a60 1
static CursorPtr	CursorCurrent;
d68 13
a80 8
#define VERIFY_CURSOR(pCursor, cursor, client, access) { \
    pCursor = (CursorPtr)SecurityLookupIDByType((client), (cursor), \
					RT_CURSOR, (access)); \
    if (!pCursor) { \
	(client)->errorValue = (cursor); \
	return BadCursor; \
    } \
}
d128 1
a128 1
#define Unwrap(as,s,elt)	((s)->elt = (as)->elt)
d133 2
d142 1
d144 1
a144 1
    Unwrap (cs, pScreen, DisplayCursor);
d151 1
a151 1
	CursorVisible = TRUE;
d160 1
a160 1
    if (pCursor != CursorCurrent)
d164 1
a164 1
	CursorCurrent = pCursor;
d182 2
a183 1
    Wrap (cs, pScreen, DisplayCursor, CursorDisplayCursor);
d192 2
d195 2
a196 2
    Unwrap (cs, pScreen, CloseScreen);
    Unwrap (cs, pScreen, DisplayCursor);
d211 2
d245 4
a248 1
	if (!LookupIDByType(pWindow->drawable.id, CursorWindowType))
d381 1
a381 1
    pCursor = CursorCurrent;
d424 1
a424 1
    (void) WriteToClient(client, sizeof (xXFixesGetCursorImageReply) +
d477 1
a477 1
    char *str;
d489 1
a489 1
    reply.length = (len + 3) >> 2;
d502 1
a502 1
    (void)WriteToClient(client, len, str);
d527 1
a527 1
    char			*name;
d533 1
a533 1
    pCursor = CursorCurrent;
d546 1
a546 1
    nbytesRound = (nbytes + 3) & ~3;
d554 1
a554 1
    rep->length = npixels + (nbytesRound >> 2);
d584 1
a584 1
    (void) WriteToClient(client, sizeof (xXFixesGetCursorImageAndNameReply) +
d913 6
a918 1
        (void) CursorDisplayCursor(PickPointer(client), pWin->drawable.pScreen, CursorCurrent);
d1010 1
d1013 5
a1017 1
    (void) CursorDisplayCursor(inputInfo.pointer, pScreen, CursorCurrent);
d1043 1
a1043 1
    static unsigned int *psrcbits, *pmaskbits;
a1044 1
    int rc;
d1046 2
a1047 2
    psrcbits = (unsigned int *) xalloc(4);
    pmaskbits = (unsigned int *) xalloc(4);
a1050 2
    *psrcbits = 0;
    *pmaskbits = 0;
d1057 9
a1065 7
    rc = AllocARGBCursor(
	        (unsigned char *)psrcbits,
		(unsigned char *)pmaskbits,
		NULL, &cm,
		0, 0, 0,
		0, 0, 0,
		&pCursor, serverClient, (XID)0);
d1076 1
a1076 1
	CursorVisible = TRUE;
d1091 10
a1100 10
    CursorClientType = CreateNewResourceType(CursorFreeClient);
    CursorHideCountType = CreateNewResourceType(CursorFreeHideCount);
    CursorWindowType = CreateNewResourceType(CursorFreeWindow);

    if (pInvisibleCursor == NULL) {
	pInvisibleCursor = createInvisibleCursor();
	if (pInvisibleCursor == NULL) {
	    return BadAlloc;
	}
    }
d1102 1
a1102 1
    return CursorClientType && CursorWindowType;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a58 1
static DevPrivateKey	CursorScreenPrivateKey = &CursorScreenPrivateKey;
d62 3
d75 1
a75 1
	
d124 3
d128 2
a129 1
CursorDisplayCursor (ScreenPtr pScreen,
d137 10
a146 2
    if (cs->pCursorHideCounts != NULL) {
	ret = (*pScreen->DisplayCursor) (pScreen, pInvisibleCursor);
d148 1
a148 1
	ret = (*pScreen->DisplayCursor) (pScreen, pCursor);
d371 1
a371 1
    GetSpritePosition (&x, &y);
d523 1
a523 1
    GetSpritePosition (&x, &y);
d866 1
a866 1
    ret = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW,
d896 1
a896 1
        (void) CursorDisplayCursor(pWin->drawable.pScreen, CursorCurrent);
d924 1
a924 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW,
d990 1
a990 1
    (void) CursorDisplayCursor(pScreen, CursorCurrent);
d1048 3
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d54 1
d59 1
a59 2
static int		CursorScreenPrivateIndex = -1;
static int		CursorGeneration;
d116 3
a118 3
#define GetCursorScreen(s)	((CursorScreenPtr) ((s)->devPrivates[CursorScreenPrivateIndex].ptr))
#define GetCursorScreenIfSet(s) ((CursorScreenPrivateIndex != -1) ? GetCursorScreen(s) : NULL)
#define SetCursorScreen(s,p)	((s)->devPrivates[CursorScreenPrivateIndex].ptr = (pointer) (p))
d144 2
a145 1
	    if (e->eventMask & XFixesDisplayCursorNotifyMask)
a173 2
    if (index == 0)
	CursorScreenPrivateIndex = -1;
d239 1
d242 3
a244 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d347 1
a347 3
    int				npixels;
    int				width, height;
    int				x, y;
d353 4
d417 1
a417 1
    VERIFY_CURSOR(pCursor, stuff->cursor, client, SecurityWriteAccess);
d450 1
a450 1
    VERIFY_CURSOR(pCursor, stuff->cursor, client, SecurityReadAccess);
d499 1
a499 1
    int				x, y;
d505 4
d685 4
a688 2
    VERIFY_CURSOR (pSource, stuff->source, client, SecurityReadAccess);
    VERIFY_CURSOR (pDestination, stuff->destination, client, SecurityWriteAccess);
d710 2
a711 1
    return (pCursor->name == (Atom) closure);
d723 2
a724 1
    VERIFY_CURSOR(pSource, stuff->source, client, SecurityReadAccess);
d728 1
a728 1
	ReplaceCursor (pSource, TestForCursorName, (pointer) name);
d852 3
a854 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin) {
d856 1
a856 1
	return BadWindow;
d874 5
d905 1
d910 3
a912 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin) {
d914 1
a914 1
	return BadWindow;
d926 5
d1004 1
d1019 1
a1019 1
    pCursor = AllocCursor(
d1022 2
a1023 1
		&cm,
d1025 1
a1025 1
		0, 0, 0);
a1034 7
    if (CursorGeneration != serverGeneration)
    {
	CursorScreenPrivateIndex = AllocateScreenPrivateIndex ();
	if (CursorScreenPrivateIndex < 0)
	    return FALSE;
	CursorGeneration = serverGeneration;
    }
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d146 1
a146 2
	    if ((e->eventMask & XFixesDisplayCursorNotifyMask) &&
		!e->pClient->clientGone)
a241 1
    int		rc;
d244 4
a247 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (rc != Success)
        return rc;
d418 1
a418 1
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixWriteAccess);
d451 1
a451 1
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixReadAccess);
d682 2
a683 2
    VERIFY_CURSOR (pSource, stuff->source, client, DixReadAccess);
    VERIFY_CURSOR (pDestination, stuff->destination, client, DixWriteAccess);
d717 1
a717 1
    VERIFY_CURSOR(pSource, stuff->source, client, DixReadAccess);
@

