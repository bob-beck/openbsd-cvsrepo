head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * Copyright 2010 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Copyright © 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "protocol-versions.h"
#include "extinit.h"

static unsigned char XFixesReqCode;
int XFixesEventBase;
int XFixesErrorBase;

static DevPrivateKeyRec XFixesClientPrivateKeyRec;

#define XFixesClientPrivateKey (&XFixesClientPrivateKeyRec)

static int
ProcXFixesQueryVersion(ClientPtr client)
{
    XFixesClientPtr pXFixesClient = GetXFixesClient(client);
    xXFixesQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    REQUEST(xXFixesQueryVersionReq);

    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);

    if (version_compare(stuff->majorVersion, stuff->minorVersion,
                        SERVER_XFIXES_MAJOR_VERSION,
                        SERVER_XFIXES_MINOR_VERSION) < 0) {
        rep.majorVersion = stuff->majorVersion;
        rep.minorVersion = stuff->minorVersion;
    }
    else {
        rep.majorVersion = SERVER_XFIXES_MAJOR_VERSION;
        rep.minorVersion = SERVER_XFIXES_MINOR_VERSION;
    }

    pXFixesClient->major_version = rep.majorVersion;
    pXFixesClient->minor_version = rep.minorVersion;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.majorVersion);
        swapl(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xXFixesQueryVersionReply), &rep);
    return Success;
}

/* Major version controls available requests */
static const int version_requests[] = {
    X_XFixesQueryVersion,       /* before client sends QueryVersion */
    X_XFixesGetCursorImage,     /* Version 1 */
    X_XFixesChangeCursorByName, /* Version 2 */
    X_XFixesExpandRegion,       /* Version 3 */
    X_XFixesShowCursor,         /* Version 4 */
    X_XFixesDestroyPointerBarrier,      /* Version 5 */
};

#define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))

int (*ProcXFixesVector[XFixesNumberRequests]) (ClientPtr) = {
/*************** Version 1 ******************/
    ProcXFixesQueryVersion,
        ProcXFixesChangeSaveSet,
        ProcXFixesSelectSelectionInput,
        ProcXFixesSelectCursorInput, ProcXFixesGetCursorImage,
/*************** Version 2 ******************/
        ProcXFixesCreateRegion,
        ProcXFixesCreateRegionFromBitmap,
        ProcXFixesCreateRegionFromWindow,
        ProcXFixesCreateRegionFromGC,
        ProcXFixesCreateRegionFromPicture,
        ProcXFixesDestroyRegion,
        ProcXFixesSetRegion,
        ProcXFixesCopyRegion,
        ProcXFixesCombineRegion,
        ProcXFixesCombineRegion,
        ProcXFixesCombineRegion,
        ProcXFixesInvertRegion,
        ProcXFixesTranslateRegion,
        ProcXFixesRegionExtents,
        ProcXFixesFetchRegion,
        ProcXFixesSetGCClipRegion,
        ProcXFixesSetWindowShapeRegion,
        ProcXFixesSetPictureClipRegion,
        ProcXFixesSetCursorName,
        ProcXFixesGetCursorName,
        ProcXFixesGetCursorImageAndName,
        ProcXFixesChangeCursor, ProcXFixesChangeCursorByName,
/*************** Version 3 ******************/
        ProcXFixesExpandRegion,
/*************** Version 4 ****************/
        ProcXFixesHideCursor, ProcXFixesShowCursor,
/*************** Version 5 ****************/
ProcXFixesCreatePointerBarrier, ProcXFixesDestroyPointerBarrier,};

static int
ProcXFixesDispatch(ClientPtr client)
{
    REQUEST(xXFixesReq);
    XFixesClientPtr pXFixesClient = GetXFixesClient(client);

    if (pXFixesClient->major_version >= NUM_VERSION_REQUESTS)
        return BadRequest;
    if (stuff->xfixesReqType > version_requests[pXFixesClient->major_version])
        return BadRequest;
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int
SProcXFixesQueryVersion(ClientPtr client)
{
    REQUEST(xXFixesQueryVersionReq);

    swaps(&stuff->length);
    swapl(&stuff->majorVersion);
    swapl(&stuff->minorVersion);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

static int (*SProcXFixesVector[XFixesNumberRequests]) (ClientPtr) = {
/*************** Version 1 ******************/
    SProcXFixesQueryVersion,
        SProcXFixesChangeSaveSet,
        SProcXFixesSelectSelectionInput,
        SProcXFixesSelectCursorInput, SProcXFixesGetCursorImage,
/*************** Version 2 ******************/
        SProcXFixesCreateRegion,
        SProcXFixesCreateRegionFromBitmap,
        SProcXFixesCreateRegionFromWindow,
        SProcXFixesCreateRegionFromGC,
        SProcXFixesCreateRegionFromPicture,
        SProcXFixesDestroyRegion,
        SProcXFixesSetRegion,
        SProcXFixesCopyRegion,
        SProcXFixesCombineRegion,
        SProcXFixesCombineRegion,
        SProcXFixesCombineRegion,
        SProcXFixesInvertRegion,
        SProcXFixesTranslateRegion,
        SProcXFixesRegionExtents,
        SProcXFixesFetchRegion,
        SProcXFixesSetGCClipRegion,
        SProcXFixesSetWindowShapeRegion,
        SProcXFixesSetPictureClipRegion,
        SProcXFixesSetCursorName,
        SProcXFixesGetCursorName,
        SProcXFixesGetCursorImageAndName,
        SProcXFixesChangeCursor, SProcXFixesChangeCursorByName,
/*************** Version 3 ******************/
        SProcXFixesExpandRegion,
/*************** Version 4 ****************/
        SProcXFixesHideCursor, SProcXFixesShowCursor,
/*************** Version 5 ****************/
SProcXFixesCreatePointerBarrier, SProcXFixesDestroyPointerBarrier,};

static int
SProcXFixesDispatch(ClientPtr client)
{
    REQUEST(xXFixesReq);
    if (stuff->xfixesReqType >= XFixesNumberRequests)
        return BadRequest;
    return (*SProcXFixesVector[stuff->xfixesReqType]) (client);
}

static void
XFixesClientCallback(CallbackListPtr *list, void *closure, void *data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
    ClientPtr pClient = clientinfo->client;
    XFixesClientPtr pXFixesClient = GetXFixesClient(pClient);

    pXFixesClient->major_version = 0;
    pXFixesClient->minor_version = 0;
}

 /*ARGSUSED*/ static void
XFixesResetProc(ExtensionEntry * extEntry)
{
    DeleteCallback(&ClientStateCallback, XFixesClientCallback, 0);
}

void
XFixesExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey
        (&XFixesClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(XFixesClientRec)))
        return;
    if (!AddCallback(&ClientStateCallback, XFixesClientCallback, 0))
        return;

    if (XFixesSelectionInit() && XFixesCursorInit() && XFixesRegionInit() &&
        (extEntry = AddExtension(XFIXES_NAME, XFixesNumberEvents,
                                 XFixesNumberErrors,
                                 ProcXFixesDispatch, SProcXFixesDispatch,
                                 XFixesResetProc, StandardMinorOpcode)) != 0) {
        XFixesReqCode = (unsigned char) extEntry->base;
        XFixesEventBase = extEntry->eventBase;
        XFixesErrorBase = extEntry->errorBase;
        EventSwapVector[XFixesEventBase + XFixesSelectionNotify] =
            (EventSwapPtr) SXFixesSelectionNotifyEvent;
        EventSwapVector[XFixesEventBase + XFixesCursorNotify] =
            (EventSwapPtr) SXFixesCursorNotifyEvent;
        SetResourceTypeErrorValue(RegionResType, XFixesErrorBase + BadRegion);
        SetResourceTypeErrorValue(PointerBarrierType,
                                  XFixesErrorBase + BadBarrier);
    }
}

#ifdef PANORAMIX

int (*PanoramiXSaveXFixesVector[XFixesNumberRequests]) (ClientPtr);

void
PanoramiXFixesInit(void)
{
    int i;

    for (i = 0; i < XFixesNumberRequests; i++)
        PanoramiXSaveXFixesVector[i] = ProcXFixesVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcXFixesVector[X_XFixesSetGCClipRegion] = PanoramiXFixesSetGCClipRegion;
    ProcXFixesVector[X_XFixesSetWindowShapeRegion] =
        PanoramiXFixesSetWindowShapeRegion;
    ProcXFixesVector[X_XFixesSetPictureClipRegion] =
        PanoramiXFixesSetPictureClipRegion;
}

void
PanoramiXFixesReset(void)
{
    int i;

    for (i = 0; i < XFixesNumberRequests; i++)
        ProcXFixesVector[i] = PanoramiXSaveXFixesVector[i];
}

#endif
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d216 1
a216 1
XFixesClientCallback(CallbackListPtr *list, pointer closure, pointer data)
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d51 1
d65 5
a69 1
    xXFixesQueryVersionReply rep;
a73 4
    memset(&rep, 0, sizeof(xXFixesQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d77 1
a77 1
                        SERVER_XFIXES_MAJOR_VERSION) < 0) {
d94 1
a94 1
    WriteToClient(client, sizeof(xXFixesQueryVersionReply), (char *) &rep);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d52 3
a54 3
static unsigned char	XFixesReqCode;
int		XFixesEventBase;
int		XFixesErrorBase;
d57 1
d63 1
a63 1
    XFixesClientPtr pXFixesClient = GetXFixesClient (client);
d65 1
a65 1
    register int n;
d75 7
a81 6
                        SERVER_XFIXES_MAJOR_VERSION, SERVER_XFIXES_MAJOR_VERSION) < 0)
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else {
	rep.majorVersion = SERVER_XFIXES_MAJOR_VERSION;
d88 4
a91 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
d93 1
a93 1
    WriteToClient(client, sizeof(xXFixesQueryVersionReply), (char *)&rep);
d99 6
a104 6
    X_XFixesQueryVersion,	    /* before client sends QueryVersion */
    X_XFixesGetCursorImage,	    /* Version 1 */
    X_XFixesChangeCursorByName,	    /* Version 2 */
    X_XFixesExpandRegion,	    /* Version 3 */
    X_XFixesShowCursor,		    /* Version 4 */
    X_XFixesDestroyPointerBarrier,  /* Version 5 */
d108 2
a109 2
    
int	(*ProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
d112 3
a114 4
    ProcXFixesChangeSaveSet,
    ProcXFixesSelectSelectionInput,
    ProcXFixesSelectCursorInput,
    ProcXFixesGetCursorImage,
d116 22
a137 23
    ProcXFixesCreateRegion,
    ProcXFixesCreateRegionFromBitmap,
    ProcXFixesCreateRegionFromWindow,
    ProcXFixesCreateRegionFromGC,
    ProcXFixesCreateRegionFromPicture,
    ProcXFixesDestroyRegion,
    ProcXFixesSetRegion,
    ProcXFixesCopyRegion,
    ProcXFixesCombineRegion,
    ProcXFixesCombineRegion,
    ProcXFixesCombineRegion,
    ProcXFixesInvertRegion,
    ProcXFixesTranslateRegion,
    ProcXFixesRegionExtents,
    ProcXFixesFetchRegion,
    ProcXFixesSetGCClipRegion,
    ProcXFixesSetWindowShapeRegion,
    ProcXFixesSetPictureClipRegion,
    ProcXFixesSetCursorName,
    ProcXFixesGetCursorName,
    ProcXFixesGetCursorImageAndName,
    ProcXFixesChangeCursor,
    ProcXFixesChangeCursorByName,
d139 1
a139 1
    ProcXFixesExpandRegion,
d141 1
a141 2
    ProcXFixesHideCursor,
    ProcXFixesShowCursor,
d143 1
a143 3
    ProcXFixesCreatePointerBarrier,
    ProcXFixesDestroyPointerBarrier,
};
d146 1
a146 1
ProcXFixesDispatch (ClientPtr client)
d149 1
a149 1
    XFixesClientPtr pXFixesClient = GetXFixesClient (client);
d152 1
a152 1
	return BadRequest;
d154 1
a154 1
	return BadRequest;
a160 1
    register int n;
d163 3
a165 3
    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
d169 1
a169 1
static int (*SProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
d172 3
a174 4
    SProcXFixesChangeSaveSet,
    SProcXFixesSelectSelectionInput,
    SProcXFixesSelectCursorInput,
    SProcXFixesGetCursorImage,
d176 22
a197 23
    SProcXFixesCreateRegion,
    SProcXFixesCreateRegionFromBitmap,
    SProcXFixesCreateRegionFromWindow,
    SProcXFixesCreateRegionFromGC,
    SProcXFixesCreateRegionFromPicture,
    SProcXFixesDestroyRegion,
    SProcXFixesSetRegion,
    SProcXFixesCopyRegion,
    SProcXFixesCombineRegion,
    SProcXFixesCombineRegion,
    SProcXFixesCombineRegion,
    SProcXFixesInvertRegion,
    SProcXFixesTranslateRegion,
    SProcXFixesRegionExtents,
    SProcXFixesFetchRegion,
    SProcXFixesSetGCClipRegion,
    SProcXFixesSetWindowShapeRegion,
    SProcXFixesSetPictureClipRegion,
    SProcXFixesSetCursorName,
    SProcXFixesGetCursorName,
    SProcXFixesGetCursorImageAndName,
    SProcXFixesChangeCursor,
    SProcXFixesChangeCursorByName,
d199 1
a199 1
    SProcXFixesExpandRegion,
d201 1
a201 2
    SProcXFixesHideCursor,
    SProcXFixesShowCursor,
d203 1
a203 3
    SProcXFixesCreatePointerBarrier,
    SProcXFixesDestroyPointerBarrier,
};
d206 1
a206 1
SProcXFixesDispatch (ClientPtr client)
d210 1
a210 1
	return BadRequest;
d215 5
a219 7
XFixesClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    XFixesClientPtr	pXFixesClient = GetXFixesClient (pClient);
d225 2
a226 3
/*ARGSUSED*/
static void
XFixesResetProc (ExtensionEntry *extEntry)
d228 1
a228 1
    DeleteCallback (&ClientStateCallback, XFixesClientCallback, 0);
d236 21
a256 21
    if (!dixRegisterPrivateKey(&XFixesClientPrivateKeyRec, PRIVATE_CLIENT, sizeof (XFixesClientRec)))
	return;
    if (!AddCallback (&ClientStateCallback, XFixesClientCallback, 0))
	return;

    if (XFixesSelectionInit() && XFixesCursorInit () && XFixesRegionInit () &&
	(extEntry = AddExtension(XFIXES_NAME, XFixesNumberEvents, 
				 XFixesNumberErrors,
				 ProcXFixesDispatch, SProcXFixesDispatch,
				 XFixesResetProc, StandardMinorOpcode)) != 0)
    {
	XFixesReqCode = (unsigned char)extEntry->base;
	XFixesEventBase = extEntry->eventBase;
	XFixesErrorBase = extEntry->errorBase;
	EventSwapVector[XFixesEventBase + XFixesSelectionNotify] =
	    (EventSwapPtr) SXFixesSelectionNotifyEvent;
	EventSwapVector[XFixesEventBase + XFixesCursorNotify] =
	    (EventSwapPtr) SXFixesCursorNotifyEvent;
	SetResourceTypeErrorValue(RegionResType, XFixesErrorBase + BadRegion);
	SetResourceTypeErrorValue(PointerBarrierType,
				  XFixesErrorBase + BadBarrier);
d262 1
a262 1
int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);
d265 1
a265 1
PanoramiXFixesInit (void)
d270 1
a270 1
	PanoramiXSaveXFixesVector[i] = ProcXFixesVector[i];
d275 4
a278 2
    ProcXFixesVector[X_XFixesSetWindowShapeRegion] = PanoramiXFixesSetWindowShapeRegion;
    ProcXFixesVector[X_XFixesSetPictureClipRegion] = PanoramiXFixesSetPictureClipRegion;
d282 1
a282 1
PanoramiXFixesReset (void)
d287 1
a287 1
	ProcXFixesVector[i] = PanoramiXSaveXFixesVector[i];
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 2
a3 1
 * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
a50 4
/*
 * Must use these instead of the constants from xfixeswire.h.  They advertise
 * what we implement, not what the protocol headers define.
 */
d72 4
a75 1
    if (stuff->majorVersion < SERVER_XFIXES_MAJOR_VERSION) {
d80 1
a80 5
	if (stuff->majorVersion == SERVER_XFIXES_MAJOR_VERSION &&
	    stuff->minorVersion < SERVER_XFIXES_MINOR_VERSION)
	    rep.minorVersion = stuff->minorVersion;
	else
	    rep.minorVersion = SERVER_XFIXES_MINOR_VERSION;
d82 1
d97 6
a102 5
    X_XFixesQueryVersion,	/* before client sends QueryVersion */
    X_XFixesGetCursorImage,	/* Version 1 */
    X_XFixesChangeCursorByName,	/* Version 2 */
    X_XFixesExpandRegion,	/* Version 3 */
    X_XFixesShowCursor,	        /* Version 4 */
d143 3
d209 3
d267 2
d271 30
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d59 2
a60 2
static int XFixesClientPrivateKeyIndex;
static DevPrivateKey XFixesClientPrivateKey = &XFixesClientPrivateKeyIndex;
d95 1
a95 1
    return(client->noClientException);
d244 1
a244 1
    if (!dixRequestPrivate(XFixesClientPrivateKey, sizeof (XFixesClientRec)))
d262 1
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2006 Sun Microsystems
d4 10
a13 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Sun Microsystems not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Sun Microsystems makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d15 7
a21 7
 * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d49 1
a49 1

a53 2
#define SERVER_XFIXES_MAJOR 4
#define SERVER_XFIXES_MINOR 0
d71 1
d75 1
a75 1
    if (stuff->majorVersion < SERVER_XFIXES_MAJOR) {
d79 3
a81 3
	rep.majorVersion = SERVER_XFIXES_MAJOR;
	if (stuff->majorVersion == SERVER_XFIXES_MAJOR && 
	    stuff->minorVersion < SERVER_XFIXES_MINOR)
d84 1
a84 1
	    rep.minorVersion = SERVER_XFIXES_MINOR;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d59 3
a61 1
static DevPrivateKey XFixesClientPrivateKey = &XFixesClientPrivateKey;
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d56 1
a56 1
unsigned char	XFixesReqCode;
d59 1
a59 1
int		XFixesClientPrivateIndex;
d170 1
a170 1
int	(*SProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
d242 1
a242 3
    XFixesClientPrivateIndex = AllocateClientPrivateIndex ();
    if (!AllocateClientPrivate (XFixesClientPrivateIndex, 
				sizeof (XFixesClientRec)))
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d58 1
a58 1
static unsigned char	XFixesReqCode;
d61 1
a61 1
static int	XFixesClientPrivateIndex;
d172 1
a172 1
static int (*SProcXFixesVector[XFixesNumberRequests])(ClientPtr) = {
@

